.........................................Table Of Contents...............................................................
1. Platform specific tips <URL:#tn=1. Platform specific tips>
    1.1 Windows <URL:#tn=    1.1 Windows>
        1.1.1 ctrl-v now working <URL:#tn=        1.1.1 ctrl-v now working>
        1.1.2 ctrl-a not working <URL:#tn=        1.1.2 ctrl-a not working>
        1.1.3 <URL:#tn=        1.1.3>
    1.2 Linux <URL:#tn=    1.2 Linux>
    1.3 Mac <URL:#tn=    1.3 Mac>
        1.3.1 SAP MBP 2018 <URL:#tn=        1.3.1 SAP MBP 2018>
            1.3.1.1  install mvim <URL:#tn=            1.3.1.1  install mvim>
            1.3.1.2 enable gui vim <URL:#tn=            1.3.1.2 enable gui vim>
            1.3.1.3 <URL:#tn=            1.3.1.3>
        1.3.2 common mac VIM issues <URL:#tn=        1.3.2 common mac VIM issues>
            1.3.2.1 ugly colors in terminal <URL:#tn=            1.3.2.1 ugly colors in terminal>
            1.3.2.2 <URL:#tn=            1.3.2.2>
        1.3.3 <URL:#tn=        1.3.3>
    1.4 <URL:#tn=    1.4>
2. common tasks <URL:#tn=2. common tasks>
    2.1. set line numbers <URL:#tn=    2.1. set line numbers>
    2.2 edit source code and setting to see syntax <URL:#tn=    2.2 edit source code and setting to see syntax>
    2.3 file operations <URL:#tn=    2.3 file operations>
        2.3.1 save a copy of current file <URL:#tn=        2.3.1 save a copy of current file>
        2.3.2 rename current file <URL:#tn=        2.3.2 rename current file>
    2.4 <URL:#tn=    2.4>
3. search and replace. <URL:#tn=3. search and replace.>
	3.1 basics <URL:#tn=	3.1 basics>
	3.2 advanced <URL:#tn=	3.2 advanced>
	3.1 simple (current line) <URL:#tn=	3.1 simple (current line)>
	3.2 replace in range of lines <URL:#tn=	3.2 replace in range of lines>
	3.3 . for current line and $ for last: <URL:#tn=	3.3 . for current line and $ for last:>
	3.4 replace for the whole file scope. <URL:#tn=	3.4 replace for the whole file scope.>
	3.5 spatial replace <URL:#tn=	3.5 spatial replace>
	3.6 global replace <URL:#tn=	3.6 global replace>
	3.7 advanced replaces <URL:#tn=	3.7 advanced replaces>
	3.8 matching () or {} <URL:#tn=	3.8 matching () or {}>
	3.9 search history <URL:#tn=	3.9 search history>
	3.10 Search and replace tip 31 <URL:#tn=	3.10 Search and replace tip 31>
		3.10.1 Use the :substitute command to search for a text pattern, and replace it with a text string. <URL:#tn=		3.10.1 Use the :substitute command to search for a text pattern, and replace it with a text string.>
		3.10.2 Search range: <URL:#tn=		3.10.2 Search range:>
		3.10.3 When searching: <URL:#tn=		3.10.3 When searching:>
		3.10.4 When replacing: <URL:#tn=		3.10.4 When replacing:>
		3.10.5 You can use other delimiters with substitute: <URL:#tn=		3.10.5 You can use other delimiters with substitute:>
		3.10.6 Save typing by using \zs and \ze to set the start and end of a pattern. <URL:#tn=		3.10.6 Save typing by using \zs and \ze to set the start and end of a pattern.>
		3.10.7 Using registers <URL:#tn=		3.10.7 Using registers>
		3.10.8 Special cases <URL:#tn=		3.10.8 Special cases>
	3.11 Advanced Examples <URL:#tn=	3.11 Advanced Examples>
		3.11.1 Change tv[1] to tv_1 <URL:#tn=		3.11.1 Change tv[1] to tv_1>
	3.12 Vim search and replace, with increment <URL:#tn=	3.12 Vim search and replace, with increment>
	3.13 vim search for a pattern followed by another pattern and set cursor in second pattern location <URL:#tn=	3.13 vim search for a pattern followed by another pattern and set cursor in second pattern location>
	    3.13.1 https://stackoverflow.com/questions/66658895/vim-search-first-match-after-match-of-another-pattern <URL:#tn=	    3.13.1 https://stackoverflow.com/questions/66658895/vim-search-first-match-after-match-of-another-pattern>
	    3.13.2 <URL:#tn=	    3.13.2>
	3.14 <URL:#tn=	3.14>
4. 	Advanced search. <URL:#tn=4. 	Advanced search.>
	4.1 search multiple buffers. <URL:#tn=	4.1 search multiple buffers.>
	4.2 Print a list of lines that match a pattern in current open buffers: <URL:#tn=	4.2 Print a list of lines that match a pattern in current open buffers:>
	4.3 ignore case mode (useful for searches and replacements) <URL:#tn=	4.3 ignore case mode (useful for searches and replacements)>
	4.4 search for non-ascii chars. <URL:#tn=	4.4 search for non-ascii chars.>
		4.4.1 Basic <URL:#tn=		4.4.1 Basic>
		4.4.2 Advanced <URL:#tn=		4.4.2 Advanced>
	4.5 Search in range (block) <URL:#tn=	4.5 Search in range (block)>
	4.6 Search across multiple lines <URL:#tn=	4.6 Search across multiple lines>
		4.6.1 http://vim.wikia.com/wiki/VimTip242 <URL:#tn=		4.6.1 http://vim.wikia.com/wiki/VimTip242>
			4.6.1.1 Example <URL:#tn=			4.6.1.1 Example>
	4.6.2 Update version 12/01/2010 <URL:#tn=	4.6.2 Update version 12/01/2010>
		4.6.2.1 Patterns including end-of-line <URL:#tn=		4.6.2.1 Patterns including end-of-line>
		4.6.2.2 Searching for multiline HTML comments <URL:#tn=		4.6.2.2 Searching for multiline HTML comments>
		4.6.2.3 Searching for words over multiple lines <URL:#tn=		4.6.2.3 Searching for words over multiple lines>
		4.6.2.4 See also <URL:#tn=		4.6.2.4 See also>
		4.6.2.5 References <URL:#tn=		4.6.2.5 References>
		4.6.2.6 Comments <URL:#tn=		4.6.2.6 Comments>
	4.6.3 <URL:#tn=	4.6.3>
5.  Basic VI stuff <URL:#tn=5.  Basic VI stuff>
	5.1. repeat last change. <URL:#tn=	5.1. repeat last change.>
	5.2 buffers <URL:#tn=	5.2 buffers>
	5.4 history <URL:#tn=	5.4 history>
6. Edit multiple files. <URL:#tn=6. Edit multiple files.>
	6.1 switch to editing new file. <URL:#tn=	6.1 switch to editing new file.>
	6.2 determine current file. <URL:#tn=	6.2 determine current file.>
	6.3 open a list of files. <URL:#tn=	6.3 open a list of files.>
	6.4 list buffers <URL:#tn=	6.4 list buffers>
	    6.4.1 simple <URL:#tn=	    6.4.1 simple>
	    6.4.2 list full pathnames of all open buffers <URL:#tn=	    6.4.2 list full pathnames of all open buffers>
	    6.4.3 <URL:#tn=	    6.4.3>
	6.5 file navigation (without plugins) <URL:#tn=	6.5 file navigation (without plugins)>
	6.6 Open from command line <URL:#tn=	6.6 Open from command line>
		6.6.1 Use bash expansion <URL:#tn=		6.6.1 Use bash expansion>
		6.6.2 Nuber file buffers according to date <URL:#tn=		6.6.2 Nuber file buffers according to date>
	6.7 <URL:#tn=	6.7>
7. Multiple windows. <URL:#tn=7. Multiple windows.>
	7.1 create a second window. <URL:#tn=	7.1 create a second window.>
		7.1.1 horizontal <URL:#tn=		7.1.1 horizontal>
		7.1.2 Vertical <URL:#tn=		7.1.2 Vertical>
		7.1.3 New window <URL:#tn=		7.1.3 New window>
		7.1.4 Close window <URL:#tn=		7.1.4 Close window>
		7.1.5 Leave only one window open, close all windows but current <URL:#tn=		7.1.5 Leave only one window open, close all windows but current>
		7.2 move between windows. <URL:#tn=		7.2 move between windows.>
	7.3 close window. <URL:#tn=	7.3 close window.>
	7.4 leave only this window open, closing all others. <URL:#tn=	7.4 leave only this window open, closing all others.>
	7.5 create a window for a new file. <URL:#tn=	7.5 create a window for a new file.>
	7.6 close all windows ( buffers). <URL:#tn=	7.6 close all windows ( buffers).>
	7.7 Move windoes around <URL:#tn=	7.7 Move windoes around>
	7.7 Window resizing <URL:#tn=	7.7 Window resizing>
8. It is possible to use cscope from vim. <URL:#tn=8. It is possible to use cscope from vim.>
	8.1 <URL:#tn=	8.1>
			8.2 last step <URL:#tn=			8.2 last step>
9. Auto complete <URL:#tn=9. Auto complete>
	9.1 use ctrl+n to auto complete forward words and ctrl+s to auto complete backword. <URL:#tn=	9.1 use ctrl+n to auto complete forward words and ctrl+s to auto complete backword.>
	9.2 use ctrl+p to visually auto complete backward and ctr+n to visually auto complete forward. <URL:#tn=	9.2 use ctrl+p to visually auto complete backward and ctr+n to visually auto complete forward.>
	9.3 use ctrlX^d (hold ctrl, press X then d) to auto complete from syntax defenition. <URL:#tn=	9.3 use ctrlX^d (hold ctrl, press X then d) to auto complete from syntax defenition.>
	9.4  options <URL:#tn=	9.4  options>
	9.5 from dictionary <URL:#tn=	9.5 from dictionary>
		9.5.1 Add dictionary <URL:#tn=		9.5.1 Add dictionary>
		9.5.2 Complete from dictionary <URL:#tn=		9.5.2 Complete from dictionary>
		9.5.3 set Completion options <URL:#tn=		9.5.3 set Completion options>
		9.5.4 <URL:#tn=		9.5.4>
10. Execute shell commands. <URL:#tn=10. Execute shell commands.>
11. Working with tag libs. <URL:#tn=11. Working with tag libs.>
	11.1 Download the taglist.zip file and unzip the files to the $HOME/.vim or the <URL:#tn=	11.1 Download the taglist.zip file and unzip the files to the $HOME/.vim or the>
	11.2 Change to the $HOME/.vim/doc or $HOME/vimfiles/doc or $VIM/doc/vimfiles <URL:#tn=	11.2 Change to the $HOME/.vim/doc or $HOME/vimfiles/doc or $VIM/doc/vimfiles>
	11.3 If the exuberant ctags utility is not present in your PATH, then set the <URL:#tn=	11.3 If the exuberant ctags utility is not present in your PATH, then set the>
		    11.3.1  Common issues <URL:#tn=		    11.3.1  Common issues>
		    11.3.2 <URL:#tn=		    11.3.2>
	11.4 If you are running a terminal/console version of Vim and the terminal <URL:#tn=	11.4 If you are running a terminal/console version of Vim and the terminal>
	11.5 Restart Vim. <URL:#tn=	11.5 Restart Vim.>
	11.6 You can now use the ":TlistToggle" command to open/close the taglist <URL:#tn=	11.6 You can now use the ":TlistToggle" command to open/close the taglist>
	11.7 exuberent ctags MAC <URL:#tn=	11.7 exuberent ctags MAC>
	11.8 <URL:#tn=	11.8>
12. Developer commands. <URL:#tn=12. Developer commands.>
	12.1 Go to definition of word under cursor	gd <URL:#tn=	12.1 Go to definition of word under cursor	gd>
	12.2 Find matching bracket, brace, #if, #endif	% <URL:#tn=	12.2 Find matching bracket, brace, #if, #endif	%>
	12.3 Do a grep	:grep foo *.c <URL:#tn=	12.3 Do a grep	:grep foo *.c>
	12.4 Get a file (eg. an #include file) whose name is under cursor	gf <URL:#tn=	12.4 Get a file (eg. an #include file) whose name is under cursor	gf>
	12.5 Auto complete (in insert mode) - match forwards		Ctrl+X Ctrl+N <URL:#tn=	12.5 Auto complete (in insert mode) - match forwards		Ctrl+X Ctrl+N>
		12.5.1 Select an item in vim autocomplete list without inserting line break <URL:#tn=		12.5.1 Select an item in vim autocomplete list without inserting line break>
		12.5.2 <URL:#tn=		12.5.2>
	12.6 <URL:#tn=	12.6>
13. Yanking (and deleting, replace 'y' with 'd') <URL:#tn=13. Yanking (and deleting, replace 'y' with 'd')>
14. More search and replace <URL:#tn=14. More search and replace>
15. Shell and filter commands <URL:#tn=15. Shell and filter commands>
	15.1 Use filter commands to process text <URL:#tn=	15.1 Use filter commands to process text>
16. Spellcheck <URL:#tn=16. Spellcheck>
    16.1  my Spellcheck config <URL:#tn=    16.1  my Spellcheck config>
    16.2 Spellcheck Tutorials <URL:#tn=    16.2 Spellcheck Tutorials>
        16.2.1 https://www.linux.com/training-tutorials/using-spell-checking-vim/ <URL:#tn=        16.2.1 https://www.linux.com/training-tutorials/using-spell-checking-vim/>
        16.2.2 <URL:#tn=        16.2.2>
    16.3 Spellcheck languages <URL:#tn=    16.3 Spellcheck languages>
        16.3.1 http://ftp.vim.org/vim/runtime/spell/ <URL:#tn=        16.3.1 http://ftp.vim.org/vim/runtime/spell/>
        16.3.2 https://github.com/nickjj/dotfiles/blob/master/.vimrc <URL:#tn=        16.3.2 https://github.com/nickjj/dotfiles/blob/master/.vimrc>
        16.3.3 <URL:#tn=        16.3.3>
    16.4 <URL:#tn=    16.4>
17. Visual mode <URL:#tn=17. Visual mode>
	17.1 visual mode intro. <URL:#tn=	17.1 visual mode intro.>
	17.2. Other ways of establishing a visual block <URL:#tn=	17.2. Other ways of establishing a visual block>
	17.3.  Here is an example, from C source code. Say you have the following code, and you want to select the code inside the inner { ... } characters. Put the cursor in the middle (eg. on CON_EDITING) and type "viB" and the "inner block" (text in bold) will be highlighted. <URL:#tn=	17.3.  Here is an example, from C source code. Say you have the following code, and you want to select the code inside the inner { ... } characters. Put the cursor in the middle (eg. on CON_EDITING) and type "viB" and the "inner block" (text in bold) will be highlighted.>
	17.4 Visual mode commands <URL:#tn=	17.4 Visual mode commands>
		17.5 Visual mode insert mode. <URL:#tn=		17.5 Visual mode insert mode.>
			17.5.1 I example: <URL:#tn=			17.5.1 I example:>
			17.5.2 Block select <URL:#tn=			17.5.2 Block select>
			17.6 Visualize a number of lines forwards or backwards. <URL:#tn=			17.6 Visualize a number of lines forwards or backwards.>
18. Marking your work <URL:#tn=18. Marking your work>
19. PLUGINS, Scripts, tags: plugins, scripts, extensions, colorschemes <URL:#tn=19. PLUGINS, Scripts, tags: plugins, scripts, extensions, colorschemes>
    19.0 list active plugins , tags: list active plugins <URL:#tn=    19.0 list active plugins , tags: list active plugins>
        19.0.1   list active plugins chatgpt <URL:#tn=        19.0.1   list active plugins chatgpt>
            19.0.1.1    03/07/23 17:31:09  plugins list <URL:#tn=            19.0.1.1    03/07/23 17:31:09  plugins list>
            19.0.1.2 <URL:#tn=            19.0.1.2>
        19.0.2 <URL:#tn=        19.0.2>
	19.1 bufexplorer <URL:#tn=	19.1 bufexplorer>
	19.2 csupport (C/CPP plugin) <URL:#tn=	19.2 csupport (C/CPP plugin)>
		19.2.1 To get help <URL:#tn=		19.2.1 To get help>
		19.2.2 Shortcuts <URL:#tn=		19.2.2 Shortcuts>
			19.2.2.1 Comments <URL:#tn=			19.2.2.1 Comments>
			19.2.2.2 Statements <URL:#tn=			19.2.2.2 Statements>
			19.2.2.3 Preprocessor <URL:#tn=			19.2.2.3 Preprocessor>
			19.2.2.4 Idioms <URL:#tn=			19.2.2.4 Idioms>
			19.2.2.5 Snippets <URL:#tn=			19.2.2.5 Snippets>
			19.2.2.6 C++ <URL:#tn=			19.2.2.6 C++>
			19.2.2.7 Run <URL:#tn=			19.2.2.7 Run>
	19.3. Python (python.vim) <URL:#tn=	19.3. Python (python.vim)>
	19.4 Mini Buffer Explorer (minibufexpl.vim) <URL:#tn=	19.4 Mini Buffer Explorer (minibufexpl.vim)>
	19.5 C reference (CRefVim) <URL:#tn=	19.5 C reference (CRefVim)>
		19.5.1. Usage <URL:#tn=		19.5.1. Usage>
	19.5 perl plugin ( perlsupport) <URL:#tn=	19.5 perl plugin ( perlsupport)>
		19.5.1 h perlsupport <URL:#tn=		19.5.1 h perlsupport>
		19.5.2 Usefull shortcuts <URL:#tn=		19.5.2 Usefull shortcuts>
	19.6 Latex plugin (latex suite). <URL:#tn=	19.6 Latex plugin (latex suite).>
		19.6.1. <URL:#tn=		19.6.1.>
		19.6.2. Help. <URL:#tn=		19.6.2. Help.>
	19.7 TagExplorer <URL:#tn=	19.7 TagExplorer>
	19.8 SpellChecker <URL:#tn=	19.8 SpellChecker>
		19.8.1 help <URL:#tn=		19.8.1 help>
		19.8.2 basics <URL:#tn=		19.8.2 basics>
	19.9 cppomnicomplete plugin. <URL:#tn=	19.9 cppomnicomplete plugin.>
		19.9.1 First steps <URL:#tn=		19.9.1 First steps>
		19.9.2 Usage <URL:#tn=		19.9.2 Usage>
	19.10 Bash plugin <URL:#tn=	19.10 Bash plugin>
	19.11 show Marks plugin: <URL:#tn=	19.11 show Marks plugin:>
	19.12 UTL, URL-based hyperlinking <URL:#tn=	19.12 UTL, URL-based hyperlinking>
		19.12.1. Ver2.0 and below <URL:#tn=		19.12.1. Ver2.0 and below>
			 19.12.2. Hit \gu on the live examples given there <URL:#tn=			 19.12.2. Hit \gu on the live examples given there>
		19.12.3 More examples <URL:#tn=		19.12.3 More examples>
		19.12.4 Ver 3.x <URL:#tn=		19.12.4 Ver 3.x>
			19.12.4.1 aaa <URL:#tn=			19.12.4.1 aaa>
			19.12.4.2 Suggested mappings <URL:#tn=			19.12.4.2 Suggested mappings>
	19.13 DrawIt, Draw ASCII diagrams. <URL:#tn=	19.13 DrawIt, Draw ASCII diagrams.>
		19.13.1 First steps <URL:#tn=		19.13.1 First steps>
		19.13.2 Usage <URL:#tn=		19.13.2 Usage>
		19.13.3. Commands <URL:#tn=		19.13.3. Commands>
	19.14 VisIncr, create columns of increasing numbers, dates, etc. <URL:#tn=	19.14 VisIncr, create columns of increasing numbers, dates, etc.>
	19.15 a.vim : Alternate Files quickly <URL:#tn=	19.15 a.vim : Alternate Files quickly>
	19.16 dbext.vim : Provides database access to 10 dbms (Oracle, Sybase, SQL Server, MySQL, DBI,...) <URL:#tn=	19.16 dbext.vim : Provides database access to 10 dbms (Oracle, Sybase, SQL Server, MySQL, DBI,...)>
		19.16.1 First steps <URL:#tn=		19.16.1 First steps>
		19.16.2 Tutorial <URL:#tn=		19.16.2 Tutorial>
		19.16.3 Connection Profiles <URL:#tn=		19.16.3 Connection Profiles>
		19.16.4 Object Completion <URL:#tn=		19.16.4 Object Completion>
		19.16.5 FileType Support <URL:#tn=		19.16.5 FileType Support>
		19.16.5 Additional Commands <URL:#tn=		19.16.5 Additional Commands>
	19.16 VJDE, java plugin <URL:#tn=	19.16 VJDE, java plugin>
		19.16.1 description: <URL:#tn=		19.16.1 description:>
	19.17 surround.vim : Delete/change/add parentheses/quotes/XML-tags/much more with ease <URL:#tn=	19.17 surround.vim : Delete/change/add parentheses/quotes/XML-tags/much more with ease>
		19.17.1 Description <URL:#tn=		19.17.1 Description>
		19.17.2 Install <URL:#tn=		19.17.2 Install>
	19.18 DirDiff <URL:#tn=	19.18 DirDiff>
		19.18.1 Description <URL:#tn=		19.18.1 Description>
		19.18.2 Install <URL:#tn=		19.18.2 Install>
		19.18.3 Usage <URL:#tn=		19.18.3 Usage>
		19.18.4 demo <URL:#tn=		19.18.4 demo>
		19.18.5 <URL:#tn=		19.18.5>
      19.18 VimCommander <URL:#tn=      19.18 VimCommander>
	19.18.1  List of Features: <URL:#tn=	19.18.1  List of Features:>
	19.18.2 VimCommander Keys <URL:#tn=	19.18.2 VimCommander Keys>
	19.19 Source explorer <URL:#tn=	19.19 Source explorer>
		19.19.1 Installation <URL:#tn=		19.19.1 Installation>
	19.20 Doxygen support <URL:#tn=	19.20 Doxygen support>
		19.20.1 Documentation <URL:#tn=		19.20.1 Documentation>
		19.20.2 Install <URL:#tn=		19.20.2 Install>
		19.20.3 Usage <URL:#tn=		19.20.3 Usage>
			19.20.3.1 GUI <URL:#tn=			19.20.3.1 GUI>
			19.20.3.2 Non GUI (xterm, eterm etc) <URL:#tn=			19.20.3.2 Non GUI (xterm, eterm etc)>
	19.21 LargeFile <URL:#tn=	19.21 LargeFile>
	19.22 CCtree  C Call-Tree Explorer - Source-code analysis, real-time display of code flow <URL:#tn=	19.22 CCtree  C Call-Tree Explorer - Source-code analysis, real-time display of code flow>
		19.22.1 Install <URL:#tn=		19.22.1 Install>
		19.22.2 Help <URL:#tn=		19.22.2 Help>
		19.22.3 Options <URL:#tn=		19.22.3 Options>
			19.22.3.1. Cscope Symbol Database~ <URL:#tn=			19.22.3.1. Cscope Symbol Database~>
			19.22.3.2. Call-tree Depth~ <URL:#tn=			19.22.3.2. Call-tree Depth~>
			19.22.3.3. Call-tree Minimum Visible Depth~ <URL:#tn=			19.22.3.3. Call-tree Minimum Visible Depth~>
			19.22.3.4. Call-tree window display~ <URL:#tn=			19.22.3.4. Call-tree window display~>
			19.22.3.4.1 Orientation~ <URL:#tn=			19.22.3.4.1 Orientation~>
			19.22.3.5 Direction~ <URL:#tn=			19.22.3.5 Direction~>
			19.22.3.5.1 Dimensions~ <URL:#tn=			19.22.3.5.1 Dimensions~>
			19.22.3.5.2 Horizontal Window Settings~ <URL:#tn=			19.22.3.5.2 Horizontal Window Settings~>
			19.22.3.5.2 Vertical Window Settings~ <URL:#tn=			19.22.3.5.2 Vertical Window Settings~>
			19.22.3.6 Call-tree display format~ <URL:#tn=			19.22.3.6 Call-tree display format~>
			19.22.3.7. Dynamic Call-tree highlighting~ <URL:#tn=			19.22.3.7. Dynamic Call-tree highlighting~>
			19.22.3.7.1 Syntax items~ <URL:#tn=			19.22.3.7.1 Syntax items~>
		19.22.4 Usage <URL:#tn=		19.22.4 Usage>
			19.22.4.1. Symbol database~ <URL:#tn=			19.22.4.1. Symbol database~>
			19.22.4.2. Exploring source-code~ <URL:#tn=			19.22.4.2. Exploring source-code~>
			19.22.4.4. Syntax Coloring~ <URL:#tn=			19.22.4.4. Syntax Coloring~>
	19.23 project.vim <URL:#tn=	19.23 project.vim>
		19.23.1 COMMANDS						    *project-invoking* <URL:#tn=		19.23.1 COMMANDS						    *project-invoking*>
		19.23.2 INHERITANCE						 *project-inheritance* <URL:#tn=		19.23.2 INHERITANCE						 *project-inheritance*>
		19.23.3 MAPPINGS						    *project-mappings* <URL:#tn=		19.23.3 MAPPINGS						    *project-mappings*>
		19.23.4 <URL:#tn=		19.23.4>
		19.23.5 ADDING MAPPINGS 				     *project-adding-mappings* <URL:#tn=		19.23.5 ADDING MAPPINGS 				     *project-adding-mappings*>
		19.23.6 PROJECT EXAMPLE FILE					     *project-example* <URL:#tn=		19.23.6 PROJECT EXAMPLE FILE					     *project-example*>
		19.23.7 TIPS ON USING PROJECT PLUGIN					*project-tips* <URL:#tn=		19.23.7 TIPS ON USING PROJECT PLUGIN					*project-tips*>
	19.24 surround.vim <URL:#tn=	19.24 surround.vim>
	19.25 NERD tree <URL:#tn=	19.25 NERD tree>
		19.25.1 Install <URL:#tn=		19.25.1 Install>
		19.25.2 Get help <URL:#tn=		19.25.2 Get help>
		19.25.3 Commands <URL:#tn=		19.25.3 Commands>
		19.25.4 Bookmarks <URL:#tn=		19.25.4 Bookmarks>
			19.25.4.1 The Bookmark Table                              *NERDTreeBookmarkTable* <URL:#tn=			19.25.4.1 The Bookmark Table                              *NERDTreeBookmarkTable*>
			19.25.4.2 Bookmark commands                            *NERDTreeBookmarkCommands* <URL:#tn=			19.25.4.2 Bookmark commands                            *NERDTreeBookmarkCommands*>
			19.25.4.3 Invalid Bookmarks                            *NERDTreeInvalidBookmarks* <URL:#tn=			19.25.4.3 Invalid Bookmarks                            *NERDTreeInvalidBookmarks*>
		19.25.5 NERD tree Mappings                                     *NERDTreeMappings* <URL:#tn=		19.25.5 NERD tree Mappings                                     *NERDTreeMappings*>
		19.25.6 <URL:#tn=		19.25.6>
	19.26 ANN: Vim for Outlook <URL:#tn=	19.26 ANN: Vim for Outlook>
		19.26.1 Issues on my env <URL:#tn=		19.26.1 Issues on my env>
		19.26.2 Install <URL:#tn=		19.26.2 Install>
		19.26.3 usage <URL:#tn=		19.26.3 usage>
	19.27 cscope.maps <URL:#tn=	19.27 cscope.maps>
		19.27.1 related - ‘egrep’ regular expression syntax <URL:#tn=		19.27.1 related - ‘egrep’ regular expression syntax>
	19.28 Vim Intellisense <URL:#tn=	19.28 Vim Intellisense>
		19.28.1 install <URL:#tn=		19.28.1 install>
		19.28.2 <URL:#tn=		19.28.2>
	19.29 supertab <URL:#tn=	19.29 supertab>
	19.30 session.vim : Extended session management for Vim <URL:#tn=	19.30 session.vim : Extended session management for Vim>
		19.30.1 short description <URL:#tn=		19.30.1 short description>
		19.30.2 Long description <URL:#tn=		19.30.2 Long description>
		19.30.3 <URL:#tn=		19.30.3>
	19.31 vim-addon-manager : manage and update plugins easily <URL:#tn=	19.31 vim-addon-manager : manage and update plugins easily>
	19.32 snipMate <URL:#tn=	19.32 snipMate>
		19.32.1 :h snipMate <URL:#tn=		19.32.1 :h snipMate>
		19.32.2 C snip <URL:#tn=		19.32.2 C snip>
		19.32.3 c++ snip <URL:#tn=		19.32.3 c++ snip>
		19.32.4 Java snips <URL:#tn=		19.32.4 Java snips>
		19.32.5 perl snip <URL:#tn=		19.32.5 perl snip>
		19.32.6 python snip <URL:#tn=		19.32.6 python snip>
		19.32.7 bash snip <URL:#tn=		19.32.7 bash snip>
		19.32.8 html snip <URL:#tn=		19.32.8 html snip>
		19.32.9 <URL:#tn=		19.32.9>
	19.33 stlrefvim : A C++ Standard Template Library reference manual <URL:#tn=	19.33 stlrefvim : A C++ Standard Template Library reference manual>
	19.34 Pathogen <URL:#tn=	19.34 Pathogen>
		19.34.1 http://www.vim.org/scripts/script.php?script_id=2332 <URL:#tn=		19.34.1 http://www.vim.org/scripts/script.php?script_id=2332>
		19.34.2 Using Vim with Pathogen <URL:#tn=		19.34.2 Using Vim with Pathogen>
		19.34.3 git repo <URL:#tn=		19.34.3 git repo>
			19.34.3.1 https://github.com/lambacck/vimconfig/blob/master/.gitmodules <URL:#tn=			19.34.3.1 https://github.com/lambacck/vimconfig/blob/master/.gitmodules>
			19.34.3.2 https://github.com/vim-scripts <URL:#tn=			19.34.3.2 https://github.com/vim-scripts>
		19.34.4 My examples <URL:#tn=		19.34.4 My examples>
			19.34.4.1 Linux <URL:#tn=			19.34.4.1 Linux>
			19.34.4.2 Windows <URL:#tn=			19.34.4.2 Windows>
			19.34.4.3 Cygwin <URL:#tn=			19.34.4.3 Cygwin>
			19.34.4.4 Mac <URL:#tn=			19.34.4.4 Mac>
			19.34.4.5 <URL:#tn=			19.34.4.5>
		19.34.5 <URL:#tn=		19.34.5>
	19.35 Gundo <URL:#tn=	19.35 Gundo>
	19.36 neocomplcach, obsolete use neocomplete instead <URL:#tn=	19.36 neocomplcach, obsolete use neocomplete instead>
	19.37 Ctrl-P <URL:#tn=	19.37 Ctrl-P>
		19.37.1 Basic Usage: <URL:#tn=		19.37.1 Basic Usage:>
		19.37.2 Once CtrlP is open: <URL:#tn=		19.37.2 Once CtrlP is open:>
		19.37.3 Basic Options: <URL:#tn=		19.37.3 Basic Options:>
		19.37.4 Get ctrlp.vim: <URL:#tn=		19.37.4 Get ctrlp.vim:>
		19.37.5 Issues <URL:#tn=		19.37.5 Issues>
			19.37.5.1 Can't find my file <URL:#tn=			19.37.5.1 Can't find my file>
			19.37.5.2 <URL:#tn=			19.37.5.2>
		19.37.6 <URL:#tn=		19.37.6>
	19.38  EasyMotion <URL:#tn=	19.38  EasyMotion>
		19.38.1  Introduction <URL:#tn=		19.38.1  Introduction>
		19.38.2 Install <URL:#tn=		19.38.2 Install>
		19.38.3 <URL:#tn=		19.38.3>
	19.39  https://github.com/Valloric/YouCompleteMe, YCM <URL:#tn=	19.39  https://github.com/Valloric/YouCompleteMe, YCM>
		19.39.1  Install <URL:#tn=		19.39.1  Install>
		19.39.2 languages support <URL:#tn=		19.39.2 languages support>
		19.39.3 <URL:#tn=		19.39.3>
	19.40 https://github.com/Lokaltog/powerline <URL:#tn=	19.40 https://github.com/Lokaltog/powerline>
	19.41  https://github.com/pthrasher/conqueterm-vim <URL:#tn=	19.41  https://github.com/pthrasher/conqueterm-vim>
	19.42 tagbar <URL:#tn=	19.42 tagbar>
	19.43 airling <URL:#tn=	19.43 airling>
	19.44 fugitive <URL:#tn=	19.44 fugitive>
	19.45  fzf, faster ctrlp <URL:#tn=	19.45  fzf, faster ctrlp>
	19.46  ag, quick recursive grep <URL:#tn=	19.46  ag, quick recursive grep>
	19.47 syntastic , on the fly syntax check for all languages <URL:#tn=	19.47 syntastic , on the fly syntax check for all languages>
	19.48  jsonpath <URL:#tn=	19.48  jsonpath>
	19.49  Table mode <URL:#tn=	19.49  Table mode>
	19.50  repeat.vim <URL:#tn=	19.50  repeat.vim>
	19.51  https://github.com/b4winckler/vim-angry <URL:#tn=	19.51  https://github.com/b4winckler/vim-angry>
	19.52  https://github.com/markonm/traces.vim <URL:#tn=	19.52  https://github.com/markonm/traces.vim>
	19.53  https://github.com/othree/html5.vim <URL:#tn=	19.53  https://github.com/othree/html5.vim>
	19.54  pack, native plugin manager since vim 8 <URL:#tn=	19.54  pack, native plugin manager since vim 8>
	    19.54.1  https://medium.com/@paulodiovani/installing-vim-8-plugins-with-the-native-pack-system-39b71c351fea <URL:#tn=	    19.54.1  https://medium.com/@paulodiovani/installing-vim-8-plugins-with-the-native-pack-system-39b71c351fea>
	    19.54.2 <URL:#tn=	    19.54.2>
	19.55  https://github.com/airblade/vim-gitgutter <URL:#tn=	19.55  https://github.com/airblade/vim-gitgutter>
	19.56 https://dev.to/hackingcpp/fantastic-and-lesser-known-vim-plugins-in-2022-12e6 <URL:#tn=	19.56 https://dev.to/hackingcpp/fantastic-and-lesser-known-vim-plugins-in-2022-12e6>
	    19.56.1 https://github.com/bounceme/poppy.vim <URL:#tn=	    19.56.1 https://github.com/bounceme/poppy.vim>
	    19.56.2 Cursorword <URL:#tn=	    19.56.2 Cursorword>
	    19.56.3 multiple cursors <URL:#tn=	    19.56.3 multiple cursors>
	    19.56.4 neodebug <URL:#tn=	    19.56.4 neodebug>
	    19.56.5 Cycle <URL:#tn=	    19.56.5 Cycle>
	    19.56.6 CamelCaseMotion <URL:#tn=	    19.56.6 CamelCaseMotion>
	    19.56.7 undotree <URL:#tn=	    19.56.7 undotree>
	19.57  ALE <URL:#tn=	19.57  ALE>
	19.58  braceless <URL:#tn=	19.58  braceless>
	19.59 <URL:#tn=	19.59>
20. Movement <URL:#tn=20. Movement>
21. recording commands. <URL:#tn=21. recording commands.>
	21.1 simple usage <URL:#tn=	21.1 simple usage>
	21.2 another suggestion <URL:#tn=	21.2 another suggestion>
	21.3 yet another suggestion <URL:#tn=	21.3 yet another suggestion>
	21.4 Modify recoreded macro <URL:#tn=	21.4 Modify recoreded macro>
22. Sessions. <URL:#tn=22. Sessions.>
	22.1 Save and Load sessions. <URL:#tn=	22.1 Save and Load sessions.>
	22.2  SESSIONS AND VIMINFO <URL:#tn=	22.2  SESSIONS AND VIMINFO>
	22.3 mkview <URL:#tn=	22.3 mkview>
	22.4 <URL:#tn=	22.4>
23. Working with tags. <URL:#tn=23. Working with tags.>
	23.1 set up tags. use ctags. <URL:#tn=	23.1 set up tags. use ctags.>
	23.2 jump to tags. <URL:#tn=	23.2 jump to tags.>
	23.3 Tag Stack. <URL:#tn=	23.3 Tag Stack.>
		23.3.1 jump to previous tag ctrl-T <URL:#tn=		23.3.1 jump to previous tag ctrl-T>
		23.3.2 :[count]po[p][!] Jump to [count] older entry in tag stack (default 1). <URL:#tn=		23.3.2 :[count]po[p][!] Jump to [count] older entry in tag stack (default 1).>
	23.4 Tag generating tools. <URL:#tn=	23.4 Tag generating tools.>
	23.5 Browsing programs with tags <URL:#tn=	23.5 Browsing programs with tags>
		23.5.1 How do I create a tags file? <URL:#tn=		23.5.1 How do I create a tags file?>
		23.5.2 How do I configure Vim to locate a tags file? <URL:#tn=		23.5.2 How do I configure Vim to locate a tags file?>
		23.5.3 How do I jump to a tag? <URL:#tn=		23.5.3 How do I jump to a tag?>
		23.5.4 How do I come back from a tag jump? <URL:#tn=		23.5.4 How do I come back from a tag jump?>
		23.5.5 How do I jump again to a previously jumped tag location? <URL:#tn=		23.5.5 How do I jump again to a previously jumped tag location?>
		23.5.6 How do browse through a list of multiple tag matches? <URL:#tn=		23.5.6 How do browse through a list of multiple tag matches?>
		  23.5.7 How do I preview a tag? <URL:#tn=		  23.5.7 How do I preview a tag?>
		23.5.8 How do I browse through the tag list in a preview window? <URL:#tn=		23.5.8 How do I browse through the tag list in a preview window?>
		  23.5.9 How do I start Vim to start editing a file at a given tag match? <URL:#tn=		  23.5.9 How do I start Vim to start editing a file at a given tag match?>
		  23.5.10 How do I list all the tags matching a search pattern? <URL:#tn=		  23.5.10 How do I list all the tags matching a search pattern?>
		 23.5.11 What options are available to control how Vim handles the tags file? <URL:#tn=		 23.5.11 What options are available to control how Vim handles the tags file?>
		23.5.12 Is there a workaround to make the Ctrl-] key not to be treated as the telnet escape character? <URL:#tn=		23.5.12 Is there a workaround to make the Ctrl-] key not to be treated as the telnet escape character?>
		 23.5.13  Ctags for unsupported languages <URL:#tn=		 23.5.13  Ctags for unsupported languages>
		23.5.14  Vim is nice to use with cscope and ctags, for this purpose <URL:#tn=		23.5.14  Vim is nice to use with cscope and ctags, for this purpose>
24. Include search <URL:#tn=24. Include search>
	24.1 :[range]is[earch][!] [count <URL:#tn=	24.1 :[range]is[earch][!] [count>
25. Encryption <URL:#tn=25. Encryption>
	25.1 To encrypt a file. <URL:#tn=	25.1 To encrypt a file.>
	25.2 Cancel (disable) encryption. <URL:#tn=	25.2 Cancel (disable) encryption.>
26. Insertion <URL:#tn=26. Insertion>
	26.1 add, subtract to number under corsur. <URL:#tn=	26.1 add, subtract to number under corsur.>
27. Formatting, Aligning and creating lists <URL:#tn=27. Formatting, Aligning and creating lists>
	27.1 Formatting 101 <URL:#tn=	27.1 Formatting 101>
	    27.1.1 basics <URL:#tn=	    27.1.1 basics>
	    27.1.2 turn off automatic line breaking <URL:#tn=	    27.1.2 turn off automatic line breaking>
	27.2 The formatter function <URL:#tn=	27.2 The formatter function>
	27.3 Alignment, aligning text <URL:#tn=	27.3 Alignment, aligning text>
		27.3.1 Basics <URL:#tn=		27.3.1 Basics>
	27.4 Creating headers <URL:#tn=	27.4 Creating headers>
	27.5 Creating lists <URL:#tn=	27.5 Creating lists>
28. Motion, Movement. <URL:#tn=28. Motion, Movement.>
	28.1 Basics <URL:#tn=	28.1 Basics>
	28.2 Advanced <URL:#tn=	28.2 Advanced>
		28.2.1 Wrapped lines <URL:#tn=		28.2.1 Wrapped lines>
	28.3 Text objects selection. <URL:#tn=	28.3 Text objects selection.>
	28.4 Using motion for selection or copying <URL:#tn=	28.4 Using motion for selection or copying>
29. View ascii, hex and octal value of character. <URL:#tn=29. View ascii, hex and octal value of character.>
30. Jumps, jump lists <URL:#tn=30. Jumps, jump lists>
	30.1 basics <URL:#tn=	30.1 basics>
31. Advanced substitution. <URL:#tn=31. Advanced substitution.>
		31.2 useful examples: <URL:#tn=		31.2 useful examples:>
			31.2.1 substitution <URL:#tn=			31.2.1 substitution>
			31.2.2 substitution in visual <URL:#tn=			31.2.2 substitution in visual>
			31.2.3 complex substitution <URL:#tn=			31.2.3 complex substitution>
			31.2.4 Increment and decrement numbers by substitution <URL:#tn=			31.2.4 Increment and decrement numbers by substitution>
				31.2.4.1 Increment and decrement numbers by substitution  in global scope <URL:#tn=				31.2.4.1 Increment and decrement numbers by substitution  in global scope>
				31.2.4.2 Increment and decrement numbers by substitution  in selection from visual mode <URL:#tn=				31.2.4.2 Increment and decrement numbers by substitution  in selection from visual mode>
				31.2.4.3 <URL:#tn=				31.2.4.3>
			31.2.5 Replacing a pattern match with the character preceding it <URL:#tn=			31.2.5 Replacing a pattern match with the character preceding it>
			31.2.6 <URL:#tn=			31.2.6>
		31.3 <URL:#tn=		31.3>
32. Text searches for multiple files, grep, external, internal <URL:#tn=32. Text searches for multiple files, grep, external, internal>
	32.1 :h grep <URL:#tn=	32.1 :h grep>
	32.2 internal example: <URL:#tn=	32.2 internal example:>
33. Tips. <URL:#tn=33. Tips.>
	33.1 Edit word docs with VIM <URL:#tn=	33.1 Edit word docs with VIM>
	33.2 Edit PDF docs with VIM <URL:#tn=	33.2 Edit PDF docs with VIM>
	33.3 VimTip 12: Converting tabs to spaces <URL:#tn=	33.3 VimTip 12: Converting tabs to spaces>
	33.4 VimTip 29: reverse all the line with only 7 keystroke in vim <URL:#tn=	33.4 VimTip 29: reverse all the line with only 7 keystroke in vim>
	33.5 Filter out lines with pattern <URL:#tn=	33.5 Filter out lines with pattern>
	33.6 delete all lines in file <URL:#tn=	33.6 delete all lines in file>
		33.6.1 ggdG <URL:#tn=		33.6.1 ggdG>
		33.6.2 :1,$d <URL:#tn=		33.6.2 :1,$d>
		33.6.3 Yank all lines instead of delete, :1,$y <URL:#tn=		33.6.3 Yank all lines instead of delete, :1,$y>
		33.6.4 yank all lines bettween markers :'a,'by <URL:#tn=		33.6.4 yank all lines bettween markers :'a,'by>
	33.7 Essential to know <URL:#tn=	33.7 Essential to know>
	33.7 Abbrevations <URL:#tn=	33.7 Abbrevations>
	33.8 Windows <URL:#tn=	33.8 Windows>
		33.8.1  Tip: #886 - Add Vim to Windows Send To menu <URL:#tn=		33.8.1  Tip: #886 - Add Vim to Windows Send To menu>
	33.9. Tip, make a tar file of buffers. <URL:#tn=	33.9. Tip, make a tar file of buffers.>
	33.10. Select your favourite font for gvim. <URL:#tn=	33.10. Select your favourite font for gvim.>
	33.11 Generate accessor and setter methods from variable names <URL:#tn=	33.11 Generate accessor and setter methods from variable names>
	33.12 Automatically create and update cscope database <URL:#tn=	33.12 Automatically create and update cscope database>
	33.13 To switch back to normal mode automatically after inaction <URL:#tn=	33.13 To switch back to normal mode automatically after inaction>
	33.14 Word frequency statistics for a file <URL:#tn=	33.14 Word frequency statistics for a file>
	33.15 Change directory to the file in the current window. <URL:#tn=	33.15 Change directory to the file in the current window.>
	33.16 Paste Indent Problems <URL:#tn=	33.16 Paste Indent Problems>
	33.17 Copy an Entire Buffer to the Clipboard <URL:#tn=	33.17 Copy an Entire Buffer to the Clipboard>
	33.18 Display line numbers <URL:#tn=	33.18 Display line numbers>
	33.19 Switching case of characters <URL:#tn=	33.19 Switching case of characters>
	33.20 Repeating a sequence of commands without defining a macro <URL:#tn=	33.20 Repeating a sequence of commands without defining a macro>
	33.21 Repeat last colon command <URL:#tn=	33.21 Repeat last colon command>
	33.22 Repeating an ex command on multiple blocks <URL:#tn=	33.22 Repeating an ex command on multiple blocks>
	33.23  Here is how to define and use a calculator, using embedded Python. Calculate, arithmetic. <URL:#tn=	33.23  Here is how to define and use a calculator, using embedded Python. Calculate, arithmetic.>
	33.24 Alternate delimiters for the replace command <URL:#tn=	33.24 Alternate delimiters for the replace command>
	33.25 Disable built-in command <URL:#tn=	33.25 Disable built-in command>
	33.26 Using an expression in substitute command <URL:#tn=	33.26 Using an expression in substitute command>
	33.27 Sorting lines in a file based on the number of words in each line <URL:#tn=	33.27 Sorting lines in a file based on the number of words in each line>
	33.28 Save each line in separate numbered files <URL:#tn=	33.28 Save each line in separate numbered files>
	33.29 Send output of g search to a new window <URL:#tn=	33.29 Send output of g search to a new window>
	33.30 Removing automatic comment leaders <URL:#tn=	33.30 Removing automatic comment leaders>
	33.31 The super star <URL:#tn=	33.31 The super star>
		33.31.1 Using the mouse <URL:#tn=		33.31.1 Using the mouse>
		33.31.2 More searching <URL:#tn=		33.31.2 More searching>
		33.31.3 Highlight matches without moving <URL:#tn=		33.31.3 Highlight matches without moving>
		33.31.4 Show the next match while entering a search <URL:#tn=		33.31.4 Show the next match while entering a search>
		33.31.5 While searching complete current matching word <URL:#tn=		33.31.5 While searching complete current matching word>
	33.32 Open file under cursor <URL:#tn=	33.32 Open file under cursor>
	33.33 Paste registers in search or colon commands instead of using the clipboard <URL:#tn=	33.33 Paste registers in search or colon commands instead of using the clipboard>
	33.34 Easy edit of files in the same directory, expand, %: operator <URL:#tn=	33.34 Easy edit of files in the same directory, expand, %: operator>
		33.34.1 Tip 2 Update content <URL:#tn=		33.34.1 Tip 2 Update content>
			33.34.1.1 Using a command line abbreviation <URL:#tn=			33.34.1.1 Using a command line abbreviation>
			33.34.1.2 Using a mapping <URL:#tn=			33.34.1.2 Using a mapping>
			33.34.1.3 References <URL:#tn=			33.34.1.3 References>
		33.34.2 Old tip content, use %/ to expand current file path <URL:#tn=		33.34.2 Old tip content, use %/ to expand current file path>
	33.35 Managing boolean (set) options <URL:#tn=	33.35 Managing boolean (set) options>
		33.35.1 Boolean options <URL:#tn=		33.35.1 Boolean options>
		33.35.2 Toggling an option <URL:#tn=		33.35.2 Toggling an option>
		33.35.3 References <URL:#tn=		33.35.3 References>
	33.36 Swapping characters, words and lines <URL:#tn=	33.36 Swapping characters, words and lines>
		33.36.1 Normal-Mode Commands <URL:#tn=		33.36.1 Normal-Mode Commands>
    		33.36.2 Normal-Mode Mappings <URL:#tn=    		33.36.2 Normal-Mode Mappings>
    		33.36.3 Other Solutions <URL:#tn=    		33.36.3 Other Solutions>
    		    33.36.3.1 Visual-Mode swapping <URL:#tn=    		    33.36.3.1 Visual-Mode swapping>
    		    33.36.3.2 Scripts <URL:#tn=    		    33.36.3.2 Scripts>
	33.37 Improved Hex editing <URL:#tn=	33.37 Improved Hex editing>
		33.37.1  Easily enter and leave hex mode <URL:#tn=		33.37.1  Easily enter and leave hex mode>
		33.37.2 Automatically handle hex mode <URL:#tn=		33.37.2 Automatically handle hex mode>
		33.37.3 Other enhancements <URL:#tn=		33.37.3 Other enhancements>
		33.37.4 References <URL:#tn=		33.37.4 References>
	33.38 Entering special characters <URL:#tn=	33.38 Entering special characters>
		33.38.1 Digraphs <URL:#tn=		33.38.1 Digraphs>
		33.38.2 By character value <URL:#tn=		33.38.2 By character value>
		33.38.3 See also <URL:#tn=		33.38.3 See also>
	33.39 Easily switch between two styles of color scheme <URL:#tn=	33.39 Easily switch between two styles of color scheme>
		33.39.1 Old version <URL:#tn=		33.39.1 Old version>
		33.39.2 Newer Version <URL:#tn=		33.39.2 Newer Version>
		33.39.3 Updated version <URL:#tn=		33.39.3 Updated version>
			33.39.3.1  One page summary of color schemes <URL:#tn=			33.39.3.1  One page summary of color schemes>
			33.39.3.2  Script features <URL:#tn=			33.39.3.2  Script features>
			33.39.3.3  Script usage <URL:#tn=			33.39.3.3  Script usage>
			33.39.3.4  Scrolling the color schemes <URL:#tn=			33.39.3.4  Scrolling the color schemes>
			33.39.3.5  References <URL:#tn=			33.39.3.5  References>
		33.39.4 <URL:#tn=		33.39.4>
	33.40 Highlight long lines <URL:#tn=	33.40 Highlight long lines>
		33.40.1 Matching <URL:#tn=		33.40.1 Matching>
		33.40.2 Automatic <URL:#tn=		33.40.2 Automatic>
		33.40.3 Manual <URL:#tn=		33.40.3 Manual>
		33.40.4 References <URL:#tn=		33.40.4 References>
	33.41  Using command-line history <URL:#tn=	33.41  Using command-line history>
	33.42 Highlight multiple words <URL:#tn=	33.42 Highlight multiple words>
		33.42.1 Requirements <URL:#tn=		33.42.1 Requirements>
		33.42.2 Usage <URL:#tn=		33.42.2 Usage>
			33.42.2.1 Searching <URL:#tn=			33.42.2.1 Searching>
			33.42.2.2 Highlight command <URL:#tn=			33.42.2.2 Highlight command>
			33.42.2.3 Other commands <URL:#tn=			33.42.2.3 Other commands>
			33.42.2.4 Example <URL:#tn=			33.42.2.4 Example>
		33.42.3 Script <URL:#tn=		33.42.3 Script>
		33.42.4 Defining highlight groups <URL:#tn=		33.42.4 Defining highlight groups>
		33.42.5 See also <URL:#tn=		33.42.5 See also>
		33.42.6 References <URL:#tn=		33.42.6 References>
	33.43 Jump to a file to a certain line number <URL:#tn=	33.43 Jump to a file to a certain line number>
	33.44 Open vimrc file <URL:#tn=	33.44 Open vimrc file>
		33.44.1 What is vimrc? <URL:#tn=		33.44.1 What is vimrc?>
		33.44.2  Location of vimrc <URL:#tn=		33.44.2  Location of vimrc>
		33.44.3  Opening vimrc <URL:#tn=		33.44.3  Opening vimrc>
		33.44.4  Sourcing vimrc <URL:#tn=		33.44.4  Sourcing vimrc>
		33.44.5  Recovering from errors <URL:#tn=		33.44.5  Recovering from errors>
	33.45 Uniq - Removing duplicate lines <URL:#tn=	33.45 Uniq - Removing duplicate lines>
	33.46 Ranges tutorial <URL:#tn=	33.46 Ranges tutorial>
		33.46.1 Examples <URL:#tn=		33.46.1 Examples>
		33.46.2 Default Range <URL:#tn=		33.46.2 Default Range>
		33.46.3 Selections <URL:#tn=		33.46.3 Selections>
		33.46.4 Deleting, copying and moving <URL:#tn=		33.46.4 Deleting, copying and moving>
		33.46.5 Ranges with marks and searches <URL:#tn=		33.46.5 Ranges with marks and searches>
	33.47 C++ code completion <URL:#tn=	33.47 C++ code completion>
	33.48 Handle common command typos <URL:#tn=	33.48 Handle common command typos>
	33.49 Environment variables <URL:#tn=	33.49 Environment variables>
	33.50 Using the Windows clipboard in Cygwin Vim <URL:#tn=	33.50 Using the Windows clipboard in Cygwin Vim>
		33.50.1 Copy to Windows clipboard <URL:#tn=		33.50.1 Copy to Windows clipboard>
		33.50.2 Paste from Windows clipboard <URL:#tn=		33.50.2 Paste from Windows clipboard>
		33.50.3 See also <URL:#tn=		33.50.3 See also>
	33.51 Showing syntax highlight group in statusline <URL:#tn=	33.51 Showing syntax highlight group in statusline>
	33.52 Tip 278 The principles of effective text editing <URL:#tn=	33.52 Tip 278 The principles of effective text editing>
	33.53 Tip 396 Highlight unwanted spaces <URL:#tn=	33.53 Tip 396 Highlight unwanted spaces>
		33.53.1 Highlighting with a search <URL:#tn=		33.53.1 Highlighting with a search>
		33.53.2 Highlighting with the match command <URL:#tn=		33.53.2 Highlighting with the match command>
		33.53.3 Highlighting with the syntax command <URL:#tn=		33.53.3 Highlighting with the syntax command>
		33.53.4 Using the list and listchars options <URL:#tn=		33.53.4 Using the list and listchars options>
		33.53.5 Using syntax space errors <URL:#tn=		33.53.5 Using syntax space errors>
		33.53.6 Showing long lines <URL:#tn=		33.53.6 Showing long lines>
		33.53.7 See also <URL:#tn=		33.53.7 See also>
	33.54 Tip 438 Search and replace in a visual selection <URL:#tn=	33.54 Tip 438 Search and replace in a visual selection>
		33.54.1 Visual selection basics <URL:#tn=		33.54.1 Visual selection basics>
		33.54.2 Ex commands <URL:#tn=		33.54.2 Ex commands>
		33.54.3 Substituting in a visual selection <URL:#tn=		33.54.3 Substituting in a visual selection>
		33.54.4 Searching with / and ? <URL:#tn=		33.54.4 Searching with / and ?>
		33.54.5 References <URL:#tn=		33.54.5 References>
	33.55 Tip 330 How to stop auto indenting <URL:#tn=	33.55 Tip 330 How to stop auto indenting>
		33.55.1 Disabling file type based indentation for a specific file type <URL:#tn=		33.55.1 Disabling file type based indentation for a specific file type>
		33.55.2 Disabling file type based indentation for all file types <URL:#tn=		33.55.2 Disabling file type based indentation for all file types>
		33.55.3 Disabling auto indent for the current file <URL:#tn=		33.55.3 Disabling auto indent for the current file>
		33.55.4 Comments <URL:#tn=		33.55.4 Comments>
	33.56 Tip 16 Avoiding the "Hit ENTER to continue" prompts <URL:#tn=	33.56 Tip 16 Avoiding the "Hit ENTER to continue" prompts>
	33.57 Tip 1577 Record a recursive macro <URL:#tn=	33.57 Tip 1577 Record a recursive macro>
	33.58 Multiple commands at once <URL:#tn=	33.58 Multiple commands at once>
	33.59 Find in files within Vim <URL:#tn=	33.59 Find in files within Vim>
		33.59.1 Basic use <URL:#tn=		33.59.1 Basic use>
		33.59.2 Tips and Tricks <URL:#tn=		33.59.2 Tips and Tricks>
			33.59.2.1 Old search results <URL:#tn=			33.59.2.1 Old search results>
			33.59.2.2 Recursive search <URL:#tn=			33.59.2.2 Recursive search>
			33.59.2.3 Path separators <URL:#tn=			33.59.2.3 Path separators>
			33.59.2.4 Mappings <URL:#tn=			33.59.2.4 Mappings>
		33.59.3 Disabling autocmds for fast searches <URL:#tn=		33.59.3 Disabling autocmds for fast searches>
		33.59.4 Using external programs for fast searches <URL:#tn=		33.59.4 Using external programs for fast searches>
		33.59.5 Related Plugins <URL:#tn=		33.59.5 Related Plugins>
		33.59.6 See also <URL:#tn=		33.59.6 See also>
		33.59.7 References <URL:#tn=		33.59.7 References>
	33.60 Copy or change search hit <URL:#tn=	33.60 Copy or change search hit>
		33.60.1 A search text object <URL:#tn=		33.60.1 A search text object>
		33.60.2 Explanation <URL:#tn=		33.60.2 Explanation>
		33.60.3 Limitations <URL:#tn=		33.60.3 Limitations>
		33.60.4 See also <URL:#tn=		33.60.4 See also>
		33.60.5 References <URL:#tn=		33.60.5 References>
	33.61 Copy the search results into clipboard <URL:#tn=	33.61 Copy the search results into clipboard>
	33.62 Cream, <URL:#tn=	33.62 Cream,>
	33.63 Example vimrc <URL:#tn=	33.63 Example vimrc>
		33.63.1 Requirements and caveats <URL:#tn=		33.63.1 Requirements and caveats>
		33.63.2 Usage recommendations <URL:#tn=		33.63.2 Usage recommendations>
		33.63.3 Example vimrc <URL:#tn=		33.63.3 Example vimrc>
	33.64 Increasing or decreasing numbers <URL:#tn=	33.64 Increasing or decreasing numbers>
	33.65 Working with Unicode <URL:#tn=	33.65 Working with Unicode>
	33.66 Search for lines not containing pattern and other helpful searches <URL:#tn=	33.66 Search for lines not containing pattern and other helpful searches>
	33.67 Tip 1585, file formats <URL:#tn=	33.67 Tip 1585, file formats>
		33.67.1 File format options Edit <URL:#tn=		33.67.1 File format options Edit>
		33.67.2 File format detection <URL:#tn=		33.67.2 File format detection>
		33.67.3 Converting the current file <URL:#tn=		33.67.3 Converting the current file>
		33.67.4 Converting clean files <URL:#tn=		33.67.4 Converting clean files>
		33.67.5 Converting mixed files <URL:#tn=		33.67.5 Converting mixed files>
		33.67.6 Removing unwanted CR or LF characters <URL:#tn=		33.67.6 Removing unwanted CR or LF characters>
		33.67.7 Terminator after last line <URL:#tn=		33.67.7 Terminator after last line>
		33.67.8 How file format conversion works <URL:#tn=		33.67.8 How file format conversion works>
		33.67.9 Results of incorrect file format detection <URL:#tn=		33.67.9 Results of incorrect file format detection>
		33.67.10 Vim script problems <URL:#tn=		33.67.10 Vim script problems>
		33.67.11 Pitfalls <URL:#tn=		33.67.11 Pitfalls>
		33.67.12 Other approaches <URL:#tn=		33.67.12 Other approaches>
		33.67.13 Tools <URL:#tn=		33.67.13 Tools>
	33.68 <URL:#tn=	33.68>
34. Clever tricks <URL:#tn=34. Clever tricks>
	34.1 Global, tags global operator <URL:#tn=	34.1 Global, tags global operator>
		34.1.1 print cerain blocks of text using global <URL:#tn=		34.1.1 print cerain blocks of text using global>
		34.1.2 Remove unwanted empty lines <URL:#tn=		34.1.2 Remove unwanted empty lines>
		34.1.3 Power of g <URL:#tn=		34.1.3 Power of g>
			34.1.3.1 Brief explanation of :g <URL:#tn=			34.1.3.1 Brief explanation of :g>
			34.1.3.2 Some examples <URL:#tn=			34.1.3.2 Some examples>
				34.1.3.2.1 Display context (5 lines) for all occurrences of a pattern. <URL:#tn=				34.1.3.2.1 Display context (5 lines) for all occurrences of a pattern.>
				34.1.3.2.2 Delete all lines matching a pattern. <URL:#tn=				34.1.3.2.2 Delete all lines matching a pattern.>
				34.1.3.2.3 Delete all blank lines. <URL:#tn=				34.1.3.2.3 Delete all blank lines.>
				34.1.3.2.4 Double space the file ('^' matches each line). <URL:#tn=				34.1.3.2.4 Double space the file ('^' matches each line).>
				34.1.3.2.5 Copy all lines matching a pattern to end of file. <URL:#tn=				34.1.3.2.5 Copy all lines matching a pattern to end of file.>
				34.1.3.2.6 Yank all lines matching a pattern to register 'a'. <URL:#tn=				34.1.3.2.6 Yank all lines matching a pattern to register 'a'.>
				34.1.3.2.7 Increment numbers from current line to end-of-document by one (this assumes the default behavior of Ctrl-A to increment a number; you might need :unmap <C-A> on Windows). <URL:#tn=				34.1.3.2.7 Increment numbers from current line to end-of-document by one (this assumes the default behavior of Ctrl-A to increment a number; you might need :unmap <C-A> on Windows).>
				34.1.3.2.8 Comment lines containing "DEBUG" statements in a C program. <URL:#tn=				34.1.3.2.8 Comment lines containing "DEBUG" statements in a C program.>
				34.1.3.2.9 Reverse lookup for records (say an address book, with Name at start-of-line and fields after a space). <URL:#tn=				34.1.3.2.9 Reverse lookup for records (say an address book, with Name at start-of-line and fields after a space).>
				34.1.3.2.10 Reverse a file (just to show the power of g). <URL:#tn=				34.1.3.2.10 Reverse a file (just to show the power of g).>
				34.1.3.2.11 using normal mode editing with global <URL:#tn=				34.1.3.2.11 using normal mode editing with global>
				34.1.3.2.12 <URL:#tn=				34.1.3.2.12>
			34.1.3.3 Notes Use :v to negate the search pattern. <URL:#tn=			34.1.3.3 Notes Use :v to negate the search pattern.>
			34.1.3.4 Some explanation of commands commonly used with :g <URL:#tn=			34.1.3.4 Some explanation of commands commonly used with :g>
			34.1.3.5 Commands used with :g are Ex commands, so a help search should be <URL:#tn=			34.1.3.5 Commands used with :g are Ex commands, so a help search should be>
			34.1.3.6  Comments <URL:#tn=			34.1.3.6  Comments>
	34.2 Count words <URL:#tn=	34.2 Count words>
		34.2.1 Count patterns, lines, characters, words <URL:#tn=		34.2.1 Count patterns, lines, characters, words>
		34.2.2 Some more ways to count lines <URL:#tn=		34.2.2 Some more ways to count lines>
	34.3 Enter, add, insert multiple characters <URL:#tn=	34.3 Enter, add, insert multiple characters>
		34.3.1 Yank <URL:#tn=		34.3.1 Yank>
		34.3.2 Macro, record <URL:#tn=		34.3.2 Macro, record>
	34.4 Advanced usage of global operator <URL:#tn=	34.4 Advanced usage of global operator>
		34.4.1 Join all consecutive lines <URL:#tn=		34.4.1 Join all consecutive lines>
			34.4.1.1 Basic <URL:#tn=			34.4.1.1 Basic>
			34.4.1.2 Advanced <URL:#tn=			34.4.1.2 Advanced>
		34.4.2 Useful global operator operations from http://www.rayninfo.co.uk/vimtips.html <URL:#tn=		34.4.2 Useful global operator operations from http://www.rayninfo.co.uk/vimtips.html>
		34.4.3 Search (Print) all instances of pattern A not containing pattern B <URL:#tn=		34.4.3 Search (Print) all instances of pattern A not containing pattern B>
			34.4.4 Print (get) a list of all line numbers that contain a given pattern <URL:#tn=			34.4.4 Print (get) a list of all line numbers that contain a given pattern>
    34.5 Edit remote file via ssh (scp) <URL:#tn=    34.5 Edit remote file via ssh (scp)>
    34.6 <URL:#tn=    34.6>
35. Regular expressions <URL:#tn=35. Regular expressions>
	35.1 magic <URL:#tn=	35.1 magic>
	35.2 Patterns <URL:#tn=	35.2 Patterns>
	35.3 Filter lines according to pattern. <URL:#tn=	35.3 Filter lines according to pattern.>
	35.4 Manual <URL:#tn=	35.4 Manual>
	35.5 substitution memory anchors <URL:#tn=	35.5 substitution memory anchors>
	35.6 example <URL:#tn=	35.6 example>
	37.7 Greedy vs. Nongreedy <URL:#tn=	37.7 Greedy vs. Nongreedy>
	37.8 Regular Expressions Reference <URL:#tn=	37.8 Regular Expressions Reference>
36. Nice tips <URL:#tn=36. Nice tips>
	36.1 edit <URL:#tn=	36.1 edit>
		36.1.1   Use % to jump from an open brace to its matching closing brace. Or from a "#if" to the matching "#endif". Actually, % can jump to many different matching items. It is very useful to check if () and {} constructs are balanced properly. <URL:#tn=		36.1.1   Use % to jump from an open brace to its matching closing brace. Or from a "#if" to the matching "#endif". Actually, % can jump to many different matching items. It is very useful to check if () and {} constructs are balanced properly.>
		36.1.2 Use [{ to jump back to the "{" at the start of the current code block. <URL:#tn=		36.1.2 Use [{ to jump back to the "{" at the start of the current code block.>
		36.1.3 Use gd to jump from the use of a variable to its local declaration. <URL:#tn=		36.1.3 Use gd to jump from the use of a variable to its local declaration.>
		36.1.4 e, ge, move to end of word, end of previous word.:w! <URL:#tn=		36.1.4 e, ge, move to end of word, end of previous word.:w!>
		36.1.5 H,M,L, move to top, middle, buttom of seen screen. <URL:#tn=		36.1.5 H,M,L, move to top, middle, buttom of seen screen.>
	36.2 count number of matches of a pattern <URL:#tn=	36.2 count number of matches of a pattern>
	36.3 Perform shell action on current buffer (!, %) <URL:#tn=	36.3 Perform shell action on current buffer (!, %)>
	36.4 Pull words into search or command line <URL:#tn=	36.4 Pull words into search or command line>
	36.5 Search in range (block) <URL:#tn=	36.5 Search in range (block)>
	36.6 substitute using a register <URL:#tn=	36.6 substitute using a register>
35. Compare with EMACS commands. <URL:#tn=35. Compare with EMACS commands.>
38. External programms <URL:#tn=38. External programms>
	38.1 Make <URL:#tn=	38.1 Make>
		39.1.1 set makeprg to work for maven and allow vim working directory to be base of project yet make only current files module <URL:#tn=		39.1.1 set makeprg to work for maven and allow vim working directory to be base of project yet make only current files module>
		39.1.2 set makeprg to work for clearmake and allow vim working directory to be base of project yet make only current files module <URL:#tn=		39.1.2 set makeprg to work for clearmake and allow vim working directory to be base of project yet make only current files module>
		39.1.3 <URL:#tn=		39.1.3>
		38.1.2 :comp[iler][!] {name} <URL:#tn=		38.1.2 :comp[iler][!] {name}>
	38.2 Insert date <URL:#tn=	38.2 Insert date>
		38.2.1 Unix <URL:#tn=		38.2.1 Unix>
		38.2.2 Windows, MAC etc <URL:#tn=		38.2.2 Windows, MAC etc>
			38.2.2.1 edit Using strftime() <URL:#tn=			38.2.2.1 edit Using strftime()>
				38.2.2.1.1 Some strftime() format string examples <URL:#tn=				38.2.2.1.1 Some strftime() format string examples>
			38.2.2.2 edit Using external tools <URL:#tn=			38.2.2.2 edit Using external tools>
			38.2.2.3 edit Automatically update timestamps <URL:#tn=			38.2.2.3 edit Automatically update timestamps>
			38.2.2.4 Updating a DNS SOA serial number <URL:#tn=			38.2.2.4 Updating a DNS SOA serial number>
	38.3 <URL:#tn=	38.3>
39. VIM diff :h vimdiff <URL:#tn=39. VIM diff :h vimdiff>
	39.1 start diff: <URL:#tn=	39.1 start diff:>
		39.1.1 Start diff from command line <URL:#tn=		39.1.1 Start diff from command line>
		39.1.2 Start diff from within VIM session <URL:#tn=		39.1.2 Start diff from within VIM session>
	39.2 Diff Navigation, <URL:#tn=	39.2 Diff Navigation,>
		41.2.1 Scrolling <URL:#tn=		41.2.1 Scrolling>
		41.2.2 Updating the diffs <URL:#tn=		41.2.2 Updating the diffs>
		39.2.3 Jump to diffs <URL:#tn=		39.2.3 Jump to diffs>
	39.3 Diff copy <URL:#tn=	39.3 Diff copy>
39. Group Highlighting. match and higlight groups of patterns. <URL:#tn=39. Group Highlighting. match and higlight groups of patterns.>
	39.1 Usage <URL:#tn=	39.1 Usage>
	39.2 Color groups <URL:#tn=	39.2 Color groups>
	39.3 examples: <URL:#tn=	39.3 examples:>
40. The status line <URL:#tn=40. The status line>
41. Work area modifications <URL:#tn=41. Work area modifications>
	41.1 Mark current line <URL:#tn=	41.1 Mark current line>
	41.2 Remove marks <URL:#tn=	41.2 Remove marks>
42. Spell checking <URL:#tn=42. Spell checking>
	42.1 Start spell check <URL:#tn=	42.1 Start spell check>
	42.2 Fix a misspelled word: <URL:#tn=	42.2 Fix a misspelled word:>
43.  Viewing optimization: <URL:#tn=43.  Viewing optimization:>
44. "BEST OF VIN TIPS" Advanced usage, Tips by David Rayner <URL:#tn=44. "BEST OF VIN TIPS" Advanced usage, Tips by David Rayner>
	44.1  searching <URL:#tn=	44.1  searching>
	44.2 substitution <URL:#tn=	44.2 substitution>
	44.3 Best Vim Tips Tip 305 <URL:#tn=	44.3 Best Vim Tips Tip 305>
		44.3.1 Absolutely essential <URL:#tn=		44.3.1 Absolutely essential>
        	44.3.2 Make it easy to update/reload _vimrc <URL:#tn=        	44.3.2 Make it easy to update/reload _vimrc>
        	44.3.3 VISUAL MODE Mappings <URL:#tn=        	44.3.3 VISUAL MODE Mappings>
        	44.3.4 Exploring <URL:#tn=        	44.3.4 Exploring>
        	44.3.5 Great <URL:#tn=        	44.3.5 Great>
        	44.3.6 Easter Eggs <URL:#tn=        	44.3.6 Easter Eggs>
        	44.3.7 Markers & moving about <URL:#tn=        	44.3.7 Markers & moving about>
        	44.3.8 Abbreviations & maps <URL:#tn=        	44.3.8 Abbreviations & maps>
        	44.3.9 For use in Maps <URL:#tn=        	44.3.9 For use in Maps>
        	44.3.10 List your Registers <URL:#tn=        	44.3.10 List your Registers>
        	44.3.11 Execute vim command from buffer contents <URL:#tn=        	44.3.11 Execute vim command from buffer contents>
        	44.3.12 Get output from shell commands <URL:#tn=        	44.3.12 Get output from shell commands>
        	44.3.13 Multiple Files Management <URL:#tn=        	44.3.13 Multiple Files Management>
        	44.3.14 Recording (BEST TIP of ALL) <URL:#tn=        	44.3.14 Recording (BEST TIP of ALL)>
        	44.3.15 vimrc essentials <URL:#tn=        	44.3.15 vimrc essentials>
        	44.3.16 Launching programs under Windows <URL:#tn=        	44.3.16 Launching programs under Windows>
        	44.3.17 FTPing from Vim <URL:#tn=        	44.3.17 FTPing from Vim>
        	44.3.18 Appending to registers (use CAPITAL) <URL:#tn=        	44.3.18 Appending to registers (use CAPITAL)>
        	44.3.19 Conventional shifting <URL:#tn=        	44.3.19 Conventional shifting>
        	44.3.20 Searching <URL:#tn=        	44.3.20 Searching>
        	44.3.21 Substitution <URL:#tn=        	44.3.21 Substitution>
        	44.3.22 Global command <URL:#tn=        	44.3.22 Global command>
        	44.3.23 Paste register * <URL:#tn=        	44.3.23 Paste register *>
        	44.3.24 Formatting text <URL:#tn=        	44.3.24 Formatting text>
        	44.3.25 Operate command over multiple files <URL:#tn=        	44.3.25 Operate command over multiple files>
        	44.3.26 Command line tricks <URL:#tn=        	44.3.26 Command line tricks>
        	44.3.27 Comments <URL:#tn=        	44.3.27 Comments>
	44.4 Flattended most recent version <URL:#tn=	44.4 Flattended most recent version>
45. VI pocket reference <URL:#tn=45. VI pocket reference>
	45.1 Command line options <URL:#tn=	45.1 Command line options>
	45.2  vi Commands <URL:#tn=	45.2  vi Commands>
		45.2.1  Movement Commands <URL:#tn=		45.2.1  Movement Commands>
		45.2.2 Editing Commands <URL:#tn=		45.2.2 Editing Commands>
		45.2.3 Exit Commands <URL:#tn=		45.2.3 Exit Commands>
		45.2.4 vi Command-Mode Tag Commands <URL:#tn=		45.2.4 vi Command-Mode Tag Commands>
		45.2.5 Buffer Names <URL:#tn=		45.2.5 Buffer Names>
		45.2.6 Buffer and Marking Commands <URL:#tn=		45.2.6 Buffer and Marking Commands>
	45.3 Input Mode Shortcuts <URL:#tn=	45.3 Input Mode Shortcuts>
		45.3.1 Word Abbreviation <URL:#tn=		45.3.1 Word Abbreviation>
		45.3.2 Command and Input Mode Maps <URL:#tn=		45.3.2 Command and Input Mode Maps>
			45.3.2.1 Syntax <URL:#tn=			45.3.2.1 Syntax>
			45.3.2.1 Tutorial <URL:#tn=			45.3.2.1 Tutorial>
		45.3.3 Named buffers provide yet another way to create "macros"complex command sequences you can repeat with a few keystrokes. Here's how it's done: <URL:#tn=		45.3.3 Named buffers provide yet another way to create "macros"complex command sequences you can repeat with a few keystrokes. Here's how it's done:>
		45.3.4 Automatic Indentation <URL:#tn=		45.3.4 Automatic Indentation>
	45.4 Substitution and Regular Expressions <URL:#tn=	45.4 Substitution and Regular Expressions>
		45.4.1 The Substitute Command <URL:#tn=		45.4.1 The Substitute Command>
		45.4.2 vi Regular Expressions <URL:#tn=		45.4.2 vi Regular Expressions>
		45.4.3  POSIX character classes <URL:#tn=		45.4.3  POSIX character classes>
		45.4.4 Metacharacters Used in Replacement Strings <URL:#tn=		45.4.4 Metacharacters Used in Replacement Strings>
		45.4.5 More Substitution Tricks <URL:#tn=		45.4.5 More Substitution Tricks>
    45.5 ex Commands <URL:#tn=    45.5 ex Commands>
	45.5.1 Command Syntax <URL:#tn=	45.5.1 Command Syntax>
	45.5.2 Address Symbols <URL:#tn=	45.5.2 Address Symbols>
	45.5.3 Command Option Symbols <URL:#tn=	45.5.3 Command Option Symbols>
	45.5.4  Alphabetical List of Commands <URL:#tn=	45.5.4  Alphabetical List of Commands>
	45.6  vi Options <URL:#tn=	45.6  vi Options>
	45.7  VIM <URL:#tn=	45.7  VIM>
		45.7.1 Important Command-Line Arguments, flags, parameters <URL:#tn=		45.7.1 Important Command-Line Arguments, flags, parameters>
		45.7.2 vim Window Management Commands <URL:#tn=		45.7.2 vim Window Management Commands>
			45.7.2.1 Window commands from vi mode <URL:#tn=			45.7.2.1 Window commands from vi mode>
		45.7.3 Extended Regular Expressions <URL:#tn=		45.7.3 Extended Regular Expressions>
		45.7.4 Command-Line History and Completion <URL:#tn=		45.7.4 Command-Line History and Completion>
			45.7.4.1 History commands <URL:#tn=			45.7.4.1 History commands>
			45.7.4.2 Completion commands <URL:#tn=			45.7.4.2 Completion commands>
		45.7.5 Tag Stacks <URL:#tn=		45.7.5 Tag Stacks>
			45.7.5.1  Tag commands <URL:#tn=			45.7.5.1  Tag commands>
			45.7.5.2 Command-mode tag commands <URL:#tn=			45.7.5.2 Command-mode tag commands>
		45.7.6 Edit-Compile Speedup <URL:#tn=		45.7.6 Edit-Compile Speedup>
			45.7.6.1 Program development commands <URL:#tn=			45.7.6.1 Program development commands>
			45.7.6.2  Program development options <URL:#tn=			45.7.6.2  Program development options>
		45.7.7 Programming Assistance <URL:#tn=		45.7.7 Programming Assistance>
			45.7.7.1 Indentation and formatting options <URL:#tn=			45.7.7.1 Indentation and formatting options>
			45.7.7.2 Identifier search commands <URL:#tn=			45.7.7.2 Identifier search commands>
			45.7.7.3 Identifier search commands from ex mode <URL:#tn=			45.7.7.3 Identifier search commands from ex mode>
			45.7.7.4  Extended matching commands <URL:#tn=			45.7.7.4  Extended matching commands>
		45.7.8 Vim 5.1 Set Options <URL:#tn=		45.7.8 Vim 5.1 Set Options>
46. Undo Branching <URL:#tn=46. Undo Branching>
	46.1 description <URL:#tn=	46.1 description>
	46.2 Usage <URL:#tn=	46.2 Usage>
		46.2.1 go to a specific undo branch <URL:#tn=		46.2.1 go to a specific undo branch>
		46.2.2 traverse the undo list <URL:#tn=		46.2.2 traverse the undo list>
		46.2.3 undo using edit time <URL:#tn=		46.2.3 undo using edit time>
47. VIM Scripting <URL:#tn=47. VIM Scripting>
	47.1 Syntax-Color Schemes <URL:#tn=	47.1 Syntax-Color Schemes>
		47.1.1 Syntax regions <URL:#tn=		47.1.1 Syntax regions>
			47.1.1.1 Syntax regions in depth <URL:#tn=			47.1.1.1 Syntax regions in depth>
		47.1.2 Syntax files <URL:#tn=		47.1.2 Syntax files>
			47.1.2.1 Syntax files additions, VIM post-processor <URL:#tn=			47.1.2.1 Syntax files additions, VIM post-processor>
		47.1.3 Color scheme and syntax coloring <URL:#tn=		47.1.3 Color scheme and syntax coloring>
	47.2 Scripts <URL:#tn=	47.2 Scripts>
		47.2.1 Script types <URL:#tn=		47.2.1 Script types>
			47.2.1.1 Scripts that add features to VIM <URL:#tn=			47.2.1.1 Scripts that add features to VIM>
		47.2.2 Installing scripts <URL:#tn=		47.2.2 Installing scripts>
		47.2.3 Uninstalling scripts <URL:#tn=		47.2.3 Uninstalling scripts>
		47.2.4 Script development <URL:#tn=		47.2.4 Script development>
			47.2.4.1 Script basics <URL:#tn=			47.2.4.1 Script basics>
				47.2.4.1.1 Types <URL:#tn=				47.2.4.1.1 Types>
				47.2.4.1.2 Variables <URL:#tn=				47.2.4.1.2 Variables>
					47.2.4.1.2.1 Strings and Ints <URL:#tn=					47.2.4.1.2.1 Strings and Ints>
					47.2.4.1.2.2 Lists <URL:#tn=					47.2.4.1.2.2 Lists>
					47.2.4.1.2.3 Dictionaries <URL:#tn=					47.2.4.1.2.3 Dictionaries>
					47.2.4.1.2.3 Function refs <URL:#tn=					47.2.4.1.2.3 Function refs>
					47.2.4.1.2.4 Variable scopes <URL:#tn=					47.2.4.1.2.4 Variable scopes>
				47.2.4.1.3 Conditions <URL:#tn=				47.2.4.1.3 Conditions>
				47.2.4.1.4 Lists and dictionaries <URL:#tn=				47.2.4.1.4 Lists and dictionaries>
				47.2.4.1.5 Loops <URL:#tn=				47.2.4.1.5 Loops>
					47.2.4.1.5.1 For loops <URL:#tn=					47.2.4.1.5.1 For loops>
					47.2.4.1.5.2 While loops <URL:#tn=					47.2.4.1.5.2 While loops>
			47.2.4.2 Creating functions <URL:#tn=			47.2.4.2 Creating functions>
				47.2.4.2.1 Variable argument list <URL:#tn=				47.2.4.2.1 Variable argument list>
			47.2.4.2 Script structure <URL:#tn=			47.2.4.2 Script structure>
				47.2.4.2.1 Header <URL:#tn=				47.2.4.2.1 Header>
				47.2.4.2.2 Was Script loaded check <URL:#tn=				47.2.4.2.2 Was Script loaded check>
				47.2.4.2.3 Configuration <URL:#tn=				47.2.4.2.3 Configuration>
				47.2.4.2.4 Mappings <URL:#tn=				47.2.4.2.4 Mappings>
				47.2.4.2.5 Functions <URL:#tn=				47.2.4.2.5 Functions>
				47.2.4.2.6 Putting it all together <URL:#tn=				47.2.4.2.6 Putting it all together>
		47.2.5 Scripting Tips <URL:#tn=		47.2.5 Scripting Tips>
			47.2.5.1 gvim or vim? <URL:#tn=			47.2.5.1 gvim or vim?>
			47.2.5.2 Which operating system? <URL:#tn=			47.2.5.2 Which operating system?>
			47.2.5.3 Which VIM version? <URL:#tn=			47.2.5.3 Which VIM version?>
			47.2.5.4 Printing longer lines <URL:#tn=			47.2.5.4 Printing longer lines>
		47.2.9 Debugging scripts <URL:#tn=		47.2.9 Debugging scripts>
			47.2.9.1 Start VIM in debug mode <URL:#tn=			47.2.9.1 Start VIM in debug mode>
			47.2.9.2 Debug Session <URL:#tn=			47.2.9.2 Debug Session>
			47.2.9.3 Breakpoints <URL:#tn=			47.2.9.3 Breakpoints>
				47.2.9.3.1 Add <URL:#tn=				47.2.9.3.1 Add>
				47.2.9.3.2 Revise <URL:#tn=				47.2.9.3.2 Revise>
				47.2.9.3.3 Remove <URL:#tn=				47.2.9.3.3 Remove>
		47.2.10 Distributing scripts <URL:#tn=		47.2.10 Distributing scripts>
		47.2.11 Making Vimballs <URL:#tn=		47.2.11 Making Vimballs>
		47.2.12 Documentation <URL:#tn=		47.2.12 Documentation>
		47.2.13 External Interpretrs <URL:#tn=		47.2.13 External Interpretrs>
			47.2.13.1 Perl scripting in VIM <URL:#tn=			47.2.13.1 Perl scripting in VIM>
			47.2.13.2 Python scripting in VIM <URL:#tn=			47.2.13.2 Python scripting in VIM>
			47.2.13.3 Ruby scripting in VIM <URL:#tn=			47.2.13.3 Ruby scripting in VIM>
	47.3 Learn scripts from examples <URL:#tn=	47.3 Learn scripts from examples>
		47.3.1 foo.vim <URL:#tn=		47.3.1 foo.vim>
	47.4 <URL:#tn=	47.4>
48. Folds. Folding <URL:#tn=48. Folds. Folding>
	48.1 folds are useful for providing readable and easy navigable view of the file. <URL:#tn=	48.1 folds are useful for providing readable and easy navigable view of the file.>
	48.2 Manual <URL:#tn=	48.2 Manual>
	48.3 syntax <URL:#tn=	48.3 syntax>
		48.3.1 CPP, C++ <URL:#tn=		48.3.1 CPP, C++>
		48.3.2 Use folds in your program <URL:#tn=		48.3.2 Use folds in your program>
49. Ommni Copmletion <URL:#tn=49. Ommni Copmletion>
	49.1 See :help new-omni-completion <URL:#tn=	49.1 See :help new-omni-completion>
50. Configure (setup) VIM <URL:#tn=50. Configure (setup) VIM>
	50.1 A VIMRC setup system <URL:#tn=	50.1 A VIMRC setup system>
	50.2 Example vimrc <URL:#tn=	50.2 Example vimrc>
	50.3 <URL:#tn=	50.3>
51. Install VIM, vim_install, install_vim, VIM patches, install patches <URL:#tn=51. Install VIM, vim_install, install_vim, VIM patches, install patches>
	51.1  On Linux by compiling the sources <URL:#tn=	51.1  On Linux by compiling the sources>
		51.1.1  Add features <URL:#tn=		51.1.1  Add features>
	51.2 on Windows <URL:#tn=	51.2 on Windows>
	51.3 More on installation for linux <URL:#tn=	51.3 More on installation for linux>
		51.3.1  Some suggestions, didn't work for me <URL:#tn=		51.3.1  Some suggestions, didn't work for me>
		51.3.2 Manually, my example <URL:#tn=		51.3.2 Manually, my example>
		51.3.3 Install VIM using mercurial <URL:#tn=		51.3.3 Install VIM using mercurial>
	51.4 On MAC <URL:#tn=	51.4 On MAC>
	51.5 Install vim 8 on linux <URL:#tn=	51.5 Install vim 8 on linux>
		51.5.1 Install git <URL:#tn=		51.5.1 Install git>
		51.5.2 Get vim <URL:#tn=		51.5.2 Get vim>
		51.5.3 Compile <URL:#tn=		51.5.3 Compile>
		51.5.4 <URL:#tn=		51.5.4>
	51.6 Install vim 8 on GE linux Suse server <URL:#tn=	51.6 Install vim 8 on GE linux Suse server>
	51.7 <URL:#tn=	51.7>
52. Tips from vim_use@googlegroups.com <URL:#tn=52. Tips from vim_use@googlegroups.com>
	52.1 Fast Buffer Switching <URL:#tn=	52.1 Fast Buffer Switching>
	52.2 quickfix list and location-list <URL:#tn=	52.2 quickfix list and location-list>
		52.2.1 What generates a quickfix? <URL:#tn=		52.2.1 What generates a quickfix?>
		52.2.2 How to open the quickfix? <URL:#tn=		52.2.2 How to open the quickfix?>
		52.2.3 How to navigate to next/previous match? <URL:#tn=		52.2.3 How to navigate to next/previous match?>
		52.2.4 Location-list <URL:#tn=		52.2.4 Location-list>
		52.2.5 How to jump to error or message from quickfix or location list <URL:#tn=		52.2.5 How to jump to error or message from quickfix or location list>
		52.2.6 How to add/append to quickfix <URL:#tn=		52.2.6 How to add/append to quickfix>
		52.2.7 Store CTAGS matches into location list <URL:#tn=		52.2.7 Store CTAGS matches into location list>
	52.3 colorscheme dependent on filetype <URL:#tn=	52.3 colorscheme dependent on filetype>
	52.4 rediraction of output, redir <URL:#tn=	52.4 rediraction of output, redir>
	52.5 sorting words <URL:#tn=	52.5 sorting words>
		52.5.1 description <URL:#tn=		52.5.1 description>
		52.5.2 Solution using visualize <URL:#tn=		52.5.2 Solution using visualize>
		52.5.3 Using global <URL:#tn=		52.5.3 Using global>
		52.5.4 Sort operator <URL:#tn=		52.5.4 Sort operator>
	52.6 Search for visually selected text <URL:#tn=	52.6 Search for visually selected text>
	52.7 How to list all occurrence of a identifier <URL:#tn=	52.7 How to list all occurrence of a identifier>
		52.7.1 Using vimgrep <URL:#tn=		52.7.1 Using vimgrep>
		52.7.2 Using cscope, find where function/method is called <URL:#tn=		52.7.2 Using cscope, find where function/method is called>
		52.7.3 Using GNU ID utils <URL:#tn=		52.7.3 Using GNU ID utils>
			52.7.3.1 Basic commands <URL:#tn=			52.7.3.1 Basic commands>
	52.8 How to determine current font in use <URL:#tn=	52.8 How to determine current font in use>
	52.9 Go to nth character (byte) from current position <URL:#tn=	52.9 Go to nth character (byte) from current position>
	52.10 VIM and bash <URL:#tn=	52.10 VIM and bash>
	52.11 command to select multiple line & move it backward/forward <URL:#tn=	52.11 command to select multiple line & move it backward/forward>
	52.12 Another method of converting dos 2 unix <URL:#tn=	52.12 Another method of converting dos 2 unix>
	52.13 Advanced pattern matching discussions <URL:#tn=	52.13 Advanced pattern matching discussions>
		52.13.1 match abcd not "abcd" <URL:#tn=		52.13.1 match abcd not "abcd">
	52.14 Strange result of reading from shell <URL:#tn=	52.14 Strange result of reading from shell>
	52.15 delete between patterns <URL:#tn=	52.15 delete between patterns>
	52.16 cscope and ctags generation and configuration tips <URL:#tn=	52.16 cscope and ctags generation and configuration tips>
	52.17 VIM for editing emails <URL:#tn=	52.17 VIM for editing emails>
		52.17.1 Firefox, Gmail, its all text firefox plugin <URL:#tn=		52.17.1 Firefox, Gmail, its all text firefox plugin>
		52.17.2 <URL:#tn=		52.17.2>
	52.18 remove an empty line if the previous line matches 'foo'. <URL:#tn=	52.18 remove an empty line if the previous line matches 'foo'.>
	52.19 Where are my marks stored? How to carry a file between two computers to preserve marks? <URL:#tn=	52.19 Where are my marks stored? How to carry a file between two computers to preserve marks?>
	52.20 running shell command in the directory of the file <URL:#tn=	52.20 running shell command in the directory of the file>
	52.21 vimgrep: how to get rid of E303 <URL:#tn=	52.21 vimgrep: how to get rid of E303>
	52.22 :set nu -> how to copy lines with line numbers? <URL:#tn=	52.22 :set nu -> how to copy lines with line numbers?>
	52.23 bring two buff into diff mode <URL:#tn=	52.23 bring two buff into diff mode>
	52.24 How to save recordings in vimrc <URL:#tn=	52.24 How to save recordings in vimrc>
	52.25 how to perform action on all modified buffers <URL:#tn=	52.25 how to perform action on all modified buffers>
		52.25.1 Question <URL:#tn=		52.25.1 Question>
		52.25.2 Answers <URL:#tn=		52.25.2 Answers>
		52.25.3 Excertp from .vimrc of adding menu actions to archive all modified buffers and checkin all checkout buffers: <URL:#tn=		52.25.3 Excertp from .vimrc of adding menu actions to archive all modified buffers and checkin all checkout buffers:>
	52.26 Tags paths problem: "E429: File "/users/yizaq/.vim/tags/long/path/to/file.h" does not exist " <URL:#tn=	52.26 Tags paths problem: "E429: File "/users/yizaq/.vim/tags/long/path/to/file.h" does not exist ">
		52.26.1 question <URL:#tn=		52.26.1 question>
		52.26.2 Answers <URL:#tn=		52.26.2 Answers>
	52.27 how to match the space Not begin from the start-of-line <URL:#tn=	52.27 how to match the space Not begin from the start-of-line>
	52.28 Exit message <URL:#tn=	52.28 Exit message>
	52.29 Folding question of a ToDo list file <URL:#tn=	52.29 Folding question of a ToDo list file>
	52.30 How to force windows vim to load appropriate vimrc? <URL:#tn=	52.30 How to force windows vim to load appropriate vimrc?>
	52.31 listing total number of buffers in the statusline <URL:#tn=	52.31 listing total number of buffers in the statusline>
	52.32 generate lines with increasing numbers <URL:#tn=	52.32 generate lines with increasing numbers>
	52.33 VIM and web pages, how to read web pages (URL) in VIM <URL:#tn=	52.33 VIM and web pages, how to read web pages (URL) in VIM>
	52.34 Can't save file due to "CONVERSION ERROR in line..." <URL:#tn=	52.34 Can't save file due to "CONVERSION ERROR in line...">
	52.35 List known filetypes? <URL:#tn=	52.35 List known filetypes?>
	52.35 how to count # of paragraphs <URL:#tn=	52.35 how to count # of paragraphs>
	52.34 search for output of shell command <URL:#tn=	52.34 search for output of shell command>
	52.35 how to display registers 0-9?- concise way & enhanced #,* <URL:#tn=	52.35 how to display registers 0-9?- concise way & enhanced #,*>
	52.36 how to read long shell output <URL:#tn=	52.36 how to read long shell output>
	52.37 How to emphesize or color a few key words on the fly? <URL:#tn=	52.37 How to emphesize or color a few key words on the fly?>
	52.38 <URL:#tn=	52.38>
53. Help system <URL:#tn=53. Help system>
	53.1  Basics <URL:#tn=	53.1  Basics>
54. Mapping <URL:#tn=54. Mapping>
	54.1 Basics <URL:#tn=	54.1 Basics>
55.  VIM interaction with different applications, tools <URL:#tn=55.  VIM interaction with different applications, tools>
	55.1  Firefox and VIM - vimperator <URL:#tn=	55.1  Firefox and VIM - vimperator>
		55.1.1  Tutorial <URL:#tn=		55.1.1  Tutorial>
		55.1.2 Initialization <URL:#tn=		55.1.2 Initialization>
		55.1.3 		Browsing <URL:#tn=		55.1.3 		Browsing>
		55.1.4 	Buffers <URL:#tn=		55.1.4 	Buffers>
		55.1.5 Search commands <URL:#tn=		55.1.5 Search commands>
		55.1.6 		options <URL:#tn=		55.1.6 		options>
		55.1.7 		tabs <URL:#tn=		55.1.7 		tabs>
		55.1.8 Navigation, hints <URL:#tn=		55.1.8 Navigation, hints>
		55.1.9 Key mapping <URL:#tn=		55.1.9 Key mapping>
		55.1.10 eval <URL:#tn=		55.1.10 eval>
		55.1.11 marks <URL:#tn=		55.1.11 marks>
		55.1.12 record macros <URL:#tn=		55.1.12 record macros>
		55.1.13 autocommands <URL:#tn=		55.1.13 autocommands>
		55.1.14 printing <URL:#tn=		55.1.14 printing>
		55.1.15 Various commands <URL:#tn=		55.1.15 Various commands>
	55.2 <URL:#tn=	55.2>
56. Mapping keys in Vim - Tutorial <URL:#tn=56. Mapping keys in Vim - Tutorial>
	56.1 Part 1 <URL:#tn=	56.1 Part 1>
		56.1.1 Introduction <URL:#tn=		56.1.1 Introduction>
		56.1.2 Creating keymaps <URL:#tn=		56.1.2 Creating keymaps>
		56.1.3 Storing the key maps <URL:#tn=		56.1.3 Storing the key maps>
		56.1.4 Listing key maps <URL:#tn=		56.1.4 Listing key maps>
		56.1.5 Removing a keymap <URL:#tn=		56.1.5 Removing a keymap>
		56.1.6 Mode-specific maps <URL:#tn=		56.1.6 Mode-specific maps>
			56.1.6.1 Normal mode maps <URL:#tn=			56.1.6.1 Normal mode maps>
			56.1.6.2 Insert mode maps <URL:#tn=			56.1.6.2 Insert mode maps>
			56.1.6.3 Visual mode maps <URL:#tn=			56.1.6.3 Visual mode maps>
			56.1.6.4 Command-line mode maps <URL:#tn=			56.1.6.4 Command-line mode maps>
			56.1.6.5 Operator pending mode maps <URL:#tn=			56.1.6.5 Operator pending mode maps>
		56.1.7 Mapping mouse events <URL:#tn=		56.1.7 Mapping mouse events>
		56.1.8 Nested (recursive) maps <URL:#tn=		56.1.8 Nested (recursive) maps>
		56.1.9 Comments <URL:#tn=		56.1.9 Comments>
	56.2 Part 2 <URL:#tn=	56.2 Part 2>
		56.2.1 Finding unused keys <URL:#tn=		56.2.1 Finding unused keys>
		56.2.2 Key notation <URL:#tn=		56.2.2 Key notation>
		56.2.3 Maps with the same prefix <URL:#tn=		56.2.3 Maps with the same prefix>
		56.2.4 Map comments <URL:#tn=		56.2.4 Map comments>
		56.2.5 Supplying a count to a map <URL:#tn=		56.2.5 Supplying a count to a map>
		56.2.6 Using multiple Ex commands in a map <URL:#tn=		56.2.6 Using multiple Ex commands in a map>
		56.2.7 Using space characters in a map <URL:#tn=		56.2.7 Using space characters in a map>
		56.2.8 Disabling key and mouse events <URL:#tn=		56.2.8 Disabling key and mouse events>
		56.2.9 Error in mapped key sequences <URL:#tn=		56.2.9 Error in mapped key sequences>
		56.2.10 Maps and 'cpoptions' option <URL:#tn=		56.2.10 Maps and 'cpoptions' option>
		56.2.11 Maps and 'paste' option <URL:#tn=		56.2.11 Maps and 'paste' option>
		56.2.12 Map attributes <URL:#tn=		56.2.12 Map attributes>
			56.2.12.1 Buffer-local maps <URL:#tn=			56.2.12.1 Buffer-local maps>
			56.2.12.2 Silent maps <URL:#tn=			56.2.12.2 Silent maps>
			56.2.12.3 Expression maps <URL:#tn=			56.2.12.3 Expression maps>
			56.2.12.4 Special characters in maps <URL:#tn=			56.2.12.4 Special characters in maps>
		56.2.13 Comments <URL:#tn=		56.2.13 Comments>
	56.3 Part 3 <URL:#tn=	56.3 Part 3>
		56.3.1 Using maps in Vim plugins and scripts <URL:#tn=		56.3.1 Using maps in Vim plugins and scripts>
			56.3.1.1 Map leader <URL:#tn=			56.3.1.1 Map leader>
			56.3.1.2 Script maps <URL:#tn=			56.3.1.2 Script maps>
			56.3.1.3 Unique maps <URL:#tn=			56.3.1.3 Unique maps>
			56.3.1.4 Use of <Plug> <URL:#tn=			56.3.1.4 Use of <Plug>>
			56.3.1.5 Map related functions <URL:#tn=			56.3.1.5 Map related functions>
			56.3.1.6 maparg() <URL:#tn=			56.3.1.6 maparg()>
			56.3.1.7 mapcheck() <URL:#tn=			56.3.1.7 mapcheck()>
			56.3.1.8 mode() <URL:#tn=			56.3.1.8 mode()>
			56.3.1.9 hasmapto() <URL:#tn=			56.3.1.9 hasmapto()>
		56.3.2 Comments <URL:#tn=		56.3.2 Comments>
57. Working with VIM Tabs. Tab pages <URL:#tn=57. Working with VIM Tabs. Tab pages>
	57.1 Basics <URL:#tn=	57.1 Basics>
	    57.1.1  open tabs <URL:#tn=	    57.1.1  open tabs>
	    57.1.2 close tabs <URL:#tn=	    57.1.2 close tabs>
	    57.1.3 navigating tabs <URL:#tn=	    57.1.3 navigating tabs>
	    57.1.4 <URL:#tn=	    57.1.4>
	57.2 Tabs configuration <URL:#tn=	57.2 Tabs configuration>
	57.3 Reordering tab pages <URL:#tn=	57.3 Reordering tab pages>
	57.4 LOOPING OVER TAB PAGES: <URL:#tn=	57.4 LOOPING OVER TAB PAGES:>
58. Nuts and bolts <URL:#tn=58. Nuts and bolts>
	58.1 Change VIM session title <URL:#tn=	58.1 Change VIM session title>
	58.2 File format, unix vs. dos question <URL:#tn=	58.2 File format, unix vs. dos question>
	58.3 <URL:#tn=	58.3>
59. Tutorials <URL:#tn=59. Tutorials>
	59.1 Video, Derek Wyatt's videos <URL:#tn=	59.1 Video, Derek Wyatt's videos>
		59.1.1 Apply (operate) commands to (over) multiple files <URL:#tn=		59.1.1 Apply (operate) commands to (over) multiple files>
		59.1.2 <URL:#tn=		59.1.2>
	59.2 <URL:#tn=	59.2>
60. Advacned regexps (regular expressions) <URL:#tn=60. Advacned regexps (regular expressions)>
	60.1 match Some text & more text & (some white space) & ... <URL:#tn=	60.1 match Some text & more text & (some white space) & ...>
	60.2 <URL:#tn=	60.2>
61. vimrc examples <URL:#tn=61. vimrc examples>
	61.1  My own <URL:#tn=	61.1  My own>
		61.1.1  Work Laptop updated Mon Jan 25 18:16:46 JST 2010 <URL:#tn=		61.1.1  Work Laptop updated Mon Jan 25 18:16:46 JST 2010>
		61.1.2 Linux development enviorment update: Mon Jan 25 18:16:18 JST 2010 <URL:#tn=		61.1.2 Linux development enviorment update: Mon Jan 25 18:16:18 JST 2010>
		61.1.3 <URL:#tn=		61.1.3>
	61.2 Other <URL:#tn=	61.2 Other>
		61.2.1 "The ultimate vimrc" <URL:#tn=		61.2.1 "The ultimate vimrc">
		61.2.2 Tony Mechelnyk's <URL:#tn=		61.2.2 Tony Mechelnyk's>
			61.2.2.1 http://users.skynet.be/antoine.mechelynck/other/.vimrc <URL:#tn=			61.2.2.1 http://users.skynet.be/antoine.mechelynck/other/.vimrc>
			61.2.2.2 http://users.skynet.be/antoine.mechelynck/other/almost-default.vim <URL:#tn=			61.2.2.2 http://users.skynet.be/antoine.mechelynck/other/almost-default.vim>
			61.2.2.3 <URL:#tn=			61.2.2.3>
		61.2.3 <URL:#tn=		61.2.3>
	61.3 <URL:#tn=	61.3>
62. Colorschemes <URL:#tn=62. Colorschemes>
	62.1 h colorscheme <URL:#tn=	62.1 h colorscheme>
	62.2 <URL:#tn=	62.2>
63. From books <URL:#tn=63. From books>
	63.1 From vimbook-OPL <URL:#tn=	63.1 From vimbook-OPL>
		63.1.1 help <URL:#tn=		63.1.1 help>
		63.1.2 Using a Count to Edit Faster <URL:#tn=		63.1.2 Using a Count to Edit Faster>
		63.1.3 Moving to the Start or End of a Line <URL:#tn=		63.1.3 Moving to the Start or End of a Line>
		63.1.4 Scrolling Up and Down <URL:#tn=		63.1.4 Scrolling Up and Down>
		63.1.5 f,F,t,T revised <URL:#tn=		63.1.5 f,F,t,T revised>
		63.1.6 Saving Your Setting <URL:#tn=		63.1.6 Saving Your Setting>
		63.1.7 The :shell Command <URL:#tn=		63.1.7 The :shell Command>
		63.1.8 Inserting Text <URL:#tn=		63.1.8 Inserting Text>
		63.1.9 The viminfo File <URL:#tn=		63.1.9 The viminfo File>
		63.1.10 Advacned Visual Mode <URL:#tn=		63.1.10 Advacned Visual Mode>
			63.1.10.1 The $ Command <URL:#tn=			63.1.10.1 The $ Command>
			63.1.10.2 Repeating a Visual Selection <URL:#tn=			63.1.10.2 Repeating a Visual Selection>
			63.1.10.3 Selecting Objects <URL:#tn=			63.1.10.3 Selecting Objects>
			63.1.10.4 Moving to the Other End of a Selection <URL:#tn=			63.1.10.4 Moving to the Other End of a Selection>
			63.1.10.5 Case Changes <URL:#tn=			63.1.10.5 Case Changes>
			63.1.10.6 Joining Lines <URL:#tn=			63.1.10.6 Joining Lines>
			63.1.10.7 Formatting a Block <URL:#tn=			63.1.10.7 Formatting a Block>
			63.1.10.8 The Encode (g?) Command <URL:#tn=			63.1.10.8 The Encode (g?) Command>
			63.1.10.9 The Colon (:) Commands <URL:#tn=			63.1.10.9 The Colon (:) Commands>
			63.1.10.10 Pipe (!) Command <URL:#tn=			63.1.10.10 Pipe (!) Command>
		63.1.11 Select Mode <URL:#tn=		63.1.11 Select Mode>
		63.1.12 Comparing Two Files, scroll two windows at same time <URL:#tn=		63.1.12 Comparing Two Files, scroll two windows at same time>
		63.1.13 The Preview Window <URL:#tn=		63.1.13 The Preview Window>
		63.1.14 Match Options <URL:#tn=		63.1.14 Match Options>
		63.1.15 Showing Matches <URL:#tn=		63.1.15 Showing Matches>
		63.1.16 Dealing with Multiple Directories <URL:#tn=		63.1.16 Dealing with Multiple Directories>
			63.1.16.1 The include Path <URL:#tn=			63.1.16.1 The include Path>
			63.1.16.2 Checking the Path <URL:#tn=			63.1.16.2 Checking the Path>
			63.1.16.3 My settings <URL:#tn=			63.1.16.3 My settings>
		63.1.17 Complete Regular Expressions <URL:#tn=		63.1.17 Complete Regular Expressions>
			63.1.17.1 Beginning (\<) and End (\>) of a Word <URL:#tn=			63.1.17.1 Beginning (\<) and End (\>) of a Word>
			63.1.17.2 Modifiers and Grouping <URL:#tn=			63.1.17.2 Modifiers and Grouping>
			63.1.17.3 Special Atoms <URL:#tn=			63.1.17.3 Special Atoms>
			63.1.17.4 Character Ranges <URL:#tn=			63.1.17.4 Character Ranges>
			63.1.17.5 Character Classes <URL:#tn=			63.1.17.5 Character Classes>
			63.1.17.6 Repeat Modifiers <URL:#tn=			63.1.17.6 Repeat Modifiers>
				63.1.17.6.1 Repeating as Little as Possible <URL:#tn=				63.1.17.6.1 Repeating as Little as Possible>
			63.1.17.7 Grouping ( \(\) ) <URL:#tn=			63.1.17.7 Grouping ( \(\) )>
			63.1.17.8 The Or Operator (\|) <URL:#tn=			63.1.17.8 The Or Operator (\|)>
			63.1.17.9 Putting It All Together <URL:#tn=			63.1.17.9 Putting It All Together>
			63.1.17.10 The magic Option <URL:#tn=			63.1.17.10 The magic Option>
			63.1.17.11 <URL:#tn=			63.1.17.11>
		63.1.18 references <URL:#tn=		63.1.18 references>
			63.1.18.1 Offset Specification Reference <URL:#tn=			63.1.18.1 Offset Specification Reference>
			63.1.18.2 Regular Expressions Reference <URL:#tn=			63.1.18.2 Regular Expressions Reference>
				63.1.18.2.1 Simple Atoms <URL:#tn=				63.1.18.2.1 Simple Atoms>
				63.1.18.2.2 Range Atoms <URL:#tn=				63.1.18.2.2 Range Atoms>
				63.1.18.2.3 Character Classes <URL:#tn=				63.1.18.2.3 Character Classes>
				63.1.18.2.4 Patterns (Used for Substitutions) <URL:#tn=				63.1.18.2.4 Patterns (Used for Substitutions)>
				63.1.18.2.5 Special Character Atoms <URL:#tn=				63.1.18.2.5 Special Character Atoms>
				63.1.18.2.6 Modifiers <URL:#tn=				63.1.18.2.6 Modifiers>
				63.1.18.2.7 <URL:#tn=				63.1.18.2.7>
			63.1.18.3 <URL:#tn=			63.1.18.3>
		63.1.19 Special Registers <URL:#tn=		63.1.19 Special Registers>
			63.1.19.1 The Black Hole Register (_) <URL:#tn=			63.1.19.1 The Black Hole Register (_)>
			63.1.19.2 The Expression Register (=) <URL:#tn=			63.1.19.2 The Expression Register (=)>
			63.1.19.3 The Clipboard Register (*) <URL:#tn=			63.1.19.3 The Clipboard Register (*)>
			63.1.19.4 How to Edit All the Files That Contain a <URL:#tn=			63.1.19.4 How to Edit All the Files That Contain a>
				63.1.19.4.1 Editing a Specific File <URL:#tn=				63.1.19.4.1 Editing a Specific File>
				63.1.19.4.2 This command enables you to specify a file by its position in the argument list. <URL:#tn=				63.1.19.4.2 This command enables you to specify a file by its position in the argument list.>
				63.1.19.4.3 The +cmd Argument <URL:#tn=				63.1.19.4.3 The +cmd Argument>
				63.1.19.4.4 <URL:#tn=				63.1.19.4.4>
			63.1.19.5 Complete Command-Mode (:) Commands <URL:#tn=			63.1.19.5 Complete Command-Mode (:) Commands>
				63.1.19.5.1 Editing Commands <URL:#tn=				63.1.19.5.1 Editing Commands>
				63.1.19.5.2 Copy and Move <URL:#tn=				63.1.19.5.2 Copy and Move>
				63.1.19.5.3 Inserting Text <URL:#tn=				63.1.19.5.3 Inserting Text>
				63.1.19.5.4 Printing with Line Numbers <URL:#tn=				63.1.19.5.4 Printing with Line Numbers>
				63.1.19.5.5 Printing with list Enabled <URL:#tn=				63.1.19.5.5 Printing with list Enabled>
				63.1.19.5.6 Print the Text and Then Some <URL:#tn=				63.1.19.5.6 Print the Text and Then Some>
			63.1.19.6 Substitute <URL:#tn=			63.1.19.6 Substitute>
				63.1.19.6.1 Making g the Default <URL:#tn=				63.1.19.6.1 Making g the Default>
				63.1.19.6.2 Global Changes <URL:#tn=				63.1.19.6.2 Global Changes>
			63.1.19.7 <URL:#tn=			63.1.19.7>
		63.1.20 Directory Manipulation <URL:#tn=		63.1.20 Directory Manipulation>
		63.1.21 Files <URL:#tn=		63.1.21 Files>
			63.1.21.1 Current File <URL:#tn=			63.1.21.1 Current File>
			63.1.21.2 Advanced :write Commands <URL:#tn=			63.1.21.2 Advanced :write Commands>
			63.1.21.3 Updating Files <URL:#tn=			63.1.21.3 Updating Files>
			63.1.21.4 Reading Files <URL:#tn=			63.1.21.4 Reading Files>
			63.1.21.5 Register Execution <URL:#tn=			63.1.21.5 Register Execution>
			63.1.21.6 Simple Edits <URL:#tn=			63.1.21.6 Simple Edits>
			63.1.21.7 Changing Text <URL:#tn=			63.1.21.7 Changing Text>
		63.1.22 Miscellaneous Commands <URL:#tn=		63.1.22 Miscellaneous Commands>
			63.1.22.1 The :preserve Command <URL:#tn=			63.1.22.1 The :preserve Command>
			63.1.22.2 The Shell Commands <URL:#tn=			63.1.22.2 The Shell Commands>
			63.1.22.3 Shell Configuration <URL:#tn=			63.1.22.3 Shell Configuration>
			63.1.22.4 Command History <URL:#tn=			63.1.22.4 Command History>
			63.1.22.5 Setting the Number of Remembered Commands <URL:#tn=			63.1.22.5 Setting the Number of Remembered Commands>
			63.1.22.6 Viewing Previous Error Messages <URL:#tn=			63.1.22.6 Viewing Previous Error Messages>
			63.1.22.7 Redirecting the Output <URL:#tn=			63.1.22.7 Redirecting the Output>
			63.1.22.8 Executing a :normal Command <URL:#tn=			63.1.22.8 Executing a :normal Command>
		63.1.23 Getting Out <URL:#tn=		63.1.23 Getting Out>
		63.1.24 Expressions and Functions <URL:#tn=		63.1.24 Expressions and Functions>
			63.1.24.1 Basic Variables and Expressions <URL:#tn=			63.1.24.1 Basic Variables and Expressions>
			63.1.24.2 Special Variable Names <URL:#tn=			63.1.24.2 Special Variable Names>
			63.1.24.3 Expressions <URL:#tn=			63.1.24.3 Expressions>
			63.1.24.4 Entering Filenames <URL:#tn=			63.1.24.4 Entering Filenames>
			63.1.24.5 How to Experiment <URL:#tn=			63.1.24.5 How to Experiment>
			63.1.24.6 The :echo Statement <URL:#tn=			63.1.24.6 The :echo Statement>
			63.1.24.7 Control Statements <URL:#tn=			63.1.24.7 Control Statements>
				63.1.24.7.1 The :if Statement <URL:#tn=				63.1.24.7.1 The :if Statement>
				63.1.24.7.2 Looping <URL:#tn=				63.1.24.7.2 Looping>
				63.1.24.7.3 The :execute Command <URL:#tn=				63.1.24.7.3 The :execute Command>
			63.1.24.8 Defining Your Own Function <URL:#tn=			63.1.24.8 Defining Your Own Function>
				63.1.24.8.1 Using a Function <URL:#tn=				63.1.24.8.1 Using a Function>
				63.1.24.8.2 Listing Functions <URL:#tn=				63.1.24.8.2 Listing Functions>
				63.1.24.8.3 Deleting a Function <URL:#tn=				63.1.24.8.3 Deleting a Function>
			63.1.24.9 <URL:#tn=			63.1.24.9>
		63.1.25 <URL:#tn=		63.1.25>
	63.2 http://joyrex.spc.uchicago.edu/bookshelves/vim/regex.html#news <URL:#tn=	63.2 http://joyrex.spc.uchicago.edu/bookshelves/vim/regex.html#news>
	63.2.2.1 What is VIM? <URL:#tn=	63.2.2.1 What is VIM?>
	63.2.2.2 About this Tutorial <URL:#tn=	63.2.2.2 About this Tutorial>
	63.2.2.3 Credits <URL:#tn=	63.2.2.3 Credits>
	63.2.3.1 Search & Replace <URL:#tn=	63.2.3.1 Search & Replace>
	63.2.3.2 Range of Operation, Line Addressing and Marks <URL:#tn=	63.2.3.2 Range of Operation, Line Addressing and Marks>
	63.2.4.1 Anchors <URL:#tn=	63.2.4.1 Anchors>
	63.2.4.2 "Escaped" characters or metacharacters <URL:#tn=	63.2.4.2 "Escaped" characters or metacharacters>
	63.2.4.3 Quantifiers, Greedy and Non-Greedy <URL:#tn=	63.2.4.3 Quantifiers, Greedy and Non-Greedy>
	63.2.4.4 Character ranges <URL:#tn=	63.2.4.4 Character ranges>
	63.2.4.5 Grouping and Backreferences <URL:#tn=	63.2.4.5 Grouping and Backreferences>
	63.2.4.6 Alternations <URL:#tn=	63.2.4.6 Alternations>
	63.2.4.7 Regexp Operator Precedence <URL:#tn=	63.2.4.7 Regexp Operator Precedence>
	63.2.5.1 Global search and execution <URL:#tn=	63.2.5.1 Global search and execution>
	63.2.5.2 Examples <URL:#tn=	63.2.5.2 Examples>
	63.2.6.1 Tips and Techniques <URL:#tn=	63.2.6.1 Tips and Techniques>
	63.2.6.2 Creating outline <URL:#tn=	63.2.6.2 Creating outline>
	63.2.6.3 Working with Tables <URL:#tn=	63.2.6.3 Working with Tables>
	63.3 <URL:#tn=	63.3>
64. FAQ <URL:#tn=64. FAQ>
	64.1 How to delete, as in close buffers? <URL:#tn=	64.1 How to delete, as in close buffers?>
	64.2 command line file name modifiers , %: operator <URL:#tn=	64.2 command line file name modifiers , %: operator>
		64.2.1 :h filename-modifiers <URL:#tn=		64.2.1 :h filename-modifiers>
		64.2.2 How to echo or print filename with modifies <URL:#tn=		64.2.2 How to echo or print filename with modifies>
		64.2.3 <URL:#tn=		64.2.3>
	64.3 Make-compile current buffer <URL:#tn=	64.3 Make-compile current buffer>
	64.4 E464: Ambiguous use of user-defined command <URL:#tn=	64.4 E464: Ambiguous use of user-defined command>
	64.5 Setting a Language for vim Syntax Highlighting <URL:#tn=	64.5 Setting a Language for vim Syntax Highlighting>
	64.6 Changing case with regular expressions <URL:#tn=	64.6 Changing case with regular expressions>
	64.7 Copy the full path of current buffer to clipboard <URL:#tn=	64.7 Copy the full path of current buffer to clipboard>
	64.8 Why does vim always say 'Already at oldest change' when I try to undo? <URL:#tn=	64.8 Why does vim always say 'Already at oldest change' when I try to undo?>
		64.8.1  Negative undolevels <URL:#tn=		64.8.1  Negative undolevels>
	64.9 yank current buffer file name and path <URL:#tn=	64.9 yank current buffer file name and path>
	64.10 remove new line at the end of file <URL:#tn=	64.10 remove new line at the end of file>
	64.11 vim buftype option is set (can't save file) <URL:#tn=	64.11 vim buftype option is set (can't save file)>
65.  Working Productively in Bash's Vi Command Line Editing Mode (with Cheat Sheet) <URL:#tn=65.  Working Productively in Bash's Vi Command Line Editing Mode (with Cheat Sheet)>
	65.1  Brief overview <URL:#tn=	65.1  Brief overview>
	65.2 CheatSheet <URL:#tn=	65.2 CheatSheet>
	65.3 <URL:#tn=	65.3>
66.  cscope <URL:#tn=66.  cscope>
	66.1 Man cscope <URL:#tn=	66.1 Man cscope>
	66.2 Troubleshoot <URL:#tn=	66.2 Troubleshoot>
		66.2.1 crash w/ core - buffer overflow <URL:#tn=		66.2.1 crash w/ core - buffer overflow>
		66.2.2 <URL:#tn=		66.2.2>
	66.3 Install cscope on MAC <URL:#tn=	66.3 Install cscope on MAC>
67. VIM as IDE <URL:#tn=67. VIM as IDE>
	67.1  C++ <URL:#tn=	67.1  C++>
		67.1.1  CLANG <URL:#tn=		67.1.1  CLANG>
			67.1.1.1 clang complete : Use of Clang for completing C, C++, Objective-C and Objective-C++ <URL:#tn=			67.1.1.1 clang complete : Use of Clang for completing C, C++, Objective-C and Objective-C++>
				67.1.1.1.1 This plugin use clang for accurately completing C, C++, Objective-C and Objective-C++ code. <URL:#tn=				67.1.1.1.1 This plugin use clang for accurately completing C, C++, Objective-C and Objective-C++ code.>
				67.1.1.1.2 Completion kinds    				*clang_complete-compl_kinds* <URL:#tn=				67.1.1.1.2 Completion kinds    				*clang_complete-compl_kinds*>
		67.1.2 eclim <URL:#tn=		67.1.2 eclim>
		67.1.3 <URL:#tn=		67.1.3>
	67.2 Java <URL:#tn=	67.2 Java>
	67.3 Python <URL:#tn=	67.3 Python>
		67.3.1 http://sontek.net/blog/detail/turning-vim-into-a-modern-python-ide <URL:#tn=		67.3.1 http://sontek.net/blog/detail/turning-vim-into-a-modern-python-ide>
		67.3.2 <URL:#tn=		67.3.2>
	67.4 <URL:#tn=	67.4>
68. receips, cookbook <URL:#tn=68. receips, cookbook>
	68.1 g, global operator <URL:#tn=	68.1 g, global operator>
		68.1.1 Join lines between patterns <URL:#tn=		68.1.1 Join lines between patterns>
		68.1.2 <URL:#tn=		68.1.2>
	68.2 <URL:#tn=	68.2>
69. Platform specific <URL:#tn=69. Platform specific>
	69.1  MAC <URL:#tn=	69.1  MAC>
		69.1.1  Transperancy <URL:#tn=		69.1.1  Transperancy>
		69.1.2 <URL:#tn=		69.1.2>
	69.2 <URL:#tn=	69.2>
70. Integration with source control systems <URL:#tn=70. Integration with source control systems>
	70.1 ClearCase <URL:#tn=	70.1 ClearCase>
	70.2 Perforce <URL:#tn=	70.2 Perforce>
	70.3 <URL:#tn=	70.3>
71. Troubelshooting <URL:#tn=71. Troubelshooting>
    71.1  crashes <URL:#tn=    71.1  crashes>
        71.1.1  got deadly signal sigabrt <URL:#tn=        71.1.1  got deadly signal sigabrt>
        71.1.2 <URL:#tn=        71.1.2>
    71.2 <URL:#tn=    71.2>
72. match white spaces <URL:#tn=72. match white spaces>
    72.1 https://vim.fandom.com/wiki/Highlight_unwanted_spaces <URL:#tn=    72.1 https://vim.fandom.com/wiki/Highlight_unwanted_spaces>
    72.2 <URL:#tn=    72.2>
73. JSON <URL:#tn=73. JSON>
    73.1 pretty format JSON <URL:#tn=    73.1 pretty format JSON>
    73.2 <URL:#tn=    73.2>
74. Neo vim, NVIM, neovim <URL:#tn=74. Neo vim, NVIM, neovim>
    74.1 Getting started <URL:#tn=    74.1 Getting started>
    74.2 Common issues <URL:#tn=    74.2 Common issues>
        74.2.1 cm_start.py nvim error invalid syntax <URL:#tn=        74.2.1 cm_start.py nvim error invalid syntax>
        74.2.2 error caught in async handler deoplete_auto_completion_begin <URL:#tn=        74.2.2 error caught in async handler deoplete_auto_completion_begin>
        74.2.3 ImportError: No module named neovim <URL:#tn=        74.2.3 ImportError: No module named neovim>
            74.2.3.1 my fix <URL:#tn=            74.2.3.1 my fix>
            74.2.3.2 reddit <URL:#tn=            74.2.3.2 reddit>
            74.2.3.3 copy to clipboard <URL:#tn=            74.2.3.3 copy to clipboard>
            74.2.3.4 <URL:#tn=            74.2.3.4>
        74.2.4 <URL:#tn=        74.2.4>
    74.3 enhanced features vs vim <URL:#tn=    74.3 enhanced features vs vim>
        74.3.1 live substitution <URL:#tn=        74.3.1 live substitution>
        74.3.2 # Highlight Yanked Text <URL:#tn=        74.3.2 # Highlight Yanked Text>
        74.3.3 # Language Server Protocol <URL:#tn=        74.3.3 # Language Server Protocol>
        74.3.4 <URL:#tn=        74.3.4>
    74.4 plugins <URL:#tn=    74.4 plugins>
        74.4.1 update plugins <URL:#tn=        74.4.1 update plugins>
        74.4.2 <URL:#tn=        74.4.2>
    74.5 <URL:#tn=    74.5>
75. vim versions <URL:#tn=75. vim versions>
    75.1 <URL:#tn=    75.1>
    75.2 <URL:#tn=    75.2>
    75.3 <URL:#tn=    75.3>
    75.4 <URL:#tn=    75.4>
    75.5 <URL:#tn=    75.5>
    75.6 <URL:#tn=    75.6>
    75.7 <URL:#tn=    75.7>
    75.8 <URL:#tn=    75.8>
    75.9 vim version 9 <URL:#tn=    75.9 vim version 9>
        75.9.1  install <URL:#tn=        75.9.1  install>
        75.9.2 features <URL:#tn=        75.9.2 features>
        75.9.3 <URL:#tn=        75.9.3>
    75.10 <URL:#tn=    75.10>
76.  Vim presentations <URL:#tn=76.  Vim presentations>
    76.1 presentation to team <URL:#tn=    76.1 presentation to team>
        76.1.1 redit discussion as preparation <URL:#tn=        76.1.1 redit discussion as preparation>
            76.1.1.1 Buffers! ... and modes!! <URL:#tn=            76.1.1.1 Buffers! ... and modes!!>
            76.1.1.2 I really like the IntelliJ vim extension. <URL:#tn=            76.1.1.2 I really like the IntelliJ vim extension.>
            76.1.1.3 I wouldn't try to show that vim can do anything their IDEs can. If that was the only competition, they'll most likely stay with their IDE. I'd show various editing in normal mode, and the power of text objects. Maybe an example of some advanced editing of lots of similar, but not identical lines, using a macro (I find recording the macro is a fun sort of meta programming, and then the rewars when repeating it with N@q). <URL:#tn=            76.1.1.3 I wouldn't try to show that vim can do anything their IDEs can. If that was the only competition, they'll most likely stay with their IDE. I'd show various editing in normal mode, and the power of text objects. Maybe an example of some advanced editing of lots of similar, but not identical lines, using a macro (I find recording the macro is a fun sort of meta programming, and then the rewars when repeating it with N@q).>
            76.1.1.4 Pretty much this. I also find that a lot of times it's the smaller things / script editing that really showcases how much power Vim has. Some examples: <URL:#tn=            76.1.1.4 Pretty much this. I also find that a lot of times it's the smaller things / script editing that really showcases how much power Vim has. Some examples:>
            76.1.1.5 <URL:#tn=            76.1.1.5>
        76.1.2 <URL:#tn=        76.1.2>
            76.1.2.1 <URL:#tn=            76.1.2.1>
            76.1.2.1 neat tips and tricks <URL:#tn=            76.1.2.1 neat tips and tricks>
                76.1.2.1.1 reverse file <URL:#tn=                76.1.2.1.1 reverse file>
                76.1.2.1.2 sort file <URL:#tn=                76.1.2.1.2 sort file>
                76.1.2.1.3 generate lines with incrementing numbers <URL:#tn=                76.1.2.1.3 generate lines with incrementing numbers>
        76.1.3 presentation structure <URL:#tn=        76.1.3 presentation structure>
            76.1.3.1 vim history <URL:#tn=            76.1.3.1 vim history>
            76.1.3.2 vim philosophy <URL:#tn=            76.1.3.2 vim philosophy>
            76.1.3.3 vim history reference 1 - https://gist.github.com/lettertwo/813e765a9f68127b0807d1d6619c5ab0 <URL:#tn=            76.1.3.3 vim history reference 1 - https://gist.github.com/lettertwo/813e765a9f68127b0807d1d6619c5ab0>
            76.1.3.4 https://dev.to/gypsydave5/the-unix-way-or-why-you-actually-want-to-use-vim-3n8p <URL:#tn=            76.1.3.4 https://dev.to/gypsydave5/the-unix-way-or-why-you-actually-want-to-use-vim-3n8p>
            76.1.3.5 <URL:#tn=            76.1.3.5>
77. <URL:#tn=77.>
78. chatgpt <URL:#tn=78. chatgpt>
    78.1  query: Error detected while processing BufReadPost Autocommands for "*.py"..FileType Autocommands for "*": <URL:#tn=    78.1  query: Error detected while processing BufReadPost Autocommands for "*.py"..FileType Autocommands for "*":>
    78.2 query: neovim fix cmp_nvim_lsp.update_capabilities is deprecated, use cmp_nvim_lsp.default_capabilities instead. See :h deprecated <URL:#tn=    78.2 query: neovim fix cmp_nvim_lsp.update_capabilities is deprecated, use cmp_nvim_lsp.default_capabilities instead. See :h deprecated>
    78.3 Query: neovim fix [LSP] Accessing client.resolved_capabilities is deprecated, update your plugins or configuration to access client.server_capabilities instead.The new key/value <URL:#tn=    78.3 Query: neovim fix [LSP] Accessing client.resolved_capabilities is deprecated, update your plugins or configuration to access client.server_capabilities instead.The new key/value>
    78.4 <URL:#tn=    78.4>
79. hebrew, utf8, encodings, tags:hebrew, utf8, encodings <URL:#tn=79. hebrew, utf8, encodings, tags:hebrew, utf8, encodings>
    79.1 vim hebrew text is shown in reverse <URL:#tn=    79.1 vim hebrew text is shown in reverse>
    79.2 <URL:#tn=    79.2>
80. <URL:#tn=80.>
.................................................END TOC..............................................






Description: 	VIM, the *best* text editor in existence. 
		My main usage of an editor is for development in languages such as PERL, PYTHON, BASH, C, C++ and JAVA.
		First came EMACS, then XEMACS, great editors in their own right, they held dominance for me over many years. 
		Later, I've experimented some with the IDEs (JBuilder, Eclipse, VC-6) and found them all lacking as editors, though Eclipse is far ahead of the rest of the IDEs.
		Last, by mistake I came upon this guy that would only work with VIM and I rememer thinkin, hey this guy is *strange*, I mean what's the deal with this editor that makes you remember a tone of stuff just to edit a simple line.
		...
		Curiosity got the best of me and I gave it a try and later...
		The understanding dawned on me.
		VIM is indeed
		the best
		editor!
		
		:)
		This file contains my accumulated knowledge of using it.

Author:		Yosi Izaq.



1. Platform specific tips

    1.1 Windows

        1.1.1 ctrl-v now working
        use ctrl-q instead

        1.1.2 ctrl-a not working
You can make CtrlA to increment in windows by opening up the 'mswin.vim' file in your vim directory and finding the section that looks like:

" CTRL-A is Select all
noremap <C-A> gggH<C-O>G
inoremap <C-A> <C-O>gg<C-O>gH<C-O>G
cnoremap <C-A> <C-C>gggH<C-O>G
onoremap <C-A> <C-C>gggH<C-O>G
snoremap <C-A> <C-C>gggH<C-O>G
xnoremap <C-A> <C-C>ggVG
Comment out all of these lines as follows:

" CTRL-A is Select all
"noremap <C-A> gggH<C-O>G
"inoremap <C-A> <C-O>gg<C-O>gH<C-O>G
"cnoremap <C-A> <C-C>gggH<C-O>G
"onoremap <C-A> <C-C>gggH<C-O>G
"snoremap <C-A> <C-C>gggH<C-O>G
"xnoremap <C-A> <C-C>ggVG
and the CtrlA keystroke will increment.

This is a pretty nice option when your keyboard doesn't have a real number pad.

for instance C:\Vim\vim80\mswin.vim
        1.1.3

    1.2 Linux

    1.3 Mac

        1.3.1 SAP MBP 2018

            1.3.1.1  install mvim

install xcode. open and accept license

sudo xcode-select -s /Applications/Xcode.app/Contents/Developer

brew install --HEAD macvim-dev/macvim/macvim

            1.3.1.2 enable gui vim
https://stackoverflow.com/questions/25978668/vim-mac-os-x-install-with-gui-support

A:
Building Vim with GUI on macOS using Homebrew:

brew edit vim.
Add a new line with option for GUI:

option "enable-gui", "Enable GUI mode"
Change from no to yes in the following line:

opts << "--enable-gui=no"
Install or re-install vim:

brew reinstall vim --enable-gui
Troubleshooting:

If you've errors related to Python 3, see: vim's GH-2754.
Checkout new Homebrew PR at GH-25785 with above patch.

ex:
    option "enable-gui", "Enable GUI mode"
    # We specify HOMEBREW_PREFIX as the prefix to make vim look in the
    # the right place (HOMEBREW_PREFIX/share/vim/{vimrc,vimfiles}) for
    # system vimscript files. We specify the normal installation prefix
    # when calling "make install".
    # Homebrew will use the first suitable Perl & Ruby in your PATH if you
    # build from source. Please don't attempt to hardcode either.
    system "./configure", "--prefix=#{HOMEBREW_PREFIX}",
                          "--mandir=#{man}",
                          "--enable-multibyte",
                          "--with-tlib=ncurses",
                          "--with-compiledby=Homebrew",
                          "--enable-cscope",
                          "--enable-terminal",
                          "--enable-perlinterp",
                          "--enable-rubyinterp",
                          "--enable-python3interp",
                          "--enable-gui=yes",
                          "--without-x",
                          "--enable-luainterp",
                          "--with-lua-prefix=#{Formula["lua"].opt_prefix}"

            1.3.1.3

        1.3.2 common mac VIM issues

            1.3.2.1 ugly colors in terminal
https://vi.stackexchange.com/questions/19021/colorscheme-not-display-correctly-for-vim-on-mac-terminal
t is very common for a fancy colorscheme (such as solarized, base16-*, you name it) to require palette changes in a terminal. Without it you will face ugly colors.

I generally avoid such colorschemes in terminals and use them only in GUI vim.

To solve it -- goto the place you have obtained colorscheme, find description on how to properly use it. Usually it is smth about changing first 16 terminal colors. Solarized example: https://github.com/altercation/solarized . There you can find how to redefine your colors for different stuff including osx terminal.

PS

There are also colorshemes that are not made with terminals in mind -- they define only gui colors.
Look for colorschemes that are compatible with the terminal and the mac OS terminal colors. Here is a list of them (search for the word "solarized"): https://github.com/rafi/awesome-vim-colorschemes

install to pathogen:
cd ~/.vim/bundle/ && git clone https://github.com/rafi/awesome-vim-colorschemes.git 
Scheme	Description	Terminal	GUI
256noir	Dark minimal colors, to avoid distraction	✓	✓
abstract	Dark theme based on Abstract app	✓	✓
afterglow	Adaptation from Sublime Text	✓	✓
alduin	Dark rustic colors	✓	✓
anderson	Dark vim colorscheme based on colors from Wes Anderson films	✓	✓
angr	Pleasant, mild, dark theme	✓	✓
ayu-vim	Simple, bright and elegant theme		✓
Apprentice	Dark, low-contrast colorscheme	✓	✓
Archery	Vim colorscheme inspired by Arch Linux colors	✓	✓
Atom	Designed to be very readable in both light and dark environments		✓
carbonized	Inspired by the Carbon keycap set	✓ (16)	✓
challenger-deep	FlatColor colorscheme	✓	✓
deep-space	Intergalactic friendly color scheme based off Hybrid	✓	✓
deus	For the late night coder	✓	✓
dogrun	Dark purple	✓	✓
flattened	Solarized, without the bullshit	✓ (16)	✓
focuspoint	Maintain color coordination and important keyword focus		✓
fogbell	Minimal grey monotone with 3 variants	✓	✓
github	Based on Github's syntax highlighting	✓	✓
gotham	Very dark vim colorscheme	✓	✓
gruvbox	Retro groove color scheme	✓	✓
happy hacking	Fairly small set of colors instead of throwing rainbows at your face	✓	✓
Iceberg	Dark blue color scheme	✓	✓
papercolor	Light and Dark color schemes inspired by Google's Material Design	✓	✓
parsec	Color scheme for people tired of solarized	✓ (16)	✓
scheakur	A light/dark colorscheme	✓	✓
hybrid	A dark colour scheme for Vim and gVim	✓	✓
hybrid-material	Material color scheme based on w0ng/vim-hybrid	✓	✓
jellybeans	Colorful, dark color scheme	✓	✓
lightning	Light vim colorscheme based on Apprentice	✓	✓
lucid	Vivid highlights and friendly, clear colors		✓
lucius	Lucius color scheme	✓	✓
materialbox	Light and dark material palette inspired based on Gruvbox		✓
meta5	Dark colorscheme, inspired by Tron	✓	✓
minimalist	Darker version of material theme inspired by Sublime Text	✓	✓
molokai	Molokai color scheme	✓	✓
molokayo	Very tweaked molokai based theme	✓	✓
mountaineer	A dark and adventurous theme	✓	✓
nord	An arctic, north-bluish clean and elegant theme	✓ (16)	✓
oceanicnext	Oceanic Next theme	✓	✓
oceanic-material	Material dark colorscheme	✓	✓
one	Adaptation of one-light and one-dark	✓	✓
onedark	Inspired by Atom's One Dark syntax theme	✓	✓
onehalf	Clean, vibrant and pleasing color scheme	✓	✓
orbital	Dark blue base16 theme	✓	✓
paramount	Minimal colorscheme that only puts emphasis on the paramount	✓	✓
pink-moon	Dark pastel theme	✓	✓
purify	Clean & vibrant color schemes for Vim, Terminals...	✓	✓
pyte	Clean, light (nearly white) theme		✓
rakr	Flat colorscheme light and dark variant	✓	✓
rdark-terminal2	Modified rdark-terminal to enhance visibility	✓	
seoul256	Low-contrast color scheme based on Seoul Colors	✓	✓
sierra	Dark vintage colors	✓	✓
solarized8	Optimized Solarized colorschemes	✓ (16)	✓
sonokai	Vivid and high contrast based on Monokai Pro	✓	✓
space-vim-dark	Dark magenta colors	✓	✓
spacecamp	Colors for the final frontier	✓	✓
sunbather	Minimal pink colorscheme	✓	✓
tender	24bit colorscheme for Vim	✓	✓
termschool	Based on the "codeschool" theme, with lots of tweaks	✓	✓
twilight256	Imitates the Twilight theme for TextMate	✓	✓
two-firewatch	A blend between duotone light and firewatch (for atom)	✓	✓
wombat256	Wombat for 256 color xterms	✓	✓

            1.3.2.2

        1.3.3
    1.4




2. common tasks
    2.1. set line numbers
	:set nu

	turn off 
	:set nonu 

	toggle
	:set nu!

    2.2 edit source code and setting to see syntax
	:syntax on

	turn it off
	:syntax off

    2.3 file operations

        2.3.1 save a copy of current file
:w ~/temp/%:t

        2.3.2 rename current file
- simple rename
!mv % new_name

- edit rename
:NERDTreeFind
m
rename

can also copy

    2.4

3. search and replace.
	3.1 basics
	
	Using the "*" key searches for the pattern under the cursor, use "#" to do the same thing backwards.
	Using the "g*" key searches for the word under the cursor, use "g#" to do the same thing backwards.

	3.2 advanced
	 most important is global replace:
        :%s/up/right/g

        and with confirmation
        :%s/up/right/gc

	and reg exp search/replace.
	first do
	:set magic
 	to allow regexp
	then search and/or replace with regexps. example:
	/^yo.i  	
	to search for yosi yoki yori etc.

	or 
	:%s/ */ /g
	replace one or more spaces with one space.

	step by step:
	3.1 simple (current line)
	:s/old/new

	3.2 replace in range of lines
	:1,10s/old/new/
	
	3.3 . for current line and $ for last:

	 To search and replace from the first line through the current line use the command:

	 :1,.s/up/right/ 

         To search and replace from the current line through the last line use the command:

	 :.,$s/up/right/ 

	3.4 replace for the whole file scope.
	To search the whole file, use the shorthand for first line and last line to create a command that processes the full file being edited and executes the search and replace.

	 :1,$s/up/right/ 
	
	And since it so common, there's a shortcut:
	:%s/up/right/

	3.5 spatial replace
The beginning or ending line for a range may be given as a positive or negative number of lines offset from the current line. To execute a search and replace on the current line and the next five lines use:

 :.,+5s/up/right/ 

To execute a search and replace from five lines above the current line through the current line use:

 :-5,.s/up/right/ 
 <Right>

To execute a search and replace from five lines above the current line through five lines below the current line use:

 :-5,+5s/up/right/ 

The range of lines must be from lowest to highest. The following command is illegal as the first address is five lines beyond the current line, and the second address is the current line.

 :+5,.s/up/right/ 
 
	3.6 global replace
	:%s/up/right/g

	and with confirmation
	:%s/up/right/gc

	3.7 advanced replaces

	There is another form of line addressing called global addressing. It is similar to the % (all lines) address, but allows you to limit the search and replace action by specifying certain text that must appear in a line before the search and replace action is applied to it. An example is show below. The syntax shown below would read "for all lines containing `some text', search for `search text' and replace any instances with `replacement text.'"

:g/some text/s/search text/replacement text/

In effect, you are requesting that two strings must be found in a line, but only one of them is to be replaced. This is probably easier to understand with an example. In Listing 6 a file of addresses contains a consistent error. Maryland zip codes have been incorrectly entered as 91042 when they should be 01042. In the sample listing, the address on the last line contains the correct zip. In this example we also make the assumption that the file is too large to edit by hand.

The first apparent solution is to globally search for all instances of 91042 and replace them with 01042. However, there are several California addresses using a correct zip code of 91042. A search and replace that replaced all instances 1042 would now result in California addresses that contain incorrect zip codes of 01042.

Listing 6

Mr. A    CA     91042
Miss B   MD     91042
Mr. C    CA     91042
Mrs. D   MD     91042
(other addresses)
Mr. X    CA     91042
Mrs. Y   MD     91042

Instead, what is needed is a method of running the search and replace for the whole file, but within the whole file, only on lines containing MD as the state.

The following command will search all lines in the file for any line containing MD. When such a line is found, it will apply the substitution rule of changing searching for 91042 and changing any instances found to 01042. The command is also given a final g option, so the search and replace will be done for all occurrences of 91042 in each line.

:g/MD/s/91042/01042/g

Substitutions only occur on the Maryland lines as in Listing 7.

Listing 7

Mr. A    CA     91042
Miss B   MD     01042
Mr. C    CA     91042
Mrs. D   MD     01042
(other addresses)
Mr. X    CA     91042
Mrs. Y   MD     01042

The limiting text criteria in a global command can also be inverted. An inverted criteria limits the search to all lines that do not contain a certain string. The inverted global command starts with :g! or :v as in the following two commands which do the same thing. They both search all lines for lines that do not contain "CA" and then substitute 01042 for 91042.

:g!/CA/s/91042/01042/g
:v/CA/s/91042/01042/g

Substitutions only occur on the lines that do not contain CA resulting in Listing 8. This is the same result as Listing 7 but arrived at from the opposite direction.

Listing 8

Mr. A    CA     91042
Miss B   MD     01042
Mr. C    CA     91042
Mrs. D   MD     01042
(other addresses)
Mr. X    CA     91042
Mrs. Y   MD     01042

There is one version of the global command that is commonly used, but it requires some explanation. First let's go back to the original substitute command. In any substitute command, the search string can be left blank. When the search string is blank, the last search string that was used in a search command is used as a default to fill in the missing search string in the current command. The following commands search from the first line to current line replacing up with right, and then search from the current line to the end of the file replacing up with left. In the second command, "up" is not entered, but defaults to the search value in the first command.

:1,.s/up/right/g
:.,$s//left/g

When using a global command, the previous search text used in a search command is, in fact, the search text just used in the global part of the command. In the following command all lines of the file are searched for "up." For each line that is found, the substitute command uses the text it has just found -- which is "up" -- as the search text and then replaces it.

:g/up/s//right/g

Please note that the previous command and the following command both do the same thing in slightly different ways.

:%s/up/right/g

The global version of the command starting with :g searches all lines for the string "up." When a line is found, the substitute command is applied to that line. The substitute command has a blank search text, so substitute looks for the last search text that was used. The last search text is the "up" used in the global command so this is used as the text. The :%s version searches all lines for "up" and replaces the string when it is found. Both of the commands perform the common function of searching an entire file for a string and replacing it. Which version of the command you use is a matter of style although some will argue that the %s version is marginally faster.

One final note before we explore the rest of the options on the substitute command is the subject of the delimiter. Any character can be used as a delimiter although the forward slash has become the accepted standard character. The following commands all do the same thing.

:%s/up/right/g
:%s$up$right$g
:%s&up&right&g

The substitute command picks up the first character after the s and assumes that it is the delimiter and uses it through the rest of the command. The character used as a delimiter cannot then appear in the search text or the replacement text as it will be seen by the substitute command as a delimiter. You should use a different delimiter when you are actually doing a search that includes looking for the delimiter character. The following command replaces the forward slash with the word "per." It uses the at sign (@) as the delimiter since the slash is part of the search text.

:%s@/@ per @g


	3.8 matching () or {}
		$

	3.9 search history
	/ ctrl+F


	3.10 Search and replace tip 31
Tip 31 Previous Next Created: March 7, 2001 Complexity: basic Author: Anon Version: 5.7 

		3.10.1 Use the :substitute command to search for a text pattern, and replace it with a text string.

There are many options, but these are what you most probably want:

:%s/foo/bar/g
    Find each occurrence of 'foo', and replace it with 'bar'. 

:%s/foo/bar/gc
    Change each 'foo' to 'bar', but ask for confirmation first. 

:%s/\<foo\>/bar/gc
    Change only whole words exactly matching 'foo' to 'bar'; ask for confirmation. 

:%s/foo/bar/gci
    Change each 'foo' (case insensitive) to 'bar'; ask for confirmation. 

:%s/foo/bar/gcI
    Change each 'foo' (case sensitive) to 'bar'; ask for confirmation. 

The g flag means global  each occurrence in the line is changed, rather than just the first.

		3.10.2 Search range: 
    The % in :%s applies the substitute to every line in the buffer, rather than just the current line. 
    :5,12s/foo/bar/g will change each 'foo' to 'bar' for all lines between line 5 and line 12. 
    :'a,'bs/foo/bar/g will change each 'foo' to 'bar' for all lines between marks a and b. 
    :.,$s/foo/bar/g will change each 'foo' to 'bar' for all lines between the current line (.) and the last line ($). 
    :.,+2s/foo/bar/g will change each 'foo' to 'bar' for the current line (.) and the two next lines (+2). 
    (Note that :%s is equivalent to :1,$s.) 

		3.10.3 When searching:

    \/ is / (use backslash + forward slash to search for forward slash) 
    \t is tab, \s is whitespace 
    \n is newline, \r is CR (carriage return = Ctrl-M = ^M) 

		3.10.4 When replacing:

    \r is newline, \n is a null byte (0x00). 
    \& is ampersand (& is the search pattern). 

		3.10.5 You can use other delimiters with substitute:

    :s#http://www.example.com/index.html#http://example.com/# 

This can be a very helpful technique, because you can avoid escaping a / character if you use something other than / for a delimiter, and some delimiters such as ; may be faster/easier to type.

		3.10.6 Save typing by using \zs and \ze to set the start and end of a pattern. 
		For example, instead of:

    :s/Copyright 2007 All Rights Reserved/Copyright 2008 All Rights Reserved/ 

You could try:

    :s/Copyright \zs2007\ze All Rights Reserved/2008/ 

		3.10.7 Using registers

:%s/foo/<c-r>a/g
    Substitute each 'foo' by the content of register 'a'. 
    <c-r>a means: Press Ctrl-R then A. The content of register 'a' will be immediately inserted. 

:%s/foo/\=@a/g
    Substitute each 'foo' by the content of register 'a'. 
    \=@a is a reference to register 'a'. The content of register 'a' will not be shown. This is useful if register 'a' contains many lines of text. 

:%s/<c-r>//bar/g
    Substitute the last search pattern (<c-r>/) by 'bar'. 
    Hint: If the substitute pattern is omitted, the last search pattern is used. See 'r' flag. 

:%s/<c-r>*/bar/g
    Substitute the visual selection (saved in the '*' register) by 'bar'. 

See Paste registers in search or colon commands instead of using the clipboard.

		3.10.8 Special cases

For substituting patterns with a corresponding case-sensitive text, Michael Geddes's keepcase plugin can be used, e.g.:

:%SubstituteCase/\cHello/goodBye/g
    Substitute 'Hello hello helLo HELLO' by 'Goodbye goodbye goodBye GOODBYE' 

For changing the offsets in a patch file (line number of a block), this little snippet can be used:

s/^@@ -\(\d\+\),\(\d\+\) +\(\d\+\),\(\d\+\) @@$/\="@@ -".eval(submatch(1)+offsetdiff).",".submatch(2)." +".eval(submatch(3)+offsetdiff).",".submatch(4)." @@"/g

Useful when we want to strip some blocks from a patch, without patch having to complain about offset differences.

NOTE ; Should try to make the expression more compact, but don't know how without having the possibility of modifying unwanted lines

	3.11 Advanced Examples

		3.11.1 Change tv[1] to tv_1
In a C Source file,
there are a bunch of variables as

tv[1]
tv[2]
....
tv[234]


I want to replace them such that first '[' is replaced by '_' and
second one deleted. So file has replaced new names as

tv_1
tv_2
...
tv_234

can somebody help me with this?

%s/tv\[/tv_/g
replaces he first but how to distinguish the second from other similar
cases.
 
Solution 1:
%s/tv\[\(\d\+\)\]/tv_\1/g

Solution 2:
%s~tv\[\([^\]]*\)\]~tv_\1~g

which means replace "tv" followed by "[" followed by anything except a "]"
and save the content between "[" and "]" in \1 by tv_ and the saved
content in \1.



	3.12 Vim search and replace, with increment

:let i=1 | g/foo/s//\=i."morestuff"/ | let i=i+1

:let i=1 | g/^Q:/s__\=i.". Q:"_ | let i=i+1

	3.13 vim search for a pattern followed by another pattern and set cursor in second pattern location

	    3.13.1 https://stackoverflow.com/questions/66658895/vim-search-first-match-after-match-of-another-pattern
The first way that came to mind (easy but not repeatable)
You can do something like this:

/Foo/;/bar
but the "last pattern" will be bar so this is not repeatable with n, N, etc. which means that you will have to do it once and then do /<Up><CR>, which may or may not satisfy your needs.

Note that, once you have jumped to the second match, you can do `` to jump back to the first one and `` to jump back to the second one, and so on.

See :help :; and :help ``.

The second way that came to mind (more complicated but repeatable)
With a single pattern, and thus repeatable with n, N, etc., you can do:

/Foo\_.\{-}\zsbar
where…

/Foo matches the next Foo,
\_.\{-} matches any character including EOL, as few as possible,
\zs starts the actual match, discarding what comes before,
which we want to be bar.
See :help \_., :help \{, and :help \zs.

	    3.13.2

	3.14
4. 	Advanced search.

	4.1 search multiple buffers. 
	:bufdo /searchstr/                : use :rewind to recommence search
	" multiple file search better but cheating
	:bufdo %s/searchstr/&/gic   : say n and then a to stop, case insensitive
	:bufdo %s/searchstr/&/gc   : say n and then a to stop, case sensitive

	4.2 Print a list of lines that match a pattern in current open buffers:
	:bufdo %g_searchstr_p

	4.3 ignore case mode (useful for searches and replacements)
	:set ic
	
	to turn off:
	:set noic

	# Double spacing:

	    * :%s/$/{ctrl-V}{CR}/g
	          This command applies an extra carriage return at the end of all lines 

	# Strip blanks at end of line:

		      * :%s/{TAB}*$// 

	# Strip DOS ctrl-M's:

		          * :1,$ s/{ctrl-V}{ctrl-M}// 


	Note: In order to enter a control character, one must first enter ctrl-v. This is true throughout vi. For example, if searching for a control character (i.e. ctrl-m): /ctrl-v ctrl-M If generating a macro and you need to enter esc without exiting the vi command line the esc must be prefixed with a ctrl-v: ctrl-v esc.

	4.4 search for non-ascii chars.

		4.4.1 Basic
Tip 791 author zzapper

Occasionally when you've pasted into Vim from some other application, you get a pesky visible non-ascii character. You can do a ga command to see what it is, but you might want to search for it or substitute it.

Here's a technique. Place the cursor on the character, then:

yl # yank one character into unnamed buffer
/<C-R>" # pull unnamed buffer contents onto search (that's Control-R)

edit References

    * :help ga
    * :help c_CTRL-R 
		4.4.2 Advanced

	/[<C-V>128-<C-V>255<C-V>01-<C-V>31]
	where <C-V> is ctrl+V.

	To clean a file from control chatacters run:
	for ^I press ctrl+v, tab
	%s_^I__g  

	for ^[ press ctrl+v, esc
	%s_^[__g

	for ^M press ctrl+v, enter
	%s_^M__g

	for ^H press ctrl+v, backspace
	%s_^H__g
	

	4.5 Search in range (block) 
You can limit the search command "/" to a certain range of lines by including
\%>l items.  For example, to match the word "limit" below line 199 and above
line 300: >
	/\%>199l\%<300llimit
Also see |/\%>l|.

Another way is to use the ":substitute" command with the 'c' flag.  Example: >
   :.,300s/Pattern//gc
This command will search from the cursor position until line 300 for
"Pattern".  At the match, you will be asked to type a character.  Type 'q' to
stop at this match, type 'n' to find the next match.

	A flavor of this is using visualization to search a certain block. Example, search inside the body of a C++ function.
	go to function, type vi{  (stands for Visualize Inside { } block)
	Then :s/Pattern//gc
	Type q to quit and n to next match

	On the same vein, its possible to search between marks:
	" To search for string between mark a and mark b:
	:'a,'bg/^/s/pattern/&/igc  

	Using visualization its possible to either visualize range and search "normally" and the search will be limited to the visualized section. Its also posisble to search in the previously visualized block using: /\%Vpattern

	4.6 Search across multiple lines

		4.6.1 http://vim.wikia.com/wiki/VimTip242
Created: May 6, 2002 Complexity: intermediate Author: vim_power

One of the most uncelebrated features of Vim is the ability to span a search across multiple lines.

\_^  matches start-of-line anywhere in search pattern
\_$  matches end-of-line anywhere in search pattern
\_s  matches a space anywhere in search pattern

e.g /{\_s will match all white spaces and new-line chars after a "{"

The \_ can be appended to other objects as well. such as \_U, \_L, \_. (this one's risky).
 References

    * :help pattern 

 Comments

To seek out HTML comments over multiple lines, for example:

<!-- foobar does
 not exist -->

Use the search:

/<!--\_p\{-}-->

We used \{-} the "few as possible" operator rather than * which is too greedy when there are many such comments in the file.

The key is of course \_p which is printable characters including EOL end-of-lines.

However, the highlighting is very erratic when the span over number of lines exceeds, say, 30. And highlighting is rather spotty when there are shifts in screen views. This is due to the default that improves highlighting performance.

If you want to ensure the most accurate highlighting, try:

:syntax sync fromstart

This can slow things down on large files with complex highlighting :help :syn-sync

For some reason <!--\_p\{-}--> doesn't work if your comments are indented (with opening and closing comment tag indented).

Here's another way to highlight HTML comments using conventional regex:

/<\!--\(.\|\n\)*-->

However, this one will spill over to the next comment if there's more than one so it's not too useful.

The TAB character is among the control chars, thus not matched with \p per default. 

			4.6.1.1 Example
To search for start_pattern.*end_pattern over possible multiple lines do:
/start_pattern\_p\{-}end_pattern

	4.6.2 Update version 12/01/2010
Vim can search for text that spans multiple lines. For example, the search /hello\_sworld finds "hello world" in a single line, and also finds "hello" ending one line, with "world" starting the next line.

This tip shows how to search over multiple lines, and presents a useful command so entering :S hello world finds "hello" followed by "world" separated by spaces or tabs or newlines, and :S! hello world allows any non-word characters, including newlines, between the words.
Contents

    * 1 Patterns including end-of-line
    * 2 Searching for multiline HTML comments
    * 3 Searching for words over multiple lines
    * 4 See also
    * 5 References
    * 6 Comments

		4.6.2.1 Patterns including end-of-line

The search /^abc finds abc at the beginning of a line, and /abc$ find abc at the end of a line. However, in /abc^def and /abc$def the ^ and $ are just ordinary characters with no special meaning. By contrast, each of the following has a special meaning anywhere in a search pattern.
\n 	a newline character
\_s 	a whitespace (space or tab) or newline character
\_^ 	the beginning of a line (zero width)
\_$ 	the end of a line (zero width)
\_. 	any character including a newline

Example searches:

/abc\n*def
    Finds abc followed by zero or more newlines then def. 
    Finds abcdef or abc followed by blank lines and def. 
    The blank lines have to be empty (no space or tab characters). 

/abc\_s*def
    Finds abc followed by any whitespace or newlines then def. 
    Finds abcdef or abc followed by blank lines and def. 
    The blank lines can contain any number of space or tab characters. 
    There may be whitespace after abc or before def. 

/abc\_$\_s*def
    Finds abc at end-of-line followed by any whitespace or newlines then def. 
    There must be no characters (other than a newline) following abc. 
    There can be any number of space, tab or newline characters before def. 

/abc\_s*\_^def
    Finds abc followed by any whitespace or newlines then def where def begins a line. 
    There must be no characters (other than a newline) before def. 
    There can be any number of space, tab or newline characters after abc. 

/abc\_$def
    Finds nothing because \_$ is "zero width" so the search is looking for abcdef where abc is also at end-of-line (which cannot occur). 

/abc\_^def
    Finds nothing because \_^ is "zero width" so the search is looking for abcdef where def is also at beginning-of-line (which cannot occur). 

/abc\_.\{-}def
    Finds abc followed by any characters or newlines (as few as possible) then def. 
    Finds abcdef or abc followed by any characters then def. 

		4.6.2.2 Searching for multiline HTML comments

It is common for comments in HTML documents to span several lines:

<!-- This comment
 covers two lines. -->

The following search finds any HTML comment:

/<!--\_.\{-}-->

The atom \_. finds any character including end-of-line. The multi \{-} matches as few as possible (stopping at the first "-->"; the multi * is too greedy and would stop at the last occurrence).

Syntax highlighting may be not be accurate, particularly with long comments. The following command will improve the accuracy when jumping in the file, but may be slower (:help :syn-sync):

:syntax sync fromstart

		4.6.2.3 Searching for words over multiple lines

The script below defines command :S that will search for a phrase, even when the words are on different lines. Examples:

:S hello world
    Searches for "hello" followed by "world", separated by whitespace including newlines. 
:S! hello world
    Searches for "hello" followed by "world", separated by any non-word characters (whitespace, newlines, punctuation). 
    Finds, for example, "hello, world" and "hello+world" and "hello ... world". The two words can be on different lines. 

After entering the command, press n or N to search for the next or previous occurrence.

Put the following in your vimrc (or in file searchmultiline.vim in your plugin directory):

" Search for the ... arguments separated with whitespace (if no '!'),
" or with non-word characters (if '!' added to command).
function! SearchMultiLine(bang, ...)
  if a:0 > 0
    let sep = (a:bang) ? '\_W\+' : '\_s\+'
    let @/ = join(a:000, sep)
  endif
endfunction
command! -bang -nargs=* -complete=tag S call SearchMultiLine(<bang>0, <f-args>)|normal! /<C-R>/<CR>

		4.6.2.4 See also

    * Search for visually selected text to search for selected text; finds targets on multiple lines 

		4.6.2.5 References

    * :help pattern 

		4.6.2.6 Comments
	4.6.3
5.  Basic VI stuff
	5.1. repeat last change.
	Using the "." key will repeat last change

	5.2 buffers
	Reload buffer, :e

	File and line number
	:f

	Buffers
	There is a general purpose buffer, and 36 named buffers. Whenever a block of text is deleted (or yanked), it is placed in the general purpose buffer. Prefixing a delete or yank action with an apostrope followed by a letter or number places the text into the buffered with that letter or number as its name. For example, the following command yanks 3 words into buffer m:

	'm3yw

	VI Paradigm
	Vi combines an action with a movement -- the action is performed on all lines or characters between the current cursor position and the destination cursor position. The general syntax is:

	number   verb   target 

	where number defaults to one, verb defaults to move, and target is implied for some verbs.
	The .vimrc file
	Each time vi starts to run, it looks for a file in your home directory called .vimrc. If it finds this file, it will execute the instructions containined within it. Thus, you can place vi commands in this file to set preferences that you want to start with in each of your vi sessions. The following is the contents of a .vimrc file that I use.

	:set ts=3
	:fixdel

	The first line sets tab spacing (ts) to 3. This causes vi to display tabs as 3 spaces rather than the common default 8 spaces. Remember, the contents of the file are not changed; only the manner in which a tab character is displayed is changed.

	The second line allows the DEL key to work as expected on PC keyboards.

	Some other settings that may be useful include the following:

	:set noautoindent
	:set nocindent
	:hi Search NONE

	The last line turns off color highlighting of strings located in searches. (Searches are done with the slash (/) character.
	VIM Commands
	Miscellaneous

	DEL     cancel operation
	ESC     leave insert mode
	^G      display file statistics in bottom line
	.       repeat last change
	:r f    read file f, place after current line
	~     -     switch case of character under cursor
	(in visual-mode: switch case of highlighted text)

	3~    -     switch case of next three characters

	g~~   -     switch case of current line

	U     -     in visual-mode: make highlighted text uppercase

	gUU   -     make current line uppercase

	u     -     in visual-mode: make highlighted text lowercase

	guu   -     make current line lowercase

	gUaw  -     make current word uppercase

	guaw  -     make current word lowercase 

	J       join current line with next

	^Vk     used in insert mode to enter keystroke k
		into the edit buffer 

	Commands inside insert mode

	^U      erase to start of insert line

	Searching

	/abc    search forward for abc
	/^abc   search for occurrances of abc 
		only at the beginning of lines
	/abc$   search for occurrances of abc 
		only at end of lines
	?abc    search backward for abc
	/A\w\+Extension  search for a pattern begins with A, one or more word letters and end with Extension.
	n       go to next occurrance in same direction
	/       same as n, but for foward searching
	N       go to next occurrance in opposite direction
	5G      go to line 5
	G       go to eof

	Substitute

	s/abc/abcd/      substitue abc with abcd
	%s/abc/abcd/g    substitute abc with abcd 
			 globally between 1,$
	s/\.doc/\.txt/   substitue .doc with .txt
			 (you must escape special characters 
			 used for regular expressions, such as ".") 

	File Commands

	:w             write file
	:w filename    write over filename
	:wq            write and quite
	ZZ             same as :wq
	:q!            quit without writing

	Delete (always places text in general buffer)

	dw     del word (from current pos to end of word)
	db     del backwards (del previous word)
	d4w    del 4 words
	dd     del current line
	3dd    del 3 lines
	'b3dd  del 3 lines into buffer b
	d^     del from current pos to beginning of line
	d$     del from current pos to end of line
	x      del char
	3x     del 3 chars
	cc     del line and enter insert mode
	dL     del lines from current pos to end of file
	d3L    del lines from current pos to 3rd line from bottom
	dG	delete until end of file
	dgg	delete until start of file

	Copy (Yank)

	y     same as d, but copies rahter than cuts

	Paste (Note: paste is from general buffer unless otherwise specified)

	p     paste after current pos
	P     paste before current pos 
	3p    paste 3 copies
	'kp   paste from buffer k
	'k3p  paste 3 copies from buffer k

	Insert

	i  enter insert mode before cursor
	a  enter insert mode after cursor
	A  enter insert mode after end of current line
	3i inserted text is replicated 3 times
	o  create new line below current line, 
	   and enter insert mode
	O  create new line above current line, 
	   and enter insert mode

	Navigate

	:5   go to line 5
	5G   go to line 5
	G    go to last line in document
	L    go to last line in screen
	5L   go to line 5 from bottom of screen
	h    left 1 char
	3h   left 3 chars
	j    down
	k    up
	l    right
	^    beginning of line
	$    end of line
	%    press % over an openning or closing bracket or 
	     parenthesis in order to jump to its closing or 
	     openning partner
	^D   scroll down one screen
	^U   scroll up one screen
	^F   go forward, like ^D, but overlap a few lines
	^B   go backward, like ^U, but overlap a few lines
	``   return to previous pos in file
	+    go to first non-white space of next line
	-    go to first non-white space of previous line
	w    beginning of next word
	e    end of word (if at end, then end of next word)
	b    back (go to beginning of previous word)

	Replace

	r  c  replace current char with c
	3r c  replace current char with 3 c's

	Undo

	u   undo previous change
	ctrl+R redo
	3u  undo last 3 changes
	U   undo changes made to current line
	:e! undo all changes since last save

	Indenting

	>>            indent line one shift width
	3>>           indent 3 lines one shift width
	:set sw=4     set shift width to 4
	:syntax off   turn off syntax recognition (and coloring)
	:syntax on    turn on syntax recognition
	:color <color scheme name> change color scheme.

	Settings

	:set ai        set autoindent
	:set noai      unset autoindent
	:set nu        show line numbers

	Customization
	Place a list of vi commands -- such as the following -- into a file called .vimrc in your home directory. These commands will be run by vi when it starts.

	:fixdel
	:set ts=3
	:set noautoindent
	:set nocindent
	:hi Search NONE
	:filetype indent off
	:filetype off

	5.4 history
		:hist prints command history
		: arrow up and down traverse history

		@: execute last command

		p: paste last command


6. Edit multiple files.
	6.1 switch to editing new file.
	:e <file name>
	
	6.2 determine current file.
	:args

	6.3 open a list of files.
	:args <file list with regexps>
	
	example.
	:args code/*.cpp myfile.h  

*/
	6.4 list buffers

	    6.4.1 simple


		:ls
		:buffers

	    6.4.2 list full pathnames of all open buffers
https://stackoverflow.com/questions/7236315/how-can-i-view-the-filepaths-to-all-vims-open-buffers

A1. 
'd have use the "simple":

echo map(filter(range(0,bufnr('$')), 'buflisted(v:val)'), 'fnamemodify(bufname(v:val), ":p")')
With:

range(0,bufnr('$')) to have a |List| of all possible buffer numbers
filter(possible_buffers, 'buflisted(v:val)') to restrict the list to the buffers that are actually listed -- you may prefer bufexist() that'll also show the help buffers, etc.
map(listed_buffer, 'nr_to_fullpath(v:val)') to transform all the buffer numbers into full pathnames
bufname() to transform a single buffer number into a (simplified) pathname
fnamemodify(pathname, ':p') to have a full absolute pathname from a relative pathname.
Change :echo to call writefile(pathname_list, 'filename'), and that's all, or to :put=, etc.


A2.
	    6.4.3
	6.5 file navigation (without plugins)
		:n for next fle
		:prev for previous.

	6.6 Open from command line


		6.6.1 Use bash expansion 
Ex: vim *.pl
or vim *.[h|c]

		6.6.2 Nuber file buffers according to date
Open all files in current dir:
gvim `\ls -lrt  | awk ' {print $NF} '`

Open all perl files in current dir:
gvim \ls -lrt  | awk ' /pl$/ {print $NF} '`

	6.7


7. Multiple windows.
	For full details:
	:h split

	7.1 create a second window.
		7.1.1 horizontal
	:split
	:sp
	:bs[N]		split to buffer N
	CTRL-W s						*CTRL-W_s*
	CTRL-W S						*CTRL-W_S*
	CTRL-W CTRL-S						*CTRL-W_CTRL-S*

		7.1.2 Vertical

		CTRL-W CTRL-V						*CTRL-W_CTRL-V*
		CTRL-W v						*CTRL-W_v*
		:[N]vs[plit] [++opt] [+cmd] [file]			*:vs* *:vsplit*
	
		7.1.3 New window

		Horizontal:
		CTRL-W n						*CTRL-W_n*
		CTRL-W CTRL_N						*CTRL-W_CTRL-N*
		:[N]new [++opt] [+cmd]					*:new*

		Vertical:
		:[N]vne[w] [++opt] [+cmd] [file]			*:vne* *:vnew*


		7.1.4 Close window

		CTRL-W q						*CTRL-W_q*
		CTRL-W CTRL-Q						*CTRL-W_CTRL-Q*
		:q[uit]		Quit current window.  When quitting the last window (not
		:q[uit]!	Quit current window.  If this was the last window for a buffer,
		:hid[e]		Quit current window, unless it is the last window on the


		7.1.5 Leave only one window open, close all windows but current

		CTRL-W o						*CTRL-W_o* *E445*
		CTRL-W CTRL-O					*CTRL-W_CTRL-O* *:on* *:only*
		:on[ly][!]	Make the current window the only one on the screen.  All other

		7.2 move between windows.
		ctrl+W

		ctrl+W {left,right,up,down}
		ctrl+W = (resize window)
		:ba (new windows for all buffers)


	7.3 close window.
	:close

	7.4 leave only this window open, closing all others.
	:only.

	7.5 create a window for a new file.
	:split <file name>

	7.6 close all windows ( buffers).
		:qa  (! force)

	7.7 Move windoes around
CTRL-W r				*CTRL-W_r* *CTRL-W_CTRL-R* *E443*
CTRL-W CTRL-R	Rotate windows downwards/rightwards.  The first window becomes
		the second one, the second one becomes the third one, etc.
		The last window becomes the first window.  The cursor remains
		in the same window.
		This only works within the row or column of windows that the
		current window is in.

						*CTRL-W_R*
CTRL-W R	Rotate windows upwards/leftwards.  The second window becomes
		the first one, the third one becomes the second one, etc.  The
		first window becomes the last window.  The cursor remains in
		the same window.
		This only works within the row or column of windows that the
		current window is in.

CTRL-W x					*CTRL-W_x* *CTRL-W_CTRL-X*
CTRL-W CTRL-X	Without count: Exchange current window with next one.  If there
		is no next window, exchange with previous window.
		With count: Exchange current window with Nth window (first
		window is 1).  The cursor is put in the other window.
		When vertical and horizontal window splits are mixed, the
		exchange is only done in the row or column of windows that the
		current window is in.

The following commands can be used to change the window layout.  For example,
when there are two vertically split windows, CTRL-W K will change that in
horizontally split windows.  CTRL-W H does it the other way around.

						*CTRL-W_K*
CTRL-W K	Move the current window to be at the very top, using the full
		width of the screen.  This works like closing the current
		window and then creating another one with ":topleft split",
		except that the current window contents is used for the new
		window.

						*CTRL-W_J*
CTRL-W J	Move the current window to be at the very bottom, using the
		full width of the screen.  This works like closing the current
		window and then creating another one with ":botright split",
		except that the current window contents is used for the new
		window.

						*CTRL-W_H*
CTRL-W H	Move the current window to be at the far left, using the
		full height of the screen.  This works like closing the
		current window and then creating another one with
		":vert topleft split", except that the current window contents
		is used for the new window.
		{not available when compiled without the +vertsplit feature}

						*CTRL-W_L*
CTRL-W L	Move the current window to be at the far right, using the full
		height of the screen.  This works like closing the
		current window and then creating another one with
		":vert botright split", except that the current window
		contents is used for the new window.
		{not available when compiled without the +vertsplit feature}

						*CTRL-W_T*
CTRL-W T	Move the current window to a new tab page.  This fails if
		there is only one window in the current tab page.
		When a count is specified the new tab page will be opened
		before the tab page with this index.  Otherwise it comes after
		the current tab page.

		
	7.7 Window resizing

CTRL-W =	Make all windows (almost) equally high and wide, but use
		'winheight' and 'winwidth' for the current window.
		Windows with 'winfixheight' set keep their height and windows
		with 'winfixwidth' set keep their width.

:res[ize] -N					*:res* *:resize* *CTRL-W_-*
CTRL-W -	Decrease current window height by N (default 1).
		If used after 'vertical': decrease width by N.

:res[ize] +N					*CTRL-W_+*
CTRL-W +	Increase current window height by N (default 1).
		If used after 'vertical': increase width by N.

:res[ize] [N]
CTRL-W CTRL-_					*CTRL-W_CTRL-_* *CTRL-W__*
CTRL-W _	Set current window height to N (default: highest possible).

z{nr}<CR>	Set current window height to {nr}.

						*CTRL-W_<*
CTRL-W <	Decrease current window width by N (default 1).

						*CTRL-W_>*
CTRL-W >	Increase current window width by N (default 1).

:vertical res[ize] [N]			*:vertical-resize* *CTRL-W_bar*
:vert res [+|-]N		Increase/decrease width by N
CTRL-W |	Set current window width to N (default: widest possible).


	
8. It is possible to use cscope from vim.
	Go to root of source code directory. 
	run $cscope -Rb
	then in vim run
	:cs add cscope.out
	Its possible to add the second step to .vimrc but my preference is to do it manauly.

	8.1
	Taken from http://cscope.sourceforge.net/cscope_vim_tutorial.html
	This is a hands-on tutorial, so open up a shell, and follow these steps:

		   -> Get and install Cscope.
		   if you don't have it already on your machine. Ideally, you will also have Vim 6.x, but you can get most of the functionality with later versions of Vim 5 (vertical splits don't work, but horizontal splits will work if you modify the maps as described in the file's comments).

		      Note: If your version of Vim wasn't compiled with '--enable-cscope', you will need to reconfigure and recompile Vim with that flag. Most Vim binaries that ship with Linux distributions have the Cscope plugin enabled.

		   -> Download the cscope_maps.vim file,
		   and arrange for it to be read by Vim at startup time. If you are using Vim 6.x, stick the file in your $HOME/.vim/plugin directory (or in any other 'plugin' subdirectory in your 'runtimepath'). If you are using Vim 5.x, you can either cut and paste the entire contents of the cscope_maps file into your $HOME/.vimrc file, or stick a "source cscope_maps.vim" line into your .vimrc file.

		   -> Go into a directory with some C code in it,
		   and enter 'cscope -R' (the '-R' makes Cscope parse all subdirectories, not just the current directory). Since we aren't passing the '-b' flag (which tells Cscope to just build the database, then exit), you will also find yourself inside Cscope's curses-based GUI. Try a couple of searches (hint: you use the arrow keys to move around between search types, and 'tab' to switch between the search types and your search results). Hit the number at the far left of a search result, and Cscope will open Vim right to that location. (unless you've set your EDITOR environment variable to something besides Vim). Exit Vim, and you'll be right back in the Cscope GUI where you left off. Nifty.

		      Alas, the Cscope interface has one big problem: you need to exit Vim each time you want to do a new search. That's where the Vim plugin comes in. Hit CTRL-D to exit Cscope.

		   -> Start up Vim.
		   If you want, you can start it with a C symbol (ex: 'vim -t main'), and you should hop right to the definition of that symbol in your code.

		   -> 
		   Put the cursor over a C symbol that is used in several places in your program. Type "CTRL-\ s" (Control-backslash, then just 's') in quick succession, and you should see a menu at the bottom of your Vim window showing you all the uses of the symbol in the program. Select one of them and hit enter, and you'll jump to that use. As with ctags, you can hit "CTRL-t" to jump back to your original location before the search (and you can nest searches and CTRL-t will unwind them one at a time).

		      Mnemonic: the '\' key is right next to the ']' key, which is used for ctags searches.

		   -> 
		   Try the same search, but this time via "CTRL-spacebar s". This time, your Vim window will split in two horizontally , and the Cscope search result will be put in the new window. [if you've never used multiple Vim windows before: move between windows via 'CTRL-W w' (or CTRL-W arrow key, or CTRL-W h/j/k/l for left/up/down/right), close a window via 'CTRL-W c' (or good old ':q'), make the current window the only one via 'CTRL-W o', split a window into two via 'CTRL-W s' (or 'CTRL-W v' for a vertical split), open a file in a new window via ':spl[it] filename']

		      Mnemonic: there's now a big, spacebar-like bar across the middle of your screen separating your Vim windows.

		   -> 
		   Now try the same search via "CTRL-spacebar CTRL-spacebar s" (just hold down the CTRL key and tap the spacebar twice). If you have trouble hitting the keys fast enough for this to work, go into the cscope_maps.vim script and change Vim's timeout settings as described in the comments [actually, I generally recommend that you turn off Vim's timeouts]. This time your Vim window will be split vertically (note: this doesn't work with Vim 5.x, as vertical splits are new with Vim 6.0).

		   ->	
		   Up to now we've only been using the keystroke maps from 'cscope_maps.vim', which all do a search for the term that happens to be under your cursor in Vim. To do Cscope searches the old-fashioned way (using Vim's built-in Cscope support), enter ":cscope find symbol foo" (or, more tersely, ":cs f s foo"). To do the horizontal split version, use ":scscope" (or just ":scs") instead (Vim 6.x only). While it's easier to use the maps if the word you want to search for is under your cursor, the command line interface lets you go to any symbol you type in, so you'll definitely want to use it at times.

		   ->	
		   So far we've only been doing one kind of search: 's', for 'find all uses of symbol X'. Try doing one of Cscope's other searches by using a different letter: 'g' finds the global definition(s) of a symbol, 'c' finds all calls to a function, 'f' opens the filename under the cursor (note: since Cscope by default parses all C header files it finds in /usr/include, you can open up most standard include files with this). Those are the ones I use most frequently, but there are others (look in the cscope_maps.vim file for all of them, and/or read the Cscope man page).

		  ->	
		  Although Cscope was originally intended only for use with C code, it's actually a very flexible tool that works well with languages like C++ and Java. You can think of it as a generic 'grep' database, with the ability to recognize certain additional constructs like function calls and variable definitions. By default Cscope only parses C, lex, and yacc files (.c, .h, .l, .y) in the current directory (and subdirectories, if you pass the -R flag), and there's currently no way to change that list of file extensions (yes, we ought to change that). So instead you have to make a list of the files that you want to parse, and call it 'cscope.files' (you can call it anything you want if you invoke 'cscope -i foofile'). An easy (and very flexible) way to do this is via the trusty Unix 'find' command:

			  find . -name '*.java' > cscope.files

		      Now run 'cscope -b' to rebuild the database (the -b just builds the database without launching the Cscope GUI), and you'll be able to browse all the symbols in your Java files. Apparently there are folks out there using Cscope to browse and edit large volumes of documentation files, which shows how flexible Cscope's parser is.

		      For larger projects, you may additionally need to use the -q flag, and/or use a more sophisticated 'find' command. See our tutorial on using Cscope with large projects for more info.

		  ->	
		  Try setting the $CSCOPE_DB environment variable to point to a Cscope database you create, so you won't always need to launch Vim in the same directory as the database. This is particularly useful for projects where code is split into multiple subdirectories. Note: for this to work, you should build the database with absolute pathnames: cd to /, and do

			  find /my/project/dir -name '*.c' -o -name '*.h' > /foo/cscope.files

		      Then run Cscope in the same directory as the cscope.files file (or use 'cscope -i /foo/cscope.files'), then set and export the $CSCOPE_DB variable, pointing it to the cscope.out file that results):

			  cd /foo
			  cscope -b
			  CSCOPE_DB=/foo/cscope.out; export CSCOPE_DB   

		      (The last command above is for Bourne/Korn/Bash shells: I've forgotten how to export variables in csh-based shells, since I avoid them like the plague).

		      You should now be able to run 'vim -t foo' in any directory on your machine and have Vim jump right to the definition of 'foo'. I tend to write little shell scripts (that just define and export CSCOPE_DB) for all my different projects, which lets me switch between them with a simple 'source projectA' command.
			BUG: in versions of Cscope prior to 15.4, there is a silly bug that may cause Vim to freeze when you do this unless you call your database something other than the default 'cscope.out': use '-f foo' in your Cscope invocation to name your database 'foo.out' instead, and you'll be OK.

		  ->	
		  That's it! Use ":help cscope" (in Vim) and/or "man cscope" (from your shell) if you've got questions, and to learn the fine points.
			8.2 last step
                        After cscope is installed you can do:
			:cs help
			:cs add [dir|file]
			:cs find symbol

9. Auto complete
	9.1 use ctrl+n to auto complete forward words and ctrl+s to auto complete backword.

	9.2 use ctrl+p to visually auto complete backward and ctr+n to visually auto complete forward.

	9.3 use ctrlX^d (hold ctrl, press X then d) to auto complete from syntax defenition.

	9.4  options 
	help in  *24.3*  Completion

        CTRL-X CTRL-F           file names
        CTRL-X CTRL-L           whole lines
        CTRL-X CTRL-D           macro definitions (also in included files)
        CTRL-X CTRL-I           current and included files
        CTRL-X CTRL-K           words from a dictionary
        CTRL-X CTRL-T           words from a thesaurus
        CTRL-X CTRL-]           tags
        CTRL-X CTRL-V           Vim command line

	9.5 from dictionary

		9.5.1 Add dictionary
		Its possible to add any kind dictionary ( a text file that contains many words either in native langauge of
				specific field of science or engineering). The easiest way to get one is to download it from the internet

			Then set in .vimrc
			:set dictionary+=[path to dictionary]

                        mac has built-in dictionary so:
set dictionary+=/usr/share/dict/words


	
		9.5.2 Complete from dictionary
		ctrl-x ctrl-k

		9.5.3 set Completion options
h 'complete'

Example:
		
if has("win32unix") "Tip will only take effect on cygwin
set complete=.,w,b,u,k
elseif  has("win32") 
set complete=.,w,b,u,k
else "Unix, where my source code is
set complete=.,w,b,u,k,i,]
endif

		9.5.4
10. Execute shell commands.
	use :!<cmd>
	for example list files :!ls

11. Working with tag libs.
	Install taglib plugin (instructions at VIM home page).
	11.1 Download the taglist.zip file and unzip the files to the $HOME/.vim or the
	    $HOME/vimfiles or the $VIM/vimfiles directory. After this step, you should
	        have the following two files (the directory structure should be preserved):

		         plugin/taglist.vim - main taglist plugin file
			          doc/taglist.txt    - documentation (help) file
	if ( pPdeVar != NULL )
	if ( pPdeVar != NULL )
	{
		if ( context->GetParam ( pPdeVar, &postureData ) == PDE_OK )
		{
			if ( postureData != NULL )
			{
				printLog ( DZLOG_INFO, "Input VAF dump START [%d] bytes", postureData->getSize() );
				int pret = printBuffOfVAFs(postureData->getValueRaw(), postureData->getSize());
				printLog ( DZLOG_INFO, "Input VAF dump END (%d)", pret );
			}
			else
			{
				printLog ( DZLOG_INFO, "Input VAF is empty" );
			}
		}
		pPdeVar = NULL;
	}
	{
		if ( context->GetParam ( pPdeVar, &postureData ) == PDE_OK )
		{
			if ( postureData != NULL )
			{
				printLog ( DZLOG_INFO, "Input VAF dump START [%d] bytes", postureData->getSize() );
				int pret = printBuffOfVAFs(postureData->getValueRaw(), postureData->getSize());
				printLog ( DZLOG_INFO, "Input VAF dump END (%d)", pret );
			}
			else
			{
				printLog ( DZLOG_INFO, "Input VAF is empty" );
			}
		}
		pPdeVar = NULL;
	}

	Refer to the |add-plugin|, |add-global-plugin| and |runtimepath| Vim
	help pages for more details about installing Vim plugins.
	11.2 Change to the $HOME/.vim/doc or $HOME/vimfiles/doc or $VIM/doc/vimfiles
					    directory, start Vim and run the ":helptags ." command to process the
					        taglist help file. Without this step, you cannot jump to the taglist help
						    topics.
	11.3 If the exuberant ctags utility is not present in your PATH, then set the
						        Tlist_Ctags_Cmd variable to point to the location of the exuberant ctags
							    utility (not to the directory) in the .vimrc file.
							    
		    11.3.1  Common issues
ctags: unrecognized option `--fields=+iaS'
        Try `ctags --help' for a complete list of options.

and
[yizaq@pmbu-dev-vm58:Tue Jan 28:852:137:/trunk/ise_13_ad_br/cpm]$ ctags -R  -f tags . 
ctags: skipping .: it is not a regular file.

- fix, use etags not ctags!
[yizaq@pmbu-dev-vm58:Tue Jan 28:853:138:/trunk/ise_13_ad_br/cpm]$ ctags --version
ctags (standalone 21.4.22)
Copyright (C) 2007 Free Software Foundation, Inc.
This program is distributed under the terms in ETAGS.README
[yizaq@pmbu-dev-vm58:Tue Jan 28:854:139:/trunk/ise_13_ad_br/cpm]$ type ctags
ctags is hashed (/usr/cisco/bin/ctags)

- while etags is
[yizaq@pmbu-dev-vm58:Mon Jan 27:744:32:/trunk/ise_13_ad_br/cpm]$ ctags --version
Exuberant Ctags 5.6, Copyright (C) 1996-2004 Darren Hiebert
  Compiled: Jul 17 2006, 11:40:44
  Addresses: <dhiebert@users.sourceforge.net>, http://ctags.sourceforge.net
  Optional compiled features: +wildcards, +regex
[yizaq@pmbu-dev-vm58:Tue Jan 28:747:35:/trunk/ise_13_ad_br/cpm]$ type ctags
ctags is hashed (/usr/bin/ctags)

		    11.3.2


	11.4 If you are running a terminal/console version of Vim and the terminal
							        doesn't support changing the window width then set the
								    'Tlist_Inc_Winwidth' variable to 0 in the .vimrc file.
	11.5 Restart Vim.
	11.6 You can now use the ":TlistToggle" command to open/close the taglist
								        window. You can use the ":help taglist" command to get more information
									    about using the taglist plugin. 
									    NOTE. make sure that .vimrc contains a line pointing to ctags.exe.
									    for example: let Tlist_Ctags_Cmd = '/usr/bin/'.'\ctags.exe' " Location of ctags


	11.7 exuberent ctags MAC
http://invisiblezero.net/tutorial-install-real-exuberant-ctags-on-mac/
download ctags source from here :
http://ctags.sourceforge.net/
 
execute these command without “sudo” :
tar xzvf <ctags package>cd ctags-5.7./configuremake
make install
This puts it in /usr/local/bin which means it avoids the ctags that comes with OS X. This is good in case Apple releases an update for it and squashes your real ctags. To make the good ctags show up first, you need it to be first in your path. If you’re using .bash_login or .bash_profile add a line like this:
export PATH=”/usr/local/bin:${PATH}”
Then you can make sure by opening a NEW terminal window and doing: which tags
It should show /usr/local/bin/ctags

My install:
525  mv ~/Downloads/ctags-5.8.tar  .
  526  tar xvfz ctags-5.8.tar 
  527  cd ctags-5.8/
  528  ./configure 
  529  make
  530  make install
  531  type ctags
  532  ctags --help
  533  ctags --version
	11.8

12. Developer commands.

	12.1 Go to definition of word under cursor	gd
Go to global definition		gD

	12.2 Find matching bracket, brace, #if, #endif	%

	12.3 Do a grep	:grep foo *.c
After grep, go to next occurrence	:cn

	12.4 Get a file (eg. an #include file) whose name is under cursor	gf

	12.5 Auto complete (in insert mode) - match forwards		Ctrl+X Ctrl+N
Auto complete (in insert mode) - match previous		Ctrl+X Ctrl+P

		12.5.1 Select an item in vim autocomplete list without inserting line break
Is there a way to select an item out of the autocomplete list without getting an additional unwanted newline?
---------------------------------------------------------------------------------------------------- 
It depends on which popup menu state you are in (see :help popupmenu-completion). I understand from your question that you're in state 2 (since you've pressed arrow keys to find a completion). However, the default behavior for Enter in state 2 is to insert the completion without newline; what you describe is normally the behavior of state 1 (which is when you use Ctrl+N/Ctrl+P.)

A way that works consistently in all states is to use Ctrl+Y. I like to remember the Y as standing for "yes, accept that word." It's also possible to just start typing the text that should come after the completed word, unless you've remapped things as in geedoubleya's answer.

In the same context, you can press Ctrl+E to cancel the menu and leave your text as it was before you invoked it. If you're used to the pairings of Ctrl+E and Ctrl+Y in other contexts (e.g. to scroll up or down in normal mode, or to insert the character below or above the cursor in insert mode), that's one way to remember it here. I guess you could also think of it as "exiting" the menu or similar.

---------------------------------------------------------------------------------------------------- 
As an alternative to using your arrow keys, enable your j & k keys to scroll through the autocomplete list.

Doing this changes the current line to match the selected word as you scroll.

Therefore you do not have to press enter as the cursor is still in insert mode at the end of the substituted word.

To enable this add this to your .vimrc (Thanks to others at stackoverflow):

inoremap <expr> j ((pumvisible())?("\<C-n>"):("j"))
inoremap <expr> k ((pumvisible())?("\<C-p>"):("k"))
Separately, instead of using the arrow keys, you could just repeat the Ctrl-n which will curse through the options (Ctrl-p to go backwards) and substitute on the current line as it moves, no need for Enter or vim key mappings.

		12.5.2


	12.6
Make an abbreviation (eg. cca = "const char *")		:ab cca const char *
Turn syntax coloring on	:syntax on
Turn syntax coloring off	:syntax off
Execute any shell command	:! command
indent selected lines with C-style indenting	=

13. Yanking (and deleting, replace 'y' with 'd')
Yank to end of line	y$
Yank to start of line	y0
Yank to word "swordfish"	y/swordfish
Yank to letter "g"	yfg
Yank entire line	Y
Yank lines 5 to 10	5,10y
Yank lines next 4 lines into register a		"a4Y
See the content of Yank registers		:registers

" appending to registers (use CAPITAL), copy to regiter, add to register.
" yank 5 lines into "a" then add a further 5 
"a5yy
10j
"A5yy


14. More search and replace
Search and replace
Change "nick" to "fred" on current line		:s/nick/fred/
Change "nick" to "fred" on the next 5 lines	:.,+4 s/nick/fred/
Change "nick" to "fred" on lines 100 to 200, all occurrences	:100,200 s/nick/fred/g
Capitalise every word in the entire file	:% s/\<./\u&/g
Capitalise first letter of first word in line		 :s/\(\w\)\+/\u&/
Insert ">" at the start of every line	:% s/^/>/
Insert "// nick" at the end of every line	:% s;$;// nick;

Special characters for line sequences:

    * . is the current line
    *     * $ is the last line
    *         * % is every line
    *             * +5 means 5 lines from current line
    *                 * -5 means 5 lines before current line 

Find lines containing "fruit" and change "apple" to "orange" on them	:g/fruit/s/apple/orange/g
Delete all blank lines	:g/^$/d
Find lines NOT containing "nick", append "oops" to them		:g! /nick/normal A oops


15. Shell and filter commands
List directory	:! ls
See processes	:! ps
Sort lines 20 to 30	:20,30 ! sort
Visualize a section the sort it with :!sort
Grep a section the sort it with :!grep something

Sort entire file	!G sort
or			:1,$!sort
or			:%!sort
Grep entire file	!G grep something

Translate next sentence to upper case	!) tr '[a-z]' '[A-Z]'
Word count file (save first)	:!wc %
				  Look up manual entry for strstr	:!man strstr
				  Insert "ls" command output into window	:r !ls

	15.1 Use filter commands to process text
http://vim.wikia.com/wiki/VimTip374
Created: November 24, 2002 Complexity: basic Author: zzapper

Here are some examples of Vim's filtering commands, showing how to get text into or out of a file.

Redirection to clipboard register + (or use any other register a-z):

:redir @+
:history
:g/fred/
  " any other commands
:redir END

Redirection to a file:

:redir >> out.txt
:registers
  " any other commands
:redir END

Store glob results in register a (must use A to append):

" Append all lines containing 'fred' to register a.
:g/fred/y A
" Append to a file (must use >>).
:'a,'b g/^Error/ . w >> errors.txt

Get output from external commands:

:r!ls     " read in output of ls (run 'ls' on Unix)
:0r!ls    " insert at start of buffer
:-r!ls    " insert before current line
:r!dir    " use 'dir' on Windows

Filter current file using an external command (these examples use sort, but note that Vim has a built-in :help :sort command which should be used to sort lines):

:%!sort -u      " use an external program to sort all lines
:'a,'b!sort -u  " same, for lines from mark a to mark b inclusive

The term "filter" means to replace lines with the result from running a program. The original lines are sent as stdin to the program, and are replaced with stdout from the program. You can also filter using motion commands or visual selection:

!}sort          " sort from cursor to end of paragraph
3!}sort         " same, 3 paragraphs
3!!sort         " sort 3 lines
V               " start visual selection of lines
(move cursor)   " select some lines
!sort           " sort the visually selected lines


Following is a Python program to sort the words on each line of standard input (each line is separately sorted).

# File sortwords.py
from sys import stdin
for line in stdin:
    print ' '.join(sorted(line.split()))

A file you are editing in Vim may include the following text:

this is a line with some words
words on each line will be sorted
fried banana and cream

Use this procedure to filter the text:

    * Press V on the first line, then jj to select three lines.
    * Type !python sortwords.py and press Enter. 

The lines are replaced with the result from running the program:

a is line some this with words
be each line on sorted will words
and banana cream fried


    * :help filter
    * :help :! 



16. Spellcheck 

    16.1  my Spellcheck config


nmap <Leader>s = :setlocal spell spelllang=en_us<CR>$
set spell
set spell spelllang=en_us

    16.2 Spellcheck Tutorials

        16.2.1 https://www.linux.com/training-tutorials/using-spell-checking-vim/
Mark Twain has been quoted as saying that he respected a person who could spell a word more than one way. Unfortunately, Twain’s enthusiasm for creative spelling isn’t widely shared today, at least in the professional world. If you need a little help in the spelling department, but prefer the old school way of editing text, you can turn to Vim’s spelling support.

Support for spell checking was added in Vim 7. Before that, a few scripts were available to hack spell checking support into Vim — or you could do what I did and use ispell or aspell, but inline spell checking is much nicer.

If you’re new to Vim and/or using Vim in text mode, it’s not obvious that Vim even supports spell checking. But it does, and it’s easy to use once you turn it on. You’ll need to be in command mode and switch to last line mode, then run this:

:set spell spelllang=en_us

You might not want to be that specific, or you might want a different region. The “en_us” specifies English, U.S. style. You might want to use “en_ca” instead, if you’re in Canada, or “en_gb” for Great Britain, or “en_au” for Australia. And, of course, this works for other languages as well.

If you’re using Vim to write code and prose, you might want to turn spell checking on only in the local buffer. To do that, use:

:setlocal spell spelllang=en_us

Once you’ve set this, Vim will highlight misspelled words. If you’re using Vim in text mode, you should see the entire word highlighted, or if you’re using Gvim, you should see a squiggly underline for any word that is misspelled.

Vim does more than just highlight misspelled words, it actually categorizes misspelled words, it also highlights rare words, words that aren’t capitalized (but should be), and words that have the wrong spelling for the specified region. For example, I’ve set Vim to check for U.S. spelling (spelllang=en_us), so it should highlight words that are spelled correctly in another region but might be considered incorrect for the local region.

Vim uses different colors for each type of word. This may vary depending on the colors you have set up in your terminal or how you have Gvim set up, but on my system I see misspelled words highlighted with red, an orange for rare words, blue for words that aren’t capitalized, and so on.

Getting tired of seeing the highlighting? You may want to turn spell checking off if you’re working with code or something like that. Use the nospell directive to turn this off:


Spell checking wouldn’t be very useful if you didn’t have any help correcting the misspelled words, or a way to tell the program that the word is actually correct. Let’s start with correcting words.

To move to a misspelled word, use ]s and [s. The ]s command will move the cursor to the next misspelled word, the [s command will move the cursor back through the buffer to previous misspelled words.

Once the cursor is on the word, use z=,
        16.2.2
    16.3 Spellcheck languages

        16.3.1 http://ftp.vim.org/vim/runtime/spell/

        16.3.2 https://github.com/nickjj/dotfiles/blob/master/.vimrc

        16.3.3

    16.4
	Updated data is at: <URL:#tn=	44.1 Start spell check>
	Following data is obsolete!!!
Save file first		:w!
Spell check it	:! ispell %
Edit fixed file		:e %

17. Visual mode
Visual mode

	17.1 visual mode intro.
	vi can be a bit difficult to follow when you are trying to do something to a block of lines (for example, do I want line 8843 through to 8903 or 8904?), so vim has a "visual mode" where you can actually see lines highlighted in inverse.


First, "mark" a block of lines (or characters) by going to the start of the block, and then using one of the following:
Character mode				v
Line mode				V
Block mode				Ctrl+V
Re-mark previous block			gv
go to start\end of visual block		o, O
replace selection			r[replacment]

The differences are:

    * Character mode - from somewhere inside one line to somewhere inside another (ie. can be a part line)
	*     * Line mode - will be whole lines
	*         * Block mode - from (say) column 5 at line 10, to column 60 in line 20 (a square block of text) 
	*
	*         Then use the cursor movement commands (search, arrow, go to line, whatever) to mark the other end of the block, and either:
	*         Do some command	(see below)
	*         Cancel visual mode	Esc
	*         Go to other end of block	o

	17.2. Other ways of establishing a visual block
	*         A word (with white space)	vaw
	*         Inner word	viw
	*         A WORD (with white space)	vaW
	*         Inner WORD	viW
	*         A sentence (with white space)		vas
	*         Inner sentence	vis
	*         A paragraph (with white space)	vap
	*         Inner paragraph	vip
	*         A ( ... ) block (includes brackets)	vab
	*         Inner ( ... ) block	vib
	*         A { ... } block (includes braces)	vaB
	*         Inner { ... } block	viB
		  also va> or  va< - entire <> block
		  also vi> or  vi< - inner <> block both work also for (, [ and {
	*
	*         A "word" is a sequence of letters, numbers, underscores. A "WORD" is a sequence that is terminated by spaces. The difference would apply in cases like a(b) - if the cursor is on "a" a "word" is "a" however a "WORD" is "a(b)".
	*

	17.3.  Here is an example, from C source code. Say you have the following code, and you want to select the code inside the inner { ... } characters. Put the cursor in the middle (eg. on CON_EDITING) and type "viB" and the "inner block" (text in bold) will be highlighted.
	*
	*
	*         if ( d->pagepoint )
	*         {
		*           if ( !pager_output(d) )
			*             {
				*                 if ( d->character
						*                     && ( d->connected == CON_PLAYING
							*                         ||   d->connected == CON_EDITING ) )
					*                                 save_char_obj( d->character );
				*                                     d->outtop = 0;
				*                                         close_socket(d, FALSE);
				*                                           }
				*                                           }
				*

				*                                           Here is another method of selecting a visual block of C code. Say we have the following code and we want to highlight everything inside the "while" loop. Put the cursor on the first "{" and type "v%". That will go into visual mode and move to the end of the block. The highlighted code will be in bold.
				*
				*
				*                                           while ( usecDelta >= 1000000 )
	*                                           {
		*                                               usecDelta -= 1000000;
		*                                                   secDelta  += 1;
		*                                                   }
		*

	17.4 Visual mode commands

		*
		*                                                   See below for meanings of notes in brackets.
		*                                                   Switch case		~
		*                                                   Delete	d
		*                                                   Change (4)	c
		*                                                   Yank	y
		*                                                   Shift right (4)	>
		*                                                   Shift left (4)	<
		*                                                   Filter through external command (1)		!
		*                                                   Filter through 'equalprg' option command (1)	=
		*                                                   Format lines to 'textwidth' length (1)	gq
		*
		*                                                   You can also do the following on the selected block:
		*                                                   Start ex command for highlighted lines (1)	:
			*                                                   Change (4)	r
			*                                                   Change	s
			*                                                   Change (2)(4)	C
			*                                                   Change (2)	S
			*                                                   Change (2)	R
			*                                                   Delete	x
			*                                                   Delete (3)	D
			*                                                   Delete (2)	X
			*                                                   Yank (2)	Y
			*                                                   Join (1)	J
			*                                                   Make uppercase	U
			*                                                   Make lowercase	u
			*                                                   Find tag	Ctrl+]
			*                                                   Block insert	I
			*                                                   Block append	A
			*
			*                                                   Notes
			*
			*                                                      1. Always whole lines
			*                                                         2. Whole lines when not using CTRL-V.
			*                                                            3. Whole lines when not using CTRL-V, delete until the end of the line when using CTRL-V.
			*                                                               4. When using CTRL-V operates on the block only. 
			*
			*                                                               An example of visual mode?
			*
			*                                                               OK, let's say we have a visual block highlighted. Try these:
			*                                                               Delete it	d
			*                                                               Copy it		Y
			*                                                               Change "apple" to "orange" in the block		:s/apple/orange/g
		:s/apple/orange/c change with confirmation in block
			*                                                               Turn into C++ comments	:s.^.//.
			*                                                               Turn into C comments	:s-^.*$-/* & */-

		17.5 Visual mode insert mode.
			17.5.1 I example:
				Do you know the I key in visual-block mode?

				Suppose you have
				let a=2
				let b=3
				let c=4

				You want to make these variables script-wise. Then you move to over a, hit <C-v>, press jj and now press I.
				You will be in insert mode before a
				Now enter s:<Esc>, and when you press <Esc>, b and c will have the s: prefix too.
				See |v_b_I|

			17.5.2 Block select
			There are lots of other neat things you can do with block selects. One of my favorites is adding a string to the end of each line... like so:

			a. Press Ctrl+V and then j (or k) to extend the selection to all the lines you want

			b. Press $. This will create a 'ragged edge' selection that extends to the right end of each line in your selection.

			c. Press A. I inserts text at the beginning of a block selection, A appends text at the end of a block selection.

			d. Type your text and press Esc.

			Presto! You could also do something like this with :.,+10s/$/newtext ... but I've become a big fan of visual selections because they avoid line counting.

			Also, the usual "c," "d," "y," and "r" commands work as you'd expect to change/delete/yank/replace stuff in blocks.
			17.6 Visualize a number of lines forwards or backwards.
			Vn[+,-]		visualize n lines forward, backwards.

			V10+		visualize 10 lines forward.

18. Marking your work

If you need to jump backwards and forwards between a couple of places you can "mark" them ...
Mark current position as "x", only works in file	mx
Go to position "x"	`x
Lowercase marks can be used in combination with operators.  For example: "d't"
deletes the lines from the cursor position to mark 't'.  Hint: Use mark 't' for
Top, 'b' for Bottom, etc..  Lowercase marks are restored when using undo and
redo.
 
For marks that work across files use mX to mark and `X to jump.
Show list of known marks	:marks

That character before the "x" is a back-quote - on my keyboard on the top-left corner, under the tilde (~) symbol. Marks can be in a different file to the current one. 

19. PLUGINS, Scripts, tags: plugins, scripts, extensions, colorschemes

    19.0 list active plugins , tags: list active plugins 

        19.0.1   list active plugins chatgpt   

To list active plugins in Vim, you can use the following command within Vim:

:scriptnames
This command will display a list of all the scripts and plugins that are currently active in your Vim session. The output will show the path to each script or plugin file loaded by Vim, and you can identify the active plugins based on their filenames or paths.

Additionally, if you're using a plugin manager like Vundle, Pathogen, or Vim-Plug, you can refer to their specific documentation or configuration files to see a list of installed and active plugins.

Here are a few examples of popular plugin managers and their respective commands to list active plugins:

Vundle:

Open your .vimrc or .vim/vimrc file.
Look for lines starting with Plugin or Bundle.
Each line represents an active plugin.
Pathogen:

Navigate to the ~/.vim/bundle directory (or your custom bundle directory).
Each subdirectory represents an active plugin.
Vim-Plug:

Open your .vimrc or .vim/vimrc file.
Look for lines starting with Plug.
Each line represents an active plugin.
Remember to save your configuration file after making any changes and restart Vim to ensure the plugins are loaded correctly.


            19.0.1.1    03/07/23 17:31:09  plugins list
To save the output of a Vim command to a file, you can use the `:redir` command in combination with the `:w` command. Here's an example:

| 1. Open the file in Vim.
| 2. Run the command and redirect the output to a file using `:redir`.
| 3. Specify the file path where you want to save the output using `:w`.
| 4. Exit the `:redir` mode using `:redir END`.

Here's an example that demonstrates how to save the output of the `:scriptnames` command to a file named "plugin_list.txt":

```
:redir > plugin_list.txt
:scriptnames
:w
:redir END
```

After running these commands, Vim will create a file named "plugin_list.txt" in the current directory (or overwrite an existing file with the same name). The file will contain the output of the `:scriptnames` command.

You can modify the file path and name as per your preference.

|  1: /Applications/MacVim.app/Contents/Resources/vim/vimrc
|  2: ~/.vimrc
|  3: ~/.vim/autoload/pathogen.vim - plugin manager
|  4: /Applications/MacVim.app/Contents/Resources/vim/runtime/filetype.vim
|  5: ~/.vim/bundle/tern_for_vim/ftdetect/tern.vim - https://github.com/ternjs/tern_for_vim
|  6: ~/.vim/bundle/ultisnips/ftdetect/snippets.vim - https://github.com/SirVer/ultisnips
|  7: ~/.vim/bundle/vim-javascript/ftdetect/flow.vim
|  8: ~/.vim/bundle/vim-javascript/ftdetect/javascript.vim - https://vimawesome.com/plugin/vim-javascript, last updated 2 years ago
|  9: /Applications/MacVim.app/Contents/Resources/vim/runtime/ftplugin.vim
| 10: /Applications/MacVim.app/Contents/Resources/vim/runtime/indent.vim
| 11: /Applications/MacVim.app/Contents/Resources/vim/runtime/syntax/syntax.vim
| 12: /Applications/MacVim.app/Contents/Resources/vim/runtime/syntax/synload.vim
| 13: /Applications/MacVim.app/Contents/Resources/vim/runtime/syntax/syncolor.vim
| 14: /Applications/MacVim.app/Contents/Resources/vim/runtime/colors/lists/default.vim
| 15: ~/.vim/colors/eva01.vim
| 16: ~/.vim/bundle/airline/plugin/airline.vim -https://github.com/vim-airline/vim-airline, better status line
| 17: ~/.vim/bundle/airline/autoload/airline/init.vim
| 18: ~/.vim/bundle/airline/autoload/airline/parts.vim
| 19: ~/.vim/bundle/ale/plugin/ale.vim - https://github.com/dense-analysis/ale , syntax checker
| 20: ~/.vim/bundle/ale/autoload/ale/events.vim
| 21: ~/.vim/bundle/AutoComplPop/plugin/acp.vim - removed
| 22: ~/.vim/bundle/AutoComplPop/autoload/acp.vim
| 23: ~/.vim/bundle/braceless/plugin/braceless.vim - text objects for python, https://github.com/tweekmonster/braceless.vim
| 24: ~/.vim/bundle/conque-term/plugin/conque_term.vim
| 25: ~/.vim/bundle/ctrlp/plugin/ctrlp.vim
| 26: ~/.vim/bundle/ctrlp/autoload/ctrlp/mrufiles.vim
| 27: ~/.vim/bundle/exvisincr/plugin/visincrPlugin.vim
| 28: ~/.vim/bundle/fzf/plugin/fzf.vim
| 29: ~/.vim/bundle/gv.vim/plugin/gv.vim
| 30: ~/.vim/bundle/largeFile/plugin/LargeFile.vim
| 31: ~/.vim/bundle/matchit/plugin/matchit.vim
| 32: ~/.vim/bundle/minibufexpl/plugin/minibufexpl.vim
| 33: ~/.vim/bundle/neodebug/plugin/NeoDebug.vim
| 34: ~/.vim/bundle/nerdtree/plugin/NERD_tree.vim
| 35: ~/.vim/pack/plugins/start/nerdtree/autoload/nerdtree.vim
| 36: ~/.vim/pack/plugins/start/nerdtree/lib/nerdtree/path.vim
| 37: ~/.vim/pack/plugins/start/nerdtree/lib/nerdtree/menu_controller.vim
| 38: ~/.vim/pack/plugins/start/nerdtree/lib/nerdtree/menu_item.vim
| 39: ~/.vim/pack/plugins/start/nerdtree/lib/nerdtree/key_map.vim
| 40: ~/.vim/pack/plugins/start/nerdtree/lib/nerdtree/bookmark.vim
| 41: ~/.vim/pack/plugins/start/nerdtree/lib/nerdtree/tree_file_node.vim
| 42: ~/.vim/pack/plugins/start/nerdtree/lib/nerdtree/tree_dir_node.vim
| 43: ~/.vim/pack/plugins/start/nerdtree/lib/nerdtree/opener.vim
| 44: ~/.vim/pack/plugins/start/nerdtree/lib/nerdtree/creator.vim
| 45: ~/.vim/pack/plugins/start/nerdtree/lib/nerdtree/flag_set.vim
| 46: ~/.vim/pack/plugins/start/nerdtree/lib/nerdtree/nerdtree.vim
| 47: ~/.vim/pack/plugins/start/nerdtree/lib/nerdtree/ui.vim
| 48: ~/.vim/pack/plugins/start/nerdtree/lib/nerdtree/event.vim
| 49: ~/.vim/pack/plugins/start/nerdtree/lib/nerdtree/notifier.vim
| 50: ~/.vim/pack/plugins/start/nerdtree/autoload/nerdtree/ui_glue.vim
| 51: ~/.vim/pack/plugins/start/nerdtree-git-plugin/nerdtree_plugin/git_status.vim
| 52: ~/.vim/pack/plugins/start/nerdtree-git-plugin/autoload/gitstatus.vim
| 53: ~/.vim/pack/plugins/start/nerdtree-git-plugin/autoload/gitstatus/log.vim
| 54: ~/.vim/pack/plugins/start/nerdtree-git-plugin/autoload/gitstatus/listener.vim
| 55: ~/.vim/pack/plugins/start/nerdtree/nerdtree_plugin/exec_menuitem.vim
| 56: ~/.vim/pack/plugins/start/nerdtree/nerdtree_plugin/fs_menu.vim
| 57: ~/.vim/pack/plugins/start/nerdtree/nerdtree_plugin/vcs.vim
| 58: ~/.vim/bundle/nerdtree/nerdtree_plugin/exec_menuitem.vim
| 59: ~/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim
| 60: ~/.vim/bundle/nerdtree/nerdtree_plugin/vcs.vim
| 61: ~/.vim/bundle/poppy.vim/plugin/poppy.vim
| 62: ~/.vim/bundle/supertab/plugin/supertab.vim
| 63: ~/.vim/bundle/surround/plugin/surround.vim
| 64: ~/.vim/bundle/syntastic/plugin/syntastic/autoloclist.vim
| 65: ~/.vim/bundle/syntastic/plugin/syntastic/balloons.vim
| 66: ~/.vim/bundle/syntastic/plugin/syntastic/checker.vim
| 67: ~/.vim/bundle/syntastic/plugin/syntastic/cursor.vim
| 68: ~/.vim/bundle/syntastic/plugin/syntastic/highlighting.vim
| 69: ~/.vim/bundle/syntastic/plugin/syntastic/loclist.vim
| 70: ~/.vim/bundle/syntastic/plugin/syntastic/modemap.vim
| 71: ~/.vim/bundle/syntastic/plugin/syntastic/notifiers.vim
| 72: ~/.vim/bundle/syntastic/plugin/syntastic/registry.vim
| 73: ~/.vim/bundle/syntastic/plugin/syntastic/signs.vim
| 74: ~/.vim/bundle/syntastic/plugin/syntastic.vim
| 75: ~/.vim/bundle/syntastic/autoload/syntastic/util.vim
| 76: ~/.vim/bundle/tagbar/plugin/tagbar.vim
| 77: ~/.vim/bundle/ultisnips/plugin/UltiSnips.vim
| 78: ~/.vim/bundle/ultisnips/autoload/UltiSnips/map_keys.vim
| 79: ~/.vim/bundle/utl/plugin/utl.vim
| 80: ~/.vim/bundle/utl/plugin/utl_rc.vim
| 81: ~/.vim/bundle/utl/plugin/utl_scm.vim
| 82: ~/.vim/bundle/utl/plugin/utl_uri.vim
| 83: ~/.vim/bundle/vim-angry/plugin/angry.vim
| 84: ~/.vim/bundle/vim-cursorword/plugin/cursorword.vim
| 85: ~/.vim/bundle/vim-easymotion/plugin/EasyMotion.vim
| 86: ~/.vim/bundle/vim-jsonpath/plugin/jsonpath.vim
| 87: ~/.vim/bundle/vim-multiple-cursors/plugin/multiple_cursors.vim
| 88: ~/.vim/bundle/vim-obsession/plugin/obsession.vim
| 89: ~/.vim/bundle/vim-signature/plugin/signature.vim
| 90: ~/.vim/bundle/vim-signature/autoload/signature/utils.vim
| 91: ~/.vim/bundle/vim-snippets/plugin/vimsnippets.vim
| 92: ~/.vim/bundle/vim-startify/plugin/startify.vim
| 93: ~/.vim/bundle/vim-table-mode/plugin/table-mode.vim
| 94: ~/.vim/bundle/vimspector/plugin/vimspector.vim
| 95: ~/.vim/bundle/working-set.vim/plugin/working-set-vim8.vim
| 96: ~/.vim/bundle/working-set.vim/plugin/working-set.vim
| 97: ~/.vim/bundle/YouCompleteMe/plugin/youcompleteme.vim
| 98: /Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/getscriptPlugin.vim
| 99: /Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/gzip.vim
|100: /Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/logiPat.vim
|101: /Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/manpager.vim
|102: /Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/matchparen.vim
|103: /Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/netrwPlugin.vim
|104: /Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/rrhelper.vim
|105: /Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/spellfile.vim
|106: /Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/tarPlugin.vim
|107: /Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/tohtml.vim
|108: /Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/vimballPlugin.vim
|109: /Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/zipPlugin.vim
|110: ~/.vim/pack/airblade/start/vim-gitgutter/plugin/gitgutter.vim
|111: ~/.vim/pack/airblade/start/vim-gitgutter/autoload/gitgutter/utility.vim
|112: ~/.vim/pack/airblade/start/vim-gitgutter/autoload/gitgutter/highlight.vim
|113: ~/.vim/pack/bundle/start/vim-dirdiff/plugin/dirdiff.vim
|114: ~/.vim/pack/plugins/start/nerdtree/plugin/NERD_tree.vim
|115: ~/.vim/pack/plugins/start/supertab/plugin/supertab.vim
|116: ~/.vim/pack/plugins/start/traces.vim/plugin/traces.vim
|117: ~/.vim/pack/plugins/start/undotree/plugin/undotree.vim
|118: ~/.vim/pack/plugins/start/vim-visual-multi/plugin/visual-multi.vim
|119: ~/.vim/pack/plugins/start/vim-visual-multi/autoload/vm/plugs.vim
|120: ~/.vim/pack/plugins/start/vim-visual-multi/autoload/vm/maps.vim
|121: ~/.vim/pack/plugins/start/vim-visual-multi/autoload/vm/maps/all.vim
|122: ~/.vim/bundle/vim-signature/after/plugin/signature.vim
|123: ~/.vim/bundle/ultisnips/after/plugin/UltiSnips_after.vim
|124: /Applications/MacVim.app/Contents/Resources/vim/runtime/ftplugin/python.vim
|125: /Applications/MacVim.app/Contents/Resources/vim/runtime/indent/python.vim
|126: /Applications/MacVim.app/Contents/Resources/vim/runtime/syntax/python.vim
|127: ~/.vim/bundle/airline/autoload/airline/extensions.vim
|128: ~/.vim/bundle/airline/autoload/airline/extensions/quickfix.vim
|129: ~/.vim/bundle/airline/autoload/airline.vim
|130: ~/.vim/bundle/airline/autoload/airline/extensions/netrw.vim
|131: ~/.vim/bundle/airline/autoload/airline/extensions/term.vim
|132: ~/.vim/bundle/airline/autoload/airline/extensions/ctrlp.vim
|133: ~/.vim/bundle/airline/autoload/airline/extensions/undotree.vim
|134: ~/.vim/bundle/airline/autoload/airline/extensions/hunks.vim
|135: ~/.vim/bundle/airline/autoload/airline/extensions/tagbar.vim
|136: ~/.vim/bundle/airline/autoload/airline/extensions/csv.vim
|137: ~/.vim/bundle/airline/autoload/airline/extensions/syntastic.vim
|138: ~/.vim/bundle/airline/autoload/airline/extensions/ale.vim
|139: ~/.vim/bundle/airline/autoload/airline/extensions/whitespace.vim
|140: ~/.vim/bundle/airline/autoload/airline/extensions/po.vim
|141: ~/.vim/bundle/airline/autoload/airline/extensions/wordcount.vim
|142: ~/.vim/bundle/airline/autoload/airline/extensions/keymap.vim
|143: ~/.vim/bundle/airline/autoload/airline/extensions/obsession.vim
|144: ~/.vim/bundle/airline/autoload/airline/section.vim
|145: ~/.vim/bundle/airline/autoload/airline/highlighter.vim
|146: ~/.vim/bundle/airline/autoload/airline/themes/dark.vim
|147: ~/.vim/bundle/airline/autoload/airline/themes.vim
|148: ~/.vim/bundle/airline/autoload/airline/util.vim
|149: ~/.vim/bundle/airline/autoload/airline/builder.vim
|150: ~/.vim/bundle/airline/autoload/airline/extensions/default.vim
|151: ~/.vim/bundle/syntastic/autoload/syntastic/log.vim
|152: ~/.vim/bundle/ale/autoload/ale.vim
|153: ~/.vim/bundle/ale/autoload/ale/util.vim
|154: ~/.vim/bundle/ale/autoload/ale/linter.vim
|155: ~/.vim/bundle/ale/ale_linters/python/bandit.vim
|156: ~/.vim/bundle/ale/ale_linters/python/cspell.vim
|157: ~/.vim/bundle/ale/autoload/ale/handlers/cspell.vim
|158: ~/.vim/bundle/ale/ale_linters/python/flake8.vim
|159: ~/.vim/bundle/ale/ale_linters/python/flakehell.vim
|160: ~/.vim/bundle/ale/ale_linters/python/jedils.vim
|161: ~/.vim/bundle/ale/ale_linters/python/mypy.vim
|162: ~/.vim/bundle/ale/ale_linters/python/prospector.vim
|163: ~/.vim/bundle/ale/ale_linters/python/pycln.vim
|164: ~/.vim/bundle/ale/ale_linters/python/pycodestyle.vim
|165: ~/.vim/bundle/ale/ale_linters/python/pydocstyle.vim
|166: ~/.vim/bundle/ale/ale_linters/python/pyflakes.vim
|167: ~/.vim/bundle/ale/ale_linters/python/pylama.vim
|168: ~/.vim/bundle/ale/ale_linters/python/pylint.vim
|169: ~/.vim/bundle/ale/ale_linters/python/pylsp.vim
|170: ~/.vim/bundle/ale/ale_linters/python/pyre.vim
|171: ~/.vim/bundle/ale/ale_linters/python/pyright.vim
|172: ~/.vim/bundle/ale/ale_linters/python/refurb.vim
|173: ~/.vim/bundle/ale/ale_linters/python/ruff.vim
|174: ~/.vim/bundle/ale/autoload/ale/fix/registry.vim
|175: ~/.vim/bundle/ale/ale_linters/python/unimport.vim
|176: ~/.vim/bundle/ale/ale_linters/python/vulture.vim
|177: ~/.vim/bundle/ale/autoload/ale/engine.vim
|178: ~/.vim/bundle/ale/autoload/ale/semver.vim
|179: ~/.vim/bundle/ale/autoload/ale/command.vim
|180: ~/.vim/bundle/ale/autoload/ale/job.vim
|181: ~/.vim/bundle/ale/autoload/ale/history.vim
|182: ~/.vim/bundle/ctrlp/autoload/ctrlp/utils.vim
|183: ~/.vim/bundle/vim-signature/autoload/signature/sign.vim
|184: ~/.vim/bundle/vim-signature/autoload/signature/mark.vim
|185: ~/.vim/pack/airblade/start/vim-gitgutter/autoload/gitgutter.vim
|186: ~/.vim/bundle/syntastic/syntax_checkers/python/bandit.vim
|187: ~/.vim/bundle/syntastic/syntax_checkers/python/flake8.vim
|188: ~/.vim/bundle/syntastic/syntax_checkers/python/pyflakes.vim
|189: ~/.vim/bundle/syntastic/syntax_checkers/python/frosted.vim
|190: ~/.vim/bundle/syntastic/syntax_checkers/python/mypy.vim
|191: ~/.vim/bundle/syntastic/syntax_checkers/python/pep257.vim
|192: ~/.vim/bundle/syntastic/syntax_checkers/python/pep8.vim
|193: ~/.vim/bundle/syntastic/syntax_checkers/python/prospector.vim
|194: ~/.vim/bundle/syntastic/syntax_checkers/python/py3kwarn.vim
|195: ~/.vim/bundle/syntastic/syntax_checkers/python/pycodestyle.vim
|196: ~/.vim/bundle/syntastic/syntax_checkers/python/pydocstyle.vim
|197: ~/.vim/bundle/syntastic/syntax_checkers/python/pylama.vim
|198: ~/.vim/bundle/syntastic/syntax_checkers/python/pylint.vim
|199: ~/.vim/bundle/syntastic/syntax_checkers/python/python.vim
|200: ~/.vim/pack/airblade/start/vim-gitgutter/autoload/gitgutter/async.vim
|201: ~/.vim/pack/airblade/start/vim-gitgutter/autoload/gitgutter/debug.vim
|202: ~/.vim/bundle/vim-cursorword/autoload/cursorword.vim
|203: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim
|204: ~/.vim/bundle/ale/autoload/ale/cursor.vim
|205: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme/filetypes.vim
|206: ~/.vim/pack/airblade/start/vim-gitgutter/autoload/gitgutter/hunk.vim
|207: ~/.vim/bundle/tagbar/autoload/tagbar.vim
|208: ~/.vim/bundle/tagbar/autoload/tagbar/debug.vim
|209: ~/.vim/bundle/ale/autoload/ale/statusline.vim
|210: ~/.vim/bundle/ale/autoload/ale/python.vim
|211: ~/.vim/bundle/ale/autoload/ale/path.vim
|212: ~/.vim/bundle/ale/autoload/ale/lsp_linter.vim
|213: ~/.vim/bundle/ale/autoload/ale/sign.vim
|214: ~/.vim/bundle/ale/autoload/ale/list.vim
|215: ~/.vim/bundle/ale/autoload/ale/highlight.vim
|216: ~/.vim/bundle/ale/autoload/ale/virtualtext.vim
|217: ~/.vim/bundle/ultisnips/autoload/UltiSnips.vim
|218: ~/.vim/pack/plugins/start/traces.vim/autoload/traces.vim
|219: ~/.vim/bundle/vimspector/autoload/vimspector.vim
|220: /Applications/MacVim.app/Contents/Resources/vim/runtime/scripts.vim
|221: /Applications/MacVim.app/Contents/Resources/vim/runtime/autoload/dist/script.vim
|222: ~/.vim/pack/plugins/start/nerdtree/syntax/nerdtree.vim
|223: ~/.vim/bundle/nerdtree/syntax/nerdtree.vim
|224: ~/.vim/pack/plugins/start/nerdtree-git-plugin/after/syntax/nerdtree.vim
|225: ~/.vim/pack/plugins/start/nerdtree-git-plugin/autoload/gitstatus/util.vim
|226: ~/.vim/pack/plugins/start/nerdtree-git-plugin/autoload/gitstatus/job.vim
|227: /Applications/MacVim.app/Contents/Resources/vim/runtime/ftplugin/qf.vim
|228: /Applications/MacVim.app/Contents/Resources/vim/runtime/syntax/qf.vim
|229: /Applications/MacVim.app/Contents/Resources/vim/runtime/autoload/python.vim

            19.0.1.2

        19.0.2


	19.1 bufexplorer
		\be - open explorer
		\bs - open explorer in split horizontal window
		\bv - open in split vertival window
		Once the explorer is open you can perform various operations on the buffers. You can sort (by MRU (default), buffer number, buffer name, or full file path) in forward or reverse order. You can delete buffers. You as see toggle the full directory paths on your buffers. You can select a buffer to open by using the keyboard to select the buffer or by double-clicking the mouse on the selected buffer. You can even open the selected buffer in a new window is you would like. If you need help while in the explorer press the '?' key. And finally to quit the explorer, press the <esc> key...

		If you would like more detailed information, please take a look at the supplied documentation. 
	
	19.2 csupport (C/CPP plugin)
		19.2.1 To get help
			:h csupport
			:h csupport-usage-vim

		19.2.2 Shortcuts

			19.2.2.1 Comments
  -- Comments -----------------------------------------------------------

  \cl       end-of-line comment                 (n,v,i)
  \cj       adjust end-of-line comment(s)       (n,v,i)
  \cs       set end-of-line comment column      (n)
  \c*       code -> comment /* */               (n,v)
  \c/       code -> comment //                  (n,v)
  \co       comment -> code                     (n,v)
  \cfr      frame comment                       (n,i)
  \cfu      function comment                    (n,i)
  \cme      method description                  (n,i)
  \cca      class description                   (n,i)
  \cd       date                                (n,i)
  \ct       date \& time                        (n,i)

			19.2.2.2 Statements
  -- Statements ---------------------------------------------------------

  \sd       do { } while                        (n,v,i)
  \sf       for                                 (n,i)
  \sfo      for { }                             (n,v,i)
  \si       if                                  (n,i)
  \sif      if { }                              (n,v,i)
  \sie      if else                             (n,v,i)
  \sife     if { } else { }                     (n,v,i)
  \sw       while                               (n,i)
  \swh      while { }                           (n,v,i)
  \ss       switch                              (n,v,i)
  \sc       case                                (n,i)
  \s{       { }                                 (n,v,i)

			19.2.2.3 Preprocessor
  -- Preprocessor -------------------------------------------------------

  \p<      $#include <>$                        (n,i)
  \p"      $#include ""$                        (n,i)
  \pd      $#define$                            (n,i)
  \pu      $#undef$                             (n,i)
  \pie     $#if$$#else #endif$                  (n,v,i)
  \pid     $#ifdef #else #endif$                (n,v,i)
  \pin     $#ifndef #else #endif$               (n,v,i)
  \pind    $#ifndef #def #endif$                (n,v,i)
  \pi0     $#if 0 #endif$                       (n,v,i)
  \pr0      remove$#if 0 #endif$                (n) 

			19.2.2.4 Idioms
  -- Idioms -------------------------------------------------------------

  \if       function                            (n,v,i)
  \isf      static function                     (n,v,i)
  \im       main()                              (n,v,i)
  \i0       for( x=0; x<n; x+=1 )               (n,v,i)
  \in       for( x=n-1; x>=0; x-=1 )            (n,v,i)
  \ie       enum   + typedef                    (n,i)
  \is       struct + typedef                    (n,i)
  \iu       union  + typedef                    (n,i)
  \ip       printf()                            (n,i)
  \isc      scanf()                             (n,i)
  \ica      p=calloc()                          (n,i)
  \ima      p=malloc()                          (n,i)
  \isi      sizeof()                            (n,v,i)
  \ias      assert()                            (n,v,i)
  \ii       open input file                     (n,i)
  \io       open output file                    (n,i)

			19.2.2.5 Snippets
  -- Snippets -----------------------------------------------------------

  \nr       read code snippet                   (n)
  \nw       write code snippet                  (n,v)
  \ne       edit code snippet                   (n)
  \np       pick up prototype                   (n,v)
  \ni       insert prototype(s)                 (n)
  \nc       clear  prototype(s)                 (n)
  \ns       show   prototype(s)                 (n)

			19.2.2.6 C++
  -- C++ ----------------------------------------------------------------

  \+m       method implementation               (n,i)
  \+c       class                               (n,i)
  \+cn      class (using new)                   (n,i)
  \+tm      template method implementation      (n,i)
  \+tc      template class                      (n,i)
  \+tcn     template class (using new)          (n,i)
  \+tf      template function                   (n,i)
  \+ec      error class                         (n,i)
  \+tr      try ... catch                       (n,v,i)
  \+ca      catch                               (n,v,i)
  \+c.      catch(...)                          (n,v,i)


			19.2.2.7 Run
  -- Run ----------------------------------------------------------------

  \rc       save and compile                    (n)
  \rl       link                                (n)
  \rr       run                                 (n)
  \ra       set comand line arguments           (n)
  \rm       run make                            (n)
  \rg       cmd. line arg. for make             (n)
  \rp       run splint                          (n)
  \ri       cmd. line arg. for splint           (n)
  \rk       run CodeCheck (TM)                  (n)
  \re       cmd. line arg. for CodeCheck (TM)   (n)
  \rd       run indent                          (n,v)
  \rh       hardcopy buffer                     (n,v)
  \rs       show plugin settings                (n)
  \rx       set xterm size                      (n, only Linux/UNIX & GUI)
  \ro       change output destination           (n)
  \rt       rebuild templates                   (n)



	19.3. Python (python.vim)
		To install add this line to .vimrc:
		au FileType python source path/python.vim 

		Most common commands:
		"   [[      -- Jump to beginning of block
		"   ]]      -- Jump to end of block
		"   ]v      -- Select (Visual Line Mode) block
		"   ]<      -- Shift block to left
		"   ]>      -- Shift block to right
		"   ]c      -- Select current/previous class
		"   ]f      -- Select current/previous function
		"   ]<up>   -- Jump to previous line with the same/lower indentation
		"   ]<down> -- Jump to next line with the same/lower indentation

	19.4 Mini Buffer Explorer (minibufexpl.vim)
		To install: Copy minibufexpl.vim into your plugin directory. Or :source minibufexpl.vim. That is all you need to get started. 

		Usage:
		You can quickly switch buffers by double-clicking the appropriate "tab" (if you don't want to use the mouse just put the cursor on the "tab" and press enter). As you open and close buffers the tabs get updated. Buffers that are modified get visually marked and buffers that are open in a window get visually marked. The -MiniBufferExplorer- opens automatically when you open more than one eligible buffer (no need to open the explorer if youre only editing one file.) -MiniBufExplorer- doesn't bother showing non-modifiable or hidden buffers. You can delete buffers by selecting them and pressing d on the keyboard.

		When you are in the -MiniBufExplorer- window, Tab and Shift-Tab move forward and backward respectively through the buffer list.

		There are a growing number of optional features in this script that are enabled by letting variables in your .vimrc:

		  control + the vim direction keys [hjkl] can be made to move you between windows.
		    control + arrow keys can be made to do the same thing
		      control + tab & shift + control + tab can be setup to switch through your open windows (like in MS Windows)
		        control + tab & shift + control + tab can alternatively be setup to cycle forwards and backwards through your modifiable buffers in the current window 

 <Leader>mbe - Opens MiniBufExplorer
 <Leader> is usually backslash so type "\mbe" 

 Other keymappings include: <Leader>mbc to close the Explorer
 "               window,  <Leader>mbu to force the Explorer to Update and
 "               <Leader>mbt to toggle the Explorer window; it will open if
 "               closed or close if open. Each of these key bindings can be
 "               overridden (see the notes on <Leader>mbe above.)
 " 

	19.5 C reference (CRefVim)
		19.5.1. Usage
	<Leader>cr normal mode:  get help for word under cursor
	Memory aid cr: (c)-(r)eference
	<Leader>cr visual mode:  get help for visually selected text
	Memory aid cr: (c)-(r)eference
	<Leader>cw:              prompt for word CRefVim should search for
	Memory aid cw: (c)-reference (w)hat
	<Leader>cc:              jump to table of contents of the C-reference manual
	Memory aid cc: (c)-reference (c)ontents
	Note: by default <Leader> is \, e.g. press \cr to invoke C-reference

	Note: The best way to search for an operator (++, --, %, ...) is to visually select it and press <Leader>cr.

	To get help do :help crefvimdoc
	To show the C-reference manual do :help crefvim

	19.5 perl plugin ( perlsupport)
		19.5.1 h perlsupport
		
		19.5.2 Usefull shortcuts

			  \cl     Line End Comment
			  \cf     Frame Comment
			  \cu     Function Description
			  \ch     File Header (*.pl)
			  \ce     File Header (*.pm)
			  \ca     File Header (*.t)
			  \cc     code to comment
			  \co     comment to code
			  \cd     Date
			  \ct     Date & Time

			  -- Statements ----------------------------

			  \af     for { }
			  \ao     foreach { }
			  \ai     if { }
			  \ae     if { } else { }
			  \aw     while { }
			  \a{     { }

			  -- Idioms --------------------------------

			  \dm     my $;
			  \dy     my $ = ;
			  \d,     my ( $, $ );
			  \d1     my @;
			  \d2     my @ = (,,);
			  \d3     my %;
			  \d4     my % = (=>,=>,);
			  \d5     my $regex_ = '';
			  \d6     my $regex_ = qr//;
			  \d7     $ =~ m//
			  \d8     $ =~ s///
			  \d9     $ =~ tr///
			  \dp     print "...\n";
			  \df     printf ("...\n");
			  \ds     subroutine
			  \di     open input file
			  \do     open output file
			  \de     open pipe

	19.6 Latex plugin (latex suite).
		19.6.1.
			Installation.
			extract tarball to .vim 

			Add to .vimrc
			" REQUIRED. This makes vim invoke latex-suite when you open a tex file.
			filetype plugin on

			" IMPORTANT: win32 users will need to have 'shellslash' set so that latex
			" can be called correctly.
			set shellslash

			" IMPORTANT: grep will sometimes skip displaying the file name if you
			" search in a singe file. This will confuse latex-suite. Set your grep
			" program to alway generate a file-name.
			set grepprg=grep\ -nH\ $*

			" OPTIONAL: This enables automatic indentation as you type.
			filetype indent on

			To install the included latex-suit.txt and latexhelp.txt files as vim help files, start vim and do the following:

			helptags ~/.vim/doc    

			"
		19.6.2. Help.
			:help latex-suite.txt
	19.7 TagExplorer
		To activate it:
		:TagExplorer

	19.8 SpellChecker
		19.8.1 help
			:h spell

		19.8.2 basics
		Tip. save your file first. Also sometimes this only works after doing :h spell.
			:SPCheck		<Leader>sc	Turn spell checking on/off
			:SPInteract		<Leader>si	Interactively step through errors
			:SPHarvest		<Leader>sh	Harvest all errors to user dictionary

	19.9 cppomnicomplete plugin.
		19.9.1 First steps
                Installation.
			Build exuberent CTAGS db with:
			$ ctags -R --c++-kinds=+p --fields=+iaS --extra=+q  --languages=c++  -f tags .
			in case of error in sorting do:
			sort -u -o tags tags 

			Or you can add a map in your |.vimrc| file, eg: >

			        map <C-F12> :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q
		19.9.2 Usage
			$ :tselect MyClass
			$ myObject. wait and select tag from if list.
			$ myObject.<C-X><C-O>

	19.10 Bash plugin
	for help :h bashsupport 

		usage w/o GUI
			
			The frequently used constructs can be inserted with key mappings.  The
			mappings are also described in the document bash-hot-keys.pdf (reference card,
			part of this package).
			Hint: Typing speed matters. The combination of a leader ('\') and the
			following character(s) will only be recognized for a short time.


			  -- Load / Unload bash Support -------------------------

			  \lbs    Load Bash Support    (normal)
			  \ubs    Unload Bash Support  (normal)

			  -- Comments -------------------------------------------

			  \cl     Line End Comment                (normal)
			  \cf     Frame Comment                   (normal)
			  \cu     Function Description            (normal)
			  \ch     File Header                     (normal)
			  \ckb    Keyword comment BUG             (normal)
			  \ckt    Keyword comment TODO            (normal)
			  \ckr    Keyword comment TRICKY          (normal)
			  \ckw    Keyword comment WARNING         (normal)
			  \ckn    Keyword comment New_Keyword     (normal)
			  \cc     code to comment                 (normal, visual)
			  \co     comment to code                 (normal, visual)
			  \cd     Date                            (normal)
			  \ct     Date & Time                     (normal)
			  \ce     echo "..."                      (normal)
			  \cr     remove echo "..."               (normal)
			  \cv     vim modeline                    (normal)
							     
			  -- Statements ------------------------------------------

			  \ac     case in ... esac                (normal)
			  \al     elif then                       (normal)
			  \af     for in do done                  (normal, visual)
			  \ai     if then fi                      (normal, visual)
			  \ae     if then else fi                 (normal, visual)
			  \as     select in do done               (normal, visual)
			  \at     until do done                   (normal, visual)
			  \aw     while do done                   (normal, visual)
			  \ao     echo -e "..."                   (normal, visual)

			  -- Run ------------------------------------------------

			  \rr     update file, run script         (normal)
			  \rc     update file, check syntax       (normal)
			  \ra     set command line arguments      (normal)
			  \rd     start debugger                  (normal)
			  \re     make script executable          (normal)
			  \rh     hardcopy buffer to FILENAME.ps  (normal)
			  \rs     settings and hot keys           (normal)
			  \rt     set xterm size                  (normal)
			  \ro     change output destination       (normal)

			  -- bash help ------------------------------------------

			  \h      display help for the builtin    (normal)
				  under the cursor


			File bash-hot-keys.pdf contains a reference card for these key mappings.
			Multiline inserts and code snippets will be indented after insertion.

			The hot keys are defined in the file type plugin sh.vim (part of this
			bash-support plugin package).
			
	19.11 show Marks plugin:
			Visibly show marks in vi.

			By default the following keymappings are defined:
			\mt : Toggles ShowMarks on and off.
			\mh : Hides an individual mark.
			\ma : Hides all marks in the current buffer.
			\mm : Places the next available mark. 

	19.12 UTL, URL-based hyperlinking
		Type :help utl-start
		To find help <URL:#r=help>
		To find the examples, <URL:#tn=EXAMPLES>
		To jump to unix KB, <URL:../knowledge_base_unix>
		To jump to unix KB crontab section, <URL:../knowledge_base_unix#tn=crontab>
		To go to web URL, <URL:http://www.vim.org/>

		19.12.1. Ver2.0 and below
		id=help Type :help utl-start

			 19.12.2. Hit \gu on the live examples given there
				Hit ctrl+o to come back.

			  As a reader of texts containing URLs that's all! As an author you have to
			  know how to write URLs. But utl.vim gives you a training. And what you
			  will learn is 90% general knowlegde about URLs that you can use elsewhere.

			* Utl.vim is friendly:
			  No side effects, fits seamlessly into your Vim Session, well documented.


			EXAMPLES

			Here are some simplistic examples. Assume you have the following stuff in a file and
			execute the URL under the cursor with command \gu (all URLs can be with or without
			<URL:...> embedding):

			* Call your web browser (setup with a smart utility) and display www.vim.org

					    URL with embedding (and syntax highlighting)...
			    <URL:http://www.vim.org>;
					    ...or without embedding...
			    http://www.vim.org
					    ...or rudimentary URL
			    www.vim.org

			* Call your mailer

			    mailto:stb@bf-consulting.de
			    stb@bf-consulting.de
			    stb@bf-consulting.de?Subject=UTL&Cc=bram@moolenaar.net

			* Link to a local file to be displayed in a Vim window...
			  (This is a bit like Vim's gf command, but portable and indepent of 'path' setting
			  and cwd)

			    ///file:/home/stb/.vimrc    or
			    /home/stb/.vimrc

					    foo.txt in same directory as file containing this link
			    foo.txt   or            
			    ./foo.txt
					    bar.txt in sibbling directory of file containing this link
			    ../sib/bar.txt  

			* ...with fragment
			  (This is a bit like tags, but theres is no tags file)

					    jump to specific position in target file foo.txt by searching
					    searchString (use this to turn phrases like "see in file foo.txt
					    and search for searchString" into hotlinks) ...
			    foo.txt#searchString
					    ...or direct addressing of a line...
			    foo.txt#line=123
					    ...or refer to the anchor `id=myIdentifier'
			    foo.txt#r=myIdentifier  
					    ...or without a file, i.e. refers to current document (use this
					    to turn phrases like "see below" into hotlinks)
			    #searchString        

			* Link to a local file displayed by a handler application

					    hand over to MS Word (or Open Office, depending on the media type
					    handler you setup in UTL)
			    foo.doc
					    typically call Acrobat Reader
			    foo.pdf                
					    typically call IrfanView or XnView
			    foo.jpg                

			* Link to a directory

					    call Vim-Explorer or call Windows Explorer or DOS box or Unix shell
					    (with directory properly set)
			    dir/  or                
			    dir

			* Embed Vim commands in text

					    switch colorscheme (perhaps maintain an annotated file with all Vim
					    schemes available?)
			    <URL:vimscript:colors peachpuff>
					    open all folds (perhaps into your plugin for users who don't know
					    how to use folds)
			    <URL:vimscript:normal zR>

					    reference the Vim help (perhaps into the source code of your own
					    plugins to explain certain constructs)...
			    <URL:vimhelp:expr-==>  
					    ...again combined with a fragment to precisely address the exact
					    position
			    <URL:vimhelp:expr-==#^since a string>

			* Command line command :Gu to execute URLs:

					    same as first example ( or may I already speak UTL to you:
					    `same as #tp=browser ' :-)
			    :Gu www.vim.org        
					    Open Windows Explorer (or whatever) displaying the directory where
					    the current file is in (on Windows very convenient in your daily
					    click click struggle)
			    :Gu .                  

			The UTL documentation contains lots of practical examples and usage patterns.

			[keywords: hypertext, hyperlink]

		19.12.3 More examples

			    #tn=text	    Same as #text
			    #tp=text	    Stand for `t'ext `p'revious, i.e. define position by
					    searching first occurance of `text' in backward direction.
			    #line=123	    Position defined by line number. Most useful for documents
					    which won't change
			    #r=identifier   Position defined by the id `identifier'


			    file:	# Protocol for accessing local files.
					# If machine is given works like `ftp:'
			    ftp:	# Delegates to http, assuming that the browser handles this.
			    http:	# Delegates call to your web browser
			    https:	# Delegates call to your web browser
			    mailto:	# Delegates call to your mail client
			    man:	# Unix Man Pages scheme (see |utl-usesourcecode| for usage)
			    scp:	# If you have a scp command
			    vimscript:	# Vim specific. A scheme for executing vim commands. See
					# |utl-exvs| for usage.
			    vimhelp:	# Vim specific. About the same as vimscript:help.  See
					# |utl-exvimhelp| for usage.
			    config:	# Protocol for accessing Utl's setup file

		19.12.4 Ver 3.x

			19.12.4.1 aaa

			19.12.4.2 Suggested mappings
"--- Suggested mappings for most frequent commands  [id=suggested_mappings] [
"
" nmap <unique> <Leader>ge :Utl openLink underCursor edit<CR>
" nmap <unique> <Leader>gu :Utl openLink underCursor edit<CR>
" nmap <unique> <Leader>gE :Utl openLink underCursor split<CR>
" nmap <unique> <Leader>gS :Utl openLink underCursor vsplit<CR>
" nmap <unique> <Leader>gt :Utl openLink underCursor tabedit<CR>
" nmap <unique> <Leader>gv :Utl openLink underCursor view<CR>
" nmap <unique> <Leader>gr :Utl openLink underCursor read<CR>
"
"					[id=suggested_mappings_visual]
" vmap <unique> <Leader>ge "*y:Utl openLink visual edit<CR>
" vmap <unique> <Leader>gu "*y:Utl openLink visual edit<CR>
" vmap <unique> <Leader>gE "*y:Utl openLink visual split<CR>
" vmap <unique> <Leader>gS "*y:Utl openLink visual vsplit<CR>
" vmap <unique> <Leader>gt "*y:Utl openLink visual tabedit<CR>
" vmap <unique> <Leader>gv "*y:Utl openLink visual view<CR>
" vmap <unique> <Leader>gr "*y:Utl openLink visual read<CR>
"
"
" nmap <unique> <Leader>cfn :Utl copyFileName underCursor native<CR>
" nmap <unique> <Leader>cfs :Utl copyFileName underCursor slash<CR>
" nmap <unique> <Leader>cfb :Utl copyFileName underCursor backSlash<CR>
"
" vmap <unique> <Leader>cfn "*y:Utl copyFileName visual native<CR>
" vmap <unique> <Leader>cfs "*y:Utl copyFileName visual slash<CR>
" vmap <unique> <Leader>cfb "*y:Utl copyFileName visual backSlash<CR>
"
"
" nmap <unique> <Leader>cl :Utl copyLink underCursor<CR>
"
" vmap <unique> <Leader>cl "*y:Utl copyLink visual<CR>
"
"]



"
	19.13 DrawIt, Draw ASCII diagrams.
		distributed as a vimball (see :help vimball)

		19.13.1 First steps
                install
			vim DrawIt.vba.gz
			:so %
			:q

		19.13.2 Usage
			\di to start DrawIt and
			\ds to stop  DrawIt. 

			When DrawIt has been started you may use the number pad to leave a trail of dashes, vertical bars, etc.  The lines will be expanded as needed to accomodate your drawing.  DrawIt can also draw boxes and ellipses on a blank-filled area (DrawIt can produce these) which can be useful for drawing boxes around comments.

		19.13.3. Commands

			Supported Features
			   <left>       move and draw left
			   <right>      move and draw right, inserting lines/space as needed
			   <up>         move and draw up, inserting lines/space as needed
			   <down>       move and draw down, inserting lines/space as needed
			   <s-left>     move left
			   <s-right>    move right, inserting lines/space as needed
			   <s-up>       move up, inserting lines/space as needed
			   <s-down>     move down, inserting lines/space as needed
			   <space>      toggle into and out of erase mode
			   >            draw -> arrow
			   <            draw <- arrow
			   ^            draw ^  arrow
			   v            draw v  arrow
			   <pgdn>       replace with a \, move down and right, and insert a \
			   <end>        replace with a /, move down and left,  and insert a /
			   <pgup>       replace with a /, move up   and right, and insert a /
			   <home>       replace with a \, move up   and left,  and insert a \
			   \>           draw fat -> arrow
			   \<           draw fat <- arrow
			   \^           draw fat ^  arrow
			   \v           draw fat v  arrow
			   \a           draw arrow based on corners of visual-block
			   \b           draw box using visual-block selected region
			   \e           draw an ellipse inside visual-block
			   \f           fill a figure with some character
			   \h           create a canvas for \a \b \e \l
			   \l           draw line based on corners of visual block
			   \s           adds spaces to canvas
			   <leftmouse>  select visual block
			<s-leftmouse>  drag and draw with current brush (register)
			   \ra ... \rz  replace text with given brush/register
			   \pa ...      like \ra ... \rz, except that blanks are considered
					to be transparent 

	19.14 VisIncr, create columns of increasing numbers, dates, etc.
:he visincr-examples

|	LEFT JUSTIFIED INCREMENTING EXAMPLES
|	:I                              :I 2            *ex-visincr-I*
|	            Use ctrl-V to                   Use ctrl-V to
|	Original    Select, :I          Original    Select, :I 2
|	   8            8                  8            8
|	   8            9                  8            10
|	   8            10                 8            12
|	   8            11                 8            14
|	   8            12                 8            16
|
|	:I -1                           :I -2
|	            Use ctrl-V to                   Use ctrl-V to
|	Original    Select, :I -1       Original    Select, :I -3
|	   8            8                  8            8
|	   8            7                  8            5
|	   8            6                  8            2
|	   8            5                  8            -1
|	   8            4                  8            -4
|
|	RIGHT JUSTIFIED INCREMENTING EXAMPLES
|	:II                             :II 2           *ex-visincr-II*
|	            Use ctrl-V to                   Use ctrl-V to
|	Original    Select, :II         Original    Select, :II 2
|	   8             8                 8             8
|	   8             9                 8            10
|	   8            10                 8            12
|	   8            11                 8            14
|	   8            12                 8            16
|
|	:II -1                          :II -2
|	            Use ctrl-V to                   Use ctrl-V to
|	Original    Select, :II -1      Original    Select, :II -3
|	   8            8                  8             8
|	   8            7                  8             5
|	   8            6                  8             2
|	   8            5                  8            -1
|	   8            4                  8            -4
|
|	DATE INCREMENTING EXAMPLES
|	:IMDY                                   *ex-visincr-IMDY*
|	          Use ctrl-V to                   Use ctrl-V to
|	Original  Select, :IMDY         Original  Select, :IMDY 7
|	06/10/03     6/10/03            06/10/03     6/10/03
|	06/10/03     6/11/03            06/10/03     6/11/03
|	06/10/03     6/12/03            06/10/03     6/12/03
|	06/10/03     6/13/03            06/10/03     6/13/03
|	06/10/03     6/14/03            06/10/03     6/14/03
|
|
|	:IYMD                                   *ex-visincr-IYMD*
|	          Use ctrl-V to                   Use ctrl-V to
|	Original  Select, :IYMD         Original  Select, :IYMD 7
|	03/06/10    03/06/10            03/06/10    03/06/10
|	03/06/10    03/06/11            03/06/10    03/06/17
|	03/06/10    03/06/12            03/06/10    03/06/24
|	03/06/10    03/06/13            03/06/10    03/07/ 1
|	03/06/10    03/06/14            03/06/10    03/07/ 8
|
|
|	:IDMY                                   *ex-visincr-IDMY*
|	          Use ctrl-V to                   Use ctrl-V to
|	Original  Select, :IDMY         Original  Select, :IDMY 7
|	10/06/03    10/06/03            10/06/03    10/06/03
|	10/06/03    11/06/03            10/06/03    17/06/03
|	10/06/03    12/06/03            10/06/03    24/06/03
|	10/06/03    13/06/03            10/06/03     1/07/03
|	10/06/03    14/06/03            10/06/03     8/07/03
|
|
|	ALPHABETIC INCREMENTING EXAMPLES
|	:IA                                     *ex-visincr-IA*
|	          Use ctrl-V to                 Use ctrl-V to
|	Original  Select, :IA         Original  Select, :IA 2
|	   a)          a)                A)           A)
|	   a)          b)                A)           C)
|	   a)          c)                A)           E)
|	   a)          d)                A)           G)
|
|	DAYNAME INCREMENTING EXAMPLES
|	:ID                                     *ex-visincr-ID*
|	          Use ctrl-V to                 Use ctrl-V to
|	Original  Select, :ID         Original  Select, :ID 2
|	  Sun       Sun                 Sun         Sun
|	  Sun       Mon                 Sun         Tue
|	  Sun       Tue                 Sun         Thu
|	  Sun       Wed                 Sun         Sat
|	  Sun       Thu                 Sun         Mon
|
|
|	:ID
|	          Use ctrl-V to                 Use ctrl-V to
|	Original  Select, :ID         Original  Select, :ID 2
|	 Sunday     Sunday             Sunday     Sunday
|	 Sunday     Monday             Sunday     Monday
|	 Sunday     Tuesday            Sunday     Tuesday
|	 Sunday     Wednesday          Sunday     Wednesday
|	 Sunday     Thursday           Sunday     Thursday
|
|	MONTHNAME INCREMENTING EXAMPLES
|	:IM                                     *ex-visincr-IM*
|	          Use ctrl-V to                 Use ctrl-V to
|	Original  Select, :IM         Original  Select, :IM 2
|	  Jan       Jan                 Jan       Jan
|	  Jan       Feb                 Jan       Mar
|	  Jan       Mar                 Jan       May
|	  Jan       Apr                 Jan       Jul
|	  Jan       May                 Jan       Sep
|
|	:IM
|	          Use ctrl-V to                 Use ctrl-V to
|	Original  Select, :IM         Original  Select, :IM 2
|	 January    January            January    January
|	 January    February           January    March
|	 January    March              January    May
|	 January    April              January    July
|	 January    May                January    September

	19.15 a.vim : Alternate Files quickly 
		:A switches to the header file corresponding to the current file being edited (or vise versa)
		(note, same as :e %<.h )
		:AS splits and switches
		:AV vertical splits and switches
		:AT new tab and switches
		:AN cycles through matches
		:IH switches to file under cursor
		:IHS splits and switches
		:IHV vertical splits and switches
		:IHT new tab and switches
		:IHN cycles through matches
		<Leader>ih switches to file under cursor
		<Leader>is switches to the alternate file of file under cursor (e.g. on  <foo.h> switches to foo.cpp)
		<Leader>ihn cycles through matches 

	19.16 dbext.vim : Provides database access to 10 dbms (Oracle, Sybase, SQL Server, MySQL, DBI,...) 

		19.16.1 First steps
                Install
		Copy the plugin/dbext.vim script to your $HOME/.vim/plugin (or $VIM/vimfiles/plugin for windows) directory.  Copy the autoload/dbext.vim script to your $HOME/.vim/autoload (or $VIM/vimfiles/autoload for windows) directory.  Copy the autoload/dbext_dbi.vim script to your $HOME/.vim/autoload (or $VIM/vimfiles/autoload for windows) directory.  Copy dbext.txt to your $HOME/.vim/doc (or $VIM/vimfiles/doc for windows) directory.
To update the Vim Help, run:
:helptags $HOME/.vim/doc  (Unix)
:helptags $VIM/vimfiles/doc  (Windows)

		19.16.2 Tutorial
		A tutorial has been added to help you become familiar with the features of the plugin, :h dbext-tutorial.

		19.16.3 Connection Profiles
You can create as many profiles as you like in your vimrc.  Each profile specifies various connection information.  Each buffer can be connected to a different database.   The plugin will automatically prompt the user for connection information.  If you have defined profiles in your vimrc, for ease of use,  you can choose from a numbered list.

		19.16.4 Object Completion
dbext ties into Vim dictionary feature.  You can complete table names, procedure names and view names using the i_CTRL-X_CTRL-K feature. 

		19.16.5 FileType Support
SQL can be used from a variety of languages.  Each development language (PHP, Perl, Java, ...) language has different syntax for creating SQL statements that are sent to the database.  dbext has support for several
different filetypes, so that it can understand and correctly parse a SQL statement.

The current supported languages are:
        PHP, Java, JSP, JavaScript, JProperties, Perl, SQL, Vim

For example assume you had the following Java code:
String mySQL =
    "SELECT s.script, ts.event, t.name                  " +
    "     , s.script_language, sv.name                  " +
    "  FROM ml_script s, ml_table_script ts, ml_table t " +
                "     , ml_script_version sv                        " +
    " WHERE s.script_id   = " + script_version +
    "   AND ts.version_id = "+obj.method() +
    "   AND ts.table_id   = t.table_id                  ";

If you visually select from the "SELECT ... to the "; and ran
:'<,'>DBExecSQL    (or used the default map <Leader>se)

The Java filetype support would concatenate each individual string into one
single string.  In this case it removed the " + " and concatenated  the
lines to result in the following (assuming this is on one line):
       SELECT s.script, ts.event, t.name , s.script_language, sv.name
       FROM ml_script s, ml_table_script ts, ml_table t
                  , ml_script_version sv
      WHERE s.script_id   = " + script_version + "
        AND ts.version_id = "+obj.method() +"
        AND ts.table_id   = t.table_id

Next, it will prompt you for replacement values for the various variables or  objects you used in the string.
Assuming you had the default behaviour turned on, you would be prompted  to supply a value for:
                " + script_version + "
                "+obj.method() +"

So assuming you entered:
                100
                'Project_Yahoo'

Then the resulting string sent to your database would be (again, this would technically be on one line):
       SELECT s.script, ts.event, t.name , s.script_language, sv.name
       FROM ml_script s, ml_table_script ts, ml_table t
                  , ml_script_version sv
      WHERE s.script_id   = 100
        AND ts.version_id = 'Project_Yahoo'
        AND ts.table_id   = t.table_id

Benefit:  
You did not have to test your SQL by cutting and pasting it into a separate tool and replacing all the object and host variables yourself.  Just by visually selecting the string and running the command DBExecSQL (or the default mapping <Leader>se) the SQL statement was executed against the database and allowed to you enter host variables.

		19.16.5 Additional Commands
DBExecSQL - Enter any command you want sent to the database
DBExecRangeSQL - Enter any range of statements you want executed
Select  - Enter the remainder of a select (ie :Select * from customer)
Call  - Call a stored procedure
Update  - Enter the remainder of an update
Insert  - Enter the remainder of an insert
Delete  - Enter the remainder of an delete
Drop    - Enter the remainder of a drop
Alter   - Enter the remainder of an alter
Create  - Enter the remainder of a create

	19.16 VJDE, java plugin

		19.16.1 description:
		:h vjde

	19.17 surround.vim : Delete/change/add parentheses/quotes/XML-tags/much more with ease
http://www.vim.org/scripts/script.php?script_id=1697

		19.17.1 Description
Surround.vim is all about "surroundings": parentheses, brackets, quotes, XML tags, and more.  The plugin provides mappings to easily delete, change and add such surroundings in pairs.  While it works under Vim 6, much of the functionality requires Vim 7.

Examples follow.  It is difficult to provide good examples in the variable width font of this site; check the documentation for more.

Press cs"' (that's c, s, double quote, single quote) inside

"Hello world!"

to change it to

'Hello world!'

Now press cs'<q> to change it to

<q>Hello world!</q>

To go full circle, press cst" to get

"Hello world!"

To remove the delimiters entirely, press ds" .

Hello world!

Now with the cursor on "Hello", press ysiw] (iw is a text object).

[Hello] world!

Let's make that braces and add some space (use "}" instead of "{" for no space): cs]{

{ Hello } world!

Now wrap the entire line in parentheses with yssb or yss) .

({ Hello } world!)

Revert to the original text: ds{ds)

Hello world!

Emphasize hello: ysiw<em>

<em>Hello</em> world!

Finally, let's try out visual mode. Press a capital V (for linewise visual mode)
followed by S<p class="important">.

<p class="important">
  <em>Hello</em> world!
</p>

This plugin is very powerful for HTML and XML editing, a niche which currently seems underfilled in Vim land.  (As opposed to HTML/XML *inserting*, for which many plugins are available).  Adding, changing, and removing pairs of tags simultaneously is a breeze.

The "." command will work with ds, cs, and yss if you install repeat.vim, vimscript #2136.

All feedback appreciated.  I am particularly interested to hear back on the following topics:

How exactly should indenting be handled?  Is the current s/S distinction useful, or should we just always reindent with =?

Is the s mapping annoying in visual mode? While you can just use c to get the original s function, does it still interfere with motor memory?  This can be disabled if you provide your own map instead, but would this be a good default?

Is the open/closing brace == add/don't add whitespace worth maintaining, or would it be better to just type an extra space before the brace to get said whitespace?

		19.17.2 Install
Extract to ~/.vim, or ~\vimfiles (Windows).  You'll need to regenerate helptags (fill in the install path below)

:helptags ~/.vim/doc

	19.18 DirDiff
https://github.com/will133/vim-dirdiff
http://www.vim.org/scripts/script.php?script_id=102


		19.18.1 Description
		description
This is a utility that performs a recursive diff on two directories and generate a diff "window".  Based on that window you can perform various diff operations such as opening two files in Vim's diff mode, copy the file or directory recursively to the other, or remove the directory tree from the source directory.

		19.18.2 Install
With pathogen.vim:

cd ~/.vim/bundle
git clone git://github.com/will133/vim-dirdiff

With Vim 8+'s default packaging system:
mkdir -p ~/.vim/pack/bundle/start
cd ~/.vim/pack/bundle/start
git clone git://github.com/will133/vim-dirdiff

(I got connection refused for git: so ran $ git clone https://github.com/will133/vim-dirdiff.git )
		19.18.3 Usage
Doing the following will generate a diff window.

      :DirDiff <A:Src Directory> <B:Src Directory>
  e.g.
      :DirDiff ../something/dir1 /usr/bin/somethingelse/dir2

  The following commands can be used inside the diff window:
  'Enter','o' - Diff open: open the diff file(s) where your cursor is at
  's' - Synchronize the current diff.  You can also select
        a range (through visual) and press 's' to synchronize differences
        across a range.

|        - There are 6 Options you can choose when you hit 's':
|          1. A -> B
|             Copy A to overwrite B
|             If A's file actually points to a directory, it'll copy it to B
|             recursively.
|          2. B -> A
|             Copy B to overwrite A
|             If B's file actually points to a directory, it'll copy it to A
|             recursively.
|          3. Always A
|             For the rest of the items that you've selected,
|             synchronize like (1).
|          4. Always B
|             For the rest of the items that you've selected,
|             synchronize like (2).
|          5. Skip
|             Skip this diff entry.
|          6. Cancel
|             Quit the loop and exit.
|
  'u' - Diff update: update the diff window
  'x' - Sets the exclude pattern, separated by ','
  'i' - Sets the ignore pattern, separated by ','
  'a' - Sets additional arguments for diff, eg. -w to ignore white space,
        etc.
  'q' - Quit DirDiff
  
  The following comamnds can be used in the Vim diff mode
  \dg - Diff get: maps to :diffget<CR>
  \dp - Diff put: maps to :diffput<CR>
  \dj - Diff next: (think j for down)
  \dk - Diff previous: (think k for up)

  You can set the following DirDiff variables.  You can add the following
  "let" lines in your .vimrc file.

  Sets default exclude pattern:
      let g:DirDiffExcludes = "CVS,*.class,*.exe,.*.swp"

  Sets default ignore pattern:
      let g:DirDiffIgnore = "Id:,Revision:,Date:"

  If DirDiffSort is set to 1, sorts the diff lines.
      let g:DirDiffSort = 1

  Sets the diff window (bottom window) height (rows)
      let g:DirDiffWindowSize = 14

  Ignore case during diff
      let g:DirDiffIgnoreCase = 0

  Dynamically figure out the diff text.  If you are using and i18n version
  of diff, this will try to get the specific diff text during runtime.  It's
  turned off by default.  If you are always targetting a specific version of
  diff, you can turn this off and set the DirDiffText* variables
  accordingly.
      let g:DirDiffDynamicDiffText = 0

  String used for the English equivalent "Files "
      let g:DirDiffTextFiles = "Files "

  String used for the English equivalent " and "
      let g:DirDiffTextAnd = " and "

  String used for the English equivalent " differ")
      let g:DirDiffTextDiffer = " differ"

  String used for the English equivalent "Only in ")
      let g:DirDiffTextOnlyIn = "Only in "

      "

		19.18.4 demo
cd ~/temp/
[i500695@WYLQRXL9LQ:2022-05-26 18:11:28:~/temp:]2021$ mkdir b
[i500695@WYLQRXL9LQ:2022-05-26 18:11:34:~/temp:]2022$ cd b
[i500695@WYLQRXL9LQ:2022-05-26 18:11:51:~/temp/b:]2025$ touch {a..z}{a..z}
[i500695@WYLQRXL9LQ:2022-05-26 18:12:05:~/temp/b:]2027$ cd ..
[i500695@WYLQRXL9LQ:2022-05-26 18:12:09:~/temp:]2028$ mkdir c
[i500695@WYLQRXL9LQ:2022-05-26 18:12:11:~/temp:]2029$ cd c
[i500695@WYLQRXL9LQ:2022-05-26 18:12:13:~/temp/c:]2030$ touch {a..y}{a..y}
[i500695@WYLQRXL9LQ:2022-05-26 18:12:31:~/temp/c:]2031$ cd ..
[i500695@WYLQRXL9LQ:2022-05-26 18:12:33:~/temp:]2032$ ls b c
b:
aa		bx		du		fr		ho		jl		li		nf		pc		qz		sw		ut		wq		yn
ab		by		dv		fs		hp		jm		lj		ng		pd		ra		sx		uu		wr		yo
ac		bz		dw		ft		hq		jn		lk		nh		pe		rb		sy		uv		ws		yp
ad		ca		dx		fu		hr		jo		ll		ni		pf		rc		sz		uw		wt		yq
ae		cb		dy		fv		hs		jp		lm		nj		pg		rd		ta		ux		wu		yr
af		cc		dz		fw		ht		jq		ln		nk		ph		re		tb		uy		wv		ys
ag		cd		ea		fx		hu		jr		lo		nl		pi		rf		tc		uz		ww		yt
ah		ce		eb		fy		hv		js		lp		nm		pj		rg		td		va		wx		yu
ai		cf		ec		fz		hw		jt		lq		nn		pk		rh		te		vb		wy		yv
aj		cg		ed		ga		hx		ju		lr		no		pl		ri		tf		vc		wz		yw
ak		ch		ee		gb		hy		jv		ls		np		pm		rj		tg		vd		xa		yx
al		ci		ef		gc		hz		jw		lt		nq		pn		rk		th		ve		xb		yy
am		cj		eg		gd		ia		jx		lu		nr		po		rl		ti		vf		xc		yz
an		ck		eh		ge		ib		jy		lv		ns		pp		rm		tj		vg		xd		za
ao		cl		ei		gf		ic		jz		lw		nt		pq		rn		tk		vh		xe		zb
ap		cm		ej		gg		id		ka		lx		nu		pr		ro		tl		vi		xf		zc
aq		cn		ek		gh		ie		kb		ly		nv		ps		rp		tm		vj		xg		zd
ar		co		el		gi		if		kc		lz		nw		pt		rq		tn		vk		xh		ze
as		cp		em		gj		ig		kd		ma		nx		pu		rr		to		vl		xi		zf
at		cq		en		gk		ih		ke		mb		ny		pv		rs		tp		vm		xj		zg
au		cr		eo		gl		ii		kf		mc		nz		pw		rt		tq		vn		xk		zh
av		cs		ep		gm		ij		kg		md		oa		px		ru		tr		vo		xl		zi
aw		ct		eq		gn		ik		kh		me		ob		py		rv		ts		vp		xm		zj
ax		cu		er		go		il		ki		mf		oc		pz		rw		tt		vq		xn		zk
ay		cv		es		gp		im		kj		mg		od		qa		rx		tu		vr		xo		zl
az		cw		et		gq		in		kk		mh		oe		qb		ry		tv		vs		xp		zm
ba		cx		eu		gr		io		kl		mi		of		qc		rz		tw		vt		xq		zn
bb		cy		ev		gs		ip		km		mj		og		qd		sa		tx		vu		xr		zo
bc		cz		ew		gt		iq		kn		mk		oh		qe		sb		ty		vv		xs		zp
bd		da		ex		gu		ir		ko		ml		oi		qf		sc		tz		vw		xt		zq
be		db		ey		gv		is		kp		mm		oj		qg		sd		ua		vx		xu		zr
bf		dc		ez		gw		it		kq		mn		ok		qh		se		ub		vy		xv		zs
bg		dd		fa		gx		iu		kr		mo		ol		qi		sf		uc		vz		xw		zt
bh		de		fb		gy		iv		ks		mp		om		qj		sg		ud		wa		xx		zu
bi		df		fc		gz		iw		kt		mq		on		qk		sh		ue		wb		xy		zv
bj		dg		fd		ha		ix		ku		mr		oo		ql		si		uf		wc		xz		zw
bk		dh		fe		hb		iy		kv		ms		op		qm		sj		ug		wd		ya		zx
bl		di		ff		hc		iz		kw		mt		oq		qn		sk		uh		we		yb		zy
bm		dj		fg		hd		ja		kx		mu		or		qo		sl		ui		wf		yc		zz
bn		dk		fh		he		jb		ky		mv		os		qp		sm		uj		wg		yd		{a-z}{a-z}
bo		dl		fi		hf		jc		kz		mw		ot		qq		sn		uk		wh		ye
bp		dm		fj		hg		jd		la		mx		ou		qr		so		ul		wi		yf
bq		dn		fk		hh		je		lb		my		ov		qs		sp		um		wj		yg
br		do		fl		hi		jf		lc		mz		ow		qt		sq		un		wk		yh
bs		dp		fm		hj		jg		ld		na		ox		qu		sr		uo		wl		yi
bt		dq		fn		hk		jh		le		nb		oy		qv		ss		up		wm		yj
bu		dr		fo		hl		ji		lf		nc		oz		qw		st		uq		wn		yk
bv		ds		fp		hm		jj		lg		nd		pa		qx		su		ur		wo		yl
bw		dt		fq		hn		jk		lh		ne		pb		qy		sv		us		wp		ym

c:
aa	aw	bt	cq	dn	ek	fh	ge	hb	hx	iu	jr	ko	ll	mi	nf	oc	oy	pv	qs	rp	sm	tj	ug	vd	wa	ww	xt	yq
ab	ax	bu	cr	do	el	fi	gf	hc	hy	iv	js	kp	lm	mj	ng	od	pa	pw	qt	rq	sn	tk	uh	ve	wb	wx	xu	yr
ac	ay	bv	cs	dp	em	fj	gg	hd	ia	iw	jt	kq	ln	mk	nh	oe	pb	px	qu	rr	so	tl	ui	vf	wc	wy	xv	ys
ad	ba	bw	ct	dq	en	fk	gh	he	ib	ix	ju	kr	lo	ml	ni	of	pc	py	qv	rs	sp	tm	uj	vg	wd	xa	xw	yt
ae	bb	bx	cu	dr	eo	fl	gi	hf	ic	iy	jv	ks	lp	mm	nj	og	pd	qa	qw	rt	sq	tn	uk	vh	we	xb	xx	yu
af	bc	by	cv	ds	ep	fm	gj	hg	id	ja	jw	kt	lq	mn	nk	oh	pe	qb	qx	ru	sr	to	ul	vi	wf	xc	xy	yv
ag	bd	ca	cw	dt	eq	fn	gk	hh	ie	jb	jx	ku	lr	mo	nl	oi	pf	qc	qy	rv	ss	tp	um	vj	wg	xd	ya	yw
ah	be	cb	cx	du	er	fo	gl	hi	if	jc	jy	kv	ls	mp	nm	oj	pg	qd	ra	rw	st	tq	un	vk	wh	xe	yb	yx
ai	bf	cc	cy	dv	es	fp	gm	hj	ig	jd	ka	kw	lt	mq	nn	ok	ph	qe	rb	rx	su	tr	uo	vl	wi	xf	yc	yy
aj	bg	cd	da	dw	et	fq	gn	hk	ih	je	kb	kx	lu	mr	no	ol	pi	qf	rc	ry	sv	ts	up	vm	wj	xg	yd
ak	bh	ce	db	dx	eu	fr	go	hl	ii	jf	kc	ky	lv	ms	np	om	pj	qg	rd	sa	sw	tt	uq	vn	wk	xh	ye
al	bi	cf	dc	dy	ev	fs	gp	hm	ij	jg	kd	la	lw	mt	nq	on	pk	qh	re	sb	sx	tu	ur	vo	wl	xi	yf
am	bj	cg	dd	ea	ew	ft	gq	hn	ik	jh	ke	lb	lx	mu	nr	oo	pl	qi	rf	sc	sy	tv	us	vp	wm	xj	yg
an	bk	ch	de	eb	ex	fu	gr	ho	il	ji	kf	lc	ly	mv	ns	op	pm	qj	rg	sd	ta	tw	ut	vq	wn	xk	yh
ao	bl	ci	df	ec	ey	fv	gs	hp	im	jj	kg	ld	ma	mw	nt	oq	pn	qk	rh	se	tb	tx	uu	vr	wo	xl	yi
ap	bm	cj	dg	ed	fa	fw	gt	hq	in	jk	kh	le	mb	mx	nu	or	po	ql	ri	sf	tc	ty	uv	vs	wp	xm	yj
aq	bn	ck	dh	ee	fb	fx	gu	hr	io	jl	ki	lf	mc	my	nv	os	pp	qm	rj	sg	td	ua	uw	vt	wq	xn	yk
ar	bo	cl	di	ef	fc	fy	gv	hs	ip	jm	kj	lg	md	na	nw	ot	pq	qn	rk	sh	te	ub	ux	vu	wr	xo	yl
as	bp	cm	dj	eg	fd	ga	gw	ht	iq	jn	kk	lh	me	nb	nx	ou	pr	qo	rl	si	tf	uc	uy	vv	ws	xp	ym
at	bq	cn	dk	eh	fe	gb	gx	hu	ir	jo	kl	li	mf	nc	ny	ov	ps	qp	rm	sj	tg	ud	va	vw	wt	xq	yn
au	br	co	dl	ei	ff	gc	gy	hv	is	jp	km	lj	mg	nd	oa	ow	pt	qq	rn	sk	th	ue	vb	vx	wu	xr	yo
av	bs	cp	dm	ej	fg	gd	ha	hw	it	jq	kn	lk	mh	ne	ob	ox	pu	qr	ro	sl	ti	uf	vc	vy	wv	xs	yp

vi 
:DirDiff b c 
		19.18.5
      19.18 VimCommander
      total-commander-like file manager for vim
      Toggle (start) it with F11
      noremap <silent> <F11> :cal VimCommanderToggle()<CR> 

	19.18.1  List of Features:                                  
    
    - Two panels side-by-side;
    - File operations work only on unix;
    - File selection;
    - Remembers settings;
    - Directory history.

	19.18.2 VimCommander Keys                                       

    Most of VimCommander's key-bindings are similar to the other
    commanders':

    - TAB     = Go to the other panel;
    - F3      = View file under cursor;
    - F4      = Edit file under cursor;
    - F5      = Copy file;
    - F6      = Move/rename file;
    - F7      = Create directory;
    - F8/DEL  = Remove file;
    - F10     = Quit VimCommander;
    - C-R     = Refresh panels;
    - C-U     = Exchange panels;
    - C-Left  = Put directory under cursor on other panel, or grab
              = other panel's dir;
    - C-Right = Same;
    - C-H     = Toggle show hidden files;
    - INS     = Select file under cursor;
    - "+"     = Select file by pattern;
    - "-"     = De-select file by pattern;
    - S-F4    = Edit new file;
    - C-t     = Previous directory;
    - C-y     = Next directory.

    C-* stands for CTRL+*. S-* stands for SHIFT+*.
    As some terminals do not support SHIFT/CTRL+non-letter-keys, a <leader>
    version has usually been provided.
    So, <leader>Right and C-Right are the same.
    Same for M-keys, including letters.

	19.19 Source explorer
	http://www.vim.org/scripts/script.php?script_id=2179
	a source code explorer for (G)Vim and provides an overview of the function and type definitions.It has such a mechannism that works like the context window component of "Source Insight" software

	If you have used Source Insight for browse your C/C++ project before, you may find that you can browse the definitions as well as the context window of "Source Insight".

For example, you put the cursor on a function name in Normal mode, its definition will show on the Source Explorer window a moment later. And then you can do the 'double-click' operation using your mouse onto the Source Explorer window which had appeared on the bottom of (G)Vim. The definition and its context will be show on the edit window.(Just like Source Insight does). In srcexpl v1.2 and above, the function key which users mapped will play a important role that you can not only use mouse but also use keyboard in order to exploring source code in both GUI and cterm VIM.

The Source Explorer can work with Taglist very well. Both of them make (G)Vim looks like the "Source Insight" in Unix/Windows enviorment.

Features:
|1\ Go insight the definitions of functions and various types of C/C++ language project.
|2\ Double click and click <ENTER> key onto the  Source Explorer Window can edit the definition and context.
|3\ Your own map key (such as <SPACE>) can force to refresh the Source Explorer directly.
|4\ Popup menu and Your own map key (such as <A-,> in Source Insight) to go back from the definition.
|5\ You can explore C/C++/ASM/ souce code only using your mouse but without keyboard.

		19.19.1 Installation
|
|		1\ Add the srcexpl.vim script to the plugin directory of Vimfiles, such as ~/.vim/plugin/
|
|2\ Add the following in your .vimrc or _vimrc
|    " Set the refreshing time interval, such as 2 seconds
|    let g:SrcExpl_RefreshTime   = 2
|    " Initialize the height of the Source Explorer window
|    let g:SrcExpl_WinHeight     = 9
|    " Make your own map key to force to do a refreshing
|    let g:SrcExpl_RefreshMapKey = "<Space>"
|    " Make your own map key for 'SrcExplGoBack' operation
|    let g:SrcExpl_GoBackMapKey  = "<C-b>"
|    " Toggles the Source Explorer on and off
|    nmap <F8> :SrcExplToggle<CR>
|
|3\ Enjoy vimming:)
|
|Tips:
|
|1\ You must make sure that there is a 'tags' file in your project PATH.
|2\ You have to compile your (G)VIM using 'quickfix' option.

"
	19.20 Doxygen support
	http://www.vim.org/scripts/script.php?script_id=1955

	This plugin generates Ex commands and a menu (or a menu tree) from a template
file containing user defined comment templates to be used for source code
documentation with Doxygen. The template file can have user defined macros.

Example and screen shots :   http://lug.fh-swf.de/vim/vim-doxygen/index.html

The help file online :   http://lug.fh-swf.de/vim/vim-doc/doxygensupport.html

"
		19.20.1 Documentation
		h doxygensupport

"
		19.20.2 Install
(1) Copy the zip archive  doxygen-support.zip to $HOME/.vim/ or $VIM/vimfiles
    (on the Windows platforms) and run

      unzip doxygen-support.zip

    If you have already an older version of doxygen-support and you have modified
    the template files you may want to save your templates first or copy the
    files from the archive by hand.

(2) Loading of plugin files must be enabled. If not use
      :filetype plugin on
    This is the minimal content of the file '$HOME/.vimrc'. Create one if there
    is none.

(3) Set at least some personal details in the main file
    'doxygen-support/templates/doxygen.templates'.

(4) Restart gVim/Vim generate the help tags

      :helptags ~/.vim/doc

    and look at the doxygensupport help with

      :h doxygensupport

		19.20.3 Usage

			19.20.3.1 GUI
The Doxygen menu will be generated when the editor starts (GUI only) or on
demand (see|doxygensupport-rebuild|).

The template names from the template definition file become menu items linked
with the template body. The template body will be inserted below the cursor.

The delimiter '.' has a special meaning: it separates a submenu name from its
submenu items. The template names

 ==block.short==
 ==block.long==
 ==block.special==

will generate a submenu entry 'block'  with the items 'short', 'long', and
'special' :

 block --+--> long
         |
         +--> short
         |
         +--> special

This feature can be used to arrange the templates into groups. The template
names

 ==C.block-short==
 ==C.block-long==
 ==C.block-special==
 ==Cpp.block-short==
 ==Cpp.block-long==
 ==Cpp.block-special==

result in menus in which the templates are arranged according to C/C++
commenting styles:

 C   --+--> block-short
       +--> block-long
       +--> block-special
 Cpp --+--> block-short
       +--> block-long
       +--> block-special

			19.20.3.2 Non GUI (xterm, eterm etc)
This plugin generates an Ex command for each Doxygen template.  These commands
will be generated when the editor starts or on demand (see|doxygensupport-rebuild|).

Vim Ex command names have to start always with an uppercase letter followed by
letters or digits. Delimiters are not allowed.  The user defined template
names are therefore transformed into camel case notation.  The parts separated
by the delimiters are joined together now. The first letter of each part will
be transformed to uppercase. The new word will be prefixed by 'Doxy'. Some
examples:

 template name           Ex command
 ----------------------------------------
 ==block.long==          DoxyBlockLong
 ==block.short==         DoxyBlockShort
 ==block.special==       DoxyBlockSpecial
 ==file-header==         DoxyFileHeader
 ==function==            DoxyFunction

 ***  You do not need to remember the names of these Ex commands. Just type
 ***  'Doxy' on the command line and use the tab expansion to show the names
 ***  and to choose from.

NAMING CONFLICTS. The template names

 ==block-special==       DoxyBlockSpecial
 ==block+special==       DoxyBlockSpecial

will generate two different menu items but obviously the same Ex command name.
Avoiding these conflicts is up to you.


	19.21 LargeFile
Sets up an autocmd to make editing large files work with celerity 

	19.22 CCtree  C Call-Tree Explorer - Source-code analysis, real-time display of code flow 
http://www.vim.org/scripts/script.php?script_id=2368

		19.22.1 Install
Install details
Installation:
Copy this file to ~/.vim/plugins/
or to /vimfiles/plugins/  (on Win32 platforms)

It might also be possible to load it as a filetype plugin
~/.vim/ftplugin/c/

Need to set :filetype plugin on 

		19.22.2 Help
http://sites.google.com/site/vimcctree/help

CCTree generates call-trees for any function or macro in real-time inside Vim.
Requires Cscope and operation is currently limited to C code.

		19.22.3 Options

You can customize behavior by changing the following variable settings
                    
			19.22.3.1. Cscope Symbol Database~
                                                *CCTreeCscopeDb*

Cscope database file, g:CCTreeCscopeDb = "cscope.out"

			19.22.3.2. Call-tree Depth~
                                                *CCTreeRecursiveDepth* 
Maximum call levels,   g:CCTreeRecursiveDepth = 3

			19.22.3.3. Call-tree Minimum Visible Depth~
                                                *CCTreeMinVisibleDepth*
Maximum visible(unfolded) level, g:CCTreeMinVisibleDepth = 3

			19.22.3.4. Call-tree window display~

			19.22.3.4.1 Orientation~
                                                *CCTreeOrientation*
Orientation of window,  g:CCTreeOrientation = "leftabove"
 (standard vim options for split: [right|left][above|below])

			19.22.3.5 Direction~
                                                *CCTreeWindowVertical* 
Use Vertical window, g:CCTreeWindowVertical = 1

			19.22.3.5.1 Dimensions~

These settings determine the layout of the CCTree preview window.

			19.22.3.5.2 Horizontal Window Settings~
                                                *CCTreeWindowHeight* 
 Horizontal window, g:CCTreeWindowHeight, default is -1.

			19.22.3.5.2 Vertical Window Settings~
                                                *CCTreeWindowMinWidth* 
                                                *CCTreeWindowWidth* 
 Minimum width for window, g:CCTreeWindowMinWidth = 40.
 g:CCTreeWindowWidth = -1, auto-select best width to fit.


			19.22.3.6 Call-tree display format~
                                                *CCTreeDisplayMode*
Display format, g:CCTreeDisplayMode, default: 1

Values: 1 -- Ultra-compact (takes minimum screen width)
        2 -- Compact       (Takes little more space)
        3 -- Wide          (Takes copious amounts of space)

For vertical splits, 1 and 2 are good, while 3 is good for horizontal
displays.

			19.22.3.7. Dynamic Call-tree highlighting~
                                                *CCTreeHilightCallTree*

Enable/disable dynamic call-tree highlighting, default: 1


			19.22.3.7.1 Syntax items~
                                               *CCTreeSymbol* *CCTreeHiSymbol*
CCTreeSymbol is the symbol name.
CCTreeHiSymbol is the highlighted call tree functions.

                                               *CCTreeMarkers* *CCTreeHiMarkers*
CCTreeMarkers include  "|","+--->".
CCTreeHiMarkers is the same as CCTreeMarkers except these denote the
highlighted call-tree.

		19.22.4 Usage

			19.22.4.1. Symbol database~

Build cscope database, for example:
run my cscope generating alias gen_scope
( find . \( -name "*.[chCH]" -o -name "*.cpp" -o -name "*.hpp" \) > my_cscope.files; cscope -ibkq my_cscope.files -b)
mv my_cscope.files cscope.files
> cscope -b -i cscope.files
 [Tip: add -c option to build uncompressed databases for faster
    load speeds]

Load database with command ":CCTreeLoadDB"
(Please note that it might take a while depending on the
       	138 database size)

A database name, i.e., my_cscope.out, can be specified with the command. If
not provided, a prompt will ask for the filename; default is cscope.out.

To unload database, use command ":CCTreeUnLoadDB"

			19.22.4.2. Exploring source-code~

Get reverse call tree for symbol  <C-\><
:CCTreeTraceReverse <symbolname>    
That is ctrl and \ and <

Get forward call tree for symbol  <C-\>>
:CCTreeTraceForward <symbolname>

Increase depth of tree and update <C-\>=
:CCTreeRecurseDepthPlus    

Decrease depth of tree and update <C-\>-
:CCTreeRecurseDepthMinus    

Open symbol in other window       <CR>
Preview symbol in other window    <Ctrl-P>

			19.22.4.4. Syntax Coloring~

CCTreeHiXXXX allows dynamic highlighting of the call-tree.  To observe the
effect, move the cursor to the function to highlight the current call-tree.
This option can be turned off using the setting, *CCTreeHilightCallTree* .

For faster highlighting, the value of 'updatetime' can be changed.

	19.23 project.vim
	

				By Aric Blumer
		      aricvim email-at-sign charter.net

	Contents:

		Commands...................|project-invoking|
		Inheritance.............|project-inheritance|
		Mappings...................|project-mappings|
		Adding Mappings.....|project-adding-mappings|
		Settings...................|project-settings|
		Example File................|project-example|
		Tips...........................|project-tips|


You can use this plugin's basic functionality to set up a list of
frequently-accessed files for easy navigation. The list of files will be
displayed in a window on the left side of the Vim window, and you can press
<Return> or double-click on filenames in the list to open the files. I find
this easier to use than having to navigate a directory hierarchy with the
|file-explorer|.

You can also instruct the Plugin to change to a directory and to run Vim
scripts when you select a file. These scripts can, for example, modify the
environment to include compilers in $PATH. This makes it very easy to use
quickfix with multiple projects that use different environments.

Other features include:
	o Loading/Unloading all the files in a Project (\l, \L, \w, and \W)
	o Grepping all the files in a Project (\g and \G)
	o Running a user-specified script on a file (can be used to launch an
	  external program on the file) (\1 through \9)
	o Running a user-specified script on all the files in a Project
	  (\f1-\f9 and \F1-\F9)
	o High degree of user-configurability
	o Also works with |netrw| using the XXXX://... notation where XXXX is
	  ftp, rcp, scp, or http.

All of this is specified within a simple text file and a few global variables
in your vimrc file.

You must set 'nocompatible' in your |vimrc| file to use this plugin. You can
stop the plugin from being loaded by setting the "loaded_project" variable: >
	:let loaded_project = 1


==============================================================================

		19.23.1 COMMANDS						    *project-invoking*

You can use the plugin by placing it in your plugin directory (e.g.,
~/.vim/plugin). See |add-global-plugin|. When you start vim the next time, you
then enter the command >
    :Project
or >
    :Project {file}

If you do not specify the filename, $HOME/.vimprojects is used.

To have Vim come up with the Project Window enabled automatically (say, from a
GUI launcher), run Vim like this:  [g]vim +Project

Note that you can invoke :Project on only one file at a time.  If you wish to
change the Project File, do a :bwipe in the Project Buffer, then re-invoke the
Plugin as described above.

Several Projects can be kept and displayed in the same file, each in a fold
delimited by { and } (see |fold.txt|).  There can be any number of nested
folds to provide you with a Project hierarchy.  Any line without a { or a } in
the file is considered to be a filename.  Blank lines are ignored, and any
text after a # is ignored.

Because the plugin uses standard Vim folds, you can use any of the
|fold-commands|. You can double-click on the first line of a fold to open and
close it. You can select a file to open by putting the cursor on its name and
pressing <Return> or by double-clicking on it.  The plugin will create a new
window to the right or use the |CTRL-W_p| equivalent if it exists.

							      *project-syntax*
Each Project Entry has this form:

project_entry ::=
    <Description>={projpath} [{options}] {
	[ filename ]
	[ project_entry ]
    }

{options} is one or more of the following (on the same line):
    CD={path}
    in={filename}
    out={filename}
    filter="{pat}"
    flags={flag}

Note that a project_entry can reside within a project_entry. This allows you
to set up a hierarchy within your Project.

The <Description> will be displayed in the foldtext and cannot contain "=".
There can be no space character directly on either side of the =.

The {projpath} is the path in which the files listed in the Project's fold
will be found, and it may contain environment variables.  If the path is a
relative path, then the plugin constructs the whole path from the Project's
parent, grandparent, etc., all the way up the hierarchy. An outermost
project_entry must have an absolute path.  See the |project-inheritance|
example below.  {projpath} may contain spaces, but they must be escaped like
normal Vim escapes. Here are two examples of the same directory:
>
	Example=/my/directory/with\ spaces {
	}
	Example="/my/directory/with spaces" {
	}

I recommend this for Windows®: >

	Example="c:\My Documents" {
	}

But Vim is smart enough to do this, too: >

	Example=c:\My\ Documents {
	}

CD= provides the directory that Vim will change to when you select a file in
that fold (using |:cd|). This allows you, for example, to enter |:make| to use
the local Makefile.  A CD=. means that Vim will make {projpath} or its
inherited equivalent the current working directory.  When CD is omitted, the
directory is not changed.  There can be no space on either side of the =.  The
value of CD can also be a relative path from a parent's CD.  See the
|project-inheritance| example below.  This directive is ignored for |netrw|
projects. Spaces are allowed in the path as for {projpath}.

in= and out= provide the means to run arbitrary Vim scripts whenever you enter
or leave a file's buffer (see the |BufEnter| and |BufLeave| autocommand
events).  The idea is to have a Vim script that sets up or tears down the
environment for the Project like this:

in.vim: >
	let $PROJECT_HOME='~/my_project'
	" Put the compiler in $PATH
	if $PATH !~ '/path/to/my/compiler'
		let $PATH=$PATH.':/path/to/my/compiler'
	endif

out.vim: >
	" Remove compiler from $PATH
	if $PATH =~ '/path/to/my/compiler'
		let $PATH=substitute($PATH, ':/path/to/my/compiler', '', 'g')
	endif

Then you can use :make with the proper environment depending on what file you
are currently editing.  If the path to the script is relative, then it is
relative from {projpath}.  These directives are inherited by Subprojects
unless the Subproject specifies its own. For use with |netrw| projects, the
paths specified for in= and out= must be absolute and local.

filter= specifies a |glob()| file pattern. It is used to regenerate the list
of files in a Project fold when using the \r (<LocalLeader>r) map in the
Project Window.  The filter value must be in quotes because it can contain
multiple file patterns.  If filter is omitted, then the * pattern is used.
There can be no space on either side of the =.  A Subproject will inherit the
filter of its parent unless it specifies its own filter.

flags= provides the means to enable/disable features for a particular fold.
The general mnemonic scheme is for lower case to turn something off and upper
case to turn something on.  {flag} can contain any of the following
characters:

      flag      Description ~

	l	Turn off recursion for this fold for \L.  Subfolds are also
	        blocked from the recursion.

	r	Turn off refresh. When present, do not refresh this fold when
		\r or \R is used.  This does not affect subfold recursion.

	S	Turn on sorting for refresh and create.

	s	Turn off sorting for refresh and create.

	T	Turn on top gravity.  Forces folds to the top of the current
		fold when refreshing. It has the same affect as the 'T' flag
		in g:proj_flags, but controls the feature on a per-fold basis.

	t	Turn off top gravity.  Forces folds to the bottom of the
	        current fold when refreshing.

	w	Turn off recursion for this fold for \W.  Subfolds are also
	        blocked from the recursion.


Flags are not inherited by Subprojects.

Any text outside a fold is ignored.


==============================================================================

		19.23.2 INHERITANCE						 *project-inheritance*

It's best to show inheritance by comparing these two Project Files:
>
	Parent=~/my_project CD=. filter="Make* *.mk" flags=r {
	 Child1=c_code {
	 }
	 Child2=include CD=. filter="*.h" {
	 }
	}

Child1's path is "~/my_project/c_code" because ~/my_project is inherited.  It
also inherits the CD from Parent.  Since Parent has CD=., the Parent's cwd is
"~/my_project".  Child1 therefore inherits a CD of "~/my_project".  Finally,
Child1 inherits the filter from Parent. The flags are not inherited.

Child2 only inherits the "~/my_project" from Parent.

Thus, the example above is exactly equivalent to this:
>
	Parent=~/my_project CD=. filter="Make* *.mk" flags=r {
	 Child1=~/my_project/c_code CD=~/my_project filter="Make* *.mk" {
	 }
	 Child2=~/my_project/include CD=~/my_project/include filter="*.h" {
	 }
	}

(For a real Project, Child1 would not want to inherit its parent's filter, but
this example shows the concept.)  You can always enter \i to display what the
cursor's project inherits.


==============================================================================

		19.23.3 MAPPINGS						    *project-mappings*

Map	Action ~

\r	Refreshes the Project fold that the cursor is in by placing in the
	fold all the files that match the filter. The Project is refreshed
	using an indent of one space for every foldlevel in the hierarchy.

	You may place a "# pragma keep" (without the quotes) at the end of a
	line, and the file entry on that line will not be removed when you
	refresh.  This is useful, for example, when you have . as an entry so
	you can easily browse the directory.
	
	Note that this mapping is actually <LocalLeader>r, and the default of
	|<LocalLeader>| is \.

	This does not work for Projects using |netrw|.

\R	Executes \r recursively in the current fold and all folds below.
	This does not work for Projects using |netrw|.

\c	Creates a Project fold entry.  It asks for the description, the path
	to the files, the CD parameter, and the filename |glob()| pattern.
	From this information, it will create the Project Entry below the
	cursor.

	This does not work for Projects using |netrw|.

\C	Creates a Project fold entry like \c, but recursively includes all the
	subdirectories.

<Return>
	Select a file to open in the |CTRL-W_p| window or in a new window.  If
	the cursor is on a fold, open or close it.

<S-Return>
\s
	Same as <Return> but horizontally split the target window.
	<LocalLeader>s is provided for those terminals that don't recognize
	<S-Return>.

\S
	Load all files in a project by doing horizontal splits.

<C-Return>
\o
	Same as <Return> but ensure that the opened file is the only other
	window. <LocalLeader>o is provided for those terminals that don't
	recognize <C-Return>.

<M-Return>
\v
	Same as <Return> but only display the file--the cursor stays in the
	Project Window.

<2-LeftMouse>
	(Double-click) If on a closed fold, open it. If on an open fold
	boundary, close it. If on a filename, open the file in the |CTRL-W_p|
	window or in a new window.

<S-2-LeftMouse>
	Same as <S-Return>.

<C-2-LeftMouse>
	Same as <C-Return>.

<RightMouse>
	Increase the width of the Project Window by g:proj_window_increment or
	toggle between a width of
		g:proj_window_width + g:proj_window_increment
	and
		g:proj_window_width.

	Whether you toggle or monotonically increase the width is determined
	by the 't' flag of the g:proj_flags variable (see |project-flags|).

	Note that a Right Mouse click will not automatically place the cursor
	in the Project Window if it is in a different window.  The window will
	go back to the g:proj_window_width width when you leave the window.

<space> Same as <RightMouse>

<CTRL-Up>
\<Up>
	Move the text or fold under the cursor up one row. This may not work
	in a terminal because the terminal is unaware of this key combination.
	<LocalLeader><Up> is provided for those terminals that don't recognize
	<C-Up>.


<CTRL-Down>
\<Down>
	Move the text or fold under the cursor down one row. This may not work
	in a terminal because the terminal is unaware of this key combination.
	<LocalLeader><Down> is provided for those terminals that don't
	recognize <C-Down>.

\i	Show in the status line the completely resolved and inherited
	parameters for the fold the cursor is in.  This is intended for
	debugging your relative path and inherited parameters for manually
	entered Projects.

\I	Show in the status line the completely resolved filename.  Uses the
        Project_GetFname(line('.')) function.

\1 - \9
	Run the command specified in g:proj_run{x} where {x} is the number
	of the key.  See the documentation of g:proj_run1 below.

\f1-\f9
	Run the command specified in g:proj_run_fold{x} where {x} is the
	number of the key.  The command is run on the files at the current
	Project level. See the |project-settings| below.

\F1-\F9
	Run the command specified in g:proj_run_fold{x} where {x} is the
	number of the key.  The command is run on the files at the current
	Project level and all Subprojects. See the |project-settings| below.

\0	Display the commands that are defined for \1 through \9.

\f0	Display the commands that are defined for \f1 through \f9 and \F1
	through \F0.  Same as \F0.

\l	Load all the files in the current Project level into Vim.  While files
	are being loaded, you may press any key to stop.

\L	Load all the files in the current Project and all Subprojects into
	Vim.  Use this mapping with caution--I wouldn't suggest using \L to
	load a Project with thousands of files. (BTW, my Project file has more
	than 5,300 files in it!)  While files are being loaded, you may press
	any key to stop.

\w	Wipe all the files in the current Project level from Vim. (If files
	are modified, they will be saved first.)  While files are being wiped,
	you may press any key to stop.

\W	Wipe all the files in the current Project and all Subprojects from
	Vim. (If files are modified, they will be saved first.)  While files
	are being wiped, you may press any key to stop.

\g	Grep all the files in the current Project level.

\G	Grep all the files in the current Project level and all Subprojects.

\e	Set up the Environment for the Project File as though you had selected
	it with <Return>.  This allows you to do a \e and a :make without
	having to open any files in the project.

\E	Explore (using |file-explorer|) the directory of the project the
	cursor is in.  Does not work with netrw.

<F12>	When the 'g' flag is present in g:proj_flags (see |project-flags|)
	this key toggles the Project Window open and closed. You may remap
	this toggle function by putting the following in your vimrc and
	replacing <Leader>P with whatever key combination you wish:

		nmap <silent> <Leader>P <Plug>ToggleProject

Note that the Project Plugin remaps :help because the Help Window and the
Project Window get into a fight over placement. The mapping avoids the
problem.

==============================================================================

		19.23.4
ADDING MAPPINGS 				     *project-adding-mappings*

You can add your own mappings or change the mappings of the plugin by placing
them in the file $HOME/.vimproject_mappings.  This file, if it exists, will be
sourced when the plugin in loaded.  Here is an example that will count the
number of entries in a project when you press \K (Kount, C is taken :-): >

    function! s:Wc()
        let b:loadcount=0
        function! SpawnExec(infoline, fname, lineno, data)
	    let b:loadcount = b:loadcount + 1
	    if getchar(0) != 0 | let b:stop_everything=1 | endif
        endfunction
        call Project_ForEach(1, line('.'), "*SpawnExec", 0, '')
        delfunction SpawnExec
        echon b:loadcount." Files\r"
        unlet b:loadcount
        if exists("b:stop_everything")
	    unlet b:stop_everything
	    echon "Aborted.\r"
	endif
    endfunction

    nnoremap <buffer> <silent> <LocalLeader>K :call <SID>Wc()<CR>

Here's another example of how I integrated the use of perforce with the plugin
in my $HOME/.vimproject_mappings:
>
	function! s:DoP4(cmd)
	   let name=Project_GetFname(line('.'))
	   let dir=substitute(name, '\(.*\)/.*', '\1', 'g')
	   exec 'cd '.dir
	   exec "!".a:cmd.' '.Project_GetFname(line('.'))
	   cd -
	endfunction

	nmap <buffer> <silent> \pa :call <SID>DoP4("p4add")<CR>
	nmap <buffer> <silent> \pe :call <SID>DoP4("p4edit")<CR>
<
(Note that I CD to the directory the file is in so I can pick of the $P4CONFIG
file. See the perforce documentation.)

This creates the mappings \pe to check out the file for edit and \pa to add
the file to the depot.

Here is another example where I remap the <Return> mapping to use an external
program to launch a special kind of file (in this case, it launches ee to view
a jpg file).  It is a bit contrived, but it works.
>
	let s:sid = substitute(maparg('<Return>', 'n'), '.*\(<SNR>.\{-}\)_.*', '\1', '')
	function! s:LaunchOrWhat()
	    let fname=Project_GetFname(line('.'))
	    if fname =~ '\.jpg$'
		exec 'silent! !ee "'.fname.'"&'
	    else
		call {s:sid}_DoFoldOrOpenEntry('', 'e')
	    endif
	endfunction
	nnoremap <buffer> <silent> <Return>   \|:call <SID>LaunchOrWhat()<CR>
<
If the file ends in .jpg, the external program is launched, otherwise the
original mapping of <Return> is run.

==============================================================================

		19.23.5 ADDING MAPPINGS 				     *project-adding-mappings*

You can add your own mappings or change the mappings of the plugin by placing
them in the file $HOME/.vimproject_mappings.  This file, if it exists, will be
sourced when the plugin in loaded.  Here is an example that will count the
number of entries in a project when you press \K (Kount, C is taken :-): >

    function! s:Wc()
        let b:loadcount=0
        function! SpawnExec(infoline, fname, lineno, data)
	    let b:loadcount = b:loadcount + 1
	    if getchar(0) != 0
SETTINGS						    *project-settings*

You can set these variables in your vimrc file before the plugin is loaded to
change its default behavior

g:proj_window_width
	The width of the Project Window that the plugin attempts to maintain.
	Default: 24

	The Project Plugin is not always successful in keeping the window
	where I want it with the size specified here, but it does a decent
	job.

g:proj_window_increment
	The increment by which to increase the width of the Project Window
	when pressing <space> or clicking the <LeftMouse>. Default: 100
	(See |project-mappings|.)

							       *project-flags*
g:proj_flags
	Default: "imst"
	Various flags to control the behavior of the Project Plugin.  This
	variable can contain any of the following character flags.

       flag	Description ~

	b	When present, use the |browse()| when selecting directories
		for \c and \C.  This is off by default for Windows, because
		the windows browser does not allow you to select directories.

	c	When present, the Project Window will automatically close when
		you select a file.

	F	Float the Project Window.  That is, turn off automatic
		resizing and placement.  This allows placement between other
		windows that wish to share similar placement at the side of
		the screen.  It is also particularly helpful for external
		window managers.

	g	When present, the mapping for <F12> will be created to toggle
		the Project Window open and closed.

	i	When present, display the filename and the current working
		directory in the command line when a file is selected for
		opening.

	l	When present, the Project Plugin will use the |:lcd| command
		rather than |:cd| to change directories when you select a file
		to open.  This flag is really obsolete and not of much use
		because of L below.

	L	Similar to l, but install a BufEnter/Leave |:autocommand| to
		ensure that the current working directory is changed to the
		one specified in the fold CD specification whenever that
		buffer is active.  (|:lcd| only changes the CWD for a window,
		not a buffer.)

	m	Turn on mapping of the |CTRL-W_o| and |CTRL-W_CTRL_O| normal
	        mode commands to make the current buffer the only visible
		buffer, but keep the Project Window visible, too.

	n	When present, numbers will be turned on for the project
	        window.

	s	When present, the Project Plugin will use syntax highlighting
		in the Project Window.

	S	Turn on sorting for refresh and create.

	t	When present, toggle the size of the window rather than just
		increase the size when pressing <space> or right-clicking.
		See the entry for <RightMouse> in |project-mappings|.

	T	When present, put Subproject folds at the top of the fold when
		refreshing.

	v	When present, use :vimgrep rather than :grep when using \G.

g:proj_run1 ...  g:proj_run9
		Contains a Vim command to execute on the file.  See the
		mappings of \1 to \9 above.
		
		  %f is replaced with the full path and filename
		  %F is replaced with the full path and filename with spaces
		     quoted
		  %n is replaced with the filename alone
		  %N is replaced with the filename alone with spaces quoted
		  %h is replaced with the home directory
		  %H is replaced with the home directory with spaces quoted
		  %r is replaced with the directory relative to the CD path
		  %R is replaced with the directory relative to the CD path
		     with spaces quoted
		  %d is replaced with the CD directory.
		  %D is replaced with the CD directory.with spaces quoted
		  %% is replaced with a single % that is not used in
		     expansion.

		(Deprecated: %s is also replaced with the full path and
		filename for backward compatibility.)

		For example, gvim will be launched on the file under the
		cursor when you enter \3 if the following is in your vimrc
		file: >
		 let g:proj_run3='silent !gvim %f'
<		Here are a few other examples: >
		 let g:proj_run1='!p4 edit %f'
		 let g:proj_run2='!p4 add %f'
		 let g:proj_run4="echo 'Viewing %f'|sil !xterm -e less %f &"
<
		On Windows systems you will want to put the %f, %h, and %d in
		single quotes to avoid \ escaping.

g:proj_run_fold1 ...  g:proj_run_fold9
		Contains a Vim command to execute on the files in a fold.  See
		the mappings of \f1 to \f9  and \F1 to \F9 above.
		
		%f is the filename, %h is replaced with the project home
		directory, and %d is replaced with the CD directory.  Multiple
		filenames can be handled in two ways:

		The first (default) way is to have %f replaced with all the
		absolute filenames, and the command is run once.  The second
		is to have the command run for each of the non-absolute
		filenames (%f is replaced with one filename at a time).  To
		select the second behavior, put an '*' character at the
		beginning of the g:proj_run_fold{x} variable.  (The '*' is
		stripped before the command is run.)

		For example, note the difference between the following: >
		 let g:proj_run_fold3="*echo '%h/%f'"
		 let g:proj_run_fold4="echo '%f'"
<
		Note that on Windows systems, you will want the %f, %h, and %c
		within single quotes, or the \ in the paths will cause
		problems.  The alternative is to put them in |escape()|.


==============================================================================

		19.23.6 PROJECT EXAMPLE FILE					     *project-example*

Here is an example ~/.vimprojects file: >

|  1	My Project=~/c/project CD=. in=in.vim out=out.vim flags=r {
|  2	 Makefile
|  3      in.vim
|  4      out.vim
|  5	 GUI Files=. filter="gui*.c gui*.h" {
|  6	  gui_window.c
|  7	  gui_dialog.c
|  8	  gui_list.c
|  9	  gui.h	       # Header file
| 10	 }
| 11	 Database Files=. filter="data*.c data*.h" {
| 12	  data_read.c
| 13	  data_write.c
| 14	  data.h
| 15	 }
| 16	 OS-Specific Files {
| 17	  Win32=. filter="os_win32*.c os_win32*.h" {
| 18	   os_win32_gui.c
| 19	   os_win32_io.c
| 20	  }
| 21	  Unix=. filter="os_unix*.c os_unix*.h" {
| 22	   os_unix_gui.c
| 23	   os_unix_io.c
| 24	  }
| 25	 }
| 26	}

(Don't type in the line numbers, of course.)


==============================================================================

		19.23.7 TIPS ON USING PROJECT PLUGIN					*project-tips*

|1.  You can create a Project Entry by entering this: >
|
|	Label=~/wherever CD=. filter="*.c *.h" {
|	}
|<
|    Then you can put the cursor in the fold and press \r. The script will fill
|    in the files (C files in this case) from this directory for you.  This is
|    equivalent to \c without any dialogs.
|
|2.  You can edit the Project File at any time to add, remove, or reorder files
|    in the Project list.
|
|3.  If the Project Window ever gets closed, you can just enter >
|	:Project
|<   to bring it back again. (You don't need to give it the filename; the
|    plugin remembers.)
|
|    If you have the 'm' flag set in g:proj_flags, then you get the Project
|    Window to show up again by pressing |CTRL-W_o|. This, of course, will
|    close any other windows that may be open that the cursor is not in.
|
|4.  Adding files to a Project is very easy.  To add, for example, the 'more.c'
|    file to the Project, just insert the filename in the Project Entry then
|    hit <Return> on it.
|
|5.  When |quickfix| loads files, it is not equivalent to pressing <Return> on
|    a filename, so the directory will not be changed and the scripts will not
|    be run. (If I could make this otherwise, I would.)  The solution is to use
|    the \L key to load all of the files in the Project before running
|    quickfix.
|
|6.  If the Project window gets a bit cluttered with folds partially
|    open/closed, you can press |zM| to close everything and tidy it up.
|
|7.  For advanced users, I am exporting the function Project_GetAllFnames()
|    which returns all the filenames within a fold and optionally all its
|    Subprojects.  Also, I export Project_ForEach() for running a function for
|    each filename in the project. See the code for examples on how to use
|    these. Finally, I export Project_GetFname(line_number) so that you can
|    write your own mappings and get the filename for it.
|
|8.  Some people have asked how to do a global mapping to take the cursor to
|    the Project window. One of my goals for the plugin is for it to be as
|    self-contained as possible, so I'm not going to add it by default. But you
|    can put this in your vimrc:
|>
|    	nmap <silent> <Leader>P :Project<CR>
|
|<
|9.  You can put the . entry in a project, and it will launch the
    |file-explorer| plugin on the directory.  To avoid removal when you
    refresh, make the entry look like this:
>
 	. # pragma keep

	19.24 surround.vim
INTRODUCTION                                    *surround*

This plugin is a tool for dealing with pairs of "surroundings."  Examples
of surroundings include parentheses, quotes, and HTML tags.  They are
closely related to what Vim refers to as |text-objects|.  Provided
are mappings to allow for removing, changing, and adding surroundings.

Details follow on the exact semantics, but first, consider the following
examples.  An asterisk (*) is used to denote the cursor position.

  Old text                  Command     New text ~
  "Hello *world!"           ds"         Hello world!
  [123+4*56]/2              cs])        (123+456)/2
  "Look ma, I'm *HTML!"     cs"<q>      <q>Look ma, I'm HTML!</q>
  if *x>3 {                 ysW(        if ( x>3 ) {
  my $str = *whee!;         vlllls'     my $str = 'whee!';

While a few features of this plugin will work in older versions of Vim,
Vim 7 is recommended for full functionality.

MAPPINGS                                        *surround-mappings*

Delete surroundings is *ds* .  The next character given determines the target
to delete.  The exact nature of the target are explained in |surround-targets|
but essentially it is the last character of a |text-object|.  This mapping
deletes the difference between the "inner" object and "an" object.  This is
easiest to understand with some examples:

  Old text                  Command     New text ~
  "Hello *world!"           ds"         Hello world!
  (123+4*56)/2              ds)         123+456/2
  <div>Yo!*</div>           dst         Yo!

Change surroundings is *cs* .  It takes two arguments, a target like with
|ds|, and a replacement.  Details about the second argument can be found
below in |surround-replacements|.  Once again, examples are in order.

  Old text                  Command     New text ~
  "Hello *world!"           cs"'        'Hello world!'
  "Hello *world!"           cs"<q>      <q>Hello world!</q>
  (123+4*56)/2              cs)]        [123+456]/2
  (123+4*56)/2              cs)[        [ 123+456 ]/2
  <div>Yo!*</div>           cst<p>      <p>Yo!</p>

*ys* takes an valid Vim motion or text object as the first object, and wraps
it using the second argument as with |cs|.  (Unfortunately there's no good
mnemonic for "ys".)

  Old text                  Command     New text ~
  Hello w*orld!             ysiw)       Hello (world)!

As a special case, *yss* operates on the current line, ignoring leading
whitespace.

  Old text                  Command     New text ~
      Hello w*orld!         yssB            {Hello world!}

There is also *yS* and *ySS* which indent the surrounded text and place it
on a line of its own.

In visual mode, a simple "s" with an argument wraps the selection.  This is
referred to as the *vs* mapping, although ordinarily there will be
additional keystrokes between the v and s.  In linewise visual mode, the
surroundings are placed on separate lines.  In blockwise visual mode, each
line is surrounded.

An "S" in visual mode (*vS*) behaves similarly but always places the
surroundings on separate lines.  Additionally, the surrounded text is
indented.  In blockwise visual mode, using "S" instead of "s" instead skips
trailing whitespace.

Note that "s" and "S" already have valid meaning in visual mode, but it is
identical to "c".  If you have muscle memory for "s" and would like to use a
different key, add your own mapping and the existing one will be disabled.
>
  vmap <Leader>s <Plug>Vsurround
  vmap <Leader>S <Plug>VSurround
<
                                                *i_CTRL-G_s* *i_CTRL-G_S*
Finally, there is an experimental insert mode mapping on <C-G>s and <C-S>.
Beware that the latter won't work on terminals with flow control (if you
accidentally freeze your terminal, use <C-Q> to unfreeze it).  The mapping
inserts the specified surroundings and puts the cursor between them.  If,
immediately after the mapping and before the replacement, a second <C-S> or
carriage return is pressed, the prefix, cursor, and suffix will be placed on
three separate lines.  <C-G>S (not <C-G>s) also exhibits this behavior.

TARGETS                                         *surround-targets*

The |ds| and |cs| commands both take a target as their first argument.  The
possible targets are based closely on the |text-objects| provided by Vim.
In order for a target to work, the corresponding text object must be
supported in the version of Vim used (Vim 7 adds several text objects, and
thus is highly recommended).  All targets are currently just one character.

Eight punctuation marks, (, ), {, }, [, ], <, and >, represent themselves
and their counterpart.  If the opening mark is used, contained whitespace is
also trimmed.  The targets b, B, r, and a are aliases for ), }, ], and >
(the first two mirror Vim; the second two are completely arbitrary and
subject to change).

Three quote marks, ', ", `, represent themselves, in pairs.  They are only
searched for on the current line.

A t is a pair of HTML or XML tags.  See |tag-blocks| for details.  Remember
that you can specify a numerical argument if you want to get to a tag other
than the innermost one.

The letters w, W, and s correspond to a |word|, a |WORD|, and a |sentence|,
respectively.  These are special in that they have nothing to delete, and
used with |ds| they are a no-op.  With |cs|, one could consider them a
slight shortcut for ysi (cswb == ysiwb, more or less).

A p represents a |paragraph|.  This behaves similarly to w, W, and s above;
however, newlines are sometimes added and/or removed.

'

	19.25 NERD tree
What is this "NERD tree"??

The NERD tree allows you to explore your filesystem and to open files and
directories. It presents the filesystem to you in the form of a tree which you
manipulate with the keyboard and/or mouse. It also allows you to perform
simple filesystem operations.

The following features and functionality are provided by the NERD tree:
    * Files and directories are displayed in a hierarchical tree structure
    * Different highlighting is provided for the following types of nodes:
        * files
        * directories
        * sym-links
        * windows .lnk files
        * read-only files
        * executable files
    * Many (customisable) mappings are provided to manipulate the tree:
        * Mappings to open/close/explore directory nodes
        * Mappings to open files in new/existing windows/tabs
        * Mappings to change the current root of the tree
        * Mappings to navigate around the tree
        * ...
    * Directories and files can be bookmarked.
    * Most NERD tree navigation can also be done with the mouse
    * Filtering of tree content (can be toggled at runtime)
        * custom file filters to prevent e.g. vim backup files being displayed
        * optional displaying of hidden files (. files)
        * files can be "turned off" so that only directories are displayed
    * The position and size of the NERD tree window can be customised
    * The order in which the nodes in the tree are listed can be customised.
    * A model of your filesystem is created/maintained as you explore it. This
      has several advantages:
        * All filesystem information is cached and is only re-read on demand
        * If you revisit a part of the tree that you left earlier in your
          session, the directory nodes will be opened/closed as you left them
    * The script remembers the cursor position and window position in the NERD
      tree so you can toggle it off (or just close the tree window) and then
      reopen it (with NERDTreeToggle) the NERD tree window will appear exactly
      as you left it
    * You can have a separate NERD tree for each tab, share trees across tabs,
      or a mix of both.
    * By default the script overrides the default file browser (netw), so if
      you :edit a directory a (slighly modified) NERD tree will appear in the
      current window
    * A programmable menu system is provided (simulates right clicking on a
      node)
        * one default menu plugin is provided to perform basic filesytem
          operations (create/delete/move/copy files/directories)
    * There's an API for adding your own keymappings

		19.25.1 Install
install details
Unzip the archive into your ~/.vim directory.
That should put NERD_tree.vim in ~/.vim/plugin and NERD_tree.txt in ~/.vim/doc.
Run :helptags.

		19.25.2 Get help
h NERD_tree.txt

		19.25.3 Commands

:NERDTree [<start-directory> | <bookmark>]                         *:NERDTree*
    Opens a fresh NERD tree. The root of the tree depends on the argument
    given. There are 3 cases: If no argument is given, the current directory
    will be used.  If a directory is given, that will be used. If a bookmark
    name is given, the corresponding directory will be used.  For example: >
        :NERDTree /home/marty/vim7/src
        :NERDTree foo   (foo is the name of a bookmark)
<
:NERDTreeFromBookmark <bookmark>                       *:NERDTreeFromBookmark*
    Opens a fresh NERD tree with the root initialized to the dir for
    <bookmark>.  This only reason to use this command over :NERDTree is for
    the completion (which is for bookmarks rather than directories).

:NERDTreeToggle [<start-directory> | <bookmark>]             *:NERDTreeToggle*
    If a NERD tree already exists for this tab, it is reopened and rendered
    again.  If no NERD tree exists for this tab then this command acts the
    same as the |:NERDTree| command.

:NERDTreeMirror                                              *:NERDTreeMirror*
    Shares an existing NERD tree, from another tab, in the current tab.
    Changes made to one tree are reflected in both as they are actually the
    same buffer.

    If only one other NERD tree exists, that tree is automatically mirrored. If
    more than one exists, the script will ask which tree to mirror.

:NERDTreeClose                                                *:NERDTreeClose*
    Close the NERD tree in this tab.

:NERDTreeFind                                                  *:NERDTreeFind*
    Find the current file in the tree. If no tree exists for the current tab,
    or the file is not under the current root, then initialize a new tree where
    the root is the directory of the current file.

		19.25.4 Bookmarks

Bookmarks in the NERD tree are a way to tag files or directories of interest.
For example, you could use bookmarks to tag all of your project directories.

------------------------------------------------------------------------------
			19.25.4.1 The Bookmark Table                              *NERDTreeBookmarkTable*

If the bookmark table is active (see |NERDTree-B| and
|'NERDTreeShowBookmarks'|), it will be rendered above the tree. You can double
click bookmarks or use the |NERDTree-o| mapping to activate them. See also,
|NERDTree-t| and |NERDTree-T|

------------------------------------------------------------------------------
			19.25.4.2 Bookmark commands                            *NERDTreeBookmarkCommands*

Note that the following commands are only available in the NERD tree buffer.

:Bookmark <name>
    Bookmark the current node as <name>. If there is already a <name>
    bookmark, it is overwritten. <name> must not contain spaces.

:BookmarkToRoot <bookmark>
    Make the directory corresponding to <bookmark> the new root. If a treenode
    corresponding to <bookmark> is already cached somewhere in the tree then
    the current tree will be used, otherwise a fresh tree will be opened.
    Note that if <bookmark> points to a file then its parent will be used
    instead.

:RevealBookmark <bookmark>
    If the node is cached under the current root then it will be revealed
    (i.e. directory nodes above it will be opened) and the cursor will be
    placed on it.

:OpenBookmark <bookmark>
    <bookmark> must point to a file. The file is opened as though |NERDTree-o|
    was applied. If the node is cached under the current root then it will be
    revealed and the cursor will be placed on it.

:ClearBookmarks [<bookmarks>]
    Remove all the given bookmarks. If no bookmarks are given then remove all
    bookmarks on the current node.

:ClearAllBookmarks
    Remove all bookmarks.

:ReadBookmarks
    Re-read the bookmarks in the |'NERDTreeBookmarksFile'|.

See also |:NERDTree| and |:NERDTreeFromBookmark|.

------------------------------------------------------------------------------
			19.25.4.3 Invalid Bookmarks                            *NERDTreeInvalidBookmarks*

If invalid bookmarks are detected, the script will issue an error message and
the invalid bookmarks will become unavailable for use.

These bookmarks will still be stored in the bookmarks file (see
|'NERDTreeBookmarksFile'|), down the bottom. There will always be a blank line
after the valid bookmarks but before the invalid ones.

Each line in the bookmarks file represents one bookmark. The proper format is:
<bookmark name><space><full path to the bookmark location>

After you have corrected any invalid bookmarks, either restart vim, or go
:ReadBookmarks from the NERD tree window.

		19.25.5 NERD tree Mappings                                     *NERDTreeMappings*

Default  Description~                                             help-tag~
Key~

o.......Open files, directories and bookmarks....................|NERDTree-o|
go......Open selected file, but leave cursor in the NERDTree.....|NERDTree-go|
t.......Open selected node/bookmark in a new tab.................|NERDTree-t|
T.......Same as 't' but keep the focus on the current tab........|NERDTree-T|
i.......Open selected file in a split window.....................|NERDTree-i|
gi......Same as i, but leave the cursor on the NERDTree..........|NERDTree-gi|
s.......Open selected file in a new vsplit.......................|NERDTree-s|
gs......Same as s, but leave the cursor on the NERDTree..........|NERDTree-gs|
O.......Recursively open the selected directory..................|NERDTree-O|
x.......Close the current nodes parent...........................|NERDTree-x|
X.......Recursively close all children of the current node.......|NERDTree-X|
e.......Edit the current dif.....................................|NERDTree-e|

<CR>...............same as |NERDTree-o|.
double-click.......same as the |NERDTree-o| map.
middle-click.......same as |NERDTree-i| for files, same as
                   |NERDTree-e| for dirs.

D.......Delete the current bookmark .............................|NERDTree-D|

P.......Jump to the root node....................................|NERDTree-P|
p.......Jump to current nodes parent.............................|NERDTree-p|
K.......Jump up inside directories at the current tree depth.....|NERDTree-K|
J.......Jump down inside directories at the current tree depth...|NERDTree-J|
<C-J>...Jump down to the next sibling of the current directory...|NERDTree-C-J|
<C-K>...Jump up to the previous sibling of the current directory.|NERDTree-C-K|

C.......Change the tree root to the selected dir.................|NERDTree-C|
u.......Move the tree root up one directory......................|NERDTree-u|
U.......Same as 'u' except the old root node is left open........|NERDTree-U|
r.......Recursively refresh the current directory................|NERDTree-r|
R.......Recursively refresh the current root.....................|NERDTree-R|
m.......Display the NERD tree menu...............................|NERDTree-m|
cd......Change the CWD to the dir of the selected node...........|NERDTree-cd|

I.......Toggle whether hidden files displayed....................|NERDTree-I|
f.......Toggle whether the file filters are used.................|NERDTree-f|
F.......Toggle whether files are displayed.......................|NERDTree-F|
B.......Toggle whether the bookmark table is displayed...........|NERDTree-B|

q.......Close the NERDTree window................................|NERDTree-q|
A.......Zoom (maximize/minimize) the NERDTree window.............|NERDTree-A|
?.......Toggle the display of the quick help.....................|NERDTree-?|

------------------------------------------------------------------------------
                                                                  *NERDTree-o*
Default key: o
Map option: NERDTreeMapActivateNode
Applies to: files and directories.

If a file node is selected, it is opened in the previous window.

If a directory is selected it is opened or closed depending on its current
state.

If a bookmark that links to a directory is selected then that directory
becomes the new root.

If a bookmark that links to a file is selected then that file is opened in the
previous window.

------------------------------------------------------------------------------
                                                                 *NERDTree-go*
Default key: go
Map option: None
Applies to: files.

If a file node is selected, it is opened in the previous window, but the
cursor does not move.

The key combo for this mapping is always "g" + NERDTreeMapActivateNode (see
|NERDTree-o|).

------------------------------------------------------------------------------
                                                                  *NERDTree-t*
Default key: t
Map option: NERDTreeMapOpenInTab
Applies to: files and directories.

Opens the selected file in a new tab. If a directory is selected, a fresh
NERD Tree for that directory is opened in a new tab.

If a bookmark which points to a directory is selected, open a NERD tree for
that directory in a new tab. If the bookmark points to a file, open that file
in a new tab.

------------------------------------------------------------------------------
                                                                  *NERDTree-T*
Default key: T
Map option: NERDTreeMapOpenInTabSilent
Applies to: files and directories.

The same as |NERDTree-t| except that the focus is kept in the current tab.

------------------------------------------------------------------------------
                                                                  *NERDTree-i*
Default key: i
Map option: NERDTreeMapOpenSplit
Applies to: files.

Opens the selected file in a new split window and puts the cursor in the new
window.

------------------------------------------------------------------------------
                                                                 *NERDTree-gi*
Default key: gi
Map option: None
Applies to: files.

The same as |NERDTree-i| except that the cursor is not moved.

The key combo for this mapping is always "g" + NERDTreeMapOpenSplit (see
|NERDTree-i|).

------------------------------------------------------------------------------
                                                                  *NERDTree-s*
Default key: s
Map option: NERDTreeMapOpenVSplit
Applies to: files.

Opens the selected file in a new vertically split window and puts the cursor in
the new window.

------------------------------------------------------------------------------
                                                                 *NERDTree-gs*
Default key: gs
Map option: None
Applies to: files.

The same as |NERDTree-s| except that the cursor is not moved.

The key combo for this mapping is always "g" + NERDTreeMapOpenVSplit (see
|NERDTree-s|).

------------------------------------------------------------------------------
                                                                  *NERDTree-O*
Default key: O
Map option: NERDTreeMapOpenRecursively
Applies to: directories.

Recursively opens the selelected directory.

All files and directories are cached, but if a directory would not be
displayed due to file filters (see |'NERDTreeIgnore'| |NERDTree-f|) or the
hidden file filter (see |'NERDTreeShowHidden'|) then its contents are not
cached. This is handy, especially if you have .svn directories.

------------------------------------------------------------------------------
                                                                  *NERDTree-x*
Default key: x
Map option: NERDTreeMapCloseDir
Applies to: files and directories.

Closes the parent of the selected node.

------------------------------------------------------------------------------
                                                                  *NERDTree-X*
Default key: X
Map option: NERDTreeMapCloseChildren
Applies to: directories.

Recursively closes all children of the selected directory.

Tip: To quickly "reset" the tree, use |NERDTree-P| with this mapping.

------------------------------------------------------------------------------
                                                                  *NERDTree-e*
Default key: e
Map option: NERDTreeMapOpenExpl
Applies to: files and directories.

|:edit|s the selected directory, or the selected file's directory. This could
result in a NERD tree or a netrw being opened, depending on
|'NERDTreeHijackNetrw'|.

------------------------------------------------------------------------------
                                                                  *NERDTree-D*
Default key: D
Map option: NERDTreeMapDeleteBookmark
Applies to: lines in the bookmarks table

Deletes the currently selected bookmark.

------------------------------------------------------------------------------
                                                                  *NERDTree-P*
Default key: P
Map option: NERDTreeMapJumpRoot
Applies to: no restrictions.

Jump to the tree root.

------------------------------------------------------------------------------
                                                                  *NERDTree-p*
Default key: p
Map option: NERDTreeMapJumpParent
Applies to: files and directories.

Jump to the parent node of the selected node.

------------------------------------------------------------------------------
                                                                  *NERDTree-K*
Default key: K
Map option: NERDTreeMapJumpFirstChild
Applies to: files and directories.

Jump to the first child of the current nodes parent.

If the cursor is already on the first node then do the following:
    * loop back thru the siblings of the current nodes parent until we find an
      open dir with children
    * go to the first child of that node

------------------------------------------------------------------------------
                                                                  *NERDTree-J*
Default key: J
Map option: NERDTreeMapJumpLastChild
Applies to: files and directories.

Jump to the last child of the current nodes parent.

If the cursor is already on the last node then do the following:
    * loop forward thru the siblings of the current nodes parent until we find
      an open dir with children
    * go to the last child of that node

------------------------------------------------------------------------------
                                                                *NERDTree-C-J*
Default key: <C-J>
Map option: NERDTreeMapJumpNextSibling
Applies to: files and directories.

Jump to the next sibling of the selected node.

------------------------------------------------------------------------------
                                                                *NERDTree-C-K*
Default key: <C-K>
Map option: NERDTreeMapJumpPrevSibling
Applies to: files and directories.

Jump to the previous sibling of the selected node.

------------------------------------------------------------------------------
                                                                  *NERDTree-C*
Default key: C
Map option: NERDTreeMapChdir
Applies to: directories.

Make the selected directory node the new tree root. If a file is selected, its
parent is used.

------------------------------------------------------------------------------
                                                                  *NERDTree-u*
Default key: u
Map option: NERDTreeMapUpdir
Applies to: no restrictions.

Move the tree root up a dir (like doing a "cd ..").

------------------------------------------------------------------------------
                                                                  *NERDTree-U*
Default key: U
Map option: NERDTreeMapUpdirKeepOpen
Applies to: no restrictions.

Like |NERDTree-u| except that the old tree root is kept open.

------------------------------------------------------------------------------
                                                                  *NERDTree-r*
Default key: r
Map option: NERDTreeMapRefresh
Applies to: files and directories.

If a dir is selected, recursively refresh that dir, i.e. scan the filesystem
for changes and represent them in the tree.

If a file node is selected then the above is done on it's parent.

------------------------------------------------------------------------------
                                                                  *NERDTree-R*
Default key: R
Map option: NERDTreeMapRefreshRoot
Applies to: no restrictions.

Recursively refresh the tree root.

------------------------------------------------------------------------------
                                                                  *NERDTree-m*
Default key: m
Map option: NERDTreeMapMenu
Applies to: files and directories.

Display the NERD tree menu. See |NERDTreeMenu| for details.

------------------------------------------------------------------------------
                                                                 *NERDTree-cd*
Default key: cd
Map option: NERDTreeMapChdir
Applies to: files and directories.

Change vims current working directory to that of the selected node.

------------------------------------------------------------------------------
                                                                  *NERDTree-I*
Default key: I
Map option: NERDTreeMapToggleHidden
Applies to: no restrictions.

Toggles whether hidden files (i.e. "dot files") are displayed.

------------------------------------------------------------------------------
                                                                  *NERDTree-f*
Default key: f
Map option: NERDTreeMapToggleFilters
Applies to: no restrictions.

Toggles whether file filters are used. See |'NERDTreeIgnore'| for details.

------------------------------------------------------------------------------
                                                                  *NERDTree-F*
Default key: F
Map option: NERDTreeMapToggleFiles
Applies to: no restrictions.

Toggles whether file nodes are displayed.

------------------------------------------------------------------------------
                                                                  *NERDTree-B*
Default key: B
Map option: NERDTreeMapToggleBookmarks
Applies to: no restrictions.

Toggles whether the bookmarks table is displayed.

------------------------------------------------------------------------------
                                                                  *NERDTree-q*
Default key: q
Map option: NERDTreeMapQuit
Applies to: no restrictions.

Closes the NERDtree window.

------------------------------------------------------------------------------
                                                                  *NERDTree-A*
Default key: A
Map option: NERDTreeMapToggleZoom
Applies to: no restrictions.

Maximize (zoom) and minimize the NERDtree window.

------------------------------------------------------------------------------
                                                                  *NERDTree-?*
Default key: ?
Map option: NERDTreeMapHelp
Applies to: no restrictions.

Toggles whether the quickhelp is displayed.



		19.25.6
	19.26 ANN: Vim for Outlook

		19.26.1 Issues on my env
I have released a new plugin for those Microsoft Windows Outlook users.

It simply adds a button in Outlook which will spawn Vim, allow you to
edit the body of the currently open email and when you :w, it will
update Outlook with the results.

There are more details, you can read about them here:
http://www.vim.org/scripts/script.php?script_id=3087

As usual, with all my plugins, feedback good and bad is always welcome.

Enjoy.
Dave

--
You received this message from the "vim_use" maillist.
Do not top-post! Type your reply below the text you are replying to.
For more information, visit http://www.vim.org/maillist.php
Reply
		
Forward
		
Invite David Fishburn to chat
		
Reply
|
Gareth Oakes	
Very cool! I have installed and tested on my Outlook 2007 instance here. Work...
	
May 7 (3 days ago)
Gareth OakesLoading...	
May 7 (3 days ago)
Gareth Oakes
 to vim_use
	
show details May 7 (3 days ago)
	
> I have released a new plugin for those Microsoft Windows Outlook users.
>
> It simply adds a button in Outlook which will spawn Vim, allow you to
> edit the body of the currently open email and when you :w, it will
> update Outlook with the results.
>
> There are more details, you can read about them here:http://www.vim.org/scripts/script.php?script_id=3087
>
> As usual, with all my plugins, feedback good and bad is always welcome.

Very cool! I have installed and tested on my Outlook 2007 instance
here. Works as advertised. I have two ideas for improvements:

| 1. Allow launching new Vim for each email, instead of reusing an
existing Vim. This is mainly because I always have a TODO list open in
Vim on my 2nd monitor and actually I would like to edit my email in
it's own Vim window on the primary screen :)

| 2. Auto-quote an email for response. All the Outlook formatting is
obviously lost in translation to text, but it would be nice to
automatically quote the email when writing a response. Not sure how
that would exactly work, but it would save me having to run a command
to add > before each line of the file in Vim :)

Thanks again for your script David, it's awesome.

Cheers,
Gareth
- Show quoted text -

--
You received this message from the "vim_use" maillist.
Do not top-post! Type your reply below the text you are replying to.
For more information, visit http://www.vim.org/maillist.php
Reply
		
Forward
		
Invite Gareth Oakes to chat
		
Reply
|
yosi izaq	
This plugin sounds very useful. I have outlook 2k7 and have followed the inst...
	
May 9 (1 day ago)
yosi izaqLoading...	
May 9 (1 day ago)
yosi izaq
 to vim_use
	
show details May 9 (1 day ago)
	
This plugin sounds very useful.

I have outlook 2k7 and have followed the install instructions. I have
added the vim macro and quick access button. Clicking it opens a vim
session for editing the email. However saving the changes (:w) doesn't
update the email.

Any idea what's wrong?

thx,
Yosi
Reply
		
Forward
		
		
Reply
|
David Fishburn	
On Fri, May 7, 2010 at 2:46 AM, Gareth Oakes <juicejuice@gmail.com> wrote: ...
	
6:06 AM (12 hours ago)
David FishburnLoading...	
6:06 AM (12 hours ago)
David Fishburn
 to vim_use
	
show details 6:06 AM (12 hours ago)
	
On Fri, May 7, 2010 at 2:46 AM, Gareth Oakes <juicejuice@gmail.com> wrote:
...
>> There are more details, you can read about them here:http://www.vim.org/scripts/script.php?script_id=3087
...
> Very cool! I have installed and tested on my Outlook 2007 instance
> here. Works as advertised. I have two ideas for improvements:
>
> 1. Allow launching new Vim for each email, instead of reusing an
> existing Vim. This is mainly because I always have a TODO list open in
> Vim on my 2nd monitor and actually I would like to edit my email in
> it's own Vim window on the primary screen :)

Version 3.0 just uploaded addresses this.
Please give it a try.


> 2. Auto-quote an email for response. All the Outlook formatting is
> obviously lost in translation to text, but it would be nice to
> automatically quote the email when writing a response. Not sure how
> that would exactly work, but it would save me having to run a command
> to add > before each line of the file in Vim :)

When the new file is opened in Vim the autocmds created by OutlookVim
set the filetype to be "mail".

There are several existing ftplugins available at vim.org which will
allow you to do all sorts of fancy quoting and such.
Perhaps current Vim users of these plugins can voice some opinions on
particularily effective ones.

Dave
- Show quoted text -

--
You received this message from the "vim_use" maillist.
Do not top-post! Type your reply below the text you are replying to.
For more information, visit http://www.vim.org/maillist.php
Reply
		
Forward
		
Invite David Fishburn to chat
		
Reply
|
David Fishburn	
Please update to OutlookVim 3.0. Two things: 1. After opening the email in Vi...
	
6:12 AM (12 hours ago)
David FishburnLoading...	
6:12 AM (12 hours ago)
David Fishburn
 to vim_use
	
show details 6:12 AM (12 hours ago)
	
On Sun, May 9, 2010 at 4:54 AM, yosi izaq <izaqyos@gmail.com> wrote:
> This plugin sounds very useful.
>
> I have outlook 2k7 and have followed the install instructions. I have
> added the vim macro and quick access button. Clicking it opens a vim
> session for editing the email. However saving the changes (:w) doesn't
> update the email.

Please update to OutlookVim 3.0.

Two things:

| 1.  After opening the email in Vim, please provide the output from:
:au outlook

You can select this with your mouse and hit CTRL-Y, then paste it into
this email.  It should look something like this:
****
:au outlook
--- Auto-Commands ---
outlook  BufEnter
   *.outlook setlocal filetype=mail
outlook  BufUnload
   *.outlook if expand('%:e') == 'outlook' | call
delete(expand('%:p').'.ctl') | call delete(expand('%:p')) | endif
outlook  BufWritePost
   *.outlook setlocal autoread | let g:outlook_cscript_output =
system('cscript "C:\Vim\vimfiles\plugin\outlookvim.js"
"'.expand("%").'"  ')| bdelete | if g:outloo
k_cscript_output =~ 'outlookvim:' | call Outlook_WarningMsg(
substitute(g:outlook_cscript_output, '^.*\(outlookvim:.*\)', '\1', '')
) | endif
****


| 2.  After typing :w, please provide the output from:
:echo g:outlook_cscript_output

It should say something like this:
****
Microsoft (R) Windows Script Host Version 5.8
Copyright (C) Microsoft Corporation. All rights reserved.

Successfully updated Outlook, message
ID:0000000026A082186274D011808F00805FF466B524ACAB01
****


Dave
- Show quoted text -

--
You received this message from the "vim_use" maillist.
Do not top-post! Type your reply below the text you are replying to.
For more information, visit http://www.vim.org/maillist.php
Reply
		
Forward
		
Invite David Fishburn to chat
		
Reply
|
yosi izaq	
inline, 10x, Yosi done Doesn't look good. I get: E216: No such group or event...
	
11:03 AM (7 hours ago)
yosi izaqLoading...	
11:03 AM (7 hours ago)
yosi izaq
 to vim_use
	
show details 11:03 AM (7 hours ago)
	
inline,

10x,

Yosi
>
> Please update to OutlookVim 3.0.
>
done

> Two things:
>
> 1.  After opening the email in Vim, please provide the output from:
> :au outlook
>
> You can select this with your mouse and hit CTRL-Y, then paste it into
> this email.  It should look something like this:
> ****
> :au outlook
> --- Auto-Commands ---
> outlook  BufEnter
>    *.outlook setlocal filetype=mail
> outlook  BufUnload
>    *.outlook if expand('%:e') == 'outlook' | call
> delete(expand('%:p').'.ctl') | call delete(expand('%:p')) | endif
> outlook  BufWritePost
>    *.outlook setlocal autoread | let g:outlook_cscript_output =
> system('cscript "C:\Vim\vimfiles\plugin\outlookvim.js"
> "'.expand("%").'"  ')| bdelete | if g:outloo
> k_cscript_output =~ 'outlookvim:' | call Outlook_WarningMsg(
> substitute(g:outlook_cscript_output, '^.*\(outlookvim:.*\)', '\1', '')
> ) | endif
> ****
>
Doesn't look good. I get:
E216: No such group or event: outlook

>
> 2.  After typing :w, please provide the output from:
> :echo g:outlook_cscript_output
>
> It should say something like this:
> ****
> Microsoft (R) Windows Script Host Version 5.8
> Copyright (C) Microsoft Corporation. All rights reserved.
>
> Successfully updated Outlook, message
> ID:0000000026A082186274D011808F00805FF466B524ACAB01
> ****
>
E121: undefined variable: g:outlook_cscript_output
E15: invalid expression: g:outlook_cscript_output

I checked a bit and I think the reason this fails is:
| 1. Fail to load the javascript b/c
| 2. $VIM contains a space (i.e c:/Program file/vim)
| 3. So this snippet is failing:
" Default location for the outlookvim.js file.
" This can be overridden in your vimrc via
" g:outlook_javascript
let s:outlook_javascript_default = expand('$VIM/vimfiles/plugin/outlookvim.js')

so outlook.vim gives error that it can't load the js file.
How can I fix this?
Reply
		
Forward
		
		
Reply
|
David Fishburn	
On Mon, May 10, 2010 at 4:03 AM, yosi izaq <izaqyos@gmail.com> wrote: Yosi I ...
	
3:29 PM (3 hours ago)
David FishburnLoading...	
3:29 PM (3 hours ago)
David Fishburn
 to vim_use
	
show details 3:29 PM (3 hours ago)
	
On Mon, May 10, 2010 at 4:03 AM, yosi izaq <izaqyos@gmail.com> wrote:

 Yosi

I will respond directly to you and take this offline until we resolve it.

I will post back the final solution.
I have tested with spaces in the name, so it must be something else.
- Show quoted text -

Dave

--
You received this message from the "vim_use" maillist.
Do not top-post! Type your reply below the text you are replying to.
For more information, visit http://www.vim.org/maillist.php
Reply
		
Forward
		
Invite David Fishburn to chat
		
Reply
|
David Fishburn	
On Mon, May 10, 2010 at 4:03 AM, yosi izaq <izaqyos@gmail.com> wrote: ... Oka...
	
4:10 PM (2 hours ago)
David FishburnLoading...	
4:10 PM (2 hours ago)
David Fishburn
 to me
	
show details 4:10 PM (2 hours ago)
	
On Mon, May 10, 2010 at 4:03 AM, yosi izaq <izaqyos@gmail.com> wrote:
...
>> Two things:
>>
>> 1.  After opening the email in Vim, please provide the output from:
>> :au outlook
>>
>> You can select this with your mouse and hit CTRL-Y, then paste it into
>> this email.  It should look something like this:
>> ****
>> :au outlook
>> --- Auto-Commands ---
>> outlook  BufEnter
>>    *.outlook setlocal filetype=mail
>> outlook  BufUnload
>>    *.outlook if expand('%:e') == 'outlook' | call
>> delete(expand('%:p').'.ctl') | call delete(expand('%:p')) | endif
>> outlook  BufWritePost
>>    *.outlook setlocal autoread | let g:outlook_cscript_output =
>> system('cscript "C:\Vim\vimfiles\plugin\outlookvim.js"
>> "'.expand("%").'"  ')| bdelete | if g:outloo
>> k_cscript_output =~ 'outlookvim:' | call Outlook_WarningMsg(
>> substitute(g:outlook_cscript_output, '^.*\(outlookvim:.*\)', '\1', '')
>> ) | endif
>> ****
>>
> Doesn't look good. I get:
> E216: No such group or event: outlook

Okay, that is the key to the trouble.

Are you overriding any values from within your .vimrc?

Have you edited the outlook.vim file in anyway?

Now, can you run each of the commands below and tell me what the
result is for each one.

   let g:outlook_javascript = expand('$VIM/vimfiles/plugin/outlookvim.js')

:echo strlen(globpath(substitute($PATH, '\\\?;', ',', 'g'), 'cscript.exe'))

:echo exists('g:outlook_javascript')

:echo filereadable(expand(g:outlook_javascript))

:echo has('autocmd')

:echo exists("g:loaded_outlook")

Thanks,
Dave
Reply
		
Forward
		
Invite David Fishburn to chat
		
Reply
|
yosi izaq	
inline 10x, Yosi I've made no changes to my .vimrc after installing your plugin.
	
5:08 PM (1 hour ago)
yosi izaqLoading...	
5:08 PM (1 hour ago)
yosi izaq
 to David
	
show details 5:08 PM (1 hour ago)
	
inline

10x,
Yosi
>> Doesn't look good. I get:
>> E216: No such group or event: outlook
>
> Okay, that is the key to the trouble.
>
> Are you overriding any values from within your .vimrc?
I've made no changes to my .vimrc after installing your plugin.

>
> Have you edited the outlook.vim file in anyway?
No

>
> Now, can you run each of the commands below and tell me what the
> result is for each one.
>
>    let g:outlook_javascript = expand('$VIM/vimfiles/plugin/outlookvim.js')
I don't see any result. It looks like it's doing something but I get no message.

>
> :echo strlen(globpath(substitute($PATH, '\\\?;', ',', 'g'), 'cscript.exe'))
31

>
> :echo exists('g:outlook_javascript')
1

>
> :echo filereadable(expand(g:outlook_javascript))
0

>
> :echo has('autocmd')
1

>
> :echo exists("g:loaded_outlook")
0

>
> Thanks,
> Dave
>
Reply
		
Forward
		
		
Reply
|
David Fishburn
 to me
	
show details 5:45 PM (1 hour ago)
	

:echo filereadable(expand(g:outlook_javascript))

    0
     


Okay, so we have found the reason the plugin is not creating the autocmds.

One thing that should have happened, is after you started Vim, if you did:
:messages

It should have shown an error indicating it could not find that file.

Let's try to figure out why though.

If you can execute these commands again:
:let g:outlook_javascript = expand('$VIM/vimfiles/plugin/outlookvim.js')


And provide the output from each of these:

:echo g:outlook_javascript

:echo filereadable(expand(g:outlook_javascript))
:exec '!dir "'.  g:outlook_javascript . '"'
:exec '!dir "'.  fnamemodify(expand(g:outlook_javascript), ':p:h') . '\out*"'


Thanks,
Dave

Reply
		
Forward
		
Invite David Fishburn to chat
		
[It's All Text!]
Reply
|
yosi izaq
 to David
	
show details 5:52 PM (57 minutes ago)
	
inline

thx,
Yosi

On Mon, May 10, 2010 at 5:45 PM, David Fishburn <dfishburn.vim@gmail.com> wrote:
>
> :echo filereadable(expand(g:outlook_javascript))
>
>> 0
>>
>
> Okay, so we have found the reason the plugin is not creating the autocmds.
>
> One thing that should have happened, is after you started Vim, if you did:
> :messages
>
> It should have shown an error indicating it could not find that file.
yeap.

>
> Let's try to figure out why though.
>
> If you can execute these commands again:
> :let g:outlook_javascript = expand('$VIM/vimfiles/plugin/outlookvim.js')

>
>
> And provide the output from each of these:
>
> :echo g:outlook_javascript
c:\Program Files\Vim\vim72\plugin\outlookvim.js

> :echo filereadable(expand(g:outlook_javascript))
0
> :exec '!dir "'.  g:outlook_javascript . '"'
!dir "c:\Program Files\Vim\vim72\plugin\outlookvim.js"
C:\WINDOWS\system32\cmd.exe /c dir "C:/Program Files/Vim/vimfiles/plugin/outlook
vim.js"
 Volume in drive C is System
 Volume Serial Number is 34C6-75D2

 Directory of C:\Program Files\Vim\vimfiles\plugin

File Not Found
shell returned 1
Hit any key to close this window...

> :exec '!dir "'.  fnamemodify(expand(g:outlook_javascript), ':p:h') .
> '\out*"'
!dir "c:\Program Files\Vim\vim72\plugin\outlookvim.js\out*"
C:\WINDOWS\system32\cmd.exe /c dir "C:/Program Files/Vim/vimfiles/plugin\out*"
 Volume in drive C is System
 Volume Serial Number is 34C6-75D2

 Directory of C:\Program Files\Vim\vimfiles\plugin

File Not Found
shell returned 1
Hit any key to close this window...


>
>
> Thanks,
> Dave
>
>
Reply
		
Forward
		
		
[It's All Text!]
Reply
|
David Fishburn
 to me
	
show details 6:24 PM (24 minutes ago)
	
On 1


:exec '!dir "'.  g:outlook_javascript . '"'

    !dir "c:\Program Files\Vim\vim72\plugin\outlookvim.js"
    C:\WINDOWS\system32\cmd.exe /c dir "C:/Program Files/Vim/vimfiles/plugin/outlook
    vim.js"
     Volume in drive C is System
     Volume Serial Number is 34C6-75D2

     Directory of C:\Program Files\Vim\vimfiles\plugin

    File Not Found
    shell returned 1
     


If you unzipped the file correctly, that file should have been there.
Can you open up the ZIP file and see what files are included.
Could it be your anti-virus software preventing .js files from being installed?



        :exec '!dir "'.  fnamemodify(expand(g:outlook_javascript), ':p:h') .
        '\out*"'
           

    !dir "c:\Program Files\Vim\vim72\plugin\outlookvim.js\out*"
     

What I was really looking for was this:

dir "c:\Program Files\Vim\vim72\plugin\out*"


So, it is up to you to figure out why all the files from OutlookVim_v3.zip are not on your hard drive.

There should be 4 files:
vimfiles\
doc\outlook.txt
plugin\outlook.vim
plugin\OutlookVim.bas
plugin\outlookvim.js

Dave

Reply
		
Forward
		
Invite David Fishburn to chat
		
Reply
|
David Fishburn
 to me
	
show details 6:26 PM (23 minutes ago)
	
Okay, so we have found the reason the plugin is not creating the autocmds.

        One thing that should have happened, is after you started Vim, if you did:
        :messages

        It should have shown an error indicating it could not find that file.
           

    yeap.
     


By the way, when you upgraded to OutlookVim 3.0, make sure you also update the Macro in Outlook with the new code.

Dave

Reply
		
Forward
		
Invite David Fishburn to chat
		
[It's All Text!]
Reply
|
yosi izaq
 to David
	
show details 6:37 PM (11 minutes ago)
	
Thanks for the tip.
The files are there however:
[yizaq@yizaq-wxp:Mon May 10:/cygdrive/c:]$ ls -lrt Program\
Files/Vim/vim72/plugin/ | tail
-rwx------+ 1 yizaq ????????   8332 2010-02-02 10:19 vcshg.vim
-rwx------+ 1 yizaq ????????   8036 2010-02-02 10:19 vcsgit.vim
-rwx------+ 1 yizaq ????????  13728 2010-02-02 10:19 vcscvs.vim
-rwx------+ 1 yizaq ????????  48965 2010-02-02 10:19 vcscommand.vim
-rwx------+ 1 yizaq ????????   8040 2010-02-02 10:19 vcsbzr.vim
-rwx------+ 1 yizaq ????????  34637 2010-02-02 13:04 bufexplorer.vim
-rwx------+ 1 yizaq ???????? 164515 2010-02-02 14:24 c.vim
-rwxrwx---+ 1 yizaq mkpasswd   4287 2010-05-09 21:58 outlookvim.js
-rwxrwx---+ 1 yizaq mkpasswd   7919 2010-05-09 22:51 OutlookVim.bas
-rwxrwx---+ 1 yizaq mkpasswd   6397 2010-05-10 10:59 outlook.vim
[yizaq@yizaq-wxp:Mon May 10:/cygdrive/c:]$ ls -lrt Program\
Files/Vim/vim72/doc/ | tail
-rwx------+ 1 yizaq ????????  15414 2009-12-01 14:02 uganda.nsis.txt
-rwx------+ 1 yizaq ????????  50021 2009-12-01 22:20 NERD_tree.txt
-rwx------+ 1 yizaq ????????  48949 2009-12-17 22:36 rails.txt
-rwx------+ 1 yizaq ???????? 108911 2009-12-28 13:47 perlsupport.txt
-rwx------+ 1 yizaq ????????  62901 2010-01-31 12:05 bashsupport.txt
-rwx------+ 1 yizaq ????????  30724 2010-02-02 10:19 vcscommand.txt
-rwx------+ 1 yizaq ????????  93544 2010-02-05 14:27 csupport.txt
-rwx------+ 1 yizaq ????????  26709 2010-02-10 11:12 bufexplorer.txt
-rwx------+ 1 yizaq ???????? 424680 2010-05-09 11:33 tags
-rwxrwx---+ 1 yizaq mkpasswd  10845 2010-05-09 22:22 outlook.txt

And just in case I manually created outlook dir and copied the files to there.
[yizaq@yizaq-wxp:Mon May 10:/cygdrive/c:]$ ls -lrt Program\
Files/Vim/vim72/plugin/outlook | tail
total 24
-rwxrwx---+ 1 yizaq mkpasswd 4287 2010-05-09 21:58 outlookvim.js
-rwxrwx---+ 1 yizaq mkpasswd 6397 2010-05-09 22:44 outlook.vim
-rwxrwx---+ 1 yizaq mkpasswd 7919 2010-05-09 22:51 OutlookVim.bas
Reply
		
Forward
		
		
[It's All Text!]
Your message has been sent.
Reply
|
yosi izaq
 to David
	
show details 6:48 PM (1 minute ago)
	
ok, I found the root cause and fixed it.

I have GVIM for windows. It has this dir struct:
vim\
   vim72\ (all VIM regular dirs and files)
   vimfiles

I put the script in vim/vim72/plugin but it looks for the js in
vimfiles. Once I copied it 2 there it started working :)

10x,
Yosi

		19.26.2 Install 
|3. Installing the plugin				*outlook-install*

 You can use this script as a plugin by copying it to your plugin directory. 
 See |add-global-plugin| for instructions.
 
 You can also |:source| it from your |.vimrc|.

 To install this help file |add-local-help| inside Vim.
 	:help add-local-help
	:helptags $VIM/vimfiles/doc (Windows)

 Files used by the plugin:
    outlook.vim
        - Sets up autocmds which are activated when editing a file
          which ends in .outlook
    outlookVim.bas
        - Visual Basic code used by Outlook to create some temporary files
          and launch Vim.
    outlookVim.js
        - A Javascript file called by the Vim autocmds when the file is saved.
          It uses Outlook APIs to update the email within Outlook.
    outlook.txt
        - This document

 NOTE:
     Vim must be in nocompatible mode for the plugin to operate correctly.
     This implies you have this line in your |.vimrc|: >
        set nocompatible 
<


==============================================================================
|4. Installing the Outlook macro				*outlook-macro*

 The macro is used to add a button in Outlook to lauch Vim.  It is used to
 create the files which Vim will edit.  It will also add a shortcut key
 (Alt-d) to fire up Vim instead of having to use a mouse.

 To install the Outlook macro flip over to Outlook.

|  1.  From the Outlook menu Tools->Macro->Security 
        Outlook 2003
             - Make sure this is set to Medium, or the macro will not be enabled 
        Outlook 2007
             - Make sure this is set to Warnings for all macros
|  2.  From the menu Tools->Macro->Visual Basic Editor (or Alt-F11)
|  3.  From the menu File->Import File (or Ctrl-M)
|  4.  Choose the file ...\vimfiles\plugin\OutlookVim.bas (where ever you
      installed the plugin).
|  5.  Expand the Modules folder in the Project pane
|  6.  Right click on Module1 and choose Project Properties
|  7.  Change the project name to "Vim"
|  8.  Change the project description to "Edit emails with Vim"
|  9.  From the menu File->Save (or Ctrl-S)
| 10.  Close the Visual Basic Editor 
| 11.  Double click on an email 
| 12.  Adding toolbar buttons
        Outlook 2003
             - Right click on the toolbar (of the email message) and choose
               "Customize"
             - Choose the Commands tab 
             - Click on the Macros category
             - Drag and drop the Vim.Edit macro onto the end of the Standard 
               toolbar displayed in the currently open email 
             - Click on the Rearrange Commands button 
             - Change the radio button to Toolbar: Standard 
             - Scroll to the bottom where the Vim.Edit button is and highlight it
             - Click on the Modify Selection button
             - On the dropdown which appears, click on Name
             - Change the name from "Vim.Edit" to "Vim.E&dit" 
                - Now you can press Alt-d as a shortcut to launch Vim to edit 
                  the email without having to use the mouse to click on the 
                  button (after all, that is the Vim way)
             - Hit Enter, Close and Close to return back to the open email
             - Click on the Vim.Edit button, or hit Ctrl-d to edit the email using Vim
        Outlook 2007
             - Toolbars are not editable in Outlook 2007
             - A new Quick Access Toolbar has been introduced in the titlebar
               of the open email
             - Click on the far right and choose "Customize Quick Access
               Toolbar" 
             - Click on "More Commands..."
             - Change the "Choose commands from" to "Macros"
             - Vim.Edit should be displayed, add it using the "Add >>" button
             - Click the Vim.Edit button in the right pane and click the
               "Modify" button below
             - Here you can assign some icon to it that will be easily 
               recognisable
             - Click on the new button in the Quick Access Toolbar
| 13.  Make a minor change to the email (in Vim) and :w
| 14.  Verify the Outlook email has the same change 
| 15.  Hit Escape to close the Outlook email, you will be prompted to Save 
      the changes you have just made.  So you always have an option of 
      cancelling the changes you made in Vim, in Outlook.


 If you changed the Macro Security settings you must restart Outlook 
 for these changes to be active.
  

==============================================================================
|5. Configuration					*outlook-configuration*

 The behavior of outlook.vim is governed by several variables. These variables
 are used by the autocmds which are created by the plugin.  These variables can
 be assigned global defaults which can be set in your |.vimrc|. 

 You can override many of the features of this script by creating various
 variables within your vimrc.
                                                                          
 The outlookvim.js (javascript) file tells Outlook to re-read the message from
 the temporary file.  This allows you to rename it, or place it in any
 location you want.  Here are some examples: >
     let g:outlook_javascript = '$VIM\vimfiles\plugin\outlookvim.js'  (default)
     let g:outlook_javascript = 'C:\Documents and Settings\Username\My Documents\outlookvim.js'
     let g:outlook_javascript = expand('$APPDATA\Microsoft\outlookvim.js')
     let g:outlook_javascript = expand('$USERPROFILE\Application Data\Microsoft\outlookvim.js')
<
 This setting (default = '') will force all emails to be edited in a particular
 Vim instance.  If the instance has not be started, a message is displayed
 with an example command line to start an appropriate Vim. >
     let g:outlook_servername = ''
<
 This setting (default = 1) overrides the default textwidth the mail ftplugin sets.  This
 allows you to automatically format text using gq by setting the following: >
     let g:outlook_textwidth = 76
<
 When you save a file, by default, Outlook will be updated and the temporary
 file you are editing will be deleted.  Autoread was added so that the Vim
 buffer is automatically cleared instead of displaying a warning message
 indicating the file has changed outside of Vim (in fact it was deleted).  If
 you wish to see the warning, you can set (default = 1) the following: >
     let g:outlook_noautoread = 1
<                                                                    
 When you save a file, by default, Outlook will be updated and the temporary
 file you are editing will be deleted.  Since the file has been deleted, you
 are left editing a file that no longer exists.  By default, the Vim buffer
 will be deleted automatically, unless this option (default = 1) is set. >
     let g:outlook_nobdelete = 1
<
 If you do not save the temporary file and instead decide to throw away your
 changes, the temporary files will be cleaned up.  This option (default = 1)
 will leave the files in the temporary directory instead of removing them. >
     let g:outlook_nodelete_unload = 1
<
 This setting (default = 1) will prevent the script from automatically turning
 on Vim's autoindent feature.  It will use your default setting instead. >
     let g:outlook_noautoindent = 1
<
 This setting (default = 1) will capture the output when attempting to update
 Outlook. >
     let g:outlook_save_cscript_output = 1
<
 This setting (default = 1) will show any errors reported when attempting
 to update Outlook.  This debugging output should help identify where
 any problems may lie. >
     let g:outlook_view_cscript_error = 1
<
                                                               
  vim:tw=78:fo=tcq2:ts=8:ft=help:norl:

		19.26.3 usage
	19.27 cscope.maps
   """"""""""""" My cscope/vim key mappings
    "
    " The following maps all invoke one of the following cscope search types:
    "
    "   's'   symbol: find all references to the token under cursor
    "   'g'   global: find global definition(s) of the token under cursor
    "   'c'   calls:  find all calls to the function name under cursor
    "   't'   text:   find all instances of the text under cursor
    "   'e'   egrep:  egrep search for the word under cursor
    "   'f'   file:   open the filename under cursor
    "   'i'   includes: find files that include the filename under cursor
    "   'd'   called: find functions that function under cursor calls
    "
    " Below are three sets of the maps: one set that just jumps to your
    " search result, one that splits the existing vim window horizontally and
    " diplays your search result in the new window, and one that does the same
    " thing, but does a vertical split instead (vim 6 only).
    "
    " I've used CTRL-\ and CTRL-@ as the starting keys for these maps, as it's
    " unlikely that you need their default mappings (CTRL-\'s default use is
    " as part of CTRL-\ CTRL-N typemap, which basically just does the same
    " thing as hitting 'escape': CTRL-@ doesn't seem to have any default use).
    " If you don't like using 'CTRL-@' or CTRL-\, , you can change some or all
    " of these maps to use other keys.  One likely candidate is 'CTRL-_'
    " (which also maps to CTRL-/, which is easier to type).  By default it is
    " used to switch between Hebrew and English keyboard mode.
    "


    " To do the first type of search, hit 'CTRL-\', followed by one of the
    " cscope search types above (s,g,c,t,e,f,i,d).  The result of your cscope
    " search will be displayed in the current window.  You can use CTRL-T to
    " go back to where you were before the search.  
    "

    nmap <C-\>s :cs find s <C-R>=expand("<cword>")<CR><CR>	
    nmap <C-\>g :cs find g <C-R>=expand("<cword>")<CR><CR>	
    nmap <C-\>c :cs find c <C-R>=expand("<cword>")<CR><CR>	
    nmap <C-\>t :cs find t <C-R>=expand("<cword>")<CR><CR>	
    nmap <C-\>e :cs find e <C-R>=expand("<cword>")<CR><CR>	
    nmap <C-\>f :cs find f <C-R>=expand("<cfile>")<CR><CR>	
    nmap <C-\>i :cs find i <C-R>=expand("<cfile>")<CR><CR>	
    nmap <C-\>d :cs find d <C-R>=expand("<cword>")<CR><CR>	


    " Using 'CTRL-spacebar' (intepreted as CTRL-@ by vim) then a search type
    " makes the vim window split horizontally, with search result displayed in
    " the new window.
    "
    " (Note: earlier versions of vim may not have the :scs command, but it
    " can be simulated roughly via:
    "    nmap <C-@>s <C-W><C-S> :cs find s <C-R>=expand("<cword>")<CR><CR>	

    nmap <C-@>s :scs find s <C-R>=expand("<cword>")<CR><CR>	
    nmap <C-@>g :scs find g <C-R>=expand("<cword>")<CR><CR>	
    nmap <C-@>c :scs find c <C-R>=expand("<cword>")<CR><CR>	
    nmap <C-@>t :scs find t <C-R>=expand("<cword>")<CR><CR>	
    nmap <C-@>e :scs find e <C-R>=expand("<cword>")<CR><CR>	
    nmap <C-@>f :scs find f <C-R>=expand("<cfile>")<CR><CR>	
    nmap <C-@>i :scs find i <C-R>=expand("<cfile>")<CR><CR>	
    nmap <C-@>d :scs find d <C-R>=expand("<cword>")<CR><CR>	


    " Hitting CTRL-space *twice* before the search type does a vertical 
    " split instead of a horizontal one (vim 6 and up only)

    nmap <C-@><C-@>s :vert scs find s <C-R>=expand("<cword>")<CR><CR>	
    nmap <C-@><C-@>g :vert scs find g <C-R>=expand("<cword>")<CR><CR>	
    nmap <C-@><C-@>c :vert scs find c <C-R>=expand("<cword>")<CR><CR>	
    nmap <C-@><C-@>t :vert scs find t <C-R>=expand("<cword>")<CR><CR>	
    nmap <C-@><C-@>e :vert scs find e <C-R>=expand("<cword>")<CR><CR>	
    nmap <C-@><C-@>f :vert scs find f <C-R>=expand("<cfile>")<CR><CR>	
    nmap <C-@><C-@>i :vert scs find i <C-R>=expand("<cfile>")<CR><CR>	
    nmap <C-@><C-@>d :vert scs find d <C-R>=expand("<cword>")<CR><CR>	

    "
		19.27.1 related - ‘egrep’ regular expression syntax

The character ‘.’ matches any single character except newline.

‘+’
indicates that the regular expression should match one or more occurrences of the previous atom or regexp. 
‘?’
indicates that the regular expression should match zero or one occurrence of the previous atom or regexp. 
‘\+’
matches a ‘+’ 
‘\?’
matches a ‘?’.
Bracket expressions are used to match ranges of characters. Bracket expressions where the range is backward, for example ‘[z-a]’, are ignored. Within square brackets, ‘\’ is taken literally. Character classes are supported; for example ‘[[:digit:]]’ will match a single decimal digit. Non-matching lists ‘[^...]’ do not ever match newline.

GNU extensions are supported:

‘\w’ matches a character within a word
‘\W’ matches a character which is not within a word
‘\<’ matches the beginning of a word
‘\>’ matches the end of a word
‘\b’ matches a word boundary
‘\B’ matches characters which are not a word boundary
‘\`’ matches the beginning of the whole input
‘\'’ matches the end of the whole input
Grouping is performed with parentheses ‘()’. A backslash followed by a digit acts as a back-reference and matches the same thing as the previous grouped expression indicated by that number. For example ‘\2’ matches the second group expression. The order of group expressions is determined by the position of their opening parenthesis ‘(’.

The alternation operator is ‘|’.

The characters ‘^’ and ‘$’ always represent the beginning and end of a string respectively, except within square brackets. Within brackets, ‘^’ can be used to invert the membership of the character class being specified.

The characters ‘*’, ‘+’ and ‘?’ are special anywhere in a regular expression.

The longest possible match is returned; this applies to the regular expression as a whole and (subject to this constraint) to subexpressions within groups.
	19.28 Vim Intellisense
Needless to say intellisense is very helpful while developing the programs. While developing Java or in .NET (C#) it is not possible to remember all the interfaces and its methods, APIs etc. The IDE or editor should help in a way to build programs. Vim helps in so many ways, and especially the auto-completion is provided by Vim, by default. But it does not give the intellisense which is beyond auto-completion. I think most of us know what is intellisense, which is provided by Visual Studio. It is also called CodeInsight. Intellisense in a broad sense means more. It can be listing methods, attributes, classes, interfaces, member variables, local variables, etc, provide online help and may be inline compilation. But we are not looking into building inline compilation.

Supported Languages

Intellisense is provided for the following languages:

Java
C++
C#
JSP
XML
HTML
SQL


		19.28.1 install 
Installing Vim Intellisense should be simple. Intellisense is packaged in self-extracting executable. To start the installation download the Windows binaries and double click it. This will extract the files and start the installation. Intellisense can be installed manually if you build it from the source.

Follow the steps to install.

| 1. The figure below shows the Welcome screen of the installation. Press Next to Continue.
| 
| 2. Read the license and choose "I Agree" if you want to proceed.
| 
| 3. Choose the plugins you want to install. For JSP to work you need both HTML and Java plugins to be installed.
| 
| 4. In the dialog shown below, enter the Vim folder. Typically Vim folder will be C:\Vim.  DO NOT Vim Rumtime directory, which is usually C:\Vim\vim63.
| 
|  
| 
| 5. Enter the Java docs directory if you have selected Java plugin. If not, you will not get this screen.
| 
| 6. Make sure you set JAVA_HOME environment variable pointing to java installation directory. If not you will get this warning; setup will not set the JAVA_HOME directory. You need to set it manually.
| 
| 7. Choose Finish to end the installation. Read the Finish page for some important information.

Now setting up intellisense is finished. Happy Vimming.
Manual Installation

Vim Intellisense can be installed manually, if you downloaded the sources and built all by yourself. Manual installation is given the intellisense.txt which is present in the $VIM\vimfiles\docs\intellisense.txt.

Read the release notes for some last minute information and some work arounds.

If your intellisense still didn't work, then see the Trouble Shoot.

		19.28.2
	19.29 supertab
==============================================================================
Supertab                                    *supertab*

|1. Introduction                             |supertab-intro|
|2. Supertab Usage                           |supertab-usage|
|3. Supertab Options                         |supertab-options|
    Default completion type                 |supertab-defaultcompletion|
    Secondary default completion type       |supertab-contextdefault|
    Completion contexts                     |supertab-completioncontexts|
        Context text                        |supertab-contexttext|
        Context Discover                    |supertab-contextdiscover|
        Example                             |supertab-contextexample|
    Completion Duration                     |supertab-duration|
    Preventing Completion After/Before...   |supertab-preventcomplete|
    Changing default mapping                |supertab-forwardbackward|
    Inserting true tabs                     |supertab-mappingtabliteral|
    Enhanced longest match support          |supertab-longestenhanced|
    Preselecting the first entry            |supertab-longesthighlight|

==============================================================================
|1. Introduction                             *supertab-intro*

Supertab is a plugin which allows you to perform all your insert completion
(|ins-completion|) using the tab key.

Supertab requires Vim version 7.0 or above.

==============================================================================
|2. Supertab usage                           *supertab-usage*

Using Supertab is as easy as hitting <Tab> or <S-Tab> (shift+tab) while in
insert mode, with at least one non whitespace character before the cursor, to
start the completion and then <Tab> or <S-Tab> again to cycle forwards or
backwards through the available completions.

Example ('|' denotes the cursor location):

bar
baz
b|<Tab>    Hitting <Tab> here will start the completion, allowing you to
           then cycle through the suggested words ('bar' and 'baz').

==============================================================================
|3. Supertab Options                         *supertab-options*

Supertab is configured via several global variables that you can set in your
|vimrc| file according to your needs. Below is a comprehensive list of
the variables available.


Default Completion Type             *supertab-defaultcompletion*
                                    *g:SuperTabDefaultCompletionType*

g:SuperTabDefaultCompletionType (default value: "<c-p>")

Used to set the default completion type. There is no need to escape this
value as that will be done for you when the type is set.

  Example: setting the default completion to 'user' completion:

    let g:SuperTabDefaultCompletionType = "<c-x><c-u>"

Note: a special value of 'context' is supported which will result in
super tab attempting to use the text preceding the cursor to decide which
type of completion to attempt.  Currently super tab can recognize method
calls or attribute references via '.', '::' or '->', and file path
references containing '/'.

    let g:SuperTabDefaultCompletionType = "context"

    /usr/l<tab>     # will use filename completion
    myvar.t<tab>    # will use user completion if completefunc set,
                    # or omni completion if omnifunc set.
    myvar-><tab>    # same as above

When using context completion, super tab will fall back to a secondary default
completion type set by |g:SuperTabContextDefaultCompletionType|.

Note: once the buffer has been initialized, changing the value of this setting
will not change the default complete type used.  If you want to change the
default completion type for the current buffer after it has been set, perhaps
in an ftplugin, you'll need to call SuperTabSetDefaultCompletionType like so,
supplying the completion type you wish to switch to:

    call SuperTabSetDefaultCompletionType("<c-x><c-u>")


Secondary default completion type   *supertab-contextdefault*
                                    *g:SuperTabContextDefaultCompletionType*

g:SuperTabContextDefaultCompletionType (default value: "<c-p>")

Sets the default completion type used when g:SuperTabDefaultCompletionType is
set to 'context' and no completion type is returned by any of the configured
contexts.


Completion contexts                 *supertab-completioncontexts*
                                    *g:SuperTabCompletionContexts*

g:SuperTabCompletionContexts (default value: ['s:ContextText'])

Sets the list of contexts used for context completion.  This value should
be a list of function names which provide the context implementation.

When supertab starts the default completion, each of these contexts will be
consulted, in the order they were supplied, to determine the completion type
to use.  If a context returns a completion type, that type will be used,
otherwise the next context in the list will be consulted.  If after executing
all the context functions, no completion type has been determined, then the
value of g:SuperTabContextDefaultCompletionType will be used.

Built in completion contexts:

  s:ContextText                     *supertab-contexttext*

  The text context will examine the text near the cursor to decide which type
  of completion to attempt.  Currently the text context can recognize method
  calls or attribute references via '.', '::' or '->', and file path
  references containing '/'.

      /usr/l<tab>  # will use filename completion
      myvar.t<tab> # will use user completion if completefunc set, or
                   # omni completion if omnifunc set.
      myvar-><tab> # same as above

  Supported configuration attributes:

    g:SuperTabContextTextFileTypeExclusions
    List of file types for which the text context will be skipped.

    g:SuperTabContextTextOmniPrecedence
    List of omni completion option names in the order of precedence that they
    should be used if available. By default, user completion will be given
    precedence over omni completion, but you can use this variable to give
    omni completion higher precedence by placing it first in the list.

  s:ContextDiscover                 *supertab-contextdiscover*

  This context will use the 'g:SuperTabContextDiscoverDiscovery' variable to
  determine the completion type to use.  It will evaluate each value, in the
  order they were defined, until a variable evaluates to a non-zero or
  non-empty value, then the associated completion type is used.

  Supported configuration properties:

    g:SuperTabContextDiscoverDiscovery
    List of variable:completionType mappings.

  Example context configuration:    *supertab-contextexample*

    let g:SuperTabCompletionContexts = ['s:ContextText', 's:ContextDiscover']
    let g:SuperTabContextTextOmniPrecedence = ['&omnifunc', '&completefunc']
    let g:SuperTabContextDiscoverDiscovery =
        \ ["&completefunc:<c-x><c-u>", "&omnifunc:<c-x><c-o>"]

  In addition to the default completion contexts, you can plug in your own
  implementation by creating a globally accessible function that returns
  the completion type to use (eg. "\<c-x>\<c-u>").

    function MyTagContext()
      if filereadable(expand('%:p:h') . '/tags')
        return "\<c-x>\<c-]>"
      endif
      " no return will result in the evaluation of the next
      " configured context
    endfunction
    let g:SuperTabCompletionContexts =
        \ ['MyTagContext', 's:ContextText', 's:ContextDiscover']

  Note: supertab also supports the b:SuperTabCompletionContexts variable
  allowing you to set the list of contexts separately for the current buffer,
  like from an ftplugin for example.


Completion Duration                 *supertab-duration*
                                    *g:SuperTabRetainCompletionDuration*

g:SuperTabRetainCompletionDuration (default value: 'insert')

Determines if, and for how long, the current completion type is retained.
The possible values include:
'completion' - The current completion type is only retained for the
               current completion.  Once you have chosen a completion
               result or exited the completion mode, the default
               completion type is restored.
'insert'     - The current completion type is saved until you exit insert
               mode (via ESC).  Once you exit insert mode the default
               completion type is restored. (supertab default)
'session'    - The current completion type is saved for the duration of
               your vim session or until you enter a different completion
               mode.


Preventing completion after...      *supertab-preventcomplete*
                                    *g:SuperTabNoCompleteBefore*
                                    *g:SuperTabNoCompleteAfter*

g:SuperTabNoCompleteBefore (default value: [])
g:SuperTabNoCompleteAfter (default value: ['\s'])

These two variables are used to control when supertab will attempt completion
or instead fall back to inserting a literal <tab>, by specifying a list of
patterns which are tested against the text before and after the current cursor
position that when matched, prevent completion. So if you don't want supertab
to start completion after a comma or space, you can set
g:SuperTabNoCompleteAfter to [',', '\s'].

Note: That a buffer local version of these variables
(b:SuperTabNoCompleteBefore, b:SuperTabNoCompleteAfter) is also supported
should you wish to have different values depending on the file type for
instance.

Changing the default mapping        *supertab-forwardbackward*
                                    *g:SuperTabMappingForward*
                                    *g:SuperTabMappingBackward*

g:SuperTabMappingForward  (default value: '<tab>')
g:SuperTabMappingBackward (default value: '<s-tab>')

These two variables allow you to set the keys used to kick off the current
completion.  By default this is <tab> and <s-tab>.  To change to something
like <c-space> and <s-c-space>, you can add the following to your |vimrc|.

        let g:SuperTabMappingForward = '<c-space>'
        let g:SuperTabMappingBackward = '<s-c-space>'

Note: if the above does not have the desired effect (which may happen in
console version of vim), you can try the following mappings.  Although the
backwards mapping still doesn't seem to work in the console for me, your
milage may vary.

        let g:SuperTabMappingForward = '<nul>'
        let g:SuperTabMappingBackward = '<s-nul>'


Inserting true tabs                 *supertab-mappingtabliteral*
                                    *g:SuperTabMappingTabLiteral*

g:SuperTabMappingTabLiteral (default value: '<c-tab>')

Sets the key mapping used to insert a literal tab where supertab would
otherwise attempt to kick off insert completion. The default is '<c-tab>'
(ctrl-tab) which unfortunately might not work at the console. So if you are
using a console vim and want this functionality, you may have to change it to
something that is supported.  Alternatively, you can escape the <tab> with
<c-v> (see |i_CTRL-V| for more infos).


Enhanced longest match support      *supertab-longestenhanced*
                                    *g:SuperTabLongestEnhanced*

g:SuperTabLongestEnhanced (default value: 0)

When enabled and 'longest' is in your |completeopt| setting, supertab will
provide an enhanced longest match support where typing one or more letters and
hitting tab again while in a completion mode will complete the longest common
match using the new text in the buffer.

For example, say you have a buffer with the following contents:
  FooBarFoo
  FooBar
  Foo
  FooBarBaz
And you then type F<tab>.  Vim's builtin longest support will complete the
longest common text 'Foo' and offer 'FooBarFoo', 'FooBar', 'Foo', and
'FooBarBaz' as possible completions.  With supertab's longest match
enhancement disabled, typing B<tab> while still in the completion mode will
end up completing 'FooBarBaz' or 'FooBarFoo' depending your settings, instead
of the next longest common match of 'FooBar'.  With supertab's enhanced
longest match feature enabled, the typing of B<tab> will result in the next
longest text being completed.


Preselecting the first entry        *supertab-longesthighlight*
                                    *g:SuperTabLongestHighlight*

g:SuperTabLongestHighlight (default value: 0)

Sets whether or not to pre-highlight the first match when completeopt has the
popup menu enabled and the 'longest' option as well. When enabled, <tab> will
kick off completion and pre-select the first entry in the popup menu, allowing
you to simply hit <enter> to use it.


Mapping <cr> to end completion      *supertab-crmapping*
                                    *g:SuperTabCrMapping*

g:SuperTabCrMapping (default value: 1)

When enabled, <cr> will cancel completion mode preserving the current text.

	19.30 session.vim : Extended session management for Vim 

		19.30.1 short description
		
		http://www.vim.org/scripts/script.php?script_id=3150


created by
Peter Odding
 
script type
utility
 
description
The session.vim plug-in improves upon Vim's built-in :mksession command by enabling you to easily and (if you want) automatically persist and restore your Vim editing sessions. It works by generating a Vim script that restores your current settings and the arrangement of tab pages and/or split windows and the files they contain. For more information about the plug-in please refer to its homepage or the project page on GitHub: 

• http://peterodding.com/code/vim/session/ 
• http://github.com/xolox/vim-session 

If you have questions, bug reports, suggestions, etc. the author can be contacted at peter@peterodding.com. If you like this plug-in please vote for it below!
 
install details
Unzip the most recent ZIP archive file (see below) inside your Vim profile directory (usually this is "~/.vim" on UNIX and "%USERPROFILE%\vimfiles" on Windows), restart Vim and execute the command ":helptags ~/.vim/doc" (use ":helptags ~\vimfiles\doc" instead on Windows). Now try it out: Open some tab pages and/or split windows, change your color scheme, etc. then save your session using the ":SaveSession my-first-session" command. You can now restore this session at any time by executing the ":OpenSession my-first-session" command.


		19.30.2 Long description
peterodding.com / code / vim / session

session.vim Extended session management for Vim

GitHub project: Watched by 46 people, most recent update was 37 hours ago
Vim Online page: Rated 39, downloaded 1370 times
The session.vim plug-in improves upon Vim’s built-in :mksession command by enabling you to easily and (if you want) automatically persist and restore your Vim editing sessions. It works by generating a Vim script that restores your current settings and the arrangement of tab pages and/or split windows and the files they contain.

To persist your current editing session you can execute the :SaveSession command. If you don’t provide a name for the session ‘default’ is used. You’re free to use whatever characters you like in session names. When you want to restore your session simply execute :OpenSession. Again the name ‘default’ is used if you don’t provide one. When a session is active, has been changed and you quit Vim you’ll be prompted whether you want to save the open session before quitting Vim:



When you start Vim without editing any files and the ‘default’ session exists, you’ll be prompted whether you want to restore the default session:



When you start Vim with a custom server name that matches one of the existing session names then the matching session will be automatically restored. For example I use several sessions to quickly edit my Vim plug-ins:

$ gvim --servername easytags-plugin
$ gvim --servername session-plugin
$ # etc.
The session scripts created by this plug-in are stored in the directory ~/.vim/sessions (on UNIX) or ~\vimfiles\sessions (on Windows) but you can change the location by setting g:session_directory. If you’re curious what the session scripts generated by session.vim look like see the sample below.

# Installation
Unzip the most recent ZIP archive file inside your Vim profile directory (usually this is ~/.vim on UNIX and %USERPROFILE%\vimfiles on Windows), restart Vim and execute the command :helptags ~/.vim/doc (use :helptags ~\vimfiles\doc instead on Windows). After you restart Vim the following commands will be available to you:

# Commands
# The :SaveSession command
This command saves your current editing session just like Vim’s built-in :mksession command does. The difference is that you don’t pass a full pathname as argument but just a name, any name really. Press <Tab> to get completion of existing session names. If you don’t provide an argument the name ‘default’ is used, unless an existing session is open in which case the name of that session will be used.

If the session you’re trying to save is already active in another Vim instance you’ll get a warning and nothing happens. You can use a bang (!) as in :SaveSession! ... to ignore the warning and save the session anyway.

As mentioned earlier your session script will be saved in the directory pointed to by g:session_directory.

# The :OpenSession command
This command is basically :source in disguise, but it supports tab completion of session names and it executes :CloseSession before opening the session. When you don’t provide a session name and only a single session exists then that session is opened, otherwise the plug-in will ask you to select one from a list:

Please select the session to restore:

| 1. vim-profile
| 2. session-plugin
| 3. etc.

Type number and <Enter> or click with mouse (empty cancels):
If the session you’re trying to open is already active in another Vim instance you’ll get a warning and nothing happens. You can use a bang (!) as in :OpenSession! ... to ignore the warning and open the session anyway.

Note also that when you use a bang (!) right after the command name existing tab pages and windows are closed, discarding any changes in the files you were editing!

# The :RestartVim command
This command saves your current editing session, restarts Vim and restores your editing session. This can come in handy when you’re debugging Vim scripts which can’t be easily/safely reloaded using a more lightweight approach. It should work fine on Windows and UNIX alike but because of technical limitations it only works in graphical Vim.

Any commands following the :RestartVim command are intercepted and executed after Vim is restarted and your session has been restored. This makes it easy to perform manual tests which involve restarting Vim, e.g. :RestartVim | edit /path/to/file | call MyTest().

# The :CloseSession command
This command closes all but the current tab page and window and then edits a new, empty buffer. If a session is loaded when you execute this command the plug-in will first ask you whether you want to save that session.

Note that when you use a bang (!) right after the command name existing tab pages and windows are closed, discarding any changes in the files you were editing!

# The :DeleteSession command
Using this command you can delete any of the sessions created by this plug-in. If the session you are trying to delete is currently active in another Vim instance you’ll get a warning and nothing happens. You can use a bang (!) as in :DeleteSession! ... to ignore the warning and delete the session anyway.

Note that this command only deletes the session script, it leaves your open tab pages and windows exactly as they were.

# The :ViewSession command
Execute this command to view the Vim script generated for a session. This command is useful when you need to review the generated Vim script repeatedly, for example while debugging or modifying the session.vim plug-in.

# Options
# The sessionoptions setting
Because the session.vim plug-in uses Vim’s :mksession command you can change how it works by setting ‘sessionoptions’ in your vimrc script, for example:

" If you only want to save the current tab page:
set sessionoptions-=tabpages
 
" If you don't want help windows to be restored:
set sessionoptions-=help
# The g:session_directory option
This option controls the location of your session scripts. Its default value is ~/.vim/sessions (on UNIX) or ~\vimfiles\sessions (on Windows). If you don’t mind the default you don’t have to do anything; the directory will be created for you. Note that a leading ~ is expanded to your current home directory ($HOME on UNIX, %USERPROFILE% on Windows).

# The g:session_autoload option
By default this option is set to 'prompt'. This means that when you start Vim without opening any files and the default session script exists, the session plug-in will ask whether you want to restore your default session. When you set this option to 'yes' and you start Vim without opening any files the default session will be restored without a prompt. To completely disable automatic loading you can set this option to 'no'.

# The g:session_autosave option
By default this option is set to 'prompt'. When you’ve opened a session and you quit Vim, the session plug-in will ask whether you want to save the changes to your session. Set this option to 'yes' to always automatically save open sessions when you quit Vim. To completely disable automatic saving you can set this option to 'no'.

# The g:session_default_to_last option
By default this option is set to false (0). When you set this option to true (1) and you start Vim, the session plug-in will open your last used session instead of the default session. Note that the session plug-in will still show you the dialog asking whether you want to restore the last used session. To get rid of the dialog you have to set g:session_autoload to 'yes'.

# The g:loaded_session option
This variable isn’t really an option but if you want to avoid loading the session.vim plug-in you can set this variable to any value in your vimrc script:

:let g:loaded_session = 1
# Compatibility with other plug-ins
Vim’s :mksession command isn’t fully compatible with plug-ins that create buffers with generated content and because of this session.vim includes specific workarounds for such plug-ins:

NERD tree and Project windows are supported;
When shell.vim is installed Vim’s full-screen state is persisted;
The netrw and taglist.vim plug-ins support sessions out of the box.
If your favorite plug-in doesn’t work with session.vim drop me a mail and I’ll see what I can do. Please include a link to the plug-in in your e-mail so that I can install and test the plug-in.

# Known issues
Recently this plug-in switched from reimplementing :mksession to actually using it because this was the only way to support complex split window layouts. Only after making this change did I realize :mksession doesn’t support quickfix and location list windows and of course it turns out that bolting on support for these after the fact is going to complicate the plug-in significantly (in other words, I’m working on it but it might take a while…)

# Contact
If you have questions, bug reports, suggestions, etc. the author can be contacted at peter@peterodding.com. The latest version is available at http://peterodding.com/code/vim/session/ and http://github.com/xolox/vim-session. If you like the script please vote for it on Vim Online.

# License
This software is licensed under the MIT license.
© 2011 Peter Odding <peter@peterodding.com>.

# Sample session script
Here’s an example session script generated by the session.vim plug-in while I was editing the plug-in itself in Vim:

" ~/.vim/sessions/example.vim: Vim session script.
" Created by session.vim on 30 August 2010 at 05:26:28.
" Open this file in Vim and run :source % to restore your session.
 
set guioptions=aegit
set guifont=Monaco\ 13
if exists('g:syntax_on') != 1 | syntax on | endif
if exists('g:did_load_filetypes') != 1 | filetype on | endif
if exists('g:did_load_ftplugin') != 1 | filetype plugin on | endif
if exists('g:did_indent_on') != 1 | filetype indent on | endif
if !exists('g:colors_name') || g:colors_name != 'slate' | colorscheme slate | endif
call setqflist([])
let SessionLoad = 1
if &cp | set nocp | endif
let s:so_save = &so | let s:siso_save = &siso | set so=0 siso=0
let v:this_session=expand("<sfile>:p")
silent only
cd ~/Development/Vim/vim-session
if expand('%') == '' && !&modified && line('$') <= 1 && getline(1) == ''
  let s:wipebuf = bufnr('%')
endif
set shortmess=aoO
badd +473 ~/Development/Vim/vim-session/autoload.vim
badd +1 ~/Development/Vim/vim-session/README.md
badd +1 ~/Development/Vim/vim-session/session.vim
badd +1 ~/Development/Vim/vim-session/TODO.md
set lines=43 columns=167
edit ~/Development/Vim/vim-session/README.md
set splitbelow splitright
set nosplitbelow
set nosplitright
wincmd t
set winheight=1 winwidth=1
argglobal
let s:l = 28 - ((27 * winheight(0) + 21) / 42)
if s:l < 1 | let s:l = 1 | endif
exe s:l
normal! zt
28
normal! 0
tabedit ~/Development/Vim/vim-session/TODO.md
set splitbelow splitright
set nosplitbelow
set nosplitright
wincmd t
set winheight=1 winwidth=1
argglobal
let s:l = 6 - ((5 * winheight(0) + 21) / 42)
if s:l < 1 | let s:l = 1 | endif
exe s:l
normal! zt
6
normal! 0
tabedit ~/Development/Vim/vim-session/session.vim
set splitbelow splitright
set nosplitbelow
set nosplitright
wincmd t
set winheight=1 winwidth=1
argglobal
let s:l = 17 - ((16 * winheight(0) + 21) / 42)
if s:l < 1 | let s:l = 1 | endif
exe s:l
normal! zt
17
normal! 014l
tabedit ~/Development/Vim/vim-session/autoload.vim
set splitbelow splitright
set nosplitbelow
set nosplitright
wincmd t
set winheight=1 winwidth=1
argglobal
let s:l = 473 - ((41 * winheight(0) + 21) / 42)
if s:l < 1 | let s:l = 1 | endif
exe s:l
normal! zt
473
normal! 018l
tabnext 4
if exists('s:wipebuf')
  silent exe 'bwipe ' . s:wipebuf
endif
unlet! s:wipebuf
set winheight=1 winwidth=1 shortmess=filnxtToO
let s:sx = expand("<sfile>:p:r")."x.vim"
if file_readable(s:sx)
  exe "source " . fnameescape(s:sx)
endif
let &so = s:so_save | let &siso = s:siso_save
doautoall SessionLoadPost
unlet SessionLoad

		19.30.3

"
	19.31 vim-addon-manager : manage and update plugins easily 


created by
Marc Weber
 
script type
utility
 
description
NEW: Windows users can use this download form now: http://mawercer.de/~marc/vam/index.php to get plugins. 

Note: 
There is also  http://packages.debian.org/sid/vim-addon-manager 
which servers a similar purpose but is Debian specific. 
I chose the same name by accident. See doc/* 

usage example: 

set runtimepath+=~/path-to/vim-plugin-manager 
call scriptmanager#Activate(["vim-haxe","The_NERD_tree","vim-latex"]) 

On startup you'll have to confirm installing plugins. 
For reviewing plugins before usage try :InstallAddon command which downloads only 

Note: I setup a cron job which updates the 
vim-plugin-manager-known-repositories every couple of days. 

Detailed description can be found in the doc directory of this distribution. 

TROUBLE ? Contact me or create a ticket (github page).
 
install details
brief: unzip and add to your runtimepath. 

Details: http://github.com/MarcWeber/vim-addon-manager/blob/master/doc/vim-addon-manager.txt


*/
	19.32 snipMate
http://www.catonmat.net/blog/vim-plugins-snipmate-vim/

Snipmate.vim is probably the best snippets plugin for vim. A snippet is a piece of often-typed text or programming construct that you can insert into your document by using a trigger followed by a <tab>. It was written by Michael Sanders. He says he modeled this plugin after TextMate's snippets.

Here is an example usage of snipmate.vim. If you are a C programmer, then one of the most often used forms of a loop is "for (i=0; i<n; i++) { ... }". Without snippets you'd have to type this out every time. Even though it takes just another second, these seconds can add to minutes throughout the day and minutes can add to hours over longer periods of time. Why waste your time this way? With snippets you can type just "for<tab>" and snipmate will insert this whole construct in your source code automatically! If "i" or "n" weren't the variable you wanted to use, you can now use <tab> and <shift-tab> to jump to next/previous item in the loop and rename them!

    |1. Download snipmate.zip.
    |2. Extract snipmate.zip to ~/.vim (on Unix/Linux) or ~\vimfiles (on Windows).
    |3. Run :helptags ~/.vim/doc (on Unix/Linux) or :helptags ~/vimfiles/doc (on Windows) to rebuild the tags file (so that you can read :help snipmate.)
    |4. Restart Vim.

The plugin comes with predefined snippets for more than a dozen languages (C, C++, HTML, Java, JavaScript, Objective C, Perl, PHP, Python, Ruby, Tcl, Shell, HTML, Mako templates, LaTeX, VimScript). Be sure to check out the snippet files in the "snippets" directory under your ~/.vim or ~\vimfiles directory.

If you need to define your own snippets (which you most likely will need), create a new file named "language-foo.snippets" in the "snippets" directory. For example, to define your own snippets for C language, you'd create a file called "c-foo.snippets" and place snippets in it.

To learn about snipmate snippet syntax, type ":help snipmate" and locate the syntax section in the help file.


		19.32.1 :h snipMate  


==============================================================================
DESCRIPTION                                             *snipMate-description*

snipMate.vim implements some of TextMate's snippets features in Vim. A
snippet is a piece of often-typed text that you can insert into your
document using a trigger word followed by a <tab>.

For instance, in a C file using the default installation of snipMate.vim, if
you type "for<tab>" in insert mode, it will expand a typical for loop in C: >

 for (i = 0; i < count; i++) {

 }


To go to the next item in the loop, simply <tab> over to it; if there is
repeated code, such as the "i" variable in this example, you can simply
start typing once it's highlighted and all the matches specified in the
snippet will be updated. To go in reverse, use <shift-tab>.

==============================================================================
SYNTAX                                                        *snippet-syntax*

Snippets can be defined in two ways. They can be in their own file, named
after their trigger in 'snippets/<filetype>/<trigger>.snippet', or they can be
defined together in a 'snippets/<filetype>.snippets' file. Note that dotted
'filetype' syntax is supported -- e.g., you can use >

	:set ft=html.eruby

to activate snippets for both HTML and eRuby for the current file.

The syntax for snippets in *.snippets files is the following: >

 snippet trigger
 	expanded text
	more expanded text

Note that the first hard tab after the snippet trigger is required, and not
expanded in the actual snippet. The syntax for *.snippet files is the same,
only without the trigger declaration and starting indentation.

Also note that snippets must be defined using hard tabs. They can be expanded
to spaces later if desired (see |snipMate-indenting|).

"#" is used as a line-comment character in *.snippets files; however, they can
only be used outside of a snippet declaration. E.g.: >

 # this is a correct comment
 snippet trigger
 	expanded text
 snippet another_trigger
 	# this isn't a comment!
	expanded text
<
This should hopefully be obvious with the included syntax highlighting.

		19.32.2 C snip

# main()
snippet main
	int main(int argc, const char *argv[])
	{
		${1}
		return 0;
	}
# #include <...>
snippet inc
	#include <${1:stdio}.h>${2}
# #include "..."
snippet Inc
	#include "${1:`Filename("$1.h")`}"${2}
# #ifndef ... #define ... #endif
snippet Def
	#ifndef $1
	#define ${1:SYMBOL} ${2:value}
	#endif${3}
snippet def
	#define 
snippet ifdef
	#ifdef ${1:FOO}
		${2:#define }
	#endif
snippet #if
	#if ${1:FOO}
		${2}
	#endif
# Header Include-Guard
# (the randomizer code is taken directly from TextMate; it could probably be
# cleaner, I don't know how to do it in vim script)
snippet once
	#ifndef ${1:`toupper(Filename('', 'UNTITLED').'_'.system("/usr/bin/ruby -e 'print (rand * 2821109907455).round.to_s(36)'"))`}

	#define $1

	${2}

	#endif /* end of include guard: $1 */
# If Condition
snippet if
	if (${1:/* condition */}) {
		${2:/* code */}
	}
snippet el
	else {
		${1}
	}
# Tertiary conditional
snippet t
	${1:/* condition */} ? ${2:a} : ${3:b}
# Do While Loop
snippet do
	do {
		${2:/* code */}
	} while (${1:/* condition */});
# While Loop
snippet wh
	while (${1:/* condition */}) {
		${2:/* code */}
	}
# For Loop
snippet for
	for (${2:i} = 0; $2 < ${1:count}; $2${3:++}) {
		${4:/* code */}
	}
# Custom For Loop
snippet forr
	for (${1:i} = ${2:0}; ${3:$1 < 10}; $1${4:++}) {
		${5:/* code */}
	}
# Function
snippet fun
	${1:void} ${2:function_name}(${3})
	{
		${4:/* code */}
	}
# Function Declaration
snippet fund
	${1:void} ${2:function_name}(${3});${4}
# Typedef
snippet td
	typedef ${1:int} ${2:MyCustomType};${3}
# Struct
snippet st
	struct ${1:`Filename('$1_t', 'name')`} {
		${2:/* data */}
	}${3: /* optional variable list */};${4}
# Typedef struct
snippet tds
	typedef struct ${2:_$1 }{
		${3:/* data */}
	} ${1:`Filename('$1_t', 'name')`};
# Typdef enum
snippet tde
	typedef enum {
		${1:/* data */}
	} ${2:foo};
# printf
# unfortunately version this isn't as nice as TextMates's, given the lack of a
# dynamic `...`
snippet pr
	printf("${1:%s}\n"${2});${3}
# fprintf (again, this isn't as nice as TextMate's version, but it works)
snippet fpr
	fprintf(${1:stderr}, "${2:%s}\n"${3});${4}
snippet .
	[${1}]${2}
snippet un
	unsigned

		19.32.3 c++ snip

# Read File Into Vector
snippet readfile
	std::vector<char> v;
	if (FILE *${2:fp} = fopen(${1:"filename"}, "r")) {
		char buf[1024];
		while (size_t len = fread(buf, 1, sizeof(buf), $2))
			v.insert(v.end(), buf, buf + len);
		fclose($2);
	}${3}
# std::map
snippet map
	std::map<${1:key}, ${2:value}> map${3};
# std::vector
snippet vector
	std::vector<${1:char}> v${2};
# Namespace
snippet ns
	namespace ${1:`Filename('', 'my')`} {
		${2}
	} /* $1 */
# Class
snippet cl
	class ${1:`Filename('$1_t', 'name')`} {
	public:
		$1 (${2:arguments});
		virtual ~$1 ();
	
	private:
		${3:/* data */}
	};

		19.32.4 Java snips 

snippet main
	public static void main (String [] args)
	{
		${1:/* code */}
	}
snippet pu
	public
snippet po
	protected
snippet pr
	private
snippet st
	static
snippet fi
	final
snippet ab
	abstract
snippet re
	return
snippet br
	break;
snippet de
	default:
		${1}
snippet ca
	catch(${1:Exception} ${2:e}) ${3}
snippet th
	throw 
snippet sy
	synchronized
snippet im
	import
snippet j.u
	java.util
snippet j.i
	java.io.
snippet j.b
	java.beans.
snippet j.n
	java.net.
snippet j.m
	java.math.
snippet if
	if (${1}) ${2}
snippet el
	else 
snippet elif
	else if (${1}) ${2}
snippet wh
	while (${1}) ${2}
snippet for
	for (${1}; ${2}; ${3}) ${4}
snippet fore
	for (${1} : ${2}) ${3}
snippet sw
	switch (${1}) ${2}
snippet cs
	case ${1}:
		${2}
	${3}
snippet tc
	public class ${1:`Filename()`} extends ${2:TestCase}
snippet t
	public void test${1:Name}() throws Exception ${2}
snippet cl
	class ${1:`Filename("", "untitled")`} ${2}
snippet in
	interface ${1:`Filename("", "untitled")`} ${2:extends Parent}${3}
snippet m
	${1:void} ${2:method}(${3}) ${4:throws }${5}
snippet v
	${1:String} ${2:var}${3: = null}${4};${5}
snippet co
	static public final ${1:String} ${2:var} = ${3};${4}
snippet cos
	static public final String ${1:var} = "${2}";${3}
snippet as
	assert ${1:test} : "${2:Failure message}";${3}

		19.32.5 perl snip

# #!/usr/bin/perl
snippet #!
	#!/usr/bin/perl
	
# Hash Pointer
snippet .
	 =>
# Function
snippet sub
	sub ${1:function_name} {
		${2:#body ...}
	}
# Conditional
snippet if
	if (${1}) {
		${2:# body...}
	}
# Conditional if..else
snippet ife
	if (${1}) {
		${2:# body...}
	} else {
		${3:# else...}
	}
# Conditional if..elsif..else
snippet ifee
	if (${1}) {
		${2:# body...}
	} elsif (${3}) {
		${4:# elsif...}
	} else {
		${5:# else...}
	}
# Conditional One-line
snippet xif
	${1:expression} if ${2:condition};${3}
# Unless conditional
snippet unless
	unless (${1}) {
		${2:# body...}
	}
# Unless conditional One-line
snippet xunless
	${1:expression} unless ${2:condition};${3}
# Try/Except
snippet eval
	eval {
		${1:# do something risky...}
	};
	if ($@) {
		${2:# handle failure...}
	}
# While Loop
snippet wh
	while (${1}) {
		${2:# body...}
	}
# While Loop One-line
snippet xwh
	${1:expression} while ${2:condition};${3}
# For Loop
snippet for
	for (my $${2:var} = 0; $$2 < ${1:count}; $$2${3:++}) {
		${4:# body...}
	}
# Foreach Loop
snippet fore
	foreach my $${1:x} (@${2:array}) {
		${3:# body...}
	}
# Foreach Loop One-line
snippet xfore
	${1:expression} foreach @${2:array};${3}
# Package
snippet cl
	package ${1:ClassName};
	
	use base qw(${2:ParentClass});
	
	sub new {
		my $class = shift;
		$class = ref $class if ref $class;
		my $self = bless {}, $class;
		$self;
	}
	
	1;${3}
# Read File
snippet slurp
	my $${1:var};
	{ local $/ = undef; local *FILE; open FILE, "<${2:file}"; $$1 = <FILE>; close FILE }${3}

		19.32.6 python snip

snippet #!
	#!/usr/bin/python

snippet imp
	import ${1:module}
# Module Docstring
snippet docs
	'''
	File: ${1:`Filename('$1.py', 'foo.py')`}
	Author: ${2:`g:snips_author`}
	Description: ${3}
	'''
snippet wh
	while ${1:condition}:
		${2:# code...}
snippet for
	for ${1:needle} in ${2:haystack}:
		${3:# code...}
# New Class
snippet cl
	class ${1:ClassName}(${2:object}):
		"""${3:docstring for $1}"""
		def __init__(self, ${4:arg}):
			${5:super($1, self).__init__()}
			self.$4 = $4
			${6}
# New Function
snippet def
	def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
		"""${3:docstring for $1}"""
		${4:pass}
snippet deff
	def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
		${3}
# New Method
snippet defs
	def ${1:mname}(self, ${2:arg}):
		${3:pass}
# New Property
snippet property
	def ${1:foo}():
		doc = "${2:The $1 property.}"
		def fget(self):
			${3:return self._$1}
		def fset(self, value):
			${4:self._$1 = value}
# Lambda
snippet ld
	${1:var} = lambda ${2:vars} : ${3:action}
snippet .
	self.
snippet try Try/Except
	try:
		${1:pass}
	except ${2:Exception}, ${3:e}:
		${4:raise $3}
snippet try Try/Except/Else
	try:
		${1:pass}
	except ${2:Exception}, ${3:e}:
		${4:raise $3}
	else:
		${5:pass}
snippet try Try/Except/Finally
	try:
		${1:pass}
	except ${2:Exception}, ${3:e}:
		${4:raise $3}
	finally:
		${5:pass}
snippet try Try/Except/Else/Finally
	try:
		${1:pass}
	except ${2:Exception}, ${3:e}:
		${4:raise $3}
	else:
		${5:pass}
	finally:
		${6:pass}
# if __name__ == '__main__':
snippet ifmain
	if __name__ == '__main__':
		${1:main()}
# __magic__
snippet _
	__${1:init}__${2}

		19.32.7 bash snip

# #!/bin/bash
snippet #!
	#!/bin/bash
	
snippet if
	if [[ ${1:condition} ]]; then
		${2:#statements}
	fi
snippet elif
	elif [[ ${1:condition} ]]; then
		${2:#statements}
snippet for
	for (( ${2:i} = 0; $2 < ${1:count}; $2++ )); do
		${3:#statements}
	done
snippet wh
	while [[ ${1:condition} ]]; do
		${2:#statements}
	done
snippet until
	until [[ ${1:condition} ]]; do
		${2:#statements}
	done
snippet case
	case ${1:word} in
		${2:pattern})
			${3};;
	esac

		19.32.8 html snip

# Some useful Unicode entities
# Non-Breaking Space
snippet nbs
	&nbsp;
# ←
snippet left
	&#x2190;
# →
snippet right
	&#x2192;
# ↑
snippet up
	&#x2191;
# ↓
snippet down
	&#x2193;
# ↩
snippet return
	&#x21A9;
# ⇤
snippet backtab
	&#x21E4;
# ⇥
snippet tab
	&#x21E5;
# ⇧
snippet shift
	&#x21E7;
# ⌃
snippet control
	&#x2303;
# ⌅
snippet enter
	&#x2305;
# ⌘
snippet command
	&#x2318;
# ⌥
snippet option
	&#x2325;
# ⌦
snippet delete
	&#x2326;
# ⌫
snippet backspace
	&#x232B;
# ⎋
snippet escape
	&#x238B;
# Generic Doctype
snippet doctype HTML 4.01 Strict
	<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""
	"http://www.w3.org/TR/html4/strict.dtd">
snippet doctype HTML 4.01 Transitional
	<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""
	"http://www.w3.org/TR/html4/loose.dtd">
snippet doctype HTML 5
	<!DOCTYPE HTML>
snippet doctype XHTML 1.0 Frameset
	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
snippet doctype XHTML 1.0 Strict
	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
snippet doctype XHTML 1.0 Transitional
	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
snippet doctype XHTML 1.1
	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
	"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
# HTML Doctype 4.01 Strict
snippet docts
	<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""
	"http://www.w3.org/TR/html4/strict.dtd">
# HTML Doctype 4.01 Transitional
snippet doct
	<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""
	"http://www.w3.org/TR/html4/loose.dtd">
# HTML Doctype 5
snippet doct5
	<!DOCTYPE HTML>
# XHTML Doctype 1.0 Frameset
snippet docxf
	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
# XHTML Doctype 1.0 Strict
snippet docxs
	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
# XHTML Doctype 1.0 Transitional
snippet docxt
	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
# XHTML Doctype 1.1
snippet docx
	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
	"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
snippet html
	<html>
	${1}
	</html>
snippet xhtml
	<html xmlns="http://www.w3.org/1999/xhtml">
	${1}
	</html>
snippet body
	<body>
		${1}
	</body>
snippet head
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8"`Close()`>

		<title>${1:`substitute(Filename('', 'Page Title'), '^.', '\u&', '')`}</title>
		${2}
	</head>
snippet title
	<title>${1:`substitute(Filename('', 'Page Title'), '^.', '\u&', '')`}</title>${2}
snippet script
	<script type="text/javascript" charset="utf-8">
		${1}
	</script>${2}
snippet scriptsrc
	<script src="${1}.js" type="text/javascript" charset="utf-8"></script>${2}
snippet style
	<style type="text/css" media="${1:screen}">
		${2}
	</style>${3}
snippet base
	<base href="${1}" target="${2}"`Close()`>
snippet r
	<br`Close()[1:]`>
snippet div
	<div id="${1:name}">
		${2}
	</div>
# Embed QT Movie
snippet movie
	<object width="$2" height="$3" classid="clsid:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B"
	 codebase="http://www.apple.com/qtactivex/qtplugin.cab">
		<param name="src" value="$1"`Close()`>
		<param name="controller" value="$4"`Close()`>
		<param name="autoplay" value="$5"`Close()`>
		<embed src="${1:movie.mov}"
			width="${2:320}" height="${3:240}"
			controller="${4:true}" autoplay="${5:true}"
			scale="tofit" cache="true"
			pluginspage="http://www.apple.com/quicktime/download/"
		`Close()[1:]`>
	</object>${6}
snippet fieldset
	<fieldset id="$1">
		<legend>${1:name}</legend>

		${3}
	</fieldset>
snippet form
	<form action="${1:`Filename('$1_submit')`}" method="${2:get}" accept-charset="utf-8">
		${3}


	<p><input type="submit" value="Continue &rarr;"`Close()`></p>
	</form>
snippet h1
	<h1 id="${1:heading}">${2:$1}</h1>
snippet input
	<input type="${1:text/submit/hidden/button}" name="${2:some_name}" value="${3}"`Close()`>${4}
snippet label
	<label for="${2:$1}">${1:name}</label><input type="${3:text/submit/hidden/button}" name="${4:$2}" value="${5}" id="${6:$2}"`Close()`>${7}
snippet link
	<link rel="${1:stylesheet}" href="${2:/css/master.css}" type="text/css" media="${3:screen}" charset="utf-8"`Close()`>${4}
snippet mailto
	<a href="mailto:${1:joe@example.com}?subject=${2:feedback}">${3:email me}</a>
snippet meta
	<meta name="${1:name}" content="${2:content}"`Close()`>${3}
snippet opt
	<option value="${1:option}">${2:$1}</option>${3}
snippet optt
	<option>${1:option}</option>${2}
snippet select
	<select name="${1:some_name}" id="${2:$1}">
		<option value="${3:option}">${4:$3}</option>
	</select>${5}
snippet table
	<table border="${1:0}">
		<tr><th>${2:Header}</th></tr>
		<tr><th>${3:Data}</th></tr>
	</table>${4}
snippet textarea
	<textarea name="${1:Name}" rows="${2:8}" cols="${3:40}">${4}</textarea>${5}

		19.32.9

	19.33 stlrefvim : A C++ Standard Template Library reference manual 
http://www.vim.org/scripts/script.php?script_id=2353

description
This plugin aims to provide a reference manual for the C++ standard template library (STL).  Based heavily off of the well-regarded SGI-STL documentation, this script puts the power of this documentation into your vim workflow.  Lookups can easily be done with user-configurable key mappings. 

For example, in the expression: 
    std::for_each(start, end, PrintFunc) 
place the cursor over for_each and type <Leader>tr to go to documentation for this function.  Type <Leader>te to go to an example that uses this function. 

Many thanks must go to Christian Habermann's for his crefvim plugin (http://www.vim.org/scripts/script.php?script_id=614) that formed the basis of and was the inspiration for this plugin.
 
install details
stlrefvim consists of two files: the script 'stlrefvim.vim' and its documentation 'stlrefvim.txt'. 

To use the script copy it into your local plugin-directory 
  Unix:    ~/.vim/plugin 
  Windows: c:\vimfiles\plugin 

You have to add this documentation and the STL-reference to Vim's help system. To do this, copy 'stlrefvim.txt' to your local doc-directory: 
  Unix:    ~/.vim/doc 
  Windows: c:\vimfiles\doc 

Then start Vim and do: 
  :helptags ~/.vim/doc   (or :helptags c:\vimfiles\doc for Windows)

  \tr - manual
  \te - example
  \tw - search
  \tc - ToC

	19.34 Pathogen

update all bundles from git
[i500695@WYLQRXL9LQ:2023-01-22 15:51:35:~/.vim/bundle:]2019$ for d in */;do echo $d; cd $d; gitfp; cd -; done

Also after clone remember to run submodule init/update:
[i500695@WYLQRXL9LQ:2023-01-22 16:02:51:~/.vim/bundle/ultisnips:]2018$ git submodule init
[i500695@WYLQRXL9LQ:2023-01-22 16:02:53:~/.vim/bundle/ultisnips:]2019$ git submodule update
		19.34.1 http://www.vim.org/scripts/script.php?script_id=2332


created by
Tim Pope
 
script type
utility
 
description
Manage your 'runtimepath' with ease.  In practical terms, pathogen.vim makes it super easy to install plugins and runtime files in their own private directories. 

Add this to your vimrc: 

    call pathogen#infect() 

Now any plugins you wish to install can be extracted to a subdirectory under ~/.vim/bundle, and they will be added to the 'runtimepath'. 

Use :Helptags to run :helptags on every doc/ directory in your 'runtimepath'. 

For more detailed, better formatted documentation, see the README on GitHub: 

http://github.com/tpope/vim-pathogen
 
install details
Install in ~/.vim/autoload (~\vimfiles\autoload on Windows). Or copy and paste: 

mkdir -p ~/.vim/autoload ~/.vim/bundle 
curl 'www.vim.org/scripts/download_script.php?src_id=19375' \ 
  > ~/.vim/autoload/pathogen.vim

		19.34.2 Using Vim with Pathogen

July 18, 2011 § 5 Comments

Vim is my editor of choice. Vim is everywhere and has hundreds of plugins to allow you to do pretty much anything a text editor can possibly do.

The problem is, setting up Vim to use plugins is not the simplest thing to do. Enter Pathogen.

Pathogen is written by Vim plugin guru Tim Pope, it lets you isolate plugin scripts under their own directories. This means easy installs, uninistalls and upgrades.

Here’s a walk through about how to get this up and running:


I always like to start things from a clean slate, so firstly backup anything you already have:

mv ~/.vimrc ~/.vimrc.bak
mv ~/.vim/ ~/.vimbak/
Next create a brand new .vim directory and download pathogen:

mkdir -p ~/.vim/autoload
mkdir -p ~/.vim/bundle
cd ~/.vim/autoload
curl https://github.com/tpope/vim-pathogen/raw/master/autoload/pathogen.vim > pathogen.vim
Now create a new ~/.vimrc and put the following lines at the top:

" Pathogen
filetype off " Pathogen needs to run before plugin indent on
call pathogen#runtime_append_all_bundles()
call pathogen#helptags() " generate helptags for everything in 'runtimepath'
filetype plugin indent on

That’s pretty much it.

Now for the payoff – git powered plugin management. As seems to be the case with most code these days, many vim plugins are hosted on Github

Let’s walk through installing the popular NERDTree plugin. This plugin gives Vim a Textmate style project drawer:

cd ~/.vim/bundle
git clone git://github.com/scrooloose/nerdtree.git
restart vim, and boom NerdTree is installed, do a :NERDTreeToggle to hide and show the project drawer. To uninstall just delete the cloned repo:

rm -Rf ~/.vim/bundle/nerdtree
Simples.

Here are some of the plugins I like:

rails.vim Essential if you’re a Rails developer, allows switching between files, autocompletion, refactoring, and lots more.
git clone git://github.com/tpope/vim-rails.git
Command-T Leader t (usually \t) for quickly finding files.
git clone git://git.wincent.com/command-t.git
snipmate.vim TextMate-style snippets in Vim: type def and a Ruby method block gets created.
git clone git://github.com/msanders/snipmate.vim.git
vividchalk.vim A colorscheme strangely reminiscent of Vibrant Ink for a certain OS X editor.
git clone git://github.com/tpope/vim-vividchalk.git

		19.34.3 git repo 

			19.34.3.1 https://github.com/lambacck/vimconfig/blob/master/.gitmodules

			19.34.3.2 https://github.com/vim-scripts

		19.34.4 My examples

			19.34.4.1 Linux


[yizaq@cow1:Tue Jul 30:1012:15:~/.vim/bundle]$ git clone git://github.com/lambacck/VisIncr.git

			19.34.4.2 Windows
			 git clone git://github.com/Shougo/neocomplcache.vim

c:\Program Files (x86)\Vim\vim74\bundle>git clone git://github.com/vim-scripts/taglist.vim

c:\Program Files (x86)\Vim\vim74\bundle>git clone git://github.com/vim-scripts/Colour-Sampler-Pack

c:\Program Files (x86)\Vim\vim74\bundle>git clone git://github.com/vim-scripts/a.vim

c:\Program Files (x86)\Vim\vim74\bundle>git clone git://github.com/vim-scripts/bash-support.vim

c:\Program Files (x86)\Vim\vim74\bundle>git clone git://github.com/vim-scripts/bufexplorer.zip

c:\Program Files (x86)\Vim\vim74\bundle>git clone git://github.com/vim-scripts/c.vim

c:\Program Files (x86)\Vim\vim74\bundle>git clone git://github.com/vim-scripts/cscope.vim

c:\Program Files (x86)\Vim\vim74\bundle>git clone git://github.com/vim-scripts/DrawIt

c:\Program Files (x86)\Vim\vim74\bundle>git clone git://github.com/vim-scripts/LargeFile

c:\Program Files (x86)\Vim\vim74\bundle>git clone git://github.com/vim-scripts/matchit.zip

c:\Program Files (x86)\Vim\vim74\bundle>git clone git://github.com/vim-scripts/minibufexpl.vim

c:\Program Files (x86)\Vim\vim74\bundle>git clone git://github.com/vim-scripts/perl-support.vim

c:\Program Files (x86)\Vim\vim74\bundle>git clone git://github.com/vim-scripts/The-NERD-tree

c:\Program Files (x86)\Vim\vim74\bundle>git clone git://github.com/vim-scripts/ShowMarks

c:\Program Files (x86)\Vim\vim74\bundle>git clone git://github.com/vim-scripts/SuperTab

c:\Program Files (x86)\Vim\vim74\bundle>git clone git://github.com/vim-scripts/surround.vim

c:\Program Files (x86)\Vim\vim74\bundle>git clone git://github.com/vim-scripts/tagexplorer.vim

c:\Program Files (x86)\Vim\vim74\bundle>git clone git://github.com/vim-scripts/VisIncr

c:\Program Files (x86)\Vim\vim74\bundle>git clone git://github.com/vim-scripts/netrw.vim
c:\Program Files (x86)\Vim\vim74\bundle>git clone git://github.com/vim-scripts/snipMate

c:\Program Files (x86)\Vim\vim74\bundle>git clone git://github.com/vim-scripts/TaskList.vim
c:\Program Files (x86)\Vim\vim74\bundle>git clone git://github.com/vim-scripts/Gundo

			19.34.4.3 Cygwin

git clone git://github.com/vim-scripts/taglist.vim
git clone git://github.com/vim-scripts/Colour-Sampler-Pack
git clone git://github.com/vim-scripts/a.vim
git clone git://github.com/vim-scripts/bash-support.vim
git clone git://github.com/vim-scripts/bufexplorer.zip
git clone git://github.com/vim-scripts/c.vim
git clone git://github.com/vim-scripts/cscope.vim
git clone git://github.com/vim-scripts/DrawIt
git clone git://github.com/vim-scripts/LargeFile
git clone git://github.com/vim-scripts/matchit.zip
git clone git://github.com/vim-scripts/minibufexpl.vim
git clone git://github.com/vim-scripts/perl-support.vim
git clone git://github.com/vim-scripts/The-NERD-tree
git clone git://github.com/vim-scripts/ShowMarks
git clone git://github.com/vim-scripts/SuperTab
git clone git://github.com/vim-scripts/surround.vim
git clone git://github.com/vim-scripts/tagexplorer.vim
git clone git://github.com/vim-scripts/VisIncr
git clone git://github.com/vim-scripts/netrw.vim
git clone git://github.com/vim-scripts/snipMate
git clone git://github.com/vim-scripts/TaskList.vim
git clone git://github.com/vim-scripts/Gundo

			19.34.4.4 Mac
YIZAQ-M-D1BW:~ yizaq$ cd ~/.vim/bundle/
YIZAQ-M-D1BW:bundle yizaq$ ls
Colour-Sampler-Pack	LargeFile		TaskList.vim		a.vim			c.vim			highlights		netrw.vim		surround.vim		utl.vim
DrawIt			ShowMarks		The-NERD-tree		bash-support.vim	cscope.vim		matchit.zip		perl-support.vim	tagexplorer.vim		vim-easymotion
Gundo			SuperTab		VisIncr			bufexplorer.zip		ctrlp.vim		minibufexpl.vim		snipMate		taglist.vim

git clone git://github.com/vim-scripts/vim-easymotion
YIZAQ-M-D1BW:bundle yizaq$ git clone git://github.com/valloric/YouCompleteMe/
[yizaq@YIZAQ-M-D1BW:Mon Dec 07:~/.vim/bundle:]$ git clone git://github.com/Shougo/neocomplete.vim

			19.34.4.5
		19.34.5
	19.35 Gundo
Graph your Vim undo tree in style.

gundo
You know that Vim lets you undo changes like any text editor. What you might not know is that it doesn't just keep a list of your changes — it keeps a tree of them.

Say you make a change (call it X), undo that change, and then make another change (call it Y). With most editors, change X is now gone forever. With Vim you can get it back.

The problem is that trying to do this in the real world is painful. Vim gives you an :undolist command that shows you the leaves of the tree. Good luck finding the change you want in that list.

Gundo is a plugin to make browsing this ridiculously powerful undo tree less painful.

Check out this quick screencast if you want to see it in action.

Requirements
Installation
Usage
Configuration
g:gundo_width
g:gundo_preview_height
g:gundo_preview_bottom
g:gundo_right
g:gundo_help
g:gundo_disable
g:gundo_map_move_[older/newer]
g:gundo_close_on_revert
g:gundo_[preview/tree]_statusline
g:gundo_auto_preview
g:gundo_playback_delay
License
Bugs
Contributing
Changelog
Credits
Requirements

Gundo requires Vim 7.3+ compiled with Python support, and Python 2.4+.

Installation

Use Pathogen. Don't use pathogen? Start.

hg clone http://bitbucket.org/sjl/gundo.vim ~/.vim/bundle/gundo
There's a git mirror if you prefer:

git clone http://github.com/sjl/gundo.vim.git ~/.vim/bundle/gundo
Add a mapping to your ~/.vimrc (change the key to suit your taste):

nnoremap <F5> :GundoToggle<CR>
Usage

We'll get to the technical details later, but if you're a human the first thing you need to do is add a mapping to your vimrc file to toggle the undo graph:

nnoremap <F5> :GundoToggle<CR>
Change the mapped key to suit your taste. We'll stick with <F5> because that's what the author uses.

Now you can press <F5> to toggle the undo graph and preview pane, which will look something like this:

  Undo graph                          File
+-----------------------------------+---------------------------+
| " Gundo for something.txt [1]     |one                        |
| " j/k  - move between undo states |two                        |
| " <cr> - revert to that state     |three                      |
|                                   |five                       |
| @  [5] 3 hours ago                |                           |
| |                                 |                           |
| | o  [4] 4 hours ago              |                           |
| | |                               |                           |
| o |  [3] 4 hours ago              |                           |
| | |                               |                           |
| o |  [2] 4 hours ago              |                           |
| |/                                |                           |
| o  [1] 4 hours ago                |                           |
| |                                 |                           |
| o  [0] Original                   |                           |
+-----------------------------------+                           |
| --- 3 2010-10-12 06:27:35 PM      |                           |
| +++ 5 2010-10-12 07:38:37 PM      |                           |
| @@ -1,3 +1,4                      |                           |
|  one                              |                           |
|  two                              |                           |
|  three                            |                           |
| +five                             |                           |
+-----------------------------------+---------------------------+
  Preview pane
Your current position in the undo tree is marked with an @ character. Other nodes are marked with an o character.

When you toggle open the graph Gundo will put your cursor on your current position in the tree. You can move up and down the graph with the j and k keys.

You can move to the top of the graph (the newest state) with gg and to the bottom of the graph (the oldest state) with G.

As you move between undo states the preview pane will show you a unified diff of the change that state made.

Pressing return on a state (or double clicking on it) will revert the contents of the file to match that state.

You can use p on a state to make the preview window show the diff between your current state and the selected state, instead of a preview of what the selected state changed.

Pressing P while on a state will initiate "play to" mode targeted at that state. This will replay all the changes between your current state and the target, with a slight pause after each change. It's mostly useless, but can be fun to watch and see where your editing lags — that might be a good place to define a new mapping to speed up your editing.

Pressing q while in the undo graph will close it. You can also just press your toggle mapping key.

Configuration

You can tweak the behavior of Gundo by setting a few variables in your :vimrc file. For example:

let g:gundo_width = 60
let g:gundo_preview_height = 40
let g:gundo_right = 1
g:gundo_width

Set the horizontal width of the Gundo graph (and preview).

Default: 45

g:gundo_preview_height

Set the vertical height of the Gundo preview.

Default: 15

g:gundo_preview_bottom

Force the preview window below current windows instead of below the graph. This gives the preview window more space to show the unified diff.

Example:

+--------+            +--------+
!g!      !            !      !g!
!g!      !     or     !      !g!
!g!______!            !______!g!
!g!pppppp!            !pppppp!g!
+--------+            +--------+
Default: 0

g:gundo_right

Set this to 1 to make the Gundo graph (and preview) open on the right side instead of the left.

Default: 0 (off, open on the left side)

g:gundo_help

Set this to 0 to disable the help text in the Gundo graph window.

Default: 1 (show the help)

g:gundo_disable

Set this to 1 to disable Gundo entirely.

Useful if you use the same ~/.vim folder on multiple machines, and some of them may not have Python support.

Default: 0 (Gundo is enabled as usual)

g:gundo_map_move_[older/newer]

These options let you change the keys that navigate the undo graph. This is useful if you use a Dvorak keyboard and have changed your movement keys.

Default:
gundo_map_move_older: "j"
gundo_map_move_newer: "k"

g:gundo_close_on_revert

Set this to 1 to automatically close the Gundo windows when reverting.

Default: 0 (windows do not automatically close)

g:gundo_[preview/tree]_statusline

Set this to 0 to disable automatically rendering preview diffs as you move through the undo tree (you can still render a specific diff with r). This can be useful on large files and undo trees to speed up Gundo.

Default: unset (windows use the default statusline)

g:gundo_auto_preview

Set this to 1 to rendering diff automatically with cursor move.

Default: 1 (auto preview diff)

g:gundo_playback_delay

This is the delay in milliseconds between each change when running 'play to' mode. Set this to a higher number for a slower playback or to a lower number for a faster playback.

Default: 60

	19.36 neocomplcach, obsolete use neocomplete instead
 git clone git://github.com/Shougo/neocomplcache.vim
git clone git://github.com/Shougo/neocomplete.vim

Follow the instructions for install.
To use: just start typing. 
To Choose, either arrows and enter, or ctrl+i , or in my mappings ctrl+n descending , ctrl+l acsending
For manual completion from buffer/file etc use ctrl-x + P/F/L etc 

For RH 6 -  sudo yum install lua-devel.x86_64 
Note, for Linux RHEL 5.5 need to Install lua manually , ex:
a. Download sources 
b. build and Install 
[root@yizaq-dev01 lua-5.3.2]# pwd
/tmp/lua-5.3.2
[root@yizaq-dev01 lua-5.3.2]# ls
doc  Makefile  README  src
 make -C src clean all SYSCFLAGS="-DLUA_USE_LINUX" SYSLIBS="-Wl,-E -ldl -lreadline -lncurses"
 make linux test
[root@yizaq-dev01 lua-5.3.2]# cp src/liblua.a  /usr/lib/
[root@yizaq-dev01 src]# cp ../../../lua-5.3.2/src/*.h /usr/include/

If you get this error:
error: #error "Compiler does not support 'long long'. Use option '-DLUA_32BITS'   or '-DLUA_C89_NUMBERS' (see file 'luaconf.h' for details)"
Manually edit
[root@yizaq-dev01 src]# pwd
/tmp/vim/vim/src
[root@yizaq-dev01 src]# vi Makefile 
...
So that:
[root@yizaq-dev01 src]# grep LUA_3 Makefile 
CFLAGS = -DLUA_32BITS

c. Build vim with lua 
[root@yizaq-dev01 src]# ./configure --with-features=huge             --enable-multibyte             --enable-pythoninterp             --enable-perlinterp             --enable-luainterp             --enable-gui=gtk2 --enable-cscope --prefix=/usr | grep lua
checking --enable-luainterp argument... yes
checking --with-lua-prefix argument... no
checking --with-luajit... no
checking for lua... no
checking if lua.h can be found in /usr/include... yes
checking if link with -L/usr/lib -llua is sane... yes


 
	19.37 Ctrl-P
If Vim made finding files as easy as it makes makes manipulating them, life would be sweet. A few plugins have been written to try to address this (FuzzyFinder and Command-T being the obvious ones). Of them, Ctrl-P currently leads the field (in BestOfVim's opinion).

Ctrl-P is a file-finder on overdrive. Once installed, you hit <Ctrl-P> and type in a few characters from your file/path. Ctrl-P quickly finds anything that matches, and sorts by best-guess. This speeds up simple stuff like typing <Ctrl-P>user to find & choose from all the files in your project with user in the name.

But it goes further. Any text you type is considered a partial match. Want to find any user files in the widget subsystem? You can type <Ctrl-P>widgetuser and it will figure out what you meant. You can even type <Ctrl-P>widusr for the same result.

This becomes particularly handy when you don't quite remember what you're looking for. Know you're looking for an HTML file somewhere under one of the template directories? Type <Ctrl-P>tmplhtm and Ctrl-P will do the legwork for you, presenting a list of best-matches.

That's the core of Ctrl-P, but it has lots of polish to its main feature that make it really nice to work with:

It will intelligently try to guess your project's root directory, by looking for hints from your version-control system.
It makes good use of syntax highlighting to show why it's suggesting the files it's picked.
It lets you select and open multiple matches in one go, in split windows or new tabs.
It tracks most recently-used files, so you can hunt by recency as well as name.
Ctrl-P's really worth giving a test-drive. It's easy to get started with, and sits happily alongside NerdTree and BufExplorer in your arsenal of filesystem-hunting.

Full path fuzzy file, buffer, mru, tag, ... finder for Vim.
Written in pure Vimscript for MacVim, gVim and Vim 7.0+.
Full support for Vim's regexp as search patterns.
Built-in Most Recently Used (MRU) files monitoring and search.
Built-in project's root finder.
Open multiple files at once.
Create new files and directories.
Execute Ex commands on an opening file (jump to a line, to a string or do anything).
Optional cross-sessions caching and history allow for fast initialization.
Mappings and usage conform to Vim's conventions.
Screenshot: CtrlP in regex and full path mode with 3 files selected to open.
screenshot

		19.37.1 Basic Usage:
Run :CtrlP or :CtrlP [starting-directory] to invoke CtrlP in find file mode.
Run :CtrlPBuffer or :CtrlPMRU to start CtrlP in find buffer or find MRU file mode.
Run :CtrlPMixed to search in Files, Buffers and MRU files at the same time.
Check :help ctrlp-commands and :help ctrlp-extensions for other commands.

		19.37.2 Once CtrlP is open:

Press <F5> to purge the cache for the current directory to get new files, remove deleted files and apply new ignore options.
Press <c-f> and <c-b> to cycle between modes.
Press <c-d> to switch to filename search instead of full path.
Press <c-r> to switch to regexp mode.
Use <c-j>, <c-k> or the arrow keys to navigate the result list.
Use <c-t> or <c-v>, <c-x> to open the selected entry in a new tab or in a new split.
Use <c-n>, <c-p> to select the next/previous string in the prompt's history.
Use <c-y> to create a new file and its parent directories.
Use <c-z> to mark/unmark multiple files and <c-o> to open them.
Run :help ctrlp-mappings or submit ? in CtrlP for more mapping help.

Submit two or more dots .. to go up the directory tree by one or multiple levels.
End the input with a colon : followed by a command to execute it after opening the file:
Use :25 to jump to line 25.
Use :/any\:\ string to jump to the first instance of any: string.
Use :+setfiletype\ myfiletype|25 to set the filetype to myfiletype then jump to line 25.
Use :diffthis when opening files marked by <c-z> to run :diffthis on the first 4 files.

		19.37.3 Basic Options:
Change the default mapping and the default command to invoke CtrlP:
let g:ctrlp_map = '<c-p>'
let g:ctrlp_cmd = 'CtrlP'
When invoked, unless a starting directory is specified, CtrlP will set its local working directory according to this variable:
let g:ctrlp_working_path_mode = 'ra'
'c' - the directory of the current file.
'r' - the nearest ancestor that contains one of these directories or files: .git .hg .svn .bzr _darcs, and your own root markers defined with the g:ctrlp_root_markers option.
'a' - like 'c', but only applies when the current working directory outside of CtrlP isn't a direct ancestor of the directory of the current file.
0 or '' (empty string) - disable this feature.
Exclude files or directories using Vim's wildignore:
set wildignore+=*/tmp/*,*.so,*.swp,*.zip     " Linux/MacOSX
set wildignore+=*\\tmp\\*,*.swp,*.zip,*.exe  " Windows
And/Or CtrlP's own g:ctrlp_custom_ignore:
let g:ctrlp_custom_ignore = '\v[\/]\.(git|hg|svn)$'
let g:ctrlp_custom_ignore = {
	\ 'dir':  '\v[\/]\.(git|hg|svn)$',
	\ 'file': '\v\.(exe|so|dll)$',
	\ 'link': 'SOME_BAD_SYMBOLIC_LINKS',
	\ }
Specify an external tool to use for listing files instead of using Vim's globpath(). Use %s in place of the target directory:
let g:ctrlp_user_command = 'find %s -type f'        " MacOSX/Linux
let g:ctrlp_user_command = 'dir %s /-n /b /s /a-d'  " Windows
Single VCS listing command:
let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files']
let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files . -co --exclude-standard', 'find %s -type f']
let g:ctrlp_user_command = ['.hg', 'hg --cwd %s locate -I .']
Multiple VCS listing commands:
let g:ctrlp_user_command = {
	\ 'types': {
		\ 1: ['.git', 'cd %s && git ls-files'],
		\ 2: ['.hg', 'hg --cwd %s locate -I .'],
		\ },
	\ 'fallback': 'find %s -type f'
	\ }
Check :help ctrlp-options for other options.

		19.37.4 Get ctrlp.vim:
Clone the plugin into a separate directory:
$ cd ~/.vim
$ git clone https://github.com/kien/ctrlp.vim.git bundle/ctrlp.vim
Or if you prefer Mercurial:
$ hg clone https://bitbucket.org/kien/ctrlp.vim bundle/ctrlp.vim
Add to your ~/.vimrc:
set runtimepath^=~/.vim/bundle/ctrlp.vim
Run at Vim's command line:
:helptags ~/.vim/bundle/ctrlp.vim/doc
Restart Vim and check :help ctrlp.txt for usage instructions and configuration details.

		19.37.5 Issues


			19.37.5.1 Can't find my file
- Try Clearing the cache - :CtrlPClearAllCaches
- Also increased the max_file limit - let g:ctrlp_max_files=0 
- For large project, we should also set 
let g:ctrlp_max_depth=40 .
-
			19.37.5.2

		19.37.6
	19.38  EasyMotion 

		19.38.1  Introduction
EasyMotion provides a much simpler way to use some motions in vim. It takes the <number> out of <number>w or <number>f{char} by highlighting all possible choices and allowing you to press one key to jump directly to the target.

When one of the available motions is triggered, all visible text preceding or following the cursor is faded, and motion targets are highlighted.

EasyMotion is triggered by one of the provided mappings.

Important notes about the default bindings
The default leader has been changed to <Leader><Leader> to avoid conflicts with other plugins you may have installed. This can easily be changed back to pre-1.3 behavior by rebinding the leader in your vimrc:

let g:EasyMotion_leader_key = '<Leader>'
All motions are now triggered with <Leader><Leader> by default, e.g. <Leader><Leader>t, <Leader><Leader>gE.

Usage example

Type <Leader><Leader>w to trigger the word motion w. When the motion is triggered, the text is updated (no braces are actually added, the text is highlighted in red by default):

<cursor>Lorem {a}psum {b}olor {c}it {d}met.
Press c to jump to the beginning of the word "sit":

Lorem ipsum dolor <cursor>sit amet.
Similarly, if you're looking for an "o", you can use the f motion. Type <Leader><Leader>fo, and all "o" characters are highlighted:

<cursor>L{a}rem ipsum d{b}l{c}r sit amet.
Press b to jump to the second "o":

Lorem ipsum d<cursor>olor sit amet.

		19.38.2 Install
yizaq-mac:.vim yizaq$ git clone https://github.com/Lokaltog/vim-easymotion
Cloning into 'vim-easymotion'...
remote: Reusing existing pack: 602, done.
remote: Total 602 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (602/602), 116.74 KiB | 0 bytes/s, done.
Resolving deltas: 100% (160/160), done.
Checking connectivity... done

		19.38.3
	19.39  https://github.com/Valloric/YouCompleteMe, YCM

		19.39.1  Install
https://valloric.github.io/YouCompleteMe/

YIZAQ-M-D1BW:bundle yizaq$ git clone git://github.com/valloric/YouCompleteMe/
YIZAQ-M-D1BW:bundle yizaq$ cd YouCompleteMe/
	$ git submodule update --init --recursive

-> On linux: YIZAQ-M-D1BW:YouCompleteMe yizaq$ ./install.sh --clang-completer
-> On Mac: 
C02X632CJGH6:YouCompleteMe i500695$ brew install cmake
$ ./install.py --clang-completer

----->> On linux this has issue w/ validating server cert. fix:
[yizaq@pmbu-dev-vm58:Sun Aug 17:674:5:~/.vim/bundle/YouCompleteMe]$ ./install.sh --clang-completer
File /users/yizaq/.vim/bundle/YouCompleteMe/third_party/ycmd/build.sh doesn't exist; you probably forgot to run:

        git submodule update --init --recursive

[yizaq@pmbu-dev-vm58:Sun Aug 17:675:6:~/.vim/bundle/YouCompleteMe]$  git submodule update --init --recursive
Cloning into 'third_party/requests'...
fatal: unable to access 'https://github.com/kennethreitz/requests/': SSL certificate problem, verify that the CA cert is OK. Details:
error:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed
Clone of 'https://github.com/kennethreitz/requests' into submodule path 'third_party/requests' failed
[yizaq@pmbu-dev-vm58:Sun Aug 17:675:7:~/.vim/bundle/YouCompleteMe]$ git --version
git version 1.9.2
[yizaq@pmbu-dev-vm58:Sun Aug 17:676:8:~/.vim/bundle/YouCompleteMe]$ git config --global http.sslVerify false
[yizaq@pmbu-dev-vm58:Sun Aug 17:677:9:~/.vim/bundle/YouCompleteMe]$ ./install.sh --clang-completer
File /users/yizaq/.vim/bundle/YouCompleteMe/third_party/ycmd/build.sh doesn't exist; you probably forgot to run:

        git submodule update --init --recursive

[yizaq@pmbu-dev-vm58:Sun Aug 17:678:10:~/.vim/bundle/YouCompleteMe]$ git submodule update --init --recursive
Cloning into 'third_party/requests'...

----->> On linux this has issue w/ validating server cert. fix:
- 
		19.39.2 languages support
The following additional language support options are available:

    C# support: install Mono with Homebrew or by downloading the Mono Mac package and add --cs-completer when calling install.py.
    Go support: install Go and add --go-completer when calling install.py.
    JavaScript and TypeScript support: install Node.js and npm then install the TypeScript SDK with npm install -g typescript.
    Rust support: install Rust and add --rust-completer when calling install.py.
    Java support: install JDK8 (version 8 required) and add --java-completer when calling install.py.

To simply compile with everything enabled, there's a --all flag. So, to install with all language features, ensure xbuild, go, tsserver, node, npm, rustc, and cargo tools are installed and in your PATH, then simply run:

cd ~/.vim/bundle/YouCompleteMe
./install.py --all

		19.39.3

	19.40 https://github.com/Lokaltog/powerline
Powerline is a statusline plugin for vim, and provides statuslines and prompts for several other applications, including zsh, bash, tmux, IPython, Awesome and Qtile. 


YIZAQ-M-D1BW:bundle yizaq$ git clone git://github.com/powerline

	19.41  https://github.com/pthrasher/conqueterm-vim
Terminal emulator in VIM

[yizaq@YIZAQ-M-D1BW:Tue Sep 02:~/.vim/bundle:]$  git clone git://github.com/pthrasher/conqueterm-vim

:ConqueTermSplit bash

	19.42 tagbar
 git clone https://github.com/majutsushi/tagbar.git
:TagbarToggle

	19.43 airling
git clone https://github.com/vim-airline/vim-airline ~/.vim/bundle/vim-airline

	19.44 fugitive 
http://vimawesome.com/plugin/fugitive-vim

install:
mkdir -p ~/.vim/pack/tpope/start
cd ~/.vim/pack/tpope/start
git clone https://tpope.io/vim/fugitive.git
vim -u NONE -c "helptags fugitive/doc" -c q

I'm not going to lie to you; fugitive.vim may very well be the best Git wrapper of all time. Check out these features:

View any blob, tree, commit, or tag in the repository with :Gedit (and :Gsplit, :Gvsplit, :Gtabedit, ...). Edit a file in the index and write to it to stage the changes. Use :Gdiff to bring up the staged version of the file side by side with the working tree version and use Vim's diff handling capabilities to stage a subset of the file's changes.

Bring up the output of git status with :Gstatus. Press - to add/reset a file's changes, or p to add/reset --patch. And guess what :Gcommit does!

:Gblame brings up an interactive vertical split with git blame output. Press enter on a line to edit the commit where the line changed, or o to open it in a split. When you're done, use :Gedit in the historic buffer to go back to the work tree version.

:Gmove does a git mv on a file and simultaneously renames the buffer. :Gdelete does a git rm on a file and simultaneously deletes the buffer.

Use :Ggrep to search the work tree (or any arbitrary commit) with git grep, skipping over that which is not tracked in the repository. :Glog loads all previous revisions of a file into the quickfix list so you can iterate over them and watch the file evolve!

:Gread is a variant of git checkout -- filename that operates on the buffer rather than the filename. This means you can use u to undo it and you never get any warnings about the file changing outside Vim. :Gwrite writes to both the work tree and index versions of a file, making it like git add when called from a work tree file and like git checkout when called from the index or a blob in history.

Use :Gbrowse to open the current file on the web front-end of your favorite hosting provider, with optional line range (try it in visual mode!). Built-in support is provided for git instaweb, and plugins are available for popular providers such as GitHub, GitLab, and Bitbucket.

Add %{fugitive#statusline()} to 'statusline' to get an indicator with the current branch in (surprise!) your statusline.

Last but not least, there's :Git for running any arbitrary command, and Git! to open the output of a command in a temp file.

Screencasts

A complement to command line git
Working with the git index
Resolving merge conflicts with vimdiff
Browsing the git object database
Exploring the history of a git repository
Installation

If you don't have a preferred installation method, one option is to install pathogen.vim, and then copy and paste:

cd ~/.vim/bundle
git clone git://github.com/tpope/vim-fugitive.git
vim -u NONE -c "helptags vim-fugitive/doc" -c q
If your Vim version is below 7.2, I recommend also installing vim-git for syntax highlighting and other Git niceties.

FAQ

I installed the plugin and started Vim. Why don't any of the commands exist?

Fugitive cares about the current file, not the current working directory. Edit a file from the repository.

I opened a new tab. Why don't any of the commands exist?

Fugitive cares about the current file, not the current working directory. Edit a file from the repository.

Why is :Gbrowse not using the right browser?

:Gbrowse delegates to git web--browse, which is less than perfect when it comes to finding the right browser. You can tell it the correct browser to use with git config --global web.browser .... On OS X, for example, you might want to set this to open. See git web--browse --help for details.

Here's a patch that automatically opens the quickfix window after :Ggrep.

This is a great example of why I recommend asking before patching. There are valid arguments to be made both for and against automatically opening the quickfix window. Whenever I have to make an arbitrary decision like this, I ask what Vim would do. And Vim does not open a quickfix window after :grep.

Luckily, it's easy to implement the desired behavior without changing fugitive.vim. The following autocommand will cause the quickfix window to open after any grep invocation:

autocmd QuickFixCmdPost *grep* cwindow
Self-Promotion

Like fugitive.vim? Follow the repository on GitHub and vote for it on vim.org. And if you're feeling especially charitable, follow tpope on Twitter and GitHub.

License

Copyright (c) Tim Pope. Distributed under the same terms as Vim itself. See :help license.

Installation

Extract in ~/.vim (~\vimfiles on Windows). I highly recommend grabbing directly from http://github.com/tpope/vim-fugitive as this version tends to fall out of date.

	19.45  fzf, faster ctrlp
    
fuzzy finder

<URL:/Users/i500695/work/KB/linux/KB_Linux#__fzf__linux__>

from terminal find + edit file:
vim $(fzf)
or vimf (alias)

from vim:
:fzf


	19.46  ag, quick recursive grep
https://robots.thoughtbot.com/faster-grepping-in-vim

install ag
brew install ag

add to .vimrc:
"ag
" The Silver Searcher
if executable('ag')
  " Use ag over grep
  set grepprg=ag\ --nogroup\ --nocolor

  " Use ag in CtrlP for listing files. Lightning fast and respects .gitignore
  let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'

  " ag is fast enough that CtrlP doesn't need to cache
  let g:ctrlp_use_caching = 0
endif

" bind K to grep word under cursor
nnoremap K :grep! "\b<C-R><C-W>\b"<CR>:cw<CR>
[i500695@C02X632CJGH6:2018-11-18 11:31:13:~/Desktop/work/SAP/CF_LocAL/portal-cf-site-semantic-service:]523$ ag --help

Usage: ag [FILE-TYPE] [OPTIONS] PATTERN [PATH]

  Recursively search for PATTERN in PATH.
  Like grep or ack, but faster.

Example:
  ag -i foo /bar/

Output Options:
     --ackmate            Print results in AckMate-parseable format
  -A --after [LINES]      Print lines after match (Default: 2)
  -B --before [LINES]     Print lines before match (Default: 2)
     --[no]break          Print newlines between matches in different files
                          (Enabled by default)
  -c --count              Only print the number of matches in each file.
                          (This often differs from the number of matching lines)
     --[no]color          Print color codes in results (Enabled by default)
     --color-line-number  Color codes for line numbers (Default: 1;33)
     --color-match        Color codes for result match numbers (Default: 30;43)
     --color-path         Color codes for path names (Default: 1;32)
     --column             Print column numbers in results
     --[no]filename       Print file names (Enabled unless searching a single file)
  -H --[no]heading        Print file names before each file's matches
                          (Enabled by default)
  -C --context [LINES]    Print lines before and after matches (Default: 2)
     --[no]group          Same as --[no]break --[no]heading
  -g --filename-pattern PATTERN
                          Print filenames matching PATTERN
  -l --files-with-matches Only print filenames that contain matches
                          (don't print the matching lines)
  -L --files-without-matches
                          Only print filenames that don't contain matches
     --print-all-files    Print headings for all files searched, even those that
                          don't contain matches
     --[no]numbers        Print line numbers. Default is to omit line numbers
                          when searching streams
  -o --only-matching      Prints only the matching part of the lines
     --print-long-lines   Print matches on very long lines (Default: >2k characters)
     --passthrough        When searching a stream, print all lines even if they
                          don't match
     --silent             Suppress all log messages, including errors
     --stats              Print stats (files scanned, time taken, etc.)
     --stats-only         Print stats and nothing else.
                          (Same as --count when searching a single file)
     --vimgrep            Print results like vim's :vimgrep /pattern/g would
                          (it reports every match on the line)
  -0 --null --print0      Separate filenames with null (for 'xargs -0')

Search Options:
  -a --all-types          Search all files (doesn't include hidden files
                          or patterns from ignore files)
  -D --debug              Ridiculous debugging (probably not useful)
     --depth NUM          Search up to NUM directories deep (Default: 25)
  -f --follow             Follow symlinks
  -F --fixed-strings      Alias for --literal for compatibility with grep
  -G --file-search-regex  PATTERN Limit search to filenames matching PATTERN
     --hidden             Search hidden files (obeys .*ignore files)
  -i --ignore-case        Match case insensitively
     --ignore PATTERN     Ignore files/directories matching PATTERN
                          (literal file/directory names also allowed)
     --ignore-dir NAME    Alias for --ignore for compatibility with ack.
  -m --max-count NUM      Skip the rest of a file after NUM matches (Default: 10,000)
     --one-device         Don't follow links to other devices.
  -p --path-to-ignore STRING
                          Use .ignore file at STRING
  -Q --literal            Don't parse PATTERN as a regular expression
  -s --case-sensitive     Match case sensitively
  -S --smart-case         Match case insensitively unless PATTERN contains
                          uppercase characters (Enabled by default)
     --search-binary      Search binary files for matches
  -t --all-text           Search all text files (doesn't include hidden files)
  -u --unrestricted       Search all files (ignore .ignore, .gitignore, etc.;
                          searches binary and hidden files as well)
  -U --skip-vcs-ignores   Ignore VCS ignore files
                          (.gitignore, .hgignore; still obey .ignore)
  -v --invert-match
  -w --word-regexp        Only match whole words
  -W --width NUM          Truncate match lines after NUM characters
  -z --search-zip         Search contents of compressed (e.g., gzip) files

File Types:
The search can be restricted to certain types of files. Example:
  ag --html needle
  - Searches for 'needle' in files with suffix .htm, .html, .shtml or .xhtml.

For a list of supported file types run:
  ag --list-file-types


	19.47 syntastic , on the fly syntax check for all languages
[i500695@C02X632CJGH6:2018-11-19 18:40:32:~/.vim/bundle:]505$ git clone --depth=1 https://github.com/vim-syntastic/syntastic.git

	19.48  jsonpath 
~/.vim/bundle:$ git clone https://github.com/mogelbrod/vim-jsonpath.git
:JsonPath: Echoes the path to the identifier under the cursor.
:JsonPath path.to.prop: Searches the active buffer for the given path, placing the cursor on it if found.

	19.49  Table mode
https://github.com/dhruvasagar/vim-table-mode

VIM Table Mode v4.6.7 Build Status
An awesome automatic table creator & formatter allowing one to create neat tables as you type.

Getting Started
Installation
There are several ways to do this

I recommend installing NeoBundle and then just add NeoBundle 'dhruvasagar/vim-table-mode' to your ~/.vimrc

If you are using pathogen.vim, then add a git submodule for your plugin:

$ cd ~/.vim
$ git submodule add git@github.com:dhruvasagar/vim-table-mode.git bundle/table-mode
Copy all files under autoload/, plugin/, doc/ to respective ~/.vim/autoload/, ~/.vim/plugin and ~/.vim/doc under UNIX or vimfiles/autoload/, vimfiles/plugin/ and vimfiles/doc under WINDOWS and restart VIM
Creating table on-the-fly
To start using the plugin in the on-the-fly mode use :TableModeToggle mapped to <Leader>tm by default (which means \ t m if you didn't override the by :let mapleader = ',' to have , t m).

Tip : You can use the following to quickly enable / disable table mode in insert mode by using || or __ :

function! s:isAtStartOfLine(mapping)
  let text_before_cursor = getline('.')[0 : col('.')-1]
  let mapping_pattern = '\V' . escape(a:mapping, '\')
  let comment_pattern = '\V' . escape(substitute(&l:commentstring, '%s.*$', '', ''), '\')
  return (text_before_cursor =~? '^' . ('\v(' . comment_pattern . '\v)?') . '\s*\v' . mapping_pattern . '\v$')
endfunction

inoreabbrev <expr> <bar><bar>
          \ <SID>isAtStartOfLine('\|\|') ?
          \ '<c-o>:TableModeEnable<cr><bar><space><bar><left><left>' : '<bar><bar>'
inoreabbrev <expr> __
          \ <SID>isAtStartOfLine('__') ?
          \ '<c-o>:silent! TableModeDisable<cr>' : '__'
Enter the first line, delimiting columns by the | symbol. The plugin reacts by inserting spaces between the text and the separator if you omit them:

| name | address | phone |
In the second line (without leaving Insert mode), enter | twice. The plugin will write a properly formatted horizontal line:

| name | address | phone |
|------+---------+-------|
When you enter the subsequent lines, the plugin will automatically adjust the formatting to match the text you’re entering every time you press |:

| name       | address | phone |
|------------+---------+-------|
| John Adams |
Go on until the table is ready:

| name            | address                  | phone      |
|-----------------+--------------------------+------------|
| John Adams      | 1600 Pennsylvania Avenue | 0123456789 |
|-----------------+--------------------------+------------|
| Sherlock Holmes | 221B Baker Street        | 0987654321 |
|-----------------+--------------------------+------------|
Then you can return to the first line and above it enter ||:

|-----------------+--------------------------+------------|
| name            | address                  | phone      |
|-----------------+--------------------------+------------|
| John Adams      | 1600 Pennsylvania Avenue | 0123456789 |
|-----------------+--------------------------+------------|
| Sherlock Holmes | 221B Baker Street        | 0987654321 |
|-----------------+--------------------------+------------|
Corner separators are adjustable:

For Markdown-compatible tables use

let g:table_mode_corner='|'


|-----------------|--------------------------|------------|
| name            | address                  | phone      |
|-----------------|--------------------------|------------|
| John Adams      | 1600 Pennsylvania Avenue | 0123456789 |
|-----------------|--------------------------|------------|
| Sherlock Holmes | 221B Baker Street        | 0987654321 |
|-----------------|--------------------------|------------|
To get ReST-compatible tables use

let g:table_mode_corner_corner='+'
let g:table_mode_header_fillchar='='


+-----------------+--------------------------+------------+
| name            | address                  | phone      |
+=================+==========================+============+
| John Adams      | 1600 Pennsylvania Avenue | 0123456789 |
+-----------------+--------------------------+------------+
| Sherlock Holmes | 221B Baker Street        | 0987654321 |
+-----------------+--------------------------+------------+
Markdown and ReST filetypes have automatically configured corners.

You can also define in a table header border how it's content should be aligned, whether center, right or left by using a : character defined by g:table_mode_align_char option.

If you manipulate the table when table mode is disabled or copy paste a table from clipboard from outside and it ends up being misaligned, you can realign it using :TableModeRealign or using the default mapping <Leader>tr defined by g:table_mode_relign_map option.

Formatting existing content into a table
Table Mode wouldn't justify it's name if it didn't allow formatting existing content into a table. And it does as promised. Like table creation on the fly as you type, formatting existing content into a table is equally simple. You can visually select multiple lines and call :Tableize on it, or alternatively use the mapping <Leader>tt defined by the g:table_mode_tableize_map option which would convert CSV (Comma Separated Value) data into a table and use , defined by g:table_mode_delimiter option as the delimiter.

If however you wish to use a different delimiter, you can use the command :Tableize/{pattern} in a similar fashion as you use tabular (eg. :Tableize/; uses ';' as the delimiter) or use the mapping <Leader>T defined by g:table_mode_tableize_op_map option which takes input in the cmd-line and uses the {pattern} input as the delimiter.

:Tableize also accepts a range and so you can also call it by giving lines manually like :line1,line2Tableize, but this is not very intuitive. You can use the mapping <Leader>T with a [count] to apply it to the next [count] lines in standard vim style.

Moving around
Now you can move between cells using table mode motions [|, ]|, {| & }| to move left | right | up | down cells respectively. The left | right motions wrap around the table and move to the next | previous row after the last | first cell in the current row if one exists.

Manipulating Table
Cell Text Object :

Tableize provides a text object for manipulating table cells. Following the vim philosophy the you have i| & a| for the inner and around (including the immidiate right table separator) the table cell.

Delete Row :

You can use the <Leader>tdd mapping defined by the option g:table_mode_delete_row_map to delete the current table row (provided you are within a table row), this can be preceeded with a [count] to delete multiple rows just like you would with 'dd'.

Delete Column :

You can use the <Leader>tdc mapping defined by the option g:table_mode_delete_column_map to delete the entire current column (provided you are within a table row), this can also be preceeded with a [count] to delete multiple columns.

Advanced Usage: Spreadsheet Capabilities
Table Formulas
Table Mode now has support for formulas like a spreadsheet. There are 2 ways of defining formulas :

You can add formulas using :TableAddFormula or the mapping <Leader>tfa defined by the option g:table_mode_add_formula_map from within a table cell, which will ask for input on the cmd-line with a f= prompt. The input formula will be appended to the formula line if one exists or a new one will be created with the input formula taking the current cell as the target cell. The formula line is evaluated immidiately to reflect the results.

You can directly add / manipulate formula expressions in the formula line. The formula line is a commented line right after the table, beginning with 'tmf:' (table mode formula). eg) # tmf: $3=$2*$1. You can add multiple formulas on the line separated with a ';' eg) # tmf: $3=$2*$1;$4=$3/3.14

You can evaluate the formula line using :TableEvalFormulaLine or the mapping <Leader>tfe defined by the option g:table_mode_eval_expr_map from anywhere inside the table or while on the formula line.

NOTE: You can now use the mapping <Leader>t?

Formula Expressions
Expressions are of the format $target = formula.

The target can be of 2 forms :

$n: This matches the table column number n. So the formula would be evaluated for each cell in that column and the result would be placed in it. You can use negative indice to represent column relative to the last, -1 being the last.

$n,m: This matches the table cell n,m (row, column). So in this case the formula would be evaluated and the result will be placed in this cell. You can also use negative values to refer to cells relative to the size, -1 being the last (row or column).

The formula can be a simple mathematical expression involving cells which are also defined by the same format as that of the target cell. You can use all native vim functions within the formula. Apart from that table mode also provides 2 special functions Sum and Average. Both these functions take a range as input. A range can be of two forms :

r1:r2: This represents cells in the current column from row r1 through r2. If r2 is negative it represents r2 rows above the current row (of the target cell).

r1,c1:r2,c2: This represents cells in the table from cell r1,c1 through cell r2,c2 (row, column).

Examples :

$2 = $1 * $1
$2 = pow($1, 5) NOTE: Remember to put space between the $1, and 5 here otherwise it will be treated like a table cell.
$2 = $1 / $1,3
$1,2 = $1,1 * $1,1
$5,1 = Sum(1:-1)
$5,1 = float2nr(Sum(1:-1))
$5,3 = Sum(1,2:5,2)
$5,3 = Sum(1,2:5,2)/$5,1
$5,3 = Average(1,2:5,2)/$5,1

	19.50  repeat.vim 
basically add . support to a bunch of plugins like surround.vim 
install via pathogen
cd ~/.vim/bundle/
git clone https://tpope.io/vim/repeat.git

	19.51  https://github.com/b4winckler/vim-angry 
Angry text object
This plugin adds text object support for comma-separated arguments enclosed by brackets. (Etymology: "argument" is sometimes abbreviated to "arg" which means "angry" in Swedish.)

For example, arguments in constructs like (x, y, z) or [1, 32, 4], { {x, y}, {w, h} } can be operated on using the objects aa (an argument, includes the separator) or ia (inner argument, excludes the separator). The text objects support a repeat count and can cope with nested lists, strings and comments (strings and comments require the current file type to have proper syntax highlighting support), as well as arguments on multiple lines.

There are also upper-case versions aA and iA. The lower-case objects will match a comma or bracket at the beginning of an argument, whereas the upper-case versions match a comma or bracket at the end of an argument. For example, if the cursor is on the first comma of (x, y, z), then daa will result in (x, z) whereas daA will result in (y, z). Another way to think of this is that aa includes the comma before an argument, whereas aA includes the comma after an argument.

The upper-case version includes whitespace and comments after the rightmost separator, and excludes whitespace and comments before the argument. The lower-case version includes whitespace and comments before the leftmost separator, and excludes whitespace and comments after the argument. For example:

call( x, /* left */ y /* right */, z )
With the cursor on the y, typing daa results in call( x /* right */, z ), whereas daA results in call( x, /* left */ z ).

Customizing
Some customization of the plugin is possible:

To disable all predefined mappings, add let g:angry_disable_maps = 1 to your .vimrc. This is useful if you dislike the choices of aa, ia, aA and iA. See the script on how to create custom mappings (look right next to the g:angry_disable_maps check).
The variable g:angry_separator defines the separator (default ,). It can be changed to any single character, e.g. let g:angry_separator = ':' would set the separator to colons. (It is not possible set this on a per-buffer basis.)
The types of brackets that the text object handles can currently only be overridden by modifying the script itself.
Examples
Counts are supported, so e.g. d3aa with the cursor on the first argument will turn

function(a, 33, Rstyle="calls, with commas inside strings, are OK")
into function(). Note that commas inside strings are ignored and so are comments (this feature depends on the syntax highlighting to detect strings and comments so 'filetype' must be set properly for this to work).

If the cursor is on the R in the above function call, then both daa and daA results in function(a, 33) so the comma after 33 is properly deleted.

Installation
Assuming you are using the Pathogen plugin, just clone this repository in your ~/.vim/bundle folder like so:

$ cd ~/.vim/bundle
$ git clone https://github.com/b4winckler/vim-angry.git
Alternatively, you can just put angry.vim in your ~/.vim/plugin folder (create the folder if it does not already exist).

	19.52  https://github.com/markonm/traces.vim 
vim 8 + required 
instead of pathogen install using vim pack support (new feature of VIM 8)
git clone --depth 1 https://github.com/markonm/traces.vim ~/.vim/pack/plugins/start/traces.vim

	19.53  https://github.com/othree/html5.vim 
install:
$ git clone https://github.com/othree/html5.vim.git

	19.54  pack, native plugin manager since vim 8

	    19.54.1  https://medium.com/@paulodiovani/installing-vim-8-plugins-with-the-native-pack-system-39b71c351fea
:help packages
Any directory under ~/.vim/pack is considered a package. A package can hold plugins in two different directories, start and opt. The plugins under start/ folder are loaded on startup, while the plugins under opt/ folder are loaded manually by the user with the command :packadd.

~/.vim/pack/*/start/{name}
Plugin auto loaded on startup
~/.vim/pack/*/opt/{name}
Plugin loaded manually, with :packadd {name}
When using Vim packages, you can unpack or git clone your desired packages directly into these directories. Or even use git submodules to keep them all in sync among several machines.

# make the pack folder a git repository
cd ~/.vim/pack
git init

# add as many plugins as you want in the desired
# package directories

# for example, lets add NERDtree and its git plugin
# as autoloaded in plugins/ directory
git submodule add https://github.com/scrooloose/nerdtree plugins/start/nerdtree
git submodule add https://github.com/Xuyuanp/nerdtree-git-plugin plugins/start/nerdtree-git-plugin

# lets also add the one color scheme in the colors/ directory
git submodule add https://github.com/rakr/vim-one.git colors/start/one

# and optinaly, we want the elixir syntax and compiler tools under syntax/
git submodule add https://github.com/elixir-lang/vim-elixir syntax/opt/elixir

# start vim and configure the plugins as desired :)
cd -
vim ~/.vimrc

# when need to update,
# it is just a matter of updating submodules
git submodule update --remote --merge
git commit
	    19.54.2

	19.55  https://github.com/airblade/vim-gitgutter 
install:
mkdir -p ~/.vim/pack/airblade/start
cd ~/.vim/pack/airblade/start
git clone https://github.com/airblade/vim-gitgutter.git
vim -u NONE -c "helptags vim-gitgutter/doc" -c q

Getting started
When you make a change to a file tracked by git, the diff markers should appear automatically. The delay is governed by vim's updatetime option; the default value is 4000, i.e. 4 seconds, but I suggest reducing it to around 100ms (add set updatetime=100 to your vimrc). Note updatetime also controls the delay before vim writes its swap file (see :help updatetime).

You can jump between hunks with [c and ]c. You can preview, stage, and undo hunks with <leader>hp, <leader>hs, and <leader>hu respectively.

You cannot unstage a staged hunk.

After updating the signs, the plugin fires the GitGutter User autocommand.

After staging a hunk or part of a hunk, the plugin fires the GitGutterStage User autocommand.

Activation
You can explicitly turn vim-gitgutter off and on (defaults to on):

turn off with :GitGutterDisable
turn on with :GitGutterEnable
toggle with :GitGutterToggle.
To toggle vim-gitgutter per buffer:

turn off with :GitGutterBufferDisable
turn on with :GitGutterBufferEnable
toggle with :GitGutterBufferToggle
You can turn the signs on and off (defaults to on):

turn on with :GitGutterSignsEnable
turn off with :GitGutterSignsDisable
toggle with :GitGutterSignsToggle.
And you can turn line highlighting on and off (defaults to off):

turn on with :GitGutterLineHighlightsEnable
turn off with :GitGutterLineHighlightsDisable
toggle with :GitGutterLineHighlightsToggle.
Note that if you have line highlighting on and signs off, you will have an empty sign column – more accurately, a sign column with invisible signs. This is because line highlighting requires signs and Vim/NeoVim always shows the sign column when there are signs even if the signs are invisible.

With Neovim 0.3.2 or higher, you can turn line number highlighting on and off (defaults to off):

turn on with :GitGutterLineNrHighlightsEnable
turn off with :GitGutterLineNrHighlightsDisable
toggle with :GitGutterLineNrHighlightsToggle.
The same caveat applies to line number highlighting as to line highlighting just above.

If you switch off both line highlighting and signs, you won't see the sign column.

In older Vims (pre 8.1.0614 / Neovim 0.4.0) vim-gitgutter will suppress the signs when a file has more than 500 changes, to avoid slowing down the UI. As soon as the number of changes falls below the limit vim-gitgutter will show the signs again. You can configure the threshold with:

let g:gitgutter_max_signs = 500  " default value (Vim < 8.1.0614, Neovim < 0.4.0)
let g:gitgutter_max_signs = -1   " default value (otherwise)
You can also remove the limit by setting g:gitgutter_max_signs = -1.

Hunks
You can jump between hunks:

jump to next hunk (change): ]c
jump to previous hunk (change): [c.
Both of those take a preceding count.

To set your own mappings for these, for example ]h and [h:

nmap ]h <Plug>(GitGutterNextHunk)
nmap [h <Plug>(GitGutterPrevHunk)
When you jump between hunks, a message like Hunk 4 of 11 is shown on the command line. If you want to turn the message off, you can use:

let g:gitgutter_show_msg_on_hunk_jumping = 0
You can load all your hunks into the quickfix list with :GitGutterQuickFix. Note this ignores any unsaved changes in your buffers. If the option g:gitgutter_use_location_list is set, this command will load hunks into the current window's location list instead. Use :copen (or :lopen) to open the quickfix / location list or add a custom command like this:

command! Gqf GitGutterQuickFix | copen
You can stage or undo an individual hunk when your cursor is in it:

stage the hunk with <Leader>hs or
undo it with <Leader>hu.
To stage part of an additions-only hunk by:

either visually selecting the part you want and staging with your mapping, e.g. <Leader>hs;
or using a range with the GitGutterStageHunk command, e.g. :42,45GitGutterStageHunk.
To stage part of any hunk:

preview the hunk, e.g. <Leader>hp;
move to the preview window, e.g. :wincmd P;
delete the lines you do not want to stage;
stage the remaining lines: either write (:w) the window or stage via <Leader>hs or :GitGutterStageHunk.
Note the above workflow is not possible if you have opted in to preview hunks with Vim's popup windows.

See the FAQ if you want to unstage staged changes.

The . command will work with both these if you install repeat.vim.

To set your own mappings for these, for example if you prefer g-based maps:

nmap ghs <Plug>(GitGutterStageHunk)
nmap ghu <Plug>(GitGutterUndoHunk)
And you can preview a hunk's changes with <Leader>hp. The location of the preview window is configured with g:gitgutter_preview_win_location (default 'bo'). You can of course change this mapping, e.g:

nmap ghp <Plug>(GitGutterPreviewHunk)
A hunk text object is provided which works in visual and operator-pending modes.

ic operates on all lines in the current hunk.
ac operates on all lines in the current hunk and any trailing empty lines.
To re-map these, for example to ih and ah:

omap ih <Plug>(GitGutterTextObjectInnerPending)
omap ah <Plug>(GitGutterTextObjectOuterPending)
xmap ih <Plug>(GitGutterTextObjectInnerVisual)
xmap ah <Plug>(GitGutterTextObjectOuterVisual)
If you don't want vim-gitgutter to set up any mappings at all, use this:

let g:gitgutter_map_keys = 0
Finally, you can force vim-gitgutter to update its signs across all visible buffers with :GitGutterAll.

See the customisation section below for how to change the defaults.

Vimdiff
Use the GitGutterDiffOrig command to open a vimdiff view of the current buffer, respecting g:gitgutter_diff_relative_to and :gitgutter_diff_base.

Folding
Use the GitGutterFold command to fold all unchanged lines, leaving just the hunks visible. Use zr to unfold 3 lines of context above and below a hunk.

Execute GitGutterFold a second time to restore the previous view.

Use gitgutter#fold#foldtext() to augment the default foldtext() with an indicator of whether the folded lines have been changed.

set foldtext=gitgutter#fold#foldtext()
For a closed fold with changed lines:

Default foldtext():         +-- 45 lines: abcdef
gitgutter#fold#foldtext():  +-- 45 lines (*): abcdef
You can use gitgutter#fold#is_changed() in your own foldtext expression to find out whether the folded lines have been changed.

Status line
Call the GitGutterGetHunkSummary() function from your status line to get a list of counts of added, modified, and removed lines in the current buffer. For example:

" Your vimrc
function! GitStatus()
  let [a,m,r] = GitGutterGetHunkSummary()
  return printf('+%d ~%d -%d', a, m, r)
endfunction
set statusline+=%{GitStatus()}

	19.56 https://dev.to/hackingcpp/fantastic-and-lesser-known-vim-plugins-in-2022-12e6 

	    19.56.1 https://github.com/bounceme/poppy.vim
Highlights different levels of matching delimiters (parentheses, braces, …) in different colors.

	    19.56.2 Cursorword
Underlines all occurrences of the word under the cursor. Super fast and useful for spotting variable occurrences or spelling errors in code and redundancy in prose.
https://github.com/itchyny/vim-cursorword


	    19.56.3 multiple cursors 
https://github.com/mg979/vim-visual-multi#readme
crazy useful

Basic usage:

select words with Ctrl-N (like Ctrl-d in Sublime Text/VS Code)
create cursors vertically with Ctrl-Down/Ctrl-Up
select one character at a time with Shift-Arrows
press n/N to get next/previous occurrence
press [/] to select next/previous cursor
press q to skip current and get next occurrence
press Q to remove current cursor/selection
start insert mode with i,a,I,A

Two main modes:

in cursor mode commands work as they would in normal mode
in extend mode commands work as they would in visual mode
press Tab to switch between «cursor» and «extend» mode

tutorial: vim -Nu path/to/visual-multi/tutorialrc
[i500695@WYLQRXL9LQ:2022-12-12 18:07:00:~/.vim/pack/plugins/start:]2024$ vim -Nu vim-visual-multi/tutorialrc 


Select words ~
------------------------------------------------------------------------------------

Quit VM, undo changes, move below and set a new mark, then |z<cr>|.

    let g:VM_moLET_mappings = 1
    Let g:VM_theme = 'iceblue'
    lEt g:VM_highlight_matches = 'underline'

    Let g:VM_maps = {}
    let g:VM_maps["Undo"]      = 'u'
    let g:VM_maps["Redo"]      = '<C-r>'

Now press <C-n>: this is the default mapping to select words under the cursor. If
your search settings are set to 'smartcase', you'll see that all following 'let'
words are underlined, and will be selected if you keep pressing <C-n>.

Quit VM and move to the second line.

Press <C-n>: if smartcase is active, only one other match will be underlined.
Press `\\c`: this allows you to cycle the case setting of the current pattern. Press
it until it becomes case insensitive.
Press `q`: the current match will be skipped. Alternate <C-n> and `q`.

Some commands ~
------------------------------------------------------------------------------------

Set a new mark here below and let's try some other commands.

    let g:VM_mouse_mappings = 1               " some text
    let g:VM_theme = 'iceblue'                " some text
    let g:VM_highlight_matches = 'underline'  " some text

    let g:VM_maps = {}                        " some text
    let g:VM_maps["Undo"]       = 'u'         " some text
    let g:VM_maps["Redo"]       = '<C-r>'     " some text


Alignment ~

Press `v2ap`, then `\\c`: from visual mode you created a column of cursors.
Press `f=`: all cursors will move to the `=` character.
Press `\\a`: all cursors will be aligned.

	    19.56.4 neodebug 
https://github.com/cpiger/NeoDebug
Debug with gdb/pdb/lldb in VIM. Shows current instruction and breakpoints in code; windows for debugger console, locals, registers, stacks, threads, breakpoints, disassembly, watch expressions. Similar to, but more user friendly and feature-rich than VIM's termdebug package. I found that it just works without any setup hassle.

	    19.56.5 Cycle
https://github.com/zef/vim-cycle
Augments VIM’s built-in increment/decrement feature (<C-a>/<C-x>) so that you can also toggle between pairs of words or cycle through lists of related words like true/false, yes/no, weekdays, months, etc. You can also add your own word lists.

	    19.56.6 CamelCaseMotion
https://github.com/bkad/CamelCaseMotion
Motions based on sub-words in CamelCase, snake_case, dash-case, etc.

	    19.56.7 undotree
awesome plugin for undotree
Start it:
:UndotreeToggle

git https://github.com/mbbill/undotree
install ~/.vim/pack/plugins/start:]2028$ git clone https://github.com/mbbill/undotree.git 

	19.57  ALE
ALE Superb integration of linters, compilers as linters, fixers/formatting tools and LSP language servers (as linters and for completion and code navigation). Requires VIM 8 or NeoVim.
works well with cquery, clangd, gcc
https://github.com/w0rp/ale

Pathogen install:
 git clone https://github.com/dense-analysis/ale ~/.vim/bundle/ale


	19.58  braceless
commands, text objects and visual aides for coding in whitespace-aware languages like Python
https://github.com/tweekmonster/braceless.vim

Pathogen install:
git clone https://github.com/tweekmonster/braceless.vim.git  ~/.vim/bundle/braceless

usage:
    - text objects: ip, ap (inner/outer indent block)
    - [[ ]] - move in blocks
    - [m , ]m - move to def and class code blocks ([M, ]M - move to end) 

supports Folding

	19.59 Codeium - AI assistant 
https://github.com/Exafunction/codeium.vim?tab=readme-ov-file#-installation-options

I basically cloned to pack and bundle directories
git clone https://github.com/Exafunction/codeium.vim ~/.vim/pack/Exafunction/start/codeium.vim
Then ran:
:Codeium Auth 

usage tutorial:
https://codeium.com/vim_tutorial

Enable/Disable
:codeiumToggle 
:codeiumEnable 


	19.60
20. Movement
	fm forward to character m
	Fm backward to character m
	tm forward to character before m
	Tm backward to character after m
	w move to next word (stops at puncuation)
	W move to next word (skips punctuation)
	b move to previous word (stops at punctuation)
	B move to previous word (skips punctuation)
	e end of word (puncuation not part of word)
	E end of word (punctuation part of word)
	), ( next, previous sentence
	]], [[ next, previous section
	}, { next, previous paragraph
	% goto matching parenthesis () {} []
	`` jump to last edit

21. recording commands.
	21.1 simple usage
	:nnoremap <space> @q

	Start recording keystrokes by hitting 'qq'.
	End recording with 'q'  (<esc> q if you're in insert mode).
	Play keystrokes by hitting space.
	---
	Refs:
	    :help register
	        :help record 
	
	21.2 another suggestion

	  :noremap Q @q

	  This allows playback of the recording that was put into the q register.
	  Example of recording and playback usage:

	  a. Begin recording keystrokes by typing "qq".
	  b. Perform your customized keystrokes.
	  c. To end recording, type

	             "q" in normal/visual mode
		       Ctrl-o + "q" in insert mode

          d. To playback recording, hit the Caps Lock key and use "Q" in normal/visual mode.
		          The Caps Lock key acts as a flip switch between recording and playback.

			  Playback can even accept a count. For instance, "5Q" repeats the recorded keystrokes 5 times.

			  If you'd still like to access Ex-mode like it was with the default "Q", use "gQ" instead. It has more features than the original Ex-mode.

			  Also see:  vimtip#144
	:help complex-repeat
	:help registers
	:help Q
	:help gQ 

	21.3 yet another suggestion


	To start recording, press "q" in normal mode followed by any of "0-9a-z".  This will start recording the keystrokes to the register you choose.  You can also see the word "recording" in the status(?) line.  You can start the key sequences that you want to record.  You can go to insert mode and type if you want.

	To stop recording, press "q" in the normal mode.

	To playback your keystrokes, press "@" followed by the character you choose.  Pressing "@@" will repeat the same again. 

	21.4 Modify recoreded macro
	Say you wish to modify named macro 'a'
	do:
	"ap
	The macro will be written to the file, modify it as you wish and then do
	"ad[movement/visualize] to copy the recoreded macro to named register a overwriting the previous record.
	for example "ad$
	then to use the modified recored do
	@a

"
22. Sessions.
	22.1 Save and Load sessions.
		:mksession vimbook.vim

		Later if you want to restore this session, you can use this command:

			:source vimbook.vim

		If you want to start Vim and restore a specific session, you can use the


		following command:

			vim -S vimbook.vim

	22.2  SESSIONS AND VIMINFO

			Sessions store many things, but not the position of marks, contents of


			registers and the command line history.  You need to use the 
			viminfo feature

			for these things.
			   In most situations you will want to use sessions separately from 
			viminfo.
			This can be used to switch to another session, but keep the command line


			history.  And yank text into 

			registers in one session, and paste it back in
			another session.
			   You might prefer to keep the info with the session.  You will have to 

			do
			this yourself then.  Example:

				:mksession! ~/.vim/secret.vim
				:wviminfo! ~/.vim/secret.viminfo

			And to restore this again:


				:source ~/.vim/secret.vim
				:rviminfo! ~/.vim/secret.viminfo


	22.3 mkview
	Saves less information about the session than mksession but usefull for folds, files etc.
	see :h mkview for more information

	:lo[adview] [nr]	Load the view for the current file.  When [nr] is
			omitted, the view stored with ":mkview" is loaded.
			When [nr] is specified, the view stored with ":mkview
			[nr]" is loaded.

	22.4

23. Working with tags.
	:h tags

	23.1 set up tags. use ctags.
		see section 19.1.1.
	
	23.2 jump to tags.
		either of
		ctrl-]
		^W} preview tag
		^W] split window and jump to tag
		:tselect [tag] (takes regexp args)
		:ptselect [tag] (takes regexp args), like the above but open a preview window and allows to 
		 move between previewed tags using commands:
			:tnext, move to next tag in list
			:tprev, move to previous tag in list

		:tag [tag] (takes regexp args)
		{Visual}CTRL-]

	23.3 Tag Stack. 
		23.3.1 jump to previous tag ctrl-T
		23.3.2 :[count]po[p][!] Jump to [count] older entry in tag stack (default 1).
			:[count]ta[g][!]        Jump to [count] newer entry in tag stack (default 1).
		:tags show active tags

	23.4 Tag generating tools.
ctags			As found on most Unix systems.  Only supports C.  Only
			does the basic work.
							*Exuberant_ctags*
exuberant ctags		This a very good one.  It works for C, C++, Java,
			Fortran, Eiffel and others.  It can generate tags for
			many items.  See http://ctags.sourceforge.net.
etags			Connected to Emacs.  Supports many languages.
JTags			For Java, in Java.  It can be found at
			http://www.fleiner.com/jtags/.
ptags.py		For Python, in Python.  Found in your Python source
			directory at Tools/scripts/ptags.py.
ptags			For Perl, in Perl.  It can be found at
			http://www.eleves.ens.fr:8080/home/nthiery/Tags/.
gnatxref		For Ada.  See http://www.gnuada.org/.  gnatxref is
			part of the gnat package.


	23.5 Browsing programs with tags
From, http://vim.wikia.com/wiki/VimTip94
Created: August 3, 2001 Complexity: basic Author: Yegappan Lakshmanan

This Q&A gives an introduction to the various facilities available in Vim for using a tags file to browse through program source files. You can read the Vim online help, which explains in detail the tags support, using the ':help tagsearch.txt' command. You can also use the help keywords mentioned in this document to read more about a particular command or option. To read more about a particular command or option use, :help <helpkeyword> in Vim.

		23.5.1 How do I create a tags file?

You can create a tags file either using the ctags utility or using a custom script or utility.

Help keyword(s): tag

Where can I download the tools to generate the tags file?

There are several utilities available to generate the tags file. Depending on the programming language, you can use any one of them.

    * Exuberant ctags generates tags for the following programming language files: 

    Assembler, AWK, ASP, BETA, Bourne/Korn/Zsh Shell, C, C++, COBOL, Eiffel, Fortran, Java, Lisp, Make, Pascal, Perl, PHP, Python, REXX, Ruby, S-Lang, Scheme, Tcl, and Vim. 
    You can download exuberant ctags from

        http://ctags.sourceforge.net/ 

    * On Unix, you can use the /usr/bin/ctags utility. This utility is present in most of the Unix installations.
    * You can use jtags for generating tags file for java programs. You can download jtags from: http://www.fleiner.com/jtags/
    * You can use ptags for generating tags file for perl programs. You can download ptags from: http://www.eleves.ens.fr:8080/home/nthiery/Tags/
    * You can download scripts from the following links for generating tags file for verilog files:
          o http://www.probo.com/vtags.htm
          o http://www.cs.albany.edu/~mosh/Perl/veri-tags 
    * You can download Hdrtag from the following link: http://mysite.verizon.net/astronaut/vim/index.html. This utility generates tags file for the following programming languages: assembly, c/c++, header files, lex, yacc,LaTeX, vim, and Maple V.
    * pltags.pl - Create tags file for perl code
    * tcltags - Create tags file for TCL code
    * shtags.pl - Create tags file for shell script 

Help keyword(s): ctags

How do I generate a tags file using ctags?

You can generate a tags file for all the C files in the current directory using the following command:

$ ctags *.c

You can generate tags file for all the files in the current directory and all the sub-directories using (this applies only to exuberant ctags):

$ ctags -R .

You can generate tags file for all the files listed in a text file named flist using (this applies only to exuberant ctags)

$ ctags -L flist

For example, this is the command I use to generate CPP tag file:
alias gen_tags='echo generating cpp tags;ctags -R --c++-kinds=+p --fields=+iaS --extra=+q  --languages=c++  -f tags . ; sort -u -o tags tags'
For example, this is the command I use to generate Java tag file:
alias gen_java_tags='echo generating java tags;ctags -R --fields=+iaS --extra=+q  --languages=java  -f tags . ; sort -u -o tags tags'

Another example, generate tags for project using multiple programming languages
alias gen_tags='echo generating all languages tags;ctags -R --c++-kinds=+p --fields=+iaS --extra=+q  -f tags . ; sort -u -o tags tags'

last bit stores the tags in a central location, the symbolic link is created to that the relative paths to source files in tags db would work
alias update_tags_to_vim='echo updating tags to VIM path, make sure to manually create tags or run alias gen_tags before!;cp tags ~/.vim/tags/acs_5_2/;ln -s ~/.vim/tags/acs_5_2/tags tags'


		23.5.2 How do I configure Vim to locate a tags file?

You can set the 'tags' option in Vim to specify a particular tags file.

set tags=/my/dir/tags

Help keyword(s): 'tags', tags-option

How do I configure Vim to use multiple tags files?

The 'tags' option can specify more than one tags file. The tag filenames are separated using either comma or spaces.

set tags=/my/dir1/tags, /my/dir2/tags

How do I configure Vim to locate a tags file in a directory tree?

You can set the 'tags' option to make Vim search for the tags file in a directory tree. For example, if the 'tags' option is set like this:

set tags=tags;/

Vim will search for the file named 'tags', starting with the current directory and then going to the parent directory and then recursively to the directory one level above, till it either locates the 'tags' file or reaches the root '/' directory. Note that the above will work only in Vim 6.0 and above.

Help keyword(s): file-searching

		23.5.3 How do I jump to a tag?

There are several ways to jump to a tag location.

|   1. You can use the 'tag' ex command. For example, the command ':tag <tagname>' will jump to the tag named <tagname>.
|   2. You can position the cursor over a tag name and then press Ctrl-].
|   3. You can visually select a text and then press Ctrl-] to jump to the tag matching the selected text.
|   4. You can click on the tag name using the left mouse button, while pressing the <Ctrl> key.
|   5. You can press the g key and then click on the tag name using the left mouse button.
|   6. You can use the 'stag' ex command, to open the tag in a new window. For example, the command ':stag func1' will open the func1 definition in a new window.
|   7. You can position the cursor over a tag name and then press Ctrl-W ]. This will open the tag location in a new window. 

Help keyword(s): :tag, Ctrl-], v_CTRL_], <C-LeftMouse>, g<LeftMouse>, :stag, Ctrl-W_]

		23.5.4 How do I come back from a tag jump?

There are several ways to come back to the old location from a tag jump.

|   1. You can use the 'pop' ex command.
|   2. You can press Ctrl-t.
|   3. You can click the right mouse button, while pressing the <Ctrl> key.
|   4. You can press the g key and then click the right mouse button. 

Help keyword(s): :pop, Ctrl-T, <C-RightMouse>, g<RightMouse>

		23.5.5 How do I jump again to a previously jumped tag location?

You can use the 'tag' ex command to jump to a previously jumped tag location, which is stored in the tag stack. Help keyword(s): tag

How do I list the contents of the tag stack?

Vim remembers the location from which you jumped to a tag in the tag stack. You can list the current tag stack using the 'tags' ex command. Help keyword(s): :tags, tagstack

How do I jump to a particular tag match, if there are multiple matching tags?

In some situations, there can be more than one match for a tag. For example, a C function or definition may be present in more than one file in a source tree. There are several ways to jump to a specific tag from a list of matching tags.

|   1. You can use the 'tselect' ex command to list all the tag matches. For example, the command ':tselect func1' will list all the locations where func1 is defined. You can then enter the number of a tag match to jump to that location.
|   2. You can position the cursor over the tag name and press g] to get a list of matching tags.
|   3. You can visually select a text and press g] to get a list of matching tags.
|   4. You can use the 'stselect' ex command. This will open the selected tag from the tag list in a new window.
|   5. You can position the cursor over the tag name and press Ctrl-W g] to do a :stselect. 

Help keyword(s): tag-matchlist, :tselect, g], v_g], :stselect, Ctrl-W_g]

I want to jump to a tag, if there is only one matching tag, otherwise a list of matching tags should be displayed. How do I do this?

There are several ways to make Vim to jump to a tag directly, if there is only one tag match, otherwise present a list of tag matches.

|   1. You can use the 'tjump' ex command. For example, the command ':tjump func1' will jump to the definition func1, if it is defined only once. If func1 is defined multiple times, a list of matching tags will be presented.
|   2. You can position the cursor over the tag and press g Ctrl-].
|   3. You can visually select a text and press g Ctrl-] to jump or list the matching tags.
|   4. You can use the 'stjump' ex command. This will open the matching or selected tag from the tag list in a new window.
|   5. You can press Ctrl-W g Ctrl-] to do a :stjump. 

Help keyword(s): :tjump, g_Ctrl-], v_g_CTRL-], :stjump, Ctrl-W_g_Ctrl-]

		23.5.6 How do browse through a list of multiple tag matches?

If there are multiple tag matches, you can browse through all of them using several of the Vim ex commands.

|   1. To go to the first tag in the list, use the 'tfirst' or 'trewind' ex command.
|   2. To go to the last tag in the list, use the 'tlast' ex command.
|   3. To go to the next matching tag in the list, use the 'tnext' ex command.
|   4. To go to the previous matching tag in the list, use the 'tprevious' or 'tNext' ex command. 

Help keyword(s): :tfirst, :trewind, :tlast, :tnext, :tprevious, :tNext

		  23.5.7 How do I preview a tag?

You can use the preview window to preview a tag, without leaving the original window. There are several ways to preview a tag:

|   1. You can use the 'ptag' ex command to open a tag in the preview window.
|   2. You can position the cursor on a tag name and press Ctrl-W } to open the tag in the preview window.
|   3. You can use the 'ptselect' ex command to do the equivalent of the 'tselect' ex command in the preview window.
|   4. You can use the 'ptjump' ex command to do the equivalent of the 'tjump' ex command in the preview window.
|   5. You can position the cursor on the tag and press Ctrl-W g} to do a :ptjump on the tag. 

Help keyword(s): :preview-window, :ptag, Ctrl-W_}, :ptselect, :ptjump, Ctrl-W_g}

		23.5.8 How do I browse through the tag list in a preview window?

If there are multiple tag matches, you can browse through all of them in the preview window using several of the Vim ex commands.

|   1. To go to the first tag in the list, use the 'ptfirst' or 'ptrewind' ex command.
|   2. To go to the last tag in the list, use the 'ptlast' ex command.
|   3. To go to the next matching tag in the list, use the 'ptnext' ex command.
|   4. To go to the previous matching tag in the list, use the 'ptprevious' or 'ptNext' ex command. 

Help keyword(s): :ptfirst, :ptrewind, :ptlast, :ptnext, :ptprevious, :ptNext

		  23.5.9 How do I start Vim to start editing a file at a given tag match?

While starting Vim, you can use the command line option '-t' to supply a tag name. Vim will directly jump to the supplied tag location.

Help keyword(s): -t

		  23.5.10 How do I list all the tags matching a search pattern?

There are several ways to go through a list of all tags matching a pattern.

    * You can list all the tags matching a particular regular expression pattern by prepending the tag name with the '/' search character. For example, 

:tag /<pattern>
:stag /<pattern>
:ptag /<pattern>
:tselect /<pattern>
:tjump /<pattern>
:ptselect /<pattern>
:ptjump /<pattern>

    * If you have the 'wildmenu' option set, then you can press the <Tab> key to display a list of all the matching tags in the status bar. You can use the arrow keys to move between the tags and then use the <Enter> key to select a tag.
    * If you don't have the 'wildmenu' option set, you can still use the <Tab> key to browse through the list of matching tags. 

Help keyword(s): tag-regexp, wildmenu

		 23.5.11 What options are available to control how Vim handles the tags file?

You can use the following options to control the handling of tags file by Vim:

|   1. 'tagrelative' - Controls how the file names in the tags file are treated. When on, the filenames are relative to the directory where the tags file is present.
|   2. 'taglength' - Controls the number of significant characters used for recognizing a tag.
|   3. 'tagbsearch' - Controls the method used to search the tags file for a tag. If this option is on, binary search is used to search the tags file. Otherwise, linear search is used.
|   4. 'tagstack' - Controls how the tag stack is used. 

Help keyword(s): 'tagrelative', 'taglength', 'tagbsearch', 'tagstack'

Is it possible to highlight all the tags in the current file?

Yes. Read the Vim online help on "tag-highlight".

Is it possible to create a menu with all the tags in the current file?

Yes. You can use the taglist plugin to display a list of tags defined in the current file in a menu. You can download this plugin from script#273.

		23.5.12 Is there a workaround to make the Ctrl-] key not to be treated as the telnet escape character?

The default escape characters for telnet in Unix systems is Ctrl-]. While using Vim in a telnet session, if you use Ctrl-] to jump to a tag, you will get the telnet prompt. There are two ways to avoid this problem:

|   1. Map the telnet escape character to some other character using the "-e <escape character>" telnet command line option
|   2. Disable the telnet escape character using the "-E" telnet command line option. 

Help keyword(s): telnet-CTRL-]


		 23.5.13  Ctags for unsupported languages

Exuberant Ctags may not support a language such as IDL (Interactive Data Language). In some cases, you will be able to find a script to create the tags file. For IDL, a Perl script is available (so ctags is not required).

However, you can also configure ctags. IDL procedures and functions are supported by putting the following in your .ctags file:

--langdef=IDL
--langmap=IDL:.pro
--regex-IDL=/^pro[ \t]+([a-zA-Z0-9_:]+)/\1/p,procedure/i
--regex-IDL=/^function[ \t]+([a-zA-Z0-9_:]+)/\1/f,function/i

See Use Taglist with LaTeX files for another example that adds support for LaTeX.

Heres an excellent tutorial on using cscope with Vim ; right from installing to becoming an expert. http://cscope.sourceforge.net/cscope_vim_tutorial.html

Um, for some reason - I couldn't get recursive lookup of tags to work with just the

set tags=tags;/

line - changing it to

set tags=./tags;/

works just fine - the only time I've EVER come across the need to use the ./ thing...

    According to the help files, "When a tag file name starts with "./", the '.' is replaced with the path of the current file. This makes it possible to use a tags file in the directory where the current file is (no matter what the current directory is). The idea of using "./" is that you can define which tag file is searched first: In the current directory ("tags,./tags") or in the directory of the current file ("./tags,tags")." Thus, it would seem that your tags file is in the current directory of the file being edited (of course!) rather than in Vim's current working directory, which is apparently different. This is one of those times that setting your working directory to the current file might be a good idea! 

TagMenu has been moved to http://members.rogers.com/jayglanville/tagsmenu/

In Brazilian keyboards, CTRL-] is CTRL-Ç (CTRL + c-cedilla). I don't know why, since 'Ç' is located just to the right of 'L' (it's ';' in US keyboards), but it works.

When -R option is not available (on Solaris), use find to generate the list of files and give them as input to ctags using -L option.

To navigate with Alt+Left and Alt+Right with tags in Vim help or in source code I added the following mappings to my .vimrc:

map <M-Left> <C-T>
map <M-Right> <C-]>

As for C++, try to use ctags with "--extra=+q" to qualify member function/variable with it's class type.

		23.5.14  Vim is nice to use with cscope and ctags, for this purpose

|1. add to file .vimrc follow strings

:map [I :cs find c <C-r><C-w><CR>
:set csto=1

|2. before launch vim, generate:

ctags -R
cscope -R -b

A modified version of exuberant ctags with support for LaTeX and BibTeX tags can be found at http://www.unb.ca/fredericton/science/chem/ajit/vim.htm

A utility similar to taglist, but for hdrtag, is available at http://mysite.verizon.net/astronaut/vim/index.html#HdrtagList


    23.6 generate ctags for different Languages, tags: generate ctags for different Languages
reference: https://medium.com/adorableio/modern-javascript-ctags-configuration-199885dbcc1
chatgpt
[i500695@WYLQRXL9LQ:2023-11-21 17:25:21:~/git/portal-cf-transport-service:]2048$ cat ~/.ctags 
--exclude=node_modules
--exclude=gulp
--languages=-javascript
--langdef=js
--langmap=js:.js
--langmap=js:+.jsx
--regex-js=/[ \t.]([A-Z][A-Z0-9._$]+)[ \t]*[=:][ \t]*([0-9"'\[\{]|null)/\1/n,constant/
--regex-js=/\.([A-Za-z0-9._$]+)[ \t]*=[ \t]*\{/\1/o,object/
--regex-js=/['"]*([A-Za-z0-9_$]+)['"]*[ \t]*:[ \t]*\{/\1/o,object/
--regex-js=/([A-Za-z0-9._$]+)\[["']([A-Za-z0-9_$]+)["']\][ \t]*=[ \t]*\{/\1\.\2/o,object/
--regex-js=/([A-Za-z0-9._$]+)[ \t]*=[ \t]*\(function\(\)/\1/c,class/
--regex-js=/['"]*([A-Za-z0-9_$]+)['"]*:[ \t]*\(function\(\)/\1/c,class/
--regex-js=/class[ \t]+([A-Za-z0-9._$]+)[ \t]*/\1/c,class/
--regex-js=/([A-Za-z$][A-Za-z0-9_$()]+)[ \t]*=[ \t]*[Rr]eact.createClass[ \t]*\(/\1/c,class/
--regex-js=/([A-Z][A-Za-z0-9_$]+)[ \t]*=[ \t]*[A-Za-z0-9_$]*[ \t]*[{(]/\1/c,class/
--regex-js=/([A-Z][A-Za-z0-9_$]+)[ \t]*:[ \t]*[A-Za-z0-9_$]*[ \t]*[{(]/\1/c,class/
--regex-js=/([A-Za-z$][A-Za-z0-9_$]+)[ \t]*=[ \t]*function[ \t]*\(/\1/f,function/
--regex-js=/(function)*[ \t]*([A-Za-z$_][A-Za-z0-9_$]+)[ \t]*\([^)]*\)[ \t]*\{/\2/f,function/
--regex-js=/['"]*([A-Za-z$][A-Za-z0-9_$]+)['"]*:[ \t]*function[ \t]*\(/\1/m,method/
--regex-js=/([A-Za-z0-9_$]+)\[["']([A-Za-z0-9_$]+)["']\][ \t]*=[ \t]*function[ \t]*\(/\2/m,method/
--langdef=typescript
--langmap=typescript:.ts
--regex-typescript=/^[ \t]*(export)?[ \t]*class[ \t]+([a-zA-Z0-9_]+)/\2/c,classes/
--regex-typescript=/^[ \t]*(export)?[ \t]*module[ \t]+([a-zA-Z0-9_]+)/\2/n,modules/
--regex-typescript=/^[ \t]*(export)?[ \t]*function[ \t]+([a-zA-Z0-9_]+)/\2/f,functions/
--regex-typescript=/^[ \t]*export[ \t]+var[ \t]+([a-zA-Z0-9_]+)/\1/v,variables/
--regex-typescript=/^[ \t]*var[ \t]+([a-zA-Z0-9_]+)[ \t]*=[ \t]*function[ \t]*\(\)/\1/v,varlambdas/
--regex-typescript=/^[ \t]*(export)?[ \t]*(public|private)[ \t]+(static)?[ \t]*([a-zA-Z0-9_]+)/\4/m,members/
--regex-typescript=/^[ \t]*(export)?[ \t]*interface[ \t]+([a-zA-Z0-9_]+)/\2/i,interfaces/
--regex-typescript=/^[ \t]*(export)?[ \t]*enum[ \t]+([a-zA-Z0-9_]+)/\2/e,enums/
--regex-typescript=/^[ \t]*import[ \t]+([a-zA-Z0-9_]+)/\1/I,imports/

#alias gen_tags='echo generating cpp tags;ctags -R --c++-kinds=+p --fields=+iaS --extra=+q  --languages=c++  -f tags . ; sort -u -o LC_ALL='C' tags tags'
# note, to resolve error sort: string comparison failed: Invalid or incomplete multibyte or wide character must perform:
# export  LC_ALL='C'
alias gen_tags='echo generating all languages tags;if [ -f tags ] ; then rm tags; fi ; LC_ALL='C'; ctags -R --c++-kinds=+p --fields=+iaS --extra=+q  -f tags . ; sort -u -o tags tags'
alias gen_tags_java='echo generating java tags;ctags -R --fields=+iaS --extra=+q  --languages=java  -f tags . ; sort -u -o tags tags'
alias gen_tags_python='echo generating python tags; ctags -R --exclude=__pycache__ --fields=+l --languages=python -f tags .; sort -u -o tags tags'
alias gen_tags_javascript="echo generating javascript tags;ctags -R src test && sed -i '' -E '/^(if|switch|function|module\.exports|it|describe).+language:js$/d' tags; sort -u -o tags tags"


    23.7
24. Include search
	24.1 :[range]is[earch][!] [count

25. Encryption
	Note, VI uses a weak encryption
	:h encrypt

	25.1 To encrypt a file.
		:X
		enter passwd. 
	
	25.2 Cancel (disable) encryption.
		:set key=

26. Insertion
	26.1 add, subtract to number under corsur.
		n^A, n^x to add or substract n.

27. Formatting, Aligning and creating lists
	27.1 Formatting 101 

	    27.1.1 basics


		:[range]ce[nter] [width] - center
		:[range]ri[ght] [width]  - right
		:[range]le[ft] [width]   - left
		gq{motion} - format
		gw{motion} - format same as above but leave cursor at start of formatting instead of end

		for example, gqap will format a paragraph.
			   5jqap will format the current paragraph and also the next four.
			   1gqG will format the whole file.

		The formatting rule is simple, lines can't exceed textwidth size (80 by default).
		Of course, its possible to change that using
		:set textwidth=N

		So, for Turning off splitting lines in vim do: 
		set formatoptions-=tc

		See :help fo-table for more info.

		Wim's suggestion of set textwidth=0 should have the same effect, though a lot of annoying filetype plugins will undo that for you. (Ugh.)
		So check with :set textwidth? and set to 0 if needed

	    27.1.2 turn off automatic line breaking
check current setting:
verbose set formatoptions

if tc are listed run:
set formatoptions-=tc

	27.2 The formatter function
		There is a simple formatter for text files. However for other types of files, such as source code
		you can specifically specify a matching formater function.
		for example, for C files do:
		:set formatexpr=c#Formatter()

	27.3 Alignment, aligning text

		27.3.1 Basics
			:[range] center WIDTH
			range, is the range of line to align and width is the maximum number of characters for each line.

			Its possible to visualize the lines first (shift+V) and then type the command w/o range.

			:[range] left WIDTH
			left align.

			:[range] right WIDTH
			left align.

	27.4 Creating headers
		An example of headers could be placing a line below the header such as:
		Level 1
		=======
		
		Level 2
		--------
		
		-Level 3-
		
		macro for creating the first two headlines is yypVr=o
		yy - yank line
		p - paste line
		V - select line
		r - replace characters with =
		o - add new line below in insert mode

		for the 3rd level :s/\(.*\)/-\1-/

		Its possible to macro those commands as follows:
			:map h1 yypVr=o
			:map h2 yypVr-o
			:map h3 :s/\(.*\)/-\1-/


	27.5 Creating lists

		A simple function to create to arrowed bullets I use in context files:
		-> entry 1
		-> entry 2
		-> entry 3

	Add to .vimrc:
	function! ArrowList()
		let lineno = line(".")
		call setline(lineno, "    -> " . getline(lineno))
	endfunction

	To invoke it on current line use:
	call ArrowList

	Its possible to specify a range, for example to exectute on entire file:
	:1,$call ArrowList

	Or visualize a range and then do :call ArrowList()

	For numbered lists add this function to .vimrc:
function! NumberList() range "range keyword tells VIM that this function only works for a range of lines
	"Set line numbers in front of lines
	let begining=line("'<") "The beginning of a visualized range
	let ending=line("'>")   "The ending of a visualized range
	let difsize = ending -begining +1 "The number of lines in range, also the biggest number in the list
	let pre = ' '
	while (begining <= ending)
		if match(difsize, '^9*$') == 0 "Whenever a number that contains only 9 (9, 99, 999 etc) 
						" is encountered it means that there's one less character
						" in the number so append one space to next numbers 
						" This is done in order to keep the numbers right aligned.

			let pre = pre . ' '
		endif
		call setline(ending, pre . difsize . "\t" . getline(ending))
		let ending = ending-1
		let difsize = difsize-1
	endwhile
endfunction

	Call it by visualizing the line and then :call NumberList()

"
28. Motion, Movement.
	:h movement
	:h motion.txt

	28.1 Basics 
	- +	line up, down on first non-blank char, accept count, example 3- three lines up.
	B W	space separated word left, right.
	gE E	end of space separated word left, right.
	n_	down n-1 lines on first non-blank char.	 
	^ $	first, last chatacter of screen line
	k, j    up, down lines.
	fc, Fc  next, previous occurence of character c.
	tc, Tc  before next, previous occurence of character c.
	; ,	repeat last fFtT, in opposite direction.
	[[ ]]	start of section backwards, forwards.
	[(, [{, [m. [#, [*, ]), ]}. ]m, ]#, ]* start end of closures, unclosed (), {} or #if, #else, /* */ and java methods.
	[M, ]M start end of Java/C++ method
	:h [M an example of how to get help on any of these motions
	g_ last non-blank character of the line
	[count]G	go to line count, defaults to last line.
	[count]gg	go to line count, defaults to first line.
	{count}%	Go to {count} percentage in the file

	28.2 Advanced 

		28.2.1 Wrapped lines
			g0 first character of the screen line
			g^ first non-blank character of the screen line
			gm Like "g0", but half a screenwidth to the right
			g$  To the last character of the screen line
			| To screen column [count] in the current line
			ex. 5| will go to 5th column, useful for looong lines

			() [count] sentences backward/forward.
			{} [count] paragraphs backward/forward.
			[[]] [count] sections backward/forward.

	28.3 Text objects selection.
			aw "a word" accepts [count]
			iw "inner word" accepts [count]
			aW "a WORD" accepts [count]
			iW "inner WORD" accepts [count]
			as "a sentence" accepts [count]
			is "inner sentence" accepts [count]
			ap "a paragraph" accepts [count]
			ip "inner paragraph" accepts [count]
			a], a[  "a [] block" accepts [count]
			i], i[  "inner [] block" accepts [count]
			same for (), <>,{}
			a", a', a`  " a quated string"
			i", a', a`  " inner quated string"

			Example with delete:

				"dl"	delete character (alias: "x")		|dl|
				"diw"	delete inner word			*diw*
				"daw"	delete a word				*daw*
				"diW"	delete inner WORD (see |WORD|)		*diW*
				"daW"	delete a WORD (see |WORD|)		*daW*
				"dd"	delete one line				|dd|
				"dis"	delete inner sentence			*dis*
				"das"	delete a sentence			*das*
				"dib"	delete inner '(' ')' block		*dib*
				"dab"	delete a '(' ')' block			*dab*
				"dip"	delete inner paragraph			*dip*
				"dap"	delete a paragraph			*dap*
				"diB"	delete inner '{' '}' block		*diB*
				"daB"	delete a '{' '}' block			*daB*


	28.4 Using motion for selection or copying
Some examples
vaw		-		Visualize a word
vas		-		Visualize a sentence
vi{		-		Visualize the inside part of a {} clause
yta		-		yank from current possition until before the next 'a' character
yFa		-		yank from current possition until the previous 'a' character		

29. View ascii, hex and octal value of character.
	ga or :as

	more info :h ascii

30. Jumps, jump lists
	:h  jumps

	30.1 basics

					:ju print jump list.
					:changes print the changes list

										*CTRL-O*
			CTRL-O			Go to [count] Older cursor position in jump list
						(not a motion command).  {not in Vi}
						{not available without the +jumplist feature}

			<Tab>		or					*CTRL-I* *<Tab>*
			CTRL-I			Go to [count] newer cursor position in jump list
						(not a motion command).
						In a |quickfix-window| it takes you to the position of
						the error under the cursor.
						{not in Vi}
						{not available without the +jumplist feature}

										*g;* *E662*
			g;			Go to [count] older position in change list.
						If [count] is larger than the number of older change
						positions go to the oldest change.
						If there is no older change an error message is given.
						(not a motion command)
						{not in Vi}
						{not available without the +jumplist feature}

										*g,* *E663*
			g,			Go to [count] newer cursor position in change list.
						Just like |g;| but in the opposite direction.
						(not a motion command)
						{not in Vi}
						{not available without the +jumplist feature}


31. Advanced substitution.
		:h substitution

		31.2 useful examples:
		
			31.2.1 substitution
		  :s/a\|b/xxx\0xxx/g		 modifies "a b"	     to "xxxaxxx xxxbxxx"
		  :s/\([abc]\)\([efg]\)/\2\1/g	 modifies "af fa bg" to "fa fa gb"
		  :s/abcde/abc^Mde/		 modifies "abcde"    to "abc", "de" (two lines)
		  :s/$/\^M/			 modifies "abcde"    to "abcde^M"
		  :%s/\r//g			 delete DOS returns ^M
		  :s/\w\+/\u\0/g		 modifies "bla bla"  to "Bla Bla"

			31.2.2 substitution in visual
		:'<,'>s/\d\+/8.1.\0/gc		in a visually selected text, change add prefic 0f 8.1 to all numbers.
		'<,'>s/\(0x\w\+\)\s\+\(\w\+.*$\)/\2\t\1/g    put first word that starts with 0x at the end of the line.
		'<,'>s/\(^.*Pos\)\(.*$\)/Pos\2/g	     remove prefix of line up until the word that starts with Pos.

			31.2.3 complex substitution

		  :s/^\s*\(\w\+\)/def set_\1(self, in_\1):/  take a list of words and make from them a list of empty python setter methods.
		:%s/\(\t\+\)print/\1if dbg_lvl == 10:\r\1\tprint/gc  replace all print directives with a condition on debug level, while
								     keeping the correct indentation. This is for windows files, for unix replace the
								     \r with a \n (carriage return with new line)
		:s/$/\r/  add new lines, ( unix, replace \r with \n)

		 :'<,'>s/^\(\s\+\w\+\)/\1,/  add , at the end of the first word in each line (good for adding , for c++ enums)
		%s$\(EAPLog\s*(\s*DZLOG\w\+\s*,\)$& __LINE__, $gc  add parameter to function, change from 
								EAPLog ( DZLOG_ALWAYS, "message") to:
								EAPLog ( DZLOG_ALWAYS, __LINE__, "message")

			31.2.4 Increment and decrement numbers by substitution

				31.2.4.1 Increment and decrement numbers by substitution  in global scope


			%" decrement numbers by 3
			%:%s/\d\+/\=(submatch(0)-3)/
			%" increment, add 18 to all numbers in file
			%:%s/\d\+/\=(submatch(0)+18)/g
			%" increment numbers by 6 on certain lines only
			%:g/loc\|function/s/\d/\=submatch(0)+6/

			%s_\(\w\+\s\+\)\{2}(\(\w\+\));_\2_gc
			Change a list of user names and emails in that format (exclude all but the words in () ):
			Nira Amit (nleibman); Christopher Murray (chmurray); Yehoshua Hershberg (yhershbe); Oleg Pekar (olpekar); Dror Koren (dror); Noam Singer (nsinger); Ori Burstein (oburstei); Vicki Inbar (vinbar); Salomon Mshesha (smashash); Amir Naftali (amirn); Itai Stern (istern)

			to that format (strip everything but user name)
			 nleibman chmurray yhershbe olpekar dror nsinger oburstei vinbar smashash amirn istern

				31.2.4.2 Increment and decrement numbers by substitution  in selection from visual mode

On Monday, October 7, 2013 8:00:38 AM UTC-5, Yosi Izaq wrote:
> Hi,
>
> I want to selectively increment numbers in substitute.
> I'm familiar w/ submatch for increment all numbers in substitute, like in vis. mode range:
> '<,'>s/\d\+/\=submatch(0)+1/gc
>
> But what if I want to increment numbers only of lines containing a preceding pattern, say "Number".
> For instance:
> "
> 1
> Number: 2
> "
>
> Should change to:
> "
> 1
> Number: 3
> "
>
> TIA,
> Thanks!
> Yosi

This is a perfect use for the :g command, for example using your substitute:

:'<,'>g#^Number#s/\d\+/\=submatch(0)+1/gc
				31.2.4.3
			31.2.5 Replacing a pattern match with the character preceding it
substitute every "abcde:fgh" with "abcdeefgh" in a file.
%s/\(.\):/\1\1/g	
	
			31.2.6
		31.3
32. Text searches for multiple files, grep, external, internal
	32.1 :h grep
		:h cn

	32.2 internal example:
		:vim pattern *.cpp

		use :cn, :cp to go to next/prev match
		:cc[number], jump to match [number]

		:copen open the match list window. use enter to jump to error.
		:ccl close the window

33. Tips.
	33.1 Edit word docs with VIM
		antiword (http://www.winfield.demon.nl/) is written by Adri van Os
		windows version can be found at:
		(http://www.informatik.uni-frankfurt.de/~markus/antiword/)

		download and install it (and put it in your path)

		antiword takes a ms-word filename from the command line and spits it out in text/plain. it does not take input from stdin

		all you gotta do to get vim to view ms-word files is to add lines to your .vimrc similar to:

		autocmd BufReadPre *.doc set ro
		autocmd BufReadPre *.doc set hlsearch!
		autocmd BufReadPost *.doc %!antiword "%"

		now, when you're curious you can do: vim resume.doc to view a text version of your ms-word document (hitting <enter> on .doc file in your .vimprojects list works too)

		but that's not too fun on it's own.

		one thing ms-word can't do (properly), is do a diff on two versions.
		however, if you're on a windows system, in explorer, try -> selecting resume-1.1.doc and resume-1.2.doc -> right click -> "Diff with Vim"

		you could probably also do: vim -d resume-1.1.doc resume-1.2.doc
		to achieve the same effect

	33.2 Edit PDF docs with VIM
		Get the free Xpdf from (http://www.foolabs.com/xpdf/download.html).  For Win32 specifically, you can get the zip file and just extract pstopedf.exe.

		Now add the following to your .vimrc:

		autocmd BufReadPre *.pdf set ro
		autocmd BufReadPost *.pdf %!pdftotext -nopgbrk "%" -

		And that's it!  And just like for MS-Word files, this allows you to use VIM to diff two pdf files very nicely.
		To Diff to pdf files: vim -d doc.pdf doc2.pdf

	33.3 VimTip 12: Converting tabs to spaces
http://vim.sourceforge.net/tip_view.php?tip_id=


To insert space characters whenever the tab key is pressed, set the
'expandtab' option:

        set expandtab

With this option set, if you want to enter a real tab character use
Ctrl-V<Tab> key sequence.

To control the number of space characters that will be inserted when
the tab key is pressed, set the 'tabstop' option.  For example, to
insert 4 spaces for a tab, use:

        set tabstop=4

After the 'expandtab' option is set, all the new tab characters entered
will be changed to spaces.  This will not affect the existing tab
characters.  To change all the existing tab characters to match the
current tab settings, use

        :retab

To change the number of space characters inserted for indentation, use
the 'shiftwidth' option:

        set shiftwidth=4

For example, to get the following coding style,
        - No tabs in the source file
        - All tab characters are 4 space characters

use the following set of options:

        set tabstop=4
        set shiftwidth=4
        set expandtab

Add the above settings to your .vimrc file.

To get more help on these options, use
:help tabstop
:help shiftwidth
:help expandtab
	
	33.4 VimTip 29: reverse all the line with only 7 keystroke in vim
http://vim.sourceforge.net/tip_view.php?tip_id=

:g/^/m0
well, 
a. : bring you to command-line mode(also known as ex-mode) from normal-mode(also known as command mode).
b. g means you'll take an action through the whole file, generally perform a search, `v' also perform a search but it match the line not match the canonical expression.
c. / begins the regular express
d. ^ is a special character respect the start of a line.
e. the second / ends the regular express and indicate that the remains is action to do.
f. m means move, `t` and `co' for copy, `d' for delete
g. 0 is the destination line.

you can use 
:g/regexp/t$
to filter all lines and pick the match line together and copy them to the end of the buffer or
:g/regexp/y A
to put them into a register(not eax, ebx...)



	33.5 Filter out lines with pattern
		To delete the lines:
		:g/pattern/d

		To print the lines:
		:g/pattern/p

	33.6 delete all lines in file
			
		33.6.1 ggdG  
			gg- go to start of file and d - delete until G- end of file

		33.6.2 :1,$d
			same as in ed from delete from first line in file to last line

		33.6.3 Yank all lines instead of delete, :1,$y

		33.6.4 yank all lines bettween markers :'a,'by

	33.7 Essential to know
	----------------------------------------
	* # g* g#           : find word under cursor (<cword>) (forwards/backwards)
	%                   : match brackets {}[]()
	.                   : repeat last modification 
	@:                  : repeat last : command (then @@)
	matchit.vim         : % now matches tags <tr><td><script> <?php etc
	<C-N><C-P>          : word completion in insert mode
	<C-X><C-L>          : Line complete SUPER USEFUL
	/<C-R><C-W>         : Pull <cword> onto search/command line
	/<C-R><C-A>         : Pull <CWORD> onto search/command line
	:set ignorecase     : you nearly always want this
	:syntax on          : colour syntax in Perl,HTML,PHP etc
	:h regexp<C-D>      : type control-D and get a list all help topics containing
			      regexp (plus use TAB to Step thru list)
	33.7 Abbrevations
VimTip 43: Using abbreviations
http://vim.sourceforge.net/tip_view.php?tip_id=
To define abbreviations, use the ab[breviate] command.
Examples:
:ab rtfm read the fine manual  -  Whenever you type 'rtfm' followed by a <space> (or <esc> or <cr>) vim
                                  will expand this to 'read the fine manual'.
:ab                            -  list all defined abbreviations
:una[bbreviate] rtfm           -  remove 'rtfm' from the list of abbreviations
:abc[lear]                     -  remove all abbreviations
NB: To avoid expansion in insert mode, type CTRL-V after the last character of the abbreviation. 
For a detailed description of the ab[breviate] command and some more examples refer to
:help abbreviations

	33.8 Windows

		33.8.1  Tip: #886 - Add Vim to Windows Send To menu


Easily open any file(s) in Vim with any options you like by adding a shortcut to Vim to your SendTo directory, located at "C:\Documents and Settings\<YOUR USER NAME>\SendTo". This will add vim.exe (or gvim.exe) to the "Send To" context menu.

You can specify any options you like with this shortcut by editing the "target" field under the shortcut properties. For example:

    * You can add a "diff in Vim" shortuct with "C:\Program Files\Vim\vim71\gvim.exe" -d
    * You can make Vim launch the selected files in tabs 

If you do not like using the "Send To" context menu, you can automatically launch files in Vim with file associations (even unknown file types or files with no extension).

	33.9. Tip, make a tar file of buffers.
	make a tar file including path information of all files
	in the current vim buffer.  If you wish to omit paths, leave out the `:p'
		 :silent bufdo !tar -rvf archive.tar %:p

		 The same only commpress result.
		 :silent bufdo !tar -rvfz archive.tarz %:p
		 :silent bufdo !zip proj.zip %:p   : zip all current files


	33.10. Select your favourite font for gvim.
	$ gvim -font courier\ Bold\ 13 <file> 

	33.11 Generate accessor and setter methods from variable names
Courtesy of http://vim.wikia.com/wiki/
Created: January 12th 2008 Complexity: basic Author: gmonfort Version:


If everytime you start writing a class need to declare a lot of private instance variables and their corresponding accessor and setter public methods, you might find this mappings usefull.

" Public Accessors
map <F3> :s/\(\(\w\)\(\w\+\)\).*/public function get\u\2\3(){\r\treturn \$this->\1;\r}/<CR>
" Public Setters
map <S-F3> :s/\(\(\w\)\(\w\+\)\).*/public function set\u\2\3(\$\1){\r\t\$this->\1 = \$\1;\r}/<CR>

Which will transform this:

variable1
variable2
variable3

Into this (using first mapping):

public function getVariable1(){
  return $this->variable1;
}
public function getVariable2(){
  return $this->variable2;
}
public function getVariable3(){
  return $this->variable3;
}

Or this (using second mapping):

public function setVariable1($variable1){
  $this->variable1 = $variable1;
}
public function setVariable2($variable2){
  $this->variable2 = $variable2;
}
public function setVariable3($variable3){
  $this->variable3 = $variable3;
}


	33.12 Automatically create and update cscope database
From Vim Tips Wiki

Created: June 21, 2007 Complexity: basic Author: Zhaojun WU Version: 7.0

In order to create or update the cscope database in current directory, the following key mapping would help a bit:

nmap <F11> :!find . -iname '*.c' -o -iname '*.cpp' -o -iname '*.h' -o -iname '*.hpp' > cscope.files ;
  \ cs kill -1<CR>:cs add cscope.out<CR>

In the above mapping, I use "find" to collect the C/C++ source code files and (re)create the cscope database; then "kill -1" to kill all cscope database connections and finally, the newly created "cscope.out" database is added by "cs add cscope.out".

There are two limitations in this key mapping:

|   1. the current directory should be the root path of the project
|   2. I don't know how to get the current cscope data connection number, so that I use "kill -1" to kill "all" cscope database connections, since actually I always only create one connections in one Vim instance. It is not practical if you are using multiple data connections in one vim instance. 


	33.13 To switch back to normal mode automatically after inaction
Created: December 9, 2007 Complexity: basic Author: Anon Version: 7.0

Looking for a way to exit insert mode automatically when you haven't typed anything for a few seconds?

Try:

au! CursorHoldI * stopinsert

	33.14 Word frequency statistics for a file
From Vim Tips Wiki
Jump to: navigation, search

Proposed new tip

Please do not discuss this tip on this page, and do not edit the talk (discussion) page.
All discussion should take place on the proposed new tips page, where we will decide whether to keep this as a new tip, or whether to merge it into an existing tip.

Created: November 13, 2007 Complexity: basic Author: vale.smth Version: 7.0

To generate a table of the occurrence frequency for every word in a file, just enter these commands.

:%s/\_A\+/\t1\r/g
:sort i
:g/\c\(.\+\)\n\1$/norm $yiwj@"^Akdd

In the above, ^A represents CTRL-A, and should be input directly (press CTRL-V then CTRL-A). On Windows, you would probably need to press CTRL-Q then CTRL-A, and you would probably first have to issue the command :unmap <C-A>.

Note that the above changes the file, so you would want to be working on a copy of your text, or you will need to undo the changes.

An amazing tip, but someone should briefly explain how it works.

The 1st command makes every word per line, and appends "1" at the end of each line.

The 2nd command sort lines.

The 3nd command find every pair of lines that are same, adds the number of the 1st line to the 2nd line's, then deletes the 1st line. 


	33.15 Change directory to the file in the current window.
Use :lcd %:p:h to 

The present working directory can be displayed in Vim with:

:pwd

To change to the directory of the currently opened file:

:cd %:h

 References

:help filename-modifiers


 Comments

Here's a mapping to make this easier:

nmap <silent> <Leader>cd :cd %:p:h<CR>

Note the use of :p first expand the % to a full path -- it takes care of the case where you're already in the correct directory. If that happens, %:h expands to an empty string and the :cd command throws an error. %:p:h is safe as it will never send an empty directory into the :cd command.

Note that 'autochdir' can be turned on to automatically switch to the directory of the current buffer upon entering the buffer. Alternatively, try:

nmap <silent> <Leader>sp :sp <c-r>=expand('%:p:h')<CR>/

(The last / can be changed to a backslash if on Windows.) Then, hitting <Leader>sp will produce a command-line all set to allow editing of a file in the same directory as the current buffer.

Also see VimTip64 (Always set your working directory to the file you're editing)

This is very useful. Personally I have these commands defined:

command! CD cd %:p:h
command! LCD lcd %:p:h

	33.16 Paste Indent Problems
Trying to cut a paste from shell running VIM to another shell running VIM, indents are all screwed up -- easy solution!

:set paste

Then, when you are done,

:set nopaste

Turns off autoindenting and stuff like that

I made myself a nice mapping for this. Put the following in your .vimrc, and if you paste and the indentation gets fscked just press C-a.

inoremap <silent> <C-a> <ESC>u:set paste<CR>.:set nopaste<CR>gi

see :h paste

	33.17 Copy an Entire Buffer to the Clipboard
http://vim.wikia.com/wiki/%22copy_all_to_clipboard%22_howto

Vim can access two different clipboard registers: * (primary selection) and + (clipboard). On Windows, either one can be used.

There are a number of ways of copying the entire contents of a file to the clipboard. These include:

Normal Mode

gg"*yG
gg"+yG

:set go+=a
ggVG
ggVGy

:set cb+=unnamed
ggyG

Ex Mode

:%y+

:set cb+=unnamed
:%y

Visual Mode (linewise)

ggoG"+y

:set go+=a
ggoG

Visual Mode (characterwise or blockwise)

VggoG"+y

:set go+=a
VggoG


Windows Specific (with Windows key bindings in effect)

ggVG<c-ins>
<C-A><C-C>

Macintosh Specific

<Cmd-A><Cmd-C>

References

    * :help :yank
    * :help registers
    * :help "+
    * :help 'guioptions'
    * :help 'clipboard'

	33.18 Display line numbers
	http://vim.wikia.com/wiki/VimTip19
This will display line numbers along the left side of a window:

:set number

You can also define a mapping to toggle the option, for example:

:nmap <C-N><C-N> :set invnumber<CR>

By pressing Ctrl-N twice in normal mode, Vim toggles between showing and hiding line numbers.

If you have Vim version 7 or greater, you can change the width of the "gutter" column used for numbering:

:set numberwidth=3

You can use the number column for the text of wrapped lines:

:set cpoptions+=n

Finally, you can change the color used for the line numbers. For example:

:highlight LineNr term=bold cterm=NONE ctermfg=DarkGrey ctermbg=NONE gui=NONE guifg=DarkGrey guibg=NONE


	33.19 Switching case of characters
http://vim.wikia.com/wiki/VimTip49
You can change the case of text:

    Toggle case "HellO" to "hELLo" with g~ then a movement. 
    Uppercase "HellO" to "HELLO" with gU then a movement. 
    Lowercase "HellO" to "hello" with gu then a movement. 

Alternatively, you can visually select text then press ~ to toggle case, or U to convert to uppercase, or u to convert to lowercase.

|Contents
|    * 1 Examples
|    * 2 Title case
|    * 3 Twiddle case
|    * 4 References
|    * 5 Comments

 Examples

~
    Toggle case of the character under the cursor, or all visually-selected characters. 

|   3~ Toggle case of the next three characters. 

g~3w
    Toggle case of the next three words. 

g~iw
    Toggle case of the current word (inner word  cursor anywhere in word). 

g~$
    Toggle case of all characters to end of line. 

g~~
    Toggle case of the current line (same as V~). 

The above uses ~ to toggle case. In each example, you can replace ~ with u to convert to lowercase, or with U to convert to uppercase. For example:

U
    Uppercase the visually-selected text. 
    First press v or V then move to select text. 
    If you don't select text, pressing U will undo all changes to the current line. 

gUU
    Change the current line to uppercase (same as VU). 

gUiw
    Change current word to uppercase. 

u
    Lowercase the visually-selected text. 
    If you don't select text, pressing u will undo the last change. 

guu
    Change the current line to lowercase (same as Vu). 

 Title case

The :s substitute command can change case (see :help s/\u).

The following converts the current line to Title Case (all lowercase, except for initial uppercase letters):

:s/\<\(\w\)\(\w*\)\>/\u\1\L\2/g

Explanation The search pattern is \<\(\w\)\(\w*\)\> which searches for \< (beginning of word), then \w (a word character), then \w* (zero or more word characters), then \> (end of word). The \(...\) create subexpressions to be recalled with \1 and \2 in the replacement. The replacement is \u\1\L\2 which substitutes the two subexpressions transformed: The \u converts the first character of what follows to uppercase, while \L converts all of what follows to lowercase.
 Twiddle case

With the following (for example, in vimrc), you can visually select text then press ~ to convert the text to UPPER CASE, then to lower case, then to Title Case. Keep pressing ~ until you get the case you want.

function! TwiddleCase(str)
  if a:str ==# toupper(a:str)
    let result = tolower(a:str)
  elseif a:str ==# tolower(a:str)
    let result = substitute(a:str,'\(\<\w\+\>\)', '\u\1', 'g')
  else
    let result = toupper(a:str)
  endif
  return result
endfunction
vnoremap ~ ygv"=TwiddleCase(@")<CR>Pgv

 References

    * :help case
	33.20 Repeating a sequence of commands without defining a macro
http://vim.wikia.com/wiki/VimTip170
Imagine.

You have just finished a complicated modification of a file, involving numerous replace commands :%s/xxx/yyyy/g, and other ex commands.

Then you realize, you have done it a little bit wrong, and you have to begin all the operation again, just to change one replace string, or do one more operation "somewhere 10 commands ago".

Or you realize, you will have to do the same stuff tomorrow with another file.

Or you realize, you want to perform the same sequence of commands, you have typed a few days ago.

You should have made it a macro (normal command q), but you haven't.

Nothing is lost yet.

You go to the command line (by typing :) and press Ctrl+F. (Ctrl+F in other modes scrolls the screen)

You get a temporary window, listing the history of command line.

It is possible to yank appropriate lines here, make a new file called $VIMRUNTIME/macros/something.vim put those lines here, edit them and save

Then you can call the macro using

:source something.vim

You might want to set variable 'history' to a higher number then default in your vimrc file like

:set history=300

 References

    * :help 'cedit'
    * :help history
    * :help vimrc 

 Comments

You can also bring up the command line history while in Normal mode by typing:

q:

which is just a touch faster than :<Ctrl-F>. (-: (Actually, I didn't even know about Ctrl-F in : mode until I read this tip. Neat!)

Once you execute a command line or search command you can retrieve the text thus:

i<C-R>: - for pasting the recent command line command
i<C-R>/ - for pasting the recent search command

	33.21 Repeat last colon command
http://vim.wikia.com/wiki/VimTip990
The last command entered with ':' can be repeated with @: and further repeats can be done with @@

This is useful for commands like :bnext or :cNext.
 Comments

I scrol through the previous commands with cursor up/down after pressing ':'.

You still can edit the command or just press Enter.

This Tip becomes super useful with something like the following:

:%s/\<pig\>/cow/gie|:update|:next

This facilitates the modification of a series of files.

Note you need the 'e' of the gie

    * g=do as many times as occurs in line
    * i=ignore case
    * e=don't break command if no search string found

	33.22 Repeating an ex command on multiple blocks
http://vim.wikia.com/wiki/VimTip1118

You can use the g// global command to repeat an Ex command on each block of lines in a file. This technique is useful because you don't need a macro, and the command is retained in history for reuse, possibly after editing.

For example, suppose you want to sort each block of text in a file, and you have a blank line before and after each block (including one before the first block, and one after the last block).

You can sort a single block after the cursor position using the command:

:/^$/;/^$/-1sort

This applies the :sort command to a block of lines defined by a range. The first line in the range is the blank line next after the cursor, and the last line is just before (-1) the blank line after that. You must use ; (not ,). See :help :;.

The following uses the global command to sort each block in the file:

:g/^\s*$/;//-1sort

The pattern /^\s*$/ is used to find blank lines, including those consisting of only whitespace (\s). The second pattern (//) is empty, so the first pattern is repeated (search for next blank line).

For the address part you can use '}. '{ and '} find paragraph boundaries.

It would be nice to have shortcuts for these patterns:

\(\%^\|^\n\)\@<=\(.\)\@= : paragraph start
\(.\)\@<=\(\%$\|\n$\)\@= : pragraph end

In normal mode, you can use "Vip:".

	33.23  Here is how to define and use a calculator, using embedded Python. Calculate, arithmetic.

These two lines go in your vimrc:

:command! -nargs=+ Calc :py print <args>
:py from math import *

Now use it inside Vim:

:Calc 2**10+5,2**16,2**128
|1029 65536 340282366920938463463374607431768211456
:Calc sin(pi/2), log(10)
#1.0 2.302585

Convert hexa to decimal
Calc int('43ed', 16)

You have to have Vim compiled with Python support, and have Python on your machine¿. Use :version to see which features are included in your Vim.

If you don't have Python support in your Vim, but do have a python command, use this instead

command! -nargs=+ Calc :!python -c "from math import *; print <args>"

You also get complex numbers and other goodies. Google for Python and math. Here is an example from complex math:

:py from cmath import *
:Calc exp(pi*1j) , " Euler famous identify e^i.pi = -1"
(-1+1.22460635382e-016j)

:Calc reduce(lambda a,b:a+b,range(1,100+1)), "Gauss' famous identity sum(1,100)"
|5050


		
	33.24 Alternate delimiters for the replace command
From Vim Tips Wiki Tip 406 
Created: January 17, 2003 Complexity: basic Author: Raj Kiran Minimum version: 5.7 Karma: 56/20 Imported from: Tip#406

You don't need to use the slash character as the expression delimiter. Whatever character follows the :s is defined to be the delimiter character. You can use most non-alphanumeric characters (but not \, " or |). This is very handy when working with Unix filenames, as in the following example:

:s#/usr/local/#/opt/#

If you insist on using the normal slash, you have to escape each slash in the pattern with a backslash:

:s/\/usr\/local\//\/opt\//

As you can see, the escaping method is much less readable, so consider carefully your choice of delimiter character!

If I need to replace a '/' character, I use a period '.' ie

 :s.///.fff.

to replace /// with fff

The description alludes to this, but another example seemed to be in order. 

	
	33.25 Disable built-in command
From Vim Tips Wiki Tip 643 
Created: January 26, 2004 Complexity: intermediate Author: Alfvaen Minimum version: 5.7 Karma: 13/6 Imported from: Tip#643

If there's a built-in key command in Vim that you find annoying, or that you often hit by accident, then you can disable the key by mapping it to nothing. For example:

:map K <Nop>

For "<Nop>", type the five characters as they appear (less-than N o p greater-than).

Of course, you can always

:unmap K

if you start doing C programming and want to instantly "man" things under the cursor again. 

	33.26 Using an expression in substitute command

Tip 755 
Created: June 26, 2004 Complexity: intermediate Author: Raj Kiran Grandhi Minimum version: 5.7 Karma: 66/23 Imported from: Tip#755

You can use an expression as the replacement string in the substitute command (:s). When the replacement string starts with "\=" it is evaluated as an expression. This opens whole new avenue of interesting possiblities. Here are a few examples:

a. Number all the lines in a file:

:%s/^/\=line('.').'^I'/

Note that for ^I you need to press ctrl+I

b. Number a range of lines (from line 10 to line 20):

:10,20s/^/\=line('.').'^I'/

c. Number a range of lines sequentially starting from 1:

:let counter=0|10,20g//let counter=counter+1|s/^/\=counter.'^I'

d. To number all the paragraphs in range starting from 1 (assuming the paragraphs are separated by one or more blank lines):

:let counter=0|1,20g/^$\n^\s*[^\s]/let counter=counter+1|+1s/^/\=counter.'^I'

Note: The above command does not work for the first paragraph in the file if there is no blank line above it.

 References

    * :help sub-replace-special
    * :help sub-replace-expression 

Comments

You can also substitute inside substitute!

:%s/.*/\='cp '.submatch(0).' all/'.substitute(submatch(0),'/','_','g')/

.* is the submatch(0)

The substitute expression will replace any "/" by "_", for example changing line:

sub1/sub2/file1.html

to

cp sub1/sub2/file1.html sub1_sub2_file1.html

See VimTip305 for a few more.

To do incremented columns, check out VimTip150 : incremented, decremented, daynames, dates, etc. 

	33.27 Sorting lines in a file based on the number of words in each line
Here is one use of substitute with an expression (:help sub-replace-expression).

I needed to sort a file according to the number of words in each line. Using the :s command, I inserted the number of words each line contains, at the beginning of the line.

To simplify sorting (using the excellent VisSort, see http://mysite.verizon.net/astronaut/vim/), instead of inserting a number, I put the corresponding character (number plus 64, so a line with one word will start with 'A').

Here is the expression I used:

:%s/^.*/\=nr2char(strlen((substitute(substitute(submatch(0), "\\S\\+", "x", "g"), "\\s","","g")))+64) . "\t" . submatch(0)

Explanation, from the inside out:

Replace all consecutive non space by a single x (each word is now a single x):

part1 = substitute(submatch(0), "\\S\\+", "x", "g")

Remove the spaces between "x":

part2 = substitute(part1,"\\s","","g")

Count the number of "x":

part3 = strlen(part2)

Get the ASCII char representing the number of words + 64:

part4 = nr2char(part3+64)

I replace all lines (^.*) by that ASCII char, followed by a tab and the initial line itself.

I can then sort, then remove all characters between the beginning of lines and the first tab. 
to sort all file
:%!sort

To remove prefix of letter and tab:
%s_^.\t__
		
	33.28 Save each line in separate numbered files
Tip 1059 


Create this function

function! SaveLines()
  execute line(".") . "w " . line(".") . ".xml"
endf

And call it

%call SaveLines()

The generated files are:

|1.xml
|2.xml
...

each containing a single line.

No need for a function. You can just use

:g/^/exe ".w ".line(".").".txt"

to get the same sort of effect.

Explanation:

:g/^/ # for very line
exe # Execute the following string as an ex command ie :

.w # . means current line so .w means write current line
line(".") # returns current line number

The string generated (for first line is) is
:g/^/exe ".w 1.txt"


	33.29 Send output of g search to a new window
Tip 1063 

Suppose you are using g/pattern/ to display all lines containing some pattern in your file. When you are satisfied with the regex you are using for the pattern, you can press F3 to output the g/pattern/ results to a new window.

To achieve this, you need the following map (place in your vimrc):

nmap <F3> :redir @a<CR>:g//<CR>:redir END<CR>:new<CR>:put! a<CR><CR>

Explanation:

:redir @a         redirect output to register a
:g//              repeat last global command
:redir END        end redirection
:new              create new window
:put! a           paste register a into new window


Send output of last g// to a named file (and open):

:nmap <F4> :redir! >/aaa/xz<CR>:g//<CR>:redir END<CR>:new /aaa/xz<CR><CR>

To not get line numbers printed if line numbers are turned on:

" before g//, store line number state and turn off line numbers; after g//, restore the previous state
:nmap <F3> :let @b=&number<CR>:set nonumber<CR>:redir @a<CR>:g//<CR>:redir END<CR>:let &number=@b<CR>:new<CR>:put! a<CR><CR>


	33.30 Removing automatic comment leaders
http://vim.wikia.com/wiki/VimTip129
Created: October 7, 2001 Complexity: basic Author: Benji Fisher

If you include the "r" or "o" flag in the 'formatoptions' option (:help 'fo', :help fo-table) then the comment leader is inserted automatically when you start a new line in a comment. For example, in TeX the "%" character is the comment leader, and you might type

% This is a tex file.
% The comment leaders on all lines but the first were generated automatically.
% This is the last line of the comment, but Vim will insert the comment leader on the next line.
%

You can get rid of the comment leader (along with anything you may already have typed on the line) without affecting the indent, if any, by typing <C-U> while in Insert mode (in case you do this by accident, there are ways to undo it).

( Recover from accidental Ctrl-U
  You can accidentally lose text that you're typing in  text that you can't recover with undo. This tip allows you to recover your lost text, and to avoid future problems with a mapping.

In insert mode, pressing Ctrl-u deletes text you've typed in the current line, and Ctrl-w deletes the word before the cursor. You can't undo these deletions. However, what you've typed is still in the . register. You can confirm that (after pressing Esc to return to normal mode) with the command :reg which will list all registers (or just :reg . to display the . register). You may be able to copy the missing text from the register display, for example, with the mouse.

Unfortunately, simply pasting the . register won't help because it will repeat the Ctrl-u or Ctrl-w and will delete the text again. However, you can use another register (register a in the following):

:let @a = @.
"aP

The above will paste all the text you last inserted, including what was accidentally deleted.

To avoid the problem in the future, put the following in your vimrc:

inoremap <c-u> <c-g>u<c-u>
inoremap <c-w> <c-g>u<c-w>

Now Ctrl-u and Ctrl-w will work as before, but they first use Ctrl-g u to start a new change, as far as undo is concerned. For example, in insert mode, you might type several lines then accidentally press Ctrl-u which deletes the last line. If you have used the above mapping, you can press Esc to return to normal mode, then u to undo, which will recover the last line.

Generally, when you insert text (after an i or o or other similar command) you make a single modification to the file that forms one undo block. Pressing Ctrl-u or Ctrl-w while in insert mode is just part of that single modification. After pressing Esc to return to Normal mode, if you press u you will undo all your typing. Therefore, you have lost text deleted with Ctrl-u or Ctrl-w.

However, some insert-mode commands break the undo block so the insertion consists of more than a single modification. One of those commands is Ctrl-g u.

    * :help i_CTRL-U Insert mode: <c-u> deletes text entered in the current line.
    * :help i_CTRL-W Insert mode: <c-w> deletes word before cursor.
    * :help i_CTRL-G_u Insert mode: <c-g> u starts a new change.
    * :help ins-special-special Insert mode: Commands which start a new change. 


The following allows you to paste all of "., while using backspace to delete the Ctrl-u at the end (assuming you accidentally typed Ctrl-u):

:put ='<C-R><C-R>.<BS>'

The above command puts the '...' string following the expression register =. Using Ctrl-r twice inserts text from the following register literally.

    * :help c_CTRL-R_CTRL-R
    * :help "=

)'"

Related point: If you want to adjust the indent while in insert mode, you can use <C-D> (to decrease the indent) or <C-T> (to increase it)

	33.31 The super star
Created: February 24, 2001 Complexity: basic Author: Scott+Yegappan

In normal mode, move the cursor to any word. How do you search for the next occurrence of that word?

Press the * key to search forwards for the current word, or press # to search backwards.

Using * or # searches for the exact word at the cursor (searching for rain would not find rainbow).

Use g* or g# if you don't want to search for the exact word.

		33.31.1 Using the mouse

With the proper settings, you can search for an exact word using the mouse.

Shift-LeftClick a word to search forwards, or Shift-RightClick to search backwards.

This needs a GUI version of Vim (gvim), or a console Vim that accepts a mouse. You may need the following line in your vimrc to enable mouse searches:

:set mousemodel=extend

In gvim, click the Edit menu, then Global Settings, then the "tear off" bar at the top. That will show a floating Global Settings menu with useful Toggle Pattern Highlight and Toggle Ignore-case commands.

		33.31.2 More searching

After searching, press n for the next match, or N to search in the reverse direction.

Vim maintains a search history. Type / or ? and use the arrow up/down keys to recall previous search patterns. You can edit a pattern, and press Enter to search for something different.

Suppose the cursor is on a word, and you want to search for a similar word.

Press / then <C-r><C-w> to copy the current word to the command line. You can now edit the search pattern and press Enter. Use <C-r><C-w> for a <cword>, or <C-r><C-a> for a <cWORD>.

<C-r><C-w> is Control-R then Control-W (hold down Ctrl and press r then w).

After searching, use <C-o> to jump back to your previous position (then <C-i> will jump forwards).

After searching, an empty search pattern will repeat the last search. This works with /, :s and :g.

So, after searching for a word, use :%s//new/g to change all occurrences to 'new', or :g/ to list all lines containing the word. See Substitute last search.

You can enter a count before a search. For example 3/pattern will search for the third occurrence of pattern, and 3* will search for the third occurrence of the current word.

		33.31.3 Highlight matches without moving

It can be useful to highlight the word under the cursor like *, but without jumping to the next match. Then you can see the search highlights on the current screen, without any scrolling. Move to the first (ggn), last (GN), next (n) or previous (N) match as usual.

The basic command is (type Ctrl-r then Ctrl-w to insert the current word):

:let @/="<C-r><C-w>"<CR>

The following map uses F10 to highlight all occurrences of the current word, and F11 to unhighlight (put in your vimrc):

nnoremap <F10> :set hls<CR>:let @/="<C-r><C-w>"<CR>
nnoremap <F11> :nohls<CR>

Here is another version that uses F10 to toggle search highlighting (F11 is not used).

nnoremap <F10> :set invhls<CR>:let @/="<C-r><C-w>"<CR>/<BS>

The 'inv' prefix on a boolean setting toggles it. The trailing /<BS> clears the command line.

Position the cursor on an interesting word, then press F10 to highlight all occurrences of that word. Use commands like n and N to search up and down. When you're done, press F10 again to toggle highlighting off.

		33.31.4 Show the next match while entering a search

To move the cursor to the matched string, while typing the search pattern, set the following option in your vimrc:

:set incsearch

		33.31.5 While searching complete current matching word
(Add letters, chars to current search while searching) 

Complete the search by pressing Enter, or cancel the search by pressing Escape. When typing the search pattern, press Ctrl-L (:help c_CTRL-L) to insert the next character from the match or press Ctrl-R Ctrl-W (:help c_CTRL-R_CTRL-F) to complete the current matching word.


	33.32 Open file under cursor
The following commands open the file name under the cursor:

    * gf    open in the same window ("goto file")
    * <c-w>f    open in a new window
    * <c-w>gf    open in a new tab 

When writing a program, it is helpful to set the 'path' option to list the directories with your include files. Then you can easily open an include file.

If there are several files in your 'path' that match the name under the cursor, gf opens the first, while 2gf opens the second, and 3gf opens the third, etc.

You can return to the previous buffer using Ctrl-^ or Ctrl-o.
 References

    * :help gf
    * :help CTRL-W_F
    * :help CTRL-W_gf
    * :help CTRL-^
    * :help CTRL-O
    * :help 'path' directory names used to look for the file 

 Comments

You could list files in 'path' that match the name under under the cursor with:

:echo globpath(&path, expand('<cfile>'))

The plugin searchInRuntime overrides gf and CTRL-W_f to ask which file must be opened if several match. Alternatives for :sp and :vsp are also provided. 

	33.33 Paste registers in search or colon commands instead of using the clipboard
Created: June 20, 2003 Complexity: intermediate Author: rainbrot 

You can type Ctrl-R to insert a register when in insert mode, or when typing in the command or search line. When you press Ctrl-R you will see " (quote) to prompt you to finish the command by entering a register. For example, press Ctrl-R then a to insert the contents of the a register, or Ctrl-R then " to insert the contents of the unnamed register.

You can press v then move the cursor to visually select some text (say the text is "hello world"). If you press y the selected text is yanked (copied) into the unnamed register. You can now type :%s/ then <C-r>" (Ctrl-R quote), which would show the following in the command line:

:%s/hello world

You could complete the substitute command, to read, for example:

:%s/hello world/goodbye everyone/gc

Type <C-r><C-w> to paste the word under the cursor into the command line, or <C-r><C-a> to paste the WORD. 

"
	33.34 Easy edit of files in the same directory, expand, %: operator
To print out the current vim filename:

:help expand
:echo expand("%:p:h")  " absolute path
:echo expand("%:p:h")  " absolute path dirname
:echo expand("%:p:h:h")" absolute path dirname dirname
:echo expand("%.")     " relative path
:echo expand("%.:h")   " relative path dirname
:echo expand("%.:h:h") " relative path dirname dirname

:echo expand("<sfile>:p")  " absolute path to [this] vimscript

:help filename-modifiers
		33.34.1 Tip 2 Update content

While editing a file, you may want to open another file in the same directory. However, navigating to the file can be frustrating if it is not in the current directory.

Using one of the following snippets in your vimrc will help open files while deep in the directory tree. An alternative would be to set the working directory to the current file.
Contents

    * 1 Using a command line abbreviation
    * 2 Using a mapping
    * 3 References
    * 4 Comments

			33.34.1.1 Using a command line abbreviation

This method uses a command line abbreviation so %% expands to the full path of the directory that contains the current file.

cabbr <expr> %% expand('%:p:h')

For example, while editing file /some/path/myfile.txt, typing :e %%/ on the command line will expand to :e /some/path/. Then you can use completion (press Tab after typing the first few letters of a file name), or press Enter to browse the directory listing. Of course, this abbreviation works anywhere on the command line, so you can use it with :cd, :grep etc.

If your Vim does not support <expr> mappings, try using the expression register to extract the path instead:

cabbr %% <C-R>=expand('%:p:h')<CR>

Note that you have to type a non-keyword character after %% in order to expand the abbreviation. For example, after typing :e %%, you could expand the abbreviation by typing / or by pressing Enter or Ctrl-].
			33.34.1.2 Using a mapping

While editing file /some/path/myfile.txt, this method allows you to type \e (assuming the default backslash leader) to enter :e /some/path/ on the command line. Again, you can use completion to enter a file name, or press Enter to browse the directory.

nnoremap <Leader>e :e <C-R>=expand('%:p:h') . '/'<CR>

This method is less versatile than the command line abbreviation above.

			33.34.1.3 References

    * :help cmdline-special % on command line is replaced with current file name
    * :help expand()
    * :help filename-modifiers explanation of '%:p:h' 

		33.34.2 Old tip content, use %/ to expand current file path 

Created: February 24, 2001 Complexity: intermediate Author: scott Version: 5.7 
It was often frustrating when I would open a file deep in the code tree and then realize I wanted to open another file in that same directory. Douglas Potts taught me a nice way to do this. Add the following snippet to your vimrc:

" Edit another file in the same directory as the current file
" uses expression to extract path from current file's path
" (thanks Douglas Potts)
if has("unix")
  map ,e :e <C-R>=expand("%:p:h") . '/'<CR>
else
  map ,e :e <C-R>=expand("%:p:h") . '\'<CR>
endif

-> Note, I like this mapping :) map %/ to expand current path
Then when you type ,e in normal mode you can use tab to complete to the file. You can also expand this to allow for splitting, etc.

An alternative is to expand the current file directory while you're on the command line with something like:

if has("unix")
  cmap %/ <C-R>=expand("%:p:h") . '/'<CR>
else
  cmap %/ <C-R>=expand("%:p:h") . '\'<CR>
endif

This has the advantage that you can use it with any command, such as :e, :w, :cd etc. For example, typing:

:cd %/

Would become something like:

:cd /home/username/foo/


"

	33.35 Managing boolean (set) options
Tip 37 Author: slimzhao Version: 6.0

The options that configure Vim are of three types:

    * boolean : on or off (example :help 'autochdir')
    * number : an integer value (example :help 'textwidth')
    * string : a string value (example :help 'backspace') 

Options can be global, or may apply only to a particular buffer or window. :help :setlocal

		33.35.1 Boolean options

The many ways to set a boolean option are best illustrated by a simple example. In the following, the 'number' option is used. Any boolean option, such as wrap, linebreak, diff, etc can be set in these ways.
:set number 	Turn line numbers on
:set nonumber 	Turn line numbers off
:set invnumber
:set number! 	Toggle line numbers
:set number& 	Set option to default value
:set number? 	Show value of option

Replace number with any boolean option.

For nonboolean options, :set option& also sets the option to its default value, and :set option? will display the current value. 



		33.35.2 Toggling an option
If you often need to change an option, you could use a mapping and script as in the following example (which could be placed in your vimrc). In this example, the F12 key is mapped to either enable or disable the mouse.

nnoremap <F12> :call ToggleMouse()<CR>
function! ToggleMouse()
  if &mouse == 'a'
    set mouse=
    echo "Mouse usage disabled"
  else
    set mouse=a
    echo "Mouse usage enabled"
  endif
endfunction

It's easier to toggle a boolean option, for example:

nnoremap <F12> :set number!

		33.35.3 References

    * :help set-option 
    
    

	33.36 Swapping characters, words and lines
		33.36.1 Normal-Mode Commands
Swap the current character (the character under the cursor) with the next: xp

Swap the current line with the next: ddp

Swap the current word with the next (see note): 
dawwP
dawelp

Swap the current word with the previous (see note): dawbP

Note: These approaches to swap words don't work around punctuation and will do the wrong thing. For this reason, it is recommended that you use some mappings (see below) that will more intelligently move words around.

    		33.36.2 Normal-Mode Mappings
To use gc to swap the current character with the next, without changing the cursor position:

:nnoremap <silent> gc xph

To use gw to swap the current word with the next, without changing cursor position: (See note.)

:nnoremap <silent> gw "_yiw:s/\(\%#\w\+\)\(\W\+\)\(\w\+\)/\3\2\1/<CR><c-o><c-l>
" This version will work across newlines:
:nnoremap <silent> gw "_yiw:s/\(\%#\w\+\)\(\_W\+\)\(\w\+\)/\3\2\1/<CR><c-o><c-l>

To use gl to swap the current word with the previous, keeping cursor on current word: (This feels like "pushing" the word to the left.) (See note.)

:nnoremap <silent> gl "_yiw?\w\+\_W\+\%#<CR>:s/\(\%#\w\+\)\(\_W\+\)\(\w\+\)/\3\2\1/<CR><c-o><c-l>

To use gr to swap the current word with the next, keeping cursor on current word: (This feels like "pushing" the word to the right.) (See note.)

:nnoremap <silent> gr "_yiw:s/\(\%#\w\+\)\(\_W\+\)\(\w\+\)/\3\2\1/<CR><c-o>/\w\+\_W\+<CR><c-l>

To use g{ to swap the current paragraph with the next:

:nnoremap g{ {dap}p{

Note: Mappings above which perform a search-and-replace (ones containing :s/) will operate incorrectly on words with accented characters. To adjust the mappings above to work with your locale, replace all \w with [alphabet] and \W with [^alphabet], where alphabet is the set of characters in your alphabet. :help /\w 

"
    		33.36.3 Other Solutions
    		    33.36.3.1 Visual-Mode swapping
To use this mapping: first, delete some text (using any normal Vim command, such as daw, dt, in normal mode, x in visual mode). Then, use visual mode to select some other text, and press CTRL-X. The two pieces of text should then be swapped.

:vnoremap <C-X> <Esc>`.``gvP``P

    		    33.36.3.2 Scripts
Chip Campbell has written a Visual Mode Based Swapping script similar to the above, available at http://mysite.verizon.net/astronaut/vim/index.html#VISSWAP


	33.37 Improved Hex editing
Tip 1518 created October 3, 2007 · author Fritzophrenic 

Many advanced text editors allow the editing of files in a "hex mode," especially useful for editing binary files. Vim provides this capability through the external program xxd, which is included by default in standard distributions of Vim. Unfortunately, using an external program for this task is non-intuitive and error-prone. A user must remember how to run the filter (:%!xxd to convert to hex, :%!xxd -r to convert back), must remember to convert back from hex before saving, cannot convert read-only files without warnings, and more. This tip improves the use of xxd to edit hex files by adding a mapping and command to easily toggle back and forth between hex and non-hex mode, and automating tasks like converting back from the hex-filtered form before saving a file.

		33.37.1  Easily enter and leave hex mode
Placing the following code in your vimrc will provide a :Hexmode ex command to toggle xxd hex mode on or off. It will keep track of what mode you are in, so you don't have to. This ex command is easy to map like this:

nnoremap <C-H> :Hexmode<CR>
inoremap <C-H> <Esc>:Hexmode<CR>
vnoremap <C-H> :<C-U>Hexmode<CR>

Note that <C-H> is already a defined command, so override it with care (or use a different left hand side to the mapping). See :help CTRL-H, :help i_CTRL-H, :help v_CTRL-H. Also, you may need to use gvim to distinguish between <C-H> and <BS>.

Note, I use  leader (\) hx for this as follows:
nnoremap <LEADER>hx :Hexmode<CR>
inoremap <LEADER>hx <Esc>:Hexmode<CR>
vnoremap <LEADER>hx :<C-U>Hexmode<CR>


" ex command for toggling hex mode - define mapping if desired
command -bar Hexmode call ToggleHex()

" helper function to toggle hex mode
function ToggleHex()
  " hex mode should be considered a read-only operation
  " save values for modified and read-only for restoration later,
  " and clear the read-only flag for now
  let l:modified=&mod
  let l:oldreadonly=&readonly
  let &readonly=0
  let l:oldmodifiable=&modifiable
  let &modifiable=1
  if !exists("b:editHex") || !b:editHex
    " save old options
    let b:oldft=&ft
    let b:oldbin=&bin
    " set new options
    setlocal binary " make sure it overrides any textwidth, etc.
    let &ft="xxd"
    " set status
    let b:editHex=1
    " switch to hex editor
    %!xxd
  else
    " restore old options
    let &ft=b:oldft
    if !b:oldbin
      setlocal nobinary
    endif
    " set status
    let b:editHex=0
    " return to normal editing
    %!xxd -r
  endif
  " restore values for modified and read only state
  let &mod=l:modified
  let &readonly=l:oldreadonly
  let &modifiable=l:oldmodifiable
endfunction


		33.37.2 Automatically handle hex mode
It would be nice if the user did not need to remember to convert back from hex before saving changes to a binary file. Also, certain files are almost always binary; it would be nice if Vim would pick up on this and automatically enter an appropriate editing mode. The help files for Vim include the following advice for automating the xxd-style hex editing capabilities for Vim, in order to automate the conversion and automatically enter hex mode for binary files:

" vim -b : edit binary using xxd-format!
augroup Binary
  au!
  au BufReadPre  *.bin let &bin=1
  au BufReadPost *.bin if &bin | %!xxd
  au BufReadPost *.bin set ft=xxd | endif
  au BufWritePre *.bin if &bin | %!xxd -r
  au BufWritePre *.bin endif
  au BufWritePost *.bin if &bin | %!xxd
  au BufWritePost *.bin set nomod | endif
augroup END

There are a few problems with this approach:

|   1. Only files with a .bin extension are opened this way, even if editing a file in binary mode (e.g. with ++bin)
|   2. This sets the binary option for any future documents opened as well. If you use tabe, for example, or if you have Vim set up to open new files in tabs, then any new files opened will open in binary mode.
|   3. If you decide to edit a binary file without the xxd, the BufWrite autocommands will try to convert it with xxd -r anyway.
|   4. Viewing a file in "xxd mode" requires you to modify the file, so read-only files will warn you if you try to do so, even if you make no changes. Buffers with 'nomodifiable' will cause errors.
|   5. If you go back into non-xxd editing, the filetype will still be xxd. 

These problems can be fixed as follows:

|   1. Trigger on all files if they are being edited with the binary option. Modify the extension-specific autocmd to set the binary option.
|   2. Use setlocal rather than using the global binary option.
|   3. Maintain a variable for each buffer that tracks whether the file is in "xxd mode". Only restore to non-xxd before writing if this variable says we are in the appropriate mode.
|   4. Temporarily clear the read-only flag whenever you transition between xxd and non-xxd mode, resetting it afterward.
|   5. Store the filetype when entering xxd mode and restore it when leaving. 

Below is some code for your vimrc that does all of this, making use of the command we define above:

" autocmds to automatically enter hex mode and handle file writes properly
if has("autocmd")
  " vim -b : edit binary using xxd-format!
  augroup Binary
    au!
    au BufReadPre *.bin,*.hex setlocal binary
    au BufReadPost *
          \ if &binary | Hexmode | endif
    au BufWritePre *
          \ if exists("b:editHex") && b:editHex && &binary |
          \  let oldro=&ro | let &ro=0 |
          \  let oldma=&ma | let &ma=1 |
          \  exe "%!xxd -r" |
          \  let &ma=oldma | let &ro=oldro |
          \  unlet oldma | unlet oldro |
          \ endif
    au BufWritePost *
          \ if exists("b:editHex") && b:editHex && &binary |
          \  let oldro=&ro | let &ro=0 |
          \  let oldma=&ma | let &ma=1 |
          \  exe "%!xxd" |
          \  exe "set nomod" |
          \  let &ma=oldma | let &ro=oldro |
          \  unlet oldma | unlet oldro |
          \ endif
  augroup END
endif


"
This will make Vim automatically invoke hex mode using the command defined earlier whenever a file is opened in binary mode, and will automatically (locally) set binary mode for .bin and .hex files (so .bin and .hex files will automatically open in hex mode always). 


		33.37.3 Other enhancements
You may need to take steps to avoid the "Hit ENTER to continue prompt if you use this tip.

Here are commands to use to launch any file(s) in hex mode in a separate "hex editor" Vim server. Under Windows, you can easily add these commands to your "Send To" menu if you use the full path for gvim.exe in place of "vim". Remove the "-p" and "--remote-tab-silent" option if you do not want the tabbed interface. The -c "set binary" ensures that any tabwidth, wrap, etc. settings are overwritten after the file finishes loading.

    * Launch in tabs in a new dedicated Vim hex editor: vim -p -b -c "set binary" --servername HEXVIM <files>
    * Launch in tabs in an existing dedicated Vim hex editor: vim -b -c "set binary" --servername HEXVIM --remote-tab-silent <files> 

"

		33.37.4 References
    * :help hex-editing
    * :help :autocmd
    * :help internal-variables
    * :help edit-binary
    * Set_options_or_named_registers_with_let 


	33.38 Entering special characters

		33.38.1 Digraphs
To enter "special" characters such as the euro or copyright symbols, or diacritical marks such as the German umlaut or accent grave, digraphs can be used.

Digraphs work by pressing CTRL-K and a two-letter combination while in insert mode. For example, in insert mode type:

CTRL-K a:
CTRL-K e>
CTRL-K Co
CTRL-K Pd

to give ä and ê, © and £ .

You can also set the digraph option :set digraph (or :set dg).

With the digraph option set you can enter

a <BS> :
e <BS> >

to give the same result.

To list the currently defined digraphs type: :dig[raphs]

Here is a small extract from the :digraphs command:

Ct ¢  162    Pd £  163    Cu ¤  164    Ye ¥  165
e! è  232    e' é  233    e> ê  234    e: ë  235

The first two characters in each column are the characters you have to type to enter the digraph.
In the middle of each column is the resulting character.
The decimal number is the normal Unicode number of the character. 

		33.38.2 By character value
It is also possible to enter any character (which can be displayed in your current 'encoding'), even a character for which no digraph is defined, if you know the character value, as follows (where ^V means "hit Ctrl-V, except if you use Ctrl-V to paste, in which case you should hit Ctrl-Q instead):

    * By decimal value: ^Vnnn (with 000 <= nnn <= 255)
    * By octal value: ^VOnnn or ^Vonnn (with 000 <= nnn <= 377)
    * By hex value: ^VXnn or ^Vxnn (with 00 <= nn <= FF)
    * By hex value for BMP Unicode codepoints: ^Vunnnn (with 0000 <= nnnn <= FFFF)
    * By hex value for any Unicode codepoint: ^VUnnnnnnnn (with 00000000 <= nnnnnnnn <= 7FFFFFFF) 

Notes:

    * In all cases, initial zeros may be omitted if the next character typed is not a digit in the given base (except, of course, that the value zero must be entered as at least one zero).
    * Hex digits A-F, when used, can be typed in upper or lower case, or even in any mixture of them. 

"

		33.38.3 See also
    * :help digraph-table
    * :help digraph.txt
    * :help digraphs-changed Vim 6.0 and later use the RFC1345 mnemonics.
    * :help i_CTRL-V_digit
    * cream-ascii
    * Working with Unicode 

	33.39 Easily switch between two styles of color scheme
Tip 955 created June 28, 2005 · author Georg Dahn
Updated and merged to: Tip 341 

		33.39.1 Old version


Pan Shizhu's color scheme ps_color script#760 supports two styles, a cool (dark) and a warm (light) style. If you want to switch between these styles by just a single key stroke, you may define the following function in your vimrc file:

function! <SID>SwitchPSCStyle()
  if exists("g:psc_style")
    if g:psc_style == 'cool'
      let g:psc_style = 'warm'
    elseif g:psc_style == 'warm'
      let g:psc_style = 'cool'
    endif
  else
    let g:psc_style = 'warm'
  endif
  colorscheme ps_color
endfunction

In order to map this function to a key (for example to <F6>), just add the following mapping:

map <silent> <F6> :call <SID>SwitchPSCStyle()<CR>

This function cycles between the default colorscheme, peachpuff and desert.

function! <SID>SwitchColorSchemes()
  if exists("g:colors_name")
    if g:colors_name == 'default'
      colorscheme peachpuff
    elseif g:colors_name == 'peachpuff'
      colorscheme desert
    elseif g:colors_name == 'desert'
      colorscheme default
    endif
  endif
endfunction


This function cycles between the default colorscheme, and all my favorite colorschemes. I mapped to F7.

map <silent> <F7> :call <SID>SwitchColorSchemes()<CR>
function! <SID>SwitchColorSchemes()
	echo g:colors_name
  if exists("g:colors_name")
    if g:colors_name == 'default'
      colorscheme peachpuff
    elseif g:colors_name == 'peachpuff'
      colorscheme desert256
    elseif g:colors_name == 'desert256'
      colorscheme breeze
	elseif g:colors_name == "breeze"
	colorscheme morning 
	elseif g:colors_name == "morning"
	colorscheme darkblue 
	elseif g:colors_name == "darkblue"
	colorscheme gothic 
	elseif g:colors_name == "gothic"
	colorscheme aqua 
	elseif g:colors_name == "aqua"
	colorscheme earth 
	elseif g:colors_name == "earth"
	colorscheme black_angus 
	elseif g:colors_name == "black_angus"
	colorscheme relaxedgreen 
	elseif g:colors_name == "relaxedgreen"
	colorscheme darkblack  
	elseif g:colors_name == "darkblack"
	colorscheme freya  
	elseif g:colors_name == "freya"
	colorscheme motus  
	elseif g:colors_name == "motus"
	colorscheme impact  
	elseif g:colors_name == "impact"
	colorscheme less  
	elseif g:colors_name == "less"
	colorscheme chocolateliquor   
	elseif g:colors_name == "chocolateliquor"
	colorscheme default   
    endif
  endif
endfunction

		33.39.2 Newer Version
" Set next or previous colorscheme from a list.
function! SetNextColor(forward)
  if exists('g:colors_name')
    let colstr = 'default elflord peachpuff desert256 breeze morning'
    let colstr .= ' darkblue gothic aqua earth black_angus relaxedgreen'
    let colstr .= ' darkblack freya motus impact less chocolateliquor'
    let missing = []
    let colors = split(colstr)
    let current = index(colors, g:colors_name)
    for i in range(len(colors))
      let current += (a:forward ? 1 : -1)
      if !(0 <= current && current < len(colors))
        let current = (a:forward ? 0 : len(colors)-1)
      endif
      try
        execute 'colorscheme '.colors[current]
        break
      catch /E185:/
        call add(missing, colors[current])
      endtry
    endfor
    redraw
    if len(missing) > 0
      echo 'Error: colorscheme not found:' join(missing)
    endif
    echo g:colors_name
  endif
endfunction
nnoremap <F8> :call SetNextColor(1)<CR>
nnoremap <S-F8> :call SetNextColor(0)<CR>



"


		33.39.3 Updated version

You can easily change your color scheme, but it can be hard to compare several schemes to decide what's best for you. It may help to view a one-page summary of many color schemes.

Alternatively, the script presented below allows you to quickly change colors by pressing a key. If you like variety, you can start Vim with a different scheme depending upon the time of day.
Contents

    * 1 One page summary of color schemes
    * 2 Script features
    * 3 Script usage
    * 4 Scrolling the color schemes
    * 5 References
    * 6 Comments

			33.39.3.1  One page summary of color schemes

Maverick Woo has created a one-page summary showing sample C code in many different color schemes. Other pages at the same site show similar information for html, Java, LaTeX and Perl.

Some of the color schemes are provided with Vim. For example, the following command should show the elflord scheme:

:colorscheme elflord

Many samples show color schemes downloaded from Vim scripts (use its search facility to find a particular scheme).

			33.39.3.2  Script features

The script defines these key mappings:

    * Press F8 to use the next color scheme.
    * Press Shift-F8 to use the previous color scheme.
    * Press Alt-F8 to use a random color scheme. 

    (Note I prefer F7 tp F8)

The next/previous/random color scheme selection uses a list of scheme names maintained by the script. The list can be controlled with these commands (the default is all):

:SetColors all
    To use all installed color schemes ($VIMRUNTIME/colors/*.vim). 
:SetColors my
    To use names built into the script (define these names by editing the script to change the variables c1, c2 and c3). 
:SetColors blue slate ron
    To use the schemes specified (scheme names, separated with a space, for example, blue slate ron). 
:SetColors
    To display the current list of scheme names. 

After using :SetColors to list the scheme names (and while the list is still displayed), you could type :colors d then press Tab to expand 'd' to a color scheme name starting with 'd'. Then press Enter to invoke the color scheme (:colors is an abbreviation for :colorscheme).

Enter :SetColors now to set the current color scheme based on the time of day. Change the colors used by editing the nowcolors variable in the script, for example:

let nowcolors = 'breeze earth less aqua gothic'

			33.39.3.3  Script usage

    * Create and save file setcolors.vim containing the script below.
    * In Vim, use the command :source setcolors.vim to execute the script so you can experiment with its features.
    * Alternatively, if you save the script in file ~/.vim/plugin/setcolors.vim (Unix) or $HOME/vimfiles/plugin/setcolors.vim (Windows), it will be available whenever you start Vim. 

" Change the color scheme from a list of color scheme names.
" Version 2008-11-02 from http://vim.wikia.com/wiki/VimTip341
" Press key:
"   F7                next scheme
"   Shift-F7          previous scheme
"   Alt-F7            random scheme
" Set the list of color schemes used by the above (default is 'all'):
"   :SetColors all              (all $VIMRUNTIME/colors/*.vim)
"   :SetColors my               (names built into script)
"   :SetColors blue slate ron   (these schemes)
"   :SetColors                  (display current scheme names)
" Set the current color scheme based on time of day:
"   :SetColors now
if v:version < 700 || exists('loaded_setcolors') || &cp
  finish
endif
let loaded_setcolors = 1
let s:mycolors = []  " colorscheme names that we use to set color

" Set list of color scheme names that we will use, except
" argument 'now' actually changes the current color scheme.
function! s:SetColors(args)
  if len(a:args) == 0
    echo 'Current color scheme names:'
    let i = 0
    while i < len(s:mycolors)
      echo '  '.join(map(s:mycolors[i : i+4], 'printf("%-14s", v:val)'))
      let i += 5
    endwhile
  elseif a:args == 'all'
    let paths = split(globpath(&runtimepath, 'colors/*.vim'), "\n")
    let s:mycolors = map(paths, 'fnamemodify(v:val, ":t:r")')
    echo 'List of colors set from all installed color schemes'
  elseif a:args == 'my'
    let c1 = 'default elflord peachpuff desert256 breeze morning'
    let c2 = 'darkblue gothic aqua earth black_angus relaxedgreen'
    let c3 = 'darkblack freya motus impact less chocolateliquor'
    let c4 = 'novula midnight revolutions camo lilac moria'
    let c5 = 'fog taqua buttercream olive revolutions autumn2'
    let s:mycolors = split(c1.' '.c2.' '.c3.' '.c4.' '.c5)
    echo 'List of colors set from built-in names'
  elseif a:args == 'now'
    call s:HourColor()
  else
    let s:mycolors = split(a:args)
    echo 'List of colors set from argument (space-separated names)'
  endif
endfunction
command! -nargs=* SetColors call <SID>SetColors('<args>')

" Set next/previous/random (how = 1/-1/0) color from our list of colors.
" The 'random' index is actually set from the current time in seconds.
" Global (no 's:') so can easily call from command line.
function! NextColor(how)
  if len(s:mycolors) == 0
    call s:SetColors('all')
  endif
  if exists('g:colors_name')
    let current = index(s:mycolors, g:colors_name)
  else
    let current = -1
  endif
  let missing = []
  let how = a:how
  for i in range(len(s:mycolors))
    if how == 0
      let current = localtime() % len(s:mycolors)
      let how = 1  " in case random color does not exist
    else
      let current += how
      if !(0 <= current && current < len(s:mycolors))
        let current = (how>0 ? 0 : len(s:mycolors)-1)
      endif
    endif
    try
      execute 'colorscheme '.s:mycolors[current]
      break
    catch /E185:/
      call add(missing, s:mycolors[current])
    endtry
  endfor
  redraw
  if len(missing) > 0
    echo 'Error: colorscheme not found:' join(missing)
  endif
  echo g:colors_name
endfunction
nnoremap <F7> :call NextColor(1)<CR>
nnoremap <S-F7> :call NextColor(-1)<CR>
nnoremap <A-F7> :call NextColor(0)<CR>

" Set color scheme according to current time of day.
function! s:HourColor()
  let hr = str2nr(strftime('%H'))
  if hr <= 3
    let i = 0
  elseif hr <= 7
    let i = 1
  elseif hr <= 14
    let i = 2
  elseif hr <= 18
    let i = 3
  else
    let i = 4
  endif
  let nowcolors = 'elflord morning desert evening pablo'
  execute 'colorscheme '.split(nowcolors)[i]
  redraw
  echo g:colors_name
endfunction




"
			33.39.3.4  Scrolling the color schemes

You may want to impress your colleagues by having Vim change the color scheme periodically. The following might be your first attempt:

:autocmd CursorHold * call NextColor(1)

However, this fails because there is no timer event in Vim. The CursorHold event will fire only once when the user has been idle for the time specified with the 'updatetime' option (so if you stop typing, the color scheme will change once only).

If you want the color scheme to change every 10 seconds, execute the following command (press Ctrl-C to finish).

:while 1|sleep 10|call NextColor(1)|endwhile

			33.39.3.5  References

    * :help :colorscheme
    * :help g:colors_name 
    	

		33.39.4

	33.40 Highlight long lines
	Tip 810 - author Nitin Raut · version 6.0 
There are a number of situations where it can be helpful to know when you are near or have exceeded a certain column width (say 80 columns). Vim's highlighting features can be used to easily identify when this occurs. Unlike some editors, Vim cannot show a line at this width.
 Searching

A quick method to find long lines is a search like the following. If you use search highlighting (:set hlsearch), this will highlight all text after virtual column 80 (after tabs are expanded).

/\%>80v.\+

		33.40.1 Matching

A simple command will highlight any text after virtual column 80:

:match ErrorMsg '\%>80v.\+'

Of course, you can define your own highlight groups if ErrorMsg is not to your taste. Enter :match to clear matching.

		33.40.2 Automatic

If you want to be warned whenever text exceeds 80 columns you can use matching. In Vim 7.2 this is easy to achieve with the following commands (the -1 means any search highlighting will override the match highlighting):

:let w:m1=matchadd('Search', '\%<81v.\%>77v', -1)
:let w:m2=matchadd('ErrorMsg', '\%>80v.\+', -1)

You can apply this highlighting automatically for all files with something like this in your vimrc:

:au BufWinEnter * let w:m1=matchadd('Search', '\%<81v.\%>77v', -1)
:au BufWinEnter * let w:m2=matchadd('ErrorMsg', '\%>80v.\+', -1)

You can change the * to a different pattern, or a comma-separated list, to make it work only for certain file types like *.c,*.h for example.

Since matches are local to a window and are not inherited when a new window is created, this method will not necessarily apply to all new windows you create. It will be pretty close, but if you really want to highlight in all windows, you will need to apply the highlighting whenever you detect a window creation.

Clear the highlighting with:

:call matchdelete(w:m1)
:call matchdelete(w:m2)

Alternatively, the following command will clear all matches that have been defined for this window:

:call clearmatches()

 Automatic (for Vim before version 7.1.40)

For earlier versions of Vim, the following is a close approximation:

:syntax match Search /\%<81v.\%>77v/
:syntax match ErrorMsg /\%>80v.\+/

:au BufRead,BufNewFile * syntax match Search /\%<81v.\%>77v/
:au BufRead,BufNewFile * syntax match ErrorMsg /\%>80v.\+/

Note the use of BufRead and BufNewFile instead of BufWinEnter. Unlike matches, syntax is local to the buffer instead of the window.

Clear the highlighting (after saving any changes) with:

:e

This assumes you are editing a file using syntax rules contained in a syntax file (which usually do a syntax clear before applying their rules). If you are editing a file with no pre-existing syntax rules, you can get rid of all syntax highlighting with:

:syntax clear

		33.40.3 Manual

If you don't like to always highlight long lines, but you want a fast way to check your line length, you can define a mapping to toggle highlighting on/off. This also allows you to easily define the highlight in terms of the 'textwidth' option. The mapping could look like this:

nnoremap <silent> <Leader>l
      \ :if exists('w:long_line_match') <Bar>
      \   silent! call matchdelete(w:long_line_match) <Bar>
      \   unlet w:long_line_match <Bar>
      \ elseif &textwidth > 0 <Bar>
      \   let w:long_line_match = matchadd('ErrorMsg', '\%>'.&tw.'v.\+', -1) <Bar>
      \ else <Bar>
      \   let w:long_line_match = matchadd('ErrorMsg', '\%>80v.\+', -1) <Bar>
      \ endif<CR>

 Explanation

The search pattern \%>80v.\+ checks for a match at each position. If the position being tested is at a virtual column above 80, the text at that position is checked to see if it matches what follows (.\+). That matches one or more characters, up to but not including the end-of-line.

A simpler pattern such as \%81v.* fails to highlight text past the limit if there is no character in virtual column 81, for example if a tab starts just before that column. Furthermore, \%81v.* can give an erroneous highlight of column 81 on lines of exactly 80 characters.

The pattern \%<81v.\%>77v matches any character at virtual column 77 to 80 inclusive. The pattern checks for a match at each position: \%<81v. matches any character at a virtual column below 81; \%>77v causes the match to fail unless the virtual column of the next character is above 77.

		33.40.4 References

    * :help matchadd()
    * :help :match
    * :help /\%v 

	33.41  Using command-line history
Tip 45 created March 12, 2001 author Anon 

When you press : to enter a command, or / to start a search, you often want to edit a previous command or search. That can be done using the up and down arrow keys to scroll through the history. Then you can edit a previous line. :help :

For example, type :s and then press the up arrow key. The last command that starts with exactly what you typed will be displayed. Scroll through the history by pressing up or down. There is a history for commands, and another for searches (and more :help history). You can list the entire history using the :history command (:help :history). The command :his lists the command history, and :his / lists the search history.

In many situations, a better solution is the command-line window which you can open in two ways:

    * Type q: for commands, or q/ for searches; or
    * Type : or / to start entering a command or search, then press the 'cedit' key (default is Ctrl-f :help 'cedit'). 

The advantage of the command-line window is that you can use all Vim's editing power, including searching for previously-entered commands. After editing a command, you can:

    * Press Enter to execute the current line (and close the command-line window); or
    * Press Ctrl-c twice to close the command-line window (cancel). 

 Details

Suppose you search for "horse", then for "Hello", then for "helium", then for "habit".

If you type /h and repeatedly press up arrow, you will see /habit, then /helium, then /horse ("Hello" is skipped because it does not start with "h").

Register @: holds the last command, and @/ holds the last search. Therefore ":p will paste the last command, and "/p will paste the last search.

Type @: to repeat the last command.

You may have used several commands (for example, :%s/old/new/g) on the current buffer, and now find you would like to repeat those commands on another buffer. Type q: to enter the command window, then select and yank the commands you want. Press Ctrl-c twice to close the command window. If wanted, you can paste the commands into a buffer, then edit and save them. Later, you can source the file containing the commands, or you can yank the commands, then type :@"<CR> to execute the yanked commands on the current buffer.

If you always want to use the command editing window, try these mappings:

nnoremap : q:i
nnoremap / q/i
nnoremap ? q?i

 References

    * :help history
    * :help Cmdline
    * :help cmdwin
    * :help 'cmdwinheight' option controls initial height of command-line window
    * :help 'history' option controls number of history items stored in viminfo 



    "

id=Highlight_multiple_words
	33.42 Highlight multiple words
Vim provides a simple way to highlight all occurrences matching your last search, but it doesn't provide an easy way to highlight more than one search. This tip provides a script to make it easy to highlight multiple words in different colors. In addition, you can search for the next highlighted word.

		33.42.1 Requirements

The script uses matchadd() which requires Vim 7.2 (actually version 7.1.040 or later). You will probably need gvim to display the colors specified in the script. In addition, the script assumes you have a numeric keypad and a system that allows you to map keys on that keypad (for example, the command :map <k0> :echo 'Hello'<CR> would display Hello when you press 0 on the numeric keypad).

You need the script (highlights.vim) and the file that defines the highlight groups (highlights.csv); these are given below.

		33.42.2 Usage
Sample highlighting of words

The script defines highlight groups named hl1, hl2, ... hl9 (and more). Once enabled, pressing one of the keys 1, 2, ... 9 on the numeric keypad will highlight the word under the cursor with the colors defined in the corresponding highlight group (for example, press 4 on the keypad to highlight the current word with the hl4 group).

Type \m (assuming the default backslash leader key) to toggle mapping of the keypad on/off. At startup, the numeric keypad operates normally because only \m is mapped.

After typing \m to enable the mappings, you could use the keypad to:

    * Press 1 to highlight the current visually selected text, or the current word (if nothing is selected). Highlight group hl1 is used.
    * Press 2 for highlight hl2, 3 for highlight hl3, etc.
    * Press 0 to remove all highlights from the current visually selected text, or the current word. 

For example, if you place the cursor on the word "rain" and press 4 on the keypad, all occurrences of "rain" will be highlighted (use :hi hl4 to show the colors). No highlighting will occur in words like "rainbow".

Alternatively, place the cursor on "rain" and press viw to select the word, then 4. All occurrences of the visually selected text will be highlighted, including the "rain" in "rainbow".

Each window has its own set of highlights: if you use :split to show two windows, you can have one set of highlights in the top window, and a different set in the other window.

With the mappings enabled, you could use the keypad to:

    * Press - to remove all highlights in the current window.
    * Press + to restore the highlighting when - was last used in the current window.
    * Press * to restore the highlighting when - was last used in any window. 

For example, suppose you are displaying two windows and you want the same highlighting in each window. In the first window, apply the wanted highlighting. Then (using the numeric keypad keys):

    * Press - to remove all highlights in the first window.
    * Press + to restore them.
    * Switch to the other window and press * to apply the highlights from the first window. 

			33.42.2.1 Searching

After using \m to enable mappings, you can search for the next or previous occurrence of highlighted text. Patterns highlighted with the :match or :2match commands are also found.

Type \f to find the next match, or \F to find backwards. This has no effect on search highlighting or history.

Alternatively, type \n or \N to search forwards or backwards. Now you can press the normal search keys n or N to find the next or previous occurrence.

			33.42.2.2 Highlight command

The script defines a :Highlight n pattern command where n is a number (1..99) and pattern is the text you want highlighted. Depending on your system, you may be able to use the abbreviation :Hi rather than :Highlight.

The following examples use different colors to highlight various patterns:

:Highlight 4 hello
:Highlight 5 \<hello\>
:Highlight 6 Hello World
:Highlight 7 \c\<th

The second example is the same as placing the cursor on "hello" then pressing 5 on the numeric keypad. The last example highlights th occurring at the beginning of a word, not case sensitive.

The following command will list all active highlights (group names and patterns):

:Highlight

			33.42.2.3 Other commands

After using \m to enable the keypad mappings, you can press 1..9 on the keypad to highlight the visual selection (if any), or the current word. For example, pressing 4 on the keypad will highlight using the hl4 group.

In addition, you can press a digit 1..9 on the main keyboard before pressing 1..9 on the keypad. For example, if you press 2 on the main keyboard before 4 on the keypad, the hl24 highlight group will be used.

The :Hclear command can clear highlights. After typing :Hclear, you can enter an argument, or you can press Space then Tab for command completion (highlighted patterns). Examples:

" Remove highlight for visual selection (if any), or current word.
:Hclear
" Remove highlight 24.
:Hclear 24
" Remove all highlights for pattern '\c\<th'.
:Hclear \c\<th
" Remove all highlights.
:Hclear *

The following command will create a scratch buffer showing all the defined highlights:

:Hsample

The following commands can be used to save or restore the current highlights:

:Hsave anyname
:Hrestore anyname

Replace anyname with any name you would like to use. These commands use uppercase global variables (anyname is converted to uppercase), which Vim will save providing you have the ! flag in the 'viminfo' option (:set viminfo^=!).

After typing :Hsave or :Hrestore, you can press Space then Tab for command completion.

			33.42.2.4 Example

Copy this text into Vim to test word highlighting:

777  888  999   111 222 333 444 555 666 777 888 999
444  555  666   999 111 222 333 444 555 666 777 888
111  222  333   888 999 111 222 333 444 555 666 777
111222 333444 555666 777888999 111222 333444 555666

Use :sp to split the window and view the above text in both windows. Use \m to enable mappings, then apply some matches in the top window. Switch to the bottom window and apply some different matches: each window maintains a separate list of highlight matches.

In the next step, you must use the -+* keys on the numeric keypad. While in the bottom window, press - to clear highlighting in that window. If wanted, press + to restore highlighting. In the top window, press * to apply the highlighting from the bottom window.

		33.42.3 Script

Create file ~/.vim/plugin/highlights.vim (Unix) or $HOME/vimfiles/plugin/highlights.vim (Windows) containing the script below, then restart Vim.

" Plugin to highlight multiple words in different colors.
" Version 2008-11-19 from http://vim.wikia.com/wiki/VimTip1572
" File highlights.csv (in same directory as script) defines the highlights.
"
" Type '\m' to toggle mapping of keypad on/off (assuming \ leader).
" Type '\f' to find the next match; '\F' to find backwards.
" Can also type '\n' or '\N' for search; then n or N will find next.
" On the numeric keypad, press:
"   1 to highlight visually selected text or current word
"     using highlight group hl1 (defined below)
"   2 for highlight hl2, 3 for highlight hl3, etc
"     (can press 1 to 9 on keypad for highlights hl1 to hl9)
"   0 to remove highlight from current word
"   - to remove all highlights in current window
"   + to restore highlights cleared with '-' in current window
"   * to restore highlights (possibly from another window)
" Can press 1 or 2 on main keyboard before keypad 1..9 for more highlights.
" Commands:
"   ':Highlight' list all highlights.
"   ':Highlight [n [pattern]]' set highlight.
"   ':Hsample' display all highlights in a scratch buffer.
"   ':Hclear [hlnum|pattern|*]' clear highlights.
"   ':Hsave x', ':Hrestore x' save/restore highlights (x any name).
" Saving current highlights requires '!' in 'viminfo' option.
if v:version < 702 || exists('loaded_highlightmultiple') || &cp
  finish
endif
let loaded_highlightmultiple = 1

" On first call, read file highlights.csv in same directory as script.
" For example, line "5,white,blue,black,green" executes:
" highlight hl5 ctermfg=white ctermbg=blue guifg=black guibg=green
let s:data_file = expand('<sfile>:p:r').'.csv'
let s:loaded_data = 0
function! LoadHighlights()
  if !s:loaded_data
    if filereadable(s:data_file)
      let names = ['hl', 'ctermfg=', 'ctermbg=', 'guifg=', 'guibg=']
      for line in readfile(s:data_file)
        let fields = split(line, ',', 1)
        if len(fields) == 5 && fields[0] =~ '^\d\+$'
          let cmd = range(5)
          call map(cmd, 'names[v:val].fields[v:val]')
          call filter(cmd, 'v:val!~''=$''')
          execute 'silent highlight '.join(cmd)
        endif
      endfor
      let s:loaded_data = 1
    endif
    if !s:loaded_data
      echo 'Error: Could not read highlight data from '.s:data_file
    endif
  endif
endfunction

" Return last visually selected text or '\<cword\>'.
" what = 1 (selection), or 2 (cword), or 0 (guess if 1 or 2 is wanted).
function! s:Pattern(what)
  if a:what == 2 || (a:what == 0 && histget(':', -1) =~# '^H')
    let result = expand("<cword>")
    if !empty(result)
      let result = '\<'.result.'\>'
    endif
  else
    let old_reg = getreg('"')
    let old_regtype = getregtype('"')
    normal! gvy
    let result = substitute(escape(@@, '\.*$^~['), '\_s\+', '\\_s\\+', 'g')
    normal! gV
    call setreg('"', old_reg, old_regtype)
  endif
  return result
endfunction

" Remove any highlighting for hlnum then highlight pattern (if not empty).
" If pat is numeric, use current word or visual selection and
" increase hlnum by count*10 (if count [1..9] is given).
function! s:DoHighlight(hlnum, pat, decade)
  call LoadHighlights()
  let hltotal = a:hlnum
  if 0 < a:decade && a:decade < 10
    let hltotal += a:decade * 10
  endif
  if type(a:pat) == type(0)
    let pattern = s:Pattern(a:pat)
  else
    let pattern = a:pat
  endif
  let id = hltotal + 100
  silent! call matchdelete(id)
  if !empty(pattern)
    try
      call matchadd('hl'.hltotal, pattern, -1, id)
    catch /E28:/
      echo 'Highlight hl'.hltotal.' is not defined'
    endtry
  endif
endfunction

" Remove all matches for pattern.
function! s:UndoHighlight(pat)
  if type(a:pat) == type(0)
    let pattern = s:Pattern(a:pat)
  else
    let pattern = a:pat
  endif
  for m in getmatches()
    if m.pattern ==# pattern
      call matchdelete(m.id)
    endif
  endfor
endfunction

" Return pattern to search for next match, and do search.
function! s:Search(backward)
  let patterns = []
  for m in getmatches()
    call add(patterns, m.pattern)
  endfor
  if empty(patterns)
    let pat = ''
  else
    let pat = join(patterns, '\|')
    call search(pat, a:backward ? 'b' : '')
  endif
  return pat
endfunction

" Enable or disable mappings and any current matches.
function! s:MatchToggle()
  if exists('g:match_maps') && g:match_maps
    let g:match_maps = 0
    for i in range(0, 9)
      execute 'unmap <k'.i.'>'
    endfor
    nunmap <kMinus>
    nunmap <kPlus>
    nunmap <kMultiply>
    nunmap <Leader>f
    nunmap <Leader>F
    nunmap <Leader>n
    nunmap <Leader>N
  else
    let g:match_maps = 1
    for i in range(1, 9)
      execute 'vnoremap <silent> <k'.i.'> :<C-U>call <SID>DoHighlight('.i.', 1, v:count)<CR>'
      execute 'nnoremap <silent> <k'.i.'> :<C-U>call <SID>DoHighlight('.i.', 2, v:count)<CR>'
    endfor
    vnoremap <silent> <k0> :<C-U>call <SID>UndoHighlight(1)<CR>
    nnoremap <silent> <k0> :<C-U>call <SID>UndoHighlight(2)<CR>
    nnoremap <silent> <kMinus> :call <SID>WindowMatches(0)<CR>
    nnoremap <silent> <kPlus> :call <SID>WindowMatches(1)<CR>
    nnoremap <silent> <kMultiply> :call <SID>WindowMatches(2)<CR>
    nnoremap <silent> <Leader>f :call <SID>Search(0)<CR>
    nnoremap <silent> <Leader>F :call <SID>Search(1)<CR>
    nnoremap <silent> <Leader>n :let @/=<SID>Search(0)<CR>
    nnoremap <silent> <Leader>N :let @/=<SID>Search(1)<CR>
  endif
  call s:WindowMatches(g:match_maps)
  echo 'Mappings for matching:' g:match_maps ? 'ON' : 'off'
endfunction
nnoremap <silent> <Leader>m :call <SID>MatchToggle()<CR>

" Remove and save current matches, or restore them.
function! s:WindowMatches(action)
  call LoadHighlights()
  if a:action == 1
    if exists('w:last_matches')
      call setmatches(w:last_matches)
    endif
  elseif a:action == 2
    if exists('g:last_matches')
      call setmatches(g:last_matches)
    else
      call s:Hrestore('')
    endif
  else
    let m = getmatches()
    if !empty(m)
      let w:last_matches = m
      let g:last_matches = m
      call s:Hsave('')
      call clearmatches()
    endif
  endif
endfunction

" Return name of global variable to save value ('' if invalid).
function! s:NameForSave(name)
  if a:name =~# '^\w*$'
    return 'HI_SAVE_'.toupper(a:name)
  endif
  echo 'Error: Invalid name "'.a:name.'"'
  return ''
endfunction

" Return custom completion string (match patterns).
function! s:MatchPatterns(A, L, P)
  return join(sort(map(getmatches(), 'v:val.pattern')), "\n")
endfunction

" Return custom completion string (saved highlight names).
function! s:SavedNames(A, L, P)
  let l = filter(keys(g:), 'v:val =~# ''^HI_SAVE_\w''')
  return tolower(join(sort(map(l, 'strpart(v:val, 8)')), "\n"))
endfunction

" Save current highlighting in a global variable.
function! s:Hsave(name)
  let sname = s:NameForSave(a:name)
  if !empty(sname)
    let l = getmatches()
    call map(l, 'join([v:val.group, v:val.pattern, v:val.priority, v:val.id], "\t")')
    let g:{sname} = join(l, "\n")
  endif
endfunction
command! -nargs=? -complete=custom,s:SavedNames Hsave call <SID>Hsave('<args>')

" Restore current highlighting from a global variable.
function! s:Hrestore(name)
  call LoadHighlights()
  let sname = s:NameForSave(a:name)
  if !empty(sname)
    if exists('g:{sname}')
      let matches = []
      for l in split(g:{sname}, "\n")
        let f = split(l, "\t", 1)
        call add(matches, {'group':f[0], 'pattern':f[1], 'priority':f[2], 'id':f[3]})
      endfor
      call setmatches(matches)
    else
      echo 'No such global variable: '.sname
    endif
  endif
endfunction
command! -nargs=? -complete=custom,s:SavedNames Hrestore call <SID>Hrestore('<args>')

" Clear a match, or clear all current matches. Example args:
"   '14' = hl14, '*' = all, '' = visual selection or cword,
"   'pattern' = all matches for pattern
function! s:Hclear(pattern) range
  if empty(a:pattern)
    call s:UndoHighlight(0)
  elseif a:pattern == '*'
    call s:WindowMatches(0)
  elseif a:pattern =~ '^[1-9][0-9]\?$'
    call s:DoHighlight(str2nr(a:pattern), '', 0)
  else
    call s:UndoHighlight(a:pattern)
  endif
endfunction
command! -nargs=* -complete=custom,s:MatchPatterns -range Hclear call <SID>Hclear('<args>')

" Create a scratch buffer with sample text, and apply all highlighting.
function! s:Hsample()
  call LoadHighlights()
  new
  setlocal buftype=nofile bufhidden=hide noswapfile
  let lines = []
  let items = []
  for hl in filter(range(1, 99), 'v:val % 10 > 0')
    if hlexists('hl'.hl)
      let sample = printf('Sample%2d', hl)
      call s:DoHighlight(hl, sample, 0)
    else
      let sample = '        '
    endif
    call add(items, sample)
    if len(items) >= 3
      call insert(lines, substitute(join(items), '\s\+$', '', ''))
      let items = []
    endif
  endfor
  call append(0, filter(lines, 'len(v:val) > 0'))
  $d
  %s/\d3$/&\r/e
endfunction
command! Hsample call <SID>Hsample()

" Set a match, or display all current matches. Example args:
"   '14' = set hl14 for visual selection or cword,
"   '14 pattern' = set hl14 for pattern, '' = display all
function! s:Highlight(args) range
  if empty(a:args)
    echo 'Highlight groups and patterns:'
    for m in getmatches()
      echo m.group m.pattern
    endfor
    return
  endif
  let l = matchlist(a:args, '^\s*\([1-9][0-9]\?\)\%($\|\s\+\(.*\)\)')
  if len(l) >= 3
    let hlnum = str2nr(l[1])
    let pattern = l[2]
    if empty(pattern)
      let pattern = s:Pattern(0)
    endif
    call s:DoHighlight(hlnum, pattern, 0)
    return
  endif
  echo 'Error: First argument must be highlight number 1..99'
endfunction
command! -nargs=* -range Highlight call <SID>Highlight('<args>')

		33.42.4 Defining highlight groups

The script reads a CSV file with the same directory/name as the script, but with .csv extension. Each line should consist of five comma-separated fields, where the first field is a number from 1 to 99 inclusive (any other lines are ignored).

For example, the line "5,white,blue,black,green" would define a highlight group named hl5 which color terminals would display as white on blue, and gvim would display as black on green.

Create file ~/.vim/plugin/highlights.csv (Unix) or $HOME/vimfiles/plugin/highlights.csv (Windows) containing the sample below, then restart Vim.

hlnum,ctermfg,ctermbg,guifg,guibg
1,red,,red,
2,green,,green,
3,blue,,blue,
4,black,magenta,black,IndianRed
5,black,green,black,chartreuse
6,black,cyan,black,DeepSkyBlue
7,white,DarkRed,white,firebrick
8,white,DarkGreen,white,DarkGreen
9,white,DarkBlue,white,DarkSlateBlue
11,,,black,thistle
12,,,black,burlywood
13,,,black,PowderBlue
14,,,black,peru
15,,,black,DarkSeaGreen
16,,,black,SteelBlue
17,,,black,DarkOrange
18,,,black,DarkOliveGreen
19,,,black,SlateGray
21,,,red,grey20
22,,,green,grey20
23,,,CornflowerBlue,grey20
24,,,red,grey40
25,,,green,grey40
26,,,blue,grey40
27,,,red,grey70
28,,,DarkGreen,grey70
29,,,blue,grey70

		33.42.5 See also

    * Discussion page for alternative methods
    * View all named colors to show the colors for the standard color names
    * Highlighting information want to fix this to list relevant tips
    * MultipleSearch highlight multiple searches, each with a different color
    * Mark highlight several words in different colors 

		33.42.6 References

    * :help matchadd()
    * :help matchdelete()
    * :help clearmatches()
    * :help gui-colors 

	33.43 Jump to a file to a certain line number
Tip 487 created June 16, 2003 · complexity basic · author yijun · version 5.7

Often when editing a file in Vim, you may have a filename/line number pair such as "vim.h:1506" indicating a file you wish to open at the line number listed.

The gF command will do this for you, although ':' is included in 'isfname' under Windows, so you'll need to get rid of it first with set isfname-=:

    * :help gF
    * :help CTRL-W_F (same thing, but split the window for the new file)
    * :help CTRL-W_gF (same thing, but open a new tab for the new file) 

When such file-name/line number pairs are the result of compiling code, the following commands are also useful:

    * :help :cn
    * :help :cl
    * :help :cfile 

so go to line that has say, file.cpp:12 and press gF to go there.

	33.44 Open vimrc file
Tip 626 created December 24, 2003 · complexity basic · author Anon · version 6.0

		33.44.1 What is vimrc?

The vimrc file contains optional runtime configuration settings to initialize Vim when it starts. On Unix based systems, the file is named .vimrc, while on Windows systems it is named _vimrc. :help vimrc

You can customize Vim by putting suitable commands in your vimrc. Here is a very simple example:

set shiftwidth=4 softtabstop=4
set incsearch ignorecase hlsearch
" Press space to clear search highlighting and any message already displayed.
nnoremap <silent> <Space> :silent noh<Bar>echo<CR>

Search for file vimrc_example.vim in your Vim files for another example. :help vimrc-intro :help vimrc_example.vim

To customize Vim for editing a specific file, or a specific type of file, you can use modelines, or auto commands, or filetype plugins. :help auto-setting :help filetype

"

		33.44.2  Location of vimrc

In Vim, your home directory is specified with ~ on Unix systems, and $HOME on Windows systems. The following commands are useful to see what directories your Vim is using:

:version
:echo expand('~')
:echo $HOME
:echo $VIM
:echo $VIMRUNTIME

Note the 'system vimrc file' and 'user vimrc file' paths displayed by the :version command. The system vimrc file can be created by an administrator to customize Vim for all users. In addition, each user can have their own user vimrc.

The output from :version includes the paths of the system and user gvimrc files. If these files exist, they are used to configure Vim when the GUI version (gvim) runs (after settings from vimrc are applied).

You don't need a gvimrc file because you can put something like the following in your vimrc:

if has('gui_running')
  set guioptions-=T  " no toolbar
  colorscheme elflord
endif

"
		33.44.3  Opening vimrc

If Vim finds your vimrc file during startup, Vim will set the MYVIMRC environment variable to the full path of the vimrc file. Similarly, if your gvimrc file is found, the MYGVIMRC variable is set. Therefore, you can easily edit these files from within Vim:

:e $MYVIMRC
:e $MYGVIMRC

Using file name completion, you could type :e $M then press Tab until you see the desired variable. If you only want to see the path, type :echo $M then press Tab to see the variable, and press Enter.

In gvim, the Edit menu includes "Startup Settings" which will use $MYVIMRC to edit your vimrc file. If $MYVIMRC does not exist, "Startup Settings" will create a new file using the "user vimrc file" path shown by the :version command.

		33.44.4  Sourcing vimrc

After you have saved changes to your vimrc file, you can see the results by exiting from Vim, then starting Vim again.

If you are making frequent changes, you might want to "source" (execute) the changed vimrc file without exiting:

:so $MYVIMRC
" Alternative that can be used if vimrc is the current file:
:so %

Warning You may need to plan your vimrc so re-sourcing does not cause problems. If you define commands, functions, or autocmds, you must make them remove or override the previous version when sourced, or you will get errors (for commands and functions) or duplicates (for autocmds). Here are some examples that will work correctly when re-sourced:

" Use bang (!) to redefine a command or function, if already defined.
command! Mycommand echo "Hello!"
function! Myfunc()
  echo "Hello!"
endfunction

" Put all autocmds in some augroup and use au! to clear the group.
augroup vimrc_autocmds
  au!
  autocmd BufRead * echo "File read!"
augroup END

"

		33.44.5  Recovering from errors

Some errors in your vimrc may prevent Vim from starting successfully. A reliable way to handle that would be to rename your vimrc file, then edit the renamed file, then give it the correct name. Alternatively, you could start Vim with a command like this (or use "gvim" if that is how you run Vim):

vim -N -u NONE -U NONE

The -N starts in "not compatible" mode (that is, with extra Vim features). The NONE argument (must be uppercase) skips initializations and does not read any vimrc file (-u), and does not read any gvimrc file (-U).

You could now use the :version command to show the vimrc path, then enter a command to edit that file. 


	33.45 Uniq - Removing duplicate lines
Tip 648 author Michael Geddes 

The following command will sort all lines and remove duplicates (keeping unique lines):

:sort u

If you need more control, here are some alternatives.

There are two versions, the first leaves only the last line, the second leaves only the first line.

g/^\(.*\)$\n\1$/d
g/\%(^\1$\n\)\@<=\(.*\)$/d

Breakdown of the second version:

g//d <-- Delete the lines matching the regexp
\@<= <-- If the bit following matches, make sure the bit preceding this symbol directly precedes the match
\(.*\)$ <-- Match the line into subst register 1
\%( ) <--- Group without placing in a subst register.
^\1$\n <--- Match subst register 1 followed by end of line and the new line between the 2 lines

In this simple format (matching the whole line), it's not going to make much difference, but it will start to matter if you want to do stuff like match the first word only.

This does a uniq on the first word in the line, and deletes all but the first line:

g/\%(^\1\>.*$\n\)\@<=\(\k\+\).*$/d

 See also

    * Unique sorting script to 'sort unique' a List (not text lines)
    * system_utils.vim command to remove duplicate lines in a range (uses g//d method)
    * Sort lines how to sort lines 

 Comments

Here are some more Vim-native ways for removing duplicate lines. This time they don't have to be adjacent. Line order is preserved.

This one can be a bit slow.

:nno \d1 :g/^/m0<CR>:g/^\(.*\)\n\_.*\%(^\1$\)/d<CR>:g/^/m0<CR>

This is faster. Uses mark l.

:nno \d2 :g/^/kl\|if search('^'.escape(getline('.'),'\.*[]^$/').'$','bW')\|'ld<CR>

Following uses a substitute to delete all repeated lines (leaving only the first line, while deleting following duplicate lines). This is a variation on the g//d method.

%s/^\(.*\)\(\n\1\)\+$/\1/


	33.46 Ranges tutorial
Tip 1611 

A range permits a command to be applied to a group of lines in the current buffer. For most commands, the default range is the current line. For example:

    * :s/old/new/g   changes all old to new in the current line
    * :11,15s/old/new/g   changes lines 11 to 15 inclusive
    * :%s/old/new/g   changes all lines 

		33.46.1 Examples
A range can be specified using line numbers or special characters, as in these examples:
|Range 	|Description					|Example
-------------------------------------------------------------------------------
|21 	|line 21 					|:21s/old/new/g
|1 	|first line 					|:1s/old/new/g
|$ 	|last line 					|:$s/old/new/g
|. 	|current line 					|:.w single.txt
|% 	|all lines (same as 1,$) 			|:%s/old/new/g
|21,25 	|lines 21 to 25 inclusive 			|:21,25s/old/new/g
|21,$ 	|lines 21 to end				|:21,$s/old/new/g
|.,$ 	|current line to end 				|:.,$s/old/new/g
|.+1,$ 	|line after current line to end			|:.+1,$s/old/new/g
|.,.+5 	|six lines (current to current+5 inclusive) 	|:.,.+5s/old/new/g
|.,.5 	|same (.5 is interpreted as .+5)		|:.,.5s/old/new/g

The :s/// command substitutes in the specified lines. The :w command writes a file. On its own, :w writes all lines from the current buffer to the file name for the buffer. Given a range and a file name, :w writes only the specified lines to the specified file. The example above creates file single.txt containing the current line.

If you know you want to substitute in six lines, starting from the current line, you can use either of the ranges shown above. An easier method is to enter a count value (type 6), then enter the colon command with no range (type :s/old/new/g). Because you entered a count, Vim displays the command:

:.,.+5s/old/new/g


		33.46.2 Default Range

For most commands, the default range is . (the current line, for example, :s/// substitutes in the current line). However, for :g// and :w the default is % (all lines).
Example 	Equivalent 	Description
:s/old/new/g 	:.s/old/new/g 	substitute in current line
:g/old/ 	:%g/old/ 	list all lines matching old
:w my.txt 	:%w my.txt 	write all lines to file my.txt

		33.46.3 Selections
A command like :123,145s/old/new/g substitutes in lines 123 to 145 inclusive, but what if you're not sure what the line numbers are? One method is to use marks: Type ma in the first line, then type mb in the last line (to set marks a and b). Then enter command :'a,'bs/old/new/g to substitute in lines from mark a to b, inclusive.

Another method is to visually select lines, then enter a colon command (for example, :s/old/new/g). Note that you do not enter a range. However, because the command was entered while lines were selected, Vim displays the command as:

:'<,'>s/old/new/g

The range '<,'> is entered automatically to identify the lines that were last visually selected (they do not need to be visually selected now).

For example, you might type vip to visually select "inner paragraph" (the paragraph holding the cursor). Then type :s/old/new/g to substitute in all lines in the selected paragraph. 
		
		33.46.4 Deleting, copying and moving

Ranges work with Ex commands (those typed after a colon, for example, :w). As well as the commands we've seen so far, it's handy to know how to use :d (delete lines), :t or :co (copy lines), and :m (move lines).
Command 	Description
:21,25d 	delete lines 21 to 25 inclusive
:$d		delete the last line
:1,.-1d 	delete all lines before the current line
:.+1,$d 	delete all lines after the current line
:21,25t 30 	copy lines 21 to 25 inclusive to just after line 30
:$t 0		copy the last line to before the first line
:21,25m 30 	move lines 21 to 25 inclusive to just after line 30
:$m 0		move the last line to before the first line

The line numbers in a command are those before the command executes. In the earlier example which moved lines 21..25 to after 30, the "30" refers to the line number before the move occurred. 

		33.46.5 Ranges with marks and searches
In a range, a line number can be given as:

    * A mark (for example, 'x is the line containing mark x).
    * A search (for example, /pattern/ is the next line matching pattern). 

When using a mark, it must exist in the current buffer.
Command 	Description
:'a,'bd 	delete lines from mark a to mark b, inclusive
:.,'bd		delete lines from the current line to mark b, inclusive
:'a,'bm 0 	move lines from mark a to b inclusive, to the beginning

Here are some examples using searches:

:.,/green/co $
    copy the lines from the current line to the next line containing 'green' (inclusive), to the end of the buffer 
:/apples/,/apples/+1s/old/new/g
    replace all "old" in the next line in which the "apples" occurs, and the line following it 
:/apples/;.1s/old/new/g
    same (.1 is .+1, and because ; was used, the cursor position is set to the line matching "apples" before interpreting the .+1) 
:/apples/,.100s/old/new/g
    replace all "old" in the next line in which "apples" occurs, and all lines up to and including 100 lines after the current line (where the command was entered) 

Even more tricks are available; see :help cmdline-ranges. Summary:
Item		Description
/pattern/ 	next line where pattern matches
?pattern? 	previous line where pattern matches
\/		next line where the previously used search pattern matches
\? 		previous line where the previously used search pattern matches
\& 		next line where the previously used substitute pattern matches
0;/that 	first line containing "that" (also matches in the first line)
1;/that 	first line after line 1 containing "that" 


	33.47 C++ code completion
Tip 1608 author Knue · version 7.0 

This tip describes how to use C++ code completion in Vim (omni completion).

When editing a C++ file, enter the command :set omnifunc? to see what completion function is currently used. If the result is omnifunc=ccomplete#Complete, it means you are using the C completion provided with Vim (not C++). The following procedure provides C++ completion.
Contents
[hide]

    * 1 Required setup
    * 2 Using omni completion
    * 3 Additional information
    * 4 Comments

edit Required setup

|1. Install OmniCppComplete. See its doc/omnicppcomplete.txt file for information.
|
|2. Make a directory, for example ~/.vim/tags that will hold your ctags.
|
|3. Create stdc++ tags: Download and unpack the modified libstdc++ headers to ~/.vim/tags/cpp_src
(get it at http://www.vim.org/scripts/script.php?script_id=2358, intructions:
|1. unpack
|
|2. run
|$ ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ cpp_src
|$ mv tags cpp # or whatever
|
|3. In Vim:
set tags+=/my/path/to/tags/cpp 
 )
|
|4. Run ctags:

$ cd ~/.vim/tags
$ ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ cpp_src
$ mv tags cpp

|5. Add additional tags (change to your system/likings):

$ ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ /usr/include/GL/ && mv tags gl # for OpenGL
$ ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ /usr/include/SDL/ && mv tags sdl # for SDL
$ ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ /usr/include/qt4/ && mv tags qt4 # for QT4

For example, to add tags of ACS 5.1 project (enter clearcase view first then)
[yizaq@yizaq-lnx:Wed Jun 10:/view/yizaq__int.acs5_0.lx/vob/nm_acs/acs/runtime]$ ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++  && mv tags ~/.vim/tags/acs_5_1/

|6. Edit your ~/.vimrc and change to your system/likings:

" configure tags - add additional tags here or comment out not-used ones
set tags+=~/.vim/tags/cpp
set tags+=~/.vim/tags/gl
set tags+=~/.vim/tags/sdl
set tags+=~/.vim/tags/qt4
"For ACS 5_1
set tags+=~/.vim/tags/acs_5_1
#Note, on my linux dev env I need to run manualy the set tags commands from ex prompt to make it work
" build tags of your own project with CTRL+F12
map <C-F12> :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .<CR>

" OmniCppComplete
let OmniCpp_NamespaceSearch = 1
let OmniCpp_GlobalScopeSearch = 1
let OmniCpp_ShowAccess = 1
let OmniCpp_MayCompleteDot = 1
let OmniCpp_MayCompleteArrow = 1
let OmniCpp_MayCompleteScope = 1
let OmniCpp_DefaultNamespaces = ["std", "_GLIBCXX_STD"]
" automatically open and close the popup menu / preview window
au CursorMovedI,InsertLeave * if pumvisible() == 0|silent! pclose|endif
set completeopt=menuone,menu,longest,preview

edit Using omni completion

When everything is set up properly you can use the code completion. Make sure the file-type of your file is set to cpp. Perhaps you must set it manually with

:setfiletype cpp

Now start typing:

std::

A box opens with suggestions. You can use C-n and C-p to navigate. C-x C-o opens the omnicompletion manually. A preview window should also appear on the top which shows the signature of functions and the like. Choose vector and continue:

std::vector<int> vi;
vi.

Another box opens with suggestions. Choose "push_back(" and continue.

As you can see this is a really nice feature which is especially nice when you use an external library which you don't know that good. Simply create the tags as described above and browse through the suggestions.
edit Additional information

It is nice to have the headers of the used libs really on your system so the preview window has something to show. So don't delete the headers after creating the tag files.
edit Comments

Notes paraphrased from a vim_use post by Brett Stahlman (to be merged into tip):

With standard Vim, when you edit a C++ file (*.cpp or *.cc), 'omnifunc' is set to ccomplete#Complete which uses the distributed omnicomplete function for C, defined in file: $VIMRUNTIME/autoload/ccomplete.vim

The C version can display class members, but it won't do so unless you declare the class variable with "class MyClass" (as opposed to simply "MyClass").

Solution: Use the omnicppcomplete plugin mentioned in the tip. It is C++ aware, and may also be used for C. It understands inheritance, "this" pointers, namespaces, etc.

Limitations: It's not fully functional with templates (supposedly because of limitations in exuberant ctags). So far, the only template limitation I've encountered is that "this" pointers aren't completed properly within method implementations.

How-it-works: The omnicppcomplete plugin, which consists of a number of Vim script files, implements an 'omnifunc' function (using the autoload mechanism) that handles completion for <C-X><C-O>, and also defines insert mode mappings for '.', '->', and '::', to ensure that completion is performed automatically when those characters are typed, without the need for the user to hit <C-X><C-O>.

    * :help i_CTRL-X_CTRL-O
    * :help 'omnifunc'
    * :help complete-functions 

The omnicppcomplete plugin's 'omnifunc' function first attempts to determine what sort of lookup needs to be performed, based upon the surrounding context, then performs the lookup in the tags file(s) specified in the 'tags' option. For C++ completion to work properly, you must use the ctags options shown in the tip, for example:

ctags --c++-kinds=+p --fields=+iaS --extra=+q test1.cpp

"


	33.48 Handle common command typos
Use cabbrev to correct command typos that you commonly make.

For example, if you tend to hold the shift key too long:

cabbrev Q quit
cabbrev W write

or, if you tend to miss the "!" and hit the "@" as well:

cabbrev q!@ q!
cabbrev wq!@ wq!

If you ever find that you actually need to type one of the typos you make, you'll need to disable cabbrev temporarily. 
 
Some related examples from my .vimrc file:
" Frequently when I go to save with :w I am flying to fast and I type :W
" which gives me an obvious error.
"
" How can I map :W to :w ???
" How can I map :Q to :q ???
"
" I know there is :ZZ but I like the :w more.
"
:command! -bang W w<bang>
:command! -bang Q q<bang>
:command! -bang Wa wa<bang>
:command! -bang Qa qa<bang>
" often make the mistake of typing w1 instead of w!.
" Can you please suggest how to map w1 to w!?
if version<  700
	        cnoreabbrev w1 w!
else
	        cnoreabbrev  <expr>  w1  ((getcmdtype() == ':'  &&  getcmdpos()  <= 2)?   'w!' : 'w1')
endif


	33.49 Environment variables
Tip 1589 complexity basic · author Metacosm · version 7.0

Vim can read and write environment variables within your current shell session. Use a $ prefix to identify an environment variable, as in the following examples.

Display the contents of the PATH environment variable:

:echo $PATH

Assign the PATH environment variable to a Vim variable:

:let myvar = $PATH

Change the PATH environment variable for the current session:

:let $PATH = '/foo:/bar'

Insert the contents of the PATH environment variable into the buffer:
Press i to enter insert mode, press Ctrl-r then =$PATH and press Enter.

References:

    * :help expr-env
    * :help expression-syntax
    * :help {{{id}}} 

	33.50 Using the Windows clipboard in Cygwin Vim
Tip 1623 created April 10, 2009 · complexity basic · author Ir0nh34d · version 7.0

Using Vim under Cygwin, it is difficult to access the Windows clipboard:

    * Typing "+y does not yank (copy) to the Windows clipboard.
    * Typing "+p does not paste from the Windows clipboard. 

As a result, you cannot easily use the clipboard to copy text between Cygwin Vim and a native Windows application. This tip shows some workarounds.

Contents

    * 1 Copy to Windows clipboard
    * 2 Paste from Windows clipboard
    * 3 See also

		33.50.1 Copy to Windows clipboard

Using this function:

function! Putclip(type, ...) range
  let sel_save = &selection
  let &selection = "inclusive"
  let reg_save = @@
  if a:type == 'n'
    silent exe a:firstline . "," . a:lastline . "y"
  elseif a:type == 'c'
    silent exe a:1 . "," . a:2 . "y"
  else
    silent exe "normal! `<" . a:type . "`>y"
  endif
  call system('putclip', @@)
  let &selection = sel_save
  let @@ = reg_save
endfunction

And simple mappings, such as:

vnoremap <silent> <leader>y :call Putclip(visualmode(), 1)<CR>
nnoremap <silent> <leader>y :call Putclip('n', 1)<CR>

You can visually select some text then yank it to the Windows clipboard, or use the normal yank options (for example, 3\y to yank 3 lines based from the current line, assuming the default backslash leader key).

To allow for usage from the command line, add a command to execute Putclip with a range:

com! -nargs=0 -range=% Putclip call Putclip('c', <line1>, <line2>)

		33.50.2 Paste from Windows clipboard

Using this function:

function! Getclip()
  let reg_save = @@
  let @@ = system('getclip')
  setlocal paste
  exe 'normal p'
  setlocal nopaste
  let @@ = reg_save
endfunction

And a simple mapping, such as:

nnoremap <silent> <leader>p :call Getclip()<CR>

You can use the normal paste options (for example, \p to paste the clipboard contents, assuming the default backslash leader key).

		33.50.3 See also

    * fakeclip plugin allowing use of "*p, "*yy and more on Cygwin 

	33.51 Showing syntax highlight group in statusline


Tip 1573 created June 22, 2008 · complexity basic · author Dominiko · version 7.0

You can show the syntax highlight group where the cursor is located in your statusbar. This is especially useful when tweaking a color theme.

First define a function which returns the highlight group syntax under the cursor:

function! SyntaxItem()
  return synIDattr(synID(line("."),col("."),1),"name")
endfunction

Then insert into your statusline a call to function SyntaxItem:

set statusline+=%{SyntaxItem()}

Here is a complete example showing the syntax highlight group among other things:

if has('statusline')
  set statusline=%#Question#                   " set highlighting
  set statusline+=%-2.2n\                      " buffer number
  set statusline+=%#WarningMsg#                " set highlighting
  set statusline+=%f\                          " file name
  set statusline+=%#Question#                  " set highlighting
  set statusline+=%h%m%r%w\                    " flags
  set statusline+=%{strlen(&ft)?&ft:'none'},   " file type
  set statusline+=%{(&fenc==\"\"?&enc:&fenc)}, " encoding
  set statusline+=%{((exists(\"+bomb\")\ &&\ &bomb)?\"B,\":\"\")} " BOM
  set statusline+=%{&fileformat},              " file format
  set statusline+=%{&spelllang},               " language of spelling checker
  set statusline+=%{SyntaxItem()}              " syntax highlight group under cursor
  set statusline+=%=                           " ident to the right
  set statusline+=0x%-8B\                      " character code under cursor
  set statusline+=%-7.(%l,%c%V%)\ %<%P         " cursor position/offset
endif

See also

    * Identify the syntax highlighting group used at the cursor 

References

    * :help 'statusline'
    * :help synIDattr 

	33.52 Tip 278 The principles of effective text editing 
	is moving around very efficiently.

	Following are some pointers which may help you do that.

	h   move one character left
	j   move one row down
	k   move one row up
	l   move one character right
	w   move to beginning of next word
	b   move to beginning of previous word
	e   move to end of word
	W   move to beginning of next word after a whitespace
	B   move to beginning of previous word before a whitespace
	E   move to end of word before a whitespace

	All the above movements can be preceded by a count; e.g. 4j will move down 4 lines.

	0   move to beginning of line
	$   move to end of line
	^   move to first non-blank char of the line
	_   same as above, but can take a count to go to a different line
	g_  move to last non-blank char of the line (can also take a count as above)

	gg  move to first line
	G   move to last line
	nG  move to n'th line of file (where n is a number)

	H   move to top of screen
	M   move to middle of screen
	L   move to bottom of screen

	Ctrl-D  move half-page down
	Ctrl-U  move half-page up
	Ctrl-B  page up
	Ctrl-F  page down
	Ctrl-o  jump to last cursor position
	Ctrl-i  jump to previous cursor position

	n   next matching search pattern
	N   previous matching search pattern
	*   next word under cursor
	#   previous word under cursor
	g*  next matching search pattern under cursor
	g#  previous matching search pattern under cursor
	
	%   jump to matching bracket { } [ ] ( )
	
	See :help {command} (for example, :help g_) for all of the above if you want more details. 


	33.53 Tip 396 Highlight unwanted spaces

It can be hard to maintain consistent use of whitespace characters (space and tab). You may not want spaces before tabs, or trailing whitespace at the end of a line. Sometimes you may want to avoid tabs, or just see where tabs occur.

This tip shows several ways to highlight unwanted whitespace. In addition, the tip explains how to use the listchars option (abbreviated to lcs) to indicate when characters are not displayed on long lines.
Contents
[hide]

    * 1 Highlighting with a search
    * 2 Highlighting with the match command
    * 3 Highlighting with the syntax command
    * 4 Using the list and listchars options
    * 5 Using syntax space errors
    * 6 Showing long lines
    * 7 See also
    * 8 Comments

		33.53.1 Highlighting with a search

For occasional use, you can simply search using a suitable pattern to highlight what you want. The following examples assume you use search highlighting (:set hlsearch).

" Show all tabs:
/\t

" Show trailing whitespace:
/\s\+$

" Show spaces before a tab:
/ \+\ze\t

		33.53.2 Highlighting with the match command

The :match command specifies the name of a highlight group and a pattern. Any text matching the pattern will be displayed in the foreground and background colors defined by the highlight group. :help :match :help :2match

Some examples follow. These use a highlight group named ExtraWhitespace which could be defined with one of the following in your vimrc. :help :highlight

:highlight ExtraWhitespace ctermbg=red guibg=red
" The following alternative may be less obtrusive.
:highlight ExtraWhitespace ctermbg=darkgreen guibg=lightgreen
" Try the following if your GUI uses a dark background.
:highlight ExtraWhitespace ctermbg=darkgreen guibg=darkgreen

However, be aware that future colorscheme commands may clear all user-defined highlight groups. Using,

:autocmd ColorScheme * highlight ExtraWhitespace ctermbg=red guibg=red

before the first colorscheme command will ensure that the highlight group gets created and is not cleared by future colorscheme commands. :help :colorscheme

Once this highlight group is created, it can be associated with matching text as in the following examples.

" Show trailing whitespace:
:match ExtraWhitespace /\s\+$/

" Show trailing whitepace and spaces before a tab:
:match ExtraWhitespace /\s\+$\| \+\ze\t/

" Show tabs that are not at the start of a line:
:match ExtraWhitespace /[^\t]\zs\t\+/

" Show spaces used for indenting (so you use only tabs for indenting).
:match ExtraWhitespace /^\t*\zs \+/

" Switch off :match highlighting.
:match

Alternatively, the following pattern will match trailing whitespace, except when typing at the end of a line.

:match ExtraWhitespace /\s\+\%#\@<!$/

If you use this alternate pattern, you may want to consider using the following autocmd to let the highlighting show up as soon as you leave insert mode after entering trailing whitespace:

:autocmd InsertLeave * redraw!

Or alternatively, the following can be used:

:au InsertEnter * match ExtraWhiteSpace /\s\+\%#\@<!$/
:au InsertLeave * match ExtraWhiteSpace /\s\+$/

which does not "flash" the screen.

Any :match highlighting applies only to the current window. With the following in your vimrc, the command will be applied to the first window, and to any subsequent windows. The pattern * applies the highlight to all files.

" Show leading whitespace that includes spaces, and trailing whitespace.
:autocmd BufWinEnter * match ExtraWhitespace /^\s* \s*\|\s\+$/

Rather than an autocmd, you may prefer a mapping. With the following, and the default backslash Leader key, you can type \wn to switch highlighting on, and \wf to switch it off.

:nnoremap <Leader>wn :match ExtraWhitespace /^\s* \s*\<Bar>\s\+$/<CR>
:nnoremap <Leader>wf :match<CR>

With Vim 7.1.40 and later, you can use the matchadd() function to define matches (making the :match command available for other purposes). See Highlight long lines for examples.
		33.53.3 Highlighting with the syntax command

Using the :match command is easy, but you may want to keep it for another purpose. An alternative is to use syntax highlighting. :help syntax

Here is an example using one of the patterns shown earlier. Put this in your vimrc, after the command :syntax on (which you may already have). Of course you would also need to define ExtraWhitespace with a :highlight command, as shown earlier.

" Show trailing whitepace and spaces before a tab:
:autocmd Syntax * syn match ExtraWhitespace /\s\+$\| \+\ze\t/

If you want the above command to also work if the match is nested in some other syntax group, append containedin=ALL to the end.

		33.53.4 Using the list and listchars options

In Vim, 'list' is a boolean option that defaults to off. If 'list' is on, whitespace characters are made visible. The 'listchars' option can be used to customize the way whitespace characters are shown. The default displays "^I" for each tab, and "$" at each EOL (end of line, so trailing whitespace can be seen). :help 'list'

The command :set list displays whitespace, while :set nolist displays normally. It is convenient to use :set list! to toggle the option on, so that you can later press : followed by the up arrow to repeat the previous command, to toggle 'list' off.

The following example toggles list, then sets listchars to not display an end-of-line character, and to display > for the first character occupied by a tab, and - for any subsequent characters that the tab may occupy.

:set list!
:set listchars=tab:>-

Here are some alternatives that you can try (each sets list and listchars in one command):

:set list listchars=tab:>-,trail:.,extends:>
" Enter the middle-dot by pressing Ctrl-k then .M
:set list listchars=tab:\|_,trail:·
" Enter the right-angle-quote by pressing Ctrl-k then >>
:set list listchars=tab:»·,trail:·
" Enter the Pilcrow mark by pressing Ctrl-k then PI
:set list listchars=tab:>-,eol:¶
" The command :dig displays other digraphs you can use.

The listchars option uses the "NonText" highlighting group for "eol", "extends" and "precedes", and the "SpecialKey" highlighting group for "nbsp", "tab" and "trail". :help 'listchars'
		33.53.5 Using syntax space errors

Vim has several syntax files that support the display of "space errors". For example, for the C programming language (:set filetype=c), you could put the following in your vimrc:

let c_space_errors = 1

Supported languages are: ada, c, chill, csc, forth, groovy, icon, java, lpc, mel, nqc, nroff, ora, pascal, plm, plsql, python and ruby. The c settings also apply to cpp.

To highlight space errors in java files, you would use:

let java_space_errors = 1

For C, if you don't want to see trailing space errors at end-of-line set:

let c_no_trail_space_error = 1

If you only use spaces to indent, and don't want to see space errors in front of tabs:

let c_no_tab_space_error = 1

If you are interested in learning more, open the syntax file for C (in Vim, put the cursor on the path $VIMRUNTIME/syntax/c.vim and type gf). Then look for the definition of the highlight group cSpaceError (near the end of the file). That group specifies the color used to display space errors in C files. The command :hi cSpaceError will show "xxx" in that color.

		33.53.6 Showing long lines

By default, lines longer than the screen width are not wrapped, and you can horizontally scroll the text, for example by moving the cursor to the end of a long line. Therefore there may be characters preceding the visible text (non-displayed characters on the left), and there may be characters that extend after the visible text (non-displayed characters on the right). The listchars option can be used to show a highlighted symbol when characters are not displayed, for example:

" Show < or > when characters are not displayed on the left or right.
:set list listchars=precedes:<,extends:>
" Same, but also show tabs and trailing spaces.
:set list listchars=tab:>-,trail:.,precedes:<,extends:>

"
		33.53.7 See also

    * Highlight some whitespace characters a script to toggle specified highlighting
    * Converting tabs to spaces to convert tabs to spaces or vice versa
    * Remove unwanted spaces to display or remove unwanted spaces
    * Remove unwanted empty lines to delete blank lines
    * cream-showinvisibles plugin for attractive display of tabs, returns and trailing spaces 

	33.54 Tip 438 Search and replace in a visual selection

Contents

    * 1 Visual selection basics
    * 2 Ex commands
    * 3 Substituting in a visual selection
    * 4 Searching with / and ?
    * 5 References
    * 6 Comments

		33.54.1 Visual selection basics

You can visually select text, then operate on the selection.

Press v to select a range of text, or V to select whole lines, or Ctrl-V (Ctrl-Q if you use Ctrl-V to paste) to select a block.

After starting the selection, move the cursor with any normal-mode movement commands (such as j to move down, or w to move by a word, or / to search).

Marks for the beginning and end of the visual selection are automatically defined:

'<  start line
`<  start character
'>  end line
`>  end character

You can press gv to reselect the last visual selection, but the '< and '> marks defining the beginning and end of the block persist even when the selection highlight has been removed, so gv is not necessary to repeat a command.

		33.54.2 Ex commands

When text is visually selected, press : to enter a command. The command line will automatically enter the range:

:'<,'>

You can enter a command such as s/red/green/g to replace each red with green in all lines of the last visual selection. The command will appear as:

:'<,'>s/red/green/g

To repeat an Ex command over a previously selected block, use the : history. That is, press : then <Up>, then edit a previous command.

		33.54.3 Substituting in a visual selection

The substitute command (:s) applies to whole lines, however the \%V atom will restrict a pattern so that it matches only inside the visual selection. This works with characterwise and blockwise selection (and is not needed with linewise selection).

For example, put the cursor on this line:

music amuse fuse refuse

In normal mode, type ^wvee to visually select "amuse fuse" (^ goes to first nonblank character, w moves forward a word, v enters visual mode, e moves forward to end of next word). Then press Escape and enter the following command to change all "us" to "az" in the last-selected area within the current line:

:s/\%Vus/az/g

The result is:

music amaze faze refuse

For another example, copy the following text into a buffer:

Before block with old and sold.
First told abc old sold gold.
Another is old, gold but not cold.
Last is older, fold not bold.
After block with fold and older and bold.

Perform a block selection:

    * Type /abc and press Enter to search for 'abc'.
    * Press Ctrl-V to start a block selection (press Ctrl-Q if you use Ctrl-V for paste).
    * Type eee to select to the end of "sold".
    * Type jj to extend the block selection over three lines.
    * Press Escape to clear the selection. 

Now we will use a substitute command to replace each "old" with "NEW". The replacement will check each line in the buffer, but will only match within the last visual selection:

:%s/\%Vold/NEW/g

The result is:

Before block with old and sold.
First told abc NEW sNEW gold.
Another is NEW, gNEW but not cold.
Last is older, fNEW not bold.
After block with fold and older and bold.

The vis.vim plugin is another approach to apply substitutes to a selected region.

		33.54.4 Searching with / and ?

In visual mode, / and ? will update the visual selection just like any other cursor-movement command (that is, when in visual mode, searching will extend the selection).

In order to actually search within the visual selection, you will need to use the \%V atom, or use the markers defined by the visual selection with the \%>'< and \%<'> atoms. This is best done by leaving the visual selection with <Esc> before entering your search. You may want to consider a mapping to automatically leave visual selection and enter the appropriate atoms. For example:

:vnoremap <M-/> <Esc>/\%V

Using this mapping, you can press Alt-/ in order to automatically fill in a "range" for your search just like using an Ex command with :. To use this, move to the first line of interest and press V to start line-wise visual selection. Move down (press j for a line or } for a paragraph, etc). When you have selected the area you want to search, press Alt-/. The visual selection will be removed, and a search command will start. You will see:

/\%V

Add what you want to find, then press Enter. For example, you may enter green and see:

/\%Vgreen

When you press Enter, each occurrence of "green" will be highlighted, but only in the area that you had previously selected.

Here are two further examples that do not use a visual selection. The first command searches only in lines 10 to 20 inclusive. The second searches only between marks a and b.

/\%>9l\%<21lgreen
/\%>'a\%<'bgreen

See Search keywords in C function which uses this technique to search within a function in a C program.

		33.54.5 References

    * :help :'
    * :help history
    * :help /\%V
    * :help /\%>'m
    * :help /\%<'m 

	33.55 Tip 330 How to stop auto indenting

This tip discusses automatic indenting of text that may occur while you are typing, and explains how to disable such automatic indentation.

For a general discussion of indenting, see Indenting source code.

If you use Vim in a terminal, you may find that pasting from another application changes the indents in the pasted text. See Toggle auto-indenting for code paste to deal with that problem.
Contents

    * 1 Disabling file type based indentation for a specific file type
    * 2 Disabling file type based indentation for all file types
    * 3 Disabling auto indent for the current file
    * 4 Comments

		33.55.1 Disabling file type based indentation for a specific file type

You may like auto indenting in C programs, but dislike it when editing html files. You can disable auto indentation for particular files types; the following example shows how to do this for html files.

Create the file ~/.vim/indent/html.vim on Unix-based systems, or $HOME/vimfiles/indent/html.vim on Windows systems, containing the single line:

let b:did_indent = 1

This creates a user-specific indent script which will be loaded before the file type indent script. Auto indenting for the particular file type is disabled because well-behaved indent scripts do nothing if the buffer-local variable b:did_indent is defined (that variable indicates that the current buffer already has script-based indenting enabled).

You need to use the correct name for the file type (html in the above). If you are not sure what that name is, edit a file where you want to remove auto indentation (for example, my.htm), then enter the following command to display the value of the ft (filetype) option for the current buffer:

:set ft?

		33.55.2 Disabling file type based indentation for all file types

The auto indentation provided for most languages is very helpful, and you should consider trying it. However, it's easy to disable all auto indents if wanted.

Actually, auto indentation is off by default, and if it is enabled on your system, that is because something has enabled it. For example, your vimrc may contain:

filetype indent plugin on

or

filetype indent on

If you remove the indent keyword, none of your files will have file type based indentation rules applied.

However, the filetype indent plugin on command may be included in a system-wide vimrc (:help system-vimrc), or in the file vimrc_example.vim sourced from your vimrc. For either of these cases, put the following near the bottom of your vimrc to disable filetype based indentation:

filetype indent off

		33.55.3 Disabling auto indent for the current file

To see the current indenting settings, and where they were set, enter:

:verbose set ai? cin? cink? cino? si? inde? indk?

If you are editing a particular file and you want to prevent auto indenting within that file, enter:

:setlocal noautoindent
:setlocal nocindent
:setlocal nosmartindent
:setlocal indentexpr=

The following is equivalent (it uses the abbreviated names in a single command):

:setl noai nocin nosi inde=

Here is a mapping so you can press F8 to disable auto indenting:

:nnoremap <F8> :setl noai nocin nosi inde=<CR>

		33.55.4 Comments

You may have disabled auto indenting in HTML files, but you would like auto indenting of your embedded PHP code. When wanted, enter the following to toggle the smartindent option, and show its current value:

:setl si! si?

    Note that while 'smartindent' works decently for PHP, filetype indentation usually works better, even in this case. I think that -- and correct me if I'm wrong -- setting ft=php should offer indentation for PHP while leaving the HTML alone. See :help 'filetype', and also VimTip1213. (Spiiph 23:10, 2 August 2009 (UTC)) 


	33.56 Tip 16 Avoiding the "Hit ENTER to continue" prompts

	The "Hit ENTER to continue" prompt is displayed when Vim is about to redraw the screen, but there's text on the screen that you might need to read. This happens when something is displayed on the status line that is wider than the window, and after executing an external command.

	To reduce how often you see the "Hit ENTER to continue" prompt, you can shorten the messages, increase the space for displaying messages, or even tell Vim not to worry about external command output.

	To decrease message size, use the 'shortmess' option. Add the following line to your vimrc:

	:set shortmess=a

	This will use abbreviations for status messages to make lines shorter. (There are several other flags for 'shortmess' that can shorten messages even more. :help 'shortmess')

	To give more space for displaying messages, you can increase the height of the command line to 2 or greater:

	:set cmdheight=2

	The default command height is 1. Increasing cmdheight will allow more room for commands, although it will take some space away from editing.

	Finally, you can use :silent to keep external commands from triggering the "Hit ENTER" prompt:

	:silent !echo Hello

	If the command generates any output, you may need to manually refresh the screen once you return to Vim (by typing Ctrl-L or entering :redraw!). (If you're running a GUI version of Vim, :silent may keep you from seeing any output from the command at all!)
	See also

	     Execute external programs asynchronously under Windows for the "Hit any key to close this window..." prompt under Windows 
	    
References

* :help hit-enter
* :help 'shortmess'
* :help 'cmdheight'
* :help :!cmd
* :help :silent 

[edit] Comments

* putting the following setting into your .vimrc settings file works good for eliminating the <Press Enter> message when first bringing up a vim editor to a specific file with a large path.
The 't' option chops the beginning portion of file lines, indicating the truncation with a < sign at the point of truncation.

set shortmess=at
	    
	33.57 Tip 1577 Record a recursive macro

	Often, when dealing with a data file in text format (e.g. csv), we need to massage the data to modify, filter or rearrange it. Using a clever trick to recursively use Vim's complex repeats (i.e. "macro recording"), such tasks can be done easily without having to be a REGEXpert.

	Let's say we have a text file with the following contents:

	dr-------- 20906
	drwx------ 20913
	drwxr-x--- 20704
	drwxr-xr-x 21104
	lrwxrwxrwx 20606
	-------r-- 21004
	-rw-r----- 20716
	-rwxrwx--- 21102

	For some reason, we want to move the 5-digit number at the end of the line to after the last "r" character on the same line, and we want to repeat it for the whole file. Notice that all these numbers begin with "2" and there can be multiple "r" per line.

	Here's the end-result that we want:

	dr20906--------
	dr20913wx------
	drwxr20704-x---
	drwxr-xr21104-x
	lrwxrwxr20606wx
	-------r21004--
	-rw-r20716-----
	-rwxr21102wx---

	Yes, this can be done via :substitute with back references (Try: %s/\v(.+r)(.+)\s(\d{5})/\1\3\2/), but that can be intimidating for some. An easier, more flexible and often quicker method to accomplish the same task is to use "complex repeats", which really aren't too complex.

	Here's how:

	   a. Place the cursor on the first character of the first line of the file.
	   b. Hit the following keys to record the repeat-sequence:
qqq : Start and immediately end recording for register q -- this essentially empties register q
* qq : Start recording actions into register q
* f2 : Find the "2" character to the right on this line (cursor will jump there)
* D : Delete and yank the 5-digit number into memory (rest of line)
* Fr : Find the "r" character to the left on this line (cursor will jump to the last "r")
* p : Paste the number that was yanked earlier after the "r" character
* Enter : Move the cursor to the next line
* @q : Execute the contents of register q (itself!), which is for now, empty, so nothing will happen. The trick here is that when we run it again with "@q" after you have ended the recording, it will call itself after processing each line! This recursive loop will process all the subsequent lines in that file, until it hits the end-of-file. This is the essence that makes complex repeats so flexible and powerful.
* q : End the recording 
c. Hit @q to apply the same manipulation to the rest of the file from the 2nd line onwards. Enjoy the art of flying cursor and automatic text manipulation on your screen. 

With this knowledge, you can now quickly perform complex editing of any structured text with relative ease.

This works much the same way as typing 9999@q to execute the 'q' register as many times as the count you pass, except that you do not need to think about the size of your file before doing so to make sure enough 9s are added.
Normally, a macro recorded in this way will repeat until it reaches the end of the file. But, you can easily take advantage of the fact that a macro will stop running if it encounters an error to end the recursion when you want. For example, suppose you have a list of file names (perhaps you obtained it with :r !ls *.c), and you want to verify that every one of these file names occurs in another buffer (a makefile, for instance). You could do this quickly and easily as follows:

* Format the file list to one file name per line, with each file name starting at beginning of the line
* Split a new window with the file you wish to contain all the file names (for a total of two windows)
* Position the cursor on the first line of the file list
* Record a recursive macro as follows: 

qfq
qf
0y$
<c-w>w
/\V<c-r>"<cr>
			<c-w>w
			j@f
			q

			The result is that register 'f' contains a macro that will search for every line of the list of file names, until it reaches the end of the list of file names or until it encounters an error such as "pattern not found: {filename}". If you run this macro on the file list, you will either see each file name highlighted in turn until the end of the list, or you will see a pattern not found error and (if 'hlsearch' is on) the missing file will be highlighted in the list.

			If you don't wan't to rely on an error in this way to end the recursion, you could also do :if cond | exe 'normal @q' | endif instead of @q while recording the macro to provide a base case to end the recursion.

			-> Adding recursion to an existing macro

			Forget to add the recursion as a final step, or want to debug first before running the macro on every line in the file? An easy solution is, after you have the macro doing everything but the recursive call, just append it to the register. Assuming that you've recorded the macro into the 'q' register, just do this:

			qQ
			@q
			q


	33.58 Multiple commands at once
	Tip 767 author pim · version 6.0

	You can execute more then one command by placing a | between two commands.

	For example:

	%s/htm/html/c | %s/JPEG/jpg/c | %s/GIF/gif/c
	
	This example substitutes for htm, then moves on to JPEG, then GIF.
	
	The second command (and subsequent commands) are only executed if the prior command succeeds.
	
	This works for most commands, but some commands like :argdo or :autocmd see the '|' as one of their arguments. This allows commands such as :argdo, which execute a different Vim command, to execute a series of commands. See :help :\bar for the full list of such commands.
	
	For example:
	
	argdo %s/foo/bar/gc | w
	
	Normally, Vim will complain if you haven't saved changes to a buffer before abandoning it, but by adding | w in the above example, you can actually write out each buffer after processing. Note that this command will, for each item in the arg list, do a :substitute and a :write. If :argdo didn't take '|' as an argument, it would instead run the :substitute on each item, then write the last item.  
	If you want to make a command chain including one of the commands listed at :help :\bar, you can still do so using the :execute command. For example, in order to chain a :normal command, you would need to do something like this:
	
	:execute 'normal "ayiw' | echo @a
	
	edit References
	
	    * :help :\bar
	        * :help :execute 
	
	
	33.59 Find in files within Vim
Tip 1543 author Fritzophrenic · version 7.0
Contents

    * 1 Basic use
    * 2 Tips and Tricks
          o 2.1 Old search results
          o 2.2 Recursive search
          o 2.3 Path separators
          o 2.4 Mappings
    * 3 Disabling autocmds for fast searches
    * 4 Using external programs for fast searches
    * 5 Related Plugins
    * 6 See also
    * 7 References
    * 8 Comments

		33.59.1 Basic use

A useful feature in many text editors is the ability to search for regular expressions in multiple files. Vim has this feature, but it is a little hard to find.

Vim provides these commands for searching files:

    * :grep
    * :lgrep
    * :vimgrep
    * :lvimgrep 

All of these commands can be used to search for a regular expression in whatever files you specify. "grep" and "lgrep" use an external application to perform the search, and are great if you are running Vim on a system with a good file searching utility, if you are accustomed to using an external application for your searches, or if your search is not a complicated one. "vimgrep" and "lvimgrep" are part of Vim, and therefore are good for using on any system, especially if you want to use Vim-style regular expressions in your search. Keep in mind though, that vimgrep can often be slower than grep, which will call an external program to do the dirty work.

These commands all fill a list with the results of their search. "grep" and "vimgrep" fill the "quickfix list", which can be opened with :cw or :copen, and is a list shared between ALL windows. "lgrep" and "lvimgrep" fill the "location list," which is local to the current window, and can be opened with :lw or :lopen. Both of these lists can be used to instantly jump to the matching line in whatever file it occurs in.

Use of grep and lgrep depend on the external application they point to, but use of vimgrep and lvimgrep is as follows:

:vim[grep][!] /{pattern}/[g][j] {file} ...

The 'g' option specifies that all matches for a search will be returned instead of just one per line, and the 'j' option specifies that Vim will not jump to the first match automatically.

For example, to search for the words "house" or "home" in all .txt files in the current directory, use:

:lvim /\<\(house\|home\)\>/gj *.txt
:lw

		33.59.2 Tips and Tricks

			33.59.2.1 Old search results

If you would like to view the results of a previous search, the :colder (or :lolder) and :cnewer (or :lnewer) commands will allow you to do this without typing the search again.

    * :help :colder
    * :help :cnewer
    * :help :lolder
    * :help :lnewer 

			33.59.2.2 Recursive search

You can use ** in the file pattern to search recursively. For example, to search for all lines containing "dostuff()" in all .c files in the parent directory and all its subdirectories, use:

:vimgrep /dostuff()/j ../**/*.c

Be careful! On Windows, either escape the backslash with another backslash, or use a forward slash (see next section). The above will work on Windows, but this will not, for example:

:vimgrep /dostuff()/j ..\**\*.c

			33.59.2.3 Path separators

In the Windows version of Vim, backslash ('\') characters can be used as path separators, but forward slashes also work, and using '/' allows file paths in these searches to work in Vim under any operating system. This is especially useful if your vimrc file is used on multiple platforms, and you want to write mappings for common searches as below.

			33.59.2.4 Mappings

You can use a mapping, command, or abbreviation for common searches, like a search for a word under the cursor in all files of the same type in the current directory. This can be especially useful if you have it automatically open the results list as well.

This mapping uses <cword> to get the word under the cursor, and searches for it in the current directory and all subdirectories, opening the quickfix window when done:

map <F4> :execute "vimgrep /" . expand("<cword>") . "/j **" <Bar> cw<CR>

This command based on VimTip483 uses <cword> to get the word under the cursor, but also uses % to limit the search to the current file only:

command GREP :execute 'vimgrep /'.expand('<cword>').'/gj '.expand('%') | copen

Finally, this cabbrev uses CTRL-R CTRL-W to get the word under the cursor, limiting the search to files of the same type using expand("%:e"), and moving the cursor on the command-line to be just before the file list using <C-Left>, so that you can easily specify a different search location. This method is nice because you can either type :lvim<Enter> to perform the default search, or :lvim<Space> to enter the default search into the command line, but leave it there for editing.

cabbrev lvim
      \ lvim /\<lt><C-R><C-W>\>/gj
      \ *<C-R>=(expand("%:e")=="" ? "" : ".".expand("%:e"))<CR>
      \ <Bar> lw
      \ <C-Left><C-Left><C-Left>

Note: Using a cabbrev and a mapping together may not work very well, because the mapping will trigger the cabbrev. Also, be careful not to use common text in your cabbrev, such as making one for the "vim" command, because then whenever you try to edit a .vim file for example, the cabbrev will be expanded when you press Enter. You could avoid this by moving the cursor to somewhere else in the line before pressing enter.

		33.59.3 Disabling autocmds for fast searches

Using vimgrep to search hundreds of files can be slow. A search taking only a few seconds using an external grep program might take nearly a minute with vimgrep. One reason for this is that vimgrep uses Vim's procedures to read files, which can involve execution of several autocommands.

You can make use of the :noautocmd command modifier to drastically increase search speed by temporarily disabling all autocmds during the execution of the :vimgrep. It may also solve other issues you may have, such as unwanted interaction with plugins that trigger off BufRead events. Use it as follows:

:noautocmd vimgrep /{pattern}/[flags] {file(s)}

See :help :noautocmd

This simple addition should work in any of the examples given in this tip, including mappings and abbreviations.

An unfortunate side effect of disabling autocmds in this way is that you may find syntax highlighting is off when Vim displays the result. One workaround is to type :e and press Enter to reload the file. Another is to use the j flag in the search, to prevent jumping to the first match automatically. You will then need to enter a command such as :cw to open the quickfix window, then press Enter to see it. Or, use :cnext.

Note that autocmds must be enabled in order for vimgrep to work for remote or archived files, since Vim's editing of such files depends on plugins using autocmds.

		33.59.4 Using external programs for fast searches

If you want to speed up searching in files, and you don't need the power of Vim's regular expressions or its ability to detect file encodings, you can use an external program (traditionally grep) for searching. But, remember to do it within Vim using :grep, so that you have the output available in Vim to view and navigate by!

Depending on your system, you may find that a command like the following will quickly search files:

:grep pattern *.c

See :help :grep, :help 'grepprg', and Search using quickfix to list occurrences for ways to customize this, either to make it work on your system or to do something else entirely! The above example will work on many Unix-based systems (which have grep in the path), and on many Windows systems (where Vim will try to use findstr).

In addition there are plugins to integrate these utilities with Vim:

    * grep.vim : Grep search tools integration with Vim
    * findstr.vim : Using MS-Windows findstr utility to search for text with Vim 

		33.59.5 Related Plugins

    * trag.vim: A wrapper for vimgrep that facilitates regexp building and project handling
    * EasyGrep: Makes vimgrep easier with mappings and configurable options, and provides "replace in files" capability 

		33.59.6 See also

    * Tip 1234: Find files in subdirectories, for when the contents of a file are not known, but the file name or part of the file name is.
    * Tip 1008: Toggle to open or close the quickfix window, for a quick way to toggle on or off the quickfix window which contains the results of your vimgrep searches. 

		33.59.7 References

    * :help :grep
    * :help :vimgrep
    * :help quickfix
    * :help starstar
    * :help :<cword>
    * :help c_<C-R>_<C-W>
    * :help :cabbrev
    * :help abbreviations 


	33.60 Copy or change search hit
	Tip 1597 

	While searching, you may want to operate on the text found by a search. Typically, you want to copy a search hit, or change it (delete the hit, and enter insert mode so you can type in new text). Often one of the standard commands can be used (for example, if you searched for a complete word, the command cw may be sufficient to change it).

	A more general approach comes from the fact that //e can be used to repeat the last search (because no new search pattern was entered), with the e search offset to move the cursor to the end of the search hit. :help search-offset

	For example, after searching, you may want to change the hit. Without implementing this tip, you could type c//e and press Enter. Then enter the replacement text and press Escape.

*1 A search text object
*2 Explanation
*3 Limitations
*4 See also
*5 References
*6 Comments

		33.60.1 A search text object

With this tip, after searching you can:

* Type ys to copy the search hit.
* Type "+ys to copy the hit to the clipboard.
* Type cs to change the hit.
* Type gUs to convert the hit to uppercase.
* Type vs to visually select the hit. If you type another s you will extend the selection to the end of the next hit. 

For example, search for 'File' and change it to 'Data' (cs = change search):
		    
/File
csData<Esc>
" Sample to search: GetFileDir GetFileId GetFilePos MyFile BackupFile

Then press n to find the next occurrence and press . to repeat the change.

Put the following in your vimrc:

" Make a simple "search" text object.
vnoremap <silent> s //e<C-r>=&selection=='exclusive'?'+1':''<CR><CR>
\:<C-u>call histdel('search',-1)<Bar>let @/=histget('search',-1)<CR>gv
omap s :normal vs<CR>

		33.60.2 Explanation

This tip implements a simple search text object identified as "s". When in visual mode, s is mapped to find the end of the last search pattern (//e). When in operator-pending mode (for example, after pressing y in normal mode), s is mapped to normal-mode vs which starts visual mode (assuming v has not been mapped) and invokes the s visual-mode mapping.

The <C-r>= evaluates the following expression which tests the 'selection' option. If exclusive selection is used, the result is '+1', otherwise the result is an empty string. Accordingly, the visual-mode map becomes //e+1 or //e. :help search-offset

The visual-mode mapping continues with :<C-u> to enter the command line while removing the visual range automatically inserted by Vim. The histdel function removes the last (-1) item from the search history ('//e+1' or '//e'). The let statement assigns the previous search item to @/ (the search register) so pressing n or N will search for the next or previous instance.

In :help todo we see a plan for a future version of Vim:

Add text object for current search pattern: "a/" and "i/". Makes it possible to turn text highlighted for 'hlsearch' into a Visual area. 

This tip prefers the simple "s" for a search hit, with no attempt to implement "a" and "i" text objects. Instead, "s" selects from the current position to the end of the next search hit.

The default for visual mode in Vim is that you can press c or s to change a selected area. Using the mapping suggested in this tip, you would no longer be able to press s to change a visual area (use c instead).
		33.60.3 Limitations

The tip can be helpful to reduce distractions while editing because you can always press ys to yank the hit, or cs to change it (you don't have to think about an alternative method). However, the tip has several limitations:

Pressing . to repeat a change will change the same number of characters that were previously changed (so you can only repeat a change when the search hit is a fixed length).
 The text object fails when the search hit is a single character, and when search wraps around the end of the buffer.
 Suppose you use :set selection=exclusive and search for 'abc'. If you find 'abc' at the end of a line, operations such as ys or cs will include the line break. 

		33.60.4 See also

 Copy the search results into clipboard 

		33.60.5 References

 :help text-objects
 :help :map-modes 

	33.61 Copy the search results into clipboard
Tip 478 

Several methods allow you to capture all search hits. Usually, you want to copy each line which contains text matching your search pattern, but you can also copy just the matching text. We'll start with methods to easily list search hits, without copying them.
Contents

    * 1 Search within a file
    * 2 Copying lines containing search hits
    * 3 Copying only the matching text
    * 4 See also
    * 5 Comments

[edit] Search within a file

To search, press / then type what you want to find, or press * to search for the current word.

To list all lines matching your search pattern, use the following. The first command lists lines matching your last search. The second lists lines matching pattern.

:g/
:g/pattern

To view a window of search results, see Find in files within Vim. You can use % for the file path to search only the current file, for example:

" Save file, search it for 'pattern', and open a clickable list.
:w
:vimgrep /pattern/ %
:copen

To view only the parts of a file that match your pattern, see Folding with Regular Expression. You can fold away non-matching lines, and use zr to reveal more context around the search hits.
[edit] Copying lines containing search hits

You can copy matching lines to the clipboard, so they can be pasted into another application.

To copy all lines containing a search pattern, use the following (see Power of g). The first command clears register a (:help q). The second appends all matching lines to that register (:help quotea). The third copies register a to the clipboard (register +) for easy pasting into another application. Replace pattern with what you want to search for.

qaq
:g/pattern/y A
:let @+ = @a

The above procedure captures only the first line of each match. If your pattern matches more than one line, use the following.

" Use /pattern to search for something, then
"   :call CopyMatchingLines()
" to copy all lines containing hits (whole lines).
" The pattern may extend over multiple lines.
" The 'normal! $' attempts to avoid copying the same line more than once.
" FIX: For some patterns, it could miss a second hit?
function! CopyMatchingLines()
  let posinit = getpos(".")
  call cursor(1, 1)
  let cnt = 0
  let hits = []
  let snum = search(@/, 'cW')
  while snum > 0
    let enum = search(@/, 'ceW')
    call extend(hits, getline(snum, enum))
    let cnt += 1
    normal! $
    let snum = search(@/, 'W')
  endwhile
  if cnt > 0
    let @+ = join(hits, "\n") . "\n"
  endif
  call cursor(posinit[1], posinit[2])
  echomsg cnt 'lines (or blocks) were appended to the clipboard.'
endfunction

[edit] Copying only the matching text

A search pattern may use a regular expression. For example, the following finds all words that begin with 'a':

/\<a\w*\>

The following procedures allow you to copy just the text which matches a pattern. Source the CopyMatches command and function, then perform the search above. To copy all matching text to the clipboard, enter the following. The first command clears the clipboard. The second appends matching text to the clipboard (since no pattern is given, the last search is used). The second command is equivalent to :%CopyMatches.

0"+y0
:g//CopyMatches

You can also use the command to copy all matches from a range of lines, and into a register other than the clipboard:

:1,10CopyMatches a

" Copy matches of the last search to a register (default is the clipboard).
" Accepts a range (default is the current line).
" Matches are appended to the register and each match is terminated by \n.
" Usage: [RANGE]CopyMatches [REGISTER]
command! -nargs=0 -range -register CopyMatches call s:CopyMatches(<line1>, <line2>, "<reg>")
function! s:CopyMatches(line1, line2, reg)
  let reg = a:reg != '' ? a:reg : '+'
  for line in range(a:line1, a:line2)
    let txt = getline(line)
    let idx = match(txt, @/)
    while idx > -1
      exec "let @".reg." .= matchstr(txt, @/, idx) . \"\n\""
      let end = matchend(txt, @/, idx)
      let idx = match(txt, @/, end)
    endwhile
  endfor
endfunction

The following alternative is to copy matches which extend over more than one line.

" Use 0"+y0 to clear the clipboard, then
"    :g/pattern/call CopyMultiMatches()
" to copy all multiline hits (just the matching text).
" This is for when the match extends over multiple lines.
" Only the first match from each line is found.
" BUG: When searching for "^function.*\_s*let" the '.*' stops at the end
" of a line, but it greedily skips "\n" in the following (we copy too much).
function! CopyMultiMatches()
  let text = join(getline(".", "$"), "\n") . "\n"
  let @+ .= matchstr(text, @/) . "\n"
endfunction

[edit] See also

    * Redirect g search output to redirect g// output to a new window or a file
    * Filter buffer on a search result to create a scratch buffer with matching lines
    * Find in files within Vim for a clickable list of search hits
    * Folding with Regular Expression to fold away non-matching lines 

"


id=__vim_wo_cream__
	33.62 Cream, 
        Where to download Vim for Windows, install VIM for windows, find most recent build for windows, latest most recent vim version 
Tip 1578 

Which version of Vim should I use?

    * I want a fully patched standard Vim for Windows, without compiling it myself. 

        See "Vim without Cream problems" below. 

    The easiest and best solution for Windows users on 32-bit systems is to use the standard Vim (Vim without Cream) at http://sourceforge.net/projects/cream/files/ 
    Enable scripting in your browser. 
    Near the bottom, click "+" next to "Vim" to expand the list of files. 
    The first file listed under Vim should have a name like gvim-7-2-234.exe (Vim without Cream, version 7.2.234 = 7.2 with patches 1234). 
    You can click the icon in the "Notes/Subscribe" column to see the output of the :version command (which shows what features are in the build). 
    Click the most recent gvim-7-2-xxx.exe to download; run the download to install. 
    It installs a patched standard gvim.exe (GUI) and vim.exe (console), with all help and runtime files. 
    Includes Perl, Python, Ruby, Tcl and MzScheme interfaces. 

    * I'm using 64-bit Windows. 

    See information and download. 

    * I want standard Vim (source code to compile for all platforms, or unpatched Windows executables). 

    Available at http://www.vim.org/download.php 

    * I want an easy-to-use configuration for Windows with common menus and standard keyboard shortcuts. 

    Cream for BSD, Linux and Windows is available at http://cream.sourceforge.net/download.html 
    Click "Windows One-click installer, includes both Vim and Cream". 
    You will download a file with a name like cream-0-41-gvim-7-1-293.exe (Cream version 0.41 with gvim version 7.1.293 = 7.1 with patches 1293). 
    Note: This package may include an obsolete version of Vim. After you download it, you may want to upgrade the "Vim" part of it from (let's say) 7.1.293 to (let's say) 7.2.234, see above "I want a fully patched Vim for Windows". 

    * I want to put Vim on a keydrive and use it on a bunch of Windows machines, but standard versions of Vim choke when the keydrive is mounted as a different drive letter. 

    Check out GVim Portable http://portablegvim.sourceforge.net/ 

    * I want Vim on a Macintosh. 

    See the versions at http://www.vim.org/download.php#mac 


	33.63 Example vimrc
Tip 1628 

This is a sample vimrc file that offers an alternative to the vimrc_example.vim delivered with Vim. It was created in discussion with the ops and regulars of the #vim community.
Contents

    * 1 Requirements and caveats
    * 2 Usage recommendations
    * 3 Example vimrc
    * 4 Comments

		33.63.1 Requirements and caveats

The code in this example .vimrc requires a full featured Vim. While it is possible to insert checks to omit some settings for Vim binaries with less features, that would make the file more complex and hard to understand.

If your Vim does not support some of the options and features suggested here, you will have to install a Vim package with a larger feature set, or upgrade to a newer version of Vim.
		33.63.2 Usage recommendations

This is a minimal, but feature rich, .vimrc that aims to satisfy the majority of new and intermediate Vim users. While you may use this example as your .vimrc out-of-the-box, it is important to understand what the options and features do. It contains features and options that almost all Vim users should have at least basic knowledge about.
		33.63.3 Example vimrc

" URL: http://vim.wikia.com/wiki/Example_vimrc
" Authors: http://vim.wikia.com/wiki/Vim_on_Freenode
" Description: A minimal, but feature rich, example .vimrc. If you are a
"              newbie, basing your first .vimrc on this file is a good choice.
"              If you're a more advanced user, building your own .vimrc based
"              on this file is still a good idea.

"------------------------------------------------------------
" Features {{{1
"
" These options and commands enable some very useful features in Vim, that
" no user should have to live without.

" Set 'nocompatible' to ward off unexpected things that your distro might
" have made, as well as sanely reset options when re-sourcing .vimrc
set nocompatible

" Attempt to determine the type of a file based on its name and possibly its
" contents.  Use this to allow intelligent auto-indenting for each filetype,
" and for plugins that are filetype specific.
filetype indent plugin on

" Enable syntax highlighting
syntax on


"------------------------------------------------------------
" Must have options {{{1
"
" These are highly recommended options.

" One of the most important options to activate. Allows you to switch from an
" unsaved buffer without saving it first. Also allows you to keep an undo
" history for multiple files. Vim will complain if you try to quit without
" saving, and swap files will keep you safe if your computer crashes.
set hidden

" Better command-line completion
set wildmenu

" Show partial commands in the last line of the screen
set showcmd

" Highlight searches (use <C-L> to temporarily turn off highlighting; see the
" mapping of <C-L> below)
set hlsearch

" Modelines have historically been a source of security vulnerabilities.  As
" such, it may be a good idea to disable them and use the securemodelines
" script, <http://www.vim.org/scripts/script.php?script_id=1876>.
" set nomodeline


"------------------------------------------------------------
" Usability options {{{1
"
" These are options that users frequently set in their .vimrc. Some of them
" change Vim's behaviour in ways which deviate from the true Vi way, but
" which are considered to add usability. Which, if any, of these options to
" use is very much a personal preference, but they are harmless.

" Use case insensitive search, except when using capital letters
set ignorecase
set smartcase

" Allow backspacing over autoindent, line breaks and start of insert action
set backspace=indent,eol,start

" When opening a new line and no filetype-specific indenting is enabled, keep
" the same indent as the line you're currently on. Useful for READMEs, etc.
set autoindent

" Stop certain movements from always going to the first character of a line.
" While this behaviour deviates from that of Vi, it does what most users
" coming from other editors would expect.
set nostartofline

" Display the cursor position on the last line of the screen or in the status
" line of a window
set ruler

" Always display the status line, even if only one window is displayed
set laststatus=2

" Instead of failing a command because of unsaved changes, instead raise a
" dialogue asking if you wish to save changed files.
set confirm

" Use visual bell instead of beeping when doing something wrong
set visualbell

" And reset the terminal code for the visual bell.  If visualbell is set, and
" this line is also included, vim will neither flash nor beep.  If visualbell
" is unset, this does nothing.
set t_vb=

" Enable use of the mouse for all modes
set mouse=a

" Set the command window height to 2 lines, to avoid many cases of having to
" "press <Enter> to continue"
set cmdheight=2

" Display line numbers on the left
set number

" Quickly time out on keycodes, but never time out on mappings
set notimeout ttimeout ttimeoutlen=200

" Use <F11> to toggle between 'paste' and 'nopaste'
set pastetoggle=<F11>


"------------------------------------------------------------
" Indentation options {{{1
"
" Indentation settings according to personal preference.

" Indentation settings for using 2 spaces instead of tabs.
" Do not change 'tabstop' from its default value of 8 with this setup.
set shiftwidth=2
set softtabstop=2
set expandtab

" Indentation settings for using hard tabs for indent. Display tabs as
" two characters wide.
"set shiftwidth=2
"set tabstop=2


"------------------------------------------------------------
" Mappings {{{1
"
" Useful mappings

" Map Y to act like D and C, i.e. to yank until EOL, rather than act as yy,
" which is the default
map Y y$

" Map <C-L> (redraw screen) to also turn off search highlighting until the
" next search
nnoremap <C-L> :nohl<CR><C-L>


"------------------------------------------------------------"



	33.64 Increasing or decreasing numbers

You can increment or decrement a number by pressing Ctrl-A or Ctrl-X when in Normal mode. The number can be at the cursor, or after the cursor.

The number can be decimal, hexadecimal or octal. You can also increment or decrement a single letter ("a...", "b...", "c..."). This is controlled with the 'nrformats' option.

Ctrl-A is very useful in a macro. As an example, suppose you type the line:

101 This is an item.

In Normal mode, enter the following to record a macro into the a register. This macro yanks the current line, then pastes it below, then increments the number.

qa
Y
p
Ctrl-A
q

Now type 15@a to perform the macro 15 times. You will see:

101 This is an item.
102 This is an item.
103 This is an item.
104 This is an item.
and so on

On Windows, your _vimrc file may source mswin.vim. That script sets Ctrl-A to Select All. If you want to use Ctrl-A in Normal mode to increment a number, you need:

:nunmap <C-A>

Making a list

It's easy to insert a list of ascending numbers, for example:

:0put =range(11,15)

Executing this command (or the equivalent :call append(0,range(11,15))) inserts the following after line 0 (that is, at the start of the buffer):

11
12
13
14
15

Here is a more elaborate example:

:for i in range(1,10) | put ='192.168.0.'.i | endfor

Executing this command inserts the following after the current line:

| 192.168.0.1
| 192.168.0.2
| 192.168.0.3
| 192.168.0.4
| 192.168.0.5
| 192.168.0.6
| 192.168.0.7
| 192.168.0.8
| 192.168.0.9
| 192.168.0.10

References

    * :help CTRL-A
    * :help 'nrformats' 

	33.65 Working with Unicode
    *  One thing you should always do first is check the help. 

    * The following is an example. Modify it to suit your work environment. 

if has("multi_byte")
  if &termencoding == ""
    let &termencoding = &encoding
  endif
  set encoding=utf-8
  setglobal fileencoding=utf-8 bomb
  set fileencodings=ucs-bom,utf-8,latin1
endif

What the above does

    * has("multi_byte") checks if you have the right options compiled-in. If you haven't got what it takes, it's no use trying to use Unicode. 

    * 'termencoding' defines how your keyboard encodes what you type. Here we save the value corresponding to your locale before changing 'encoding' (see below). 

    * 'encoding' sets how vim shall represent characters internally. Utf-8 is necessary for most flavors of Unicode. 

    * 'fileencoding' sets the encoding for a particular file (local to buffer); :setglobal sets the default value. An empty value can also be used: it defaults to same as 'encoding'. Or you may want to set one of the ucs encodings, It might make the same disk file bigger or smaller depending on your particular mix of characters. Also, IIUC, utf-8 is always big-endian (high bit first) while ucs can be big-endian or little-endian, so if you use it, you will probably need to set 'bomb" (see below). 

    * 'bomb' (boolean): if set, vim will put a "byte order mark" (or BOM for short) at the start of Unicode files. This option is irrelevant for non-Unicode files (iso-8859, etc.). This BOM is the codepoint U+FEFF, which is represented on disk as follows:
          o UTF-8: EF BB BF
          o UTF-16be: FE FF
          o UTF-16le: FF FE
          o UTF-32be: 00 00 FE FF
          o UTF-32le: FF FE 00 00 

    That is, the BOM allows an easy determination of which Unicode encoding and which endianness are being used (assuming that a file in UTF-16le won't start with a NULL). 

    * 'fileencodings' defines the heuristic to set 'fileencoding' (local to buffer) when reading an existing file. The first one that matches will be used. Ucs-bom is "ucs with byte-order-mark"; it must not come after utf-8 if you want it to be used. 

Additional remarks

    * In "replace" mode, one utf character (one or more data bytes) replaces one utf character (which need not use the same number of bytes). 

    * In "normal" mode, ga shows the character under the cursor as text, decimal, octal and hex; g8 shows which byte or bytes are used to represent it. 

    * In "insert" or "replace" mode,
          o any character defined on your keyboard can be entered the usual way (even with dead keys if you have them, e.g. French circumflex, German umlaut, etc.);
          o any character which has a "digraph" (there are a huge lot of them, see :dig after setting enc=utf-8) can be entered with a Ctrl-K prefix;
          o any utf character at all can be entered with a Ctrl-V prefix, either <Ctrl-V> u aaaa or <Ctrl-V> U bbbbbbbb, with 0 <= aaaa <= FFFF, or 0 <= bbbbbbbb <= 7FFFFFFF.
          o If you have sourced mswin.vim (which I don't recommend) then <Ctrl-V> has been remapped to the "paste" operation; in this case you need to use <Ctrl-Q> instead. 

    * Gvim will display it properly if you have the fonts for it, provided that you set 'guifont' to some fixed-width font which has the glyphs you want to use (Courier New is OK for French, German, Greek, Russian and more, but I'm not sure about Hebrew or Arabic; its glyphs are of a more "fixed" width than those of, e.g. Lucida Console: the latter can be awkward if you need bold Cyrillic writing). 

    * Until recently, gvim displayed any Unicode codepoint above U+FFFF as a question mark (double-width for CJK). This was fixed by patch 7.1.116 dated 2007 Sep 17 20:39. If you still have an older version, it is strongly recommended that you upgrade to the current release (and a recent patchlevel). 

See also

    * Switching to Unicode in an orderly manner
    * Forcing file encoding at load time
    * Entering special characters
    * :help utf8
    * :help encoding-values
    * :help 'encoding'
    * :help 'fileencoding'
    * :help 'fileencodings'
    * :help 'termencoding'
    * :help 'bomb'
    * :help 'guifont'
    * :help ga
    * :help g8
    * :help digraphs
    * :help i_CTRL-V_digit

	33.66 Search for lines not containing pattern and other helpful searches
Tip 802 created October 5, 2004  complexity intermediate  author Eric Boucher  version 6.0

It can be useful to specify in a search or a substitution what you do not want to have. Here is how to do that:

/^\(\(The_Regular_Expression\)\@!.\)*$

This will find everything but the regular expression you have specified. For example, if we want to find all the lines not containing the word 'foo', simply do:

/^\(\(.*foo.*\)\@!.\)*$

If we want to find a more complex regular expression on multiple lines, like all the lines which do not begin with 'foo' with 'bar' somewhere else and the word 'magic' at the end of the next line, do:

/^\(\(^foo.*bar.*\n.*magic$\)\@!.\)*$

Another thing useful in searches and substitutions is to omit some information. For example, suppose we want to find every 'foo' with 'bar' somewhere else on the line, but we do not want to take the 'bar' part in the search (let's say not highlight it if the hlsearch is set), we can do:

/foo\(.*bar\)\@=
/foo.*\(bar\)\@=
/foo.\{-}\(bar\)\@=

The first one will highlight only 'foo' in lines containing both 'foo' and 'bar'. The second one will highlight 'foo' and everything up to the longest match where 'bar' appears on the line. The third one, will do the same thing, but with the shortest match (non-greedy). So, if there is more than one 'bar' on the same line, the search will stop right before the first occurrence of 'bar'.

We can also do the opposite. Let's say for example finding all the 'foo' with 'bar' some place else without highlighting the 'foo', we can do:

/\(foo.*\)\@<=bar
/\(foo\)\@<=.*bar
/\(foo\)\@<=.\{-}bar

The first one will highlight only 'bar' in lines containing both 'foo' and 'bar'. The second one will highlight everything right after 'foo' up to the last 'bar' on the line. The third one will highlight everything right after 'foo' and up to the first 'bar' (non-greedy).

There is also a way to specify that a part of the regular expression should not be there. As an example, if we want to search for all the lines where there is no word 'foo' preceding the word 'bar', we can do:

/\(foo.*\)\@<!bar

Or, on the other hand, find all the word 'foo' where there is no 'bar' following, we can do:

/foo\(.*bar\)\@!

Now, let's see another kind of search. Imagine we want to find every 'bar' where there is no 'foo' before it. TODO Fix missing text

There is a way with Vim to specify where the beginning of the search pattern should start. As an example, suppose we want to find the lines beginning with 'foo', with the word 'bar' somewhere else and then 'magic', but that we only want to highlight 'magic' and everything up to the end to the line. We can use 'zs' for that like this:

/^foo.*bar.*\zsmagic.*

We can also do the opposite, specify where the search should end. For example, if we want to highlight every 'foo' with 'bar' with 'magic', but not highlight 'magic', we can do:

/foo.*bar.*\zemagic
/foo.*bar.\{-}\zemagic

The last example was non-greedy, that is, matches up to the first occurrence of 'magic' in a line.

Other interesting searches are the beginning of a file. For example to find the first word of a file, we can do (this one needs the +syntax feature when compiled):

/\%^\_.\{-}\<.\{-}\>

Or the first occurrence of a word in a file:

/\%^\_.\{-}\zsVIM

We can also search for something at the end of a file. For example, the last occurrence of 'VIM' in a file (this one is tricky):

/VIM\ze\(\(VIM\)\@!\_.\)*\%$

It finds the word 'VIM' where there is no word 'VIM' after it until the end of the file!
edit References

    * :help /\@=
    * :help /\@!
    * :help /\@<=
    * :help /\@<!
    * :help /\@>
    * :help /\zs
    * :help /\ze
    * :help /\%^
    * :help /\%$ 

	33.67 Tip 1585, file formats 

Vim recognizes three file formats (unix, dos, mac) that determine what line ending characters (line terminators) are removed from each line when a file is read, or are added to each line when a file is written. A file format problem can display ^M characters, or can prevent scripts from running correctly. This tip explains how to avoid problems, and how to convert from one file format to another. Use of the 'fileformat' and 'fileformats' options is also explained. See below if all you want to know is how to remove ^M characters, or how to fix the line endings in the file you are working on.
The line terminator expected for each file format is:

unix	 LF only (each line ends with an LF character).
dos	 CRLF (each line ends with two characters, CR then LF).
mac	 CR only (each line ends with a CR character).
CR is carriage return (return cursor to left margin), which is Ctrl-M or ^M or hex 0D.
LF is linefeed (move cursor down), which is Ctrl-J or ^J or hex 0A. Sometimes, LF is written as NL (newline).

Mac OS version 9 and earlier use mac line endings, while Mac OS X and later use unix line endings.

| Contents 
| 1 File format options
| 2 File format detection
| 3 Converting the current file
| 4 Converting clean files
| 5 Converting mixed files
| 6 Removing unwanted CR or LF characters
| 7 Terminator after last line
| 8 How file format conversion works
| 9 Results of incorrect file format detection
| 10 Vim script problems
| 11 Pitfalls
| 12 Other approaches
| 13 Tools
| 14 See also
| 15 Comments

		33.67.1 File format options Edit
The 'fileformat' option is local to each buffer. It is set by Vim when a file is read, or can be specified in a command telling Vim how to read a file. In addition, the 'fileformat' option can be changed to specify the line endings that will be added to each line when the buffer is written to a file.
The 'fileformats' option is global and specifies which file formats will be tried when Vim reads a file (unless otherwise specified, Vim attempts to automatically detect which file format should be used to read a file). The first file format in 'fileformats' is also used as the default for a new buffer.

The following command displays the fileformat option (abbreviated as ff) for the current buffer, and the fileformats global option (abbreviated as ffs) which determines how Vim reads and writes files: :help 'ff' :help 'ffs'

:set ff? ffs?
This command also shows where each option was last set:
:verbose set ff? ffs?
The fileformats option is often not explicitly set (the defaults are usually adequate). However, the above command may indicate that the option was set in your vimrc because that file probably contains set nocompatible which sets many options.

		33.67.2 File format detection 
The 'fileformats' option ('ffs') has these defaults:
ffs=unix,dos	 Unix based systems
ffs=dos,unix	 Windows and DOS systems
ffs=mac,unix,dos	 Mac OS 9 systems
When a file is read, the order of the items specified in 'ffs' has no effect (for example, ffs=unix,dos has the same effect as ffs=dos,unix when reading). The order is only important when a new buffer is created (if not empty, the first item in 'ffs' is used as the file format for a new buffer; this determines which line endings will be added when the buffer is saved).
Suppose your system has ffs=dos,unix and you open an existing file. Vim will look for both dos and unix line endings, but Vim has a built-in preference for the unix format.

If all lines in the file end with CRLF, the dos file format will be applied, meaning that each CRLF is removed when reading the lines into a buffer, and the buffer 'ff' option will be dos.
If one or more lines end with LF only, the unix file format will be applied, meaning that each LF is removed (but each CR will be present in the buffer, and will display as ^M), and the buffer 'ff' option will be unix.

		33.67.3 Converting the current file 
A common problem is that you open a file and see ^M at the end of many lines. Entering :set ff? will probably show that the file was read as unix: the problem is that some lines actually end with CRLF. To fix this, you need to tell Vim to read the file again using dos file format. When reading as dos, all CRLF line endings, and all LF-only line endings, are removed. Then you need to change the file format for the buffer and save the file. The following procedures will easily handle this situation, but they only work reliably on reasonably recent versions of Vim (7.2.40 or higher).
Convert from dos/unix to unix
To convert the current file from any mixture of CRLF/LF-only line endings, so all lines end with LF only:
:update	 Save any changes.
:e ++ff=dos	 Edit file again, using dos file format ('fileformats' is ignored).[A 1]
:setlocal ff=unix	 This buffer will use LF-only line endings when written.[A 2]
:w	 Write buffer using unix (LF-only) line endings.
In the above, replacing :set ff=unix with :set ff=mac would write the file with mac (CR-only) line endings. Or, if it was a mac file to start with, you would use :e ++ff=mac to read the file correctly, so you could convert the line endings to unix or dos.
Convert from dos/unix to dos
To convert the current file from any mixture of CRLF/LF-only line endings, so all lines end with CRLF only:
:update	 Save any changes.
:e ++ff=dos	 Edit file again, using dos file format ('fileformats' is ignored).[A 1]
:w	 Write buffer using dos (CRLF) line endings.
Notes A
^ a b The :e command reads the current file again, using the ++ff=dos option so the read will omit all CRLF and LF-only line terminators (dos file format). Each ^M at the end of a line should disappear. Some older versions of Vim do not perform this step correctly and the ^M endings are not removed; upgrade Vim to fix. :help :e
^ Use :setlocal (or :setl) to avoid changing the global default.

		33.67.4 Converting clean files 
When working with "clean" files (where every line has the same line ending), Vim's default settings provide reliable file format detection, and conversion is easy.
Suppose you have a collection of files where some are dos (every line ends with CRLF), and others are unix (every line ends with LF only). To convert all the dos files to unix (while not modifying the unix files):[B 1]

:args *.c *.h	 Specify the files to convert.[B 2]
:argdo set ff=unix|update	 For each argument, set unix file format for the buffer, and save the file if needed.[B 3]
Suppose you have a collection of files where some are dos (every line ends with CRLF), and others are unix (every line ends with LF only). To convert all the unix files to dos (while not modifying the dos files):[B 1]
:args *.c *.h	 Specify the files to convert.
:argdo set ff=dos|update	 For each argument, set dos file format for the buffer, and save the file if needed.
If you have opened several files where some are dos and some are unix, you can convert the dos files to unix:[B 1]
:bufdo! set ff=unix|w	 For each buffer, set unix file format, and write the file.
If you have opened several files where some are dos and some are unix, you can convert the unix files to dos:[B 1]
:bufdo! set ff=dos|w	 For each buffer, set dos file format, and write the file.
Notes B
^ a b c d This procedure will fail if a file has a mixture of dos and unix line endings because such files are detected as unix, and the CR characters are retained in the buffer.
^ This example processes all *.c and *.h files in the current directory by setting the argument list to the wanted names. :help :args
^ The :argdo command operates on each file in the argument list. For each file, it sets the buffer to use unix file format. That sets the modified flag for buffers that were detected as dos. The :update command writes the buffer if its modified flag is set.

		33.67.5 Converting mixed files 
When working with "mixed" files (where some lines have one kind of terminator, while other lines have a different terminator), reliable conversion requires more effort. Some methods do not work reliably with older Vim 7.2 versions. The procedures here should work in Vim 7.2 and later.
Convert from dos/unix to unix
To convert from any mixture of CRLF endings and LF-only endings, to LF-only endings:[C 1]
:set hidden	 Allow modified buffers to be hidden.
:set ffs=dos	 Assume dos line endings (CRLF or LF-only) when reading files.
:args *.c *.h	 Specify the files to convert.
:argdo set ff=unix|w	 For each argument, set unix file format for the buffer, and write the file.[C 2]
Convert from dos/unix to dos
To convert from any mixture of CRLF endings and LF-only endings, to CRLF endings:[C 1]
:set ffs=dos	 Assume dos line endings (CRLF or LF-only) when reading files.
:args *.c *.h	 Specify the files to convert.
:argdo w	 Write each file with CRLF line endings.
Notes C
^ a b A defect with this procedure is that all files are modified, even if no change was required. That is, a file is written even if it originally had all lines in the wanted format.
^ The :argdo command operates on each file in the argument list. For each file, it sets the buffer to use unix file format, and writes the file (even if the file has not been marked as modified). An alternative would be to use :argdo w ++ff=unix which will write each file as unix, with the potential problem that the buffer will still be marked as using dos format (so if you later make a change and save it, the file will be written in dos format).

		33.67.6 Removing unwanted CR or LF characters 
First ensure you have read the file with the appropriate file format. For example, use :e ++ff=dos to remove all CRLF and LF-only line terminators, or use :e ++ff=mac if the file uses CR as a line terminator,.
After reading with the correct file format, the buffer may still contain unwanted CR characters. You can search for these with /\r (slash starts a search; backslash r represents CR when searching; press Enter to search).

To delete ^M at line endings, and replace it with a space everywhere else (the c flag will prompt to confirm that you want each replacement, and the e flag prevents an error message if the string is not found):

:%s/\r\+$//e
:%s/\r/ /gce
To process, say, all *.txt files in the current directory:
vim *.txt
:set hidden
:bufdo %s/\r\+$//e
:bufdo %s/\r/ /ge
:xa
To delete every ^M, regardless of where they occur in a line (this is not a good idea if two lines were separated only by a CR because the command joins the lines together):
:%s/\r//g
To replace every CR with LF (when searching, \r matches CR, but when replacing, \r inserts LF; this is not a good idea if LF occurs at the end of a line, because an extra blank line will be created):
:%s/\r/\r/g
If a file uses CR line terminators, it should be read as mac (using :e ++ff=mac). After doing that, you may see unwanted ^J (LF) characters. In a mac buffer, all CR characters will have been removed because CR is the line terminator, and searching for \r will find unwanted LF characters. Use these commands to remove ^J from the start of all lines, and to replace all other ^J with a line break:
%s/^\r//e
%s/\r/\r/ge

		33.67.7 Terminator after last line 
Every line in a text file should have a terminator (for example, a dos file should end with CRLF). When reading a file, Vim accepts the last line as a normal line, even if it has no terminator. Normally, Vim writes a terminator after every line, including the last. For rare occasions, it is possible to save a file with no terminator after the last line:
:set noendofline binary
:w
Some obsolete dos files use Ctrl-Z as an end-of-file character. When reading a dos file, Vim accepts any Ctrl-Z bytes within the file as normal characters (these will appear in the buffer as ^Z), however if Ctrl-Z is the last byte in the file, it is omitted.

		33.67.8 How file format conversion works 
Understanding the principles involved in converting file formats can help avoid mistakes.
Suppose you have some files that use a mixture of CRLF and LF-only line endings (all line terminators use CRLF, or all use LF-only, or there are some of each). These steps are required when converting each file:

Read the file as dos so any text ending with CRLF or LF-only is regarded as a line. These line endings (CRLF and LF) are removed and are not present in the buffer.
If you want to force all line endings to CRLF, write as dos. The :w command is required (not :update or :wa because these only write if the buffer has not been modified, and no modification has occurred).
If you want to force all line endings to LF-only, write as unix.
If you want to force all line endings to CR-only, write as mac.
If all lines in a file end with LF-only, the file can be converted to use CRLF endings by reading as unix and writing as dos. However, if some lines end with CRLF, reading a file as unix will keep each CR in the buffer, and writing the file using any format will write each CR to the file, as if it were a normal character. When writing, line endings are added, so any CR characters that were in the original file, will be written in addition to line endings.
An LF-only file can also be converted to CRLF by reading as dos and writing as dos.

When reading a file as dos, if a CR followed by LF is encountered (CRLF), those two bytes are removed, and the preceding text is regarded as a line. Similarly, if LF is encountered, it is removed, and the preceding text is regarded as a line. However, if a CR is encountered (without a following LF), the CR will be regarded as a normal character and will be copied into the buffer where it will be displayed as ^M (Ctrl-M, the code for CR).


		33.67.9 Results of incorrect file format detection 
Suppose a file contains two lines:
Line 1
Line 2
When reading the file, if Vim does not correctly detect the file format, here is what you will see in the buffer (^J is Ctrl-J or LF; ^M is Ctrl-M or CR).
File has unix line endings; file read with ff=dos:

Line 1
Line 2
File has unix line endings; file read with ff=mac:
Line 1^JLine 2^J
File has dos line endings; file read with ff=unix:
Line 1^M
Line 2^M
File has dos line endings; file read with ff=mac:
Line 1
^JLine 2
^J
File has mac line endings; file read with ff=unix or ff=dos:
Line 1^MLine 2^M

		33.67.10 Vim script problems 
Under Unix, you may find that a Vim script does not work because you have downloaded a script that contains CR characters. Each CR displays as ^M and will cause some scripts to fail.
If you put, say, script.vim in your plugin directory, you may not see any useful error messages about CR characters when using Vim. You can source the script after starting Vim (for example, :source ~/.vim/plugin/script.vim) to see if errors including ^M are shown. To fix, you need to convert the file to unix format.


		33.67.11 Pitfalls 
Some suggestions for working with file formats suffer from pitfalls that are described here.
You are editing a file which you expect to be in unix format, yet you see many ^M characters. The following attempt to convert the file to unix format does not work:

:setlocal ff=unix	 Set unix file format for current buffer.
:w	 Write buffer to file.
The file was probably already detected as unix format, so the :set ff=unix command will do nothing (the problem is that the file uses dos format, but Vim read it as unix because at least one line had an LF-only ending). Furthermore, each ^M represents a CR character that is in the current buffer, and writing the buffer will write that CR to the file (not what you want).
You are editing a file which you expect to be in unix format, yet you see many ^M characters. You perform the following to convert it to unix format, then perform further edits:

:e ++ff=dos	 Read file again in dos format, to accept both CRLF and LF-only line endings.
:w ++ff=unix	 Write buffer to file using LF-only line endings.
...	 Do some edits.
:w	 Save the edits.
The first two steps above are correct, and the file will initially be written in unix format. However, the buffer is still marked as dos format, so the :w will overwrite the file using CRLF line endings. The :e ++ff=dos command tells Vim to read the file again, forcing dos file format. Vim will remove CRLF and LF-only line endings, leaving only the text of each line in the buffer. However, if you are going to edit the file, you need to use these commands:
:e ++ff=dos	 Read file again in dos format.
:setlocal ff=unix	 Mark buffer so LF-only line endings will be used when buffer is written.
...	 Do some edits.
:w	 Save the edits (will use LF-only line endings).
Here is a mistaken attempt to convert certain files from dos to unix format by starting Vim with commands to convert all *.c and *.h files in the current directory:
vim +"argdo setlocal ff=unix" +wqa *.c *.h
This will work if 'fileformats' includes dos and if the files have only CRLF line endings. However, if 'fileformats' includes both dos and unix, and if a file has at least one LF-only line ending, that file will be detected as unix, and any CR in the file will be shown in the buffer as ^M. The :setlocal ff=unix will not flag a unix file as modified, so the +wqa command (same as :xa) will not save that file. If :w is used to write the buffer, nothing useful will be achieved because the CR characters will be written to the file.

		33.67.12 Other approaches 
You may find a discussion of other techniques for handling line endings elsewhere. Some drawbacks of other procedures are mentioned here.
You can specify a file format for a particular file by inserting a modeline in that file. For example, in file my.c, you may put the following comment near the top or bottom of the file in an attempt to maintain dos line endings, regardless of what system is used to edit the file:

/* vim: set ff=dos: */
In general, using a modeline is useless in this context, although it may help if the file format is correctly detected when the file is read, because the next write will save the file in the preferred format specified in the modeline. However, the modeline does not avoid problems, and may make problems worse. For example, if file my.c has one or more lines that end with LF only, and the file is edited on a default Windows system, the file will be detected as having unix format, and the modeline will then change the format to dos, which will set the buffer modified flag. The buffer will display each CR as ^M. If you now save the file, each line will be written with a CRLF ending. However, the ^M characters that were visible in the buffer will be written to the file, so some lines will now end with CRCRLF (two CR characters).
Another unhelpful approach is to hide ^M characters which occur at the end of a line by highlighting them with the Ignore highlight group:

:match Ignore /\r$/
While this may be helpful as a quick workaround when viewing a file, in general, it is a misguided approach because the characters are hidden, but present, which will inevitably cause trouble when editing. In addition, it is much better to correctly handle the problem rather than temporarily hide it.

		33.67.13 Tools 
Several tools are available to convert files from one type of line ending to another. These need to be run at the command line, and are not related to Vim.
On Unix-based systems, the file utility can display what kind of line endings are present in a file. For example, file *.c will report what line terminators (CRLF, CR, LF) are present in each *.c file. The dos2unix utility can convert from dos or mac format to unix, and the unix2dos utility can convert from unix to dos format, optionally while preserving file timestamps.

Many other conversion tools are available. For example, flip can convert files between dos/mac/unix formats, and versions for each platform are available.




	33.68

34. Clever tricks
	(taken from VIM manual chapter 12)
	34.1 Global, tags global operator
	The |:global| command can be combined with the |:move| command to move all the
lines before the first line, resulting in a reversed file.  The command is:

	:global/^/m 0

Abbreviated:

	:g/^/m 0

The "^" regular expression matches the beginning of the line (even if the line
is blank).  The |:move| command moves the matching line to after the mythical
zeroth line, so the current matching line becomes the first line of the file.
As the |:global| command is not confused by the changing line numbering,
|:global| proceeds to match all remaining lines of the file and puts each as
the first.

This also works on a range of lines.  First move to above the first line and
mark it with "mt".  Then move the cursor to the last line in the range and
type:

	:'t+1,.g/^/m 't

		34.1.1 print cerain blocks of text using global

			print three lines, line containing pattern and two above it. 
			. is current line.
			.+/-n offset from current line.
			1 is first line
			$ is last line

			:g/<pattern>/.-2,.p


		34.1.2 Remove unwanted empty lines
http://vim.wikia.com/wiki/VimTip72
Created: June 5, 2001 Complexity: basic Author: Volker Duetsch

Use either of the following commands to delete all empty lines:

:g/^$/d
:v/./d

(v like g on all lines that don't match pattern)

If you want to delete all lines that are empty or that contain only whitespace characters (spaces, tabs), use either of:

:g/^\s*$/d
:v/\S/d

In the second command, v operates on lines that do not match, and \S matches anything that is not a whitespace, and d deletes the flagged lines (all lines that have no characters, or that have only whitespace characters).

You may want to condense multiple blank lines into a single blank line. The following will delete all trailing whitespace from each line, then replace three or more consecutive line endings with two line endings (a single blank line):

:%s/\s\+$//e
:%s/\n\{3,}/\r\r/e

The e substitute flag means that no error is displayed if the pattern is not found. In the second command, \n in the search pattern finds newline, while \r in the replacement inserts a newline.

 Handling IDEOGRAPHIC SPACE

In CJK languages (Chinese, Japanese, Korean), the Unicode character IDEOGRAPHIC SPACE may be used. If you have 'encoding' utf-8 (and do not have the 'l' flag in 'cpoptions'), you can use \u3000 in a search pattern to specify the UTF-16 hex code for IDEOGRAPHIC SPACE. :help /\]

In that case, the following will delete all empty lines, or lines that contain only combinations of space, tab or IDEOGRAPHIC SPACE.

:g/^[ \t\u3000]*$/d

An alternative procedure, which should work in other encodings, would be to enter the CJK space directly into the pattern. That is, you would type the following, but instead of '#' you would enter a CJK space.

:g/^[ \t#]*$/d

If you're not sure how to type the character, position your cursor on an example of the character that you already have in the buffer. Then type yl to yank the character. Then, enter the above :g command, but instead of '#' type Ctrl-R " (Control-R then double-quote, which will insert the contents of the unnamed register containing the yanked character).


		34.1.3 Power of g
http://vim.wikia.com/wiki/VimTip227

The global command :g is very useful. Here are some examples showing the power of :g.

			34.1.3.1 Brief explanation of :g

:[range]g/<pattern>/cmd

The command works in the specified range (default whole file), by executing the Ex command cmd for each line matching <pattern>. Before executing cmd, "." is set to the particular line. An Ex command is one starting with a colon (':').

			34.1.3.2 Some examples

				34.1.3.2.1 Display context (5 lines) for all occurrences of a pattern.

:g/<pattern>/z#.5
" Same, but with some beautification.
:g/<pattern>/z#.5|echo "=========="

				34.1.3.2.2 Delete all lines matching a pattern.

:g/<pattern>/d

				34.1.3.2.3 Delete all blank lines.

:g/^\s*$/d

				34.1.3.2.4 Double space the file ('^' matches each line).

:g/^/pu =\"\n\"
" Alternative (:put inserts nothing from the blackhole register)
:g/^/pu _

				34.1.3.2.5 Copy all lines matching a pattern to end of file.

:g/<pattern>/t$

				34.1.3.2.6 Yank all lines matching a pattern to register 'a'.

0"ay0:g/<pattern>/y A

    Explanation The first 0 moves the cursor to the first character of the line. Then "ay0 yanks into register a the motion 0. Since the cursor is already on the first character, it yanks nothing into register a, clearing it. The y A is an Ex command (:help :y). It yanks the current line into register A (append to register a). 

				34.1.3.2.7 Increment numbers from current line to end-of-document by one (this assumes the default behavior of Ctrl-A to increment a number; you might need :unmap <C-A> on Windows).

:.,$g/^\d/exe "normal! \<C-A>"

				34.1.3.2.8 Comment lines containing "DEBUG" statements in a C program.

g/^\s*DEBUG/exe "norm! I/* \<Esc>A */\<Esc>"

				34.1.3.2.9 Reverse lookup for records (say an address book, with Name at start-of-line and fields after a space).

:g/<pattern>?^\w?p "if only name is interesting
:g/<pattern>/ka|?^\w?p|'ap "if name and the lookup-line is interesting
:g/<pattern>/?^\w?|+,/^[^ ]/-1p "if entire record is interesting

				34.1.3.2.10 Reverse a file (just to show the power of g).

:g/^/m0

				34.1.3.2.11 using normal mode editing with global
example prefix hi to pattern
:g/pattern/norm Ihi

				34.1.3.2.12
			34.1.3.3 Notes Use :v to negate the search pattern. 
			
			Example: Delete all lines not matching pattern:

:v/pattern/d

			34.1.3.4 Some explanation of commands commonly used with :g

following comes after :g/pattern/

:2,8co15  "copy lines 2 through 8 after line 15
:4,15t$   "copy lines 4 through 15 to end of document (t == co)
:-t$      "copy previous line to end of document
:m0       "move current line to the top of the document
:.,+3m$-1 "move current line through current+3 to the last but one line

			34.1.3.5 Commands used with :g are Ex commands, so a help search should be

:help :<help-topic>
:help :k   "example

See :help ex-cmd-index for a list of Ex commands.

			34.1.3.6  Comments

Over a range defined by marks a and b, operate on each line containing pattern. The operation is to replace each pattern2 with string.

:'a,'bg/pattern/s/pattern2/string/gi

Run a macro on matching lines (example assuming a macro recorded as 'q'):

:g/<pattern>/normal @q

To delete (subsequent) duplicate lines from a file:

:g/^\(.*\)\(\r\?\n\1\)\+$/d

To just view the duplicates use:

/^\(.*\)\(\r\?\n\1\)\+$

Compress multiple occurrences of blank lines into a single blank line

:v/./,/./-j

Use :helpgrep '\/,\/' *.txt for an explanation.

I'll break down this incredible collapse-multiple-blank-lines command for everyone, now that I finally figured out how it works.

First, however, I'll rewrite it this way to illustrate that some of those slashes have totally different meaning than others:

:v_._,/./-1join

Note that to delimit expressions like these, just about any symbol can be used in place of the typical slashes... in this case, I used underscores. What we have is an inverse search (:v, same as :g!) for a dot ('.') which means anything except a newline. So this will match empty lines and proceed to execute [command] on each of them.

:v_._[command]

The remaining [command] is this, which is a fancy join command, abbreviated earlier as just 'j'.

,/./-1join

The comma tells it to work with a range of lines:

:help :,

With nothing before the comma, the range begins at the cursor, which is where that first blank line was. The end of the range is specified by a search, which to my knowledge actually does require slashes. The slash and dot mean to search for anything (again), which matches the nearest non-empty line and offsets by {offset} lines.

/./{offset}

The {offset} here is -1, meaning one line above. In the original command we just saw a minus sign, to which vim assumes a count of 1 by default, so it did the same thing as how I've rewritten it, but simply with one character fewer to type.

/./-1

There is a caveat about join that makes this trick possible. If you specify a range of only one line to "join", it will do nothing. For example, this command tells vim to join into one line all lines from 5 to 5, which does nothing:

:5,5join

In this case, any time you have more than one empty line (the case of interest), the join will see a range greater than one and join them together. For all single empty lines, join will leave it alone.

There's no good way use a delete command with :v/./ because you have to delete one line for every empty line you find. Join turned out to be the answer.

This command only merges truly "empty" lines... if any lines contain spaces and/or tabs, they will not be collapsed. To make sure you kill those lines, try this:

:v/^[^ \t]\+$/,/^[^ \t]\+$/-j

Or, to just clean such lines up first,

:%s/^[ \t]\+$//g

	34.2 Count words
	Sometimes you have to write a text with a maximum number of words.  Vim can
count the words for you.
   When the whole file is what you want to count the words in, use this
command:

	g CTRL-G

Do not type a space after the g, this is just used here to make the command
easy to read.
   The output looks like this:

	Col 1 of 0; Line 141 of 157; Word 748 of 774; Byte 4489 of 4976 

You can see on which word you are (748), and the total number of words in the
file (774).

When the text is only part of a file, you could move to the start of the text,
type "g CTRL-G", move to the end of the text, type "g CTRL-G" again, and then
use your brain to compute the difference in the word position.  That's a good
exercise, but there is an easier way.  With Visual mode, select the text you
want to count words in.  Then type g CTRL-G.  The result:

	Selected 5 of 293 Lines; 70 of 1884 Words; 359 of 10928 Bytes 

For other ways to count words, lines and other items, see |count-items|.

		34.2.1 Count patterns, lines, characters, words

Counting words, lines, etc.				*count-items*

To count how often any pattern occurs in the current buffer use the substitute
command and add the 'n' flag to avoid the substitution.  The reported number
of substitutions is the number of items.  Examples: >

	:%s/./&/gn		characters
	:%s/\i\+/&/gn		words
	:%s/^//n		lines
	:%s/the/&/gn		"the" anywhere
	:%s/\<the\>/&/gn	"the" as a word

Example, count how many #define lines are in file
:%s/^#define/n

Note, in my tests the -n flag doesn't work and the replacments takes place, hit 'u' to cancel substitutions

		34.2.2 Some more ways to count lines
:'a,'bs/^// will count the lines between two markers a and b but is there any

add the "n" flag
 :'a,'bs/^//n

do the math (adjust for fenceposting):
 :echo line("'b")-line("'a")
	
yank the lines and look at the "N lines yanked"
message.

'ay'b
		

	34.3 Enter, add, insert multiple characters
	like for example add a line with 20 *.
		34.3.1 Yank
		From command mode do, i * ctrl[ x 20p

		34.3.2 Macro, record
		From command mode do, qa shift+I * ctrl[ q 20@a
			

	34.4 Advanced usage of global operator
		
		34.4.1 Join all consecutive lines

			34.4.1.1 Basic

			The J command joins the current line with the next one. A space is added to the end
of the first line to separate the two pieces that are joined. But suppose you do not
want the spaces.Then you use the gJ command to join lines without spaces . It works just like the J command, except that no space is inserted
between the joined parts.
gJ

			In all file:
			g/^/j  

			In visualy selected text:
			'<,'>g/^/j

			in section between patterns
			/pattern/,/pattern2/g/^/j 
			
			34.4.1.2 Advanced

-> I have to print on paper something like this,

111111111
222222222
333333333
444444444
555555555
666666666
777777777
......
(very long list)

To be environmental friendly, I would like to reformat it as

111111111 222222222 333333333
444444444 555555555 666666666
777777777 ............

Command J should be useful, but I want to know how to automate it to
process to whole file.

-> Set column width, Highlight all the text and use gq to reformat the text.
set textwidth=bla

-> 
>>> if you want to have exactly 3 columns in each line you can use
>>>
>>>   :g/^/normal 3J
>> Or you can skip the normal command:
>>
>>    :g/^/j3
>
> Thank you all for help. I learn three different ways :)
>
> I found a caveat when using gp is that needs set formatoptions-=n to
> work so that for my particular case :g is easier to use.

The two join methods ("norm 3J" and "j3") are for literal "I want
to join 3 lines together".  The "gq" method is a generic "join
lines to fill the width I specify" which may be more or less than
3 lines joined together.  Both have their place, depending on
which type of behavior you want.

As a side note, if you don't want Vim to automatically add spaces
to your joined lines, you can either use "norm 3gJ" or "j!3"


		34.4.2 Useful global operator operations from http://www.rayninfo.co.uk/vimtips.html
		" global command display 
:g/gladiolli/#              : display with line numbers (YOU WANT THIS!)
:g/fred.*joe.*dick/         : display all lines fred,joe & dick
:g/\<fred\>/                : display all lines fred but not freddy
:g/^\s*$/d                  : delete all blank lines
:g!/^dd/d                   : delete lines not containing string
:v/^dd/d                    : delete lines not containing string
:g/fred/,/joe/d             : not line based (very powerfull)
:g/fred/,/joe/j             : Join Lines *N*
:g/-------/.-10,.d          : Delete string & 10 previous lines
:g/{/ ,/}/- s/\n\+/\r/g     : Delete empty lines but only between {...}
:v/\S/d                     : Delete empty lines (both types)
:v/./,/./-j                 : compress empty lines
:g/^$/,/./-j                : compress empty lines
:g/<input\|<form/p          : ORing
:g/^/put_                   : double space file (pu = put)
:g/^/m0                     : Reverse file (m = move)
:'a,'bg/^/m'b               : Reverse a section a to b
:g/^/t.                     : duplicate every line
:g/fred/t$                  : copy(transfer) lines matching fred to EOF
:g/stage/t'a                : copy (transfer) lines matching stage to marker a (cannot use .) *C*
:g/\(^I[^^I]*\)\{80}/d      : delete all lines containing at least 80 tabs
" perform a substitute on every other line
:g/^/ if line('.')%2|s/^/zz / 
" match all lines containing "somestr" between markers a & b
" copy after line containing "otherstr"
:'a,'bg/somestr/co/otherstr/ : co(py) or mo(ve)
" as above but also do a substitution
:'a,'bg/str1/s/str1/&&&/|mo/str2/
:%norm jdd                  : delete every other line
" incrementing numbers (type <c-a> as 5 characters)
:.,$g/^\d/exe "norm! \<c-a>": increment numbers
:'a,'bg/\d\+/norm! ^A       : increment numbers
" storing glob results (note must use APPEND) you need to empty reg a first with qaq. 
"save results to a register/paste buffer
:g/fred/y A                 : append all lines fred to register a
:g/fred/y A | :let @*=@a    : put into paste buffer
:let @a=''|g/Barratt/y A |:let @*=@a
" filter lines to a file (file must already exist)
:'a,'bg/^Error/ . w >> errors.txt
"Note, an alternative way is first yanking to a buffer and then pasting it to file. Like:
:g/pattern/y A
:e filename
"AP //paster buffer A

" duplicate every line in a file wrap a print '' around each duplicate
:g/./yank|put|-1s/'/"/g|s/.*/Print '&'/
" replace string with contents of a file, -d deletes the "mark"
:g/^MARK$/r tmp.txt | -d
" display prettily
:g/<pattern>/z#.5           : display with context
:g/<pattern>/z#.5|echo "=========="  : display beautifully
" Combining g// with normal mode commands
:g/|/norm 2f|r*                      : replace 2nd | with a star
"send output of previous global command to a new window
:nmap <F3>  :redir @a<CR>:g//<CR>:redir END<CR>:new<CR>:put! a<CR><CR>
			

"
		34.4.3 Search (Print) all instances of pattern A not containing pattern B
			Print all lines containing patternA exclusive those that also contain patternB
			???

			The following doesn't work since it only brings the first line matching patternA.
			/patternA/g!/patternB/p

			To search use the idle substitute trick
			/patternA/g!/patternB/s/patternA/&/gc
			and answer no

			34.4.4 Print (get) a list of all line numbers that contain a given pattern
			:g/pattern/.=

    34.5 Edit remote file via ssh (scp)
You can do that via scp like this:

vim scp://user@myserver[:port]//path/to/file.txt
Notice the two slashes // between server and path, which is needed to correctly resolve the absolute path. [:port]is optional.

This is handled by vim's netrw.vim standard plugin. Several other protocols are supported.

my example
e scp://${USER_UNX}@${DS_64_1}//home/de680136/st 

    34.6
35. Regular expressions
	35.1 magic
Some characters in the pattern are taken literally.  They match with the same
character in the text.  When preceded with a backslash however, these
characters get a special meaning.

Other characters have a special meaning without a backslash.  They need to be
preceded with a backslash to match literally.

If a character is taken literally or not depends on the 'magic' option and the
items mentioned next.
							*/\m* */\M*
Use of "\m" makes the pattern after it be interpreted as if 'magic' is set,
ignoring the actual value of the 'magic' option.
Use of "\M" makes the pattern after it be interpreted as if 'nomagic' is used.
							*/\v* */\V*
Use of "\v" means that in the pattern after it all ASCII characters except
'0'-'9', 'a'-'z', 'A'-'Z' and '_' have a special meaning.  "very magic"

Use of "\V" means that in the pattern after it only the backslash has a
special meaning.  "very nomagic"

Examples:
after:	  \v	   \m	    \M	     \V		matches ~
		'magic' 'nomagic'
	  $	   $	    $	     \$		matches end-of-line
	  .	   .	    \.	     \.		matches any character
	  *	   *	    \*	     \*		any number of the previous atom
	  ()	   \(\)     \(\)     \(\)	grouping into an atom
	  |	   \|	    \|	     \|		separating alternatives
	  \a	   \a	    \a	     \a		alphabetic character
	  \\	   \\	    \\	     \\		literal backslash
	  \.	   \.	    .	     .		literal dot
	  \{	   {	    {	     {		literal '{'
	  a	   a	    a	     a		literal 'a'
	
	35.2 Patterns
	  multi ~
     'magic' 'nomagic'	matches of the preceding atom ~
|/star|	*	\*	0 or more	as many as possible
|/\+|	\+	\+	1 or more	as many as possible (*)
|/\=|	\=	\=	0 or 1		as many as possible (*)
|/\?|	\?	\?	0 or 1		as many as possible (*)

|/\{|	\{n,m}	\{n,m}	n to m		as many as possible (*)
	\{n}	\{n}	n		exactly (*)
	\{n,}	\{n,}	at least n	as many as possible (*)
	\{,m}	\{,m}	0 to m		as many as possible (*)
	\{}	\{}	0 or more	as many as possible (same as *) (*)

|/\{-|	\{-n,m}	\{-n,m}	n to m		as few as possible (*)
	\{-n}	\{-n}	n		exactly (*)
	\{-n,}	\{-n,}	at least n	as few as possible (*)
	\{-,m}	\{-,m}	0 to m		as few as possible (*)
	\{-}	\{-}	0 or more	as few as possible (*)

							*E59*
|/\@>|	\@>	\@>	1, like matching a whole pattern (*)
|/\@=|	\@=	\@=	nothing, requires a match |/zero-width| (*)
|/\@!|	\@!	\@!	nothing, requires NO match |/zero-width| (*)
|/\@<=|	\@<=	\@<=	nothing, requires a match behind |/zero-width| (*)
|/\@<!|	\@<!	\@<!	nothing, requires NO match behind |/zero-width| (*)

(*) {not in Vi}


Overview of ordinary atoms.				*/ordinary-atom*
More explanation and examples below, follow the links.

      ordinary atom ~
      magic   nomagic	matches ~
|/^|	^	^	start-of-line (at start of pattern) |/zero-width|
|/\^|	\^	\^	literal '^'
|/\_^|	\_^	\_^	start-of-line (used anywhere) |/zero-width|
|/$|	$	$	end-of-line (at end of pattern) |/zero-width|
|/\$|	\$	\$	literal '$'
|/\_$|	\_$	\_$	end-of-line (used anywhere) |/zero-width|
|/.|	.	\.	any single character (not an end-of-line)
|/\_.|	\_.	\_.	any single character or end-of-line
|/\<|	\<	\<	beginning of a word |/zero-width|
|/\>|	\>	\>	end of a word |/zero-width|
|/\zs|	\zs	\zs	anything, sets start of match
|/\ze|	\ze	\ze	anything, sets end of match
|/\%^|	\%^	\%^	beginning of file |/zero-width|		*E71*
|/\%$|	\%$	\%$	end of file |/zero-width|
|/\%V|	\%V	\%V	inside Visual area |/zero-width|
|/\%#|	\%#	\%#	cursor position |/zero-width|
|/\%'m|	\%'m	\%'m	mark m position |/zero-width|
|/\%l|	\%23l	\%23l	in line 23 |/zero-width|
|/\%c|	\%23c	\%23c	in column 23 |/zero-width|
|/\%v|	\%23v	\%23v	in virtual column 23 |/zero-width|

Character classes {not in Vi}:				*/character-classes*
|/\i|	\i	\i	identifier character (see 'isident' option)
|/\I|	\I	\I	like "\i", but excluding digits
|/\k|	\k	\k	keyword character (see 'iskeyword' option)
|/\K|	\K	\K	like "\k", but excluding digits
|/\f|	\f	\f	file name character (see 'isfname' option)
|/\F|	\F	\F	like "\f", but excluding digits
|/\p|	\p	\p	printable character (see 'isprint' option)
|/\P|	\P	\P	like "\p", but excluding digits
|/\s|	\s	\s	whitespace character: <Space> and <Tab>
|/\S|	\S	\S	non-whitespace character; opposite of \s
|/\d|	\d	\d	digit:				[0-9]
|/\D|	\D	\D	non-digit:			[^0-9]
|/\x|	\x	\x	hex digit:			[0-9A-Fa-f]
|/\X|	\X	\X	non-hex digit:			[^0-9A-Fa-f]
|/\o|	\o	\o	octal digit:			[0-7]
|/\O|	\O	\O	non-octal digit:		[^0-7]
|/\w|	\w	\w	word character:			[0-9A-Za-z_]
|/\W|	\W	\W	non-word character:		[^0-9A-Za-z_]
|/\h|	\h	\h	head of word character:		[A-Za-z_]
|/\H|	\H	\H	non-head of word character:	[^A-Za-z_]
|/\a|	\a	\a	alphabetic character:		[A-Za-z]
|/\A|	\A	\A	non-alphabetic character:	[^A-Za-z]
|/\l|	\l	\l	lowercase character:		[a-z]
|/\L|	\L	\L	non-lowercase character:	[^a-z]
|/\u|	\u	\u	uppercase character:		[A-Z]
|/\U|	\U	\U	non-uppercase character		[^A-Z]
|/\_|	\_x	\_x	where x is any of the characters above: character
			class with end-of-line included
(end of character classes)

|/\e|	\e	\e	<Esc>
|/\t|	\t	\t	<Tab>
|/\r|	\r	\r	<CR>
|/\b|	\b	\b	<BS>
|/\n|	\n	\n	end-of-line
|/~|	~	\~	last given substitute string
|/\1|	\1	\1	same string as matched by first \(\) {not in Vi}
|/\2|	\2	\2	Like "\1", but uses second \(\)
	   ...
|/\9|	\9	\9	Like "\1", but uses ninth \(\)
								*E68*
|/\z1|	\z1	\z1	only for syntax highlighting, see |:syn-ext-match|
	   ...
|/\z1|	\z9	\z9	only for syntax highlighting, see |:syn-ext-match|

	x	x	a character with no special meaning matches itself

|/[]|	[]	\[]	any character specified inside the []
|/\%[]| \%[]	\%[]	a sequence of optionally matched atoms

|/\c|	\c	\c	ignore case
|/\C|	\C	\C	match case
|/\m|	\m	\m	'magic' on for the following chars in the pattern
|/\M|	\M	\M	'magic' off for the following chars in the pattern
|/\v|	\v	\v	the following chars in the pattern are "very magic"
|/\V|	\V	\V	the following chars in the pattern are "very nomagic"
|/\Z|	\Z	\Z	ignore differences in Unicode "combining characters".
			Useful when searching voweled Hebrew or Arabic text.

|/\%d|	\%d	\%d	match specified decimal character (eg \%d123
|/\%x|	\%x	\%x	match specified hex character (eg \%x2a)
|/\%o|	\%o	\%o	match specified octal character (eg \%o040)
|/\%u|	\%u	\%u	match specified multibyte character (eg \%u20ac)
|/\%U|	\%U	\%U	match specified large multibyte character (eg
			\%U12345678)

Example			matches ~
\<\I\i*		or
\<\h\w*
\<[a-zA-Z_][a-zA-Z0-9_]*
			An identifier (e.g., in a C program).

\(\.$\|\. \)		A period followed by <EOL> or a space.

[.!?][])"']*\($\|[ ]\)	A search pattern that finds the end of a sentence,
			with almost the same definition as the ")" command.

"


cat\Z			Both "cat" and "caÌt" ("a" followed by 0x0300)
			Does not match "cÃ t" (character 0x00e0), even
			though it may look the same.
	
	35.3 Filter lines according to pattern.
		:g/pattern/

	35.4 Manual
		h regexp

	35.5 substitution memory anchors
		& the whole matched pattern 	
			example, put all log print code in comment:
			s_^\s\+dzlog_//&_gc
		\L the following characters are made lowercase
		\0 the whole matched pattern 	
		\U the following characters are made uppercase
		\1 the matched pattern in the first pair of \(\) 	
		\E end of \U and \L
		\2 the matched pattern in the second pair of \(\) 	
		\e end of \U and \L
		...  ... 	
		\r split line in two at this point
		\9 the matched pattern in the ninth pair of \(\) 	
		\l next character made lowercase
		~ the previous substitute string 	
		\u next character made uppercase

	35.6 example
	:'<,'>s/.*DZLOG.*,\s\+"/&[acsProcessEapResponse]: /gc  Add to all log prints a prefix with the function name.

	37.7 Greedy vs. Nongreedy
We used \{-} the "few as possible" operator rather than * which is too greedy when there are many such comments in the file.
Some examples:
Greedy search for between 3-5 words with the spaces between them (5 words matched): \(\w\+\s*\)\{3,5}
Non-Greedy search for between 3-5 words with the spaces between them (3 words matched)\(\w\+\s*\)\{-3,5}
Non-Greedy search for any character (match one character): .\{-}
Greedy search for any character (match all characters until newline): .*


"


	37.8 Regular Expressions Reference
The following table assumes that the 'magic' option is on (the default).
Simple Atoms
x The literal character x.
^ Start of line.
$ End of line.
. A single character.
\< Start of a word.
\> End of word.
Range Atoms
[abc] Match either a, b, or c.
[^abc] Match anything except a, b, or c.
[a-z] Match all characters from a through z.
[a-zA-Z] Match all characters from a through z and A through Z.
Character Classes
[:alnum:] Match all letters and digits.
[:alpha:] Match letters.
[:ascii:] Match all ASCII characters.
[:backspace:] Match the backspace character (<BS>).
[:blank:] Match the space and tab characters.
[:cntrl:] Match all control characters.
[:digit:] Match digits.
[:escape:] Matches the escape character (<Esc>).
[:graph:] Match the printable characters, excluding space.
[:lower:] Match lowercase letters.
[:print:] Match printable characters, including space.
[:punct:] Match the punctuation characters.
[:return:] Matches the end-of-line (carriage return, <Enter>, <CR>, <NL>).
[:space:] Match all whitespace characters.
[:tab:] Match the tab character (<Tab>).
[:upper:] Match the uppercase letters.
[:xdigit:] Match hexadecimal digits.
Patterns (Used for Substitutions)
\(pattern\) Mark the pattern for later use.The first set of \(\) marks a
subexpression as \1, the second \2, and so on.
\1 Match the same string that was matched by the first subexpression
in \( and \). For example: \([a-z]\).\1 matches ata,
ehe, tot, and so forth.
\2 Like \1, but uses second subexpression,
\9 Like \1, but uses ninth subexpression.
Special Character Atoms
\a Alphabetic character (A-Za-z).
\A Non-alphabetic character (any character except A-Za-z).
\b <BS>.
\d Digit.
\D Non-digit.
\e <Esc>.
\f Any filename character as defined by the isfname option.
\F Any filename character, but does not include the digits.
\h Head of word character (A-Za-z_).
\H Non-head of word character (any character except A-Za-z_).
\i Any identifier character as defined by the isident option.
\I Any identifier character, but does not include the digits.
\k Any keyword character as defined by the iskeyword option.
\K Any keyword character, but does not include the digits.
\l Lowercase character (a-z).
\L Non-lowercase character (any character except a-z).
\o Octal digit (0-7).
\O Non-octal digit.
\p Any printable character as defined by the isprint option.
\P Any printable character, but does not include the digits.
\r <CR>.
\s Whitespace (<Space> and <Tab>).
\S Non-whitespace character. (Any character except <Space> and
<Tab>).
\t <Tab>.
\u Uppercase character (A-Z).
\U Non-uppercase character (any character except A-Z).
\w Word character (0-9A-Za-z_).
\W Non-word character (any character except 0-9A-Za-z_).
\x Hexadecimal digit (0-9 a-f A-F).
\X Non-hexadecimal digit.
\~ Matches the last given substitute string.
Modifiers
* Match the previous atom 0 or more times.As much as possible.
\+ Match the previous atom 1 or more times.As much as possible.
\= Match the previous atom 0 or 1 times.
\{} Match the previous atom 0 or more times. (Same as the *
modifier.)
\{n}
\{-n} Match the previous atom n times.
\{n,m} Match the previous atom n to m times.
\{n,} Match the previous atom n or more times.
\{,m} Match the previous atom from 0 to m times.
\{-n,m} Match the previous atom n to m times. Match as little as
possible.
\{-n,} Match the previous atom at least n times. Match as little as
possible.
\{-,m} Match the previous atom up to m times. Match as little as
possible.
\{-} Match the previous atom 0 or more times. Match as little as
possible.
str1\|str2 Match str1 or str2.


36. Nice tips
	36.1 edit

		36.1.1   Use % to jump from an open brace to its matching closing brace. Or from a "#if" to the matching "#endif". Actually, % can jump to many different matching items. It is very useful to check if () and {} constructs are balanced properly.
		36.1.2 Use [{ to jump back to the "{" at the start of the current code block.
		36.1.3 Use gd to jump from the use of a variable to its local declaration.
		36.1.4 e, ge, move to end of word, end of previous word.:w!
		36.1.5 H,M,L, move to top, middle, buttom of seen screen.

	36.2 count number of matches of a pattern 
	replace something for itself using "%s/pattern/&/g".
        %s/pattern//gn
        
in region, say lines 100-200
100,200%s/pattern//gn


	36.3 Perform shell action on current buffer (!, %)
	:! action %
	   ! activates non interactive shell
	% represents the current buffer name

	   Note that its possible to break file names of format name.suffix to get prefix name. For example,
	   current buffer xxx.cpp and want to switch to xxx.h (not using Alternate plugin :A) do
		   :e %<.h

	36.4 Pull words into search or command line 
		/<C-R><C-W>         : Pull <cword> onto search/command line
		/<C-R><C-A>         : Pull <CWORD> onto search/command line

	36.5 Search in range (block) 
You can limit the search command "/" to a certain range of lines by including
\%>l items.  For example, to match the word "limit" below line 199 and above
line 300: >
	/\%>199l\%<300llimit
Also see |/\%>l|.

Another way is to use the ":substitute" command with the 'c' flag.  Example: >
   :.,300s/Pattern//gc
This command will search from the cursor position until line 300 for
"Pattern".  At the match, you will be asked to type a character.  Type 'q' to
stop at this match, type 'n' to find the next match.

	A flavor of this is using visualization to search a certain block. Example, search inside the body of a C++ function.
	go to function, type vi{  (stands for Visualize Inside { } block)
	Then :s/Pattern//gc
	Type q to quit and n to next match

	On the same vein, its possible to search between marks:
	" To search for string between mark a and mark b:
	:'a,'bg/^/s/pattern/&/igc  

	Using visualization its possible to either visualize range and search "normally" and the search will be limited to the visualized section. Its also posisble to search in the previously visualized block using: /\%Vpattern

	36.6 substitute using a register

:s/fred/<c-r>a/g            : sub "fred" with contents of register "a"
:s/fred/<c-r>asome_text<c-r>s/g  
:s/fred/\=@a/g              : better alternative as register not displayed

"

35. Compare with EMACS commands.
		Equivalence of VIM and Emacs commands

		Descriptions for VIM commands are quite straightforward, there is not many choice, you have just to type the command. This is not as simple in Emacs, because there is so much possibilities. Here is presented the Emacs commands and their standard key bindings when there are some. But many (like myself) alter the default keybindings to type faster and according to what they do with Emacs.

		This heading includes contributions from David Richfield. Thanks David !
		Conventions

		    * NA
		      Not Applicable, the equivalence doesn't exist.
		    * -
		      I personnaly don't know if there is an equivalence.

		Commands
		Help
		Action	Emacs command	VIM command
		General 	apropos 	:help
		:help <word> then hit CTRL-D to see matching help entries for word
		About commands 	apropos-command : f1 a 	:help <command>
		Describe function 	describe-function : f1 f 	NA
		Describe variable 	describe-variable : f1 v 	:help options
		Describe key briefly 	describe-key-briefly : f1 c 	NA
		Tutorial 	help-with-tutorial : C-h t 	NA
		Open/Close/Save
		Action	Emacs command	VIM command
		Open a file 	find-file : C-x C-f 	:e file-name
		Reload a file from disk 	revert-buffer 	:e
		Close a buffer, a frame 	kill-buffer : C-x k 	:q
		Close all files 	C-x C-c 	:qall
		List all buffers, frame 	C-x C-b 	:files
		Change to next frame 	switch-to-buffer : C-x b 	C-w C-w
		Change to next buffer 	switch-to-buffer : C-x b 	:e#<n>
		Save a buffer, a frame 	save-current-buffer : C-x C-s 	:w
		Save all buffers, frame 	save-some-buffer : C-x s 	:wall or :wa
		Save all files and exit		:xa

		In Emacs, it is better to load all the files in different buffers, but in the same instance of Emacs, if only to load the file faster. Thus, open as many files as you want and then switch from one buffer to another.
		Navigation / Search
		Action	Emacs command	VIM command
		Go to the beginning of a buffer 	beginning-of-buffer : M-< 	1G or gg
		Go to the end of a buffer 	end-of-buffer : M-> 	G
		Search forward 	C-s 	/<string>
		Repeat last search forward 	C-s C-s 	n or /
		Search backward 	C-r 	?<string>
		Repeat last search backward 	C-r C-r 	N or ?
		Find the next brace, bracket, etc. 	Click on the brace, bracket, etc. 	%
		Edition
		Action	Emacs command	VIM command
		Transpose letters 	C-t 	xp
		Transpose words 	M-t 	Go to start of first word, then dwwP. Except at the end of the line, then go to the space in between the words, and type 2dwbhP
		downcase word 	M-l 	With cursor at beginning of word: veu
		Downcase region 	C-x C-l 	Mark region, press u.
		Upcase word 	M-u 	With cursor at beginning of word: veU
		Upcase region 	C-x C-u 	Mark region, press U.
		Syntax highlighting 	M-x toggle-global-lazy-font-lock-mode 	:syntax enable and then :set syntax=>syntax name<
		Region indentation 	M-x indent-according-to-mode 	== (current line)
		<n>== (n, the number of lines)
		=G (till end of file)
		Inserting comments 	indent-for-comment : M-; 	-
		Cut & Paste
		Action	Emacs command	VIM command
		Copy a region, a selection 	copy-region-as-kill 	<n>yy to "yank" or copy n lines, or mark region in visual mode, then press y
		Set mark 	C-Space 	m{a-zA-Z}
		Copy 	M-w 	See above
		Mark the buffer 	C-x h 	ggVG
		String substitution

		To come, work in progress.

		:%s/stringToReplace/newString/gc
		:%s#stringToReplace#newString#gc
		:%s#/home/guest/tmp/comp#/usr/local/#gc
		Undo / Redo
		Action	Emacs command	VIM command
		Undo 	C-_ 	u
		Redo 	Space C-_ 	C-r
		Repeat a command 	M-x z 	.
		Repeat a complex command 	repeat-complex-command : C-x M-: 	.

		More about the undo/redo in Emacs : All the actions are piled up, even the "undo" action. Thus to perform a "redo", one has to undo an "undo". One way to do that is after an "undo" to write a character, like "space", and then perform an "undo".

		Check this out too about macros.
		Spelling check
		Action	Emacs command	VIM command
		Check spelling of a region/file 	ispell-region / ispell-buffer 	

		:w! (hit ENTER):!ispell % (hit ENTER):e! % (hit ENTER)

		Or a bit more complex and powerful, use some macros :
		map <F5> :w!<CR>:!ispell -d francais %<CR>:e! %<CR>
		map <F6> :w!<CR>:!ispell -d american %<CR>:e! %<CR>
		Check spelling of a word 	ispell-word 	NA

38. External programms
	38.1 Make
		39.1.1 set makeprg to work for maven and allow vim working directory to be base of project yet make only current files module
		makeprg=mvnc\ %<
		meaning pass to mvnc the current file name (so that mvnc will compile to corresponding directory in the source code tree)

When mvnc is:
$ which mvnc
/users/yizaq/work/scripts/util/mvnc
$ cat `which mvnc`
#!/usr/bin/bash
CUR_PATH=`echo $1 |  sed -e 's_/src.*__'` #Extract the directory containing the current file
shift
echo "Changing dir to ${CUR_PATH}"
cd ${CUR_PATH}

mvn $@ #Run with any further parameters such as, compile, install, clean etc


		39.1.2 set makeprg to work for clearmake and allow vim working directory to be base of project yet make only current files module

		: set makeprg=my_cmake_t\ %<
[de680136@ctds64-1:Mon Nov 27:~/bin:]$ cat my_*
my_cmake_t

#!/bin/bash

file=$1
fpath=$(readlink -f "$file")
fdir=${fpath%/*}
echo "Executing cmake for file $file, path $fpath,  at dir $fdir"

cd $fdir
clearmake -C gnu test 
cd -


my_cmake
#!/bin/bash

file=$1
fpath=$(readlink -f "$file")
fdir=${fpath%/*}
echo "Executing cmake for file $file, path $fpath,  at dir $fdir"

cd $fdir
clearmake -C gnu test 
cd -

		39.1.3

		38.1.2 :comp[iler][!] {name}


	38.2 Insert date

		38.2.1 Unix
		(only works for Linux/Unix systems)
		:r!date

		38.2.2 Windows, MAC etc
Tip 97 

There are a variety of ways to insert a date/time stamp. You can even have Vim automatically update an existing 'last modified' date/time when writing the file.
Contents

    * 1 Using strftime()
          o 1.1 Some strftime() format string examples
    * 2 Using external tools
    * 3 Automatically update timestamps
    * 4 Updating a DNS SOA serial number
    * 5 See also
    * 6 Comments

			38.2.2.1 edit Using strftime()

Vim's internal strftime() function (:help strftime()) returns a date/time string formatted in a way you specify with a format string. Most systems support strftime(), but some don't. To store the return value of the function, the "= register (:help "=) is used. Here's a bunch of examples:

Press F5 in normal mode or in insert mode to insert the current datestamp: :help i_CTRL-R

:nnoremap <F5> "=strftime("%c")<CR>P
:inoremap <F5> <C-R>=strftime("%c")<CR>

In the example above, the uppercase P at the end inserts before the current character, which allows datestamps inserted at the beginning of an existing line. Other 'put' commands may be more useful for you: :help p :help P :help gp :help gP

Type dts in insert mode to expand to a datestamp: :help abbreviations

:iab dts <C-R>=strftime("%c")<CR>

To replace text with the current date in a substitute command:

:s/text to replace/\=strftime("%c")/

Vary the format string (the "%c" argument), to change how the time and/or date are displayed. For some formats, the result may depend on your locale. :help :language

The specification for the format string itself depends on the implementation of strftime() on your platform. For details, Unix users may refer to the strftime(3) man page, by running 'man 3 strftime'.

"
				38.2.2.1.1 Some strftime() format string examples

Format String              Example output
-------------              --------------
%c                         Thu 27 Sep 2007 07:37:42 AM EDT (depends on locale)
%a %d %b %Y                Thu 27 Sep 2007
%b %d, %Y                  Sep 27, 2007
%d/%m/%y %H:%M:%S          27/09/07 07:36:32
%H:%M:%S                   07:36:44
%T                         07:38:09
%m/%d/%y                   09/27/07
%y%m%d                     070927
%x %X (%Z)                 09/27/2007 08:00:59 AM (EDT)

RFC822 format:
%a, %d %b %Y %H:%M:%S %z   Wed, 29 Aug 2007 02:37:15 -0400

ISO8601/W3C format (http://www.w3.org/TR/NOTE-datetime):
%FT%T%z                    2007-08-29T02:37:13-0400

"
			38.2.2.2 edit Using external tools

On Unix-based systems, enter the following in Vim to read the output from running the date utility, inserting the result after the current line:

:r!date

Under Windows, use:

:r!date /t

"
			38.2.2.3 edit Automatically update timestamps

You might want to automatically update existing time stamps when writing a file.

This is a solution for html implemented as an autocmd which fires when the file is written:

:au BufWritePre *.html exe "norm mz"|exe '%s/\(<!-- DATE -->\).\{-}\d\d:\d\d:\d\d/\1'.strftime("%b %d, %Y %X")."/e"|norm `z

That way a string of the form Aug 13, 2001 14:19:50 is embedded in the text, and it will be updated to the current date and time automatically, every time the file is saved (the ...DATE... stuff is an HTML comment which won't appear in an HTML document).

This is a general solution:

" If buffer modified, update any 'Last modified: ' in the first 20 lines.
" 'Last modified: ' can have up to 10 characters before (they are retained).
" Restores position using s mark.
function! LastModified()
  if &modified
    normal ms
    let n = min([20, line("$")])
    exe '1,' . n . 's#^\(.\{,10}Last modified: \).*#\1' .
          \ strftime('%a %b %d, %Y  %I:%M%p') . '#e'
    normal `s
  endif
endfun
autocmd BufWritePre * call LastModified()

	"
			38.2.2.4 Updating a DNS SOA serial number

When manually editing a zone file for a DNS name server, the serial number in the SOA record needs to be updated. Often a ten-digit number is used, consisting of a timestamp of the form "YYYYMMDD" and a two-digit version number. For example, "2009042101" might represent update number 01 on 21 April 2009.

The following mapping finds the next 10-digit number, and replaces it with a timestamp + "00", and shows the original number in the message line (so you can see what change occurred):

:nnoremap <F8> /\<\d\{10}\><CR>ce<C-r>=strftime("%Y%m%d00")<CR><Esc>:echo @"<CR>

For example, if the date today is 21 April 2009 and the next ten-digit number after the cursor is "2008123002", pressing the F8 key would change the number to "2009042100", and would display "2008123002" in the message line at the bottom of the window.

The command searches for \< (beginning word), followed by 10 digits, followed by \> (end word). The ce changes to the end of the word (deleting the number to the unnamed register), then inserts (Ctrl-r) the value of register = (which evaluates the following expression). 


"

	38.3
39. VIM diff :h vimdiff
	39.1 start diff:

		39.1.1 Start diff from command line
	vimdiff file1 file2 [file3 [file4]]
	vim -d file1 file2 [file3 [file4]]
You may also use "gvimdiff" or "vim -d -g".  The GUI is started then.
You may also use "viewdiff" or "gviewdiff".  Vim starts in readonly mode then.
"r" may be prepended for restricted mode (see |-Z|).

What happens is that Vim opens a window for each of the files.  This is like
using the |-O| argument.  This uses vertical splits.  If you prefer horizontal
splits add the |-o| argument: >

	vimdiff -o file1 file2 [file3]

		39.1.2 Start diff from within VIM session
		:diffsplit filename
		Horizontal diff

		:vert diffsplit filename
		Vertical diff

		 :diffs file2  or :vert diffs

		:diffthis
		Add current window to the existing set of diff-enabled windows. could be used to later diff the file to its earlier state.

	39.2 Diff Navigation, 
		
		41.2.1 Scrolling
		scrolling will move in both windows (same as :set scrollbind)
		to cancel this use :set noscrollbind

		41.2.2 Updating the diffs
		Editing the files in the diff window should also update the diff colors. If not exectute:
		:diffupdate

		39.2.3 Jump to diffs
Two commands can be used to jump to diffs:
								*[c*
	[c		Jump backwards to the previous start of a change.
			When a count is used, do it that many times.
								*]c*
	]c		Jump forwards to the next start of a change.
			When a count is used, do it that many times.

	39.3 Diff copy

							*:diffg* *:diffget*
:[range]diffg[et] [bufspec]
		Modify the current buffer to undo difference with another
		buffer.  If [bufspec] is given, that buffer is used.
		Otherwise this only works if there is one other buffer in diff
		mode.
		See below for [range].

						*:diffpu* *:diffput* *E793*
:[range]diffpu[t] [bufspec]
		Modify another buffer to undo difference with the current
		buffer.  Just like ":diffget" but the other buffer is modified
		instead of the current one.
		When [bufspec] is omitted and there is more than one other
		buffer in diff mode where 'modifiable' is set this fails.
		See below for [range].

							*do*
do		Same as ":diffget" without argument or range.  The "o" stands
		for "obtain" ("dg" can't be used, it could be the start of
		"dgg"!).

							*dp*
dp		Same as ":diffput" without argument or range.

When no [range] is given, the diff at the cursor position or just above it is
affected.  When [range] is used, Vim tries to only put or get the specified
lines.  When there are deleted lines, this may not always be possible.

39. Group Highlighting. match and higlight groups of patterns.
	:h match

	Used to highliht intersting patterns.

	39.1 Usage
	match group /pattern/
	And 2nd and 3rd matches can be defined as well:

	2match group /pattern/  
	3match group /pattern/

	stop matching:
	:match NONE

	39.2 Color groups
		To get a list of defined color groups:
		:so $VIMRUNTIME/syntax/hitest.vim

-> my example on mac terminal vim
:highlight MyGroup ctermbg=red guibg=red
:match MyGroup /"msg":.*}/

->
		To define a new group:
		:highlight MyGroup ctermbg=red guibg=red gctermfg=yellow
guifg=yellow term=bold

	ctermbg : Background color in console
	guibg : Background color in Gvim
	ctermfg : Text color in console
	guifg : Text color in Gvim
	gui : Font formatting in Gvim
	term : Font formatting in console (for example, bold)

	39.3 examples:
		For context files, highlight the ToDo list,
		:match ToDo /^\s\+-\+>.*$/

		For log file, match errors:
		:match ErrorMsg /^Error/

		match single lines XML tags in ACS configuration:
		:match SpellCap /<\/\?\(\w\+\.\?\)\+>/

		Make the KB file look nicer:
		:match StatusLine /^\s*\d\+\..*$/

		In mails, it is a common rule that you do not write lines more than 74 characters
long (a rule that also applies to some older programming languages like for example
Fortran-77). In a case like this, it would be nice if Vim could warn you when you
reached this specific number of characters.
This can simply be done with the following command:
:match ErrorMsg /\%>73v.\+/
Here, every character after the 73rd character will be marked as an error. This match
is a regular expression that when broken down consists of:
\%> : Match after column with the number right after this
73 : The column number
V : Combined with the previous command, this means that the next part is very
magic. See :help magic for more info.
.\+ : Match one or more of any character.

When coding, it is generally a good rule of thumb that tabs are only to be used to
indent code, and not anywhere else. However, for some it can be hard to obey this
rule. Now, with the help of a simple match command this can easily be prevented.
The following command will mark any tabs that are not at the beginning of the line
(indentation) as an error:
:match errorMsg /[^\t]\zs\t\+/
Now you can check if you have forgotten the rule and used the tab key inside the
code. Broken down, the match consists of the following parts:
[^ : Begin a group of characters that should not be matched
\t : The tab-character
] : End of character group.
\zs : A zero-width match that places the 'matching' at the beginning of the line
ignoring any whitespaces
\t\+ : One or more tabs in a row.
This command says: don't match all the tab-characters, match only the ones that are
not used at the beginning of the line (ignoring any whitespaces around it).
If instead of using tabs if you want to use the space character for indentation, then
you can change the command to:
:match errorMsg /[\t]/
This command just says: match all the tab-characters.
	

40. The status line

:set statusline format
where format is a printf-like string (known from C programming) that describes
how the status line should look.
If you look in the Vim help system by typing :help 'statusline', you will see that
the status line can contain a wide variety of pieces of information, some more useful
in your daily work than others.

My status line always contains information about:
Name of the file that I am editing
Format of the file that I am editing (DOS, Unix)
Filetype as recognized by Vim for the current file
ASCII and hex value of the character under the cursor
Position in the document as row and column number
Length of the file (line count)
The following command will turn your status line into a true information bar with
all the above information:
:set statusline=%F%m%r%h%w\ [FORMAT=%{&ff}]\ [TYPE=%Y]\ [ASCII=\%03.3b]\
[HEX=\%02.2B]\ [POS=%04l,%04v][%p%%]\ [LEN=%L]
I have added a '[ ]' around each of the pieces of information, so that it is easier to
distinguish them from each other. This is purely to give a visual effect and can be left
out if necessary.

However, we now see that the status line still shows the old non-informative status
line, as in the default installation. This problem occurs because Vim, by default, does
not show the status line at all. Instead, it just shows the command buffer with a little
bit of information in it. To tell Vim that you would like to have a real status line
shown, you will have to add the following setting to your vimrc file. This command
will make sure that your status line is always shown as the second last line in the
editor window:
:set laststatus=2
You will now see that the command buffer gets a place of its own in the last line of
the editor window. This way there's always room for the status line and you will
always have information about the file right in front of you. The status line does of
course take up some of the editing area, but it is then up to you to decide whether it
should be shown or not. You can always remove it for the rest of the editing session
by executing the following command from within Vim:
:set laststatus=0

41. Work area modifications
	41.1 Mark current line

	The first one is the cursorline command, which basically marks the entire line with,
for example, another background color, without breaking the syntax coloring. To
turn it on, use the following command (highlight horizontaly):
:set cursorline
The color it uses is the one defined in the color group CursorLine. You can change this
to any color or styling you like, for example:
:highlight CursorLine guibg=lightblue ctermbg=lightgray

If you are working with a lot of aligned file content (like tab-separated data), the next
solution for cursor tracking comes in handy (highlight vertically):
:set cursorcolumn
This command marks the current column the cursor is in by, for example, coloring
the entire column in the file.

	41.2 Remove marks
	:set no[cursorLine/cursorcolumn]

42. Spell checking

	42.1 Start spell check
	The command to execute to turn on this helpful spell checker feature is:
:set spell
This turns on the spell checker with the default language (English). If you don't use
English much, and would prefer to use another language in the spell checker, then
there is no problem changing this. Just add the code of the language you would like
to use to the spelllang property, for example:
:set spelllang=de

	42.2 Fix a misspelled word: 
	Whenever you encounter a misspelled word, you can ask Vim to suggest better ways
to spell the word. This is simply done by placing the cursor over the word and then
going into the normal mode (press Esc), and then pressing z=.

Often Vim gives you a long list of alternatives for your misspelled word, but unless
you have spelled the word completely wrong, chances are that the correct word
is within the top 5 of the alternatives. If this is the case, and you don't want to
look through the entire list of alternatives, then you can limit the output with the
following command:
:set spellsuggest=X
Set X to the number of alternative ways of spelling you want Vim to suggest.

43.  Viewing optimization:
:match StatusLine /^\s*\d\+\..*$/

44. "BEST OF VIN TIPS" Advanced usage, Tips by David Rayner
		
	44.1  searching
/joe/e                      : cursor set to End of match
/joe/e+1                    : cursor set to End of match plus 1
/joe/s-2                    : cursor set to Start of match minus 2
/joe/+3                     : find joe move cursor 3 lines down, search and offset 3 lines down
/^joe.*fred.*bill/          : normal
/^[A-J]/                    : search for lines beginning with one or more A-J
/begin\_.*end               : search over possible multiple lines
/fred\_s*joe/               : any whitespace including newline *C*
/fred\|joe                  : Search for FRED OR JOE
/.*fred\&.*joe              : Search for FRED AND JOE in any ORDER!
/\<fred\>/                  : search for fred but not alfred or frederick *C*
/\<\d\d\d\d\>               : Search for exactly 4 digit numbers
/\D\d\d\d\d\D               : Search for exactly 4 digit numbers
/\<\d\{4}\>                 : same thing
/\([^0-9]\|^\)%.*%          : Search for absence of a digit or beginning of line
" finding empty lines
/^\n\{3}                    : find 3 empty lines
" using rexexp memory in a search, find fred then joe then joe then fred
/\(fred\).*\(joe\).*\2.*\1
" Repeating the Regexp (rather than what the Regexp finds)
/^\([^,]*,\)\{8}
" visual searching
:vmap // y/<C-R>"<CR>       : search for visually highlighted text
:vmap <silent> //    y/<C-R>=escape(@", '\\/.*$^~[]')<CR><CR> : with spec chars
" \zs and \ze regex delimiters :h /\zs
/<\zs[^>]*\ze>              : search for tag contents, ignoring chevrons

" zero-width :h /\@=
" \@<= matches with width zero the preceding pattern for match *before* pattern, sometimes its possible to use \zs instead
" It is similar to ?<=pattern in perl. Example:
" \(an\_s\+\)\@<=file	"file" after "an" and white space or an end-of-line
" \(foo\)bar
" Note that its much more efficient to use \zs instead. Example:
" /foo\zsbar 
" \@= matches with width zero the preceding pattern for match *after* pattern
"Example			matches ~
"foo\(bar\)\@=		"foo" in "foobar"
" foobar
" an
 file
/<\@<=[^>]*>\@=             : search for tag contents, ignoring chevrons

/<\@<=\_[^>]*>\@=           : search for tags across possible multiple lines
" Note that the above can be acheived much more efficiently by:
<\zs\_[^>]*\ze>		    : search for tags across possible multiple lines not using ?= multi operators
"<!-- search 
" example
" -->

" searching over multiple lines \_ means including newline \_x the x stands for regex classes. p for example is for printable chars
" \{-} is minimum of 0 or more matches, in contrast to * which is maximum of 0 or more matches.
/<!--\_p\{-}-->                   : search for multiple line comments

/fred\_s*joe/                     : any whitespace including newline *C*
/bugs\(\_.\)*bunny                : bugs followed by bunny anywhere in file
:h \_                             : help

" search for declaration of subroutine/function under cursor
:nmap gx yiw/^\(sub\<bar>function\)\s\+<C-R>"<CR>
" multiple file search
:bufdo /searchstr/                : use :rewind to recommence search

" multiple file search better but cheating, instead of seatch use %- buffer name, s- substitute, &- pattern with itself. meaning the better substitute is used instead of search.
:bufdo %s/searchstr/&/gic   : say n and then a to stop

" How to search for a URL without backslashing
?http://www.vim.org/        : (first) search BACKWARDS!!! clever huh!

" Specify what you are NOT searching for (vowels)
/\c\v([^aeiou]&\a){4}       : search for 4 consecutive consonants, \c ignore case, \v very magic
/\%>20l\%<30lgoat           : Search for goat between lines 20 and 30 *N*

" \{-} is match the preceding pattern 0 or more time, the minimum possible amount, * does the same but matches the maximum amount. \zs if for setting the match at the given point (2nd occorence of home)
/^.\{-}home.\{-}\zshome/e   : match only the 2nd occurence in a line of "home" *N* home. 

:%s/home.\{-}\zshome/alone  : Substitute only the 2nd occurrence of home in any line *N*

" search using contents of a register (buffer)
:/<c-r>a            : search with contents of register "a"
:/\=@a              : better alternative as register not displayed
----------------------------------------

	44.2 substitution
:%s/fred/joe/igc            : general substitute command
:%s//joe/igc                : Substitute what you last searched for *N*
:%s/~/sue/igc               : Substitute your last replacement string for *N*
:%s/\r//g                   : Delete DOS returns ^M

" Is your Text File jumbled onto one line? use following
:%s/\r/\r/g                 : Turn DOS returns ^M into real returns
:%s=  *$==                  : delete end of line blanks
:%s= \+$==                  : Same thing
:%s#\s*\r\?$##              : Clean both trailing spaces AND DOS returns
:%s#\s*\r*$##               : same thing

" deleting empty lines
:%s/^\n\{3}//               : delete blocks of 3 empty lines
:%s/^\n\+/\r/               : compressing empty lines
:%s#<[^>]\+>##g             : delete html tags, 
:%s#<\_.\{-1,}>##g          : delete html tags possibly multi-line (non-greedy)

" IF YOU ONLY WANT TO KNOW ONE THING
:'a,'bg/fred/s/dick/joe/igc : VERY USEFUL
" To search for string between mark a and mark b:
:'a,'bg/^/s/pattern/&/igc  

" duplicating columns
:%s= [^ ]\+$=&&=            : duplicate end column, substitute pattern, one space followed by a run of 1 or more none space chars until end of line (last column) with itself two times (duplicate it).

:%s= \f\+$=&&=              : same thing
:%s= \S\+$=&&               : usually the same

" memory
%s#.*\(tbl_\w\+\).*#\1#     : produce a list of all strings tbl_*   *N*
:s/\(.*\):\(.*\)/\2 : \1/   : reverse fields separated by :
:%s/^\(.*\)\n\1$/\1/        : delete duplicate lines

" non-greedy matching \{-}
:%s/^.\{-}pdf/new.pdf/      : delete to 1st pdf only

" use of optional atom \?
:%s#\<[zy]\?tbl_[a-z_]\+\>#\L&#gc : lowercase with optional leading characters

" over possibly many lines
:%s/<!--\_.\{-}-->//        : delete possibly multi-line comments
:help /\{-}                 : help non-greedy
" substitute using a register
:s/fred/<c-r>a/g            : sub "fred" with contents of register "a"
:s/fred/<c-r>asome_text<c-r>s/g  
:s/fred/\=@a/g              : better alternative as register not displayed
" multiple commands on one line
:%s/\f\+\.gif\>/\r&\r/g | v/\.gif$/d | %s/gif/jpg/
:%s/a/but/gie|:update|:next : then use @: to repeat
" ORing
:%s/suck\|buck/loopy/gc     : ORing (must break pipe)
" Calling a VIM function
:s/__date__/\=strftime("%c")/ : insert datestring
" Working with Columns sub any str1 in col3
:%s:\(\(\w\+\s\+\)\{2}\)str1:\1str2:
" Swapping first & last column (4 columns)
:%s:\(\w\+\)\(.*\s\+\)\(\w\+\)$:\3\2\1:
" filter all form elements into paste register
:redir @*|sil exec 'g#<\(input\|select\|textarea\|/\=form\)\>#p'|redir END
:nmap ,z :redir @*<Bar>sil exec 'g@<\(input\<Bar>select\<Bar>textarea\<Bar>/\=form\)\>@p'<Bar>redir END<CR>
" substitute string in column 30 *N*
:%s/^\(.\{30\}\)xx/\1yy/
" decrement numbers by 3
:%s/\d\+/\=(submatch(0)-3)/
" increment numbers by 6 on certain lines only
:g/loc\|function/s/\d/\=submatch(0)+6/
" better
:%s#txtdev\zs\d#\=submatch(0)+1#g
:h /\zs
" increment only numbers gg\d\d  by 6 (another way)
:%s/\(gg\)\@<=\d\+/\=submatch(0)+6/
:h zero-width
" rename a string with an incrementing number
:let i=10 | 'a,'bg/Abc/s/yy/\=i/ |let i=i+1 # convert yy to 10,11,12 etc
" as above but more precise
:let i=10 | 'a,'bg/Abc/s/xx\zsyy\ze/\=i/ |let i=i+1 # convert xxyy to xx11,xx12,xx13
" find replacement text, put in memory, then use \zs to simplify substitute
:%s/"\([^.]\+\).*\zsxx/\1/
" Pull word under cursor into LHS of a substitute
:nmap <leader>z :%s#\<<c-r>=expand("<cword>")<cr>\>#
" Pull Visually Highlighted text into LHS of a substitute
:vmap <leader>z :<C-U>%s/\<<c-r>*\>/
----------------------------------------
" all following performing similar task, substitute within substitution
" Multiple single character substitution in a portion of line only
:%s,\(all/.*\)\@<=/,_,g     : replace all / with _ AFTER "all/"
" Same thing
:s#all/\zs.*#\=substitute(submatch(0), '/', '_', 'g')#
" Substitute by splitting line, then re-joining
:s#all/#&^M#|s#/#_#g|-j!
" Substitute inside substitute
:%s/.*/\='cp '.submatch(0).' all/'.substitute(submatch(0),'/','_','g')/
----------------------------------------
" global command display 
:g/gladiolli/#              : display with line numbers (YOU WANT THIS!)
:g/fred.*joe.*dick/         : display all lines fred,joe & dick
:g/\<fred\>/                : display all lines fred but not freddy
:g/^\s*$/d                  : delete all blank lines
:g!/^dd/d                   : delete lines not containing string
:v/^dd/d                    : delete lines not containing string
:g/fred/,/joe/d             : not line based (very powerfull)
:g/fred/,/joe/j             : Join Lines *N*
:g/-------/.-10,.d          : Delete string & 10 previous lines
:g/{/ ,/}/- s/\n\+/\r/g     : Delete empty lines but only between {...}
:v/\S/d                     : Delete empty lines (both types)
:v/./,/./-j                 : compress empty lines
:g/^$/,/./-j                : compress empty lines
:g/<input\|<form/p          : ORing
:g/^/put_                   : double space file (pu = put)
:g/^/m0                     : Reverse file (m = move)
:'a,'bg/^/m'b               : Reverse a section a to b
:g/^/t.                     : duplicate every line
:g/fred/t$                  : copy(transfer) lines matching fred to EOF
:g/stage/t'a                : copy (transfer) lines matching stage to marker a (cannot use .) *C*
:g/\(^I[^^I]*\)\{80}/d      : delete all lines containing at least 80 tabs
" perform a substitute on every other line
:g/^/ if line('.')%2|s/^/zz / 
" match all lines containing "somestr" between markers a & b
" copy after line containing "otherstr"
:'a,'bg/somestr/co/otherstr/ : co(py) or mo(ve)
" as above but also do a substitution
:'a,'bg/str1/s/str1/&&&/|mo/str2/
:%norm jdd                  : delete every other line
" incrementing numbers (type <c-a> as 5 characters)
:.,$g/^\d/exe "norm! \<c-a>": increment numbers
:'a,'bg/\d\+/norm! ^A       : increment numbers
" storing glob results (note must use APPEND) you need to empty reg a first with qaq. 
"save results to a register/paste buffer
:g/fred/y A                 : append all lines fred to register a
:g/fred/y A | :let @*=@a    : put into paste buffer
:let @a=''|g/Barratt/y A |:let @*=@a
" filter lines to a file (file must already exist)
:'a,'bg/^Error/ . w >> errors.txt
" duplicate every line in a file wrap a print '' around each duplicate
:g/./yank|put|-1s/'/"/g|s/.*/Print '&'/
" replace string with contents of a file, -d deletes the "mark"
:g/^MARK$/r tmp.txt | -d
" display prettily
:g/<pattern>/z#.5           : display with context
:g/<pattern>/z#.5|echo "=========="  : display beautifully
" Combining g// with normal mode commands
:g/|/norm 2f|r*                      : replace 2nd | with a star
"send output of previous global command to a new window
:nmap <F3>  :redir @a<CR>:g//<CR>:redir END<CR>:new<CR>:put! a<CR><CR>
----------------------------------------
" Global combined with substitute (power editing)
:'a,'bg/fred/s/joe/susan/gic :  can use memory to extend matching
:g/fred/,/joe/s/fred/joe/gic :  non-line based (ultra)
----------------------------------------
" Find fred before beginning search for joe
:/fred/;/joe/-2,/sid/+3s/sally/alley/gIC
----------------------------------------
" create a new file for each line of file eg 1.txt,2.txt,3,txt etc
:g/^/exe ".w ".line(".").".txt"
----------------------------------------
" Absolutely essential
----------------------------------------
* # g* g#           : find word under cursor (<cword>) (forwards/backwards)
%                   : match brackets {}[]()
.                   : repeat last modification 
@:                  : repeat last : command (then @@)
matchit.vim         : % now matches tags <tr><td><script> <?php etc
<C-N><C-P>          : word completion in insert mode
<C-X><C-L>          : Line complete SUPER USEFUL
/<C-R><C-W>         : Pull <cword> onto search/command line
/<C-R><C-A>         : Pull <CWORD> onto search/command line
:set ignorecase     : you nearly always want this
:set smartcase      : overrides ignorecase if uppercase used in search string (cool)
:syntax on          : colour syntax in Perl,HTML,PHP etc
:h regexp<C-D>      : type control-D and get a list all help topics containing
                      regexp (plus use TAB to Step thru list)
----------------------------------------
" MAKE IT EASY TO UPDATE/RELOAD _vimrc
:nmap ,s :source $VIM/_vimrc
:nmap ,v :e $VIM/_vimrc
----------------------------------------
"VISUAL MODE (easy to add other HTML Tags)
:vmap sb "zdi<b><C-R>z</b><ESC>  : wrap <b></b> around VISUALLY selected Text
:vmap st "zdi<?= <C-R>z ?><ESC>  : wrap <?=   ?> around VISUALLY selected Text
----------------------------------------
"vim 7 tabs
vim -p fred.php joe.php             : open files in tabs
:tabe fred.php                      : open fred.php in a new tab
:tab ball                           : tab open files
" vim 7 forcing use of tabs from .vimrc
:nnoremap gf <C-W>gf
:cab      e  tabe

----------------------------------------
" Exploring
:e .                            : file explorer
:Exp(lore)                      : file explorer note capital Ex
:Sex(plore)                     : file explorer in split window
:browse e                       : windows style browser
:ls                             : list of buffers
:cd ..                          : move to parent directory
:args                           : list of files
:args *.php                     : open list of files (you need this!)
:lcd %:p:h                      : change to directory of current file
:autocmd BufEnter * lcd %:p:h   : change to directory of current file automatically (put in _vimrc)
----------------------------------------
" Changing Case
guu                             : lowercase line
gUU                             : uppercase line
Vu                              : lowercase line
VU                              : uppercase line
g~~                             : flip case line
vEU                             : Upper Case Word
vE~                             : Flip Case Word
ggguG                           : lowercase entire file
" Titlise Visually Selected Text (map for .vimrc)
vmap ,c :s/\<\(.\)\(\k*\)\>/\u\1\L\2/g<CR>
" titlise a line
nmap ,t :s/.*/\L&/<bar>:s/\<./\u&/g<cr>  *N*
" Uppercase first letter of sentences
:%s/[.!?]\_s\+\a/\U&\E/g
----------------------------------------
gf                              : open file name under cursor (SUPER)
:nnoremap gF :view <cfile><cr>  : open file under cursor, create if necessary
ga                              : display hex,ascii value of char under cursor
ggVGg?                          : rot13 whole file
ggg?G                           : rot13 whole file (quicker for large file)
:8 | normal VGg?                : rot13 from line 8
:normal 10GVGg?                 : rot13 from line 8
<C-A>,<C-X>                     : increment,decrement number under cursor
                                  win32 users must remap CNTRL-A
<C-R>=5*5                       : insert 25 into text (mini-calculator), works in insert mode only
----------------------------------------
" Make all other tips superfluous
:h 42            : also http://www.google.com/search?q=42
:h holy-grail
:h!
----------------------------------------
" Markers & moving about
'.               : jump to last modification line (SUPER)
`.               : jump to exact spot in last modification line
g;               : cycle thru recent changes (oldest first)
g,               : reverse direction 
:changes
:h changelist    : help for above
<C-O>            : retrace your movements in file (starting from most recent)
<C-I>            : retrace your movements in file (reverse direction)
:ju(mps)         : list of your movements
:help jump-motions
:history         : list of all your commands
:his c           : commandline history
:his s           : search history
q/               : Search history Window (puts you in full edit mode) (exit CTRL-C)
q:               : commandline history Window (puts you in full edit mode) (exit CTRL-C)
:<C-F>           : history Window (exit CTRL-C)
----------------------------------------
" Abbreviations & Maps
" Following 4 maps enable text transfer between VIM sessions
:map   <f7>   :'a,'bw! c:/aaa/x       : save text to file x
:map   <f8>   :r c:/aaa/x             : retrieve text 
:map   <f11>  :.w! c:/aaa/xr<CR>      : store current line
:map   <f12>  :r c:/aaa/xr<CR>        : retrieve current line
:ab php          : list of abbreviations beginning php
:map ,           : list of maps beginning ,
" allow use of F10 for mapping (win32)
set wak=no       : :h winaltkeys
" For use in Maps
<CR>             : carriage Return for maps
<ESC>            : Escape
<LEADER>         : normally \
<BAR>            : | pipe
<BACKSPACE>      : backspace
<SILENT>         : No hanging shell window
#display RGB colour under the cursor eg #445588
:nmap <leader>c :hi Normal guibg=#<c-r>=expand("<cword>")<cr><cr>
map <f2> /price only\\|versus/ :in a map need to backslash the \
# type table,,, to get <table></table>       ### Cool ###
imap ,,, <esc>bdwa<<esc>pa><cr></<esc>pa><esc>kA
----------------------------------------
" Simple PHP debugging display all variables yanked into register a
iab phpdb exit("<hr>Debug <C-R>a  ");
----------------------------------------
" Using a register as a map (preload registers in .vimrc)
:let @m=":'a,'bs/"
:let @s=":%!sort -u"
----------------------------------------
" Useful tricks
"ayy@a           : execute "Vim command" in a text file
yy@"             : same thing using unnamed register
u@.              : execute command JUST typed in
----------------------------------------
" Get output from other commands (requires external programs)
:r!ls            : reads in output of ls
:r !grep "^ebay" file.txt  : grepping in content   *N*
:20,25 !rot13    : rot13 lines 20 to 25   *N*
!!date           : same thing (but replaces/filters current line)
" Sorting with external sort
:%!sort -u       : use an external program to filter content
:'a,'b!sort -u   : use an external program to filter content
!1} sort -u      : sorts paragraph (note normal mode!!)
:g/^$/;,/^$/-1!sort : Sort each block (note the crucial ;)
----------------------------------------
" Multiple Files Management (Essential)
:bn              : goto next buffer
:bp              : goto previous buffer
:wn              : save file and move to next (super)
:wp              : save file and move to previous
:bd              : remove file from buffer list (super)
:bun             : Buffer unload (remove window but not from list)
:badd file.c     : file from buffer list
:b 3             : go to buffer 3
:b main          : go to buffer with main in name eg main.c (ultra)
:sav php.html    : Save current file as php.html and "move" to php.html
:sav! %<.bak     : Save Current file to alternative extension (old way)
:sav! %:r.cfm    : Save Current file to alternative extension
:sav %:s/fred/joe/           : do a substitute on file name
:sav %:s/fred/joe/:r.bak2    : do a substitute on file name & ext.
:!mv % %:r.bak   : rename current file (DOS use Rename or DEL)
:help filename-modifiers
:e!              : return to unmodified file
:w c:/aaa/%      : save file elsewhere
:e #             : edit alternative file (also cntrl-^)
:rew             : return to beginning of edited files list (:args)
:brew            : buffer rewind
:sp fred.txt     : open fred.txt into a split
:sball,:sb       : Split all buffers (super)
:scrollbind      : in each split window
:map   <F5> :ls<CR>:e # : Pressing F5 lists all buffer, just type number
:set hidden      : Allows to change buffer w/o saving current buffer
----------------------------------------
" Quick jumping between splits
map <C-J> <C-W>j<C-W>_
map <C-K> <C-W>k<C-W>_
----------------------------------------
" Recording (BEST TIP of ALL)
qq  # record to q
your complex series of commands
q   # end recording
@q to execute
@@ to Repeat
5@@ to Repeat 5 times
" editing a register/recording
"qp                               :display contents of register q (normal mode)
<ctrl-R>q                         :display contents of register q (insert mode)
" you can now see recording contents, edit as required
"qdd                              :put changed contacts back into q
@q                                :execute recording/register q
" Operating a Recording on a Visual BLOCK
1) define recording/register
qq:s/ to/ from/g^Mq
2) Define Visual BLOCK
V}
3) hit : and the following appears
:'<,'>
4)Complete as follows
:'<,'>norm @q
----------------------------------------
"combining a recording with a map (to end up in command mode)
:nnoremap ] @q:w!<bar>bd
----------------------------------------
" Visual is the newest and usually the most intuitive editing mode
" Visual basics
v                               : enter visual mode
V                               : visual mode whole line
<C-V>                           : enter VISUAL BLOCK mode
gv                              : reselect last visual area (ultra)
o                               : navigate visual area
"*y                             : yank visual area into paste buffer
V%                              : visualise what you match
V}J                             : Join Visual block (great)
V}gJ                            : Join Visual block w/o adding spaces
`[v`]                           : Highlight last insert
----------------------------------------
" Delete first 2 characters of 10 successive lines
0<c-v>10j2ld
----------------------------------------
" how to copy a set of columns using VISUAL BLOCK
" visual block (AKA columnwise selection) (NOT BY ordinary v command)
<C-V> then select "column(s)" with motion commands (win32 <C-Q>)
then c,d,y,r etc
----------------------------------------
" how to overwrite a visual-block of text with another such block
Pick the first block: ctrl-v move "ay
Pick the second block: ctrl-v move c ctrl-o "aP <esc>
----------------------------------------
" text objects :h text_objects                                     *N*
daW                                   : delete contiguous non whitespace
di<   yi<                             : Delete/Yank HTML tag contents
da<   ya<                             : Delete/Yank whole HTML tag
dat   dit                             : Delete HTML tag pair
diB   daB                             : Empty a function {}
das                                   : delete a sentence
----------------------------------------
" _vimrc essentials
:set incsearch : jumps to search word as you type (annoying but excellent)
:set wildignore=*.o,*.obj,*.bak,*.exe : tab complete now ignores these
:set shiftwidth=3                     : for shift/tabbing
:set vb t_vb=".                       : set silent (no beep)
:set browsedir=buffer                 : Maki GUI File Open use current directory
----------------------------------------
" launching Win IE
:nmap ,f :update<CR>:silent !start c:\progra~1\intern~1\iexplore.exe file://%:p<CR>
:nmap ,i :update<CR>: !start c:\progra~1\intern~1\iexplore.exe <cWORD><CR>
----------------------------------------
" FTPing from VIM
cmap ,r  :Nread ftp://209.51.134.122/public_html/index.html
cmap ,w  :Nwrite ftp://209.51.134.122/public_html/index.html
gvim ftp://www.somedomain.com/index.html # uses netrw.vim
----------------------------------------
" appending to registers (use CAPITAL)
" yank 5 lines into "a" then add a further 5
"a5yy
10j
"A5yy
----------------------------------------
[I     : show lines matching word under cursor <cword> (super)
----------------------------------------
" Conventional Shifting/Indenting
:'a,'b>>
" visual shifting (builtin-repeat)
:vnoremap < <gv
:vnoremap > >gv
" Block shifting (magic)
>i{
>a{
" also
>% and <%
----------------------------------------
" Redirection & Paste register *
:redir @*                    : redirect commands to paste buffer
:redir END                   : end redirect
:redir >> out.txt            : redirect to a file
" Working with Paste buffer
"*yy                         : yank to paste
"*p                          : insert from paste buffer
" yank to paste buffer (ex mode)
:'a,'by*                     : Yank range into paste
:%y*                         : Yank whole buffer into paste
:.y*                         : Yank Current line to paster
" filter non-printable characters from the paste buffer
" useful when pasting from some gui application
:nmap <leader>p :let @* = substitute(@*,'[^[:print:]]','','g')<cr>"*p
----------------------------------------
" Re-Formatting text
gq}                          : Format a paragraph
gqap                         : Format a paragraph
ggVGgq                       : Reformat entire file
Vgq                          : current line
" break lines at 70 chars, if possible after a ;
:s/.\{,69\};\s*\|.\{,69\}\s\+/&\r/g
----------------------------------------
" Operate command over multiple files
:argdo %s/foo/bar/e          : operate on all files in :args
:bufdo %s/foo/bar/e
:windo %s/foo/bar/e
:argdo exe '%!sort'|w!       : include an external command
:bufdo exe "normal @q" | w   : perform a recording on open files
:silent bufdo !zip proj.zip %:p   : zip all current files
----------------------------------------
" Command line tricks
gvim -h                    : help
ls | gvim -                : edit a stream!!
cat xx | gvim - -c "v/^\d\d\|^[3-9]/d " : filter a stream
gvim -o file1 file2        : open into a split
" execute one command after opening file
gvim.exe -c "/main" joe.c  : Open joe.c & jump to "main"
" execute multiple command on a single file
vim -c "%s/ABC/DEF/ge | update" file1.c
" execute multiple command on a group of files
vim -c "argdo %s/ABC/DEF/ge | update" *.c
" remove blocks of text from a series of files
vim -c "argdo /begin/+1,/end/-1g/^/d | update" *.c
" Automate editing of a file (Ex commands in convert.vim)
vim -s "convert.vim" file.c
#load VIM without .vimrc and plugins (clean VIM)
gvim -u NONE -U NONE -N
" Access paste buffer contents (put in a script/batch file)
gvim -c 'normal ggdG"*p' c:/aaa/xp
" print paste contents to default printer
gvim -c 's/^/\=@*/|hardcopy!|q!'
" gvim's use of external grep (win32 or *nix)
:grep somestring *.php     : creates a list of all matching files
" use :cn(ext) :cp(rev) to navigate list
:h grep
----------------------------------------
" GVIM Difference Function (Brilliant)
gvim -d file1 file2        : vimdiff (compare differences)
dp                         : "put" difference under cursor to other file
do                         : "get" difference under cursor from other file
----------------------------------------
" Vim traps
In regular expressions you must backslash + (match 1 or more)
In regular expressions you must backslash | (or)
In regular expressions you must backslash ( (group)
In regular expressions you must backslash { (count)
/fred\+/                   : matches fred/freddy but not free
/\(fred\)\{2,3}/           : note what you have to break
----------------------------------------
" \v or very magic (usually) reduces backslashing
/codes\(\n\|\s\)*where  : normal regexp
/\vcodes(\n|\s)*where   : very magic
----------------------------------------
" pulling objects onto command/search line (SUPER)
<C-R><C-W> : pull word under the cursor into a command line or search
<C-R><C-A> : pull WORD under the cursor into a command line or search
<C-R>-                  : pull small register (also insert mode)
<C-R>[0-9a-z]           : pull named registers (also insert mode)
<C-R>%                  : pull file name (also #) (also insert mode)
<C-R>=somevar           : pull contents of a variable (eg :let sray="ray[0-9]")
----------------------------------------
" List your Registers
:reg             : display contents of all registers
:reg a           : display content of register a
:reg 12a         : display content of registers 1,2 & a *N*
"5p              : retrieve 5th "ring" 
"1p....          : retrieve numeric registers one by one
:let @y='yy@"'   : pre-loading registers (put in .vimrc)
qqq              : empty register "q"
qaq              : empty register "a"
----------------------------------------
" manipulating registers
:let @a=@_              : clear register a
:let @a=""              : clear register a
:let @a=@"              : Save unnamed register *N*
:let @*=@a              : copy register a to paste buffer
:let @*=@:              : copy last command to paste buffer
:let @*=@/              : copy last search to paste buffer
:let @*=@%              : copy current filename to paste buffer
----------------------------------------
" help for help (USE TAB)
:h quickref             : VIM Quick Reference Sheet (ultra)
:h tips                 : Vim's own Tips Help
:h visual<C-D><tab>     : obtain  list of all visual help topics
                        : Then use tab to step thru them
:h ctrl<C-D>            : list help of all control keys
:helpg uganda           : grep HELP Files use :cn, :cp to find next
:helpgrep edit.*director: grep help using regexp
:h :r                   : help for :ex command
:h CTRL-R               : normal mode
:h /\r                  : what's \r in a regexp (matches a <CR>)
:h \\zs                 : double up backslash to find \zs in help
:h i_CTRL-R             : help for say <C-R> in insert mode
:h c_CTRL-R             : help for say <C-R> in command mode
:h v_CTRL-V             : visual mode
:h tutor                : VIM Tutor
<C-[>, <C-T>            : Move back & Forth in HELP History
gvim -h                 : VIM Command Line Help
----------------------------------------
" where was an option set
:scriptnames            : list all plugins (scripts), _vimrcs loaded (super)
:verbose set history?   : reveals value of history and where set
:function               : list functions
:func SearchCompl       : List particular function
----------------------------------------
" making your own VIM help
:helptags /vim/vim64/doc  : rebuild all *.txt help files in /doc
:help add-local-help
----------------------------------------
" running file thru an external program (eg php)
map   <f9>   :w<CR>:!c:/php/php.exe %<CR>
map   <f2>   :w<CR>:!perl -c %<CR>
----------------------------------------
" capturing output of current script in a separate buffer
:new | r!perl #                   : opens new buffer,read other buffer
:new! x.out | r!perl #            : same with named file
:new+read!ls
----------------------------------------
" create a new buffer, paste a register "q" into it, then sort new buffer
:new +put q|%!sort
----------------------------------------
" Inserting DOS Carriage Returns
:%s/$/\<C-V><C-M>&/g          :  that's what you type
:%s/$/\<C-Q><C-M>&/g          :  for Win32
:%s/$/\^M&/g                  :  what you'll see where ^M is ONE character
----------------------------------------
" automatically delete trailing Dos-returns,whitespace
autocmd BufRead * silent! %s/[\r \t]\+$//
autocmd BufEnter *.php :%s/[ \t\r]\+$//e
----------------------------------------
" perform an action on a particular file or file type
autocmd VimEnter c:/intranet/note011.txt normal! ggVGg?
autocmd FileType *.pl exec('set fileformats=unix')
----------------------------------------
" Retrieving last command line command for copy & pasting into text
i<c-r>:
" Retrieving last Search Command for copy & pasting into text
i<c-r>/
----------------------------------------
" more completions
<C-X><C-F>                        :insert name of a file in current directory
----------------------------------------
" Substituting a Visual area
" select visual area as usual (:h visual) then type :s/Emacs/Vim/ etc
:'<,'>s/Emacs/Vim/g               : REMEMBER you dont type the '<.'>
gv                                : Re-select the previous visual area (ULTRA)
----------------------------------------
" inserting line number into file
:g/^/exec "s/^/".strpart(line(".")."    ", 0, 4)
:%s/^/\=strpart(line(".")."     ", 0, 5)
:%s/^/\=line('.'). ' '
----------------------------------------
#numbering lines VIM way
:set number                       : show line numbers
:map <F12> :set number!<CR>       : Show linenumbers flip-flop
:%s/^/\=strpart(line('.')."        ",0,&ts)
#numbering lines (need Perl on PC) starting from arbitrary number
:'a,'b!perl -pne 'BEGIN{$a=223} substr($_,2,0)=$a++'
#Produce a list of numbers
#Type in number on line say 223 in an empty file
qqmnYP`n^Aq                       : in recording q repeat with @q
" increment existing numbers to end of file (type <c-a> as 5 characters)
:.,$g/^\d/exe "normal! \<c-a>"
" advanced incrementing
http://vim.sourceforge.net/tip_view.php?tip_id=150
----------------------------------------
" advanced incrementing (really useful)
" put following in _vimrc
let g:I=0
function! INC(increment)
let g:I =g:I + a:increment
return g:I
endfunction
" eg create list starting from 223 incrementing by 5 between markers a,b
:let I=223
:'a,'bs/^/\=INC(5)/
" create a map for INC
cab viminc :let I=223 \| 'a,'bs/$/\=INC(5)/
----------------------------------------
" generate a list of numbers  23-64
o23<ESC>qqYp<C-A>q40@q
----------------------------------------
" editing/moving within current insert (Really useful)
<C-U>                             : delete all entered
<C-W>                             : delete last word
<HOME><END>                       : beginning/end of line
<C-LEFTARROW><C-RIGHTARROW>       : jump one word backwards/forwards
<C-X><C-E>,<C-X><C-Y>             : scroll while staying put in insert
----------------------------------------
#encryption (use with care: DON'T FORGET your KEY)
:X                                : you will be prompted for a key
:h :X
----------------------------------------
" modeline (make a file readonly etc) must be in first/last 5 lines
// vim:noai:ts=2:sw=4:readonly:
" vim:ft=html:                    : says use HTML Syntax highlighting
:h modeline
----------------------------------------
" Creating your own GUI Toolbar entry
amenu  Modeline.Insert\ a\ VIM\ modeline <Esc><Esc>ggOvim:ff=unix ts=4 ss=4<CR>vim60:fdm=marker<esc>gg
----------------------------------------
" A function to save word under cursor to a file
function! SaveWord()
   normal yiw
   exe ':!echo '.@0.' >> word.txt'
endfunction
map ,p :call SaveWord()
----------------------------------------
" function to delete duplicate lines
function! Del()
 if getline(".") == getline(line(".") - 1)
   norm dd
 endif
endfunction

:g/^/ call Del()
----------------------------------------
" Digraphs (non alpha-numerics)
:digraphs                         : display table
:h dig                            : help
i<C-K>e'                          : enters é
i<C-V>233                         : enters é (Unix)
i<C-Q>233                         : enters é (Win32)
ga                                : View hex value of any character
#Deleting non-ascii characters (some invisible)
:%s/[\x00-\x1f\x80-\xff]/ /g      : type this as you see it
:%s/[<C-V>128-<C-V>255]//gi       : where you have to type the Control-V
:%s/[-ÿ]//gi                     : Should see a black square & a dotted y
:%s/[<C-V>128-<C-V>255<C-V>01-<C-V>31]//gi : All pesky non-asciis
:exec "norm /[\x00-\x1f\x80-\xff]/"        : same thing
#Pull a non-ascii character onto search bar
yl/<C-R>"                         :
/[^a-zA-Z0-9_[:space:][:punct:]]  : search for all non-ascii
:%s/[^a-zA-Z0-9_[:space:][:punct:]]//g  :author note, remove all non-ascii chars
:%s/[^a-zA-Z0-9_[:space:][:punct:]]/'/g  :author note, replace all non-ascii chars with '
----------------------------------------
" All file completions grouped (for example main_c.c)
:e main_<tab>                     : tab completes
gf                                : open file under cursor  (normal)
main_<C-X><C-F>                   : include NAME of file in text (insert mode)
----------------------------------------
" Complex Vim
" swap two words
:%s/\<\(on\|off\)\>/\=strpart("offon", 3 * ("off" == submatch(0)), 3)/g
" swap two words
:vnoremap <C-X> <Esc>`.``gvP``P
" Swap word with next word
nmap <silent> gw    "_yiw:s/\(\%#\w\+\)\(\_W\+\)\(\w\+\)/\3\2\1/<cr><c-o><c-l> *N*
----------------------------------------
" Convert Text File to HTML
:runtime! syntax/2html.vim        : convert txt to html
:h 2html
----------------------------------------
" VIM has internal grep
:grep some_keyword *.c            : get list of all c-files containing keyword
:cn                               : go to next occurrence
----------------------------------------
" Force Syntax coloring for a file that has no extension .pl
:set syntax=perl
" Remove syntax coloring (useful for all sorts of reasons)
:set syntax off
" change coloring scheme (any file in ~vim/vim??/colors)
:colorscheme blue
" Force HTML Syntax highlighting by using a modeline
# vim:ft=html:
" Force syntax automatically (for a file with non-standard extension)
au BufRead,BufNewFile */Content.IE?/* setfiletype html
----------------------------------------
:set noma (non modifiable)        : Prevents modifications
:set ro (Read Only)               : Protect a file from unintentional writes
----------------------------------------
" Sessions (Open a set of files)
gvim file1.c file2.c lib/lib.h lib/lib2.h : load files for "session"
:mksession                        : Make a Session file (default Session.vim)
:q
gvim -S Session.vim               : Reload all files
----------------------------------------
#tags (jumping to subroutines/functions)
taglist.vim                       : popular plugin
:Tlist                            : display Tags (list of functions)
<C-]>                             : jump to function under cursor
----------------------------------------
" columnise a csv file for display only as may crop wide columns
:let width = 20
:let fill=' ' | while strlen(fill) < width | let fill=fill.fill | endwhile
:%s/\([^;]*\);\=/\=strpart(submatch(1).fill, 0, width)/ge
:%s/\s\+$//ge
" Highlight a particular csv column (put in .vimrc)
function! CSVH(x)
    execute 'match Keyword /^\([^,]*,\)\{'.a:x.'}\zs[^,]*/'
    execute 'normal ^'.a:x.'f,'
endfunction
command! -nargs=1 Csv :call CSVH(<args>)
" call with
:Csv 5                             : highlight fifth column
----------------------------------------
" folding : hide sections to allow easier comparisons
zf}                               : fold paragraph using motion
v}zf                              : fold paragraph using visual
zf'a                              : fold to mark
zo                                : open fold
zc                                : re-close fold
:help folding
----------------------------------------
" displaying "invisible characters"
:set list
:h listchars
----------------------------------------
" How to paste "normal commands" w/o entering insert mode
:norm qqy$jq
----------------------------------------
" manipulating file names, h filename-modifiers 
:h filename-modifiers             : help
:w %                              : write to current file name
:w %:r.cfm                        : change file extention to .cfm
:!echo %:p                        : full path & file name
:!echo %:p:h                      : full path only
:!echo %:t                        : filename only
:reg %                            : display filename
<C-R>%                            : insert filename (insert mode)
"%p                               : insert filename (normal mode)
/<C-R>%                           : Search for file name in text
----------------------------------------
" delete without destroying default buffer contents
"_d                               : what you've ALWAYS wanted
"_dw                              : eg delete word (use blackhole)
----------------------------------------
" pull full path name into paste buffer for attachment to email etc
nnoremap <F2> :let @*=expand("%:p")<cr> :unix
nnoremap <F2> :let @*=substitute(expand("%:p"), "/", "\\", "g")<cr> :win32
----------------------------------------
" Simple Shell script to rename files w/o leaving vim
$ vim
:r! ls *.c
:%s/\(.*\).c/mv & \1.bla
:w !sh
:q!
----------------------------------------
" count words in a text file
g<C-G>
----------------------------------------
" example of setting your own highlighting
:syn match DoubleSpace "  "
:hi def DoubleSpace guibg=#e0e0e0
" another example
:syn match YourSynType "^.*yourpattern.*$"
:hi YourSynType guibg=skyblue
----------------------------------------
" reproduce previous line word by word
imap ]  @@@<ESC>hhkyWjl?@@@<CR>P/@@@<CR>3s
nmap ] i@@@<ESC>hhkyWjl?@@@<CR>P/@@@<CR>3s
" Programming keys depending on file type
:autocmd bufenter *.tex map <F1> :!latex %<CR>
:autocmd bufenter *.tex map <F2> :!xdvi -hush %<.dvi&<CR>
----------------------------------------
" reading Ms-Word documents, requires antiword
:autocmd BufReadPre *.doc set ro
:autocmd BufReadPre *.doc set hlsearch!
:autocmd BufReadPost *.doc %!antiword "%"
----------------------------------------
" a folding method
vim: filetype=help foldmethod=marker foldmarker=<<<,>>>
A really big section closed with a tag <<< 
--- remember folds can be nested --- 
Closing tag >>> 
----------------------------------------
" Return to last edit position (You want this!) *N*
autocmd BufReadPost *
     \ if line("'\"") > 0 && line("'\"") <= line("$") |
     \   exe "normal! g`\"" |
     \ endif
----------------------------------------
" Just Another Vim Hacker JAVH
vim -c ":%s%s*%Cyrnfr)fcbafbe[Oenz(Zbbyranne%|:%s)[[()])-)Ig|norm Vg?"
----------------------------------------
__END__

	44.3 Best Vim Tips Tip 305

		44.3.1 Absolutely essential

vim.sf.net : Visit frequently
comp.editors : Vim dominated newsgroup
* # g* g# : find word under cursor (forwards/backwards)
% : match brackets {}[]()
matchit.vim : % now matches tags <tr><td><script> etc
<C-N> <C-P> : word completion in insert mode
<C-X><C-L> : Line complete SUPER USEFUL
/<C-R><C-W> : Pull <cword> onto search/command line
:set ignorecase # you nearly always want this
:set ic		# the same
:syntax on : colour syntax in Perl,HTML,PHP etc
:h slash<C-D> : type control-D and get a list all help topics containing slash
    (plus use TAB for Help completion)

        	44.3.2 Make it easy to update/reload _vimrc

:nmap ,s :source $VIM/_vimrc
:nmap ,v :e $VIM/_vimrc

        	44.3.3 VISUAL MODE Mappings

:vmap sb "zdi<b><C-R>z</b><ESC> : wrap <b></b> around VISUALLY selected Text
:vmap st "zdi<?= <C-R>z ?><ESC> : wrap <?= ?> around VISUALLY selected Text

        	44.3.4 Exploring

:Ex : file explorer note capital Ex
\be : builtin buffer explorer
:ls : list of buffers(eg following)
:cd .. : move to parent directory

        	44.3.5 Great


guu : lowercase line
gUU : uppercase line
gf : open file name under cursor (SUPER)
ga : display hex, ascii value of character under cursor
ggg?G : rot13 whole file
CTRL-A,CTRL-X : increment, decrement number under cursor
CTRL-R=5*5 : insert 25 into text

If you use Ctrl-V for paste, you will probably need to unmap CTRL-A first.

        	44.3.6 Easter Eggs

:h 42
:h holy-grail
:help!
:help mapmode-nvo    (comment about :nunmap)
:help UserGettingBored

        	44.3.7 Markers & moving about

'. : jump to last modification line (SUPER)
`. : jump to exact spot in last modification line
<C-O> : retrace your movements in file (old)
<C-I> : retrace your movements in file (new)
:ju(mps) : list of your movements {{help|jump-motions}}
:history : list of all your commands

        	44.3.8 Abbreviations & maps

:map <f7> :'a,'bw! c:/aaa/x
:map <f8> :r c:/aaa/x
:map <f9> :w<CR>:!c:/php/php.exe %<CR>
:map <f11> :.w! c:/aaa/xr<CR>
:map <f12> :r c:/aaa/xr<CR>
:ab php : list of abbreviations beginning php
:map , : list of maps beginning ,

        	44.3.9 For use in Maps

<CR> : carriage Return for maps
<ESC> : Escape
<LEADER> : normally \
<BAR> : | pipe

        	44.3.10 List your Registers

:reg : display contents of all registers
"1p.... : retrieve numeric buffers

        	44.3.11 Execute vim command from buffer contents

"ayy@a : execute "Vim command" in a text file
yy@" : same thing using unnamed register

        	44.3.12 Get output from shell commands

The following uses external programs  sort is just an example (see :help :sort to learn how to use Vim's built-in sort).

:r!ls            : reads in output of ls (use dir on Windows)
:r !grep "^ebay" file.txt  : grepping in content
:20,25 !rot13    : rot13 lines 20 to 25
:r!date           : same thing

" Sorting with external sort
:%!sort -u       : use an external program to filter content
:'a,'b!sort -u   : use an external program to filter content
!1} sort -u      : sorts paragraph (note normal mode!)
:g/^$/;,/^$/-1!sort : sort each block (note the crucial ;)

" Using !!command in normal mode will automatically translate to :.!command
" This will send the current line to the command, and replace the current line
" With command's result
!!date           : Replaces current line with date
!!which 'command': Replace current line with the absolute path to 'command'
!!tr -d abcd     : Delete a,b,c,d from the current line

" You can also use ! on a visual selection. Select an area with one of the visualmode
" commands, and then type !command to pipe the whole selection through command. (Note
" that this is equivalent to :'<,'>!command). For example, after selecting multiple lines
" with visualmode:
!sort            : Filters the lines through the sort program
!grep word       : delete all lines not containing 'word'


        	44.3.13 Multiple Files Management

:wn : write file and move to next (SUPER)
:bd : remove file from buffer list (SUPER)
:sav php.html : Save current file as php.html and "move" to php.html
:sp fred.txt : open fred.txt into a split
:e! : return to unmodified file
:w c:/aaa/% : save file elsewhere
:e # : edit alternative file
:e %
:rew : rewwind to first file in ARGS
:bn : next file
:bp : next file
:brew

        	44.3.14 Recording (BEST TIP of ALL)

qq # record to register q
your commands
q
@q to execute
@@ to Repeat
# editing a register/recording
"qp
<you can now see register contents, edit as required>
"add
@a

        	44.3.15 vimrc essentials

:set incsearch : jumps to search word as you type (annoying but excellent)
:set wildignore=*.o,*.obj,*.bak,*.exe
:set shiftwidth=3

        	44.3.16 Launching programs under Windows

There are a number of options to run applications on the Windows platform.

This causes Windows to launch the program associated with the file extension. It also restores the paste buffer to its original value:

" This command will execute the file, for example, if this is an
" HTML file, it will run:
"     start c:\absolute\filename.html
nnoremap <silent> <C-F6> :let old_reg=@"<CR>:let @"=substitute(expand("%:p"), "/", "\\", "g")<CR>:silent!!cmd /cstart <C-R><C-R>"<CR><CR>:let @"=old_reg<CR>

You can also use Windows rundll32.exe for some options:

" vmap <silent> <C-F5> :<C-U>let old_reg=@"<CR>gvy:silent!!start rundll32.exe url.dll,FileProtocolHandler <C-R><C-R>"<CR><CR>:let @"=old_reg<CR>

Or, for example, you can launch Internet Explorer directly:

:nmap ,f :update<CR>:silent !start c:\progra~1\intern~1\iexplore.exe file://%:p<CR>
:nmap ,i :update<CR>:!start c:\progra~1\intern~1\iexplore.exe <cWORD><CR>
        	44.3.17 FTPing from Vim

cmap ,r :Nread ftp://209.51.134.122/public_html/index.html
cmap ,w :Nwrite ftp://209.51.134.122/public_html/index.html
gvim ftp://209.51.134.122/public_html/index.html

        	44.3.18 Appending to registers (use CAPITAL)

|# yank 5 lines into "a" then add a further 5
|"a5yy
|10j
|"A5yy
|[I : show lines matching word under cursor <cword>

        	44.3.19 Conventional shifting

:'a,'b>>
# visual shifting (builtin-repeat)
:vnoremap < <gv
:vnoremap > >gv

        	44.3.20 Searching

/^joe.*fred.*bill/ : normal
/^[A-J]\+/ : search for lines beginning A-J followed by at leat 1 A-J
/forum\(\_.\)*pent search over possible multiple lines
/fred\_s*joe/i : any whitespace including newline
/fred\|joe : Search for FRED OR JOE

        	44.3.21 Substitution

:%s/fred/joe/igc : general substitute command
:%s/\r//g : Delete DOS returns ^M
Note, this will remove the first carriage return not neccessarily the last. To remove only last do: 

       :%s/\r$//
       (I write the ending slashes explicitly for clarity, and to allow a comment on the same line.)

:'a,'bg/fred/s/dick/joe/gc : VERY USEFUL
:s/\(.*\):\(.*\)/\2 : \1/ : reverse fields separated by :
:%s/^.\{-}pdf/new.pdf/ non greedy matching (ie to first pdf)
:s/fred/<c-r>a/g substitute "fred" with contents of register "a"
:%s/^\(.*\)\n\1/\1$/ delete duplicate lines
# non-greedy matching \{-}
:%s/^.\{-}pdf/new.pdf/
:help /\{-}
:s/fred/<c-r>a/g substitute "fred" with contents of register "a"
# multiple commands
:%s/\f\+\.gif\>/\r&\r/g | v/\.gif$/d | %s/gif/jpg/
:%s/suck\|buck/loopy/gc : ORing
:s/__date__/\=strftime("%c")/ : insert datestring

        	44.3.22 Global command

:g/^\s*$/d :delete all blank lines
:g!/^dd/d : delete lines not containing string
:v/^dd/d : delete lines not containing string
:g/fred/,/joe/d : not line based
:v/./.,/./-1join : compress empty lines
:'a,'b g/^Error/ . w >> errors.txt
Note, file must exist for this to work. Use touch to create an empty file.
:g/cmap\|form/p : ORing

        	44.3.23 Paste register *

:redir @* : redirect commands to paste
:redir END
"*yy : yank to paste
"*p : insert paste buffer

        	44.3.24 Formatting text

gq<CR>
gqap (a is motion p paragraph (visual mode))

        	44.3.25 Operate command over multiple files

:argdo %s/foo/bar/
:bufdo %s/foo/bar/
:windo %s/foo/bar/
:tabdo %s/foo/bar/

        	44.3.26 Command line tricks

gvim -h
ls | gvim - : edit a PIPE!
# vg.ksh (shell script)
# vi all files in directory containing keyword $1 and jump to $1
gvim.exe -c "/$1" $(grep -isl "$1" *) &

        	44.3.27 Comments


 Comments

More tips:

# Vim traps
In regular expressions you must backslash + (match 1 or more)
/fred\+/ : matches fred/freddy but not free
----------------------------------------
# \v or very magic (usually) reduces backslashing
/codes\(\n\|\s\)*where : normal regexp
/\vcodes(\n|\s)*where : very magic
----------------------------------------
# pulling objects onto command/search line (SUPER)
/CTRL-R CTRL-W Pull word under the cursor into a command line or search
(see help c_CTRL-R_CTRL-W for more of the same like:
CTRL-F	the Filename under the cursor
CTRL-P	the Filename under the cursor, expanded with
	'path' as in |gf|
CTRL-A	the WORD under the cursor; see |WORD|
)

/CTRL-R - : pull small register " replace - with buffer name to put any buffer "
/CTRL-R [0-9a-z] : pull named registers
/CTRL-R % : pull file name (also #)
----------------------------------------
# manipulating registers
map <f11> "qyy:let @q=@q."zzz"
----------------------------------------
# help
:h visual<C-D><tab> : obtain list of all visual help topics
    : Then use tab to step thru them
----------------------------------------
# where was an option set
:verbose set history : reveals value of history and where set
----------------------------------------
# running file thru an external program (eg php)
map <f9> :w<CR>:!c:/php/php.exe %<CR>
----------------------------------------
# Inserting Carriage Returns
:%s/nubian/<C-V><C-M>&/g : that's what you type
:%s/nubian/<C-Q><C-M>&/g : for Win32
:%s/nubian/^M&/g : what you'll see where ^M is ONE character
----------------------------------------
# Retrieving last command line command for copy & pasting into text
/<c-r>:
# Retrieving last Search Command for copy & pasting into text
/<c-r>/
----------------------------------------
# doing things over multiple lines \_ means including newline
/<!--\_p\{-}--> : search for multiple line comments
/fred\_s*joe/i : any whitespace including newline
/bugs\(\_.\)*bunny : bugs followed by bunny anywhere in file
:h \_ : help
----------------------------------------
# more completions
<C-X><C-F> :insert name of a file in current directory
----------------------------------------
# help for help
:h visual<C-D><tab> : obtain list of all visual help topics
 : Then use tab to step thru them
:h ctrl<C-D> : list help of all control keys
:h :r : help for :ex command
:h CTRL-R : normal mode
:h \r : what's \r in a regexp
:h i_CTRL-R : help for say <C-R> in insert mode
:h c_CTRL-R : help for say <C-R> in command mode
:h v_CTRL-V : visual mode
----------------------------------------

This is an extension to

# pulling objects onto command/search line

If you use

/CTRL-R CTRL-A

it brings the whole word under the cursor including any special characters.

For eample, if you are in an HTML page and the cursor is under a keyword <table>

/CTRL-R CTRL-A brings /<table>
/CTRL-R CTRL-W brings /table (depending on what the letter under your cursor is ... table or < or >

The Buffer Explorer scripts mentioned above (\be \bs) rely on the very popular Vim script bufexplorer.vim.

Have recently started to appreciate taglist.vim (the most popular Vim script) it really comes into it's own with very long programs containting lots of subroutines/functions as it shows which function/sub you're in etc script#273.

   |1. ftping with vim - great functionality 

for ascii file transfers add the following line to your profile

let g:netrw_ftpmode="ascii"

If you want to delete multiple duplicate lines in a sorted file:

:%s/^\(.*\)\n\(\1\n\)*/\1<NL>/

where <NL> is the character sequence that represents a return in your file type. For Windows, the easiest way to get this is to highlight a return character in another program (open a new notepad, hit return once, select all, and copy) and then use Edit -> Paste in Vim to insert it.

If you want to number the lines in the file try:

:%! nl -ba

I think rot13 of the whole file can be improved by this:

ggg?G

It's so much better to read. Saves one byte over ggVGg? Also, it does not require the overhead of selecting the whole file, especially if the file is huge.

In the message above by junk4todd about getting the <NL> character, you can get the <NL> character by typing:

<Ctrl-V><CR>

The Ctrl-V character is the "escape"-like character and prints the literal of what the next sequence is (it works in vi, and seems to work in vim, too)

I'm confused. I'm a long time vi/vim user. I've often used ctrl-v to enter escaped characters, but I haven't done it in a while. I just tried, and ctrl-v puts me in visual mode block selection... as documented. Well, the docs also make reference to ctrl-v being used as an escape. So which is it? How can ctrl-v be documented to do both things?

Ctrl-V only lets you enter escaped characters when in insert mode.

You need to use Ctrl-Q on default Windows systems.

:g/^\s\+$/d

delete all lines containing whitespace only.

:g/^\s*$/d

delete all empty lines with no whitespace.

:v/^\d/d

delete all lines that don't start with a digit.

I use

:map <F12> :set number!<CR>

like this:

map <F12> :set number!<bar>set number?<CR>

or:

map <F11> :set hls!<bar>set hls?<CR>
map <F10> :set paste!<bar>set paste?<CR>
map <F9> :set wrap!<bar>set wrap?<CR>

so I can see what the current state is (not really usefull for number, but better for hlsearch with nothing highlighted on your current view)

> How delete any line that contains DTE unless that line also contains STX or ETX?

:g/^/call setreg(0,getline(".")) | if (@0=~#"DTE") && !((@0=~#"STX") || (@0=~#"ETX")) | d | endif

Each line is searched for the strings DTE, STX, ETX and according to the given rule only the lines matching the specified condition are deleted. If you replace =~# with =~ then the search will be case insensitive. The vertical bar separates the commands to be entered all in one line First copying the lines in a register and then examining the register avoids calling the getline() function several times. See :help eval.

If you do not want to remove windows key mappings, keep the line

noremap <C-kPlus> <C-A>

in your vimrc.

Then you can use Ctrl-NumPad+ to increment numbers as others do with <C-A>

Another very useful mapping:

noremap <C-J> gj
noremap <C-K> gk

That's really useful when dealing with long lines. It lets you use Control-J and Control-K to move up and down screen lines instead of buffer lines with j and k. Control-J isn't really mapped to anything by default, it's like hitting enter, but Control-K is something to do with digraphs. However, noremap won't remove this ability in insert mode.

Alternatively, you could use:

noremap <Up> gk
noremap <Down> gj

which would map the arrow keys to screen line movement instead of buffer line movement.

To substitute any word (say FILE) by actual filename you can use

:%s/FILE/\=expand("%:t")

Simple but useful, to reopen a file, (revert to the last saved version), anybody can use:

:open

The mappings to wrap visual selections in text clobbers a buffer.

I use:

vmap s( <ESC>`>a)<ESC>`<i(<ESC> : wrap a visual selection in ()


Try this for getting omni-completion working in VIM and elminate the silly CTRL-X, CTRL-O (which didn't work for me anyway), just use the tab key instead. This tip requires the installation of Supertab.vim

let g:SuperTabDefaultCompletionType = "<C-X><C-O>"

	44.4 Flattended most recent version 
" new items marked *N* , corrected items marked *C*
" searching
/joe/e                      : cursor set to End of match
/joe/e+1                    : cursor set to End of match plus 1
/joe/s-2                    : cursor set to Start of match minus 2
/joe/+3                     : find joe move cursor 3 lines down
/^joe.*fred.*bill/          : find joe AND fred AND Bill (Joe at start of line)
/^[A-J]/                    : search for lines beginning with one or more A-J
/begin\_.*end               : search over possible multiple lines
/fred\_s*joe/               : any whitespace including newline *C*
/fred\|joe                  : Search for FRED OR JOE
/.*fred\&.*joe              : Search for FRED AND JOE in any ORDER!
/\<fred\>/                  : search for fred but not alfred or frederick *C*
/\<\d\d\d\d\>               : Search for exactly 4 digit numbers
/\D\d\d\d\d\D               : Search for exactly 4 digit numbers
/\<\d\{4}\>                 : same thing
/\([^0-9]\|^\)%.*%          : Search for absence of a digit or beginning of line
" finding empty lines
/^\n\{3}                    : find 3 empty lines
/^str.*\nstr                : find 2 successive lines starting with str
/\(^str.*\n\)\{2}           : find 2 successive lines starting with str
" using rexexp memory in a search
/\(fred\).*\(joe\).*\2.*\1
" Repeating the Regexp (rather than what the Regexp finds)
/^\([^,]*,\)\{8}
" visual searching
:vmap // y/<C-R>"<CR>       : search for visually highlighted text
:vmap <silent> //    y/<C-R>=escape(@", '\\/.*$^~[]')<CR><CR> : with spec chars
" \zs and \ze regex delimiters :h /\zs
/<\zs[^>]*\ze>              : search for tag contents, ignoring chevrons
" zero-width :h /\@=
/<\@<=[^>]*>\@=             : search for tag contents, ignoring chevrons
/<\@<=\_[^>]*>\@=           : search for tags across possible multiple lines
" searching over multiple lines \_ means including newline
/<!--\_p\{-}-->                   : search for multiple line comments
/fred\_s*joe/                     : any whitespace including newline *C*
/bugs\(\_.\)*bunny                : bugs followed by bunny anywhere in file
:h \_                             : help
" search for declaration of subroutine/function under cursor
:nmap gx yiw/^\(sub\<bar>function\)\s\+<C-R>"<CR>
" multiple file search
:bufdo /searchstr/                : use :rewind to recommence search
" multiple file search better but cheating
:bufdo %s/searchstr/&/gic   : say n and then a to stop
" How to search for a URL without backslashing
?http://www.vim.org/        : (first) search BACKWARDS!!! clever huh!
" Specify what you are NOT searching for (vowels)
/\c\v([^aeiou]&\a){4}       : search for 4 consecutive consonants
/\%>20l\%<30lgoat           : Search for goat between lines 20 and 30 *N*
/^.\{-}home.\{-}\zshome/e   : match only the 2nd occurence in a line of "home" *N*
:%s/home.\{-}\zshome/alone  : Substitute only the occurrence of home in any line *N*
" find str but not on lines containing tongue
^\(.*tongue.*\)\@!.*nose.*$
\v^((tongue)@!.)*nose((tongue)@!.)*$
.*nose.*\&^\%(\%(tongue\)\@!.\)*$ 
:v/tongue/s/nose/&/gic
"----------------------------------------
"substitution
:%s/fred/joe/igc            : general substitute command
:%s//joe/igc                : Substitute what you last searched for *N*
:%s/~/sue/igc               : Substitute your last replacement string *N*
:%s/\r//g                   : Delete DOS returns ^M
" Is your Text File jumbled onto one line? use following
:%s/\r/\r/g                 : Turn DOS returns ^M into real returns
:%s=  *$==                  : delete end of line blanks
:%s= \+$==                  : Same thing
:%s#\s*\r\?$##              : Clean both trailing spaces AND DOS returns
:%s#\s*\r*$##               : same thing
" deleting empty lines
:%s/^\n\{3}//               : delete blocks of 3 empty lines
:%s/^\n\+/\r/               : compressing empty lines
:%s#<[^>]\+>##g             : delete html tags, leave text (non-greedy)
:%s#<\_.\{-1,}>##g          : delete html tags possibly multi-line (non-greedy)
:%s#.*\(\d\+hours\).*#\1#   : Delete all but memorised string (\1) *N*
" VIM Power Substitute
:'a,'bg/fred/s/dick/joe/igc : VERY USEFUL
" duplicating columns
:%s= [^ ]\+$=&&=            : duplicate end column
:%s= \f\+$=&&=              : same thing
:%s= \S\+$=&&               : usually the same
" memory
%s#.*\(tbl_\w\+\).*#\1#     : produce a list of all strings tbl_*   *N*
:s/\(.*\):\(.*\)/\2 : \1/   : reverse fields separated by :
:%s/^\(.*\)\n\1$/\1/        : delete duplicate lines
" non-greedy matching \{-}
:%s/^.\{-}pdf/new.pdf/      : delete to 1st pdf only
" use of optional atom \?
:%s#\<[zy]\?tbl_[a-z_]\+\>#\L&#gc : lowercase with optional leading characters
" over possibly many lines
:%s/<!--\_.\{-}-->//        : delete possibly multi-line comments
:help /\{-}                 : help non-greedy
" substitute using a register
:s/fred/<c-r>a/g            : sub "fred" with contents of register "a"
:s/fred/<c-r>asome_text<c-r>s/g  
:s/fred/\=@a/g              : better alternative as register not displayed
" multiple commands on one line
:%s/\f\+\.gif\>/\r&\r/g | v/\.gif$/d | %s/gif/jpg/
:%s/a/but/gie|:update|:next : then use @: to repeat
" ORing
:%s/goat\|cow/sheep/gc      : ORing (must break pipe)
:%s/\v(.*\n){5}/&\r         : insert a blank line every 5 lines *N*
" Calling a VIM function
:s/__date__/\=strftime("%c")/ : insert datestring
" Working with Columns sub any str1 in col3
:%s:\(\(\w\+\s\+\)\{2}\)str1:\1str2:
" Swapping first & last column (4 columns)
:%s:\(\w\+\)\(.*\s\+\)\(\w\+\)$:\3\2\1:
" filter all form elements into paste register
:redir @*|sil exec 'g#<\(input\|select\|textarea\|/\=form\)\>#p'|redir END
:nmap ,z :redir @*<Bar>sil exec 'g@<\(input\<Bar>select\<Bar>textarea\<Bar>/\=form\)\>@p'<Bar>redir END<CR>
" substitute string in column 30 *N*
:%s/^\(.\{30\}\)xx/\1yy/
" decrement numbers by 3
:%s/\d\+/\=(submatch(0)-3)/
" increment numbers by 6 on certain lines only
:g/loc\|function/s/\d/\=submatch(0)+6/
" better
:%s#txtdev\zs\d#\=submatch(0)+1#g
:h /\zs
" increment only numbers gg\d\d  by 6 (another way)
:%s/\(gg\)\@<=\d\+/\=submatch(0)+6/
:h zero-width
" rename a string with an incrementing number
:let i=10 | 'a,'bg/Abc/s/yy/\=i/ |let i=i+1 # convert yy to 10,11,12 etc
" as above but more precise
:let i=10 | 'a,'bg/Abc/s/xx\zsyy\ze/\=i/ |let i=i+1 # convert xxyy to xx11,xx12,xx13
" find replacement text, put in memory, then use \zs to simplify substitute
:%s/"\([^.]\+\).*\zsxx/\1/
" Pull word under cursor into LHS of a substitute
:nmap <leader>z :%s#\<<c-r>=expand("<cword>")<cr>\>#
" Pull Visually Highlighted text into LHS of a substitute
:vmap <leader>z :<C-U>%s/\<<c-r>*\>/
" substitute singular or plural
:'a,'bs/bucket\(s\)*/bowl\1/gic   *N*
----------------------------------------
" all following performing similar task, substitute within substitution
" Multiple single character substitution in a portion of line only
:%s,\(all/.*\)\@<=/,_,g     : replace all / with _ AFTER "all/"
" Same thing
:s#all/\zs.*#\=substitute(submatch(0), '/', '_', 'g')#
" Substitute by splitting line, then re-joining
:s#all/#&^M#|s#/#_#g|-j!
" Substitute inside substitute
:%s/.*/\='cp '.submatch(0).' all/'.substitute(submatch(0),'/','_','g')/
----------------------------------------
" global command display 
:g/gladiolli/#              : display with line numbers (YOU WANT THIS!)
:g/fred.*joe.*dick/         : display all lines fred,joe & dick
:g/\<fred\>/                : display all lines fred but not freddy
:g/^\s*$/d                  : delete all blank lines
:g!/^dd/d                   : delete lines not containing string
:v/^dd/d                    : delete lines not containing string
:g/fred/,/joe/d             : not line based (very powerfull)
:g/fred/,/joe/j             : Join Lines *N*
:g/-------/.-10,.d          : Delete string & 10 previous lines
:g/{/ ,/}/- s/\n\+/\r/g     : Delete empty lines but only between {...}
:v/\S/d                     : Delete empty lines (both types)
:v/./,/./-j                 : compress empty lines
:g/^$/,/./-j                : compress empty lines
:g/<input\|<form/p          : ORing
:g/^/put_                   : double space file (pu = put)
:g/^/m0                     : Reverse file (m = move)
:'a,'bg/^/m'b               : Reverse a section a to b
:g/^/t.                     : duplicate every line
:g/fred/t$                  : copy(transfer) lines matching fred to EOF
:g/stage/t'a                : copy (transfer) lines matching stage to marker a (cannot use .) *C*
:g/^Chapter/t.|s/./-/g      : Automatically underline selecting headings *N*
:g/\(^I[^^I]*\)\{80}/d      : delete all lines containing at least 80 tabs
" perform a substitute on every other line
:g/^/ if line('.')%2|s/^/zz / 
" match all lines containing "somestr" between markers a & b
" copy after line containing "otherstr"
:'a,'bg/somestr/co/otherstr/ : co(py) or mo(ve)
" as above but also do a substitution
:'a,'bg/str1/s/str1/&&&/|mo/str2/
:%norm jdd                  : delete every other line
" incrementing numbers (type <c-a> as 5 characters)
:.,$g/^\d/exe "norm! \<c-a>": increment numbers
:'a,'bg/\d\+/norm! ^A       : increment numbers
" storing glob results (note must use APPEND) you need to empty reg a first with qaq. 
"save results to a register/paste buffer
:g/fred/y A                 : append all lines fred to register a
:g/fred/y A | :let @*=@a    : put into paste buffer
:let @a=''|g/Barratt/y A |:let @*=@a
" filter lines to a file (file must already exist)
:'a,'bg/^Error/ . w >> errors.txt
" duplicate every line in a file wrap a print '' around each duplicate
:g/./yank|put|-1s/'/"/g|s/.*/Print '&'/
" replace string with contents of a file, -d deletes the "mark"
:g/^MARK$/r tmp.txt | -d
" display prettily
:g/<pattern>/z#.5           : display with context
:g/<pattern>/z#.5|echo "=========="  : display beautifully
" Combining g// with normal mode commands
:g/|/norm 2f|r*                      : replace 2nd | with a star
"send output of previous global command to a new window
:nmap <F3>  :redir @a<CR>:g//<CR>:redir END<CR>:new<CR>:put! a<CR><CR>
"----------------------------------------
" Global combined with substitute (power editing)
:'a,'bg/fred/s/joe/susan/gic :  can use memory to extend matching
:/fred/,/joe/s/fred/joe/gic :  non-line based (ultra)
:/biz/,/any/g/article/s/wheel/bucket/gic:  non-line based *N*
----------------------------------------
" Find fred before beginning search for joe
:/fred/;/joe/-2,/sid/+3s/sally/alley/gIC
"----------------------------------------
" create a new file for each line of file eg 1.txt,2.txt,3,txt etc
:g/^/exe ".w ".line(".").".txt"
"----------------------------------------
" chain an external command
:.g/^/ exe ".!sed 's/N/X/'" | s/I/Q/    *N*
"----------------------------------------
" Operate until string found *N*
d/fred/                                :delete until fred
y/fred/                                :yank until fred
c/fred/e                               :change until fred end
"----------------------------------------
" Summary of editing repeats *N*
.      last edit (magic dot)
:&     last substitute
:%&    last substitute every line
:%&gic last substitute every line confirm
g%     normal mode repeat last substitute
g&     last substitute on all lines
@@     last recording
@:     last command-mode command
:!!    last :! command
:~     last substitute
:help repeating
----------------------------------------
" Summary of repeated searches
;      last f, t, F or T
,      last f, t, F or T in opposite direction
n      last / or ? search
N      last / or ? search in opposite direction
----------------------------------------
" Absolutely essential
----------------------------------------
* # g* g#           : find word under cursor (<cword>) (forwards/backwards)
%                   : match brackets {}[]()
.                   : repeat last modification 
@:                  : repeat last : command (then @@)
matchit.vim         : % now matches tags <tr><td><script> <?php etc
<C-N><C-P>          : word completion in insert mode
<C-X><C-L>          : Line complete SUPER USEFUL
/<C-R><C-W>         : Pull <cword> onto search/command line
/<C-R><C-A>         : Pull <CWORD> onto search/command line
:set ignorecase     : you nearly always want this
:set smartcase      : overrides ignorecase if uppercase used in search string (cool)
:syntax on          : colour syntax in Perl,HTML,PHP etc
:h regexp<C-D>      : type control-D and get a list all help topics containing
                      regexp (plus use TAB to Step thru list)
----------------------------------------
" MAKE IT EASY TO UPDATE/RELOAD _vimrc
:nmap ,s :source $VIM/_vimrc
:nmap ,v :e $VIM/_vimrc
" How to have a variant in your .vimrc for different PCs *N*
if $COMPUTERNAME == "NEWPC"
ab mypc vista
else
ab mypc dell25
endif
----------------------------------------
"VISUAL MODE (easy to add other HTML Tags)
:vmap sb "zdi<b><C-R>z</b><ESC>  : wrap <b></b> around VISUALLY selected Text
:vmap st "zdi<?= <C-R>z ?><ESC>  : wrap <?=   ?> around VISUALLY selected Text
----------------------------------------
"vim 7 tabs
vim -p fred.php joe.php             : open files in tabs
:tabe fred.php                      : open fred.php in a new tab
:tab ball                           : tab open files
" vim 7 forcing use of tabs from .vimrc
:nnoremap gf <C-W>gf
:cab      e  tabe
:tab sball                           : retab all files in buffer (repair) *N*
----------------------------------------
" Exploring
:e .                            : file explorer
:Exp(lore)                      : file explorer note capital Ex
:Sex(plore)                     : file explorer in split window
:browse e                       : windows style browser
:ls                             : list of buffers
:cd ..                          : move to parent directory
:args                           : list of files
:args *.php                     : open list of files (you need this!)
:lcd %:p:h                      : change to directory of current file
:autocmd BufEnter * lcd %:p:h   : change to directory of current file automatically (put in _vimrc)
----------------------------------------
" Changing Case
guu                             : lowercase line
gUU                             : uppercase line
Vu                              : lowercase line
VU                              : uppercase line
g~~                             : flip case line
vEU                             : Upper Case Word
vE~                             : Flip Case Word
ggguG                           : lowercase entire file
" Titlise Visually Selected Text (map for .vimrc)
vmap ,c :s/\<\(.\)\(\k*\)\>/\u\1\L\2/g<CR>
" titlise a line
nmap ,t :s/.*/\L&/<bar>:s/\<./\u&/g<cr>  *N*
" Uppercase first letter of sentences
:%s/[.!?]\_s\+\a/\U&\E/g
----------------------------------------
gf                              : open file name under cursor (SUPER)
:nnoremap gF :view <cfile><cr>  : open file under cursor, create if necessary
ga                              : display hex,ascii value of char under cursor
ggVGg?                          : rot13 whole file
ggg?G                           : rot13 whole file (quicker for large file)
:8 | normal VGg?                : rot13 from line 8
:normal 10GVGg?                 : rot13 from line 8
<C-A>,<C-X>                     : increment,decrement number under cursor
                                  win32 users must remap CNTRL-A
<C-R>=5*5                       : insert 25 into text (mini-calculator)
----------------------------------------
" Make all other tips superfluous
:h 42            : also http://www.google.com/search?q=42
:h holy-grail
:h!
----------------------------------------
" Markers & moving about
'.               : jump to last modification line (SUPER)
`.               : jump to exact spot in last modification line
g;               : cycle thru recent changes (oldest first)
g,               : reverse direction 
:changes
:h changelist    : help for above
<C-O>            : retrace your movements in file (starting from most recent)
<C-I>            : retrace your movements in file (reverse direction)
:ju(mps)         : list of your movements
:help jump-motions
:history         : list of all your commands
:his c           : commandline history
:his s           : search history
q/               : Search history Window (puts you in full edit mode) (exit CTRL-C)
q:               : commandline history Window (puts you in full edit mode) (exit CTRL-C)
:<C-F>           : history Window (exit CTRL-C)
----------------------------------------
" Abbreviations & Maps
" Following 4 maps enable text transfer between VIM sessions
:map   <f7>   :'a,'bw! c:/aaa/x       : save text to file x
:map   <f8>   :r c:/aaa/x             : retrieve text 
:map   <f11>  :.w! c:/aaa/xr<CR>      : store current line
:map   <f12>  :r c:/aaa/xr<CR>        : retrieve current line
:ab php          : list of abbreviations beginning php
:map ,           : list of maps beginning ,
" allow use of F10 for mapping (win32)
set wak=no       : :h winaltkeys
" For use in Maps
<CR>             : carriage Return for maps
<ESC>            : Escape
<LEADER>         : normally \
<BAR>            : | pipe
<BACKSPACE>      : backspace
<SILENT>         : No hanging shell window
#display RGB colour under the cursor eg #445588
:nmap <leader>c :hi Normal guibg=#<c-r>=expand("<cword>")<cr><cr>
map <f2> /price only\\|versus/ :in a map need to backslash the \
# type table,,, to get <table></table>       ### Cool ###
imap ,,, <esc>bdwa<<esc>pa><cr></<esc>pa><esc>kA
----------------------------------------
" Simple PHP debugging display all variables yanked into register a
iab phpdb exit("<hr>Debug <C-R>a  ");
----------------------------------------
" Using a register as a map (preload registers in .vimrc)
:let @m=":'a,'bs/"
:let @s=":%!sort -u"
----------------------------------------
" Useful tricks
"ayy@a           : execute "Vim command" in a text file
yy@"             : same thing using unnamed register
u@.              : execute command JUST typed in
"ddw             : store what you delete in register d *N*
"ccaw            : store what you change in register c *N*
----------------------------------------
" Get output from other commands (requires external programs)
:r!ls -R         : reads in output of ls
:put=glob('**')  : same as above                 *N*
:r !grep "^ebay" file.txt  : grepping in content   *N*
:20,25 !rot13    : rot13 lines 20 to 25   *N*
!!date           : same thing (but replaces/filters current line)
" Sorting with external sort
:%!sort -u       : use an external program to filter content
:'a,'b!sort -u   : use an external program to filter content
!1} sort -u      : sorts paragraph (note normal mode!!)
:g/^$/;,/^$/-1!sort : Sort each block (note the crucial ;)
" Sorting with internal sort
:sort /.*\%2v/   : sort all lines on second column *N*
----------------------------------------
" Multiple Files Management (Essential)
:bn              : goto next buffer
:bp              : goto previous buffer
:wn              : save file and move to next (super)
:wp              : save file and move to previous
:bd              : remove file from buffer list (super)
:bun             : Buffer unload (remove window but not from list)
:badd file.c     : file from buffer list
:b3              : go to buffer 3 *C*
:b main          : go to buffer with main in name eg main.c (ultra)
:sav php.html    : Save current file as php.html and "move" to php.html
:sav! %<.bak     : Save Current file to alternative extension (old way)
:sav! %:r.cfm    : Save Current file to alternative extension
:sav %:s/fred/joe/           : do a substitute on file name
:sav %:s/fred/joe/:r.bak2    : do a substitute on file name & ext.
:!mv % %:r.bak   : rename current file (DOS use Rename or DEL)
:help filename-modifiers
:e!              : return to unmodified file
:w c:/aaa/%      : save file elsewhere
:e #             : edit alternative file (also cntrl-^)
:rew             : return to beginning of edited files list (:args)
:brew            : buffer rewind
:sp fred.txt     : open fred.txt into a split
:sball,:sb       : Split all buffers (super)
:scrollbind      : in each split window
:map   <F5> :ls<CR>:e # : Pressing F5 lists all buffer, just type number
:set hidden      : Allows to change buffer w/o saving current buffer
----------------------------------------
" Quick jumping between splits
map <C-J> <C-W>j<C-W>_
map <C-K> <C-W>k<C-W>_
----------------------------------------
" Recording (BEST TIP of ALL)
qq  # record to q
your complex series of commands
q   # end recording
@q to execute
@@ to Repeat
5@@ to Repeat 5 times
qQ@qq                             : Make an existing recording q recursive *N*
" editing a register/recording
"qp                               :display contents of register q (normal mode)
<ctrl-R>q                         :display contents of register q (insert mode)
" you can now see recording contents, edit as required
"qdd                              :put changed contacts back into q
@q                                :execute recording/register q
" Operating a Recording on a Visual BLOCK
1) define recording/register
qq:s/ to/ from/g^Mq
2) Define Visual BLOCK
V}
3) hit : and the following appears
:'<,'>
4)Complete as follows
:'<,'>norm @q
----------------------------------------
"combining a recording with a map (to end up in command mode)
:nnoremap ] @q:update<bar>bd
----------------------------------------
" Visual is the newest and usually the most intuitive editing mode
" Visual basics
v                               : enter visual mode
V                               : visual mode whole line
<C-V>                           : enter VISUAL BLOCK mode
gv                              : reselect last visual area (ultra)
o                               : navigate visual area
"*y or "+y                      : yank visual area into paste buffer  *C*
V%                              : visualise what you match
V}J                             : Join Visual block (great)
V}gJ                            : Join Visual block w/o adding spaces
`[v`]                           : Highlight last insert
----------------------------------------
" Delete first 2 characters of 10 successive lines
0<c-v>10j2ld
----------------------------------------
" how to copy a set of columns using VISUAL BLOCK
" visual block (AKA columnwise selection) (NOT BY ordinary v command)
<C-V> then select "column(s)" with motion commands (win32 <C-Q>)
then c,d,y,r etc
----------------------------------------
" how to overwrite a visual-block of text with another such block *C*
" move with hjkl etc
Pick the first block: ctrl-v move y
Pick the second block: ctrl-v move P <esc>
----------------------------------------
" text objects :h text-objects                                     *C*
daW                                   : delete contiguous non whitespace
di<   yi<  ci<                        : Delete/Yank/Change HTML tag contents
da<   ya<  ca<                        : Delete/Yank/Change whole HTML tag
dat   dit                             : Delete HTML tag pair
diB   daB                             : Empty a function {}
das                                   : delete a sentence
----------------------------------------
" _vimrc essentials
:set incsearch : jumps to search word as you type (annoying but excellent)
:set wildignore=*.o,*.obj,*.bak,*.exe : tab complete now ignores these
:set shiftwidth=3                     : for shift/tabbing
:set vb t_vb=".                       : set silent (no beep)
:set browsedir=buffer                 : Maki GUI File Open use current directory
----------------------------------------
" launching Win IE
:nmap ,f :update<CR>:silent !start c:\progra~1\intern~1\iexplore.exe file://%:p<CR>
:nmap ,i :update<CR>: !start c:\progra~1\intern~1\iexplore.exe <cWORD><CR>
----------------------------------------
" FTPing from VIM
cmap ,r  :Nread ftp://209.51.134.122/public_html/index.html
cmap ,w  :Nwrite ftp://209.51.134.122/public_html/index.html
gvim ftp://www.somedomain.com/index.html # uses netrw.vim
----------------------------------------
" appending to registers (use CAPITAL)
" yank 5 lines into "a" then add a further 5
"a5yy
10j
"A5yy
----------------------------------------
[I     : show lines matching word under cursor <cword> (super)
----------------------------------------
" Conventional Shifting/Indenting
:'a,'b>>
" visual shifting (builtin-repeat)
:vnoremap < <gv
:vnoremap > >gv
" Block shifting (magic)
>i{
>a{
" also
>% and <%
----------------------------------------
" Redirection & Paste register *
:redir @*                    : redirect commands to paste buffer
:redir END                   : end redirect
:redir >> out.txt            : redirect to a file
" Working with Paste buffer
"*yy                         : yank to paste
"*p                          : insert from paste buffer
" yank to paste buffer (ex mode)
:'a,'by*                     : Yank range into paste
:%y*                         : Yank whole buffer into paste
:.y*                         : Yank Current line to paster
" filter non-printable characters from the paste buffer
" useful when pasting from some gui application
:nmap <leader>p :let @* = substitute(@*,'[^[:print:]]','','g')<cr>"*p
----------------------------------------
" Re-Formatting text
gq}                          : Format a paragraph
gqap                         : Format a paragraph
ggVGgq                       : Reformat entire file
Vgq                          : current line
" break lines at 70 chars, if possible after a ;
:s/.\{,69\};\s*\|.\{,69\}\s\+/&\r/g
----------------------------------------
" Operate command over multiple files
:argdo %s/foo/bar/e          : operate on all files in :args
:bufdo %s/foo/bar/e
:windo %s/foo/bar/e
:argdo exe '%!sort'|w!       : include an external command
:bufdo exe "normal @q" | w   : perform a recording on open files
:silent bufdo !zip proj.zip %:p   : zip all current files
----------------------------------------
" Command line tricks
gvim -h                    : help
ls | gvim -                : edit a stream!!
cat xx | gvim - -c "v/^\d\d\|^[3-9]/d " : filter a stream
gvim -o file1 file2        : open into a split
" execute one command after opening file
gvim.exe -c "/main" joe.c  : Open joe.c & jump to "main"
" execute multiple command on a single file
vim -c "%s/ABC/DEF/ge | update" file1.c
" execute multiple command on a group of files
vim -c "argdo %s/ABC/DEF/ge | update" *.c
" remove blocks of text from a series of files
vim -c "argdo /begin/+1,/end/-1g/^/d | update" *.c
" Automate editing of a file (Ex commands in convert.vim)
vim -s "convert.vim" file.c
#load VIM without .vimrc and plugins (clean VIM)
gvim -u NONE -U NONE -N
" Access paste buffer contents (put in a script/batch file)
gvim -c 'normal ggdG"*p' c:/aaa/xp
" print paste contents to default printer
gvim -c 's/^/\=@*/|hardcopy!|q!'
" gvim's use of external grep (win32 or *nix)
:grep somestring *.php     : creates a list of all matching files
" use :cn(ext) :cp(rev) to navigate list
:h grep
" Using vimgrep with copen                              *N*
:vimgrep /keywords/ *.php
:copen
----------------------------------------
" GVIM Difference Function (Brilliant)
gvim -d file1 file2        : vimdiff (compare differences)
dp                         : "put" difference under cursor to other file
do                         : "get" difference under cursor from other file
" complex diff parts of same file *N*
:1,2yank a | 7,8yank b
:tabedit | put a | vnew | put b
:windo diffthis 
----------------------------------------
" Vim traps
In regular expressions you must backslash + (match 1 or more)
In regular expressions you must backslash | (or)
In regular expressions you must backslash ( (group)
In regular expressions you must backslash { (count)
/fred\+/                   : matches fred/freddy but not free
/\(fred\)\{2,3}/           : note what you have to break
----------------------------------------
" \v or very magic (usually) reduces backslashing
/codes\(\n\|\s\)*where  : normal regexp
/\vcodes(\n|\s)*where   : very magic
----------------------------------------
" pulling objects onto command/search line (SUPER)
<C-R><C-W> : pull word under the cursor into a command line or search
<C-R><C-A> : pull WORD under the cursor into a command line or search
<C-R>-                  : pull small register (also insert mode)
<C-R>[0-9a-z]           : pull named registers (also insert mode)
<C-R>%                  : pull file name (also #) (also insert mode)
<C-R>=somevar           : pull contents of a variable (eg :let sray="ray[0-9]")
----------------------------------------
" List your Registers
:reg             : display contents of all registers
:reg a           : display content of register a
:reg 12a         : display content of registers 1,2 & a *N*
"5p              : retrieve 5th "ring" 
"1p....          : retrieve numeric registers one by one
:let @y='yy@"'   : pre-loading registers (put in .vimrc)
qqq              : empty register "q"
qaq              : empty register "a"
:reg .-/%:*"     : the seven special registers *N*
:reg 0           : what you last yanked, not affected by a delete *N*
"_dd             : Delete to blackhole, don't affect any register *N*
----------------------------------------
" manipulating registers
:let @a=@_              : clear register a
:let @a=""              : clear register a
:let @a=@"              : Save unnamed register *N*
:let @*=@a              : copy register a to paste buffer
:let @*=@:              : copy last command to paste buffer
:let @*=@/              : copy last search to paste buffer
:let @*=@%              : copy current filename to paste buffer
----------------------------------------
" help for help (USE TAB)
:h quickref             : VIM Quick Reference Sheet (ultra)
:h tips                 : Vim's own Tips Help
:h visual<C-D><tab>     : obtain  list of all visual help topics
                        : Then use tab to step thru them
:h ctrl<C-D>            : list help of all control keys
:helpg uganda           : grep HELP Files use :cn, :cp to find next
:helpgrep edit.*director: grep help using regexp
:h :r                   : help for :ex command
:h CTRL-R               : normal mode
:h /\r                  : what's \r in a regexp (matches a <CR>)
:h \\zs                 : double up backslash to find \zs in help
:h i_CTRL-R             : help for say <C-R> in insert mode
:h c_CTRL-R             : help for say <C-R> in command mode
:h v_CTRL-V             : visual mode
:h tutor                : VIM Tutor
<C-[>, <C-T>            : Move back & Forth in HELP History
gvim -h                 : VIM Command Line Help
:cabbrev h tab h        : open help in a tab *N*
----------------------------------------
" where was an option set
:scriptnames            : list all plugins, _vimrcs loaded (super)
:verbose set history?   : reveals value of history and where set
:function               : list functions
:func SearchCompl       : List particular function
----------------------------------------
" making your own VIM help
:helptags /vim/vim64/doc  : rebuild all *.txt help files in /doc
:help add-local-help
----------------------------------------
" running file thru an external program (eg php)
map   <f9>   :w<CR>:!c:/php/php.exe %<CR>
map   <f2>   :w<CR>:!perl -c %<CR>
----------------------------------------
" capturing output of current script in a separate buffer
:new | r!perl #                   : opens new buffer,read other buffer
:new! x.out | r!perl #            : same with named file
:new+read!ls
----------------------------------------
" create a new buffer, paste a register "q" into it, then sort new buffer
:new +put q|%!sort
----------------------------------------
" Inserting DOS Carriage Returns
:%s/$/\<C-V><C-M>&/g          :  that's what you type
:%s/$/\<C-Q><C-M>&/g          :  for Win32
:%s/$/\^M&/g                  :  what you'll see where ^M is ONE character
----------------------------------------
" automatically delete trailing Dos-returns,whitespace
autocmd BufRead * silent! %s/[\r \t]\+$//
autocmd BufEnter *.php :%s/[ \t\r]\+$//e
----------------------------------------
" perform an action on a particular file or file type
autocmd VimEnter c:/intranet/note011.txt normal! ggVGg?
autocmd FileType *.pl exec('set fileformats=unix')
----------------------------------------
" Retrieving last command line command for copy & pasting into text
i<c-r>:
" Retrieving last Search Command for copy & pasting into text
i<c-r>/
----------------------------------------
" more completions
<C-X><C-F>                        :insert name of a file in current directory
----------------------------------------
" Substituting a Visual area
" select visual area as usual (:h visual) then type :s/Emacs/Vim/ etc
:'<,'>s/Emacs/Vim/g               : REMEMBER you dont type the '<.'>
gv                                : Re-select the previous visual area (ULTRA)
----------------------------------------
" inserting line number into file
:g/^/exec "s/^/".strpart(line(".")."    ", 0, 4)
:%s/^/\=strpart(line(".")."     ", 0, 5)
:%s/^/\=line('.'). ' '
----------------------------------------
#numbering lines VIM way
:set number                       : show line numbers
:map <F12> :set number!<CR>       : Show linenumbers flip-flop
:%s/^/\=strpart(line('.')."        ",0,&ts)
#numbering lines (need Perl on PC) starting from arbitrary number
:'a,'b!perl -pne 'BEGIN{$a=223} substr($_,2,0)=$a++'
#Produce a list of numbers
#Type in number on line say 223 in an empty file
qqmnYP`n^Aq                       : in recording q repeat with @q
" increment existing numbers to end of file (type <c-a> as 5 characters)
:.,$g/^\d/exe "normal! \<c-a>"
" advanced incrementing
http://vim.sourceforge.net/tip_view.php?tip_id=150
----------------------------------------
" advanced incrementing (really useful)
" put following in _vimrc
let g:I=0
function! INC(increment)
let g:I =g:I + a:increment
return g:I
endfunction
" eg create list starting from 223 incrementing by 5 between markers a,b
:let I=223
:'a,'bs/^/\=INC(5)/
" create a map for INC
cab viminc :let I=223 \| 'a,'bs/$/\=INC(5)/
----------------------------------------
" generate a list of numbers  23-64
o23<ESC>qqYp<C-A>q40@q
----------------------------------------
" editing/moving within current insert (Really useful)
<C-U>                             : delete all entered
<C-W>                             : delete last word
<HOME><END>                       : beginning/end of line
<C-LEFTARROW><C-RIGHTARROW>       : jump one word backwards/forwards
<C-X><C-E>,<C-X><C-Y>             : scroll while staying put in insert
----------------------------------------
#encryption (use with care: DON'T FORGET your KEY)
:X                                : you will be prompted for a key
:h :X
----------------------------------------
" modeline (make a file readonly etc) must be in first/last 5 lines
// vim:noai:ts=2:sw=4:readonly:
" vim:ft=html:                    : says use HTML Syntax highlighting
:h modeline
----------------------------------------
" Creating your own GUI Toolbar entry
amenu  Modeline.Insert\ a\ VIM\ modeline <Esc><Esc>ggOvim:ff=unix ts=4 ss=4<CR>vim60:fdm=marker<esc>gg
----------------------------------------
" A function to save word under cursor to a file
function! SaveWord()
   normal yiw
   exe ':!echo '.@0.' >> word.txt'
endfunction
map ,p :call SaveWord()
----------------------------------------
" function to delete duplicate lines
function! Del()
 if getline(".") == getline(line(".") - 1)
   norm dd
 endif
endfunction

:g/^/ call Del()
----------------------------------------
" Digraphs (non alpha-numerics)
:digraphs                         : display table
:h dig                            : help
i<C-K>e'                          : enters é
i<C-V>233                         : enters é (Unix)
i<C-Q>233                         : enters é (Win32)
ga                                : View hex value of any character
#Deleting non-ascii characters (some invisible)
:%s/[\x00-\x1f\x80-\xff]/ /g      : type this as you see it
:%s/[<C-V>128-<C-V>255]//gi       : where you have to type the Control-V
:%s/[¿-ÿ]//gi                     : Should see a black square & a dotted y
:%s/[<C-V>128-<C-V>255<C-V>01-<C-V>31]//gi : All pesky non-asciis
:exec "norm /[\x00-\x1f\x80-\xff]/"        : same thing
#Pull a non-ascii character onto search bar
yl/<C-R>"                         :
/[^a-zA-Z0-9_[:space:][:punct:]]  : search for all non-ascii
----------------------------------------
" All file completions grouped (for example main_c.c)
:e main_<tab>                     : tab completes
gf                                : open file under cursor  (normal)
main_<C-X><C-F>                   : include NAME of file in text (insert mode)
----------------------------------------
" Complex Vim
" swap two words
:%s/\<\(on\|off\)\>/\=strpart("offon", 3 * ("off" == submatch(0)), 3)/g
" swap two words
:vnoremap <C-X> <Esc>`.``gvP``P
" Swap word with next word
nmap <silent> gw    "_yiw:s/\(\%#\w\+\)\(\_W\+\)\(\w\+\)/\3\2\1/<cr><c-o><c-l> *N*
----------------------------------------
" Convert Text File to HTML
:runtime! syntax/2html.vim        : convert txt to html
:h 2html
----------------------------------------
" VIM has internal grep
:grep some_keyword *.c            : get list of all c-files containing keyword
:cn                               : go to next occurrence
----------------------------------------
" Force Syntax coloring for a file that has no extension .pl
:set syntax=perl
" Remove syntax coloring (useful for all sorts of reasons)
:set syntax off
" change coloring scheme (any file in ~vim/vim??/colors)
:colorscheme blue
" Force HTML Syntax highlighting by using a modeline
# vim:ft=html:
" Force syntax automatically (for a file with non-standard extension)
au BufRead,BufNewFile */Content.IE?/* setfiletype html
----------------------------------------
:set noma (non modifiable)        : Prevents modifications
:set ro (Read Only)               : Protect a file from unintentional writes
----------------------------------------
" Sessions (Open a set of files)
gvim file1.c file2.c lib/lib.h lib/lib2.h : load files for "session"
:mksession                        : Make a Session file (default Session.vim)
:q
gvim -S Session.vim               : Reload all files
----------------------------------------
#tags (jumping to subroutines/functions)
taglist.vim                       : popular plugin
:Tlist                            : display Tags (list of functions)
<C-]>                             : jump to function under cursor
----------------------------------------
" columnise a csv file for display only as may crop wide columns
:let width = 20
:let fill=' ' | while strlen(fill) < width | let fill=fill.fill | endwhile
:%s/\([^;]*\);\=/\=strpart(submatch(1).fill, 0, width)/ge
:%s/\s\+$//ge
" Highlight a particular csv column (put in .vimrc)
function! CSVH(x)
    execute 'match Keyword /^\([^,]*,\)\{'.a:x.'}\zs[^,]*/'
    execute 'normal ^'.a:x.'f,'
endfunction
command! -nargs=1 Csv :call CSVH(<args>)
" call with
:Csv 5                             : highlight fifth column
----------------------------------------
" folding : hide sections to allow easier comparisons
zf}                               : fold paragraph using motion
v}zf                              : fold paragraph using visual
zf'a                              : fold to mark
zo                                : open fold
zc                                : re-close fold
:help folding
----------------------------------------
" displaying "non-asciis"
:set list
:h listchars
----------------------------------------
" How to paste "normal commands" w/o entering insert mode
:norm qqy$jq
----------------------------------------
" manipulating file names
:h filename-modifiers             : help
:w %                              : write to current file name
:w %:r.cfm                        : change file extention to .cfm
:!echo %:p                        : full path & file name
:!echo %:p:h                      : full path only
:!echo %:t                        : filename only
:reg %                            : display filename
<C-R>%                            : insert filename (insert mode)
"%p                               : insert filename (normal mode)
/<C-R>%                           : Search for file name in text
----------------------------------------
" delete without destroying default buffer contents
"_d                               : what you've ALWAYS wanted
"_dw                              : eg delete word (use blackhole)
----------------------------------------
" pull full path name into paste buffer for attachment to email etc
nnoremap <F2> :let @*=expand("%:p")<cr> :unix
nnoremap <F2> :let @*=substitute(expand("%:p"), "/", "\\", "g")<cr> :win32
----------------------------------------
" Simple Shell script to rename files w/o leaving vim
$ vim
:r! ls *.c
:%s/\(.*\).c/mv & \1.bla
:w !sh
:q!
----------------------------------------
" count words in a text file
g<C-G>
----------------------------------------
" example of setting your own highlighting
:syn match DoubleSpace "  "
:hi def DoubleSpace guibg=#e0e0e0
----------------------------------------
" reproduce previous line word by word
imap ]  @@@<ESC>hhkyWjl?@@@<CR>P/@@@<CR>3s
nmap ] i@@@<ESC>hhkyWjl?@@@<CR>P/@@@<CR>3s
" Programming keys depending on file type
:autocmd bufenter *.tex map <F1> :!latex %<CR>
:autocmd bufenter *.tex map <F2> :!xdvi -hush %<.dvi&<CR>
----------------------------------------
" reading Ms-Word documents, requires antiword
:autocmd BufReadPre *.doc set ro
:autocmd BufReadPre *.doc set hlsearch!
:autocmd BufReadPost *.doc %!antiword "%"
----------------------------------------
" a folding method
vim: filetype=help foldmethod=marker foldmarker=<<<,>>>
A really big section closed with a tag <<< 
--- remember folds can be nested --- 
Closing tag >>> 
----------------------------------------
" Return to last edit position (You want this!) *N*
autocmd BufReadPost *
     \ if line("'\"") > 0 && line("'\"") <= line("$") |
     \   exe "normal! g`\"" |
     \ endif
----------------------------------------
" store text that is to changed,deleted in register a
"act<                                 :  Change Till < *N*
----------------------------------------
" Just Another Vim Hacker JAVH
vim -c ":%s%s*%Cyrnfr)fcbafbe[Oenz(Zbbyranne%|:%s)[[()])-)Ig|norm Vg?"
----------------------------------------
__END__
----------------------------------------
"Read Vimtips into a new vim buffer (needs w3m.sourceforge.net)
:tabe | :r ! w3m -dump http://rayninfo.co.uk/vimtips.html    *N*
----------------------------------------
" *NEW* Utilities to use with VIM to help the editing process 
VimTools *N*
----------------------------------------
updated version at http://www.rayninfo.co.uk/vimtips.html
----------------------------------------
Please email any errors, tips etc to
david@rayninfo.co.uk
" Information Sources
----------------------------------------
www.vim.org
Vim Wiki *** VERY GOOD *** *N*
Vim Use VIM newsgroup *N*
comp.editors
groups.yahoo.com/group/vim "VIM" specific newsgroup
VIM Webring
Vim Book
Searchable VIM Doc
VimTips PDF Version (PRINTABLE!)
----------------------------------------
" : commands to neutralise < for HTML display and publish
" use yy@" to execute following commands
:w!|sav! vimtips.html|:/^__BEGIN__/,/^__END__/s#<#\<#g|:w!|:!vimtipsftp
----------------------------------------


45. VI pocket reference

	45.1 Command line options
	Command				Action
	vi file				Invoke vi on file
	vi file1 file2			Invoke vi on files sequentially
	view file			Invoke vi on file in read-only mode
	vi -R file			Invoke vi on file in read-only mode
	vi -r file			Recover file and recent edits after a crash
	vi -t tag			Look up tag and start editing at its definition
	vi -w n				Set the window size to n ; useful over a slow connection
	vi + file			Open file at last line
	vi +n file			Open file directly at line number n
	vi -c command file		Open file, execute command, which is usually a search command or line number (POSIX)
	vi +/pattern file		Open file directly at pattern
					Example: vi +/change.*password stam 
					will open file in first occurence of pattern change.*password
	ex file				Invoke ex on file
	ex - file < script		Invoke ex on file, taking commands from script ; suppress informative messages and prompts
	ex -s file < script		Invoke ex on file, taking commands from script ; suppress informative messages and prompts (POSIX)

	45.2  vi Commands

Most vi commands follow a general pattern:

[command][number]text object

or the equivalent form:

[number][command]text object

		45.2.1  Movement Commands

Command			Meaning
Character	 
h, j, k, l		Left, down, up, right (, , , )
Text	 
w, W, b, B		Forward, backward by word
e, E			End of word
), (			Beginning of next, previous sentence
}, {			Beginning of next, previous paragraph
] ], [ [		Beginning of next, previous section
Lines	 
RETURN			First nonblank character of next line
0, $			First, last position of current line
^			First nonblank character of current line
+, -			First nonblank character of next, previous line
n |			Column n of current line
H			Top line of screen
M			Middle line of screen
L			Last line of screen
nH			n (number) of lines after top line
nL			n (number) of lines before last line
Scrolling	 
CTRL-F, CTRL-B		Scroll forward, backward one screen
CTRL-D, CTRL-U		Scroll down, up one-half screen
CTRL-E, CTRL-Y		Show one more line at bottom, top of window
z RETURN		Reposition line with cursor: to top of screen
z .			Reposition line with cursor: to middle of screen
z - 			Reposition line with cursor: to bottom of screen
CTRL-L			Redraw screen (without scrolling)
Searches	 
/pattern		Search forward for pattern
?pattern		Search backward for pattern
n, N			Repeat last search in same, opposite direction
/, ?			Repeat previous search forward, backward
fx			Search forward for character x in current line
Fx			Search backward for character x in current line
tx			Search forward to character before x in current line
Tx			Search backward to character after x in current line
;			Repeat previous current-line search
,			Repeat previous current-line search in opposite direction
Line number	 
CTRL-G			Display current line number
nG			Move to line number n
G			Move to last line in file
:n			Move to line n in file
Marking position	 
mx			Mark current position as x
'x			Move cursor to mark x
''			Return to previous mark or context
'x			Move to beginning of line containing mark x
' '			Return to beginning of line containing previous mark

		45.2.2 Editing Commands

Command			Action
Insert	 
i, a			Insert text before, after cursor
I, A			Insert text before beginning, after end of line
o, O			Open new line for text below, above cursor
Change	 
r			Replace character
cw			Change word
cc			Change current line
cmotion			Change text between the cursor and the target of motion
C			Change to end of line
R			Type over (overwrite) characters
s			Substitute: delete character and insert new text
S			Substitute: delete current line and insert new text
Delete, move	 
x			Delete character under cursor
X			Delete character before cursor
dw			Delete word
dd			Delete current line
dmotion			Delete text between the cursor and the target of motion
D			Delete to end of line
d0			Delete to start of line
p, P			Put deleted text after, before cursor
"np			Put text from delete buffer number n after cursor (for last nine deletions)
Yank	 
yw			Yank (copy) word
yy,Y			Yank current line
"ayy			Yank current line into named buffer a (az). Uppercase names append text
ymotion			Yank text between the cursor and the target of motion
p, P			Put yanked text after, before cursor
"aP			Put text from buffer a before cursor (az)
Other commands	 
.			Repeat last edit command
u, U			Undo last edit; restore current line
J			Join two lines
ex edit commands	 
:d			Delete lines
:m			Move lines
:co or :t		Copy lines
:.,$d			Delete from current line to end of file
:%d			% is a shortcut to 1,$ so equivalent to :1,$d which is delete all file. replace d with y for yank.
:30,60m0		Move lines 30 through 60 to top of file
:.,/pattern/co$	Copy	from current line through line containing pattern to end of file

		45.2.3 Exit Commands

Command			Meaning
ZZ			Write (save) and quit file
:x			Write (save) and quit file
:wq			Write (save) and quit file
:w			Write (save) file
:w!			Write (save) file, overriding protection
:30,60w newfile		Write from line 30 through line 60 as newfile
:30,60w>> file		Write from line 30 through line 60 and append to file
:w %.new		Write current buffer named file as file.new
:q			Quit file
:q!			Quit file, overriding protection
Q			Quit vi and invoke ex
:e file2		Edit file2 without leaving vi
:n			Edit next file
:e!			Return to version of current file at time of last write (save)
:e #			Edit alternate file
:vi			Invoke vi editor from ex
:			Invoke one ex command from vi editor
%			Current filename (substitutes into ex command line)
#			Alternate filename (substitutes into ex command line)

		45.2.4 vi Command-Mode Tag Commands

Command			Action
^]			Look up the location of the identifier under the cursor in the tags file and move to that location; if tag stacking is enabled, the current location is automatically pushed onto the tag stack
^T			Return to the previous location in the tag stack, i.e., pop off one element
:pop

		45.2.5 Buffer Names

Buffer Names		Buffer Use
19			The last nine deletions, from most to least recent
az			Named buffers to use as needed; uppercase letters append to the buffer

		45.2.6 Buffer and Marking Commands

Command			Meaning
"b command		Do command with buffer b
mx			Mark current position with x
'x			Move cursor to first character of line marked by x
`x			Move cursor to character marked by x
` `			Return to exact position of previous mark or context
' '			Return to beginning of the line of previous mark or context

	45.3 Input Mode Shortcuts

		45.3.1 Word Abbreviation
:ab abbr phrase
    Define abbr as an abbreviation for phrase.

:unab abbr
    Remove definition of abbr.

Be careful with abbreviation texts that either end with the abbreviation name or contain the abbreviation name in the middle.

		45.3.2 Command and Input Mode Maps

			45.3.2.1 Syntax
:map  x sequence
    Define character(s) x as a sequence of editing commands.

:unmap  x
    Disable the sequence defined for x.

:map
    List the characters that are currently mapped.

:map!  x sequence
    Define character(s) x as a sequence of editing commands or text that will be recognized in input mode.

:unmap!  x
    Disable the sequence defined for the input mode map x.

:map!
    List the characters that are currently mapped for interpretation in insert mode.

For both command and input mode maps, the map name x can take several forms:


One character
    When you type the character, vi executes the associated sequence of commands.

Multiple characters
    All the characters must be typed within one second. The value of notimeout changes the behavior.

# n
    Function key notation: a # followed by a digit n represents the sequence of characters sent by the terminal's function key number n.

To enter characters such as Escape (^[) or carriage return (^M), first type a CTRL-V (^V).

			45.3.2.1 Tutorial
Command mapping
You define your own new command by mapping a sequence of commands to a single or several key stroke(s).

    :map new_command command_sequence 

Here both the new_command and command_sequence can be a sequence of characters.

To input a special character such as Esc, or Ctrlf you will need to push Ctrlv first, then hit the special key. For the Space key, you'll need two Ctrlvs. For example, using this map

    :map CtrlvCtrlvSpace CtrlvCtrlf 

when you press the Space key, the cursor is moved forward by a screen.

An alternative way to input special keys is using the special names defined by vim. Here is some examples:
Ctrlk		<c-k>
Ctrlw		<c-w>
Space		<space>
Enter		<enter>
Esc		<esc>
You can find out other key names by typing :help. Using this instead of the Ctrlv way in map definition is more convenient and reliable.
Examples

    * Press gi to insert a character

          :map gi iSpaceCtrlvEscr 

      or

          :map gi i<space><esc>r 

    * Press # to get a current date stamp

          :map # :r!dateCtrlvEnter 

      or

          :map # :r!date<enter> 

    * Press Space to move cursor forward by a screen

          :map CtrlvCtrlvSpace CtrlvCtrlf 

    * Press @, to produce a block of text
      map command on one line in the command mode of vi:

          :map @ oif X CtrlvEnter Tab then aCtrlvEnter Tab else b CtrlvEsc 

      when you push @ in command mode, you will get

             if X
                  then a
                  else b

      The o command opens a new line below and enters insert mode. Everything from the o until the Esc character is entered in the insert mode. The Ctrlv allows you to enter keys like Enter and Esc into the command sequence. 

Ctrlq or Ctrlv ?
Again, in newer versions of Windows gvim you may find Ctrlv not working. That is because it is mapped to do pasting. In this case, to enter the visual block mode, or input a special key in defining mapping, you may use Ctrlq instead. And if you find that inconvenient and inconsistent, you either remove the line in your _vimrc file which contains the word mswin, or you can unmap the Ctrlv by

    :unmap <c-v> 


		45.3.3 Named buffers provide yet another way to create "macros"complex command sequences you can repeat with a few keystrokes. Here's how it's done:

   a.  Type a vi command sequence or an ex command preceded by a colon ; return to command mode.
   b.  Delete the text into a named buffer.
   c.  Execute the buffer with the @ command followed by the buffer letter.

The ex command :@buf-name works similarly.

Some versions treat * identically to @ when used from the ex command line. In addition, if the buffer character supplied after the @ or * commands is *, the command is taken from the default (unnamed) buffer.

		45.3.4 Automatic Indentation

You enable automatic indentation with the command:

:set autoindent 
Four special input sequences affect automatic indentation:


^T Add one level of indentation; typed in insert mode

^D Remove one level of indentation; typed in insert mode

^ ^D Shift the cursor back to the beginning of the line, but only for the current line[1]

0 ^D Shift the cursor back to the beginning of the line and reset the current auto-indent level to zero[2]

Two commands can be used for shifting source code:

<< Shift a line left eight spaces

>> Shift a line right eight spaces

The default shift is the value of shiftwidth, usually eight spaces.

	45.4 Substitution and Regular Expressions

		45.4.1 The Substitute Command

The general form of the substitute command is:

:[addr1[,addr2]]s/old/new/[flags]

Omitting the search pattern (:s//replacement/) uses the last search or substitution regular expression.

An empty replacement part (:s/pattern//) "replaces" the matched text with nothing, effectively deleting it from the line.

Substitution flags
Flag	Meaning
c	Confirm each substitution
g	Change all occurrences of old to new on each line (globally)
p	Print the line after the change is made

It's often useful to combine the substitute command with the ex global command, :g:

:g/Object Oriented/s//Buzzword compliant/g

		45.4.2 vi Regular Expressions
.  Matches any single character except a newline. Remember that spaces are treated as characters.

* Matches zero or more (as many as there are) of the single character that immediately precedes it.

    The * can follow a metacharacter, such as . or a range in brackets.

^ When used at the start of a regular expression, ^ requires that the following regular expression be found at the beginning of the line. When not at the beginning of a regular expression, ^ stands for itself.

$ When used at the end of a regular expression, $ requires that the preceding regular expression be found at the end of the line. When not at the end of a regular expression, $ stands for itself.

\ Treats the following special character as an ordinary character. (Use \ \ to get a literal backslash.)

[ ] Matches any one of the characters enclosed between the brackets. A range of consecutive characters can be specified by separating the first and last characters in the range with a hyphen.

    You can include more than one range inside brackets and specify a mix of ranges and separate characters.

    Most metacharacters lose their special meaning inside brackets, so you don't need to escape them if you want to use them as ordinary characters. Within brackets, the three metacharacters you still need to escape are \ - ]. (The hyphen (-) acquires meaning as a range specifier; to use an actual hyphen, you can also place it as the first character inside the brackets.)

    A caret (^) has special meaning only when it's the first character inside the brackets, but in this case, the meaning differs from that of the normal ^ metacharacter. As the first character within brackets, a ^ reverses their sense: the brackets match any one character not in the list. For example, [^a-z] matches any character that's not a lowercase letter.

\(  \) Saves the pattern enclosed between \ ( and \ ) into a special holding space or "hold buffer." Up to nine patterns can be saved in this way on a single line.

    You can also use the \n notation within a search or substitute string:

    :s/\(abcd\)\1/alphabet-soup/

    changes abcdabcd into alphabet-soup.

\<  \> Matches characters at the beginning (\<) or end (\>) of a word. The end or beginning of a word is determined either by a punctuation mark or by a space. Unlike \(¿\), these don't have to be used in matched pairs.

~ Matches whatever regular expression was used in the last search.

		45.4.3  POSIX character classes
Class		Matching Characters
[:alnum:]	Alphanumeric characters
[:alpha:]	Alphabetic characters
[:blank:]	Space and tab characters
[:cntrl:]	Control characters
[:digit:]	Numeric characters
[:graph:]	Printable and visible (nonspace) characters
[:lower:]	Lowercase characters
[:print:]	Printable characters (includes whitespace)
[:punct:]	Punctuation characters
[:space:]	Whitespace characters
[:upper:]	Uppercase characters
[:xdigit:]	Hexadecimal digits

Note that in normal mode you'll need double brackets, for example:
/[[:digit:]]
will search for digits
		
		45.4.4 Metacharacters Used in Replacement Strings
\ n Is replaced with the text matched by the n th pattern previously saved by \( and \), where n is a number from 1 to 9, and previously saved patterns (kept in hold buffers) are counted from the left on the line.

\ Treats the following special character as an ordinary character. To specify a real backslash, type two in a row ( \ \ ).

& Is replaced with the entire text matched by the search pattern when used in a replacement string. This is useful when you want to avoid retyping text.

~ The string found is replaced with the replacement text specified in the last substitute command. This is useful for repeating an edit.

\u or \l Changes the next character in the replacement string to upper- or lowercase, respectively.

\U or \L and \e or \E 
    \U and \L are similar to \u or \l, but all following characters are converted to upper- or lowercase until the end of the replacement string or until \e or \E is reached. If there is no \e or \E, all characters of the replacement text are affected by the \U or \L.

		

		45.4.5 More Substitution Tricks
    * You can instruct vi to ignore case by typing :set ic.
    *
A simple :s is the same as :s//~/.  *

      :& is the same as :s. You can follow the & with a g to make the substitution globally on the line, and even use it with a line range.  * 
      The & key can be used as a vi command to perform the :& command, i.e., to repeat the last substitution.
    * The :~ command is similar to the :& command, but with a subtle difference. The search pattern used is the last regular expression used in any command, not necessarily the one used in the last substitute command.
    * Besides the / character, you may use any nonalphanumeric, nonwhitespace character as your delimiter, except backslash, double-quote, and the vertical bar (\, ", and |).
    * When the edcompatible option is enabled, vi remembers the flags (g for global and c for confirmation) used on the last substitute and applies them to the next one.  

    45.5 ex Commands

	45.5.1 Command Syntax
:[address] command [options]

	45.5.2 Address Symbols

Address			Includes
1,$			All lines in the file
x,y			Lines x through y
x;y			Lines x through y, with current line reset to x
0			Top of file
.			Current line
n			Absolute line number n
$			Last line
%			All lines; same as 1,$
x-n			n lines before x
x+n			n lines after x
-[n]			One or n lines previous
+[n]			One or n lines ahead
'x			Line marked with x
'' 			Previous mark
/pat/ or ?pat?		Ahead or back to line where pat matches 

	45.5.3 Command Option Symbols

Symbol			Meaning
!			A variant form of the command
count			Repeat the command count times
file			Filename: % is current file, # is previous file

	45.5.4  Alphabetical List of Commands

Full Name		Command
Abbrev			ab [string text]
Append			[address]a[!]			to use, first type :[address]a and then enter. Then enter text and end by . enter.
			text		
			.
Args			ar
Change			[address] c[!] 
			text
			.
Copy			[address] co destination
Delete			[address] d [buffer]
Edit			e [!][+n] [filename]
File			f [filename]
Global			[address]g[!]/pattern/[commands]
Insert			[address]i[!]
			text
			.
Join			[address]j[!][count]
K (mark)		[address] k char
List			[address] l [count]
Map			map char commands
Mark			[address] ma char
Move			[address] m destination
Next			n[!] [[+command] filelist]
Number			[address] nu [count]
Open			[address] o [/pattern/]
Preserve		pre
Print			[address] p [count] [address] P [count]
Put			[address] pu [char]
Quit			q[!]
Read			[address] r filename
Read			[address] r ! command
Recover			rec [filename]
Rewind			rew[!]
Set	
			set
			set option
			set nooption
			6set option=value
			set option?
Shell			sh
Source			so filename
Substitute		[addr] s [/pat/repl/][opts]
T (to)			[address]t destination
Tag			[address] ta tag
Unabbreviate		una word
Undo			u
Unmap			unm char
V (global exclude)	[address] v/pattern/[commands]
Version			ve
Visual			[address] vi [type] [count]
Visual			vi [+n] [filename]
Write			[address] w[!] [[>>]filename]
Write			[address] w !command
Wq (write + quit)	wq[!]
Xit			x
Yank			[address] y [char] [count]
Z (position line)	[address] z[type] [count]

type can be one of: 
			+ Place line at the top of the window (default)
			- Place line at bottom of the window
			.  Place line in the center of the window
			^ Print the previous window
			= Place line in the center of the window and leave the current line at this line

!			[address] !command
=			(line number)	[address] =
< > (shift)		[address] < [count]
			[address] > [count]
Address			address
Return (next line)	RETURN
&			[address] & [options] [count] repeat substitute
~			[address]~[count] Like &, but with last used regular expression; for details, see Chapter 6 of Learning the vi Editor

	45.6  vi Options

Option			Default
autoinden(ai)		noai
autoprint(ap)		ap
autowrite(aw)		noaw
beautify (bf)		nobf
directory(dir)		/tmp
edcompatible		noedcompatible
errorbells (eb)		errorbells
exrc (ex)		noexrc
hardtabs (ht)		8
ignorecase (ic)		noic
lisp			nolisp
list			nolist
magic			magic
mesg			mesg
novice			nonovice
number (nu)		nonu
open			open
optimize (opt)		noopt
paragraphs (para)	IPLPPPQP LIpplpipbp
prompt			prompt
readonly (ro)		noro
redraw (re)	 
remap			remap
report			5
scroll			half window
sections (sect)		SHNHH HU
shell (sh)		/bin/sh
shiftwidth (sw)		8
showmatch (sm)		nosm
showmode		noshowmode
slowopen (slow)		 
tabstop (ts)		8
taglength (tl)		0
tags	tags		/usr/lib/tags
tagstack		tagstack
term			(from $TERM)
terse			noterse
timeout 		(to)	timeout
ttytype			(from $TERM)
warn			warn
window (w)	 
wrapscan (ws)		ws
wrapmargin (wm)		ws0
writeany (wa)		wsnowa

	45.7  VIM

		45.7.1 Important Command-Line Arguments, flags, parameters
		For help on all flags do :h -font (or any other flag)
c command 
    Execute command at startup. (POSIX version of the historic +command )

R Start in read-only mode, setting the readonly option.

s Enter batch (script) mode. This is only for ex and intended for running editing scripts (POSIX version of the historic "" argument).

b Start in binary mode.

f For the GUI version, stay in the foreground.

g 
    Start the GUI version of vim, if it has been compiled in.

o [N] 
    Open N windows, if given; otherwise open one window per file.

i viminfo 
    Read the given viminfo file for initialization, instead of the default viminfo file.

n Don't create a swap file: recovery won't be possible.

q filename 
    Treat filename as the "quick fix" file.

u vimrc 
    Read the given .vimrc file for initialization and skip all other normal initialization steps.

U gvimrc 
    Read the given .gvimrc file for GUI initialization and skip all other normal GUI initialization steps.

Z Enter restricted mode (same as having a leading r in the name).

w
-w {scriptout}	All the characters that you type are recorded in the file
		"scriptout", until you exit Vim.  This is useful if you want
		to create a script file to be used with "vim -s" or
		":source!".  When the "scriptout" file already exists, new
		characters are appended.  See also |complex-repeat|.
		{scriptout} cannot start with a digit.
		{not in Vi}

		45.7.2 vim Window Management Commands

Command				Function
[N]sp[lit] [position] [file]	Split the current window in half
[N]new [position] [file]	Create a new window, editing an empty buffer
[N]sv[iew] [position] [file]	Same as :split, but set the readonly option for the buffer
q[uit][!]			Quit the current window (exit if given in the last window)
clo[se][!]			Close the current window; behavior affected by the hidden option
hid[e]				Close the current window, if it's not the last one on the screen
on[ly]				Make this window the only one on the screen
res[ize] [±n]			Increase or decrease the current window height by n
res[ize] [n]			Set the current window height to n if supplied, otherwise, set it to the largest size possible without hiding the other windows
qa[ll][!]			Exit vim
wqa[ll][!]			Write all changed buffers and exit
xa[ll][!]
wa[ll][!]			Write all modified buffers that have filenames
[N]sn[ext]			Split the window and move to the next file in the argument list, or to the N th file if a count is supplied
sta[g] [tagname]		Split the window and run the :tag command as appropriate in the new window

			45.7.2.1 Window commands from vi mode

Command			Function
^W s			Same as :split without a file argument; ^W ^S may not work on all terminals
^W S
^W ^S			 
^W n			Same as :new without a file argument
^W ^N			 
^W ^			Perform :split #, split the window, and edit the alternate file
^W ^^
^W q			Same as the :quit command; ^W ^Q may not work on all terminals
^W ^Q
^W c			Same as the :close command
^W o			Like the :only command
^W ^O	 
^W <DOWN>		Move cursor to n th window below the current one
^W j
^W ^J	 
^W <UP>			Move cursor to n th window above the current one
^W k
^W ^K			 
^W w			With count, go to n th window; otherwise, move to the window below the current one; if in the bottom window, move to the top one
^W ^W
^W W			With count, go to n th window; otherwise, move to window above the current one; if in the top window, move to the bottom one
^W t			Move the cursor to the top window
^W ^T			 
^W b			Move the cursor to the bottom window
^W ^B			 
^W p			Go to the most recently accessed (previous) window
^W ^P			 
^W r			Rotate all the windows downwards; the cursor stays in the same window
^W ^R
^W R			Rotate all the windows upwards; the cursor stays in the same window
^W x			Without count, exchange the current window with the next one; if there is no next window, exchange with the previous window. With count, exchange the current window with the n th window (first window is 1; the cursor is put in the other window)
^W ^X
^W =			Make all windows the same height.
^W -			Decrease current window height
^W +			Increase current window height
^W _			Set the current window size to the value given in a preceding count
^W ^_
zNRETURN		Set the current window height to N
^W ]			Split the current window; in the new upper window, use the identifier under the cursor as a tag and go to it
^W ^]
^W f			Split the current window and edit the filename under the cursor in the new window
^W ^F
^W i			Open a new window; move the cursor to the first line that matches the keyword under the cursor
^W ^I
^W d			Open a new window, with the cursor on the first macro definition line that contains the keyword under the cursor
^W ^D

		45.7.3 Extended Regular Expressions
\| 
    Indicates alternation.

\+ 
    Matches one or more of the preceding regular expressions.

\= 
    Matches zero or one of the preceding regular expression.

\{ n, m} 
    Matches n to m of the preceding regular expression, as much as possible. n and m are numbers between 0 and 32,000; vim only requires the left brace to be preceded by a backslash, but not the right brace.

\{ n} 
    Matches n of the preceding regular expression.

\{ n,} 
    Matches at least n of the preceding regular expression, as much as possible.

\{, m} 
    Matches 0 to m of the preceding regular expression, as much as possible.

\{} 
    Matches 0 or more of the preceding regular expressions, as much as possible (same as *).

\{- n, m} 
    Matches n to m of the preceding regular expression, as few as possible.

\{- n} 
    Matches n of the preceding regular expression.

\{- n,} 
    Matches at least n of the preceding regular expression, as few as possible.

\{-, m} 
    Matches 0 to m of the preceding regular expression, as few as possible.

\i 
    Matches any identifier character, as defined by the isident option.

\I 
    Like \i, excluding digits.

\k 
    Matches any keyword character, as defined by the iskeyword option.

\K 
    Like \k, excluding digits.

\f 
    Matches any filename character, as defined by the is-fname option.

\F 
    Like \f, excluding digits.

\p 
    Matches any printable character, as defined by the isprint option.

\P 
    Like \p, excluding digits.

\s 
    Matches a whitespace character (exactly space or tab).

\S 
    Matches anything that isn't a space or a tab.

\b 
    Backspace.

\e 
    Escape.

\r 
    Carriage return.

\t 
    Tab.

\n 
    Reserved for future use.

~ 
    Matches the last given substitute (i.e., replacement) string.

\(...\) 
    Provides grouping for *, \+, and \=, as well as making matched subtexts available in the replacement part of a substitute command (\1, \2, etc.).

\1 
    Matches the same string that was matched by the first subexpression in \( and \). \2, \3 and so on may be used to represent the second, third, and so forth subexpressions.

The isident, iskeyword, isfname, and isprint options define the characters that appear in identifiers, keywords, and filenames, and that are printable, respectively.

		45.7.4 Command-Line History and Completion
			
			45.7.4.1 History commands 

Key			Meaning
 ^ |			Move up (previous), down (more recent) in the history
 | V
<- -> 			Move left, right on the recalled line
INS			Toggle insert/overstrike mode; default is insert mode
BACKSPACE		Delete characters
SHIFT or CONTROL	combined with or 	Move left or right one word at a time
^B or HOME		Move to the beginning of the command line
^E or END		Move to the end of the command line

If vim is in vi compatibility mode, ESC acts likes RETURN and executes the command. When vi compatibility is turned off, ESC exits the command line without executing anything.

The wildchar option contains the character you type when you want vim to do a completion. The default value is the tab character. You can use completion for the following:


Command names 
    Available at the start of the command line

Tag values 
    After you've typed :tag

Filenames 
    When typing a command that takes a filename argument (see :help suffixes for details)

Option values 
    When entering a :set command, for both option names and their values

			45.7.4.2 Completion commands

Command			Function
^D			List the names that match the pattern; for filenames, directories are highlighted
Value of wildchar	(Default: tab) Performs a match, inserting the generated text; hitting TAB successively cycles among all the matches
^N			Go to next of multiple wildchar matches, if any; otherwise recall more recent history line
^P			Go to previous of multiple wildchar matches, if any; otherwise recall older history line
^A			Insert all names that match the pattern
^L			If there is exactly one match, insert it; otherwise, expand to the longest common prefix of the multiple matches

		45.7.5 Tag Stacks

			45.7.5.1  Tag commands

Command				Function
ta[g][!] [tagstring]		Edit the file containing tagstring as defined in the tags file
[count]ta[g][!]			Jump to the count th newer entry in the tag stack
[count]po[p][!]			Pop a cursor position off the stack, restoring the cursor to its previous position
tags				Display the contents of the tag stack
ts[elect][!] [tagstring]	List the tags that match tagstring, using the information in the tags file(s)
sts[elect][!] [tagstring]	Like :tselect, but splits the window for the selected tag
[count]tn[ext][!]		Jump to the count th next matching tag (default 1)
[count]tp[revious][!]		Jump to the count th previous matching tag (default 1)
[count]tN[ext][!]
[count]tr[ewind][!]		Jump to the first matching tag; with count, jump to the count th matching tag
tl[ast][!]			Jump to the last matching tag

			45.7.5.2 Command-mode tag commands

Command				Function
^]				Look up the location of the identifier under the cursor in the tags file and move to that location; the current location is automatically pushed to the tag stack
g <LeftMouse>
CTRL-<LeftMouse>
^T				Return to the previous location in the tag stack, i.e., pop off one element

		45.7.6 Edit-Compile Speedup

			45.7.6.1 Program development commands

Command				Function
mak[e] [arguments]		Run make, based on the settings of several options as described in the next table, then go to the location of the first error
cf[ile][!] [errorfile]		Read the error file and jump to the first error
cl[ist][!]			List the errors that include a filename
[count]cn[ext][!]		Display the count th next error that includes a filename
[count]cN[ext][!]		Display the count th previous error that includes a filename

[count]cp[revious][!]
clast[!] [n]			Display error n if supplied; otherwise, display the last error
crewind[!] [n]			Display error n if supplied
cc[!] [n]			Displays error n if supplied, otherwise redisplays the current error
cq[uit]				Quit with an error code, so that the compiler won't compile the same file again; intended primarily for the Amiga compiler

			45.7.6.2  Program development options

Option			Value			Function
shell			/bin/sh			The shell to execute the command for rebuilding your program
makeprg			make			The program that actually handles the recompilation
shellpipe		2>&1| tee		Whatever is needed to cause the shell to save both standard output and standard error from the compilation in the error file
makeef			/tmp/vim##.err		The name of a file that will contain the compiler output; the ## causes vim to create unique filenames
errorformat		%f:%l:\ %m	A description of what error messages from the compiler look like; this example value is for GCC, the GNU C compiler

		45.7.7 Programming Assistance

			45.7.7.1 Indentation and formatting options

Option				Function
autoindent			Simple-minded indentation; uses that of the previous line
smartindent			Similar to autoindent, but knows a little about C syntax; deprecated in favor of cindent
cindent	Enables 		automatic indenting for C programs and is quite smart; C formatting is affected by the rest of the options in this table
cinkeys				Input keys that trigger indentation options
cinoptions			Tailor your preferred indentation style
cinwords			Keywords that start an extra indentation on the following line
formatoptions			A number of single-letter flags that control several behaviors, notably how comments are formatted as you type them
comments			Describes different formatting options for different kinds of comments, both those with starting and ending delimiters, as in C, and those that start with a single symbol and go to the end of the line, such as in a Makefile or shell program

			45.7.7.2 Identifier search commands

Command				Function
[i				Display the first line that contains the keyword under the cursor
]i				Display the first line that contains the keyword under the cursor, but starts the search at the current position in the file; this command is most effective when given a count
[I				Display all lines that contain the keyword under the cursor; filenames and line numbers are displayed
]I				Display all lines that contain the keyword under the cursor, but start from the current position in the file
[ ^I				Jump to the first occurrence of the keyword under the cursor
] ^I				Jump to the first occurrence of the keyword under the cursor, but start the search from the current position
^W i				Open a new window showing the location of the first (or count th) occurrence of the identifier under the cursor
^W ^I
[d				Display the first macro definition for the identifier under the cursor
]d				Display the first macro definition for the identifier under the cursor, but start the search from the current position
[D				Display all macro definitions for the identifier under the cursor; filenames and line numbers are displayed
]D				Display all macro definitions for the identifier under the cursor, but start the search from the current position
[ ^D				Jump to the first macro definition for the identifier under the cursor
] ^D				Jump to the first macro definition for the identifier under the cursor, but start the search from the current position
^W d				Open a new window showing the location of the first (or count th) macro definition of the identifier under the cursor
^W ^D

			45.7.7.3 Identifier search commands from ex mode

Command						Function
[range]is[earch][!] [count] [/]pattern[/]	Like [i and ]i but searches in range lines (the default is the whole file). Without the slashes, a word search is done; with slashes, a regular expression search is done
[range]il[ist][!] [/]pattern[/]			Like [I and ]I but searches in range lines; the default is the whole file
[range]ij[ump][!] [count] [/]pattern[/]		Like [ ^I and ] ^I but searches in range lines; the default is the whole file
[range]isp[lit][!] [count] [/]pattern[/]	Like ^W i and ^W ^I but searches in range lines; the default is the whole file
[range]ds[earch][!] [count] [/]pattern[/]	Like [d and ]d but searches in range lines; the default is the whole file
[range]dl[ist][!] [/]pattern[/]			Like [D and ]D but searches in range lines; the default is the whole file
[range]dj[ump][!] [count] [/]pattern[/]		Like [ ^D and ] ^D but searches in range lines. The default is the whole file.
[range]dsp[lit][!] [count] [/]pattern[/]	Like ^W d and ^W ^D but searches in range lines; the default is the whole file
che[ckpath][!]					List all the included files that couldn't be found; with the !, list all the included files

			45.7.7.4  Extended matching commands

Command			Function
%			Extended to match the /* and */ of C comments, and also the C preprocessor conditionals, (#if, #endif, etc.)
[(			Move to the count th previous unmatched (
[)			Move to the count th next unmatched )
[{			Move to the count th previous unmatched {
[}			Move to the count th next unmatched }
[#			Move to the count th previous unmatched #if or #else
]#			Move to the count th next unmatched #else or #endif
[*, [/			Move to the count th previous unmatched start of a C comment, /*
]*, ]/			Move to the count th next unmatched end of a C comment, */ 

		45.7.8 Vim 5.1 Set Options

Option			Default
background (bg)		dark or light
backspace (bs)		0
backup (bk)		nobackup
backupdir (bdir)		.,~/tmp/,~/
backupext (bex)		~
binary (bin)		nobinary
cindent (cin)		nocindent
cinkeys (cink)		0{,0},:,0#,!^F,o,O,e
cinoptions (cino)	 
cinwords (cinw)		if,else,while,do,for,switch
comments (com)	 
compatible (cp)		cp, nocp when a .vimrc file is found
cpoptions (cpo)		aABceFs
define (def)		^#\s*define
directory (dir)		.,~/tmp,/tmp
equalprg (ep)		 
errorfile (ef)		errors.err
errorformat (efm)	(Too long to print)
expandtab (et)		noexpandtab
fileformat (ff)		unix
fileformats (ffs)	dos,unix
formatoptions (fo)	vim default: tcq; vi default: vt
gdefault (gd)		nogdefault
guifont (gfn)	 
hidden (hid)		nohidden
hlsearch (hls)		hidnohlsearch, set on or off for highlithing last search pattern
history (hi)		hidvim default: 20; vi default: 0
icon	noicon
iconstring		hid 
include (inc)		hid^#\s*include
incsearch (is)		hidnoincsearch
isfname (isf)		hid@,48-57,/,.,-,_,+,,,$,:,~
isident (isi)		hid@,48-57,_,192-255
iskeyword (isk)		hid@,48-57,_,192-255
isprint (isp)		hid@,161-255
makeef (mef)		hid/tmp/vim##.err
makeprg (mp)		hidmake
mouse	 
mousehide (mh)		hidnomousehide
paste			nopaste
ruler (ru)		hidnoruler
secure			nosecure
shellpipe (sp)	 
shellredir (srr)	 
showmode (smd)		vim default: smd; vi default: nosmd
sidescroll (ss)		0
smartcase (scs)		nosmartcase
suffixes		*.bak,~,.o,.h,.info,.swp
taglength (tl)		0
tagrelative (tr)	vim default: tr; vi default: notr
tags (tag)		./tags,tags
tildeop (top)		notildeop
undolevels (ul)		1000
viminfo (vi)	 
writebackup (wb)	writebackup

46. Undo Branching

	46.1 description
	Say that you are editing a text file and have undone (u) the four last changes (4u)
	you continue edit and them realize you've made a mistake so you undo. In most editors your previous undo will be erased. Not in VIM, which actually will create a new branch of undo for the new change. You can get an overview of the undo branches using
	:undolist

	output is something along the lines of:
	number changes  time
	43      13  8 seconds ago
	44      13  4 seconds ago
	45      13  1 seconds ago 	
	
	Each line represent one undo branch and give its ID (number), number of changes (changes) and time of the branch creation.

	46.2 Usage
	
		46.2.1 go to a specific undo branch
	:undo N
	where N is the branch #

		46.2.2 traverse the undo list
		g-,g+ go backwards/forwards in the list of changes

		g- is not the same as u. u traverses the changes not in undo branches while g- traverses all the changes in every undo branch

		46.2.3 undo using edit time
		:earlier Ns
		:earlier Nm
		:earlier Nh

		:later Ns
		:later Nm
		:later Nh

		N is a number in seconds (s), minutes (m) or hours (h) you want to go back or forward to.
47. VIM Scripting
	
	
	47.1 Syntax-Color Schemes

	example,
	:syntax keyword myVars vim VIM
	:syntax match mySymbols ":-(){}[];="
	:syntax keyword myKeywords usage help script 
	:highlight myVars	ctermfg=red guifg=red
	:highlight mySymbols	ctermfg=blue guifg=blue
	:highlight myKeywords	ctermfg=green guifg=green
		
	Coloring is done once as VIM processes the syntax rules so the order matters.

	Add to this comments 
	:syntax match myComments "/\*.*\*/"
	:highlight myComments	ctermfg=yellow guifg=yellow

		47.1.1 Syntax regions
		Sometimes matching regions (like comments) using match could be difficult so there's a special command for regions that takes into account the start and end patterns of the region.

	Change the match for comments from:
	:syntax keyword myVars vim VIM
	:syntax match mySymbols ":-(){}[];="
	:syntax keyword myKeywords usage help script 
	:highlight myVars	ctermfg=red guifg=red
	:highlight mySymbols	ctermfg=blue guifg=blue
	:highlight myKeywords	ctermfg=green guifg=green
	:syntax match myComments "/\*.*\*/"
	:highlight myComments	ctermfg=yellow guifg=yellow

	:syntax keyword myVars vim VIM
	:syntax match mySymbols ":-(){}[];="
	:syntax keyword myKeywords usage help script 
	:highlight myVars	ctermfg=red guifg=red
	:highlight mySymbols	ctermfg=blue guifg=blue
	:highlight myKeywords	ctermfg=green guifg=green
	:syntax region myComments start=/\/\*/ end=/\*\//
	:highlight myComments	ctermfg=yellow guifg=yellow

	The region will easily match one line and multi line comments.

			47.1.1.1 Syntax regions in depth
			regions control more than start and end it also allows to set which items inside the region you want to color by the syntax rules, like for example keywords (TODO, OBSOLETE, FIXME)
			
			To add keywords we first define a group of keywords:
	:syntax keyword myKeywords OBSOLETE FIXME TODO

			Now modify the region command to contain the keywords:
	:syntax region myComments start=/\/\*/ end=/\*\// contains=myKeywords

			The region command supports multiple color groups so its possible to add more contains= flags.
			Note, Its possible to tell VIM to enforce one line regions by adding the option "oneline"
			to the syntax region command.

			Note, to allow a region to be nested add to "contained" keyword.

			Note, "contains" keyword can be set for more control to either of:
			ALL				- all defined keyword groups
			ALLBUT,group1, group2...	- all groups except the ones in the list
			CONTAINED			- only syntax groups that have the "contained" option
			TOP				- only syntax groups that don't have the "contained" option

			Note, in case its known that several syntax groups are often used together, then its possible to join them together into a cluster:
			:syntax cluster myCluster contains=myKeywords,mySymbols,myCondtions
			Then use the cluster by adding @ in front of the name:
	:syntax region myComments start=/\/\*/ end=/\*\// contains=@myCluster

		47.1.2 Syntax files
		The syntax directives needs to be combined in one file in the directory VIMHOME/syntax.
		The file name must be the name of the file type of the given language appended with .vim. for C language the file would be c.vim

		If the file type used is not know to VIM, then it needs to be registered first before the syntax file will work. This is done by adding some lines to <file type>.vim file in VIMHOME. If the file doesn't exist then first create it. For example to add the .my syntax in this example:
		augroup	filetypedetect
		autocmd	BufNewFile,BufRead *.my	setfiletype my
		augroup END

		The augroup command is used by VIM to differentiate file types (groups).
		autocmd commands run automatically. This command sets the file type to 'my' for files with extension .my. Now VIM automatically attempts to match a syntax file by looking in VIMHOME/syntax/my.vim.

			47.1.2.1 Syntax files additions, VIM post-processor
			Most languages already have well defined syntax files. What if you just want to tweak one a bit to your liking?- There are two options: First, find and edit the syntax file. The second is much better, VIM has post processing feature that allows to 

			To enable post-processing you need to add (or use) directory VIMHOME/after.
			Now whenever VIM looks for a script, syntax file or color scheme and find it, it will look for the same file in the 'after' directory.
			under 'after' create the same directory structure as under VIMHOME:
indent/
colors/
syntax/
autoload/
ftplugin/
plugin/

		47.1.3 Color scheme and syntax coloring
		Previous example we added highlighting color groups with the :syntax command.
		This gives complete control over the colors but also limits to just those colors and may not follow the colors defined by the color scheme currently in use.

		A better approach is to use the color groups already defined in VIM, and thereby split the color definition and syntax highlighting into two parts. This way, whenever the color scheme is changed so will the syntax coloring change accordingly.

		To find the list of all defined colors do:
		:highlight

	47.2 Scripts

		47.2.1 Script types
		
		"
			47.2.1.1 Scripts that add features to VIM
			Global, meaning initialized when VIM starts or when the user executes some specific call.
			File-Type, scripts that work on specific file types.

		47.2.2 Installing scripts
		Scripts come in three flavours
    -> 		As a single .vim file
    -> 		As a compressed file
    -> 		As a vimball, which is an automatic Vim script installation file

		To install a .vim file simply copy it to plugin or ftplugin dir (in case its a file-type script).
		On a multi user system, its possible to install to all users by copying no to your VIMHOME path but rather to the VIM installation location.

		The compressed file scripts usually contain the directory structure and only need to be extracted to VIMHOME. 

		The vimball, .vba file. For using them its required to install the vimball script (http://vim.sourceforge.net/scripts/script.php?script_id=1502)

		To install a .vba simply open it in VIM and run :source %
		This will install the script in the first place found in the runtimepath option in vim.
		To install elsewhere run :UseVimball path. 
		To view the contents of the vimball do :VimballList.

		47.2.3 Uninstalling scripts
		Uninstall is not supported for most scripts. To uninstall a script its required to manually remove its files.
		For vimball scripts however there's an uninstall, :RmVimball VIMBALLNAME

		47.2.4 Script development
			
			47.2.4.1 Script basics

				47.2.4.1.1 Types
				Two major types strings and numbers.

    -> 					Decimal number		:	1,3,4,10,100 etc
    -> 					Hexadecimal number	:	0x01,0x03,0x04,0x0A,0x64 etc
    -> 					Octal number		:	01,03,04,012,100 etc

					:echo 10+0xa+012
					should return 30

				Strings are either double quoted "str" or single quoted 'str'.
				" and ' or escaped via \, like "\"str\"". 
				Single quotes strings are also called literal strings, meaning special control characters can not be embedded in literal strings.
				For example "str\n" with put a new line after str, while 'str\n' will print exactly that.
				Some of the control characters available in VIM are:
    -> 				\n	newline
    -> 				\r	Carriage return (in dos/windows \r\n is newline)
    -> 				\t	tab
    -> 				\123	Octal number
    -> 				\x123	Hexadecimal number
    -> 				\u	Character encoded as up to 4 hex numbers
    -> 				\f	Form feed
    -> 				\e	Esc
    -> 				\b	Backspace
    -> 				\\	Backslash

				Besides those its possible to use VIM conventions by appending them with a backslash, like \<CR> \<ESC> \<C-W> etc

				47.2.4.1.2 Variables
				Five types:
				    -> String, i.e. "a string"
				    -> Number, i.e. 12 0xaf
				    -> List,  An ordered sequence of items
				    -> Dictionary, An unordered asscoiative array holding key-value pairs
				    -> Funcref, A reference to a function

				All variables are defined with the let command:
				:let myvar = VALUE
				Where VALUE depends on the variable type. 

					47.2.4.1.2.1 Strings and Ints
				Vim automatically converts between string and integer type according to context.
				Example:
				:let mystringvar = "12"
				:let mynumber = mystringvar -1
				
				Tip, Covener string to int by adding 0 to it.
				Conver int to string by :let mystr = string(mynum)

				Some examples of how automatic conversion works:
----------------------------------------------------------------------------------------------------
Input (types)			Result (type)
----------------------------------------------------------------------------------------------------
"hello"."world" (str.str)	"helloworld" (str)
----------------------------------------------------------------------------------------------------
"num".12			"num12" (str)
----------------------------------------------------------------------------------------------------
"12"+10				22 (num)
----------------------------------------------------------------------------------------------------
"12"-10." hits"			"2 hits" (str)
----------------------------------------------------------------------------------------------------
"12"-10+" hits"			2 (num)
----------------------------------------------------------------------------------------------------

					47.2.4.1.2.2 Lists
					Lists are defined using square brackets to enclose a comma spearated list of values.
					:let mylist = [1, 2, "str, 0x05, myvar]

					A list can contain other lists.
					:let mylist2 = [[1,2,3], ["a", "b"]]

					List can contain items of differing types.

					47.2.4.1.2.3 Dictionaries
					:let mydict = {1:"one", 2:"two", 3:"three"}
					This creates a dictionary with three items, where the key is the number and the value is the number spelled out with letters.

					Its possible to create dictionaries with nested dictionaries. Example:
					:let mydict1 = {1:"one", 2:"two", 3:"three", "nested":{0:"ten", 1:"eleven"}}
					
					Order between keys and key types do not matter.

					47.2.4.1.2.3 Function refs
					Contain a reference to a function that can be executed.
					Example:
					:let Myfunctorvar = function("Myfunc")

					This ties the function "Myfunc" to the variable Myfunctorvar.
					Notice that the variable name starts with a capital letter. This is because all user defined functions in VIM need to have a capital first letter in the name, and hence all function refs have the same limitation.
					To ude a funcref variable you see use it as a normal variable name, except that you add parentheses after the name, like:
					:echo Myfunctorvar()

					Altarnatively, it can be called with the "call" command:
					:call Myfunctorvar()
	
					If the function takes arguements, then these are added in the parentheses like Myfunctorvar(arg1, arg2, ..., argN)

					47.2.4.1.2.4 Variable scopes
					In VIM its the developer's responsibility to make the scope of variables.
					When no scope is given to a variable it will default to "global" scope, unless it is defined in a function, which binds it to the function scope.

					There are eight scopes in VIM:
						-> v:	Vim predefined global scope

						-> g:	Global scope

						-> b:	Buffer scope - Only available in the buffer where it was defined

						-> t:	Tab scope - Only available in the tab where it was defined 

						-> w:	Window scope - Only available in the window where it was defined 

						-> l:	Function scope - local to the function in which it was defined

						-> s:	Sourced file scope - local to a scripts loaded using :source

						-> a:	Argument scope - used in arguments for functions
						
						Note, comments in scripts are created by having a " as the first non-space character on the line: "This is a comment

						An exmaple for variable scopes:
						let g:sum=0

						function SumNumbers(num1, num2)
							let l:sum = a:num1+a:num2
							"Check if previous sum was lower than this

							if g:sum < l:sum
								let g:sum = l:sum
							endif
						endfunction

						"test
						call SumNumbers(3,4)
						"returns 7
						echo g:sum

				47.2.4.1.3 Conditions
				if condition
					code if true
				else/elseif 
					code if false
				endif

				condition can be made of val1 OPERATOR val2 
				OPERATOR can be either logical or string operator.

				logical operators:

					-> ==	equals
					-> !=	not equals
					-> >	higher
					-> <	lower
					-> >=	higher equals
					-> <=	lower equals

					Those operators can be used both on string and integer values (since VIM can automatically convert between those types).

				String operators
					-> =~ partial match, true if left string contains or equals right string
					-> !~ partial match, true if left string does not contain and is not equal to right string
					right hand string can be a regular expression pattern.

				47.2.4.1.4 Lists and dictionaries
				
				To access item i in list use [] operator, mylist[i]
				for nested lists (say i,j) use mylist[i][j]

				negative inices are allowed, they are converted to positive indices as follows:
				list size is n. index -i equals index n-i (count backwards from end of list)
				for example, last index in list is -1, or n-1.
				
				Adding items to list: 
					-> calling add
					:call add(mylist, 1)

					-> list concatenation
					:let mylist= [1,2,3]+[4,5,6]

					-> extend
					:call extend(mylist, [4,5,6])
					
					Note, add interperts the argument to add as one item to add to the list while extend interperts the item as a list of items. This means that add(mylist, [4,5,6]) will result in mylist being [1,2,3, [4,5,6]] while extend call will result in [1,2,3,4,5,6].

				Remove items from list:

					-> Remove:
					:call remove(mylist, 2)
					remove item with index 2 from list.

				Dictionaries.
				:let mydict = {1:"one", 2:"two", 3:"three"}

				Accessing entries is done using [] operator with key argument.
				:echo mydict[3]

				An alterntive way to access work only if the key is all ASCII, numbers or underscores.
				:echo mydict.3

				Lists are ordered, dictionaries are not

				Change value in dictionary:
				:let mydict[3] = "tres"

				:let mydict[4] = "cuatro"
				notice that first example changed an existing entry while the second has added a new entry.

				There is a similar mechanism to Python's list comprehension that applies to dictionaries and allows to "map" a function to all the dictionary entries. See the example below:

				let mynumbers = {0:'zero', 1:'one', 2:'two', 3:'three', 4:'four',...,9:'nine'}

				And map a function:
				function mynumbers.convert(numb) dict
					return join(map(split(a:numb, '\zs'), 'get(self, v:val, "unknown")'))
				endfunction

				Note that the function name contains the name of the dictionary variable and there is a keyword 'dict' after the function arguments. This keyword is what tell VIM this is a dictionary function and allows the use of a special variable 'self'. 'self' variable is refers to the dictionary to which the function is bound. so self[1] will return 'one'. 
				The function is made of the following parts:
				-> split	Splits a:numb into an unnamed list
					e.g:
					:let a = split("one two")
					:echo a;	"This prints "one"

				-> map		Maps a given command to every element in a list (the one from split). Note, this may modify the original list.:b1

					e.g.:
					:let mylist = ["one", "two", "three"]
					:call map(mylist, "<" . v:val . ">")
					:echo mylist[0]	"This prints <one>

				-> get	Gets values from "self" where key is equal to v:val (the value from map)
					e.g.:
					:let mylist2 = ["one", "two", "three"]
					:echo get(mylist2, 2, "none") "Prints three
					:echo get(mylist2, 3, "none") "Prints none

				-> join	Joins all elements returned by the map, get, combination
					e.g.:
					:let mylist3 = ["one", "two", "three"]
					:let mystring = join(mystring,"+")
					:echo mystring	"prints one+two+three

				(you can get help on each function by :h <func name>() e.g. :h join() )

				So, translated briefly, the function takes a range of digits (a:numb) and
				splits it into individual digits, then it uses each digit as a key to look up 
				the value in the dictionary (mynumbers, references as "self"), and joins
				all the returned values into a string by putting a whitespace between the values.

				So its possible to use this dictionary as a converter from numbers to written numbers such as:
				:echo mynumbers.conver(12345)
				"one two three four five"

				47.2.4.1.5 Loops
				VIM supports two loop types, for and while.

					47.2.4.1.5.1 For loops
					In its simplest form:
					for var in range
						do something
					endfor

					Example:
					for myvar in range(1,10)
						echo myvar
					endfor

					for mylist = ['a','b',...,'z']
					for itemvar in mylist
						echo itemvar
					endfor
					This one will print the abc

					Looping over dictionaries is a bit more complex because the loop variable is bound to the key, not the value. Example:
					let mydict = {a: "apple", b: "banana", c: "citrus"}
					for keyvar in keys(mydict)
						echo mydict[keyvar]
					endfor

					By default the keys will not be returned in any specific order in case its important to access them sorted use helper function sort, example:
					let mydict = {a: "apple", b: "banana", c: "citrus"}
					for keyvar in sort(keys(mydict))
						echo mydict[keyvar]
					endfor

					47.2.4.1.5.2 While loops
					In its simplest form:
					while condition
						do something
					endwhile

					while loop keywords are:
						-> break which ends the loop when called
						-> continue which skips the rest of loop and jumps to next iteration


			47.2.4.2 Creating functions
			Syntax of simple function:
			function Name(arg1, arg2, ..., argN) keyword
				code 
			endfunction

			Note, Function name must start with a capital letter. It can only contain letters, numbers and underscores.
			VIM supports up to 20 arguments passed to a function.

			The "keyword" is a hint for VIM of how this function is supposed to be exectuted. Example:
				-> dict		The function is bound to a dictionary
				-> range	The function is called once for a range a lines and not once for 
				each line that it is called on.

				Variables inside function code are local to the function and are not valid when the function has finished executing.
				To access a value of a variable from outside the function, either pass it as an argument or refer to a global variable (g:Var)
				Note, Passing a varibale as an argument to a function is always done by value. Meaning a local copy is made and any changes to it are not updated when the function has finished executing.

				An example of a simple function:
				function PrintSum(num1, num2)
					let sum = a:num1 + a:num2
					echo "the sum is ".sum
				endfunction

				The sum is local and not updated when the function terminates. To store the sum use global variable:
				function PrintSum(num1, num2)
					let sum = a:num1 + a:num2
					echo "the sum is ".sum
					let g:sum = sum
				endfunction
				
				A usage example:
				let sum = 0
				call PrintSum(4,5)
				echo sum
				This will print 9 since the global variable is updated.

				Now, since updating global variables is not considered a good practice, vim allows a cleaner way to update values - the "return" statement.
				Example:
				function PrintSum(num1, num2)
					let sum = a:num1 + a:num2
					echo "the sum is ".sum
					return sum
				endfunction

				used as follows:
				let sum = PrintSum(4,5)
				echo sum

				47.2.4.2.1 Variable argument list
				Synatx (arg1, agr2,...)
				Example:
				function PrintSum(num1, num2,...)
					let sum = a:num1 + a:num2
					let argnum = 1
					while argnum <= a:0
						let sum+= a:{argnum}
						let argnum+=1
					endwhile
					echo "the sum is " sum
					return sum
				endfunction

				"a:0" is a special varibale that stores the number of arguments that were given to the function.
				To access each of the variables use syntax, a{argnum} where argnum is the index of the argument.
				a:{} is the full list of optional arguments

				Another possible way to acheive the same is using "a:000" which passes all the optional arguments as a list. See example:
				function PrintSum(num1, num2,...)
					let sum = a:num1 + a:num2
					let argnum = 1
					for arg in a:000
						let sum+= arg
					endfor
					echo "the sum is " sum
					return sum
				endfunction

				To remove a function from current vim session do:
				:delfunction function-name

				Note, To see what a function does do:
				:function FunctionName
				To get a list of all functions do:
				:function

				Note, there are a lot of pre-existing helper funciton in VIM. To get a list of them do:
				:h function-list

			47.2.4.2 Script structure

				47.2.4.2.1 Header
				An example:
" myscript.vim			: Example script that does this and that...
" version			: 1.0.0
" Maintainer			: Yosi Izaq, izaqyos@gmail.com
" Last Modified			: 12/02/2008
" License			: This script is release under the VIM license.

				47.2.4.2.2 Was Script loaded check
				It is a good practice to check if the script has already been loaded, and if it has, then unload the function before continuing. This is a good check because the script is not only installed globaly on the system but also on the user's own VIMHOME.
				Example check:
				if exists("loaded_myscript")
					finish "Stop loading script"
				endif
				let loaded_myscript=1

				In some cases its not the best choice to just stop loading the script, because the user might have changed his version of the script (the one in VIMHOME). So instead of calling finish its possible to unload the functions and let the script create the again. This can looks like:
				if exists("loaded_myscript")
					delfunction	myGlobalFunctionA
					delfunction	myGlobalFunctionB
					delfunction	myGlobalFunctionC
					...
				endif
				let loaded_myscript=1

				Note, The user or may or may not be in "compatible" mode (compatibel to VI), so it may be a good idead to store the user's compatible mode, while in script. This makes it posisble to 

				47.2.4.2.3 Configuration
				Generally a good place for configuration settings is the start of the script, for this is where a user of a script will look for them first.
				A user of the script may want to change the settings in his vimrc file, and so the script must make sure not to overwrite those settings. To do this the script has to check that the settings do not already exist prior to setting them.
				Example:
				" variable myscript_path
				if !exists("myscript_path")
					let s:vimhomepath = split (&runtimepath, ',')
					let s:myscript_path = s:vimhomepath[0]."/plugin/myscript.vim"
				else
					let s:myscript_path = myscript_path
					unlet myscript_path
				endif

				" variable myscript_indent
				if !exists("myscript_indent")
					let s:myscript_indent = 4
				else
					let s:myscript_indent = myscript_indent
					unlet myscript_indent
				endif

				The example sets two configuration values - myscript_path and myscript_indent.
				It checks to see if they exist, and if not, it sets the default values in the script scope variable name (e.g. s:myscript_indent). If the user has already defined the variables, then this value is assigned to the script scope variable of the same name. Finally, the user-defined variable is removed with unlet, so it does not float around in global scope with no porpuse.

				47.2.4.2.4 Mappings
				Key mappings, either for calling functions, setting variables etc.
				The same principle as with configuration applies here, the mappings may have already been defiened so a check is required.
				Example:
				if !hasmapto('<Plug>MyscriptMyfunctionA')
					map <unique> <Leader>a <Plug>MyscriptMyfunctionA
				endif

				Explanation:
				-> hasmapto(), Function that checks if a mapping to a function already exists
				-> <unique>, This instructs VIM to give an error if a similar map exists
				-> <Leader>, Lets the user decide which map leader to use. <Leader> is replaced by the contents of the global variable mapleader
				-> <Plug>, This is a way to make a unique global identifier for a function

				-> The example checks if some mapping is already made for the unique function identifier <Plug>MyscriptMyfunctionA. If a map does not exist, then <Leader>a is mapped to the indentifier-unleas <Leader>a is already used and VIM instead gives an error.

				-> <Plug>MyscriptMyfunctionA maps to the actual function MyfunctionA() in the script as follows:
				noremap <unique> <script> <Plug>MyscriptMyfunctionA <SID>MyfunctionA
				noremap <SID>MyfunctionA :call <SID>MyfunctionA()<CR>

				The first mapping maps our unique <Plug>MyscriptMyfunctionA identifier to <SID>MyfunctionA. We use <SID> here, because this tag is exchanged with VIM's own unique ID for this script, and this is needed if we want to make a global mapping to a function that is only available in script scope (e.g. MyfunctionA).
				The second mapping binds the actual function (<SID>MyfunctionA(), which is s:MyfunctionA()) to the global mapping <SID>MyfunctionA.

				-> So what happens is when \a (having mapleader set the default "\"), then the first mapping translates this into <Plug>MyscriptMyfunctionA. This is defined in the script and hence the <SID> is now has the right value. Therefore <Plug>MyscriptMyfunctionA is again translated into <SID>MyfunctionA which is finally mapped to the actual call fo the local function s:MyfunctionA().

				-> All this sounds a bit complicated and a bit too much, but when your script contains functions with common names such as Add(), Delete() etc. its a must in order to prevent mapping conflicts.

				-> For further information see:
				:help <SID>
				:help <Plug>
				:help 'script-local'

				47.2.4.2.5 Functions
				Note, Unless a function is absolutely required in global scope, its best to put it into the script scope with s:.
				Example
"Local function with a mapping
function s:MyfunctionA()
		echo "Hello world from script scope function MyfunctionA"
endfunction

"This is a global function that can be called by anyone
function myGlobalFunctionB()
	echo "Hello world from global scope function myGlobalFunctionB"
endfunction

"This is another global function that can be called by anyone
function myGlobalFunctionC()
	echo "Hello world from global scope function myGlobalFunctionC(), now calling localy:"
	call <SID>MyfunctionA()
endfunction

The first function is a private function, only available in the script scope, while the two others are both available from global scope. Note, how its possible for one of the global functions to call the local function because it knows the correct SID for the current script.



				47.2.4.2.6 Putting it all together

An skeleton example of a VIM script:

" myscript.vim			: Example script that does this and that...
" version			: 1.0.0
" Maintainer			: Yosi Izaq, izaqyos@gmail.com
" Last Modified			: 12/02/2008
" License			: This script is release under the VIM license.


"Check is script was already loaded
				if exists("loaded_myscript")
					finish "Stop loading script"
				endif
				let loaded_myscript=1
"Configuration

				" variable myscript_path
				if !exists("myscript_path")
					let s:vimhomepath = split (&runtimepath, ',')
					let s:myscript_path = s:vimhomepath[0]."/plugin/myscript.vim"
				else
					let s:myscript_path = myscript_path
					unlet myscript_path
				endif

				" variable myscript_indent
				if !exists("myscript_indent")
					let s:myscript_indent = 4
				else
					let s:myscript_indent = myscript_indent
					unlet myscript_indent
				endif

" Functions

"Local function with a mapping
function s:MyfunctionA()
		echo "Hello world from script scope function MyfunctionA"
endfunction

"This is a global function that can be called by anyone
function myGlobalFunctionB()
	echo "Hello world from global scope function myGlobalFunctionB"
endfunction

"This is another global function that can be called by anyone
function myGlobalFunctionC()
	echo "Hello world from global scope function myGlobalFunctionC(), now calling localy:"
	call <SID>MyfunctionA()
endfunction

For further information, check vim help:
:h 'write-filetype-plugin'
:h 'write-compiler-plugin'
:h 'write-library-plugin'

		47.2.5 Scripting Tips

			47.2.5.1 gvim or vim?
			Some additional features are only available in gvim (like menus, toolbars, tabs etc).
			To check in your script whether or not gvim is running you can use the has function which returns true if a given feature is supported.
			Example:
			if has("gui_running")
				"execute gui only commands here
				"...
			endif

			Note, use :h 'feature-list' for a complete list of features that its possible to check with has()

			47.2.5.2 Which operating system?
			Determine which OS for making corresponding code.
			if has("win16") || has("win32") || has ("win64") || has ("win95") 
				"Windows OS, do windows code here
			elseif has("unix")
				"do Linux/unix things ere
			endif
	
			47.2.5.3 Which VIM version?
			Vim has deloped a lot and so has many versions with old versions missing functionality existing in newer versions. So any script should at least check for older versions of VIM and stop executing if that's the case. An even better option is to execute compatible code for each older version.

			VIM version numbers are made of three fields:
			-> Major number (e.g. 7 for VIM version 7)
			-> Minor number (e.g. 1 for VIM 7.1)
			-> Patch number (e.g. 123 for VIM 7.1.123)

			Code that checks version looks like:
			if v:version >= 702 || v:version >= 701 && has("patch123")
				"Code is done only for version 7.2 or 7.1.123
			endif
	
			47.2.5.4 Printing longer lines
			Since VIM was created for old text terminal it has a limitation on line length of 80 characters (by default). This means that echo statements for printing lines longer than 80 chars will prompt "please press enter" message to see the rest of the line. To avoid that its neccessary to increase the line length, see example:
			"WideMsg() prints (long) message up to (&columns -1) length
			funcion! WideMsg(msg)
				let x=&ruler | let y=&showcmd
				set noruler noshowcmd
				redraw
				echo a:msg
				let &ruler=x | let &showcmd=y
			endfunction

			Usage:
			:call WideMsg("Loooooong line of text...")


"
		47.2.9 Debugging scripts

			47.2.9.1 Start VIM in debug mode
			Add -D flag,

			vim -D file

			Debug sessions will start with VIM reading the first vimrc file

			Alternately, its possible to start VIM debug at a certain known point:
			-> For a function
			:debug call Myfunction()

			-> file/script
			:debug read script_file_name

			-> mapping
			:debug nmap ,a :call Myfunction() <CR>

			->help topic
			:debug help :debug

			47.2.9.2 Debug Session
			c, cont:	Continue running
			q:		Quit debugging session without executing the remaining lines
			s, step:	Step into file/function
			n, next:	Execute current line/function and continue to next one
			f, finish:	Continue executing the script without stopping on breakpoints. Continue debugging remaining scripts (if any).

			47.2.9.3 Breakpoints

				47.2.9.3.1 Add
				-> Function
				breakadd func linenum functionname

				Note, the function name can be a pattern, such as MyFunc*, this will add breakpoints to all functions whose names match the pattern.

				-> File, line
				breakadd file linenum filename

				-> Current line
				breakadd here

				-> From command line
				vim -D -c 'breakadd file 15 */.vimrc' 

				47.2.9.3.2 Revise
				get a list of breakpoints:
				:breaklist

				47.2.9.3.3 Remove
				
				-> By breakpoint number (from :breaklist)
				:breakdel number

				-> Function
				breakdel func linenum functionname

				Note, the function name can be a pattern, such as MyFunc*, this will add breakpoints to all functions whose names match the pattern.

				-> File, line
				breakdel file linenum filename

				-> Current line
				breakdel here

				-> All breakpoints
				breakdel *
				

		47.2.10 Distributing scripts

		Either is a single .vim script or, if multiple files are required, as a compressed archive with paths related to VIMHOME like:
		VIMHOME/plugin/myscript.vim
		VIMHOME/syntax/mylang.vim
		VIMHOME/doc/myscript.txt

		47.2.11 Making Vimballs
		To create a vimball:
		:[range]MKVimball filename.vba

		The procedure is as follows:
		-> run :enew to open a new empty buffer
		-> In this buffer add the paths to all the files (one per line) relative to your VIMHOME
		example:
		plugin/myscript.vim
		syntax/mylang.vim
		doc/myscript.txt

		-> Now execute the vimball command for the above range of lines.
		For example, go to first line and use shift-v to select all line with paths on.
		Now execute:
		:MKVimball myscript.vba


		47.2.12 Documentation
		Vim documentation is in the form of text files with some special markup.

		First line must start with * as the first char and look something like:
*docname.txt* single line of description

		The typically, longer description, credtits and a table of contents.
		Every markup work is between *.

		-> Examle, *myscript-intro* when added to introduction section will allow :help 'myscript-intro'
		to jumt right to this section

		-> Adding ~ after a word marks the line with a different color then the rest of the text, example:
		overview~

		-> words marked with || will tell VIM to create a link to the same word marked with *. Example

		|myscript-intro| in table of contents will create a link to *myscript-intro* section. To jump to links when reading help use ctrl-]

		-> Text sorrounded with <> is considered as source code

		To install the documentation the user needs to perform :helptags /path/to/doc/dir

		47.2.13 External Interpretrs
		Support for external interpertes is not builtin in VIM and you'll have to compile VIM to get it or get a precompiled package.

		To check which interpertrs your installed VIM supports run:
		$ vim --version
		and check for + or - prefix for python, perl and ruby.
		+, supported
		-, not supported

		Or when VIM is opened:
		:echo has("language name")
		returns 1 if the language is supported.

			47.2.13.1 Perl scripting in VIM

			47.2.13.2 Python scripting in VIM

			47.2.13.3 Ruby scripting in VIM

	47.3 Learn scripts from examples

		47.3.1 foo.vim 


		


	47.4

48. Folds. Folding
	48.1 folds are useful for providing readable and easy navigable view of the file.
	decides the criteria for creating folds.
foldmethod can be set to
manual manually created
indent based on indentation. Useful for python or other indented codes
marker based on foldmarker
Folding Commands
zf create fold
zo/zO open fold
zc/zC close fold
zM close all folds
zR open all folds
	:set foldmethod=manual/indent/marker
	:set foldmarker=, or <,>
	see :help Folding

	48.2 Manual
	Try  :set foldmethod=manual
	Then in a paragrap print zfap this will fold the paragrapgh.
	use zo to open the fold and zc to close.

	zf{motion}, try zfG to fold from current line to EOF or zf0 to start of file.
	{Visual}zf fold the visually selected text.
	zf{number} fold number lines. zf10 will fold the next 10 lines.
	:{range}fo fold the range :.,+10fo will do the same

	To save the folds do :mkview , to restore them do :loadview
	To save a specific fold :mkview n , to restore it :loadview n

	48.3 syntax

		48.3.1 CPP, C++
		To enable folds do
		: set foldmethod=syntax
		To fold all file
		:%fc

		or
		zM

		To unfold all file
		:%foldo

		or 
		zR


		48.3.2 Use folds in your program
Tip 108 (old #1093) created December 30, 2005 · author brailsmt 


		Instead of keeping zc and zo in your head, just use za to toggle a fold open or closed.

		If you open a file or change a fold method, and everything in your file is folded, use zR to "reveal" all of it by opening all folds.

		Try setting foldmethod=syntax. Many syntax files define folding based on the language syntax, although you may need to enable it by setting syntax file options. If a specific syntax file doesn't define folding, you can define your own or see below.

		Map [{V%zf (or even zfa{ which is easier) to some key sequence (I use <Leader><Leader>) to fold the current code block (in languages which use {,} as block delimiters).

			Use folds liberally. If you fold every function, when you open the file, you will be presented with a quick reference of what functions are defined in the file.

				Don't nest too many folds, it grows to be a pain if you use more than two levels of nested folds.

				If you think you need more than two levels of folds, you probably need to refactor your code. 

49. Ommni Copmletion

	49.1 See :help new-omni-completion

Omni completion support comes out of the box for several languages (e.g. C).

MS Windows users will also want to install [Exuberant Ctags | http://georgevreilly.com/vim/ctags.html].

C++ support

Try doing :set omnifunc while editing a C++ file.

If you get omnifunc=ccomplete#Complete as a result, it means you are presently using not C++, but the bundled C completion.

To get C++ completion support you can try installing OmniCppComplete. Please read the doc/omnicppcomplete.txt file in the archive for further help.

_Note:_ In *NIX these files go into your ~/.vim directory. In MS Windows you put them in %HOMEPATH%/vimfiles. 

50. Configure (setup) VIM

	50.1 A VIMRC setup system

	50.2 Example vimrc 
	http://amix.dk/vim/vimrc.html#Fileformats

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"          _
"      __ | \
"     /   | /
"     \__ | \
" by Amix - http://amix.dk/
"
" Maintainer: Amir Salihefendic <amix3k at gmail.com>
" Version: 2.7
" Last Change: 12/10/06 00:09:21
"
" Sections:
" ----------------------
" General
" Colors and Fonts
" Fileformats
" VIM userinterface
"    Statusline
" Visual
" Moving around and tabs
" General Autocommands
" Parenthesis/bracket expanding
" General Abbrevs
" Editing mappings etc.
" Command-line config
" Buffer realted
" Files and backups
" Folding
" Text options
"    Indent
" Spell checking
" Plugin configuration
"    Yank ring
"    File explorer
"    Minibuffer
"    Tag list (ctags) - not used
"    LaTeX Suite things
" Filetype generic
"    Todo
"    VIM
"    HTML related
"    Ruby & PHP section
"    Python section
"    Cheetah section
"    Vim section
"    Java section
"    JavaScript section
"    C mappings
"    SML
"    Scheme bindings
" Snippets
"    Python
"    javaScript
" Cope
" MISC
"
"  Tip:
"   If you find anything that you can't understand than do this:
"   help keyword OR helpgrep keywords
"  Example:
"   Go into command-line mode and type helpgrep nocompatible, ie.
"   :helpgrep nocompatible
"   then press <leader>c to see the results, or :botright cw
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" General
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Get out of VI's compatible mode..
set nocompatible

"Sets how many lines of history VIM har to remember
set history=400

"Enable filetype plugin
filetype plugin on
filetype indent on

"Set to auto read when a file is changed from the outside
set autoread

"Have the mouse enabled all the time:
set mouse=a

"Set mapleader
let mapleader = ","
let g:mapleader = ","

"Fast saving
nmap <leader>w :w!<cr>
nmap <leader>f :find<cr>

"Fast reloading of the .vimrc
map <leader>s :source ~/vim_local/vimrc<cr>
"Fast editing of .vimrc
map <leader>e :e! ~/vim_local/vimrc<cr>
"When .vimrc is edited, reload it
autocmd! bufwritepost vimrc source ~/vim_local/vimrc


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Colors and Fonts
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Enable syntax hl
syntax enable

"Set font to Monaco 10pt
if MySys() == "mac"
  set gfn=Bitstream\ Vera\ Sans\ Mono:h14
  set nomacatsui
  set termencoding=macroman
elseif MySys() == "linux"
  set gfn=Monospace\ 11
endif

if has("gui_running")
  set guioptions-=T
  let psc_style='cool'
  colorscheme ps_color
else
  set background=dark
  colorscheme zellner
endif

"Some nice mapping to switch syntax (useful if one mixes different languages in one file)
map <leader>1 :set syntax=cheetah<cr>
map <leader>2 :set syntax=xhtml<cr>
map <leader>3 :set syntax=python<cr>
map <leader>4 :set ft=javascript<cr>
map <leader>$ :syntax sync fromstart<cr>

autocmd BufEnter * :syntax sync fromstart

"Highlight current
if has("gui_running")
  set cursorline
  hi cursorline guibg=#333333
  hi CursorColumn guibg=#333333
endif

"Omni menu colors
hi Pmenu guibg=#333333
hi PmenuSel guibg=#555555 guifg=#ffffff


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Fileformats
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Favorite filetypes
set ffs=unix,dos,mac

nmap <leader>fd :se ff=dos<cr>
nmap <leader>fu :se ff=unix<cr>



"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" VIM userinterface
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Set 7 lines to the curors - when moving vertical..
set so=7

"Turn on WiLd menu
set wildmenu

"Always show current position
set ruler

"The commandbar is 2 high
set cmdheight=2

"Show line number
set nu

"Do not redraw, when running macros.. lazyredraw
set lz

"Change buffer - without saving
set hid

"Set backspace
set backspace=eol,start,indent

"Bbackspace and cursor keys wrap to
set whichwrap+=<,>,h,l

"Ignore case when searching
set ignorecase
set incsearch

"Set magic on
set magic

"No sound on errors.
set noerrorbells
set novisualbell
set t_vb=

"show matching bracets
set showmatch

"How many tenths of a second to blink
set mat=2

"Highlight search things
set hlsearch

  """"""""""""""""""""""""""""""
  " Statusline
  """"""""""""""""""""""""""""""
  "Always hide the statusline
  set laststatus=2

  function! CurDir()
     let curdir = substitute(getcwd(), '/Users/amir/', "~/", "g")
     return curdir
  endfunction

  "Format the statusline
  set statusline=\ %F%m%r%h\ %w\ \ CWD:\ %r%{CurDir()}%h\ \ \ Line:\ %l/%L:%c



""""""""""""""""""""""""""""""
" Visual
""""""""""""""""""""""""""""""
" From an idea by Michael Naumann
function! VisualSearch(direction) range
  let l:saved_reg = @"
  execute "normal! vgvy"
  let l:pattern = escape(@", '\\/.*$^~[]')
  let l:pattern = substitute(l:pattern, "\n$", "", "")
  if a:direction == 'b'
    execute "normal ?" . l:pattern . "^M"
  else
    execute "normal /" . l:pattern . "^M"
  endif
  let @/ = l:pattern
  let @" = l:saved_reg
endfunction

"Basically you press * or # to search for the current selection !! Really useful
vnoremap <silent> * :call VisualSearch('f')<CR>
vnoremap <silent> # :call VisualSearch('b')<CR>


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Moving around and tabs
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Map space to / and c-space to ?
map <space> /
map <c-space> ?

"Smart way to move btw. windows
map <C-j> <C-W>j
map <C-k> <C-W>k
map <C-h> <C-W>h
map <C-l> <C-W>l

"Actually, the tab does not switch buffers, but my arrows
"Bclose function ca be found in "Buffer related" section
map <leader>bd :Bclose<cr>
map <down> <leader>bd
"Use the arrows to something usefull
map <right> :bn<cr>
map <left> :bp<cr>

"Tab configuration
map <leader>tn :tabnew %<cr>
map <leader>te :tabedit
map <leader>tc :tabclose<cr>
map <leader>tm :tabmove
try
  set switchbuf=usetab
  set stal=2
catch
endtry

"Moving fast to front, back and 2 sides ;)
imap <m-$> <esc>$a
imap <m-0> <esc>0i
imap <D-$> <esc>$a
imap <D-0> <esc>0i


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" General Autocommands
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Switch to current dir
map <leader>cd :cd %:p:h<cr>


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Parenthesis/bracket expanding
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
vnoremap $1 <esc>`>a)<esc>`<i(<esc>
")
vnoremap $2 <esc>`>a]<esc>`<i[<esc>
vnoremap $3 <esc>`>a}<esc>`<i{<esc>
vnoremap $$ <esc>`>a"<esc>`<i"<esc>
vnoremap $q <esc>`>a'<esc>`<i'<esc>
vnoremap $w <esc>`>a"<esc>`<i"<esc>

"Map auto complete of (, ", ', [
inoremap $1 ()<esc>:let leavechar=")"<cr>i
inoremap $2 []<esc>:let leavechar="]"<cr>i
inoremap $4 {<esc>o}<esc>:let leavechar="}"<cr>O
inoremap $3 {}<esc>:let leavechar="}"<cr>i
inoremap $q ''<esc>:let leavechar="'"<cr>i
inoremap $w ""<esc>:let leavechar='"'<cr>i
au BufNewFile,BufRead *.\(vim\)\@! inoremap " ""<esc>:let leavechar='"'<cr>i
au BufNewFile,BufRead *.\(txt\)\@! inoremap ' ''<esc>:let leavechar="'"<cr>i

imap <m-l> <esc>:exec "normal f" . leavechar<cr>a
imap <d-l> <esc>:exec "normal f" . leavechar<cr>a


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" General Abbrevs
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"My information
iab xdate <c-r>=strftime("%d/%m/%y %H:%M:%S")<cr>
iab xname Amir Salihefendic


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Editing mappings etc.
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Remap VIM 0
map 0 ^

"Move a line of text using control
nmap <M-j> mz:m+<cr>`z
nmap <M-k> mz:m-2<cr>`z
vmap <M-j> :m'>+<cr>`<my`>mzgv`yo`z
vmap <M-k> :m'<-2<cr>`>my`<mzgv`yo`z

if MySys() == "mac"
  nmap <D-j> <M-j>
  nmap <D-k> <M-k>
  vmap <D-j> <M-j>
  vmap <D-k> <M-k>
endif

func! DeleteTrailingWS()
  exe "normal mz"
  %s/\s\+$//ge
  exe "normal `z"
endfunc
autocmd BufWrite *.py :call DeleteTrailingWS()

set completeopt=menu

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Command-line config
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
func! Cwd()
  let cwd = getcwd()
  return "e " . cwd 
endfunc

func! DeleteTillSlash()
  let g:cmd = getcmdline()
  if MySys() == "linux" || MySys() == "mac"
    let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*", "\\1", "")
  else
    let g:cmd_edited = substitute(g:cmd, "\\(.*\[\\\\]\\).*", "\\1", "")
  endif
  if g:cmd == g:cmd_edited
    if MySys() == "linux" || MySys() == "mac"
      let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*/", "\\1", "")
    else
      let g:cmd_edited = substitute(g:cmd, "\\(.*\[\\\\\]\\).*\[\\\\\]", "\\1", "")
    endif
  endif
  return g:cmd_edited
endfunc

func! CurrentFileDir(cmd)
  return a:cmd . " " . expand("%:p:h") . "/"
endfunc

"Smart mappings on the command line
cno $h e ~/
cno $d e ~/Desktop/
cno $j e ./

cno $q <C-\>eDeleteTillSlash()<cr>

cno $c e <C-\>eCurrentFileDir("e")<cr>

cno $tc <C-\>eCurrentFileDir("tabnew")<cr>
cno $th tabnew ~/
cno $td tabnew ~/Desktop/

"Bash like
cnoremap <C-A>    <Home>
cnoremap <C-E>    <End>
cnoremap <C-K>    <C-U>


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Buffer realted
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Fast open a buffer by search for a name
map <c-q> :sb

"Open a dummy buffer for paste
map <leader>q :e ~/buffer<cr>

"Restore cursor to file position in previous editing session
set viminfo='10,\"100,:20,%,n~/.viminfo
au BufReadPost * if line("'\"") > 0|if line("'\"") <= line("$")|exe("norm '\"")|else|exe "norm $"|endif|endif

" Buffer - reverse everything ... :)
map <F9> ggVGg?

" Don't close window, when deleting a buffer
command! Bclose call <SID>BufcloseCloseIt()

function! <SID>BufcloseCloseIt()
   let l:currentBufNum = bufnr("%")
   let l:alternateBufNum = bufnr("#")

   if buflisted(l:alternateBufNum)
     buffer #
   else
     bnext
   endif

   if bufnr("%") == l:currentBufNum
     new
   endif

   if buflisted(l:currentBufNum)
     execute("bdelete! ".l:currentBufNum)
   endif
endfunction


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Files and backups
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Turn backup off
set nobackup
set nowb
set noswapfile


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Folding
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Enable folding, I find it very useful
set nofen
set fdl=0


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Text options
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set expandtab
set shiftwidth=2

map <leader>t2 :set shiftwidth=2<cr>
map <leader>t4 :set shiftwidth=4<cr>
au FileType html,python,vim,javascript setl shiftwidth=2
au FileType html,python,vim,javascript setl tabstop=2
au FileType java setl shiftwidth=4
au FileType java setl tabstop=4

set smarttab
set lbr
set tw=500

   """"""""""""""""""""""""""""""
   " Indent
   """"""""""""""""""""""""""""""
   "Auto indent
   set ai

   "Smart indet
   set si

   "C-style indeting
   set cindent

   "Wrap lines
   set wrap


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Spell checking
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
map <leader>sn ]s
map <leader>sp [s
map <leader>sa zg
map <leader>s? z=


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Plugin configuration
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
   """"""""""""""""""""""""""""""
   " Vim Grep
   """"""""""""""""""""""""""""""
   let Grep_Skip_Dirs = 'RCS CVS SCCS .svn'
   let Grep_Cygwin_Find = 1

   """"""""""""""""""""""""""""""
   " Yank Ring
   """"""""""""""""""""""""""""""
   map <leader>y :YRShow<cr>

   """"""""""""""""""""""""""""""
   " File explorer
   """"""""""""""""""""""""""""""
   "Split vertically
   let g:explVertical=1

   "Window size
   let g:explWinSize=35

   let g:explSplitLeft=1
   let g:explSplitBelow=1

   "Hide some files
   let g:explHideFiles='^\.,.*\.class$,.*\.swp$,.*\.pyc$,.*\.swo$,\.DS_Store$'

   "Hide the help thing..
   let g:explDetailedHelp=0


   """"""""""""""""""""""""""""""
   " Minibuffer
   """"""""""""""""""""""""""""""
   let g:miniBufExplModSelTarget = 1
   let g:miniBufExplorerMoreThanOne = 2
   let g:miniBufExplModSelTarget = 0
   let g:miniBufExplUseSingleClick = 1
   let g:miniBufExplMapWindowNavVim = 1
   let g:miniBufExplVSplit = 25
   let g:miniBufExplSplitBelow=1

   let g:bufExplorerSortBy = "name"

   autocmd BufRead,BufNew :call UMiniBufExplorer


   """"""""""""""""""""""""""""""
   " Tag list (ctags) - not used
   """"""""""""""""""""""""""""""
   "let Tlist_Ctags_Cmd = "/sw/bin/ctags-exuberant"
   "let Tlist_Sort_Type = "name"
   "let Tlist_Show_Menu = 1
   "map <leader>t :Tlist<cr>


   """"""""""""""""""""""""""""""
   " LaTeX Suite things
   """"""""""""""""""""""""""""""
   set grepprg=grep\ -nH\ $*
   let g:Tex_DefaultTargetFormat="pdf"
   let g:Tex_ViewRule_pdf='xpdf'

   "Bindings
   autocmd FileType tex map <silent><leader><space> :w!<cr> :silent! call Tex_RunLaTeX()<cr>

   "Auto complete some things ;)
   autocmd FileType tex inoremap $i \indent
   autocmd FileType tex inoremap $* \cdot
   autocmd FileType tex inoremap $i \item
   autocmd FileType tex inoremap $m \[<cr>\]<esc>O


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Filetype generic
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
   """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
   " Todo
   """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
   au BufNewFile,BufRead *.todo so ~/vim_local/syntax/amido.vim

   """"""""""""""""""""""""""""""
   " VIM
   """"""""""""""""""""""""""""""
   autocmd FileType vim map <buffer> <leader><space> :w!<cr>:source %<cr>


   """"""""""""""""""""""""""""""
   " HTML related
   """"""""""""""""""""""""""""""
   " HTML entities - used by xml edit plugin
   let xml_use_xhtml = 1
   "let xml_no_auto_nesting = 1

   "To HTML
   let html_use_css = 1
   let html_number_lines = 0
   let use_xhtml = 1


   """"""""""""""""""""""""""""""
   " Ruby & PHP section
   """"""""""""""""""""""""""""""
   autocmd FileType ruby map <buffer> <leader><space> :w!<cr>:!ruby %<cr>
   autocmd FileType php compiler php
   autocmd FileType php map <buffer> <leader><space> <leader>cd:w<cr>:make %<cr>


   """"""""""""""""""""""""""""""
   " Python section
   """"""""""""""""""""""""""""""
   "Run the current buffer in python - ie. on leader+space
   au FileType python so ~/vim_local/syntax/python.vim
   autocmd FileType python map <buffer> <leader><space> :w!<cr>:!python %<cr>
   autocmd FileType python so ~/vim_local/plugin/python_fold.vim

   "Set some bindings up for 'compile' of python
   autocmd FileType python set makeprg=python\ -c\ \"import\ py_compile,sys;\ sys.stderr=sys.stdout;\ py_compile.compile(r'%')\"
   autocmd FileType python set efm=%C\ %.%#,%A\ \ File\ \"%f\"\\,\ line\ %l%.%#,%Z%[%^\ ]%\\@=%m

   "Python iMaps
   au FileType python set cindent
   au FileType python inoremap <buffer> $r return
   au FileType python inoremap <buffer> $s self
   au FileType python inoremap <buffer> $c ##<cr>#<space><cr>#<esc>kla
   au FileType python inoremap <buffer> $i import
   au FileType python inoremap <buffer> $p print
   au FileType python inoremap <buffer> $d """<cr>"""<esc>O

   "Run in the Python interpreter
   function! Python_Eval_VSplit() range
     let src = tempname()
     let dst = tempname()
     execute ": " . a:firstline . "," . a:lastline . "w " . src
     execute ":!python " . src . " > " . dst
     execute ":pedit! " . dst
   endfunction
   au FileType python vmap <F7> :call Python_Eval_VSplit()<cr>

   """"""""""""""""""""""""""""""
   " Cheetah section
   """""""""""""""""""""""""""""""
   autocmd FileType cheetah set ft=xml
   autocmd FileType cheetah set syntax=cheetah

   """""""""""""""""""""""""""""""
   " Vim section
   """""""""""""""""""""""""""""""
   autocmd FileType vim set nofen

   """""""""""""""""""""""""""""""
   " Java section
   """""""""""""""""""""""""""""""
   au FileType java inoremap <buffer> <C-t> System.out.println();<esc>hi

   "Java comments
   autocmd FileType java source ~/vim_local/macros/jcommenter.vim
   autocmd FileType java let b:jcommenter_class_author='Amir Salihefendic (amix@amix.dk)'
   autocmd FileType java let b:jcommenter_file_author='Amir Salihefendic (amix@amix.dk)'
   autocmd FileType java map <buffer> <F2> :call JCommentWriter()<cr>

   "Abbr'z
   autocmd FileType java inoremap <buffer> $pr private
   autocmd FileType java inoremap <buffer> $r return
   autocmd FileType java inoremap <buffer> $pu public
   autocmd FileType java inoremap <buffer> $i import
   autocmd FileType java inoremap <buffer> $b boolean
   autocmd FileType java inoremap <buffer> $v void
   autocmd FileType java inoremap <buffer> $s String

   "Folding
   function! JavaFold()
     setl foldmethod=syntax
     setl foldlevelstart=1
     syn region foldBraces start=/{/ end=/}/ transparent fold keepend extend
     syn match foldImports /\(\n\?import.\+;\n\)\+/ transparent fold

     function! FoldText()
       return substitute(getline(v:foldstart), '{.*', '{...}', '')
     endfunction
     setl foldtext=FoldText()
   endfunction
   au FileType java call JavaFold()
   au FileType java setl fen

   au BufEnter *.sablecc,*.scc set ft=sablecc

   """"""""""""""""""""""""""""""
   " JavaScript section
   """""""""""""""""""""""""""""""
   au FileType javascript so ~/vim_local/syntax/javascript.vim
   function! JavaScriptFold()
     setl foldmethod=syntax
     setl foldlevelstart=1
     syn region foldBraces start=/{/ end=/}/ transparent fold keepend extend

     function! FoldText()
       return substitute(getline(v:foldstart), '{.*', '{...}', '')
     endfunction
     setl foldtext=FoldText()
   endfunction
   au FileType javascript call JavaScriptFold()
   au FileType javascript setl fen

   au FileType javascript imap <c-t> console.log();<esc>hi
   au FileType javascript imap <c-a> alert();<esc>hi
   au FileType javascript setl nocindent
   au FileType javascript inoremap <buffer> $r return

   au FileType javascript inoremap <buffer> $d //<cr>//<cr>//<esc>ka<space>
   au FileType javascript inoremap <buffer> $c /**<cr><space><cr>**/<esc>ka


   """"""""""""""""""""""""""""""
   " HTML
   """""""""""""""""""""""""""""""
   au FileType html,cheetah set ft=xml
   au FileType html,cheetah set syntax=html


   """"""""""""""""""""""""""""""
   " C mappings
   """""""""""""""""""""""""""""""
   autocmd FileType c map <buffer> <leader><space> :w<cr>:!gcc %<cr>


   """""""""""""""""""""""""""""""
   " SML
   """""""""""""""""""""""""""""""
   autocmd FileType sml map <silent> <buffer> <leader><space> <leader>cd:w<cr>:!sml %<cr>


   """"""""""""""""""""""""""""""
   " Scheme bidings
   """"""""""""""""""""""""""""""
   autocmd BufNewFile,BufRead *.scm map <buffer> <leader><space> <leader>cd:w<cr>:!petite %<cr>
   autocmd BufNewFile,BufRead *.scm inoremap <buffer> <C-t> (pretty-print )<esc>i
   autocmd BufNewFile,BufRead *.scm vnoremap <C-t> <esc>`>a)<esc>`<i(pretty-print <esc>


   """"""""""""""""""""""""""""""
   " SVN section
   """""""""""""""""""""""""""""""
   map <F8> :new<CR>:read !svn diff<CR>:set syntax=diff buftype=nofile<CR>gg


""""""""""""""""""""""""""""""
" Snippets
"""""""""""""""""""""""""""""""
   "You can use <c-j> to goto the next <++> - it is pretty smart ;)

   """""""""""""""""""""""""""""""
   " Python
   """""""""""""""""""""""""""""""
   autocmd FileType python inorea <buffer> cfun <c-r>=IMAP_PutTextWithMovement("def <++>(<++>):\n<++>\nreturn <++>")<cr>
   autocmd FileType python inorea <buffer> cclass <c-r>=IMAP_PutTextWithMovement("class <++>:\n<++>")<cr>
   autocmd FileType python inorea <buffer> cfor <c-r>=IMAP_PutTextWithMovement("for <++> in <++>:\n<++>")<cr>
   autocmd FileType python inorea <buffer> cif <c-r>=IMAP_PutTextWithMovement("if <++>:\n<++>")<cr>
   autocmd FileType python inorea <buffer> cifelse <c-r>=IMAP_PutTextWithMovement("if <++>:\n<++>\nelse:\n<++>")<cr>


   """""""""""""""""""""""""""""""
   " JavaScript
   """""""""""""""""""""""""""""""
   autocmd FileType cheetah,html,javascript inorea <buffer> cfun <c-r>=IMAP_PutTextWithMovement("function <++>(<++>) {\n<++>;\nreturn <++>;\n}")<cr>
   autocmd filetype cheetah,html,javascript inorea <buffer> cfor <c-r>=IMAP_PutTextWithMovement("for(<++>; <++>; <++>) {\n<++>;\n}")<cr>
   autocmd FileType cheetah,html,javascript inorea <buffer> cif <c-r>=IMAP_PutTextWithMovement("if(<++>) {\n<++>;\n}")<cr>
   autocmd FileType cheetah,html,javascript inorea <buffer> cifelse <c-r>=IMAP_PutTextWithMovement("if(<++>) {\n<++>;\n}\nelse {\n<++>;\n}")<cr>


   """""""""""""""""""""""""""""""
   " HTML
   """""""""""""""""""""""""""""""
   autocmd FileType cheetah,html inorea <buffer> cahref <c-r>=IMAP_PutTextWithMovement('<a href="<++>"><++></a>')<cr>
   autocmd FileType cheetah,html inorea <buffer> cbold <c-r>=IMAP_PutTextWithMovement('<b><++></b>')<cr>
   autocmd FileType cheetah,html inorea <buffer> cimg <c-r>=IMAP_PutTextWithMovement('<img src="<++>" alt="<++>" />')<cr>
   autocmd FileType cheetah,html inorea <buffer> cpara <c-r>=IMAP_PutTextWithMovement('<p><++></p>')<cr>
   autocmd FileType cheetah,html inorea <buffer> ctag <c-r>=IMAP_PutTextWithMovement('<<++>><++></<++>>')<cr>
   autocmd FileType cheetah,html inorea <buffer> ctag1 <c-r>=IMAP_PutTextWithMovement("<<++>><cr><++><cr></<++>>")<cr>


   """""""""""""""""""""""""""""""
   " Java
   """""""""""""""""""""""""""""""
   autocmd FileType java inorea <buffer> cfun <c-r>=IMAP_PutTextWithMovement("public<++> <++>(<++>) {\n<++>;\nreturn <++>;\n}")<cr>
   autocmd FileType java inorea <buffer> cfunpr <c-r>=IMAP_PutTextWithMovement("private<++> <++>(<++>) {\n<++>;\nreturn <++>;\n}")<cr>
   autocmd FileType java inorea <buffer> cfor <c-r>=IMAP_PutTextWithMovement("for(<++>; <++>; <++>) {\n<++>;\n}")<cr>
   autocmd FileType java inorea <buffer> cif <c-r>=IMAP_PutTextWithMovement("if(<++>) {\n<++>;\n}")<cr>
   autocmd FileType java inorea <buffer> cifelse <c-r>=IMAP_PutTextWithMovement("if(<++>) {\n<++>;\n}\nelse {\n<++>;\n}")<cr>
   autocmd FileType java inorea <buffer> cclass <c-r>=IMAP_PutTextWithMovement("class <++> <++> {\n<++>\n}")<cr>
   autocmd FileType java inorea <buffer> cmain <c-r>=IMAP_PutTextWithMovement("public static void main(String[] argv) {\n<++>\n}")<cr>


   "Presse c-q insted of space (or other key) to complete the snippet
   imap <C-q> <C-]>


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Cope
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"For Cope
map <silent> <leader><cr> :noh<cr>

"Orginal for all
map <leader>n :cn<cr>
map <leader>p :cp<cr>
map <leader>c :botright cw 10<cr>
map <c-u> <c-l><c-j>:q<cr>:botright cw 10<cr>


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" MISC
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Remove the Windows ^M
noremap <Leader>m mmHmt:%s/<C-V><cr>//ge<cr>'tzt'm

"Paste toggle - when pasting something in, don't indent.
set pastetoggle=<F3>

"Remove indenting on empty lines
map <F2> :%s/\s*$//g<cr>:noh<cr>''

"Super paste
inoremap <C-v> <esc>:set paste<cr>mui<C-R>+<esc>mv'uV'v=:set nopaste<cr>

"A function that inserts links & anchors on a TOhtml export.
" Notice:
" Syntax used is:
" Link
" Anchor
function! SmartTOHtml()
   TOhtml
   try
    %s/&quot;\s\+\*&gt; \(.\+\)</" <a href="#\1" style="color: cyan">\1<\/a></g
    %s/&quot;\(-\|\s\)\+\*&gt; \(.\+\)</" \&nbsp;\&nbsp; <a href="#\2" style="color: cyan;">\2<\/a></g
    %s/&quot;\s\+=&gt; \(.\+\)</" <a name="\1" style="color: #fff">\1<\/a></g
   catch
   endtry
   exe ":write!"
   exe ":bd"
endfunction


	50.3
51. Install VIM, vim_install, install_vim, VIM patches, install patches

	51.1  On Linux by compiling the sources
-> DL sources from http://www.vim.org/sources.php
or git clone https://github.com/b4winckler/vim

-> Copy to location on LNX machine, example
[yizaq@yizaq-lnx:Tue Nov 04:~/temp/vim_7_2]$

-> For default installation just do 
./configure; make; sudo make install

		51.1.1  Add features
		-> 
./configure \
    --prefix=/usr/local/vim-7.4 \
    --enable-perlinterp \
    --enable-pythoninterp \
    --enable-rubyinterp \
    --enable-cscope \
    --enable-gui=auto \
    --enable-gtk2-check \
    --enable-gnome-check \
    --with-features=huge \
    --enable-multibyte \
    --with-x \
    --with-compiledby="Yosi Izaq" \
    --with-python-config-dir=/usr/lib/python2.4/config

-> For customized install edit the file src/Makefile
for example, to enable cscope uncomment line 
CONF_OPT_CSCOPE = --enable-cscope

Or for example, add support for +signs.
You need --with-features=big (or --with-features=huge)
The reference is the B in the first column of ":help +signs".
So in Makefile uncomment line 
CONF_OPT_FEAT = --with-features=big


Then do:
make distclean; make config; make; sudo make install
break this chain up in case of issues

	51.2 on Windows

see: <URL:#r=__vim_wo_cream__>

	51.3 More on installation for linux

		51.3.1  Some suggestions, didn't work for me
 Vim 7 on Red Hat Enterprise Linux (RHEL) October 15, 2010

Following my last post I moved on to installing Vim 7.x as the one that comes with RHEL 4 is pretty outdated (6.x).
Vim 7.2 from SVN

Tested on RHEL 4 i386:

$ cd ~
$ svn co https://vim.svn.sourceforge.net/svnroot/vim/vim7
$ cd vim7
$ ./configure —prefix=/usr —with-features=huge —disable-gui —without-x —enable-rubyinterp —enable-cscope —enable-multibyte
$ make && make install
$ vim —version
VIM – Vi IMproved 7.2 (2008 Aug 9)

Vim 7.3 from Mercurial

Tested on RHEL 5 x86_64:

$ cd ~
$ yum install hg ncurses-devel
$ hg clone https://vim.googlecode.com/hg/ vim
$ cd vim
$ ./configure —prefix=/usr —with-features=huge —disable-gui —without-x —enable-rubyinterp —enable-cscope —enable-multibyte
$ make && make install
$ vim —version
VIM – Vi IMproved 7.3 (2010 Aug 15)

RHEL 4 comes with up2date. I tried -i mercurial and -i hg, but both failed. Vim offers an archived download so you can skip steps 3-4 above and instead use:

# [..]
$ wget ftp://ftp.vim.org/pub/vim/unix/vim-7.3.tar.bz2
$ tar xjvf vim-7.3.tar.bz2
$ cd vim73
# [..]



		51.3.2 Manually, my example
		- best way to get most recent version (w/ patches)
git clone https://github.com/vim/vim.git
[root@gpk0128-pod tmp]# cd vim && git fetch && git merge
Already up-to-date.

-or manually compile and buid
cd vim/src
./configure --with-features=huge \
            --enable-multibyte \
            --enable-pythoninterp \
            --enable-perlinterp \
            --enable-luainterp \
            --enable-gui=gtk2 --enable-cscope --prefix=/usr






- Old way
E2E example w/o mercurial :
- su
- cd /tmp ; mkdir vim ; cd vim

- vim latest patches; ftp://ftp.vim.org/pub/vim/patches/7.4/
- PNUM="914"
cd .. && mkdir patches
for v in $( seq -f "%03g" ${PNUM} ) ; do  wget ftp://ftp.vim.org/pub/vim/patches/7.4/7.4.$v ; done
cd ..  
	
( pre-2015 way: wget ftp://ftp.vim.org/pub/vim/unix/vim-7.4.tar.bz2
bunzip2  vim-7.4.tar.bz2 ; tar xvf vim-7.4.tar ; cd vim74/
)

	[root@pmbu-dev-vm22 vim74]# for v in $( seq -f "%03g" ${PNUM} ) ; do patch -p0 < ../patches/7.4.$v >& ../patch_install_p_7_4.$v.log; done

./configure --with-features=huge \
            --enable-multibyte \
            --enable-rubyinterp \
            --enable-pythoninterp \
            --with-python-config-dir=/usr/lib/python2.4/config \
            --enable-perlinterp \
            --enable-luainterp \
            --enable-gui=gtk2 --enable-cscope --prefix=/usr
make
make install 
----------------------------------------------------------------------------------------------------
Possible issues
- [root@gpk0128-pod vim]# /usr/bin/vim --version
/usr/bin/vim: error while loading shared libraries: libperl.so: cannot open shared object file: No such file or directory
	-- fix:
[root@gpk0128-pod vim]# ln -s /usr/lib64/perl5/5.10.0/x86_64-linux-thread-multi/CORE/libperl.so /usr/lib64/libperl.so
[root@gpk0128-pod vim]# /usr/bin/vim --version
VIM - Vi IMproved 7.4 (2013 Aug 10, compiled Nov 12 2015 10:59:04)
Included patches: 1-922
Compiled by yizaq@gpk0128-pod
Huge version without GUI.  Features included (+) or not (-):
+acl             +farsi           +mouse_netterm   +syntax
+arabic          +file_in_path    +mouse_sgr       +tag_binary

- 
[yizaq@yizaq-dev:Wed Nov 26:134:5:/trunk]$ vim --version
/usr/bin/vim: error while loading shared libraries: libperl.so: cannot open shared object file: No such file or directory

fix: 
	-- on RH5
[root@yizaq-dev vim74]# locate libperl.so
/usr/NX/lib/perl/libperl.so
/usr/lib64/perl5/5.10.0/x86_64-linux-thread-multi/CORE/libperl.so
/usr/lib64/perl5/CORE/libperl.so
[root@yizaq-dev vim74]# ln -s /usr/lib64/perl5/CORE/libperl.so /usr/lib/libperl.so
[root@yizaq-dev vim74]# ln -s /usr/lib64/perl5/CORE/libperl.so /usr/lib64/libperl.so

	-- on RH6
[yizaq@csi-pmbu17-lnx:Fri Feb 19:1038:43:/tmp/vim]$ locate libperl.so
/usr/lib64/perl5/5.10.0/x86_64-linux-thread-multi/CORE/libperl.so
/usr/lib64/perl5/CORE/libperl.so
[yizaq@csi-pmbu17-lnx:Fri Feb 19:1039:44:/tmp/vim]$ sudo ln -s /usr/lib64/perl5/CORE/libperl.so /usr/lib/libperl.so
[yizaq@csi-pmbu17-lnx:Fri Feb 19:1040:45:/tmp/vim]$ sudo ln -s /usr/lib64/perl5/CORE/libperl.so /usr/lib64/libperl.so

-
----------------------------------------------------------------------------------------------------
- su
- cd /tmp ; mkdir vim ; cd vim
- 7.3: wget ftp://ftp.vim.org/pub/vim/unix/vim-7.3.tar.bz2
- 7.4: wget ftp://ftp.vim.org/pub/vim/unix/vim-7.4.tar.bz2
- ls
- mkdir patches ;  cd patches/
- PNUM="179"
- 7.3:
	for v in $( seq -f "%03g" ${PNUM} ) ; do  wget ftp://ftp.vim.org/pub/vim/patches/7.3/7.3.$v ; done
	- cd .. ; bunzip2  vim-7.3.tar.bz2 ; tar xvf vim-7.3.tar
	[root@cow1 vim]# cd vim73/
	- [root@pmbu-dev-vm22 vim73]# pwd
	/root/temp/vim/vim73
	- [root@pmbu-dev-vm22 vim73]# for v in $( seq -f "%03g" ${PNUM} ) ; do patch -p0 < ../patches/7.3.$v >& ../patch_install_p_7_3.$v.log; done
- 7.4:
	for v in $( seq -f "%03g" ${PNUM} ) ; do  wget ftp://ftp.vim.org/pub/vim/patches/7.4/7.4.$v ; done
	- cd .. ; bunzip2  vim-7.4.tar.bz2 ; tar xvf vim-7.4.tar ; cd vim74/
	- [root@pmbu-dev-vm22 vim74]# pwd
	/root/temp/vim/vim74
	- [root@pmbu-dev-vm22 vim74]# for v in $( seq -f "%03g" ${PNUM} ) ; do patch -p0 < ../patches/7.4.$v >& ../patch_install_p_7_4.$v.log; done
- configure
or to add feature
configure --enable-pythoninterp --enable-rubyinterp --enable-python3interp --enable-cscope --enable-perlinterp --with-features=huge
[root@yizaq-lnx vim73]# configure  --enable-rubyinterp  --enable-cscope --enable-perlinterp --with-features=huge
- make
	- Note how to fix checking for tgetent()... configure: error: NOT FOUND!
[root@pmbu-dev-vm58 vim74]# yum install ncurses-devel.x86_64
[root@pmbu-dev-vm58 vim74]# configure  --enable-rubyinterp  --enable-cscope --enable-perlinterp --with-features=huge --with-tlib=ncurses
	- os_unix.c:45:30: error: selinux/selinux.h: No such file or directory
[root@pmbu-dev-vm58 vim74]# make distclean
[root@pmbu-dev-vm58 vim74]# configure  --enable-rubyinterp  --enable-cscope --enable-perlinterp --with-features=huge --with-tlib=ncurses --disable-selinux  

	- /usr/bin/ld: skipping incompatible /usr/cisco/packages/ruby/ruby-1.8.7-p72/lib/libruby-static.a when searching for -lruby-static
/usr/bin/ld: cannot find -lruby-static
collect2: ld returned 1 exit status
link.sh: Linking failed
make[1]: *** [vim] Error 1
make[1]: Leaving directory `/tmp/vim/vim74/src'
make: *** [first] Error 2
	- 
     - lruby-static -lpthread -ldl -lcrypt -lm  -L/usr/cisco/packages/ruby/ruby-1.8.7-p72/lib   
/usr/bin/ld: skipping incompatible /usr/cisco/packages/ruby/ruby-1.8.7-p72/lib/libruby-static.a when searching for -lruby-static
/usr/bin/ld: cannot find -lruby-static

	[root@pmbu-dev-vm58 vim74]# configure   --enable-cscope --enable-perlinterp --with-features=huge --with-tlib=ncurses --disable-selinux 
	- 
- make install
[root@yizaq-lnx vim73]# vim --version
VIM - Vi IMproved 7.3 (2010 Aug 15, compiled Feb 21 2013 16:44:21)
Included patches: 1-831
Compiled by yizaq@yizaq-lnx
Huge version with GTK2 GUI.  Features included (+) or not (-):
+arabic          +file_in_path    +mouse_sgr       +tag_binary
+autocmd         +find_in_path    -mouse_sysmouse  +tag_old_static
+balloon_eval    +float           +mouse_urxvt     -tag_any_white
+browse          +folding         +mouse_xterm     -tcl
++builtin_terms  -footer          +multi_byte      +terminfo
+byte_offset     +fork()          +multi_lang      +termresponse
+cindent         +gettext         -mzscheme        +textobjects
+clientserver    -hangul_input    +netbeans_intg   +title
+clipboard       +iconv           +path_extra      +toolbar
+cmdline_compl   +insert_expand   +perl            +user_commands
+cmdline_hist    +jumplist        +persistent_undo +vertsplit
+cmdline_info    +keymap          +postscript      +virtualedit
+comments        +langmap         +printer         +visual
+conceal         +libcall         +profile         +visualextra
+cryptv          +linebreak       -python          +viminfo
+cscope          +lispindent      -python3         +vreplace
+cursorbind      +listcmds        +quickfix        +wildignore
+cursorshape     +localmap        +reltime         +wildmenu
+dialog_con_gui  -lua             +rightleft       +windows
+diff            +menu            +ruby            +writebackup
+digraphs        +mksession       +scrollbind      +X11
+dnd             +modify_fname    +signs           -xfontset
-ebcdic          +mouse           +smartindent     +xim
+emacs_tags      +mouseshape      -sniff           +xsmp_interact
+eval            +mouse_dec       +startuptime     +xterm_clipboard
+ex_extra        +mouse_gpm       +statusline      -xterm_save
+extra_search    -mouse_jsbterm   -sun_workshop    
+farsi           +mouse_netterm   +syntax          
   system vimrc file: "$VIM/vimrc"
     user vimrc file: "$HOME/.vimrc"
      user exrc file: "$HOME/.exrc"
  system gvimrc file: "$VIM/gvimrc"
    user gvimrc file: "$HOME/.gvimrc"
    system menu file: "$VIMRUNTIME/menu.vim"
  fall-back for $VIM: "/usr/local/share/vim"
Compilation: gcc -c -I. -Iproto -DHAVE_CONFIG_H -DFEAT_GUI_GTK  -DXTHREADS -D_REENTRANT -DXUSE_MTSAFE_API -I/usr/include/gtk-2.0 -I/usr/lib/
gtk-2.0/include -I/usr/X11R6/include -I/usr/include/atk-1.0 -I/usr/include/pango-1.0 -I/usr/include/freetype2 -I/usr/include/freetype2/confi
g -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include     -g -O2   -I/usr/X11R6/include    
Linking: gcc  -L/usr/X11R6/lib   -rdynamic -Wl,-export-dynamic  -rdynamic   -L/usr/local/lib -o vim   -Wl,--export-dynamic -lgtk-x11-2.0 -lg
dk-x11-2.0 -latk-1.0 -lgdk_pixbuf-2.0 -lpangoxft-1.0 -lpangox-1.0 -lpango-1.0 -lgobject-2.0 -lgmodule-2.0 -lglib-2.0   -lXt -lm -lncurses -l
selinux -lacl -lgpm -rdynamic  /usr/cisco/packages/perl/perl-5.8.6/lib/5.8.6/i686-linux/auto/DynaLoader/DynaLoader.a -L/usr/cisco/packages/p
erl/perl-5.8.6/lib/5.8.6/i686-linux/CORE -lperl -lnsl -ldl -lm -lcrypt -lutil -lc    -lruby-static -ldl -lcrypt -lm  -L/usr/cisco/packages/r
uby/ruby-1.8.6/lib   

- make errors Addendum
...
gcc -c -I. -Iproto -DHAVE_CONFIG_H     -g -O2 -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1       -o objects/os_unix.o os_unix.c
os_unix.c:45:30: error: selinux/selinux.h: No such file or directory
os_unix.c: In function ?mch_copy_sec?:
os_unix.c:2698: error: ?security_context_t? undeclared (first use in this function)
os_unix.c:2698: error: (Each undeclared identifier is reported only once
os_unix.c:2698: error: for each function it appears in.)
os_unix.c:2698: error: expected ?;? before ?from_context?
os_unix.c:2699: error: expected ?;? before ?to_context?
os_unix.c:2701: error: ?from_context? undeclared (first use in this function)
os_unix.c:2714: error: ?to_context? undeclared (first use in this function)
make[1]: *** [objects/os_unix.o] Error 1
make[1]: Leaving directory `/root/temp/vim/vim73/src'
make: *** [first] Error 2

- To fix
[root@pmbu-dev-vm22 vim73]# yum libselinux-devel install
- make
OLD_PO_FILE_INPUT=yes msgfmt -v -o nb.mo nb.po
1672 translated messages.
make[2]: *** No rule to make target `nl.mo', needed by `all'.  Stop.
make[2]: Leaving directory `/root/temp/vim/vim73/src/po'
make[1]: *** [languages] Error 2
make[1]: Leaving directory `/root/temp/v m/vim73/src'
make: *** [first] Error 2

- Fix, create it manually and copy from: https://code.google.com/p/vim/source/browse/src/po/nl.po
# Dutch Translation for Vim vim:set foldmethod=marker:
# Do ":help uganda" in Vim to read copying and usage conditions.
# Do ":help credits" in Vim to see a list of people who contributed.
# Previous-Translator(s):
# highlight: oplichten
# Erwin Poeze <erwin.poeze@gmail.com>, 2011, 2012.
msgid ""
msgstr ""

- [root@pmbu-dev-vm22 vim73]# rm /usr/bin/vim
rm: remove regular file `/usr/bin/vim'? y
[root@pmbu-dev-vm22 vim73]# ln -s /usr/local/bin/vim /usr/bin/vim
[root@pmbu-dev-vm22 vim73]# vim --version
VIM - Vi IMproved 7.3 (2010 Aug 15, compiled Jan 20 2013 10:47:37)
Included patches: 1, 1-497, 499-773
Compiled by yizaq@pmbu-dev-vm22
Normal version without GUI.  Features included (+) or not (-):
-arabic +autocmd -balloon_eval -browse +builtin_terms +byte_offset +cindent 
-clientserver -clipboard +cmdline_compl +cmdline_hist +cmdline_info +comments 
-conceal +cryptv -cscope +cursorbind +cursorshape +dialog_con +diff +digraphs 
-dnd -ebcdic -emacs_tags +eval +ex_extra +extra_search -farsi +file_in_path 
+find_in_path +float +folding -footer +fork() +gettext -hangul_input -iconv 
+insert_expand +jumplist -keymap -langmap +libcall +linebreak +lispindent 
+listcmds +localmap -lua +menu +mksession +modify_fname +mouse -mouseshape 
-mouse_dec -mouse_gpm -mouse_jsbterm -mouse_netterm -mouse_sgr -mouse_sysmouse 
-mouse_urxvt +mouse_xterm -multi_byte +multi_lang -mzscheme +netbeans_intg 
+path_extra -perl +persistent_undo +postscript +printer -profile -python 
-python3 +quickfix +reltime -rightleft -ruby +scrollbind +signs +smartindent 
-sniff +startuptime +statusline -sun_workshop +syntax +tag_binary 
+tag_old_static -tag_any_white -tcl +terminfo +termresponse +textobjects +title
 -toolbar +user_commands +vertsplit +virtualedit +visual +visualextra +viminfo 
+vreplace +wildignore +wildmenu +windows +writebackup -X11 -xfontset -xim -xsmp
 -xterm_clipboard -xterm_save 
   system vimrc file: "$VIM/vimrc"
     user vimrc file: "$HOME/.vimrc"
      user exrc file: "$HOME/.exrc"
  fall-back for $VIM: "/usr/local/share/vim"
Compilation: gcc -c -I. -Iproto -DHAVE_CONFIG_H     -g -O2 -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1      
Linking: gcc   -L/usr/local/lib -Wl,--as-needed -o vim       -lm -lncurses -lnsl  -lselinux    


		51.3.3 Install VIM using mercurial 
helpfull link: https://github.com/Valloric/YouCompleteMe/wiki/Building-Vim-from-source 
summary:
cd ~
(using mercurial - may need to install first, see "If you install python-setuptools you should be able
 to do easy_install mercurial."
 or [yizaq@csi-pmbu17-lnx:Thu Feb 18:1001:4:/tmp]$ sudo yum install mercurial )
(note - this will install with patches )
hg clone https://code.google.com/p/vim/
cd vim
./configure --with-features=huge \
            --enable-multibyte \
            --enable-rubyinterp \
            --enable-pythoninterp \
            --with-python-config-dir=/usr/lib/python2.4/config \
            --enable-perlinterp \
            --enable-luainterp \
            --enable-gui=gtk2 --enable-cscope --prefix=/usr
make VIMRUNTIMEDIR=/usr/share/vim/vim74
sudo make install
----------------------------------------------------------------------------------------------------
 sudo yum install ncurses-devel

	51.4 On MAC

https://macvim-dev.github.io/macvim/
https://github.com/macvim-dev/macvim/releases

Download binary. Install DMG, copy to Applications, open directly from Applications (just 1st time)

	51.5 Install vim 8 on linux


		51.5.1 Install git
https://git-scm.com/book/en/v2/Getting-Started-Installing-Git
 Getting Started - Installing Git
Installing Git
Before you start using Git, you have to make it available on your computer. Even if it’s already installed, it’s probably a good idea to update to the latest version. You can either install it as a package or via another installer, or download the source code and compile it yourself.

NOTE
This book was written using Git version 2.0.0. Though most of the commands we use should work even in ancient versions of Git, some of them might not or might act slightly differently if you’re using an older version. Since Git is quite excellent at preserving backwards compatibility, any version after 2.0 should work just fine.

Installing on Linux
If you want to install the basic Git tools on Linux via a binary installer, you can generally do so through the basic package-management tool that comes with your distribution. If you’re on Fedora for example, you can use yum:

$ sudo yum install git-all
If you’re on a Debian-based distribution like Ubuntu, try apt-get:

$ sudo apt-get install git-all
For more options, there are instructions for installing on several different Unix flavors on the Git website, at http://git-scm.com/download/linux.

Installing on Mac
There are several ways to install Git on a Mac. The easiest is probably to install the Xcode Command Line Tools. On Mavericks (10.9) or above you can do this simply by trying to run git from the Terminal the very first time. If you don’t have it installed already, it will prompt you to install it.

If you want a more up to date version, you can also install it via a binary installer. An OSX Git installer is maintained and available for download at the Git website, at http://git-scm.com/download/mac.

Git OS X installer.
Figure 1-7. Git OS X Installer.
You can also install it as part of the GitHub for Mac install. Their GUI Git tool has an option to install command line tools as well. You can download that tool from the GitHub for Mac website, at http://mac.github.com.

Installing on Windows
There are also a few ways to install Git on Windows. The most official build is available for download on the Git website. Just go to http://git-scm.com/download/win and the download will start automatically. Note that this is a project called Git for Windows, which is separate from Git itself; for more information on it, go to https://git-for-windows.github.io/.

Another easy way to get Git installed is by installing GitHub for Windows. The installer includes a command line version of Git as well as the GUI. It also works well with Powershell, and sets up solid credential caching and sane CRLF settings. We’ll learn more about those things a little later, but suffice it to say they’re things you want. You can download this from the GitHub for Windows website, at http://windows.github.com.

Installing from Source
Some people may instead find it useful to install Git from source, because you’ll get the most recent version. The binary installers tend to be a bit behind, though as Git has matured in recent years, this has made less of a difference.

If you do want to install Git from source, you need to have the following libraries that Git depends on: curl, zlib, openssl, expat, and libiconv. For example, if you’re on a system that has yum (such as Fedora) or apt-get (such as a Debian based system), you can use one of these commands to install the minimal dependencies for compiling and installing the Git binaries:

$ sudo yum install curl-devel expat-devel gettext-devel \
  openssl-devel perl-devel zlib-devel
$ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \
  libz-dev libssl-dev
In order to be able to add the documentation in various formats (doc, html, info), these additional dependencies are required (Note: users of RHEL and RHEL-derivatives like CentOS and Scientific Linux will have to enable the EPEL repository to download the docbook2X package):

$ sudo yum install asciidoc xmlto docbook2X
$ sudo apt-get install asciidoc xmlto docbook2x
Additionally, if you’re using Fedora/RHEL/RHEL-derivatives, you need to do this

$ sudo ln -s /usr/bin/db2x_docbook2texi /usr/bin/docbook2x-texi
due to binary name differences.

When you have all the necessary dependencies, you can go ahead and grab the latest tagged release tarball from several places. You can get it via the Kernel.org site, at https://www.kernel.org/pub/software/scm/git, or the mirror on the GitHub web site, at https://github.com/git/git/releases. It’s generally a little clearer what the latest version is on the GitHub page, but the kernel.org page also has release signatures if you want to verify your download.

Then, compile and install:

$ tar -zxf git-2.0.0.tar.gz
$ cd git-2.0.0
$ make configure
$ ./configure --prefix=/usr
$ make all doc info
$ sudo make install install-doc install-html install-info
After this is done, you can also get Git via Git itself for updates:

$ git clone git://git.kernel.org/pub/scm/git/git.git

Note, if git can't access network, a proxy might be required
ex:
[212680136@G9VK2GH2E:Mon Nov 13:~/temp:]$ git clone https://github.com/vim/vim.git
Cloning into 'vim'...
fatal: unable to access 'https://github.com/vim/vim.git/': Could not resolve host: github.com
[212680136@G9VK2GH2E:Mon Nov 13:~/temp:]$ set_proxy 
[212680136@G9VK2GH2E:Mon Nov 13:~/temp:]$ git clone https://github.com/vim/vim.git

when set_proxy is
#GE related
set_proxy() {
    local proxy_url=http://uswausc301.am.health.ge.com:88
    export ftp_proxy=${proxy_url}
    export FTP_PROXY=${proxy_url}
    export http_proxy=${proxy_url}
    export HTTP_PROXY=${proxy_url}
    export https_proxy=${proxy_url}
    export HTTPS_PROXY=${proxy_url}
    export proxy=${proxy_url}
    export PROXY=${proxy_url}
    export no_proxy='.ge.com,localhost,127.0.0.1'
    export NO_PROXY=${no_proxy}
}



		51.5.2 Get vim

either directly by git
git clone https://github.com/vim/vim.git

(or copy to MAC and pass to linux )

		51.5.3 Compile
[root@yizaq-dev01 src]# ./configure --with-features=huge             --enable-multibyte             --enable-pythoninterp             --enable-luainterp             --enable-gui=gtk2 --enable-cscope --prefix=/usr | grep lua

sudo make install
		51.5.4

	51.6 Install vim 8 on GE linux Suse server
git clone https://github.com/vim/vim.git
a. on cygwin:
    $ cd vim && git fetch && git merge

b. configure
./configure --with-features=huge \
            --enable-multibyte \
            --enable-rubyinterp \
            --enable-pythoninterp \
            --enable-perlinterp \
            --enable-luainterp \
            --enable-gui=gtk2 --enable-cscope --prefix=/usr

c. make

d. install

Note, no root access so make sure to
make install DESTDIR=~/.local, then make a symlink in ~/bin to ~/.local/bin/vim.
ex:
de680136@ctds64-1:/home/de680136> mkdir bin
de680136@ctds64-1:/home/de680136> cd .local/ 
de680136@ctds64-1:/home/de680136/.local> cd ../bin/
de680136@ctds64-1:/home/de680136/bin> ln -s /home/de680136/.local/usr/bin/vim vim                                                                                                           
de680136@ctds64-1:/home/de680136/bin> ls -l vim
lrwxrwxrwx 1 de680136 unity 33 2017-11-14 01:20 vim -> /home/de680136/.local/usr/bin/vim*
de680136@ctds64-1:/home/de680136/bin> export PATH="$HOME/bin:$PATH"

add to .kshrc
de680136@ctds64-1:/home/de680136/bin> vim --version                   
VIM - Vi IMproved 8.0 (2016 Sep 12, compiled Nov 14 2017 00:39:11)
Included patches: 1-1297
Compiled by de680136@ctds64-1
Huge version without GUI.  Features included (+) or not (-):
+acl             +farsi           +mouse_netterm   +tag_binary
+arabic          +file_in_path    +mouse_sgr       +tag_old_static
+autocmd         +find_in_path    -mouse_sysmouse  -tag_any_white
-autoservername  +float           +mouse_urxvt     -tcl
-balloon_eval    +folding         +mouse_xterm     +termguicolors
-browse          -footer          +multi_byte      +terminal
++builtin_terms  +fork()          +multi_lang      +terminfo
+byte_offset     +gettext         -mzscheme        +termresponse
+channel         -hangul_input    +netbeans_intg   +textobjects
+cindent         +iconv           +num64           +timers
+clientserver    +insert_expand   +packages        +title
+clipboard       +job             +path_extra      -toolbar
+cmdline_compl   +jumplist        +perl            +user_commands
+cmdline_hist    +keymap          +persistent_undo +vertsplit
+cmdline_info    +lambda          +postscript      +virtualedit
+comments        +langmap         +printer         +visual
+conceal         +libcall         +profile         +visualextra
+cryptv          +linebreak       +python          +viminfo
+cscope          +lispindent      -python3         +vreplace
+cursorbind      +listcmds        +quickfix        +wildignore
+cursorshape     +localmap        +reltime         +wildmenu
+dialog_con      -lua             +rightleft       +windows
+diff            +menu            -ruby            +writebackup
+digraphs        +mksession       +scrollbind      +X11
-dnd             +modify_fname    +signs           +xfontset
-ebcdic          +mouse           +smartindent     -xim
+emacs_tags      -mouseshape      +startuptime     +xpm
+eval            +mouse_dec       +statusline      +xsmp_interact
+ex_extra        +mouse_gpm       -sun_workshop    +xterm_clipboard
+extra_search    -mouse_jsbterm   +syntax          -xterm_save
   system vimrc file: "$VIM/vimrc"
     user vimrc file: "$HOME/.vimrc"
 2nd user vimrc file: "~/.vim/vimrc"
      user exrc file: "$HOME/.exrc"
       defaults file: "$VIMRUNTIME/defaults.vim"
  fall-back for $VIM: "/usr/share/vim"
Compilation: gcc -c -I. -Iproto -DHAVE_CONFIG_H     -g -O2 -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1       
Linking: gcc   -Wl,-E -Wl,-rpath,/usr/lib/perl5/5.10.0/x86_64-linux-thread-multi/CORE   -L/usr/local/lib -Wl,--as-needed -o vim    -lSM -lICE -lXpm -lXt -lX11 -lXdmcp -lSM -lICE  -lm -lncurses -lnsl   -lgpm   -Wl,-E -Wl,-rpath,/usr/lib/perl5/5.10.0/x86_64-linux-thread-multi/CORE  -L/usr/local/lib64  -L/usr/lib/perl5/5.10.0/x86_64-linux-thread-multi/CORE -lperl -lm -ldl -lcrypt -lpthread -L/usr/lib64/python2.6/config -lpython2.6 -lpthread -ldl -lutil -lm -Xlinker -export-dynamic       

f. set VIMRUNTIME
de680136@ctds64-1:/home/de680136/temp/cscope-15.8b> export VIMRUNTIME=/home/de680136/.local/usr/share/vim/vim80/                  
de680136@ctds64-1:/home/de680136/temp/cscope-15.8b> echo $VIMRUNTIME
Also set kshrc

g. install cscope

    g1. get that tarball copy to machine
    g2. configure -h for options then
    de680136@ctds64-1:/home/de680136/temp/cscope-15.8b> ./configure --prefix=/home/de680136/.local/
    g3. make && make install
    g4. symlink in bin
de680136@ctds64-1:/home/de680136/bin> find  /home/de680136/.local/ -name cscope                                                                                                             /home/de680136/.local/bin/cscope
de680136@ctds64-1:/home/de680136/bin> ln -s /home/de680136/.local/bin/cscope cscope  
de680136@ctds64-1:/home/de680136/bin> ll cscope 
lrwxrwxrwx 1 de680136 unity 32 2017-11-14 02:11 cscope -> /home/de680136/.local/bin/cscope*

h.
	51.7

	
52. Tips from vim_use@googlegroups.com

	52.1 Fast Buffer Switching
> 2008/11/3, Dean <dean.keough@lac-bac.gc.ca>:
> > A nice way to jump between 3 buffers is to set uppercase marks. Go to
> > each file in turn and set the marks: mA, mB, mC. Then 'A or 'B or 'C
> > to jump between the files instantly.
> >
> > Of course you can set marks for as many files as you like and you can
> > use any uppercase letter or a digit in the mark. Something mnemonic
> > would be helpful. (Lowercase marks don't jump between files.)
> >
> > :help marks
>
> Yes, but the problem with marks is that you are forced always to
> redefine marks a bit - otherwise you are dropped to the exact place in
> the file, where do you made the mark.
>
> So it isn't what you can IMO use for quick switches between files
> (since your area of interests will be moved in those files, but marks
		> will alway drop you at the same place).
>
> Or are there some '<letter>, `<letter> analog to jump to the line of
> buffer, which you are in this buffer if you use :buffer
> <bufNameOrNumber> command ?

the fastest, easiest buffer switching I know is to map:

nmap <silent> <F6> :silent bnext<CR>
nmap <silent> <S-F6> :silent bprev<CR>

then use F6 or S-F6 to move around.  I use these so much they are a
permanent feature of my .vimrc



'

	52.2 quickfix list and location-list
:h quickfix.txt
:h location-list

		52.2.1 What generates a quickfix?
Commands such as compilation or grep.
For example:
:vim[grep][!] /{pattern}/[g][j] {file} ...
vimgrep /logs/ %

or
:make

(For make costumization see :h makeprg
 Also refer to my costumization for ACS 5.0 source code structure:
"Compile and build command for systems that use GNU make
set makeprg=makec\ %<

and 
[yizaq@yizaq-lnx:Tue Nov 11:~]$ cat `which makec`
#!/usr/bin/bash
CUR_PATH=`echo $1 |  sed -e 's_/src.*__'`
shift
echo "Changing dir to ${CUR_PATH}"
cd ${CUR_PATH}

make $@

)

"


		52.2.2 How to open the quickfix?
:copen

		52.2.3 How to navigate to next/previous match?
:cc, first match
:cn, next match
:cp, previous match

Note that count is acceptes so :3cn with go the third next match

		52.2.4 Location-list

A location list is similar to a quickfix list and contains a list of positions
in files.  A location list is associated with a window and each window can
have a separate location list.  A location list can be associated with only
one window.  The location list is independent of the quickfix list.

When a window with a location list is split, the new window gets a copy of the
location list.  When there are no references to a location list, the location
list is destroyed.

The following quickfix commands can be used.  The location list commands are
similar to the quickfix commands, replacing the 'c' prefix in the quickfix
command with 'l'.

Example:
lvimgrep /logs/ %
:lopen
:lc, first match
:ln, next match
:lp, previous match

		52.2.5 How to jump to error or message from quickfix or location list
press enter when on appropriate line

		52.2.6 How to add/append to quickfix
for grep there is grepadd
see :h grepadd

		52.2.7 Store CTAGS matches into location list
:h ltag

ltag <tag name>
then
Basically the quickfix commands all start with :c and are global; the
location list commands all start with :l and are local to a window
(well, 'connected' to a certain window anyway). So you have :lnext,
	:lprev, :lopen, etc.

	52.3 colorscheme dependent on filetype
Example:
autocmd WinEnter,FileType  vim,tex,*    colorscheme wombat
autocmd WinEnter,FileType  perl,sh      colorscheme desert

	52.4 rediraction of output, redir
:h redir

Examples:
-> redirect cscope output
:redir > result.txt
:cs find s cout
:redir END

-> redirect VIM settings report
:redir > result.txt
:set all
:redir END

	52.5 sorting words

		52.5.1 description
suppose I have a few line that goes like this:
str_list="foo bar   man act"

how can I sort all the words within the quote ¿ ... " so that it
becomes "act bar foo man"? It is okay to eliminate extra whitespace so
that it ends up with only one space behind each word.

		52.5.2 Solution using visualize
This is a common pattern of "decorate, sort, undecorate".  In
this case the decoration is putting each word on its own line.
If it's long, you can readily do this with

a) issue

  :s/\(\<\w\+\)\s*/\1\r/g

this should yield

  str_list
  ="foo
  bar
  man
  act
  "

which you can hand-tweak to add one extra newline before "foo",
yielding

  str_list
  ="
  foo
  bar
  man
  act
  "

The aim in the first step is just to get each word on its own
line.  If your string is short, it may be faster to do it by
hand.  But if it's 20+ words in the string, using the regexp can
be faster.

b) highlight the range of words in the string and use

  :'<,'>sort

to sort them

c) highlight the whole shebang and press J to rejoin them.

d) Clean up the extra space at the beginning and end of your
string (and optionally around the "=")

---------------

After typing the above, an alternative method (assuming you have
Vim7.0+) occurred to me, so you might also try

before sort: "ccc aaa bbb eee "
before sort: "aaa bbb ccc eee"

  vi"       visualize-inner-quotation
  c         change
  ^R=       control+r = (expression register)
  join(sort(split(@")), ' ')
            the expression to split the deleted content
            on whitespace, sort it, and join it back
            together with a single space
  <enter>   accept the expression
  <esc>     leave insert-mode

If it's something you do frequently, it's easily mappable:

  :nnoremap <f4> vi"c<c-r>=join(sort(split(@")), ' ')<cr><esc>
  :vnoremap <f4> c<c-r>=join(sort(split(@")), ' ')<cr><esc>


Just a couple ideas -- use whichever works better for your needs
(or whichever you remember).

		52.5.3 Using global

How about:

:g/str_list/let items = sort(copy(split(matchlist(getline('.'),
'"\([^"]*\)"')[1], ' \+'))) | s/"\zs[^"]*\ze"/\=join(items, ' ')

The above should be one line

:g/str_list/     " for all lines containing str_list
let items =      " Assign to variable 'items'
sort(            " Sort the list
copy(            " Work on a copy of the list (:help sort())
split(           " Split a string into parts (using delimiter ' \+')
matchlist(       " Get a list of matches of a regular expression
getline('.')     " Use the current line as the search fodder
'"\([^"]*\)"'    " Search for a string of non-" characters inside double quotes
)[1]             " Take the first match (everything inside the " ")
, ' \+')         " See the split comment above
))               " End of sort/copy
|                " THEN:
s/               " Substitute on the current line
"\zs[^"]\ze"     " Match everything between the double quotes
\=               " Expression replace
join(items, ' ') " Replace with a string comprising the sorted items


		52.5.4 Sort operator
To sort words within double quoted texts, try:

:%s/"\zs[^"]*\ze"/\=join(sort(split(submatch(0))))/g


	52.6 Search for visually selected text
a. Select the text using characterwise or linewise VISUAL (v or V), not
SELECT (i.e. not shift-cursor).
b. Yank it to the unnamed register using y
Or yank to clipboard using "+y
or yank to a named register using "ay (to copy to register a for example)
c. Start your command-line
       /
d. Insert the unnamed register
       Ctrl-R " (control-R then double-quote with no intervening space) -- see
":help c_CTRL-R"
Or from clipboard using Ctrl-R "+
Or from named register using Ctrl-R "a

e. If there are "special" characters in the just-pasted text (backslash,
forward slash, period, circumflex, dollar, opening bracket, asterisk),
backslash-escape them by editing the command-line -- see ":help
pattern-overview".
f. You may or may not want to insert \< (start word) and/or \> (end
word) at the ends of your search pattern. If you do, do it now, by
command-line editing.
g. Check your search command-line, then hit Enter. Voilà!


	52.7 How to list all occurrence of a identifier
Q:
I am using vim writing C/C++ and I want to (as one usually can in
		other IDE) have vim listed all occurrence of identifier.  For example,
there is a method foo() in a class C, I want to get know where the
	foo() is called in the whole project (current directory and its
			subdirectories).  It seems, in this case, a ctag tags file does not
	help since it can only list where the identifier is defined/declared.


		52.7.1 Using vimgrep
       :vimgrep /\<foo\>/g ./**/*.[ch] ./**/*.cpp

or much faster
       :noautocmd vimgrep /\<foo\>/g ./**/*.[ch] ./**/*.cpp

search in context files
noautocmd vimgrep /090831-013608/g ./**/context* 

will find every occurrence of foo (as a word) in files *.c *.h and *.cpp
in the current directory or below up to 30 levels down. The results
appear as a quickfix list, so the usual commands apply:

- to see the matches (editing the files they're in)
       :cfirst
       :cnext
       :cprev
       :clast
       :cnfile
       :cpfile
- to see one line per match in the quickfix window
       :copen
       :cclose

Of course you can map those you use most to keys, for instance my vimrc
includes

       map     <F2>    :cnext<CR>
       map     <S-F2>  :cprev<CR>

Note: Since :vimgrep does a "dumb" search using a Vim search pattern, it
will list _all_ occurrences of the word, also as part of a string or
comment.


		52.7.2 Using cscope, find where function/method is called
cscope can be useful for this.  Install cscope, then build a cscope DB
(cscope.out) from your source files. Connect to the cscope DB in Vim
with  :cs add cscope.out  (you can put it in your ~/.vimrc) then you can
start using cscope in Vim. For example, to find all locations where foo()
is called, you can do:

 :cs find c foo

Then use quickfix commands to navigates through all matches
(:cn  or :copen for example)  assuming you have set up cscopequickfix
as in my ~/.vimrc.  Here is a snippet from my ~/.vimrc
(http://dominique.pelle.free.fr/.vimrc):

==================================
if has('cscope')
 if filereadable(expand("$HOME/cscope.out"))
   cs kill -1
   cs add ~/cscope.out
 endif
 set cscopeverbose
 set cscopequickfix=s-,c-,d-,i-,t-,e-,g-
endif

set tags=tags,~/tags,~/stl-tags
==================================

Note: 
If your cscope.out is in the directory from which VIM is opened then change the test to:

filereadable("cscope.out")

If really you want the directory of the current buffer, perhaps

filereadable(expand("%:p:h/cscope.out"))

cscope answers those questions:

      c: Find functions calling this function
      d: Find functions called by this function
      e: Find this egrep pattern
      f: Find this file
      g: Find this definition
      i: Find files #including this file
      s: Find this C symbol
      t: Find assignments to

Here is a sh script which I use to produce the cscope DB
and ctags (exuberant ctags) file for example:

==================================
#!/bin/sh

TMP_FILE=/tmp/build-tags.$$

find ~/sb/vim7/src \
    \( -name '*.l'   -o \
       -name '*.y'   -o \
       -name '*.c'   -o \
       -name '*.cpp' -o \
       -name '*.h' \)   \
    -print > $TMP_FILE

echo "=== Building ctags..."
ctags -L $TMP_FILE --language-force=c++ \
                  --c++-kinds=+p       \
                  --fields=+iaS        \
                  --extra=+f+q -f ~/tags

echo "=== Building cscope database..."
rm -f cscope.*
cscope -i $TMP_FILE -b -q -f ~/cscope.out

rm -f $TMP_FILE
==================================

It's not perfect, since it can't distinguish between
overloaded c++ functions for example, but still helps
a lot.


		52.7.3 Using GNU ID utils
The fastest way to search across a large number of C files is to use
GNU id-utils.

http://www.gnu.org/software/idutils/idutils.html

With GNU id-utils, it takes few seconds to search across several
thousand source files.

You can use the following Vim plugin with GNU id-utils:

http://vim.sourceforge.net/scripts/script.php?script_id=251

			52.7.3.1 Basic commands
Tutorial: http://www.delorie.com/gnu/docs/id-utils/id-utils_toc.html
An ID database is a binary file containing a list of file names, a list of tokens, and a sparse matrix indicating which tokens appear in which files.

With this database and some tools to query it (described in this manual), many text-searching tasks become simpler and faster. For example, you can list all files that reference a particular #include file throughout a huge source hierarchy, search for all the memos containing references to a project, or automatically invoke an editor on all files containing references to some function or variable. Anyone with a large software project to maintain, or a large set of text files to organize, can benefit from the ID utilities.

Although the name `ID' is short for `identifier', the ID utilities handle more than just identifiers; they also treat other kinds of tokens, most notably numeric constants, and the contents of certain character strings. Thus, this manual will use the word token as a term that is inclusive of identifiers, numbers and strings.

There are several programs in the ID utilities family:

`mkid'
    scans files for tokens and builds the ID database file.

`lid'
    queries the ID database for tokens, then reports matching file names or matching lines.

`fid'
    lists all tokens recorded in the database for given files, or tokens common to two files.

`fnid'
    matches the file names in the database, rather than the tokens.

`xtokid'
    extracts raw tokens--helps with testing of new `mkid' scanners.

In addition, the ID utilities have historically provided several query programs which are specializations of `lid':

`gid'
    (alias for `lid -R grep') lists all lines containing the requested pattern.

`eid'
    (alias for `lid -R edit') invokes an editor on all files containing the requested pattern, and if possible, initiates a text search for that pattern.

`aid'
    (alias for `lid -ils') treats the requested pattern as a case-insensitive literal substring. 


	52.8 How to determine current font in use
-> :set guifont?

-> In GVim, just type :set guifont
In Vim, I don't think there's a way to determine it, since it's
defined by the terminal itself.

	52.9 Go to nth character (byte) from current position
For example, go to 1000 character from start:
:1000go

	52.10 VIM and bash
You can explicitly set the 'shell' option to /bin/bash or another path as needed.  Vim gets it's
default from the $SHELL environment variable.  Some vim init script
might be overwriting the default with a bad value.  You can use
":verbose set shell" to find out where that might be happening.

> So how do I explicitly set the VIM shell variable?

Technically, it's an option in Vim, not a variable.

:set shell=/bin/bash

(put it in your .vimrc or something).

To set the $SHELL environment variable from which Vim automatically sets
its shell option when it starts up, you have to do something like

export SHELL=/bin/bash

or

setenv SHELL /bin/bash

in your shell login/initialisation scripts (~/.profile or ~/.login
probably). See your shell man page for the gory details.

It is odd for these values to be wrong, though, if your logins are
actually working. If something is not working, it is more likely that
some rogue Vim script is changing the option or shell script is setting
environment variable, when it shouldn't.


Q:     s it possible for VIM to "recognize" my aliases, such as I have
     in my .aliases for example?- (in bash I simply source them of course)

A:  Vim doesn't know anything about how a shell invokes a command,
    including whether that command is a built-in, an alias, a function
    or a file.  What you really want to know is whether aliases can be
    used by a shell invoked from vim.

    Bash "normally" sources ~/.bashrc only if it is run as an
    interactive shell.  This improves the performance of the shell when
    it is run in non-interactive mode, where aliases are usually not
    used.  If you want the shell invoked from vim to see your aliases,
    you can either tell vim to always invoke the shell in interactive
    mode or tell the shell to always source ~/.bashrc even when not in
    interactive mode.

    For the former, I think (untested) that adding "-i" to
    'shellcmdflag' will work, e.g.,

      set shcf=-i\ -c

Note,	Above won't work, do this instead:
  set shellcmdflag=-ic



Q: I tried that, and then invoked !ls and got the following errors:
/bin/bash: - : invalid option
Usage:  /bin/bash [GNU long option] [option] ...
        /bin/bash [GNU long option] [option] script-file ...

A: Hmm.  I just tried it with ksh and got the same results.  A command
like this one,

  ksh -i -c 'ct ls'

works fine from the command line, so those options are OK.  (ct is
an alias for cleartool.)  I don't know what it is that causes

  set shellcmdflag=-i\ -c

to fail.  However, this variation does work:

  set shellcmdflag=-ic


	52.11 command to select multiple line & move it backward/forward
INDENTING/DEDENTING
====================
You can use the >/< commands to indent/dedent a line, range,
motion, or as an Ex target.  You can also use control+[t/d] to
indent/exdent while in insert mode

:help >
:help :>
:help i_CTRL-T

Thus if you have a visually highlighted range (":help V"), you
can just use

>

to indent the lines.  Or you can use

>ip

to indent the "inner paragraph" (using the "ip" text object,
":help text-objects").  Or, if you want to indent select lines:

:g/foo/>

will indent all lines matching the pattern "foo" (with an
annoying stream of messages that I usually suppress with a
well-placed "sil!" in the command).

Incidentally, indentation behavior is controlled by your
'shiftwidth' and 'expandtabs' settings.



MOVING LINES UP/DOWN
=====================
To move lines up/down in a file, you can copy (yank) and paste
them.  Or you can use the Ex ":m"ove command:

:help :move

For example

:.,+3m'a

will move 4 lines (the current line and the 3 below it) to the
location you've marked with the "a" mark.  Any line-reference
(":help :range") will do, so you can do things like

:-3,/foo/m1/bar

(take the range from "3 lines above the cursor, through the next
occurance of 'foo'" and move them to the line after the first
instance of 'bar' after line #1)  Or even
 
:g/foo/m$

will find all lines containing "foo" and move them to the bottom
of the file.

A side-benefit of the ":m"ove method is that it doesn't tromp
your scratch yank/delete register.  I frequently use

:m+
to move the current line below the next one without disturbing my
registers.



	52.12 Another method of converting dos 2 unix
Using global substitute: 
:%s/\r//g                   : Delete DOS returns ^M

Using vim 7.2 options:
You can either use the special-purpose dos2unix utility or do the following:

|1. Load Vim (don't yet specify an editfile).
|
|2. Read the file, accepting either CR+LF or LF alone (or any mixture of
|them) as an end-of-line marker
|       :e ++ff=dos filename.txt
|
|3. Write the file, outputting only LF (without CR) at the end of each line
|       :setlocal ff=unix
|       :w
|
|4. (Optional, if you don't need Vim any longer)
       :q

The above assumes Vim 7.2.040 or later. With earlier versions it's
possible but not as simple.

	52.13 Advanced pattern matching discussions

		52.13.1 match abcd not "abcd"
-> how can i did this? i want match abcd which is not in quote. e.g:
abcd  //match
"abcd" //mismatch
"\"abcd" //mismatch
"\"ab" abcd //match

how can i did this?
		
	
-> 
[^"]abcd[^"]

which of course would also match abcde, so perhaps:

[^"]\<abcd\>[^"]

Depends what exactly you want, really.

-> 
> how can i did this? i want match abcd which is not in quote. e.g:
> abcd  //match
> "abcd" //mismatch
> "\"abcd" //mismatch
> "\"ab" abcd //match
>
> how can i did this?

/\v%(^[^"]*%(%("%(\\.|[^\\"])*")[^"]*)*)@<=abcd

makes sure that 0 or more fully quoted parts do match from the start of
the line up to the "actual" match for "abcd" in the same line.
basically an even number of quotes is required left from "abcd", but
within a quoted part, escaped quotes (and other escaped chars) are
skipped.
   :h pattern
   :h /\v
   ...
-> 

use negative look-ahead and look-behind, something like:

\("\)\@<!abcd\("\)\@!

should work. [^"]abcd[^"] will not work if abcd stand at the beginning or end
of a line.

-> 
> > how can i did this?
>
> [^"]abcd[^"]
>

> which of course would also match abcde, so perhaps:
>
> [^"]\<abcd\>[^"]
>

this will match "i'm abcd in quote". witch is mustn't matched. so i
can't use this...


>
> /\v%(^[^"]*%(%("%(\\.|[^\\"])*")[^"]*)*)@<=abcd
>
> makes sure that 0 or more fully quoted parts do match from the start of
> the line up to the "actual" match for "abcd" in the same line.
> basically an even number of quotes is required left from "abcd", but
> within a quoted part, escaped quotes (and other escaped chars) are
> skipped.
>     :h pattern
>     :h /\v
>     ...
>

this is even match "aaa abcd " abcd....(two of this...) so i can't use
this.


-> 

> use negative look-ahead and look-behind, something like:
>
> \("\)\@<!abcd\("\)\@!
>
> should work. [^"]abcd[^"] will not work if abcd stand at the beginning or end
> of a line.

okay, if you insist, it must be /\v(^.*".*)@<!abcd(.*")@!. this is
very good, but, it always match:

" trick string ... " . this is should matched abcd . "trick string ...
"

so... didn't prefect, isn't it?

i have thought a while, i think i need the pattern that can describe
the idea "match pattern one, and except pattern two, even if pattern
one is matched". Does Vim has this way?
- Show quoted text -

-> 
> /\v%(^[^"]*%(%("%(\\.|[^\\"])*")[^"]*)*)@<=abcd

> makes sure that 0 or more fully quoted parts do match from the start of
> the line up to the "actual" match for "abcd" in the same line.
> basically an even number of quotes is required left from "abcd", but
> within a quoted part, escaped quotes (and other escaped chars) are
> skipped.
>     :h pattern
>     :h /\v
>     ...


	52.14 Strange result of reading from shell
Hi,

I'm using gvim launched from an linux xterm.

I want to work with all the files in the current directory so I do :r!
ls
the result is full of strange characters that get in the way of
editing the file.
I get something like (ignore the line numbers):
| 2 ^[[00mtotal 184
|   3 ^[[00m^[[00mcentrifydc.conf^[[00m
|   4 ^[[00mdefaults.conf^[[00m
|   5 ^[[00mdiff_cfg^[[00m
|   6 ^[[00mgid.ignore^[[00m
|   7 ^[[00mgroup.ignore^[[00m
|   8 ^[[00mgroup.ovr.sample^[[00m
|   9 ^[[00;34mold^[[00m/
|  10 ^[[00;34mopenldap^[[00m/
|  11 ^[[00mpasswd.ovr.sample^[[00m
|  12 ^[[00muid.ignore^[[00m
|  13 ^[[00mupgradeconf.conf^[[00m
|  14 ^[[00muser.ignore^[[00m

-> 
Found away around this outside of VIM by performing:
for file in *; do echo $file; done > list_of_files

Still, would love to be able to make it work from VIM.


-> 
Yes.  Those are ANSI escape codes
http://en.wikipedia.org/wiki/Ansi_escape_codes

Your version of ls uses them to visually enhance the output on a xterm.
Usually this means you are using an alias for ls.  Try:

:!r
/bin/ls


-> 
I suspect they are escape sequence for color codes. Does it help if
you pipe the output. eg,  ls | cat


-> 

r! /bin/ls works well
r! ls | cat doesn't

-> What about :r  !ls --color=no 
?

[works well]

->
>
> To verify that you are using an alias, you can execute (at a shell
> prompt):
>
>    alias ls
>
> I think you'll see something like this:
>
>    ls='ls --color=always'
>
> If you can find where that alias is defined--probably in your
> ~/.bashrc or the rc file for whatever shell you're using--change it
> to this instead:
>
>    alias ls='ls --color=auto'
>
> Then you will continue to see directory listings in color when ls is
> executed at a shell prompt, but not have the escape sequences
> included when ls is piped into something else, such as a vim buffer.
>

$ alias ls
alias ls='ls -F --color '

Changed to
alias ls='ls -F --color=auto '

Now :r !ls works as expected w/o ANSI codes. 
'

-> 
> To verify that you are using an alias, you can execute (at a shell
> prompt):
>
>     alias ls
>
> I think you'll see something like this:
>
>     ls='ls --color=always'
>
> If you can find where that alias is defined--probably in your
> ~/.bashrc or the rc file for whatever shell you're using--change it
> to this instead:
>
>     alias ls='ls --color=auto'
>
> Then you will continue to see directory listings in color when ls is
> executed at a shell prompt, but not have the escape sequences
> included when ls is piped into something else, such as a vim buffer.
>

If those fail, see if these give any results:

:!typeset -f ls

:!which ls

The last one should be /bin/ls or /usr/bin/ls

If the above don't give anything interesting:

:!env|grep LS|sort

Here you are looking for LSOPTIONS, LSRC, anything starting with LS_ or
ending with _LS

BTW, the interesting thing about the escape codes if that they all are
switching to normal black-on-white text.

-> Another possibility is the environment variable $LS_OPTIONS. If it is
set, find out where (probably by one or more of your startup scripts --
the manpage for your shell will tell you wwhich scripts it runs at
startup) and replace (in that environment variable) --color=yes,
--color=always or --color without an equal sign and a value, by
--color=auto.

	52.15 delete between patterns

->
I couldn't find a way to do this and would like a help. I'm editing a svn
dump, but would like to know how to delete blocks between
       /Node-path: .*LCK/
to the Next
       /Node-path:/-1

============
Node-path: edit-1.gif
...

Node-path: edit.gif.LCK         | I want to delete this block.
....                            |
                               |
Node-path: edit.gif
============

       :/Node-path:.*LCK/,/Node-path:/-1d

gives me backward range warning and I cannot seem to tell vim to look for
the Node-path: after the first Node-path in Node-path:.*LCK.

-> >       :/Node-path:.*LCK/,/Node-path:/-1d

Close.  You might try changing your "," to a ";"

  :/Node-path:.*LCK/;/Node-path:/-1d

which is detailed (but easily overlooked) at

  :help :;

Yours only does one instance (and may be context-sensitive
regarding where your cursor is relative to both bits; thus your
backward-range warning).  If you want to do all of them in the
file, you should be able to use:

  :g/^Node-path:.*LCK/,/^Node-path:/-1d

If for some reason the very last LCK line doesn't have a
Node-path after it, it may try to wrap around, and you'll get the
backward-range warning again.  If you turn off the 'wrapscan'
option, this will transform into a E385 ("search hit bottom
without match for ^Node-path"), so you might have to treat the
last one specially.

And as an aside, the "-1" can be lazily shortened to just "-"
(because the "1" is defaulted):

  :/Node-path:.*LCK/;/Node-path:/-d
  :g/^Node-path:.*LCK/,/^Node-path:/-d

as detailed under the table at

  :help :range

-> >>   :g/^Node-path:.*LCK/,/^Node-path:/-1d
>
> So quick and helpful. Thanks a lot. It'd help me so much dealing with the
> svn dumps.
>
> I guess you meant ; here? (Just in case...)
>
> :g/^Node-path:.*LCK/,/^Node-path:/-1d
> :g/^Node-path:.*LCK/,/^Node-path:/-d

nope...really did mean "," here :)

In your original/first (problematic) case, the reason for the
weirdness was that the searches were both started from your
current cursor position.  Therefore, it would search forward,
find the LCK line, and then for the end-point, search forward for
the next Node-path line (which would happen to be the same line)
and go back one row.  Thus your inversion problem:  it was
getting the LCK line as the start, and the line before it as the end.

With the :g command, each Ex command that follows it has the
cursor already on the line in question, so the
implict-made-explicit becomes

  :g/^Node-path:.*LCK/.,/^Node-path:/-1d

The Ex command-portion being

  .,/^Node../-1

which means "from the current line", rather than your original
non-:g command which searched forward from the current line for
the starting location.

If your start location was relative to the :g command, you'd have
to use the ";" instead -- something like

  :g/^Chapter \d\+//Subsection/+1;/SubsectionEnd/-1d

which would look for each "^Chapter", search forward to
"Subsection", and then *relative to the "Subsection"* search
forward to find "SubsectionEnd".  If it was a comma instead of a
semicolon, it would search for "SubsectionEnd" relative to the
"Chapter" line instead.

-> Summary, to delete a block between two patterns (but not the lines with the patterns):
:/3rdPar/+1,/daemons/-1d
or
g/3rdPar/+1,/daemons/-d 

	52.16 cscope and ctags generation and configuration tips
To find files, you can use ":ts filename".  But you need to pass
the command line option --extra=+f  when you build your tags
with exuberant ctags.

This is how I build tags and the cscope DB for vim sources for
example:

=========================================
#!/bin/sh
TMP_FILE=/tmp/build-tags.$$

find ~/sb/vim7/src -name '*.[ch]' -print > $TMP_FILE
ctags -e -L $TMP_FILE --language-force=c --fields=+S --extra=+f+q -f ~/tags

rm -f cscope.*
cscope -i $TMP_FILE -b -q -f ~/cscope.out

rm -f $TMP_FILE
=========================================

in my ~/.vimrc, I have:

set tags=~/tags

if has('cscope')
 if filereadable(expand("$HOME/cscope.out"))
   cs kill -1
   cs add ~/cscope.out
 endif
 set cscopeverbose
 set cscopequickfix=s-,c-,d-,i-,t-,e-,g-
endif


Then I can jump to a file with...

:ts screen.c

Or using cscope, I can also do:

:cs find f screen.c

	52.17 VIM for editing emails

		52.17.1 Firefox, Gmail, its all text firefox plugin

--> Small Issue:
- Hide quoted text -
> Hi,
	>
		> I've followed up on the it's all text addon to firefox. It works well for me.
		> One thing I'd like to improve though. My VIM is heavily configured
		> towards source code editing so it takes a lot of time to load. Is
		> there a quick way to force VIM to load with a minimal feature set with
		> the aim of getting fast load time?
		> [...]

		You can specify a .vimrc with the -u command line option and a .gvimrc
		with the -U command line option. Read :help -u and :help -U


		52.17.2


	52.18 remove an empty line if the previous line matches 'foo'.
 :g/^foo\n$/+1d

removes every empty line after a line with a single foo.

	52.19 Where are my marks stored? How to carry a file between two computers to preserve marks?
:help viminfo-file
:help 'viminfo'

	52.20 running shell command in the directory of the file
 :!cd %:p:h ; somecommand arg1 arg2

	52.21 vimgrep: how to get rid of E303

-> Hi,

	I'm not sure what has changed in my environment/settings but now every
		time I run a recursive vimgrep on my project's source files I get this
		endless list of errors saying:
		E303: Unable to open swap file for "[filename]" recovery impossible

		The message slows down the search considerably. Also, it was annoying
		to use enter/space just to get the search going - that is until I
		found that G gets you the the end of the search/error list.

		My question is how to eliminate this error when grepping.

		TIA,
	Yosi

-> 
> I'm not sure what has changed in my environment/settings but now every
> time I run a recursive vimgrep on my project's source files I get this
> endless list of errors saying:
> E303: Unable to open swap file for "[filename]" recovery impossible
>

:help E303 says "you may want to change the 'directory' option to
avoid this error." What does ":verbose set directory?" tell you?

Check ":help 'directory' for the format of this option and a list of
potential gotchas, and make sure you have write privileges in the
directories listed.

-> 
>
> :help E303 says "you may want to change the 'directory' option to
> avoid this error." What does ":verbose set directory?" tell you?
>
> Check ":help 'directory' for the format of this option and a list of
> potential gotchas, and make sure you have write privileges in the
> directories listed.

:verbose set directory
 directory=$VIMvimfilestemp
        Last set from ~/.vimrc

	$VIM is /usr/local/share/vim and I don't have permissions there.

	I found the following in .vimrc:
	set backupdir=$VIM\vimfiles\backup " where to put backup file
	set directory=$VIM\vimfiles\temp " directory is the directory for temp file

	And changed to
	set backupdir=/tmp/vimbackup " where to put backup file
	set directory=/tmp/vimtemp " directory is the directory for temp file

	Then double checked setting:
	verbose set directory
	directory=/tmp/vimtemp

	I do have permission to /tmp. I tried touching, reading writing and
	deleting files. All work.
	The E303 error persists though (after I restarted vim to make sure the
			changed .vimrc applies).
	Last, I tried removing the settings from my .vimrc and just settle for
	VIM's default. This eliminated the error :)

	Thanks for the help!
	Yosi

	52.22 :set nu -> how to copy lines with line numbers?
-> when I mark in visual mode, only the text itself (what do we need
		normally) is marked.

sometimes I would like to select the interesting lines with the line
numbers from the left margin.

how to copy them along with the text?

-> One possibility: use :print (see :help :print)

Select lines you want to copy, say ':print' and select the lines with your
mouse, along with the line numbers.

-> You have several alternatives. First you could use the TOhtml command
to let vim generate a html file, which includes the line numbers, if I
am not mistaken. You could then copy and paste from that html file.

Another possibility would be to replace each line by its line number
plus it's content, so you could copy it with the line number included.
This can be done using the following substitute command:
:s/^/\=printf("%2d ", line('.'))/
You obviously want to undo this replace after copying using e.g. undo
or :s/^\d\+ //

Or you create your own command to take care of copying the desired
text together with the line numbers. Something like this should work:

fu! YankNu(first, last)
       let start=a:first
       let l=[]
       while start <= a:last
               let l = add(l,printf("%".len(a:last) . "d %s",start , " " . getline(start)))
               let start+=1
       endwhile
       return join(l,"\n") . "\n"
endfu

com! -nargs=0 -range Yank :let @+=YankNu(<line1>,<line2>)

Now select your text and enter :Yank
The function then copies the range into your +-register (which should
correspond to your System's clipboard, if your vim was compiled with
clipboard functionality [:help should output +clipboard, instead of
-clipboard] and can access it)

-> Open the file with console vim in a terminal, :set nu, and use the mouse.

-> You can use

  :redir @a
  :sil! '<,'>#
  :redir END

to pull the numbered lines into register "a".  This can be
wrapped into a mapping:

 :vnoremap <f4> :<home>redir @a<bar>sil! <end>#<bar>redir END<cr>

assuming you always want to tromp the same register.  If you use
it frequently, you might designate a preferred register such as
"n" for "(n)umbered" and then only use it for that purpose.
Alternatively, :redir allows you to redirect to other sinks if
you prefer.



	52.23 bring two buff into diff mode
Supposing I have two files opened in two separated buffers b1 and b2,
and now I decide to compare b1 and b2 as if I open these file by 'vim
-d f1 f2', how can vim help me accomplish this?  

Usually I have exactly two windows open when I want to do this,
and the following command starts diff:
 :windo diffthis

After making some changes, you might want:
 :windo diffupdate
[Small correction: the latter :windo should be omitted:
   :diffu 
]

When finished, turn off:
 :diffoff!

It's also handy to know that you can move the windows around:
 Ctrl-W K  (move current window up)
 Ctrl-W L  (move current window to right)

	52.24 How to save recordings in vimrc
Q: Is there a way to save recordings, as I often need to retype all the
useful recordings(e.g commenting a line) whenever I open a vim
session.

A:
-> there may be other ways, but one thing i like to do is to create
modules for specific purposes

let's say for example i am going to be working on some html -- i
will

   :source ~/.vim/html_lets

   which looks like

   <html_lets>
   echo 'html_lets being applied'
   echo 'insert mode <C-R>register inserts them'

   let @a = '<a href=""></a>'
   let @b = '<br>'
   let @c = '<!-- -->'
   let @g = '&gt;'
   let @l = '&lt;'
   let @p = '<pre>
   </pre>'
   let @q = '&quot;'

   "  vim:ft=vim
   </html_lets>

   what these "lets" do is populate various registers with things i
   find useful in an html edit session, which i use with the insert
   mode <C-R>

   if you want, you can save your recording(s) in a similar module

	   to access them, read up on "redir" -- save the output of

		      :reg

		      using redir, then make a module to be sourced that contains "let"s
		      for the recordings you find most useful -- this is a handy way of
			      editing your recordings after you've made them too

-> Well, let's see if I understand you, which isn't certaion since you
aren't using established Vim terminology. I think tht you are talking
about (register) _macros_, i.e., series of keystrokes recorded "by doing
them" by means of the Normal-mode commands qa to qz, but that (key)
_mappings_ might be more useful to you.

Mappings are sequences of keystrokes assigned to one key or to a
sequence of keys by means of one of the variations on the |:map|
command, see |map-overview|. For instance, I have the following in my
vimrc so that hitting F11 will always move to the next (split) window in
sequence, and Shift-F11 will go to the previous one:

       :noremap        <F11>   <C-W>w
       :noremap        <S-F11> <C-W>W
       :inoremap       <F11>   <C-O><C-W>w
       :inoremap       <S-F11> <C-O><C-W>W

The difference between mappings and registers is that mappings are
defined by the ":map" (and family) ex-command, and are often written in
the vimrc, while qa to qz macros are saved in a register at the moment
you record them, and registers can be saved from one session to the next
in the |viminfo| file.

See
       :help map.txt
       :help viminfo
       :help 'viminfo'
       :help complex-repeat
       :help registers

 

	52.25 how to perform action on all modified buffers

		52.25.1 Question


Hi,

Possibly a trivial question, yet I searched some, read help some and
couldn't find a quick answer.
I actually have two sub questions:

|1. say I want to perform an action on all modified buffers. Like
performing compress or just echo their name. how is it done?
I read about bufdo and assume the answer lies in that direction.

|2. More complex. Say I want to execute a shell (bash) command on all
buffers. For the buffers that the shell command succeeds (i.e. returns 0) perform some action. This can be useful for example to compress all
files larger than a given size, checking in all checked-out source
files  at the end of editing session etc.
what I had in mind is something along the lines of:
:silent bufdo !if test_cmd % > /dev/null ; then execute_desired_cmd
% ; fi

Haven't tried it yet and I have to go offline but I'm guessing it
won't work.

TIA,
Yosi
		
	
		52.25.2 Answers
-> Christian Brabandt

Hi WL!

On Do, 04 Jun 2009, WL wrote:

> 1. say I want to perform an action on all modified buffers. Like
> performing compress or just echo their name. how is it done?
> I read about bufdo and assume the answer lies in that direction.

This echoes the name of all modified buffers:
set hidden
:bufdo if &modified | echo bufname("%") 'modified!' |sleep 1 | endif

> 2. More complex. Say I want to execute a shell (bash) command on all
> buffers. For the buffers that the shell command succeeds (i.e. returns
> 0) perform some action. This can be useful for example to compress all
> files larger than a given size, checking in all checked-out source
> files  at the end of editing session etc.
> what I had in mind is something along the lines of:
> :silent bufdo !if test_cmd % > /dev/null ; then execute_desired_cmd
> % ; fi

Not sure. Probably depends on what exactly you are trying to achieve.
		
-> Tim Chase
> 1. say I want to perform an action on all modified buffers. Like
> performing compress or just echo their name. how is it done?
> I read about bufdo and assume the answer lies in that direction.

You're right -- though the command you want to execute may have
to be wrapped in an exec() call/statement.  It may also need to
have 'hidden' set to allow you to leave the modified buffers:

  :set hidden
  :bufdo if &modified | some_ex_command | endif

where some_ex_command may require using exec as described at

  :help :bar

which lists the "problem" commands (those that eat following
bars/pipes), as well as the example of using :execute

> 2. More complex. Say I want to execute a shell (bash) command on all
> buffers. For the buffers that the shell command succeeds (i.e. returns
> 0) perform some action. This can be useful for example to compress all
> files larger than a given size, checking in all checked-out source
> files  at the end of editing session etc.
> what I had in mind is something along the lines of:
> :silent bufdo !if test_cmd % > /dev/null ; then execute_desired_cmd
> % ; fi

Not sure on this one, but it looks fairly kosher.

-> Tony Mechelynck
>
> Hi,
>
> Possibly a trivial question, yet I searched some, read help some and
> couldn't find a quick answer.
> I actually have two sub questions:
>
> 1. say I want to perform an action on all modified buffers. Like
> performing compress or just echo their name. how is it done?
> I read about bufdo and assume the answer lies in that direction.

yes, see other replies

>
> 2. More complex. Say I want to execute a shell (bash) command on all
> buffers. For the buffers that the shell command succeeds (i.e. returns
> 0) perform some action. This can be useful for example to compress all
> files larger than a given size, checking in all checked-out source
> files  at the end of editing session etc.
> what I had in mind is something along the lines of:
> :silent bufdo !if test_cmd %>  /dev/null ; then execute_desired_cmd
> % ; fi
>
> Haven't tried it yet and I have to go offline but I'm guessing it
> won't work.
>
> TIA,
> Yosi

       silent bufdo exe '!some_shell_command > /dev/null'
                       \ | if !v:shell_error
                               \ | call SomeUserFunc()
                       \ | endif

The :exe wrapper (with single quotes for literal quoting) is necessary
to allow other ex-commands after it on the same line.
See
       :help :bar
       :help v:shell_error

On Dos/Windows, replace >/dev/null by >NUL -- the rest should work,
except of course that you may need to call an external command with a
different name.

-> WL
> This echoes the name of all modified buffers:
> set hidden
> :bufdo if &modified | echo bufname("%") 'modified!' |sleep 1 | endif
>
This seems to work well thank you!
How do I perform shell commands on the modified buffers, like for
example compressing them?
Would the following work?
:bufdo if &modified | tar -rvf archive.tar %  |sleep 1 | endif
I tried it and it did not seem to work. In-fact it seemed to mess up
VIM input and output streams.


> > what I had in mind is something along the lines of:
> > :silent bufdo !if test_cmd % > /dev/null ; then execute_desired_cmd
> > % ; fi
>
> Not sure. Probably depends on what exactly you are trying to achieve.
>
I tried the following:
:silent budfo !if ls % | grep desired_pattern > /dev/null; then echo
%; fi
and got this error: E492: Not an editor command: silent budfo !if ls % | grep Flow > /dev

On Jun 7, 9:02 am, Tony Mechelynck  wrote:
>         silent bufdo exe '!some_shell_command > /dev/null'
>                         \ | if !v:shell_error
>                                 \ | call SomeUserFunc()
>                         \ | endif
>
> The :exe wrapper (with single quotes for literal quoting) is necessary
> to allow other ex-commands after it on the same line.
> See
>         :help :bar
>         :help v:shell_error
>
> On Dos/Windows, replace >/dev/null by >NUL -- the rest should work,
> except of course that you may need to call an external command with a
> different name.
>

I copied the suggestion to the letter. I got an error when executing
it from : prompt.
So I executed:
:silent budfo exe 'if ls % | grep desired_pattern > /dev/null' | if !
v:shell_error | !echo % | endif
and got error:
E492: Not an editor command: silent budfo exe 'if ls % | grep
desired_pattern >

Seeing as this is not trivial (well at least not for me) I'd like to
ask specific related questions.
|1. How do I put all modified buffers to archive?- Ultimately I'd like
to either map the command or add to a GUI menu.
|2. How do check in all buffers that pass a shell test (meaning $test
buffer returns $? value of 0)?
Specifically. All files that pass cleartool ct ls buffer | grep
CHECKEDOUT (i.e. they are checked out) will have the check in command
executed on them: cleartool ci -nc buffer.

->
Hi yosi!

On Di, 09 Jun 2009, yosi izaq wrote:

>
> On Sun, Jun 7, 2009 at 3:28 PM, WL wrote:
> > ...
> > Seeing as this is not trivial (well at least not for me) I'd like to
> > ask specific related questions.
> > 1. How do I put all modified buffers to archive?- Ultimately I'd like
> > to either map the command or add to a GUI menu.

Here we go:

set hidden
let archive=[]
bufdo if &modified |  call add(archive, shellescape(expand("%"),1))| endif

if len(archive) > 0
   exe "!tar -cvjf archive.tar.bz2 " . join(archive, " ")
endif

> > 2. How do check in all buffers that pass a shell test (meaning
> > $test
> > buffer returns $? value of 0)?
> > Specifically. All files that pass cleartool ct ls buffer | grep
> > CHECKEDOUT (i.e. they are checked out) will have the check in command
> > executed on them: cleartool ci -nc buffer.

As Tony said, something like this should work:

bufdo exe "!test -f " . expand("%") ."  > /dev/null"
    \ | if !v:shell_error
    \ | echo "passed"
    \ | endif


-> 
On Wed, Jun 10, 2009 at 12:20 AM, Christian Brabandt wrote:

>> > 1. How do I put all modified buffers to archive?- Ultimately I'd like
>> > to either map the command or add to a GUI menu.
>
> Here we go:
>
> set hidden
> let archive=[]
> bufdo if &modified |  call add(archive, shellescape(expand("%"),1))| endif
>
> if len(archive) > 0
>    exe "!tar -cvjf archive.tar.bz2 " . join(archive, " ")
> endif
>
First I'd like to clarify why I asked again. I asked how to perform
said things from ex prompt. I have tried and tested the answers I got
from ex prompt. Re. this question the first answer I got worked well -
alas I didn't/don't have sufficient knowledge to modify it to do what
I wanted (archive).
Now, I guess you mean by your answer that I should add a function to
.vimrc. I did that and added:
function! Archive_all_modified_buffers()
   set hidden
   let archive=[]
   bufdo if &modified |  call add(archive, shellescape(expand("%"),1))| endif

   if len(archive) > 0
      exe "!tar -cvjf archive.tar.bz2 " . join(archive, " ")
   endif
endfunction

Then I called it (call Archive_all...). It seemed to work on all the
(modified?) buffers but I didn't see the archive.tar.bz2 file being
created. Nor could I find it in my account.


>> > 2. How do check in all buffers that pass a shell test (meaning
>> > $test
>> > buffer returns $? value of 0)?
>> > Specifically. All files that pass cleartool ct ls buffer | grep
>> > CHECKEDOUT (i.e. they are checked out) will have the check in command
>> > executed on them: cleartool ci -nc buffer.
>
> As Tony said, something like this should work:
>
> bufdo exe "!test -f " . expand("%") ."  > /dev/null"
>     \ | if !v:shell_error
>     \ | echo "passed"
>     \ | endif
>
>
Yes. I tried Tony's suggestion from ex prompt and got an error
(reported it earlier in thread).
This time I added his suggestion as a function and it works perfectly well :)
I added:
function! Perform_Shell_Test_all__buffers()
bufdo exe "!test -f " . expand("%") ."  > /dev/null"
   \ | if !v:shell_error
   \ | echo "passed"
   \ | endif
endfunction

function! CheckIn_all__buffers()
bufdo exe "!ct ls  " . expand("%") ." | grep -i checkedout > /dev/null"
   \ | if !v:shell_error
   \ | echo "file is checked out"
   \ | exe "!ci " . expand("%")
   \ | endif
endfunction

They both work well. (ci is aliased the cleartool ci -nc).

Thanks,
Yosi

		52.25.3 Excertp from .vimrc of adding menu actions to archive all modified buffers and checkin all checkout buffers:

" My personal menu
amenu MyMenu.HighlighCtxt       :match ToDo /^\s\+-\+>.*$/<cr>
amenu MyMenu.KBEntries          :match StatusLine /^\s*\d\+\..*$/<cr>
amenu MyMenu.-SEP-      :   
amenu MyMenu.ArchiveBuffers     :silent bufdo !tar -rvf ~/temp/vim_archive.tar %:p<cr>
amenu MyMenu.-SEP-      :   
amenu MyMenu.highlight          :set cursorline<cr>
amenu MyMenu.highlightV         :set cursorcolumn<cr>
amenu MyMenu.-SEP-      :   
vmenu MyMenu.makeArrowList              :call ArrowList()<cr>
vmenu MyMenu.makeNumberList             :call NumberList()<cr>
amenu MyMenu.-SEP-      :   
amenu MyMenu.InsertFileLink             :s/^.*$/&\r<URL:[File Path]><cr>
amenu MyMenu.InsertLocalLink            :s/^.*$/&\r<URL:#tn=[pattern in file]><cr>
amenu MyMenu.-SEP-      :   
amenu MyMenu.ArchiveModifiedBuffers            :call Archive_all_modified_buffers()<cr>

" My ACS 5, linux develoment environment clearcase menu
amenu MyCCMenu.checkout       :! co % <cr>
amenu MyCCMenu.checkin       :! ci % <cr>
amenu MyCCMenu.-SEP-      :   
amenu MyCCMenu.version_tree       :! ct lsvtree -g % <cr>
amenu MyCCMenu.diff_pred       :! ct diff -pred -graph % <cr>
amenu MyCCMenu.-SEP-      :   
amenu MyCCMenu.checkin_all       :call CheckIn_all__buffers()<cr>

"Custom functions
function! Archive_all_modified_buffers()
    set hidden
    let archive=[]
    bufdo if &modified |  call add(archive, shellescape(expand("%"),1))| endif
    
    if len(archive) > 0
       exe "!tar -cvjf archive.tar.bz2 " . join(archive, " ")
    endif
endfunction

function! Perform_Shell_Test_all__buffers()
bufdo exe "!test -f " . expand("%") ."  > /dev/null"
    \ | if !v:shell_error
    \ | echo "passed"
    \ | endif
endfunction

function! CheckIn_all__buffers()
bufdo exe "!ct ls  " . expand("%") ." | grep -i checkedout > /dev/null"
    \ | if !v:shell_error
    \ | echo "file is checked out"
    \ | exe "!ci " . expand("%")
    \ | endif
endfunction

	52.26 Tags paths problem: "E429: File "/users/yizaq/.vim/tags/long/path/to/file.h" does not exist "

		52.26.1 question


Hi,

Up until a month ago I used tags by generating a tags file and placing
it in the root directory of my project. Then I would open vim from
this directory and searching for tags (ctrl+[) was working well.
I changed that when I installed the omni complete plugin. The
instructions for installing it suggests putting the tags file in a
fixed location so I put my tags file in ~/.vim/tags.
Now when I open VIM and try to get to a tag (ctrl+[) I get an error
that the file was not found as follows:
 "E429: File "/users/yizaq/.vim/tags/long/path/to/file.h" does not
exist"
The thing is that the path to get to this file, given that I fired up
VIM from the projects root dir is /long/path/to/file.h
the added prefix of the tags location is evidently causing this error.

My question is whether it is possible to change that via configuration/
settings?- I can always just keep a local copy of the tags file in the
root dir of the project and choose this match as a workaround but I'd
like to better understand and handle this.

		52.26.2 Answers
-> Alessandro Antonello	
I am not sure if this is your problem, but...

You can create your tags file with the following command to ctags tool:

 ctags -f out_put/path/file %--c++-kinds=+p --fields=+iaS --extra=+q
 --tag-relative=yes sources/path/*

This is the way  I use it in a Windows XP  SP2 environment and GVim.  Usually I
enter this  command line in a  directory above the directory  where the sources
are (I have a common directory structure for all my projects).  But this is not
really relevant if you set the correct target and source directories and path.

If you set the  'tags'  option  correctly  Vim  (of  GVim)  will know where the
sources are.  See:

:help tag-commands


Sorry! The command line to the ctags tool is:

  ctags -f out_put/path/file --c++-kinds=+p --fields=+iaS --extra=+q
  --tag-relative=yes sources/path/*

I left a '%' sign in the preceding message in the middle of the command line.

Alessandro Antonello


*/

-> yosi izaq
>

> Sorry! The command line to the ctags tool is:
>
>   ctags -f out_put/path/file --c++-kinds=+p --fields=+iaS --extra=+q
>   --tag-relative=yes sources/path/*
>
> I left a '%' sign in the preceding message in the middle of the command line.
>

Since I launch VIM from my projects root dir I figured I need to set
the relative paths of the tags to that so I create the tags using this
command:
[yizaq@yizaq-lnx:Wed Jun 17:/path/projects/root/dir/]$ ctags -R
--c++-kinds=+p --fields=+iaS --extra=+q  --languages=c++  -f tags .
--tag-relative=yes ./

I then moved the tags to .vim/tags/my_proj/

However the tags still have wrong path, see example:
 # pri kind tag               file
 1 F   f    ParsedRequest     /users/yizaq/.vim/tags/proj/path/to/file.h
              class:ParsedRequest::ParsedRequest access:public signature:()
              ParsedRequest::ParsedRequest()
 2 F   s    ParsedRequest     /users/yizaq/.vim/tags/proj/path/to/file.h
              struct ParsedRequest
Choice number (<Enter> cancels): 2
E429: File "/users/yizaq/.vim/tags/proj/path/to/file" does not exist

Clearly, the path is wrong since it should be only proj/path/to/file.h

I'm probably missing something here. I read in the help that:
"
If the 'tagrelative' option is on (which is the default) and using a tag file
in another directory, file names in that tag file are relative to the
directory where the tag file is.
"
If that is the case then perhaps I should turn that option off. I
tried that but it didn't change the tag paths.
I created the tags using:
ctags -R --c++-kinds=+p --fields=+iaS --extra=+q  --languages=c+
+  -f tags . --tag-relative=no

Then moved to the .vim/tags/proj but when searching the tag I get the
same result as above.

I confirm with just creating a symbolic link to the tags file from my
project's root dir (from where I launch VIM). since I set ./ to be
searched first for the tags file the symbolic link is chosen and so
the paths are relative to my project's root dir which is what I need.

For example:
[yizaq@yizaq-lnx:Tue Feb 16:/view/yizaq1__int.acs5_0.lx/vob/nm_acs/acs/runtime]$ ln -s ~/.vim/tags/acs_5_2/tags tags


*/
	52.27 how to match the space Not begin from the start-of-line
 I want to know how to match the space that is not in the start of the line.

for example
   sss sss
^^^^   ^
I just match the second part of the sample.
Can anyone help me?

-> How about:

/^\s\+\S\+\zs\s

/    - Search
^    - Start of the line
\s\+ - One or more spaces (replace \+ with * if you don't mind whether
there are spaces)
\S\+ - One or more non-space characters
\zs  - Start the match from here (so ignore everything before)
\s   - A space

-> You want the "\@<!" modifier:

  \%(^\s*\)\@<!\s

which "Matches with zero width if the preceding atom does NOT
match just before what follows." as detailed at

  :help /\@<!

In this case, the preceding atom is

  \%(^\s*\)

or "whitespace at the beginning of the line".

-> Thank for quick reply,  you pattern work for this case.
I think I do not say clear, the other example
   sss  sss   ss
^^^^   ^^   ^^  ^^

just match the second part. I want to match the 2,3,4 part

thanks Tim , I think your atom work well. I know the \@<! , but I use
the   \%(^\s\+\)\@<!\s ,
can you tell me, why the \s\+ not work well, but the \s* work well

-> 
They should be nearly equiv., with the only difference being the
"\+" version *requires* that the line start with whitespace (one
or more whitespace characters) whereas the "*" version allows the
line to start without -whitespace.  This also finds *all* the
non-leading whitespace on the line.  If you want just the first
space, A.S. Budden posed a good solution.

-> Ah, sorry, I misunderstood.  I think Tim has posted a good solution,
but another option would be:

/\S\@<=\s

\S - Non space
\@<= - Match with zero width if the \S is present
\s\+ - The spaces (or tabs) that you're looking for.

This will match any space characters that are preceded by something
that isn't a space character.  You can probably also do:

\S\zs\s\+

	52.28 Exit message
" bye bye message
 au VimLeave * :call PrintAtExit()
   function! PrintAtExit()
       echo "Hope you had a good VIM session :) "
   endfun

	52.29 Folding question of a ToDo list file
Hi,

I keep a monthly ToDo list file in the format of:

date:
-> item1
 --> subitem11
 --> subitem21
    --->subsubitem211
...

example:
08/09:
-> Post to vim_use
 --> Fold question

-> Read 200 lines of debug logs of recent application crash:
[200 lines of logs]

-> Do something else

09/09
...

I would like to apply the most simple directive to fold all the file
so that each item (->) would be closed.
I tried to play a bit with foldmarker but the results were not what I
expected. For example I tried:
set foldmethod=marker foldmarker=->,->

I would appreciate any tips you may have.

-> Answer, using syntax:
None of the lines start with `contains'. The lines were broken
automatically. The simplest way to test would be to paste it into a
file (e.g., /tmp/todo_syntax.vim) and source the file from within the
file containing your TODO items. E.g.,

	:so /tmp/todo_syntax.vim

		Here's the same script with backslashes continuing the long lines to
		prevent their being broken:

		syn region Lvl1 start=/^\s*-\{1}>/ end=/^\s*-\{1}>/me=s-1
		\ contains=Lvl2,Lvl3,Lvl4 fold
		syn region Lvl2 start=/^\s*-\{2}>/ end=/^\s*-\{1,2}>/me=s-1 contained
		\ contains=Lvl3,Lvl4 fold
		syn region Lvl3 start=/^\s*-\{3}>/ end=/^\s*-\{1,3}>/me=s-1 contained
		\ contains=Lvl4 fold
		syn region Lvl4 start=/^\s*-\{4}>/ end=/^\s*-\{1,4}>/me=s-1 contained
		\ fold
		set foldmethod=syntax

-> created syntax file for my context files "my_ctxt_syn.vim"

syn region Lvl1 start=/^\s*-\{1}>/ end=/^\s*-\{1}>/me=s-1 contains=Lvl2,Lvl3,Lvl4 fold
syn region Lvl2 start=/^\s*-\{2}>/ end=/^\s*-\{1,2}>/me=s-1 contained contains=Lvl3,Lvl4 fold
syn region Lvl3 start=/^\s*-\{3}>/ end=/^\s*-\{1,3}>/me=s-1 contained contains=Lvl4 fold
syn region Lvl4 start=/^\s*-\{4}>/ end=/^\s*-\{1,4}>/me=s-1 contained fold

	52.30 How to force windows vim to load appropriate vimrc?
-> Hi,

	I have two gvim 7.2 installs on my machine. One for cygwin and another
	for windows. I recently noticed that the windows gvim is actually
	loading the cygwin ~/.vimrc file instead of the Program file/vim/
	_vimrc file.
	How come? and how can I fix that?

	TIA,
	Yosi

->    :help _vimrc
One way would be to put this at the top of your ~/.vimrc:

   if has("win32")
       source $VIM/_vimrc
       finish
   endif

HTH,
Gary

-> Fritz:
> I have two gvim 7.2 installs on my machine. One for cygwin and another
> for windows. I recently noticed that the windows gvim is actually
> loading the cygwin ~/.vimrc file instead of the Program file/vim/
> _vimrc file.
> How come?

Vim will always source the .vimrc (or _vimrc) that is in your HOME
directory. Apparently you either have an environment variable HOME
set, or you placed your .vimrc in the same place that Windows looks
for HOME. You can determine the setting of HOME by doing ":echo $HOME"
from within Vim.

> and how can I fix that?
>

As Gary suggests, make sure your .vimrc works on both Windows and
cygwin, possibly by sourcing the Windows-only vimrc or a Cygwin-only
vimrc depending on platform.

I find it nicer to use the SAME configuration for both platforms, and
just separate out stuff that shouldn't be common within the vimrc
itself.

-> My preference: put it all in ~/.vimrc file and use has("unix")/"win32"/"win32unix" for unix/windows/cygwin specific settings

	52.31 listing total number of buffers in the statusline
let @b=bufnr('$')
reg b

	52.32 generate lines with increasing numbers
I have questions about getting vi to add numbers in sequence within a file.

Example:

dummy01
dummy02
dummy03
dummy
dummy
....

etc.

So If I have 1000 dummy's and instead of hand typing all this in a file. I wonder if there was
an easy to accomplish this using vim.

->
I think, the easiest solution would facilitate a macro. Assuming you
have written dummy01 and the cursor is on the word dummy, record the
macro into register a like this:
qayyp$^Aq

(where ^A ist a literal Ctrl-A key press not the 2 keys ^ and A).

And then execute 100@a which executes the macro stored in register a.

Note, that you can also fill the register explicitly, if you know
exactly what to execute (^A ist inserted as Ctrl-V Ctrl-A):
:let @a="yyp$^A"
100@a

Another solution, which would only work with vim 7.2 with patch 295
included uses a little bit scripting:

:let list=repeat(["dummy"], 100)
:call map(list, 'v:val.printf("%02d",v:key+1)')
:call append("$", list)

-> :call append('$', map(range(100), 'printf("dummy%02d", v:val)'))

	52.33 VIM and web pages, how to read web pages (URL) in VIM

e http://www.cnn.com
will retreive the html

:r !lynx -dump http://www.somewebsite.com
will format the text as well (remove html tags)
w3m and links can be used instead of lynx

	52.34 Can't save file due to "CONVERSION ERROR in line..."
- My way
w! ++enc=utf8

-
Yosi Izaq
 to vim_use
Hi,

This happens to me when I copy paste text from my browser. It's
driving me crazy :)
How can I turn this off?

TIA,
Yosi
----------------------------------------------------------------------------------------------------
Charles Campbell	
I can't precisely answer this, but I'll give you some guesses: I'll guess tha...
	
Mar 25 (3 days ago)
Charles CampbellLoading...	
Mar 25 (3 days ago)
Charles Campbell
 to vim_use
	
show details Mar 25 (3 days ago)
	
- Show quoted text -
Yosi Izaq wrote:

    This happens to me when I copy paste text from my browser. It's
    driving me crazy :)
    How can I turn this off?
     


I can't precisely answer this, but I'll give you some guesses:  I'll guess that the browser is using one encoding and you have gvim/vim using a different, incompatible encoding.  I'm not sure how to determine what encoding your browser is using, but the encoding for vim can be checked with

 set enc
 set fenc

If you can live with utf-8, try using that.

Regards,
Chip Campbell

----------------------------------------------------------------------------------------------------
Tony Mechelynck
 to vim_use
	
show details Mar 25 (3 days ago)
	
On 25/03/10 19:33, Charles Campbell wrote:

    Yosi Izaq wrote:

        This happens to me when I copy paste text from my browser. It's
        driving me crazy :)
        How can I turn this off?


    I can't precisely answer this, but I'll give you some guesses: I'll
    guess that the browser is using one encoding and you have gvim/vim using
    a different, incompatible encoding. I'm not sure how to determine what
    encoding your browser is using, but the encoding for vim can be checked
    with

    set enc
    set fenc

    If you can live with utf-8, try using that.

    Regards,
    Chip Campbell


Yes indeed.

Conversion error when saving the file means that the file in the buffer (in the 'encoding' charset) contains one or more characters which cannot be represented in the 'fileencoding' charset which you're trying to save the file in. For instance, the file contains an œ character (French oe digraph) and you're trying to save it in Latin1.

If the conversion error happens when reading or pasting into Vim memory, then your 'encoding' is not compatible with the data; IOW, Vim cannot represent the data in memory with the present choice of 'encoding'.

I recommend to use UTF-8 for the data in Vim memory ('encoding'), because Unicode (including UTF-8) can represent any possible computer charset. Conversion between Unicode and Latin1 is trivial and Vim (if compiled with +multi_byte of course, i.e. if has('multi_byte') is nonzero) can do it without external help; conversion to or from some other non-Unicode charset (or to or from GB18030, which technically is a Unicode charset but requires large conversion tables) usually requires the iconv library, either compiled-in or available for dynamic load at runtime (to check it, make sure that has('iconv') has a nonzero value).

See also http://vim.wikia.com/wiki/Working_with_Unicode and the help pages mentioned there.

See also :help 8g8


Best regards,
Tony.
----------------------------------------------------------------------------------------------------
yosi izaq
 to vim_use
	
show details 11:10 AM (0 minutes ago)
	
- Show quoted text -
>> I can't precisely answer this, but I'll give you some guesses: I'll
>> guess that the browser is using one encoding and you have gvim/vim using
>> a different, incompatible encoding. I'm not sure how to determine what
>> encoding your browser is using, but the encoding for vim can be checked
>> with
>>
>> set enc
>> set fenc
>>
>> If you can live with utf-8, try using that.
>>
>> Regards,
>> Chip Campbell
>>
>
> Yes indeed.
>
> Conversion error when saving the file means that the file in the buffer (in
> the 'encoding' charset) contains one or more characters which cannot be
> represented in the 'fileencoding' charset which you're trying to save the
> file in. For instance, the file contains an œ character (French oe digraph)
> and you're trying to save it in Latin1.
>
> If the conversion error happens when reading or pasting into Vim memory,
> then your 'encoding' is not compatible with the data; IOW, Vim cannot
> represent the data in memory with the present choice of 'encoding'.
>
> I recommend to use UTF-8 for the data in Vim memory ('encoding'), because
> Unicode (including UTF-8) can represent any possible computer charset.
> Conversion between Unicode and Latin1 is trivial and Vim (if compiled with
> +multi_byte of course, i.e. if has('multi_byte') is nonzero) can do it
> without external help; conversion to or from some other non-Unicode charset
> (or to or from GB18030, which technically is a Unicode charset but requires
> large conversion tables) usually requires the iconv library, either
> compiled-in or available for dynamic load at runtime (to check it, make sure
> that has('iconv') has a nonzero value).
>
> See also http://vim.wikia.com/wiki/Working_with_Unicode and the help pages
> mentioned there.
>
> See also :help 8g8
>
>
> Best regards,
> Tony.

Hi,

Thanks for the tips. Following two of them didn't really solve the issue.
set enc returns
 encoding=utf-8

 and set fenc returns
file encoding=latin1

How can I know which of them actually applies?- the utf-8 or the
latin1?- And how can I make sure utf-8, assuming this will resolve the
error, applies?

the 8g8 is nice but it's not robust enough to help me cope with 2k
line choke full of encoding wise illegal chars.
The tip though had an example of encoding settings. I added it to my
vimrc and it resolved the problem. For the record, end and fenc
remains the same after I apply the tip. The problem is gone though and
I can copy paste the problematic text to vim and save w/o error.

Thanks!
Yosi

Note: set fenc=utf-8 if you have further errors
----------------------------------------------------------------------------------------------------

	52.35 List known filetypes?
How can I get a list of known file types?
Preferably with info which criteria they are recognized by
(file suffix, interpreter directive...)

(I suspect this is a faq, but none of help helpgrep or
Google returns anything useful, or I can't come up with
the right search term. :-? )

----------------------------------------------------------------------------------------------------
>
> How can I get a list of known file types?

 :echo glob($VIMRUNTIME . '/ftplugin/*.vim')

or

 :echo glob($VIMRUNTIME . '/syntax/*.vim')

(I find the latter a better exhaustive list, the former are often
shared by multiple languages.)


> Preferably with info which criteria they are recognized by
> (file suffix, interpreter directive...)

Much tougher, each syntax/filetype is detected in a different way.
Often by extension, but sometimes by internal file structure or
format.

	52.35 how to count # of paragraphs
-> Hi,

I'm familiar with the %s/patt//n "trick" to count the # of patterns in
the file. I would like to ask how to count the # of paragraphs in a
file.
My question has 2 flavors:
a. Count free text paragraphs separated by empty lines
b. Count structured paragraphs that have a prefix and suffix
delimiters, such as
[
l1
l2
l3
]

[
l4
l5
]

I tried search as follows: /[\_p\{-}\]
and it matches well, however the search I tried didn't match: %s/[\_p\
{-}\]/n

I'm obviously doing something wrong and would appreciate pointers how
to do it right.

TIA,
Yosi

-> 	I tested against this text:

======= text starts here =======
[
l1
l2
l3
]
[
l4
l5
]

l1
l2
l3
l4

l1
l2
l3
l4
l5



====== text ends here ========

The following command finds four matches on the previous text:

:%s/\(\[\_p\{-}]\)\|\(\%^\|^\n\)\@<=\(\p\+\n\)\{-1,}\ze\(^\n\|\%$\)//n

Explanation:

:%s
 /           start pattern
   \(        start group
     \[      literal [
     \_p     any printable + \n
     \{-}    0 or more, as few as posible
     \]      literal ]
   \)        end group
 \|          or
   \(        start group
     \%^     start of file
   \|        or
     ^\n     an empty line
   \)        end group
   \@<=      match starts after previous group
   \(        start group
     \p\+\n  a non-empty line
   \)        end group
   \{-1,}    1 or more, as few as posible
   \ze       match ends before the next group
   \(        start group
     ^\n     empty line
   \|        or
     \%$     end of file
   \)        end group
 //n

It was fun writing that, but I suppose that somebody else can find a shorter alternative.

Cheers!
Israel

-> >>
>> :%s/\(\[\_p\{-}]\)\|\(\%^\|^\n\)\@<=\(\p\+\n\)\{-1,}\ze\(^\n\|\%$\)//n
>>

BTW, I tested both 
:%s/\(\[\_p\{-}]\)\|\(\%^\|^\n\)\@<=\(\p\+\n\)\{-1,}\ze\(^\n\|\%$\)//n
and
:%s/\(\[\_p\{-}]\)//n

Both worked well for my file and returned the same number. Why do you need all the or part, match start and end of file and look behind for the actual match?

Also for paragraphs that are separated by one empty line the following counted # of paragraphs:
%s/^\n\{1}//n
%s/^\n//n
%s/\(^\s*$\)//n

It works simply b/c there's one empty line per paragraph. I still didn't figure how to match: possible empty line followed by one or more lines of text followed by an empty line.

Cheers,
Yosi

-> 
	52.34 search for output of shell command
Hi,

For example, search for line starting with current day (^17).
How can it be done?- The following doesn't work: /^r!date | awk
'{print $3}'
I tried a few permutations but didn't figure out how to make it one
liner (in two commands it's simple, read to register and use it's
content in search pattern).

TIA,
Yosi
	
On 06/20/2010 06:38 AM, Yosi Izaq wrote:

    For example, search for line starting with current day (^17).
    How can it be done?- The following doesn't work: /^r!date | awk
    '{print $3}'


For your particular use-case, I'd use vim's internal strftime() function:

 :nnoremap <f4> /^<c-r>=strftime('%d')<cr><bslash>><cr>
 :cnoremap <f4> <c-r>=strftime('%d')<cr>

You don't mention what single-digit dates look like in your file (whether they are left-justified, or padded with spaces or a leading zero).  So you might have to use "%e" (pad with spaces) instead of "%d" (pad with a zero) or strip the unwanted stuff:

:nnoremap <f4> /^<c-r>=substitute(strftime('%d'), '^0*', '', '')<cr><bslash>><cr>

:cnoremap <f4><c-r>=substitute(strftime('%d'), '^0*', '', '')<cr>

==========================

For your more general case, I'd use vim's system() function to call an external program or chain and return the output such as:

  system("date | awk '{print $3}'")

however, that returns the trailing newline, so you'd have to clean that out:

substitute(system("date | awk '{print $3}'"), '\D', '', 'g')


To get this into your search, you can either assign to the search register:

 :let @/ = substitute(system(...)...)

and then use n/N to navigate next/previous matches, or you can use expression register (as I do above with control+R followed by the "=" to allow you to enter an expression that gets evaluated and returned in your context).  You can read more at

 :help @/
 :h c_CTRL-R_=
 :h substitute()
 :h system()
 :h strftime()

Hope this helps,

-tim

-> 

	52.35 how to display registers 0-9?- concise way & enhanced #,*

Q:
Hi,

As per subject. Yes :reg 0123456789 will do but aside from map is
there a more concise way?

like:
:reg seq(0,9)

I know it doesn't work, is there an equivalent that does?
note, :regi could do but it's overkill and takes more time...

Oh, and is there a WORD search equivalent to #,* (that search word) w/
o mapping?- if not, is there a commonly used map?

TIA,
yosi

A: 
execute 'registers '.join(range(0, 9))
? ``execute'' may be truncated to ``exe'', ``registers'' to ``reg',' other part
cannot by truncated, but ``j<tab>'' gives ``join('' and ``r<tab>'' gives
``range(''.

:execute 'registers'.join(range(0,9))

Q:
Hi ZyX,

Your answer to first part if helpful, though I didn't understand
what's probably Russian.
Thanks!

Any idea re. how to search for WORD with */# shortcuts?- Can I make a
map like \* \# for that?- Or is there already a common mapping that
does the same?

Thanks,
Yosi

A:
There are two ways:
a. Somewhat destructive, but the most simple: yank the word and search for it:
      noremap <special> \* yiW/<C-r>=escape(@", '^$*~[]\')<CR>
b. Custom function, like I use in my transliteration plugin to transliterate
current word:
           let s:tWregs=[['\(\S*\)', '\(\S\+\|\%$\)'],
                        \['\(\s*\)', '\(\s*\)'      ],]
           function s:LRmatch(patlist)
               let line=getline('.')
               let column=col('.')
               let match=[]
               let i=0
               let lpatlist=len(a:patlist)
               while i<lpatlist && (match==[] || match[0]=='')
                   let pattern=a:patlist[i][0].'\%'.column.'c'.a:patlist[i][1]
                   let match=matchlist(line, pattern)
                   let i+=1
               endwhile
               let lmatch=match[1]
               let rmatch=match[2]
               return escape(lmatch.rmatch, '^$*~[]\')."\n"
           endfunction
           " You cannot use script global variables in mappings, but you can
           " define a wrapper function
           function s:Eval(str)
               return eval(a:str)
           endfunction
           noremap <expr> \* "/".<SID>LRmatch(<SID>Eval('s:tWregs'))
           noremap <expr> \# "?".<SID>LRmatch(<SID>Eval('s:tWregs'))

This is a bit complicated, but it does not do anything with registers content
(except current search register @/, of course)

A:
Thanks for the answers. 

I chose the first option and tweaked it a bit to work with more spec. chars and add \# (duh), ending up with:
noremap <special> \* yiW/<C-r>=escape(@", '^$*~[]\</>')<CR>
noremap <special> \# yiW?<C-r>=escape(@", '^$*~[]\</>')<CR>

I think it's useful enough to perhaps post as a tip.

Thanks again,
Yosi


	52.36 how to read long shell output						

Q:
Hi,

	Say I'm executing a shell command with long output and want to read
	the results. Just running the cmd will only show the last lines of
	output. The question is how to make VIM present it in a scrollable
	window (w/o writing to explicit file...)?- Alternately, how to direct
	the output to quickfix or location list?

	Ex:
	! cd %:h && nm `find .. -name *.so ` <cr>

	output all the symbols in the shared object artifacts.

	Note, I read :h quickfix, didn't find the answer there.

	TIA,
	Yosi

A:
should work with standard unix command `less` and pipe , did you try
with it ?

! cd %:h && nm `find .. -name *.so ` | less <cr>

--
Best Regards,
Aaron Lewis - PGP: 0x4A6D32A0

A:
How about :r! nm `find %:h -name *.so ...` to redirect the output into a
scratch buffer?

regards,
	Christian

Q:
Aaron Lewis:
"
should work with standard unix command `less` and pipe , did you try
with it ?

! cd %:h && nm `find .. -name *.so ` | less <cr>
"

Doesn't work. See:
Error detected while processing /users/yizaq/.vimrc:
line  534:
E492: Not an editor command:  less <cr>

Christian Brabandt:
"
How about :r! nm `find %:h -name *.so ...` to redirect the output into a
scratch buffer?
"

I did
:r! cd %:h && nm `find .. -name *.so ` <cr>

but output goes to current buffer, not scratch. I'm probably doing
something wrong, could you please point out what?

Thanks,
	Yosi

A:
Check out RunView (http://mysite.verizon.net/astronaut/vim/index.html#RUNVIEW)

Regards,
	Chip Campbell

A:
Hi yosi!

On So, 22 Aug 2010, yosi izaq wrote:

> I did
> :r! cd %:h && nm `find .. -name *.so ` <cr>
>
> but output goes to current buffer, not scratch. I'm probably doing
> something wrong, could you please point out what?

Well open a new buffer first ;)
:h :enew

regards,
Christian

A:
On Sun, Aug 22, 2010 at 6:16 PM, Charles E Campbell Jr wrote:
>
> Check out RunView
> (http://mysite.verizon.net/astronaut/vim/index.html#RUNVIEW)
>
> Regards,
> Chip Campbell
Looks cool but probably an overkill. That page seems to have a
treasure of useful scripts though.


On Sun, Aug 22, 2010 at 8:59 PM, Christian Brabandt wrote:
> Hi yosi!
>
...
> Well open a new buffer first ;)
> :h :enew
>
> regards,
> Christian
That would work but I'd prefer to avoid the inconvenience of opening a
new window


On Mon, Aug 23, 2010 at 3:23 AM, Aaron Lewis wrote:
>
> Escape '|' then , like
>
> map <S-P> :! cd %:h && nm `find .. -name *.so ` \| less <cr>
>
> Best Regards,
> Aaron Lewis - PGP: 0x4A6D32A0
> FingerPrint EA63 26B2 6C52 72EA A4A5 EB6B BDFE 35B0 4A6D 32A0
> irc: A4R0NL3WI5 on freenode

duh *slap on head*. Naturally, works like a charm. Thanks.

Thank you all for the prompt and helpfull answers. I give 10/10 points
to this awesome mailing list!
Yosi

	52.37 How to emphesize or color a few key words on the fly?
> I'm referring to something like syntax files do - color keywords of
> language.
> However, instead of static definition I'm looking for a convenient way to
> color, say in yellow, the last two or three searched patters. This could be
> useful when analyzing dense source code and I saw at least one IDE that
> supports this.

Probably this helps you

http://vim.wikia.com/wiki/Highlight_multiple_words

<URL:#r=Highlight_multiple_words>
> Short Q. plz. It so turns out that my two main keyboards are, albeit
> fancy and expensive, devoid of a keypad, My rudimentary understanding
> of VIM script language is not sufficient to circumvent that. I'd
> greatly appreciate any suggestion how to adapt to no-keypad keyboards.
>

Yikes, that is hard to find!

I think you'll need to modify this code:

   for i in range(1, 9)
     execute 'vnoremap <silent> <k'.i.'> :<C-U>call
<SID>DoHighlight('.i.', 1, v:count)<CR>'
     execute 'nnoremap <silent> <k'.i.'> :<C-U>call
<SID>DoHighlight('.i.', 2, v:count)<CR>'
   endfor

Change "<k'.i.'>" in these to "<Leader>'.i.'" or "<F10>'.i.'" or
whatever prefix you want to press before a normal numeric key to
trigger the desired highlight mapping.

--------------------------------------------------------------------------------
Note that for keyboards w/o keypad the mapping won't work so you could highlight manually for example, search a pattern then do
:Highlight 1 CTRL-R/ 
To use H11 color for the / register (last search)

	52.38
53. Help system

	53.1  Basics
:h <subject> will take you to subject

:helpg <pattern> will search for pattern in all help .txt files




54. Mapping

	54.1 Basics



55.  VIM interaction with different applications, tools

	55.1  Firefox and VIM - vimperator 
http://vimperator.org/trac/wiki/Vimperator
Vimperator is a free browser add-on for Firefox, which makes it look and behave like the Vim text editor. It has similar key bindings and you could call it a modal web browser, as key bindings differ according to which mode you are in.

Warning: To provide the most authentic Vim experience, Vimperator hides the Firefox menubar and toolbar by default. Most users find them unnecessary once they're used to Vimperator, but if you really need them, type: :set guioptions+=mT to get them back.
If you don't like Vimperator at all, you can uninstall it by typing :addons and removing/disabling it.
If you like it, but can't remember the shortcuts, press F1 or :help.

Vimperator was initially written by Martin Stubenschrott but has found many other contributors in the meanwhile. If you appreciate the work on Vimperator and want to encourage us working on it more, you can send us greetings, patches, or donations (thanks a lot to these people who already did): 

Features ¶

screenshot_linux-small.png

    * Vim-like keybindings (h, j, k, l, gg, G, 0, $, ZZ, <C-f>, etc.)
    * Ex commands (:quit, :open www.foo.com, ...)
    * Tab completion available for all commands with support for 'longest' matching when set in 'wildmode'
    * Extensions! Yes, you can extend Vimperator's functionality with scripts just like you can extend Firefox with extensions.
    * Explore JavaScript objects with :echo window and even context-sensitive tab completion.
    * Hit-a-hint like navigation of links (start with f to follow a link)
    * Advanced completion of bookmark and history URLs (searching also in title, not only URL)
    * Vim-like statusline with a wget-like progress bar
    * Minimal GUI (easily hide useless menubar and toolbar with :set guioptions=)
    * Ability to :source JavaScript files, and to use a ~/.vimperatorrc file with syntax highlighting if you install vimperator.vim
    * Easy quick searches (:open foo will search for "foo" in google, :open ebay terminator will search for "terminator" on ebay) with support for Firefox keyword bookmarks and search engines
    * Count supported for many commands (3<C-o> will go back 3 pages)
    * Beep on errors
    * Marks support (ma to set mark 'a' on a webpage, 'a to go there)
    * QuickMarks support (quickly go to previously marked web pages with go{a-zA-Z0-9})
    * :map and :command support (and feedkeys() for script writers)
    * :time support for profiling
    * Move the text cursor and select text with vim keys and a visual mode.
    * External editor support
    * Macros to replay key strokes
    * AutoCommands to execute action on certain events
    * A comprehensive :help, explaining all commands, mappings and options.
    * Much more... 

		55.1.1  Tutorial

Vimperator

This is a quickstart tutorial to help get new users up and running in Vimperator. It is not indented as a full reference explaining all features.

Quick-start tutorial
	tutorial

If you've started using Vimperator from scratch (i.e., without any customization), you should be looking at this help page in a relatively bare-looking window. The menubar, navigation bar, and bookmark bars are hidden. In case you missed the notice in the Introduction, you can regain these by issuing the command

:set go+=mTb<cr>

where cr represents pressing the <Enter> or <Return> key. If you're a veteran Vim user, this may look familiar. It should.

However, in this author's opinion, the best way to get familiar with Vimperator is to leave these disabled for now. (The above action can be reversed with :set go=<cr>) You can look at the entry for guioptions in options for more information on this.

Vimperator's modal interface
	modal

Vimperator's power, like Vim's, comes from it's modal interface. Keys have different meanings depending on which mode the browser is in. Vimperator has several modes, but the 2 most important are ¿normal¿ mode and ¿command-line¿ mode.

When Vimperator starts, it is in normal mode by default. This is probably where you will spend the majority of your time.

The other core mode of Vimperator, command-line mode, can be entered from normal mode by typing a ':' (colon). You will frequently see Vimperator commands start with a ':', indicating that what follows is a command.

To return to normal mode command-line mode, type <Esc>. Pressing <Esc> will also return you to normal mode from most other modes in Vimperator.

Getting help
	getting_help

Vim is a great editor but it's not much of a web browser. So even seasoned Vim users will probably have to look at Vimperator documentation sooner or later. Most of the documentation for Vimperator's features are easily found using the :help command. For example, you can find help on the :help command by typing

:help :help<cr>

Similarly, help on configurable options is available with :help '{option_name}'. (Note the single quotes around the option name as in Vim.) Information on all available options is, predictably, :help options.

and you can find out about the gt and gT mapping with

:help gt<cr>
:help gT<cr>

Finally, in addition to the help system itself, :exusage and :viusage are useful quick-reference commands.

Mouseless
	living_mouseless

 or how I learned to stop worrying and love the 80+ buttons I already have.

The efficiency of Vimperator, as with the legendary editor it was inspired by, relies on the user being able to keep his fingers on the keyboard where they can do the most good. While there are some areas where the mouse is clearly superior at, such as GUI design or some games, Vimperator acts on the assumption that the web browser doesn't have to be one of those.

Here are some areas where the mouse is typically considered indisposable, and how Vimperator challenges this preconception.

Scrolling
	keyboard_scrolling

Scrolling the browser window is done with simple keystrokes:

    * j/k  scroll window down/up by one line, respectively
    * h/l  scroll window left/right
    * <Space>/<C-b>  scroll down/up by one page
    * <C-d>/<C-u>  scroll down/up by 1/2 page

Your standard buttons (<Up>/<Down>/<PgUp>/<PgDn>) will also work as expected.

History and tabs
	tab_navigation history_navigation

History navigation (e.g., ¿Back¿, ¿Forward¿) are done similarly to scrolling.

    * <C-o>/<C-i>  move Back/Forward in the current window/tab's history, respectively

Move between tabs using these keystrokes which may also be familiar to tabbing Vimmers.

    * gt/<C-n>  go to the next tab
    * gT/<C-p>  go to the previous tab
    * g0/g$  go to the first/last tab
    * d  close the active tab (delete the buffer)

To open a web page in a new tab, use the :tabopen {url}. To open a URL in the current tab, use :open. The normal mode mappings t and o, respectively, map to these commands, so the following pairs sequences are equivalent:

:open my.webmail.com<cr>
omy.webmail.com<cr>

:tabopen vimperator.mozdev.org<cr>
tvimperator.mozdev.org<cr>

Some hints about surfing¿
	hints.html

So now you can navigate around in Vimperator. But wait¿ how do you open a page or tab linked in a web page? How do you ¿click¿ on all those links without your tailed friend?

The answer is ¿hints¿. Activating hints displays a number next to every link Vimperator can find. To follow the link, simply type the number corresponding to the hint, a white number inside a red square by default.

For text links, there's an additional shortcut; you can type some text contained in the link and Vimperator will search all the links it can find and only hint the matching links, further narrowing down the list. If the text you type uniquely identifies any given link, Vimperator will follow that link immediately without any further user input.

Whichever way you choose to indicate your target link, once Vimperator has highlighted the link you want, simply hit <Enter> to open it.

The most common hint mode is called QuickHint mode. To activate QuickHint mode, press either f or F. The lower-case f will open the resulting link in the current tab, while the upper-case F will open it in a new tab.

To test it, try this link: Vimperator Homepage. Activate QuickHint mode with f or F to highlight all currently visible links. The start typing the text of the link. The link should be uniquely identified soon, and Vimperator will open it. Once you're done, remember to use <C-o> (¿History Back¿) or d (¿Delete Buffer¿) to return here, depending on which key you used to activate QuickHint mode.

Common issues
	common_issues

Say you get half-way done typing in a new URL, only to remember that you've already got that page open in the previous tab. Your command-line might look something like this:

:open my.partial.url/fooba

You can exit the command-line and access the already loaded page with the following:

<Esc>gT

Saving for posterity - vimperatorrc
	vimperatorrc

Once you get Vimperator set up with your desired options, maps, and commands, you'll probably want them to be available the next time you open Vimperator. Continuing the Vim theme, this is done with a vimperatorrc file.

To save your current settings and allow them to be loaded automatically next time you start Vimperator, issue the :mkv command.

This will create the file $HOME/.vimperatorrc containing your settings. It is a simple text file, just like a vimrc file and can be easily edited to suit your preferences.

Find the exit nearest you
	quitting_without_menus

Vimperator supports all of Vim's classic methods of exiting.

    * :xall  command to quit and save the current browsing session for next time; the default.
    * :qall  command to quit without saving the session
    * ZZ  normal mode mapping equivalent to :xall
    * ZQ  normal mode mapping equivalent to :qall

Where did Firefox go?
	whither_firefox

You might feel pretty disoriented now. Don't worry. This is still Firefox underneath. Here are some ways Vimperator allows Firefox to shine through. See the :help for these commands and mappings for more information on how to make the best use of them.

    * :dialog  To access some of Firefox's many dialog windows, you can use the :dialog command. See :help :dialog.
    * :bmarks  Vimperator provides a new interface to bookmarks, but they're still your standard Firefox bookmarks under the hood. :bmark will add a new bookmark, while :bmarks will list the bookmarks currently defined.
    * :history  It's exactly what it sounds like. This command will display a colorized, scrollable and clickable list of the locations in Vimperator's history.

Feel free to explore at this point. If you use the :tabopen command, remember to use the gt/gT mappings to get back to this page. If using the :open command, use the history keys (e.g., H) to return. If you get hopelessly lost, just type :help<cr> and click the ¿Tutorial¿ link to return.

Get me out of here!
	removal

If you've given it a fair shot and determined ¿ TODO

The Vimperator way to do this is with the command :addons. Issuing this command brings up the Firefox Add-ons dialog window; you can then remove it as normal, selecting Vimperator from the list and clicking (yes, clicking) Uninstall.

Alternatively, you can do this the old-fashioned way: re-enable the menubar, as above, with :set go+=m, and select Add-ons from the Tools menu.

I'm interested¿but lost!
	support

Vimperator has an energetic and growing user base. If you've run into a problem that you can't seem to solve with Vimperator, or if you think you might have found a bug, please let us know! There is support available on the wiki, or in the #vimperator IRC channel on freenode.

If you have any feature requests or (even better) offers to help, we'd love to hear from you as well. Developers work on Vimperator whenever possible, but we are neither infinite nor omnipotent; please bear with us. If you can't wait for us to get around to it, rest assured patches are welcome! See the Developer page for more information.

		55.1.2 Initialization
	startup initialization

At startup Vimperator sources a user RC file, containing Ex commands, and any JavaScript files found in the plugin directory. The RC file may be named .vimperatorrc or _vimperatorrc. The search order is:

    * Unix and Mac: ~/.vimperatorrc then ~/_vimperatorrc
    * Windows - ~/_vimperatorrc then ~/.vimperatorrc

The plugin directory is named:

    * Unix and Mac - ~/.vimperator/plugin
    * Windows - ~/vimperator/plugin

The user's '$HOME'(~) directory is determined as follows:

    * Unix and Mac - $HOME is used.
    * Windows - if %HOME% is set then this is used, otherwise %USERPROFILE% or finally %HOMEDRIVE%%HOMEPATH%.

$VIMPERATOR_HOME can be used to override the calculated $HOME directory.

Saving settings
	save-settings

:mkv :mkvimperatorrc
:mkv[imperatorrc][!] [file]

Write current key mappings and changed options to [file]. If no [file] is specified then ~/.vimperatorrc is written unless this file already exists. The special version :mkvimperatorrc! will overwrite [file] if it exists.

Warning: this differs from Vim's behavior which defaults to writing the file in the current directory.

Restarting
	restarting

:res :restart
:res[tart]

Force the browser to restart. Useful when installing extensions.


		55.1.3 		Browsing


Vimperator overrides nearly all Firefox keys in order to make browsing more pleasant for Vim users. In the rare occurrences where you want to pass a keystroke to the web page or to Firefox to retain its original meaning you have 2 possibilities:

pass-through <C-z> CTRL-Z


CTRL-Z

Disable all Vimperator keys except <Esc> and pass them to the next event handler. This is especially useful, if JavaScript controlled forms like the RichEdit form fields of Gmail don't work anymore. To exit this mode, press <Esc>. If you also need to pass <Esc> in this mode to the web page, prepend it with CTRL-V.

send-key <C-v> CTRL-V


CTRL-V

If you only need to pass a single key to a JavaScript form field or another extension prefix the key with <C-v>. Also works to unshadow Firefox shortcuts like <C-o> which are otherwise hidden in Vimperator. When Vimperator mode is temporarily disabled with <C-q>, <C-v> will pass the next key to Vimperator instead of the web page.


Opening web pages

opening 	

o :o :open 

:o[pen][!] [arg1], [arg2], 

o

Open one or more URLs in the current tab. Multiple URLs can be separated with 'urlseparator' (default: ", " Note that the space after the comma is required." ") Each token is analyzed and in this order:

Opened as a local file if it is an existing relative or absolute filename. 

:open /etc/fstab shows the file system table. 

:open ../other/foo.html in your home directory opens /home/other/foo.html 

Opened with the specified search engine if the token looks like a search string and the first word is the name of a search engine (:open wikipedia linus torvalds opens the Wikipedia entry for linus torvalds). The short name of a search engine is automatically guessed from its name. If you want to set a custom name, you can change it with :dialog searchengines. 

Opened with the default search engine or keyword (specified with the 'defsearch' option) if the first word is no search engine (:open linus torvalds opens a Google search for linux torvalds). 

Passed directly to Firefox in all other cases (:open www.osnews.com, www.slashdot.org opens OSNews in the current, and Slashdot in a new background tab). 

You can use :open -tags linux torvalds<Tab> to complete bookmarks with tag "linux" and which contain "torvalds". Note that -tags support is only available for tab completion, not for the actual command. The items which are completed on <Tab> are specified in the 'complete' option. Without argument, reloads the current page. Without argument but with [!], reloads the current page skipping the cache.

t :t :tabopen :tabnew :tabe :tabedit 

:tabopen[!] [arg1], [arg2], 

t Just like :open, but opens the resulting web page(s) in a new tab. When used with [!], the 'tabopen' value of the 'activate' option is negated.

Open one or more URLs in a new tab, based on current location. Works like t, but preselects current URL in the :tabopen query.

:tabd :tabduplicate 

:[count]tabd[uplicate][!]


Duplicates current tab [count] times. Uses 'tabopen' value of the 'activate' to determine if last cloned tab should be activated. When used with [!], 'tabopen' value is negated.

O Open one or more URLs in the current tab, based on current location. Works like o, but preselects current URL in the :open query.

:winopen :wopen :winedit 

:wino[pen][!] [arg1], [arg2], 


Just like :open, but opens the resulting web page(s) in a new window.

<MiddleMouse> p


p 
Open (put) a URL based on the current clipboard contents in the current buffer. You can also just select (for non-X11 users: copy) some non-URL text, and search for it with the default search engine or keyword (specified by the 'defsearch' option) with p.

P Open (put) a URL based on the current clipboard contents in a new buffer. Works like p, but opens a new tab.
Whether the new buffer is activated, depends on the 'activate' option.

gP Open (put) a URL based on the current clipboard contents in a new buffer. Works like P, but inverts the 'activate' option.

<C-x> 

[count]<C-x>

Decrements the last number in URL by 1, or by count if given.

<C-a> 

[count]<C-a>

Increments the last number in URL by 1, or by count if given.

~ Open home directory. You can also use the hints and have the probably fastest file browser on earth. :)


Navigating

navigating 	

H <C-o> CTRL-O :ba :back 

:[count]ba[ck][!] [url]

CTRL-o

Go [count] pages back in the browser history. The special version :back! goes to the beginning of the browser history.

L <C-i> CTRL-i :fo :fw :forward 

:[count]fo[rward][!] [url]

CTRL-i

Go [count] pages forward in the browser history. The special version :forward! goes to the end of the browser history.

:ju :jumps 

:ju[mps]

List all jumps aka current tab's history aka session history.

Current history position is marked with >, jump numbers are counters to be used with :back (above zero record) or :forward (below zero record).

gh Go home. Opens the homepage in the current tab.

gH Go home in a new tab. Opens the homepage in a new tab. Whether the new tab is activated or not depends on the 'activate' option.

gu 

[count]gu

Go to [count]th parent directory.


| 2gu on http://www.example.com/dir1/dir2/file.htm opens http://www.example.com/dir1/.

gU Go to the root of the web site.


gU on http://www.example.com/dir1/dir2/file.htm opens http://www.example.com/. When browsing a local directory, it goes to the root directory.

reloading 	

r Force reloading of the current page.

R Force reloading of the current page skipping the cache.

:re :reload


:re[load][!]

Reload current page. Forces reloading of the current page. If [!] is given, skip the cache.

:reloada :reloadall


:reloada[ll][!]

Reload all pages. Forces reloading of all pages. If [!] is given, skip the cache.

stopping 	

<C-c> Stop loading the current web page.

:st :stop 

:st[op] Stop loading. Stop loading current web page.


Writing

save-file writing 	

:w :write :sav :saveas


:sav[eas]

Save current web page to disk. Opens the original Firefox "Save page as" dialog. There, you can save the current web page to disk with various options. Use [!] to save the file with a default filename to the current working directory, skipping the "Save as" prompt


Quitting

save-session quitting 	

:q :quit


:q[uit]

Quit current tab. If this is the last tab in the window, close the window. If this was the last window, close Vimperator. When quitting Vimperator, the session is not stored.

:qa :qall :quita :quitall


:quita[ll]

Quit Vimperator. Quit Vimperator, no matter how many tabs/windows are open. The session is not stored.

:wc :wclose :winc :winclose 

:winc[lose]


Close window.

:xa :xall :wq :wqa :wqall 

:wqa[ll]

:xa[ll]

Save the session and quit. Quit Vimperator, no matter how many tabs/windows are open. The session is stored. :wq is different as in Vim, as it closes the window instead of just one tab by popular demand. Complain on the mailing list, if you want to change that.

ZQ 

ZQ

Quit and don't save the session. Works like :qall.

ZZ 

ZZ

Quit and save the session. Quit Vimperator, no matter how many tabs/windows are open. The session is stored. Works like :xall.


The current directory

current-directory 	

:chd :chdir :cd 

:cd [-|path]

Change the current directory. :cd - changes to the last directory.

:pw :pwd 

:pw[d]

Print the current directory name.

		55.1.4 	Buffers



Vimperator holds exactly one buffer object for each tab. It is usually an (X)HTML document with advanced features.


Buffer information

buffer-information 	

<C-g>


[count]<C-g> Print the current file name. Also shows some additional file information like file size or the last modified date. If {count} is given print the current file name with full path.

g<C-g> Print file information. Same as :pa[geinfo].

:pa :pageinfo 

:pa[geinfo] Show various page information. See :help 'pageinfo' for available options.

gf View source. Opens the source code of the current web site with the internal editor in the current tab.

gF View source with an external editor. Opens the source code of the current web site with the external editor specified by the 'editor' option. For now the external editor must be able to download and open files from a remote URL.

:vie :viewsource 

:vie[wsource][!] [url] View source code of current document. If [url] is specified then view the source of that document. When [!] is given, it is opened with the external editor.


Motion commands

scrolling motion 	

^ 0 
| 0 
Scroll to the absolute left of the document. Unlike in Vim, 0 and ^ work exactly the same way.

$ Scroll to the absolute right of the document

<Home> gg
[count]gg Goto the top of the document. When used with [count] like in 35gg, it scrolls to 35% of the document.

<End> G 
[count]G Goto the end of the document. When used with [count] like in 35G, it scrolls to 35% of the document.

<Left> h [count]h

Scroll document to the left. Count is supported: 10h will move 10 times as much to the left.
If the document cannot scroll more, a beep is emitted (unless 'visualbell' is set).

<C-e> <Down> j 
[count]j Scroll document down. Count is supported: 10j will move 10 times as much down.
If the document cannot scroll more, a beep is emitted (unless 'visualbell' is set).

<C-y> <Up> k 
[count]k Scroll document up. Count is supported: 10k will move 10 times as much up.
If the document cannot scroll more, a beep is emitted (unless 'visualbell' is set).

<C-d> 
[count]<C-d> Scroll window downwards in the buffer. The number of lines is set by the 'scroll' option which defaults to half a page. If [count] is given 'scroll' is first set to this value.

<C-u> 
[count]<C-u> Scroll window upwards in the buffer. The number of lines is set by the 'scroll' option which defaults to half a page. If [count] is given 'scroll' is first set to this value.

<Right> l 
[count]l Scroll document to the right. Count is supported: 10l will move 10 times as much to the right.
If the document cannot scroll more, a beep is emitted (unless 'visualbell' is set).

<S-Space> <PageUp> <C-b> 
[count]<C-b> Scroll up a full page. Scroll window [count] pages Backwards (upwards) in the buffer.

<Space> <PageDown> <C-f> 
[count]<C-f> Scroll down a full page. Scroll window [count] pages Forwards (downwards) in the buffer.


Jumping to elements

jumping 	

<Tab> Advance keyboard focus to the next element.

<S-Tab> Rewind keyboard focus to the previous element.

gi 
[count]gi Focus last used input field. If there is no last input field, it focuses the first input field. When used with [count] it directly jumps to the [count]th input field.

]f 
[count]]f Focus next frame. Transfer keyboard focus to the [count]th next frame in order. The newly focused frame is briefly colored red. Does not wrap.

[f 
[count][f Focus previous frame. Transfer keyboard focus to the [count]th previous frame in order. The newly focused frame is briefly colored red. Does not wrap.

]] 
[count]]] Open link labeled with "next" or ">". Useful when browsing forums or documentation. Change 'nextpattern' to modify its behavior. It follows relations between files too.

[[ 
[count][[ Open link labeled with "prev", "previous" or "<". Useful when browsing forums or documentation. Change 'previouspattern' to modify its behavior. It follows relations between files too.


Zooming

zooming 	

+ zi [count]
zi Enlarge text zoom of current web page. Mnemonic: zoom in

zm 
[count]zm Enlarge text zoom of current web page by a larger amount. Mnemonic: zoom more

- zo 
[count]zo Reduce text zoom of current web page. Mnemonic: zoom out

zr 
[count]zr Reduce text zoom of current web page by a larger amount. Mnemonic: zoom reduce

zz 
[count]zz Set text zoom value of current web page. Zoom value can be between 1 and 2000%. If it is omitted, text zoom is reset to 100%.

zI 
[count]zI Enlarge full zoom of current web page. Mnemonic: zoom in

zM 
[count]zM Enlarge full zoom of current web page by a larger amount. Mnemonic: zoom more

zO 
[count]zO Reduce full zoom of current web page. Mnemonic: zoom out

zR 
[count]zR Reduce full zoom of current web page by a larger amount. Mnemonic: zoom reduce

zZ 
[count]zZ Set full zoom value of current web page. Zoom value can be between 1 and 2000%. If it is omitted, full zoom is reset to 100%.

:zo :zoom 
:zo[om][!] [value] 
:zo[om][!] +{value} | -{value} Set zoom value of current web page. If [value] can be an absolute value between 1 and 2000% or a relative value if prefixed with "-" or "+". If [value] is omitted, zoom is reset to 100%.

Normally this command operates on the text zoom, if used with [!] it operates on full zoom.


Copying text

yanking copying 	

When running in X11 the text of the following commands is not only copied to the clipboard, but also put into the X11 selection, which can be pasted with the middle mouse button:

y Yank current location to the clipboard. When running in X11 the location is also put into the selection, which can be pasted with the middle mouse button.

Y Copy currently selected text to the system clipboard.


Alternate style sheets

style stylesheet 	

Page authors may specify alternate style sheets for an HTML document. Users can then switch between these various style sheets, selecting their favorite.

:pagest :pagestyle 

:pagest[yle] [stylesheet] Select the author style sheet to apply. If [stylesheet] is not specified the page's default style sheet is used.

All author styling can be removed by setting the 'usermode' option.

		55.1.5 Search commands


		55.1.6 		options


Vimperator has a number of internal variables and switches which can be set to achieve special effects. These options come in 5 forms:

boolean 	can only be on or off 	
number 	has a numeric value 	
string 	has a string value 	
charlist 	like a string but with unique characters 	
stringlist 	a comma-separated list of strings 	


Setting options

E764 set-option 	

:set :se 

:se[t]
Show all options that differ from their default value. 

:se[t] all
Show all options. 

:se[t] {option}?
Show value of {option}. 

:se[t] {option}
Toggle option: set, switch it on. 

Number option: show value.
String option: show value.

:set-default 

:se[t] {option}&
Reset option to its default value. 

:se[t] all&
Set all options to their default value. 

:set-args E487 E521 

:se[t] {option}={value}


Set string or number option to {value}.
For numeric options the value must be given in decimal. The old value can be inserted by typing <Tab>.

:set+= 

:se[t] {option}+={value}


Add the {value} to a number option, or append the {value} to a string option. When the option is a comma separated list, a comma is added, unless the value was empty. If the option is a list of flags, superfluous flags are removed. When adding a flag that was already present the option value doesn't change.

:set^= 

:se[t] {option}^={value}


Multiply the {value} to a number option, or prepend the {value} to a string option. When the option is a comma separated list, a comma is added, unless the value was empty.

:set-= 

:se[t] {option}-={value}


Subtract the {value} from a number option, or remove the {value} from a string option, if it is there. If the {value} is not found in a string option, there is no error or warning. When the option is a comma separated list, a comma is deleted, unless the option becomes empty. When the option is a list of flags, {value} must be exactly as they appear in the option. Remove flags one by one to avoid problems.

:setlocal :setl 

:setl[ocal]

:setl[ocal] all

:setl[ocal] {option}?

:setl[ocal] {option}

:setl[ocal] {option}&

:setl[ocal] all&

:setl[ocal] {option}={value}

:setl[ocal] {option}+={value}

:setl[ocal] {option}^={value}

:setl[ocal] {option}-={value}


The same as :set command, but operates on local for current tab options only. See :set for details.

:setglobal :setg 

:setg[lobal]

:setg[lobal] all

:setg[lobal] {option}?

:setg[lobal] {option}

:setg[lobal] {option}&

:setg[lobal] all&

:setg[lobal] {option}={value}

:setg[lobal] {option}+={value}

:setg[lobal] {option}^={value}

:setg[lobal] {option}-={value}


The same as :set command, but operates on global options only. See :set for details.


Setting Firefox options

firefox-options 	

Most Firefox options are not touched/overridden by Vimperator. In order to set any of these preferences use either of the following:

:prefs :preferences 

:pref[erences]

Show Browser Preferences
You can change the browser preferences from this dialog. Be aware that not all Firefox preferences work, because Vimperator overrides some key bindings and changes Firefox's GUI.

:prefs! :preferences! 

:pref[erences]!

Opens about:config in the current tab where you can change advanced Firefox preferences.

:set-! 

:se[t]! {preference}={value}


Change any Firefox {preference} (those in the about:config window). You can also reset/delete those preferences with :set! {preference}&.


List of options

list-options 	

'act' 'activate' 

'activate' 'act'
stringlist (default: "homepage,quickmark,tabopen,paste") 

Define when tabs are automatically activated. Available items:

homepage 	gH mapping 	
quickmark 	go and gn mappings 	
tabopen 	:tabopen[!] command 	
paste 	P and gP mappings 	

'albc' 'activelinkbgcolor' 

'activelinkbgcolor' 'albc'
string (default: ##88FF00) 

Background color of the current active link during hint mode.

'alfc' 'activelinkfgcolor' 

'activelinkfgcolor' 'alfc'
string (default: black) 

Foreground color of the current active link during hint mode.

'cpt' 'complete' 

'complete' 'cpt'
charlist (default: sfbh) 

Items which are completed at the :[tab]open prompt. Available items:

s 	Search engines and keyword URLs 	
f 	Local files 	
b 	Bookmarks 	
h 	History 	
l 	Firefox location bar entries (bookmarks and history sorted in an intelligent way) 	
S 	Suggest engines 	

The order is important, so :set complete=bs would list bookmarks first, and then any available quick searches. Add "sort" to the 'wildoptions' option if you want all entries sorted. If 'wildoptions' contains "auto", "b" and "h" are not available for performance reasons but you can use "l" to achieve a similar effect. On the other hand "l" does not yet work, when 'wildoptions' does NOT contain "auto".

'ds' 'defsearch' 

'defsearch' 'ds'
string (default: "google") 

Sets the default search engine. The default search engine name is used in the :[tab]open [arg] command if [arg] neither looks like a URL or like a specified search engine/keyword.

This means, it you set 'defsearch' to "youtube", then :open arnold schwarzenegger will be exactly the same as :open youtube arnold schwarzenegger. Therefore, you need to add a keyword or search engine "youtube" first.

'editor' 

'editor'
string (default: "gvim -f") 

Set the external text editor. Sets the editor to run when <C-i> is pressed in INSERT and TEXTAREA modes.
Warning: Vimperator will not behave correctly if the editor forks its own process, such as with gvim without the -f argument.

'eht' 'extendedhinttags' 

'extendedhinttags' 'eht'
string 

(default: //*[@onclick or @onmouseover or @onmousedown or @onmouseup or @oncommand or @class='lk' or @class='s'] | //input[not(@type='hidden')] | //a | //area | //iframe | //textarea | //button | //select | //xhtml:*[@onclick or @onmouseover or @onmousedown or @onmouseup or @oncommand or @class='lk' or @class='s'] | //xhtml:input[not(@type='hidden')] | //xhtml:a | //xhtml:area | //xhtml:iframe | //xhtml:textarea | //xhtml:button | //xhtml:select)

The XPath string of hintable elements activated by ;.

'nofc' 'nofocuscontent' 'fc' 'focuscontent' 

'focuscontent' 'fc'
boolean (default: off) 

Focus the content after a page has loaded. This is useful, if you always want to stay in normal mode when browsing between web sites. When "on", it blurs any textbox which often is automatically focused on page load. If you usually like 'focuscontent' but sometimes you'd like to focus the first input field, you can use gi to jump to it.

'nofs' 'nofullscreen' 'fs' 'fullscreen' 

'fullscreen' 'fs'
boolean (default: off) 

Show the current window fullscreen. Also hide certain GUI elements like the statusline.

'go' 'guioptions' 

'guioptions' 'go'
charlist (default: "") 

Show or hide certain GUI elements like the menu or toolbar. Supported characters:

m 	Menubar 	
T 	Toolbar 	
b 	Bookmark bar 	

You can also hide the tab bar with :set showtabline=0.

'hm' 'hintmatching' 

'hintmatching' 'hm'
string (default: contains) 

Change the hint matching algorithm during hint mode. Possible values:

contains 	The typed characters are split on whitespace, and these character groups have to match anywhere inside the text of the link. 	
wordstartswith 	The typed characters are matched with the beginning of the first word (see 'wordseparators') in the link as long as possible. If no matches occur in the current word, then the matching is continued at the beginning of the next word. The words are worked through in the order they appear in the link. If the typed characters contain spaces, then the characters are split on whitespace. These character groups are then matched with the beginning of the words, beginning at the first one and continuing with the following words in the order they appear in the link. 	
firstletters 	Behaves like wordstartswith, but non matching words aren't overleaped. 	
custom 	Delegate to a custom function: liberator.plugins.customHintMatcher(hintString) 	

'hs' 'hintstyle' 

'hintstyle' 'hs'
string 

(default: z-index:5000; font-family:monospace; font-size:12px; color:white; background-color:red; border-color:ButtonShadow; border-width:0px; border-style:solid; padding:0px 1px 0px 1px; position:absolute;)

CSS specification of hints

'ht' 'hinttags' 

'hinttags' 'ht'
string 

(default: //*[@onclick or @onmouseover or @onmousedown or @onmouseup or @oncommand or @class='lk' or @class='s'] | //input[not(@type='hidden')] | //a | //area | //iframe | //textarea | //button | //select | //xhtml:*[@onclick or @onmouseover or @onmousedown or @onmouseup or @oncommand or @class='lk' or @class='s'] | //xhtml:input[not(@type='hidden')] | //xhtml:a | //xhtml:area | //xhtml:iframe | //xhtml:textarea | //xhtml:button | //xhtml:select)

XPath string of hintable elements activated by f and F

'hto' 'hinttimeout' 

'hinttimeout' 'hto'
number (default: 0) 

Automatically follow non unique numerical hint after 'hinttimeout' milliseconds.
Set to 0 (the default) to only follow numeric hints after pressing <Return> or when the hint is unique.

'hi' 'history' 

'history' 'hi'
number (default: 500) 

Number of Ex commands and search patterns to store in the commandline history.

'nohls' 'nohlsearch' 'hls' 'hlsearch' 

'hlsearch' 'hls'
boolean (default: off) 

Highlight previous search pattern matches

'hlss' 'hlsearchstyle' 

'hlsearchstyle' 'hlss'

string (default: color: black; background-color: yellow; padding: 0; display: inline;)


CSS specification of highlighted search items

'noic' 'noignorecase' 'ic' 'ignorecase' 

'ignorecase' 'ic'
boolean (default: on) 

Ignore case in search patterns.

'nois' 'noincsearch' 'is' 'incsearch' 

'incsearch' 'is'
boolean (default: on) 

Show where the search pattern matches as it is typed.
Note: Incremental searching currently only works in the forward direction.

'noim' 'noinsertmode' 'im' 'insertmode' 

'insertmode' 'im'
boolean (default: on) 

Use Insert mode as the default for text areas. Makes Vimperator work in a way that Insert mode is the default mode for text areas. Useful if you want to use Vimperator as a modeless editor, keeping the known Firefox interface for editing text areas.

'ls' 'laststatus' 

'laststatus' 'ls'
number (default: 2) 

Determines when the last window will have a status line. Possible values:

|0 	Never 	
|1 	Only if there are multiple windows 	
|2 	Always 	

Note: laststatus=1 not implemented yet.

'lbc' 'linkbgcolor' 

'linkbgcolor' 'lbc'
string (default: yellow) 

Background color of a link during hint mode.

'lfc' 'linkfgcolor' 

'linkfgcolor' 'lfc'
string (default: black) 

Foreground color of a link during hint mode.

'nolks' 'nolinksearch' 'lks' 'linksearch' 

'linksearch' 'lks'
boolean (default: off) 

Limit the search to hyperlink text. This includes (X)HTML elements with an "href" atrribute and XLink "simple" links.

'nomore' 'more' 

'more'
boolean (default: on) 

Pause the message list window when more than one screen of listings is displayed

'nextpattern' 

'nextpattern'
stringlist (default: \bnext,^>$,^(>>|Â»)$,^(>|Â»),(>|Â»)$,\bmore\b) 

Patterns to use when guessing the 'next' page in a document sequence. Each pattern, in order, is matched against all links in the page with the first match being used. The patterns are case insensitive regular expressions.

'newtab' 

'newtab'
stringlist (default: "") 

Define which Ex commands output the result in a new tab automatically. You can also use :tab command to manually output a command in a new tab.

The possible values:

all 	All commands 	
addons 	:addo[ns] command 	
downloads 	:downl[oads] command 	
help 	:h[elp] command 	
javascript 	:javascript! or :js! command 	
prefs 	:pref[erences]! or :prefs! command 	

'noonline' 'online' 

'online'
boolean (default on) 

Show and set the 'work offline' behavior.

'pageinfo' 'pa' 

'pageinfo' 'pa'
charlist (default: gfm) 

Desired info on :pa[geinfo]. Available items:

g 	General info 	
f 	Feeds 	
m 	Meta tags 	

The order matters.

'pps' 'popups' 

'popups' 'pps'
number (default: 1) 

Define where to show requested popup windows. Does not apply to windows which are opened by middle clicking a link, they always open in a new tab. Possible values:

|0 	Force to open in the current tab (Warning: this can stop some web sites from working correctly!) 	
|1 	Always open in a new tab 	
|2 	Open in a new window if it has a specific requested size (default in Firefox) 	
|3 	Always open in a new window 	
|4 	Open in the same tab unless it has a specific requested size 	

Note: This option does not change the popup blocker of Firefox in any way.

'nopreload' 'preload' 

'preload' 'nopreload'
boolean (default: on) 

Speed up first time history/bookmark completion

History access can be quite slow for a large history. Vimperator maintains a cache to speed it up significantly on subsequent access. In order to also speed up first time access, it is cached at startup, if this option is set (recommended).

'previouspattern' 

'previouspattern'
stringlist  

Patterns to use when guessing the 'previous' page in a document sequence Each pattern, in order, is matched against all links in the page with the first match being used. The patterns are case insensitive regular expressions.


'scr' 'scroll' 

'scroll' 'scr'
number (default: 0) 

Number of lines to scroll with C-u and C-d commands. The number of lines scrolled defaults to half the window size. When a {count} is specified to the <C-u> or <C-d> commands this is used to set the value of 'scroll' and also used for the current command. The value can be reset to half the window height with :set scroll=0.

'shell' 'sh' 

'shell' 'sh'
string (default: on) 

Show the current mode in the command line.

'shellcmdflag' 'shcf' 

'shellcmdflag' 'shcf'
string (default: $SHELL or "sh", Win32: "cmd.exe") 

Shell to use for executing :! and :run commands.

'nosmd' 'noshowmode' 'smd' 'showmode' 

'showmode' 'smd'
boolean (default: "-c", Win32: "/c") 

Flag passed to shell when executing :! and :run commands.

E.g. bash -c gvim

'ssli' 'showstatuslinks' 

'showstatuslinks' 'ssli'
number (default: 1) 

Show the destination of the link under the cursor in the status bar Also links which are focused by keyboard commands like <Tab> are shown. Possible values:

|0 	Don't show link destination 	
|1 	Show the link in the status line 	
|2 	Show the link in the command line 	

'stal' 'showtabline' 

'showtabline' 'stal'
number (default: 2) 

Control when to show the tab bar of opened web pages. Possible values:

|0 	Never show tab bar 	
|1 	Show tab bar only if more than one tab is open 	
|2 	Always show tab bar 	

'noscs' 'nosmartcase' 'scs' 'smartcase' 

'smartcase' 'scs'
boolean (default: on) 

Override the 'ignorecase' option if the pattern contains uppercase characters. This is only used if the 'ignorecase' option is set.

'suggestengines' 

'suggestengines' 
stringlist (default: "google") 

Set the search engines which can be used for completion suggestions. Add "S" to the 'complete' option if you want use this feature.

Warning: This feature could make tab-completion slower because it needs to wait for changes, so use it only if you have a fast internet connection.

'titlestring' 

'titlestring'
string (default: "Vimperator") 

Change the title of the browser window. Vimperator changes the browser title from "Title of web page - Mozilla Firefox" to "Title of web page - Vimperator".
If you don't like that, you can restore it with: :set titlestring=Mozilla Firefox.

'noum' 'nousermode' 'um' 'usermode' 

'usermode' 'um'
boolean (default: off) 

Show current website with a minimal style sheet to make it easily accessible. Note that this is a local option for now, later it may be split into a global and :setlocal part

'urlseparator' 

'urlseparator'
string (default: ",\s") 

Set the separator regexp used to separate multiple URL args. Multiple arguments can be specified for :open, and similar commands, using this regexp as the separator. Using whitespace alone is not generally useful since it is often contained in a single argument. E.g. :open linus torvalds should perform a single search for the key words "linus" and "torvalds"

'verbose', 'vbs' 

'verbose' 'vbs'
number (default: 0) 

Define which type of messages are logged. When bigger than zero, Vimperator will give messages about what it is doing. They are printed to the error console which can be shown with :javascript!. The highest value is 9, being the most verbose mode.

'novb' 'novisualbell' 'vb' 'visualbell' 

'visualbell' 'vb'
boolean (default: off) 

Use visual bell instead of beeping on errors. For now you can't turn off both, this will hopefully change.

'visualbellstyle' 't_vb' 

'visualbellstyle' 't_vb'
string (default: "border: none; background-color: black;") 

The CSS style to use for the visual bell. Set this to the empty string if you want no bell at all.

'wim' 'wildmode' 

'wildmode' 'wim'
stringlist (default: "list:full") 

Define how command line completion works. It is a comma-separated list of parts, where each part specifies what to do for each consecutive use of the completion key. The first part specifies the behavior for the first use of the completion key, the second part for the second use, etc.

These are the possible values for each part:

"" 	Complete only the first match 	
"full" 	Complete the next full match. After the last, the original string is used. 	
"longest" 	Complete till the longest common string. 	
"list" 	When more than one match, list all matches. 	
"list:full" 	When more than one match, list all matches and complete first match. 	
"list:longest" 	When more than one match, list all matches and complete till the longest common string. When there is only a single match, it is fully completed regardless of the case. 	

'wop' 'wildoptions' 

'wildoptions' 'wop'
stringlist (default: "") 

A list of words that change how command line completion is done.

Possible words:

auto 	Automatically show completions while you are typing 	
sort 	Always sorts completion list, overriding the 'complete' option. 	

'wsp' 'wordseparators' 

'wordseparators' 'wsp'
string (default: [\.,!\?:;/\\"\^\$%&§\(\)\[\]{}<>#\*\+\|=~ _\\-]) 

A regex which defines the word separators which are used for the 'hintmatching' types 'wordstartswith' and 'firstletters' to split the words in the text of a link.

"

		55.1.7 		tabs


Tabs are used to be able to view many web pages at the same time. Each tab contains exactly one buffer - multiple buffers per tab are not supported. As a result many buffer and tab commands are interchangeable.


Listing tabs

listing-tabs 	

B :tabs :ls :files :buffers 

:buffers[!]

B

Show a list of all buffers (=tabs). The special version :buffers! opens the buffer list in a persistent preview window. Call the special version of this command again to close the window.


Opening tabs

listing-tabs 	

:tab


:tab {cmd}

Execute {cmd} and tell it to output in a new tab. Works only for commands that support it, currently:

:tab help 

:tab prefs[!] 

:tab addons 

:tab downloads 

See :open for other ways to open new tabs.


Changing tabs

changing-tabs 	

gb


[count]gb

Repeat last :buffer[!] command. This is useful to quickly jump between buffers which have a similar URL or title.

gB


[count]gB

Repeat last :buffer[!] command in reverse direction. Just like gb but in the other direction.

<C-PageDown> <C-Tab> <C-n> gt


[count]gt

Go to the next tab. Cycles to the first tab, when the last is selected.
Count is supported: 3gt goes to the third tab.

<C-PageUp> <C-S-Tab> <C-p> gT


[count]gT

Go {count} pages back. Wraps around from the first tab to the last tab.
Count is supported: 3gT goes three tabs back.

<C-6> <C-^>


<C-^>

Select the alternate tab. The alternate tab is the last selected tab. This provides a quick method of toggling between two tabs.

b :b :buffer 

[count]:b[uffer][!] {url|index}

b

Go to the specified buffer from the buffer list. Argument can be either the buffer index or the full URL.

If argument is neither a full URL nor an index but uniquely identifies a buffer, it is selected. With [!] the next buffer matching the argument is selected, even if it cannot be identified uniquely. Use b as a shortcut to open this prompt.

If argument is #, the alternate buffer will be selected (see <C-6>).

g^ g0 :bf :bfirst :br :brewind :tabfir :tabfirst :tabr :tabrewind 

:tabr[ewind]

:tabfir[st]

:br[ewind]

:bf[irst]

g0

g^

Switch to the first tab.

g$ :bl :blast :tabl :tablast 

:tabl[ast]

:bl[ast]

g$

Switch to the last tab.

:tabm :tabmove 

:tabm[ove] [N]

:tabm[ove][!] +N | -N


Move the current tab after tab N. When N is 0 the current tab is made the first one. Without N the current tab is made the last one. N can also be prefixed with "+" or "-" to indicate a relative movement. If [!] is specified the movement wraps around the start or end of the tab list.

:bn :bnext :tn :tnext :tabn :tabnext 

:[count]tabn[ext] [count]

:[count]tn[ext] [count]

:[count]bn[ext] [count]


Switch to the next or [count]th tab. Cycles to the first tab when the last is selected and {count} is not specified.

:tabo :tabonly 

:tabo[nly]

Close all other tabs.

:bN :bNext :bp :bprevious :tN :tNext :tabN :tabNext :tp :tprevious :tabp :tabprevious


:[count]tabp[revious] [count]

:[count]tp[revious] [count]

:[count]tabN[ext] [count]

:[count]bp[revious] [count]

:[count]bN[ext] [count]


Switch to the previous tab or go [count] tabs back. Wraps around from the first tab to the last tab.


Closing tabs

closing-tabs 	

d :tabc :tabclose :bun :bunload :bw :bwipeout :bd :bdelete 

:[count]bd[elete][!] [arg]

[count]d

Delete current buffer (=tab). Count is supported, :2bd removes two tabs and the one to the right is selected. Afterwards, the tab to the right of the deleted one is selected.

When used with [arg], remove all tabs which contain [arg] in the hostname. [!] forces this command to also search for [arg] in the full URL and also the title of the tab. Use with care.

D 

[count]D

Like d but selects the tab to the left of the deleted tab.

u :u :undo 

:[count]u[ndo][!] [url]

[count]u

Undo closing of a tab. If a count is given, don't close the last but the [count]th last tab. With [url] restores the tab matching the URL.

:undoa :undoall


:undoa[ll]

Undo closing of all closed tabs. Firefox stores up to 10 closed tabs, even after a browser restart.

		55.1.8 Navigation, hints



f hints


f{hint}

Start QuickHint mode. In QuickHint mode, every hintable item (according to the 'hinttags' XPath query) is assigned a unique number. You can now either type this number or type any part of the URL which you want to follow, and it is followed as soon as it can be uniquely identified. Often it is can be useful to combine these techniques to narrow down results with some letters, and then typing a single digit to make the match unique. Pressing <Leader> (defaults to :let mapleader = "\") toggles "escape-mode", where numbers are treated as normal text.
<Esc> stops this mode at any time.

F


F{hint}

Start QuickHint mode, but open link in a new tab. Like normal QuickHint mode (activated with f) but opens the link in a new tab.

;


;{mode}{hint}

Start an extended hint mode. ExtendedHint mode is useful, since in this mode you can yank link locations, open them in a new window or save images. If you want to yank the location of hint 24, press ;y to start this hint mode. Then press 24 to copy the hint location.

{mode} can be either one of:


; to focus a link and hover it with the mouse 

a to save its destination (prompting for save location) 

s to save its destination 

o to open its location in the current tab 

t to open its location in a new tab 

O to open its location in an :open query 

T to open its location in a :tabopen query 

v to view its destination source 

w to open its destination in a new window 

W to open its location in a :winopen query 

y to yank its destination location 

Y to yank its text description 

f to open its location in the current tab 

F to open its location in a new tab 

These work like the f or F mappings but will keep you in AlwaysHint mode. This is useful if you want to open many links of one page without pressing f or F each time. Hintable elements for all extended hint modes can be set in the 'extendedhinttags' XPath string.


		55.1.9 Key mapping

macro mapping key-mapping 	

<Nop>


<Nop>

Do nothing. This command is useful for disabling a specific mapping. :map <C-n> <Nop> will prevent <C-n> from doing anything.

:map 

:map {lhs} {rhs}

:map {lhs}

:map

Map the key sequence {lhs} to {rhs}. The {rhs} is remapped, allowing for nested and recursive mappings. Mappings are NOT saved during sessions, make sure you put them in your vimperatorrc file!

:cm :cmap 

:cmap {lhs} {rhs}

:cmap {lhs}

:cmap

Map the key sequence {lhs} to {rhs} (in command-line mode). The {rhs} is remapped, allowing for nested and recursive mappings. Mappings are NOT saved during sessions, make sure you put them in your vimperatorrc file!

:im :imap 

:imap {lhs} {rhs}

:imap {lhs}

:imap

Map the key sequence {lhs} to {rhs} (in insert mode). The {rhs} is remapped, allowing for nested and recursive mappings. Mappings are NOT saved during sessions, make sure you put them in your vimperatorrc file!

:mapc :mapclear


:mapc[lear]

Remove all mappings. All user-defined mappings which were set by :map or :noremap are cleared.

:cmapc :cmapclear


:cmapc[lear]

Remove all mappings (in command-line mode). All user-defined mappings which were set by :cmap or :cnoremap are cleared.

:imapc :imapclear


:imapc[lear]

Remove all mappings (in insert mode). All user-defined mappings which were set by :imap or :inoremap are cleared.

:no :noremap


:no[remap] {lhs} {rhs}

:no[remap] {lhs}

:no[remap]

Map the key sequence {lhs} to {rhs}. No remapping of the {rhs} is performed.

:cno :cnoremap


:cno[remap] {lhs} {rhs}

:cno[remap] {lhs}

:cno[remap]

Map the key sequence {lhs} to {rhs} (in command-line mode). No remapping of the {rhs} is performed.

:ino :inoremap


:ino[remap] {lhs} {rhs}

:ino[remap] {lhs}

:ino[remap]

Map the key sequence {lhs} to {rhs} (in insert mode). No remapping of the {rhs} is performed.

:unm :unmap 

:unm[ap] {lhs}

Remove the mapping of {lhs}.

:cunm :cunmap 

:cunm[ap] {lhs}

Remove the mapping of {lhs} (in command-line mode).

:iunm :iunmap 

:iunm[ap] {lhs}

Remove the mapping of {lhs} (in insert mode).


Abbreviations

abbreviations 	

list abbreviations:
:ab :abbreviate 

mine: 
i  }-            }<Esc>h%?\w<CR>:nohl<CR>:call JCommentWriter()<CR>
c  w1          * ((getcmdtype() == ':'  &&  getcmdpos()  <= 2)?   'w!' : 'w1')
i  xdate         <C-R>=strftime("%d/%m/%y %H:%M:%S")<CR><Space>
i  xasp          <%@language=jscript%><CR><%<CR><Tab><CR><BS>%><Esc><<O<Tab>    

i - insert mode
c - : mode 

:ab[breviate] {lhs} {rhs}

:ab[breviate] {lhs}

:ab[breviate]

Abbreviate a key sequence. Abbreviate {lhs} to {rhs}. If only {lhs} given, list that particular abbreviation. List all abbreviations, if no arguments to are given.

:ca :cabbrev 

:ca[bbrev] {lhs} {rhs}

:ca[bbrev] {lhs}

:ca[bbrev]

Abbreviate a key sequence for Command-line mode. Same as :ab[reviate], but for command-line mode only.

:ia :iabbrev 

:ia[bbrev] {lhs} {rhs}

:ia[bbrev] {lhs}

:ia[bbrev]

Abbreviate a key sequence for Insert mode. Same as :ab[breviate], but for Insert mode only.

:una :unabbreviate 

:una[bbreviate] {lhs}


Remove an abbreviation.

:cuna :cunabbrev 

:cuna[bbrev] {lhs}


Remove an abbreviation for Command-line mode. Same as :una[bbreviate], but for Command-line mode only.

:iuna :iunabbrev 

:iuna[bbrev] {lhs}


Remove an abbreviation for Insert mode. Same as :una[bbreviate], but for Insert mode only.

:abc :abclear 

:abc[lear]

Remove all abbreviations.

:cabc :cabclear 

:cabc[lear]

Remove all abbreviations for Command-line mode.

:iabc :iabclear 

:iabc[lear]

Remove all abbreviations for Insert mode.


User-defined commands

user-commands 	

:com :command 

:com[mand]


List all user-defined commands.

:com[mand] {cmd}


List all user-defined commands that start with {cmd}.

:com[mand][!] [{attr}] {cmd} {rep}


Define a new user command. The name of the command is {cmd} and its relacement text is {rep}. The command's attributes are {attr}. If a command with this name already exists an error is reported unless [!] is specified, in which case the command is redefined. Unlike Vim, the command may start with a lowercase letter.

The replacement text {rep} is scanned for escape sequences and these are replaced with values from the user entered command line. The resulting string is then executed as an Ex command.

The valid escape sequences are:

<args> 	The command arguments exactly as supplied 	
<lt> 	A literal '<' character to allow for a literal copy of one of the escape sequences. Eg. <lt>args> will expand to a literal <args> 	

Note: {attr} not implemented yet.

:comc :comclear 

:comc[lear]

Delete all user-defined commands.

:delc :delcommand 

:delc[ommand] {cmd}


Delete the user-defined command {cmd}.


		55.1.10 eval


INTRO TO BE WRITTEN

:ec :echo


:ec[ho] {expr}

Display a string at the bottom of the window. Useful for showing informational messages. Multiple lines can be separated by \n. {expr} can either be a quoted string, or any expression which can be fed to eval() like 4+5. You can also view the source code of objects and functions if the return value of {expr} is an object or function.

:echoe :echoerr 

:echoe[rr] {expr}


Display an error string at the bottom of the window. Just like :ec[ho], but echoes the result highlighted in red. Useful for showing important messages.

:exe :execute 

:exe[cute] {expr1} [  ]


Execute the string that results from the evaluation of {expr1} as an Ex command. Example: :execute echo "test" shows a message with the text "test".

:js :javas :javascript 

:javas[cript] {cmd}

:javascript <<{endpattern}\n{script}\n{endpattern}

:javascript[!]

Run any JavaScript command through eval(). Acts as a JavaScript interpreter by passing the argument to eval(). :javascript alert('Hello world') shows a dialog box with the text "Hello world". :javascript <<EOF reads all the lines until a line starting with 'EOF' is found, and interpret them with the JavaScript eval() function.

The special version :javascript! opens the JavaScript console of Firefox.

Rudimentary <Tab> completion is available for :javascript {cmd}<Tab> (but not yet for the :js <<EOF multiline widget). Be aware that Vimperator needs to run {cmd} through eval() to get the completions, which could have unwanted side effects.

:let 

:let {var-name} [+-.]= {expr1}

:let {var-name}

:let

Sets or lists a variable. Sets the variable {var-name} to the value of the expression {expr1}. If no expression is given, the value of the variable is displayed.Without arguments, displays a list of all variables.

:unl :unlet 

:unl[et][!] {name} 


Deletes the variable {name}. Several variable names can be given. When used with [!] no error message is output for non-existing variables.


		55.1.11 marks

Bookmarks which allow you to mark a web page as one of your favorites for easy access. 

QuickMarks allow you to define up to 62 (a-zA-Z0-9) web sites (or group of web sites) which you really visit most often 

Local marks to store the position with a web page 

History is also a special type of marks, as Vimperator automatically remembers sites which you have visited in the past. 


a :bma :bmark 

:bm[ark] [-title=title] [-keyword=kw] [-tags=tag1,tag2] [url]

a

Add a bookmark.


The following options are interpreted:

-title="custom title" (short option: -t) 

-tags=comma,separated,tag,list (short option: -T) 

-keyword=keyword (short option: -k) 

If you don't add a custom title, either the title of the web page or the URL is taken as the title. You can omit the optional [url] argument, so just do :bmark to bookmark the currently loaded web page with a default title and without any tags.

A

Toggle bookmarked state of current URL. Add/remove a bookmark for the current location, depending if it already is bookmarked or not. In contrast to the :bmark command, the bookmark is just starred which means it is placed in the Unfiled Bookmarks Folder instead of the bookmarks menu.

:bma :bmark 

:bma[rk] [-title=title] [-keyword=kw] [-tags=tag1,tag2] [url]


Add a bookmark. If you don't add a custom title, either the title of the web page or the URL is taken as the title.
You can omit the optional [url] argument, so just do :bmark to bookmark the currently loaded web page with a default title and without any tags.


The following options are interpreted:
-title="custom title"
-tags=comma,separated,tag,list
-keyword=keyword


:bmarks 

:bmarks[!] [filter]


List or open multiple bookmarks. Open the message window at the bottom of the screen with all bookmarks which match [filter] either in the title or URL.
The special version :bmarks! works the same as :bmarks except it opens all the found bookmarks in new tabs.

Filter can also contain the following options:
-tags=comma,separated,tag,list


:delbm :delbmarks 

:delbm[arks] [url]


Delete a bookmark. Deletes all bookmarks which match the [url]. If omitted, [url] defaults to the URL of the current buffer. Use <Tab> key on a string to complete the URL which you want to delete.

The following options WILL be interpreted in the future:

[!] a special version to delete ALL bookmarks 


history 	

<C-o>


[count]<C-o>

Go to an older position in the jump list. The jump list is just the browser history for now.

<C-i>


[count]<C-i>

Go to a newer position in the jump list. The jump list is just the browser history for now.

<M-Left> <A-Left> H

[count]H

Go back in the browser history. Count is supported: 3H goes back 3 steps.

<M-Right> <A-Right> L
[count]L

Go forward in the browser history. Count is supported: 3L goes forward 3 steps.

:ba :back 

:[count]ba[ck][!] [url]


Go back in the browser history. Count is supported, :3back goes back 3 pages in the browser history.
The special version :back! goes to the beginning of the browser history.

:fw :fo :forward 

:[count]fo[rward][!] [url]


Go forward in the browser history. Count is supported, :3forward goes forward 3 pages in the browser history. The special version :forward! goes to the end of the browser history.

:hs :hist :history 

:hist[ory][!] [filter]


Show recently visited URLs. Open the message window at the bottom of the screen with all history items which match [filter] either in the title or URL. The special version :history! works the same as :history except it opens all the found items in new tabs.


QuickMarks
go


go{a-zA-Z0-9}

Jump to a QuickMark in the current tab. Open any QuickMark in the current tab. across browser sessions.

gn


gn{a-zA-Z0-9}

QuickMark in a new tab. Whether the new tab is activated or not depends on the 'activate' option.
Mnemonic: Go in a new tab. gt would make more sense but is already taken.

M


M{a-zA-Z0-9}

Add new QuickMark for current URL. You can go to a marked URL in the current QuickMarks are persistent across browser sessions.

:delqm :delqmarks 

:delqm[arks] {marks}

:delqm[arks]!

Delete the specified QuickMarks. QuickMarks are presented as a list.

Examples:

:delqmarks Aa b p deletes QuickMarks A, a, b and p


:delqmarks b-p deletes all QuickMarks in the range b to p


:delqmarks! deletes all QuickMarks 

:qma :qmark 

:qma[rk] {a-zA-Z0-9} [url]


Mark a URL with a letter for quick access. You can also mark whole groups like this: 
:qmark f http://forum1.com, http://forum2.com, imdb some artist

:qmarks 

:qmarks [arg]

Show all QuickMarks. If [arg] is specified then limit the list to those QuickMarks mentioned.


Local marks

m
m{a-zA-Z}

Set mark at the cursor position. Marks a-z are local to the buffer, whereas A-Z are valid between buffers.

` '


'{a-zA-Z}

Jump to the mark in the current buffer. Marks a-z are local to the buffer, whereas A-Z are valid between buffers.

:delm :delmarks 

:delm[arks] {marks}

:delm[arks]!

Delete the specified marks. Marks are presented as a list.

Examples:

:delmarks Aa b p deletes marks A, a, b and p


:delmarks b-p deletes all marks in the range b to p


:delmarks! deletes all marks for the current buffer 

:ma :mark 

:ma[rk] {a-zA-Z}

Mark current location within the web page.

:marks


:marks [arg]

Show all location marks of current web page. If [arg] is specified then limit the list to those marks mentioned.


		55.1.12 record macros


Macros

complex-repeat macros 	

q 

q {arg}


Record a key sequence into a macro. Available macros are {0-9a-zA-Z} (uppercase to append). Type q to stop recording.

:macros


:mac[ros] [regex]

List recorded macros matching the optional regular expression. If no regex is given, list all.

:delmac :delmacros 

:delmac[ros] [regex]


Delete recorded macros matching a regular expression.

@ @@ :play 

[count]@ {arg}

[count]@@

:pl[ay] {arg}


Plays the contents of macro {0-9a-z}.

@@ replays a previous executed macro.

:play {arg} plays a recorded macro.


Using scripts

using-scripts 	

:so :source 

:so[urce][!] {file}


Read Ex commands from {file}. You can either source files which mostly contain Ex commands like map < gt and put JavaScript code within a:

js <<EOF
hello = function () {
  alert("Hello world");
}
EOF

Or you can alternatively source a file which ends in .js, these files are automatically sourced as pure JavaScript files.

Note: In both cases you must add functions to the global window object like shown above, functions written as:

function hello2() {
  alert("Hello world");
}

are only available within the scope of the script.

The .vimperatorrc file in your home directory and any files in ~/.vimperator/plugin/ are always sourced at startup. ~ is supported as a shortcut for the $HOME directory. If [!] is specified, errors are not printed.


Profiling

profiling profile 	

:time 

:[count]time[!] {code|:command}


Profile a piece of code or a command. Run {code} [count] times (default 1) and returns the elapsed time. {code} is always passed to JavaScript's eval(), which might be slow, so take the results with a grain of salt.

If {code} starts with a :, it is executed as a Vimperator command.

Use the special version with [!] if you just want to run any command multiple times without showing profiling statistics.


		55.1.13 autocommands


Autocommands are a way to automatically execute code when certain events happen.

:au :autocmd


:au[tocmd]
Execute commands automatically on events. 

:au[tocmd] {event} {pat} {cmd}.

Add {cmd} to the list of commands Vimperator will execute on {event} for a URL matching {pat}:

:autocmd[!] {events} {pat}: list/remove autocommands filtered by {events} and {pat} 

:autocmd[!] {events}: list/remove autocommands matching {events} 

:autocmd[!] * {pat}: list/remove autocommands matching {pat} 

:autocmd[!]: list/remove all autocommands 

Available {events}:

LocationChange 	Triggered when changing tabs or when navigating to a new location 	
PageLoadPre 	Triggered after a page load is initiated. 	
PageLoad 	Triggered when a page gets (re)loaded/opened 	
Quit 	Triggered before exiting Firefox 	
Startup 	Triggered after Firefox starts 	

{pat} is a regular expression, use .* if you want to match all URLs.


Examples

autocmd_examples 	

Enable passthrough mode on all Google sites:

:au LocationChange .* js modes.passAllKeys = /google\.com/.test(buffer.URL)

Enable passthrough mode on some Google sites:

:au LocationChange .* js modes.passAllKeys = /(www|mail)\.google\.com/.test(buffer.URL)

Set the filetype to mail when editing email at Gmail:

:au LocationChange .* :set editor=gvim -f
:au LocationChange mail\.google\.com :set editor=gvim -f -c 'set ft=mail'


		55.1.14 printing


:ha :hardcopy


:ha[rdcopy][!]

Print current document. Open a GUI dialog where you can select the printer, number of copies, orientation, etc. When used with [!], the dialog is skipped and the default printer used.


Firefox printing dialogs

firefox-print-dialogs 	

The "Print Preview" and "Page Setup" dialogs can be opened via the :dialog command

:dialog printpreview

and

:dialog printsetup

respectively.



		55.1.15 Various commands

various 	

<C-l> CTRL-L :redr :redraw


:redr[aw]

Redraws the screen. Useful to update the screen halfway executing a script or function.

:norm :normal 

:norm[al][!] {commands}


Execute Normal mode commands {commands}. This makes it possible to execute Normal mode commands typed on the command-line. {commands} is executed like it is typed. If the [!] is given, mappings will not be used. {commands} should be a complete command. {commands} cannot start with a space. Put a 1 (one) before it, 1 space is one space.

:run :!


:!{cmd}

Run a command. Runs {cmd} through system() and displays its output. Any '!' in {cmd} is replaced with the previous external command. But not when there is a backslash before the '!', then that backslash is removed.

Warning: Input redirection (< foo) not done, also do not run commands which require stdin or it will hang Firefox!

:ve :version


:ve[rsion][!]

Show version information. You can show the Firefox version page with :version!.


Online help

online-help 	

<F1> :help :h help 

:h[elp] {subject}

<F1>

Open help window. The default section is shown unless {subject} is specified. If you need help for a specific topic, try :help overview.

:exu :exusage 

:exu[sage]

Show help on Ex commands. Added to simulate the Nvi command.

:viu :viusage 

:viu[sage]

Show help on Normal mode commands. Added to simulate the Nvi command.

| 42


What is the meaning of life, the universe and everything? Douglas Adams, the only person who knew what this question really was about is now dead, unfortunately. So now you might wonder what the meaning of death is


Uncategorized help

uncategorized 	

<C-[> <Esc>


<Esc>

Focus content. Exits any command line or hint mode and returns to browser mode. Also focuses the web page, in case a form field has focus and eats our key presses.

: 

:

Start command line mode. In command line mode, you can perform extended commands, which may require arguments.

<Insert> i


i

Start caret mode. This mode resembles the Vim normal mode where you see a text cursor and can move around. If you want to select text in this mode, press v to start its Visual mode.

:addo :addons


:addo[ns]

Show available Browser Extensions and Themes. You can add/remove/disable browser extensions from this dialog. Be aware that not all Firefox extensions work, because Vimperator overrides some key bindings and changes Firefox's GUI.

:beep 

:beep

Play a system beep.

:emenu


:emenu {menu}

Execute {menu} from the command line. This command provides command line access to all menu items available from the main Firefox menubar. {menu} is a hierachical path to the menu item with each submenu separated by a period. E.g. :emenu File.Open File

:dia :dialog 

:dia[log] [firefox-dialog]


Open a firefox-dialog. Available dialogs: use completion on :dialog <Tab>

:dl :downl :downloads


:downl[oads]

Show progress of current downloads. Open the original Firefox download dialog in a new tab. Here, downloads can be paused, canceled and resumed.

:sbcl :sbclose 

:sbcl[ose]

Close the sidebar window.

:sbope :sbopen :sb :sbar :sideb :sidebar


:sidebar {name}

Open the sidebar window. {name} is any of the menu items listed under the standard Firefox View->Sidebar menu. Add-ons, Preferences and Downloads are also available in the sidebar.


	55.2

56. Mapping keys in Vim - Tutorial 
Tip 1516 author Yegappan Lakshmanan · 

	56.1 Part 1
		56.1.1 Introduction
Key mapping refers to creating a shortcut for repeating a sequence of keys or commands. You can map keys to execute frequently used key sequences or to invoke an Ex command or to invoke a Vim function or to invoke external commands. Using key maps you can define your own Vim commands.

Vim supports several editing modes - normal, insert, replace, visual, select, command-line and operator-pending. You can map a key to work in all or some of these modes.

The general syntax of a map command is:

{cmd} {attr} {lhs} {rhs}

where
{cmd}  is one of ':map', ':map!', ':nmap', ':vmap', ':imap',
       ':cmap', ':smap', ':xmap', ':omap', ':lmap', etc.
{attr} is optional and one or more of the following: <buffer>, <silent>,
       <expr> <script>, <unique> and <special>.
       More than one attribute can be specified to a map.
{lhs}  left hand side, is a sequence of one or more keys that are being
       mapped.
{rhs}  right hand side, is the sequence of keys that the {lhs} keys are
       mapped to.

Examples:

map <F2> :echo 'Current time is ' . strftime('%c')<CR>
map! <F3> a<C-R>=strftime('%c')<CR><Esc>
nnoremap <silent> <F2> :lchdir %:p:h<CR>:pwd<CR>

The first step in creating a map is to decide the sequence of keys that needs to be mapped. When you invoke a map, Vim will execute the sequence of keys as though you entered it from the keyboard. You can do this by manually entering the key sequence and verifying that they perform the desired operation.

The second step is to decide the editing mode (insert mode, visual mode, command-line mode, normal mode, etc.) in which the map should work. Instead of creating a map that works in all the modes, it is better to define the map that works only in selected modes.

The third step is to find an unused key sequence that can be used to invoke the map. You can invoke a map using either a single key or a sequence of keys.

The above steps are explained in more detail in the following sections. 

		56.1.2 Creating keymaps
To map a sequence of keys to execute another sequence of keys, use the ':map' command.

For example, the following command maps the <F2> key to display the current date and time.

:map <F2> :echo 'Current time is ' . strftime('%c')<CR>

The following command maps the <F3> key to insert the current date and time in the current buffer:

:map! <F3> a<C-R>=strftime('%c')<CR><Esc>

The ':map' command creates a key map that works in normal, visual, select and operator pending modes. The ':map!' command creates a key map that works in insert and command-line mode.

A better alternative than using the 'map' and 'map!' commands is to use mode-specific map commands which are described in later sections. 

		56.1.3 Storing the key maps
If you want to map a key for only one Vim session temporarily, then you don't need to save the map command in a file. When you quit that Vim instance, the temporary map definition will be lost.

If you want to restore the key maps across Vim instances, you need to save the map definition command in a file.

One place to store the map commands is the $HOME/.vimrc or $HOME/_vimrc or $VIM/_vimrc file. If you have filetype specific key maps, then you can store them in the filetype specific plugin files. The key maps defined by Vim plugins are stored in the plugin or script file itself.

When adding the map commands to a file, there is no need to prefix the commands with the ':' character. 

		56.1.4 Listing key maps
You can display a list of existing key maps using the following commands without any arguments:

:map
:map!

The first command displays the maps that work in normal, visual and select and operator pending mode. The second command displays the maps that work in insert and command-line mode.

To display the mode specific maps, prefix the ':map' command with the letter representing the mode.

:nmap - Display normal mode maps
:imap - Display insert mode maps
:vmap - Display visual and select mode maps
:smap - Display select mode maps
:xmap - Display visual mode maps
:cmap - Display command-line mode maps
:omap - Display operator pending mode maps

Example:

:nmap
n  <C-W>*      * <C-W><C-S>*
n  <C-W>#      * <C-W><C-S>#
n  <F2>        * :lchdir %:p:h<CR>:pwd<CR>

In the output of the above commands, the first column indicates the mode in which the map works. You can interpret the first column character using the following table:

n  Normal mode map. Defined using ':nmap' or ':nnoremap'.
i  Insert mode map. Defined using ':imap' or ':inoremap'.
v  Visual and select mode map. Defined using ':vmap' or ':vnoremap'.
x  Visual mode map. Defined using ':xmap' or ':xnoremap'.
s  Select mode map. Defined using ':smap' or ':snoremap'.
c  Command-line mode map. Defined using ':cmap' or ':cnoremap'.
o  Operator pending mode map. Defined using ':omap' or ':onoremap'.

<Space>  Normal, Visual and operator pending mode map. Defined using
         ':map' or ':noremap'.
!  Insert and command-line mode map. Defined using 'map!' or
   'noremap!'.

The following characters may be displayed before the {rhs} of the map:

*  The {rhs} of the map is not re-mappable. Defined using the
   ':noremap' or ':nnoremap' or ':inoremap', etc. commands.
&  Only script local mappings are re-mappable in the {rhs} of the
   map. The map command has the <script> attribute.
@  A buffer local map command with the <buffer> attribute.

To display all the key maps that start with a particular key sequence, enter the key sequence in the above commands. For example, the following command displays all the normal mode maps that start with 'g'.

:nmap g

To display all the buffer-local maps for the current buffer, use the following commands:

:map <buffer>
:map! <buffer>

Typically the output of the above commands will span several pages. You can use the following set of commands to redirect the output to the vim_maps.txt file:

:redir! > vim_maps.txt
:map
:map!
:redir END

		56.1.5 Removing a keymap
To permanently remove a map, you first need to locate the place where it is defined by using the ':verbose map {lhs}' command (replace {lhs} with the mapped key sequence). If the map is defined in the .vimrc or _vimrc file or in one of the files in the vimfiles or .vim directory, then you can edit the file to remove the map.

Another approach is to use the ':unmap' and ':unmap!' commands to remove the map. For example, to remove the map for the <F8> key, you can use the following commands:

:unmap <F8>
:unmap! <F8>

Note that after a key is unmapped using the ':unmap' command, it can be mapped again later. Also you cannot unmap a key used by one of the Vim internal commands. Instead you have to map it to <Nop> to disable it's functionality. If you are trying to disable a key map defined by a plugin, make sure the unmap command is executed after the key map is defined by the plugin.

You can remove a mode-specific map by using the mode specific unmap command. The mode-specific unmap commands are listed below:

nunmap - Unmap a normal mode map
vunmap - Unmap a visual and select mode map
xunmap - Unmap a visual mode map
sunmap - Unmap a select mode map
iunmap - Unmap an insert and replace mode map
cunmap - Unmap a command-line mode map
ounmap - Unmap an operator pending mode map

Note that in the above unmap commands, if a space character is present at the end of the unmapped key sequence, then the command will fail. For example, the following unmap command will fail (replace <Space> with a space character):

:nnoremap <F2> :ls<CR>
:nunmap <F2><Space>

To map a key in only a selected set of modes, you can use the ':map' and ':map!' commands and then unmap them using the mode specific unmap commands in a few modes. For example, to map a key in normal and visual mode but not in operator-pending mode, you can use the following commands:

:map <F6> ....
:ounmap <F6>

To clear all the mappings for a particular mode, you can use the ':mapclear' command. The mode-specific map clear commands are listed below:

mapclear  - Clear all normal, visual, select and operating pending
            mode maps
mapclear! - Clear all insert and command-line mode maps
nmapclear - Clear all normal mode maps
vmapclear - Clear all visual and select mode maps
xmapclear - Clear all visual mode maps
smapclear - Clear all select mode maps
imapclear - Clear all insert mode maps
cmapclear - Clear all command-line mode maps
omapclear - Clear all operating pending mode maps

		56.1.6 Mode-specific maps
Vim supports creating keymaps that work only in specific editing modes. You can create keymaps that work only in normal, insert, visual, select, command and operator pending modes. The following table lists the various map commands and their corresponding editing mode:

Commands                        Mode
--------                        ----
nmap, nnoremap, nunmap          Normal mode
imap, inoremap, iunmap          Insert and Replace mode
vmap, vnoremap, vunmap          Visual and Select mode
xmap, xnoremap, xunmap          Visual mode
smap, snoremap, sunmap          Select mode
cmap, cnoremap, cunmap          Command-line mode
omap, onoremap, ounmap          Operator pending mode

Note that the language specific mappings defined using the ':lmap' and ':lnoremap' commands are not discussed here. For more information about this refer to the Vim help. 

			56.1.6.1 Normal mode maps
To map keys that work only in the normal mode, use the ':nmap' or ':nnoremap' command. The 'n' in ':nmap' and ':nnoremap' denotes normal mode.

For example, the following command maps the <F5> key to search for the keyword under the cursor in the current directory using the 'grep' command:

:nnoremap <F5> :grep <C-R><C-W> *<CR>

Examples:

The following commands map the 'j' key to execute 'gj' and the 'k' key to execute 'gk'. These are useful for moving between long wrapped lines.

:nnoremap k gk
:nnoremap j gj

The following command maps ',b' to display the buffer list and invoke the ':buffer' command. You can enter the desired buffer number and hit <Enter> to edit the buffer.

:nnoremap ,b :ls<CR>:buffer<Space>

In the above command, you can enter <Space> at the end of the map command either literally or by pressing the space bar.

To display the currently defined normal mode maps, use the ':nmap' command without any argument:

:nmap

To remove a keymap from normal mode, use the ':nunmap' command. For example, the following command removes the map for the <F9> key from normal mode:

:nunmap <F9>

If you invoke an Ex command from a map, you have to add a <CR> or <Enter> or <Return> at the end of the Ex command to execute the command. Otherwise the command will not be executed. For example:

:nnoremap <F3> :ls

With the above map, if you use <F3> in normal mode, you will be left in the ':' command-line after the text 'ls'. To execute the command, you have to use <CR> at the end of the command:

:nnoremap <F3> :ls<CR>

Now, when you press <F3>, the 'ls' Ex command will be executed.

From a normal mode map, you can get the keyword under the cursor using the expand('<cword>') function or using the <C-R><C-W> command. For example, the following two map commands provide the same functionality:

:nnoremap ,s :exe 'grep ' . expand('<cword>') . ' *'<CR>
:nnoremap ,s :grep <C-R><C-W> *<CR>

			56.1.6.2 Insert mode maps
To map keys that work only in the insert and replace modes, use the 'imap' or 'inoremap' command.

Example: The following command maps <F2> to insert the directory name of the current buffer:

:inoremap <F2> <C-R>=expand('%:p:h')<CR>

To display the currently defined insert mode maps, use the 'imap' command without any argument:

:imap

To remove a keymap from insert mode, use the ':iunmap' command. For example, the following command removes the insert mode map for <F2>.

:iunmap <F2>

As printable keys insert a character in the current buffer in insert mode, you should use non-printable keys to create insert mode maps. Some examples for non-printable keys include the function keys <F2>, keys prefixed with the Ctrl or Alt key.

To execute Vim normal mode commands from an insert mode map, you have to go from insert mode to normal mode. But after executing the map, you may want to restore the mode back to insert mode. To do this, you can use the <CTRL-O> insert-mode key which temporarily goes to normal-mode for one normal mode command and then comes back to insert mode. For example, to call the Vim function MyVimFunc() from insert mode, you can use the following map command:

:inoremap <F5> <C-O>:call MyVimFunc()<CR>

One caveat with using the <C-O> command is that if the cursor is after the last character in a line in insert mode, then <C-O> moves the cursor one character to the left after executing the map. If you don't want this, then you can use the <C-\><C-O> command, which doesn't move the cursor. But now the cursor may be placed on a character beyond the end of a line. The above map command is modified to use the <C-\><C-O> key:

:inoremap <F5> <C-\><C-O>:call MyVimFunc()<CR>

Both the <C-O> and <C-\><C-O> commands create a new undo point, i.e. you can undo the text inserted before and after typing these commands separately.

Another alternative for going from insert mode to normal mode is to use the <Esc> key. But it is preferable to use the <C-O> or <C-\><C-O> command for this.

If you press <Esc> in normal mode to make sure you are in normal mode, then you will hear the error beep sound. Instead, you can use the CTRL-\ CTRL-N command to go to normal mode. If you are already in normal mode, this command will not result in the error bell. This command can be used from a map to go to normal mode.

After executing the normal mode commands from an insert mode map, if the cursor position was moved by the map and no new text was inserted by the commands invoked, then you can use the gi command to restart the insert mode from the previous position where the insert mode was last stopped.

You can insert the result of a Vim expression in insert mode using the <C-R>= command. For example, the following command creates an insert mode map command that inserts the current directory:

:inoremap <F2> <C-R>=expand('%:p:h')<CR>

If you don't want to insert anything then you can return an empty string from the expression. For example, you can invoke a function from the insert mode map to perform some operation but return an empty string from the function.

The <C-R>= command doesn't create a new undo point. You can also call Vim functions using the <C-R>= command:

:inoremap <F2> <C-R>=MyVimFunc()<CR>

When Vim parses a string in a map command, the \<...> sequence of characters is replaced by the corresponding control character. For example, let us say in insert mode you want the down arrow key to execute <C-N> when the insert complete popup menu is displayed. Otherwise, you want the down arrow key to move the cursor one line down. You can try the following command (which doesn't work):

:inoremap <Down> <C-R>=pumvisible() ? '\<C-N>' : '\<Down>'<CR>

When parsing the above command, Vim replaces <C-N> and <Down> with the corresponding control characters. When you press the down arrow in insert mode, as there are control characters in the expression now, the command will fail.

To fix this, you should escape the '<' character, so that Vim will not replace '\<C-N>' with the control character when parsing the command. The following command works:

:inoremap <Down> <C-R>=pumvisible() ? '\<lt>C-N>' : '\<lt>Down>'<CR>

With the above command, Vim will use the control character only when the map is invoked and not when the above command is parsed.

To insert a template you should use a Vim abbreviation instead of a insert mode map. For more information about abbreviations refer to the Vim help.

Note that if the 'paste' option is set, then insert mode maps are disabled. 

			56.1.6.3 Visual mode maps
To map keys that work only in visual mode, use the ':vmap' or ':vnoremap' commands. These maps are invoked when you press the mapped keys after visually selecting a range of characters.

For example, the following command maps the g/ key sequence to search for the visually selected sequence of characters:

:vnoremap g/ y/<C-R>"<CR>

"

Another visual mode map example to add single quotes around a selected block of text:

:vnoremap qq <Esc>`>a'<Esc>`<i'<Esc>

To display all the currently defined visual mode maps, use the ':vmap' command without any arguments:

:vmap

To remove a visual mode map, use the ":vunmap" command. For example, the following command removes the visual mode map for g/:

:vunmap g/

From a visual mode map, you can either perform a text editing operation on the selected characters or add/remove characters at the beginning and/or end of the selected region or pass the selected text to some other internal/external command.

The '< Vim mark represents the beginning line of a visual region and the '> mark represents the ending line of the visual region. The `< mark represents the beginning character position of the visual region and the `> mark represents the ending character position of the visual region. You can use these marks in your map to perform operation at the beginning and end of the visual region. If the map is invoked from visual mode, then these marks will refer to the beginning and end of the previous selection and not to the current selected region.

If you want to use the visually selected text in your map, then you can yank the text and then use it in your map. You can either yank the text to a register or use the unnamed (") register. For example, the following command maps the g/ key sequence to search for the visually selected text:

:vnoremap g/ y/<C-R>"<CR>

Another approach is to use the above described marks and get the text in the region from the buffer using the getline() function.

To execute an Ex command from a visual mode map, you have to first enter the command-line mode using the ':' character. After visually selecting a sequence of characters, when you press ':' to execute a Vim Ex command, Vim automatically inserts the visual block begin ('<') and end ('>') marks. If you invoke an Ex command with this range, then the command is executed for every line in this range. This may be undesirable. For example, if you invoke a Vim function, then the function will be executed separately for each line in the range (unless the function is defined with the '-range' attribute). To remove the visual block start and end marks, use the <C-U> command, which removes all the characters between the start of the line and the current cursor position, at the beginning of your map. For example,

:vnoremap <F2> :<C-U>call MyVimFunc()<CR>

When you enter a mapped key sequence in character-wise or line-wise or block-wise visual mode, the same visual map is invoked. You can use the visualmode() function in your map to differentiate between these modes. For example, the following code maps the <F5> keys in visual mode to invoke the MyFunc() function. The MyFunc() function uses the visualmode() function to distinguish between the visual modes.

vnoremap <silent> <F5> :<C-U>call MyFunc()<CR>
function! MyFunc()
    let m = visualmode()
    if m ==# 'v'
        echo 'character-wise visual'
    elseif m == 'V'
        echo 'line-wise visual'
    elseif m == "\<C-V>"
        echo 'block-wise visual'
    endif
endfunction

Note that we use ==# for the initial comparison instead of ==. This is because ==# will always make a case-sensitive comparison, whereas == will consider 'v' and 'V' to be the same if the ignorecase option has been set.

When you enter the command mode using ':' in visual mode, the visual mode is stopped. If you want to re-enter the visual mode from a function invoked from a map, you can use the gv command:

vnoremap <silent> <F5> :<C-U>call MyFunc()<CR>
function! MyFunc()
    normal! gv
endfunction

The maps created with the ":vmap" and ":vnoremap" commands work in both Visual mode and Select mode. When a map is invoked in select mode, Vim temporarily switches to visual mode before executing the map and at the end of the map, switches back to select mode. So the map behaves the same in visual and select mode.

To create a map that works only in Visual mode and not in Select mode use the ":xmap" and ":xnoremap" commands. All the other descriptions for the ":vmap" and ":vnoremap" commands also apply to the ":xmap" and ":xnoremap" commands.

To create a map that works only in Select mode and not in Visual mode use the ":smap" and ":snoremap" commands. 

			56.1.6.4 Command-line mode maps
To map keys to work only in the command-line mode, use the "cmap" or ":cnoremap" commands.

The command-line mode map works in the following command prompts:

:    Ex command prompt
/    Forward search prompt
?    Backward search prompt
>    Debug prompt
@    input() prompt
-    :insert and :append prompts.

You can distinguish between the above prompts using the getcmdtype() function in your map. Example:

:cnoremap <F8> <C-R>=MyFunc()<CR>
function! MyFunc()
    let cmdtype = getcmdtype()
    if cmdtype == ':'
        " Perform Ex command map action
    elseif cmdtype == '/' || cmdtype == '?'
        " Perform search prompt map action
    elseif cmdtype == '@'
        " Perform input() prompt map action
    else
        " Perform other command-line prompt action
    endif
endfunction

To invoke functions from a command-line map, you have to use the '<C-R>=' command or the 'CTRL-\ e' command. An example map that shows this is below:

:cnoremap <C-F6> <C-R>=Somefunc()<CR>
:cnoremap <C-F6> <C-\>eSomefunc()<CR>

The <C-R>= command inserts the value returned by the invoked function at the current location in the command-line. The <C-\>e command replaces the entire command-line with the value returned by the invoked function.

The <C-R>= and <C-\>e commands cannot be used in the prompt for getting an expression (represented by =). For example, to insert the value of the Vim variable 'abc' in the command line, you can use <C-R>=abc<CR> command. In the prompt where you enter the variable name, you cannot again use <C-R>= and <C-\>e. To do this use the <expr> attribute to the map command as explained below.

Another way to invoke a function from a command-line mode map is to use the <expr> attribute as shown below:

:cnoremap <expr> <C-F6> Cmdfunc()

Using the above map, the value returned by Cmdfunc() is inserted at the current location in the command-line.

In the function invoked by the <C-R>= and <C-\>e commands and <expr> attribute, you can use the getcmdpos() function to get the current position of the cursor in the command. You can use the setcmdpos() function to change the location of the cursor in the command-line. You can use the getcmdline() function to get the current command-line.

It is preferable to use a non-printable control character for invoking a command-line mode map. Otherwise, the map may interfere with the printable characters used in the Vim Ex commands.

Note that if the 'paste' option is set, then command-line mode maps are disabled. 

			56.1.6.5 Operator pending mode maps
You can create maps that work only when waiting for a motion command from an operator command. For example, the yank command 'y' yanks the text that is selected by the motion that follows the command. To yank the current line and the two following lines of text, you can use the command 'y2j'. After pressing 'y', Vim waits for you to enter the motion command. The operator pending maps can be used here. The operator pending mode maps can be used to define your own text objects.

Operator pending commands are defined using the ":omap" and ":onoremap" commands.

For example, the following command creates an operator pending map for <F6> to select the current inner block defined by "{" and "}".

:onoremap <F6> iB

You can now yank an inner block using the y<F6> command, delete an inner block using the d<F6> command, etc.

To change the starting location of the operator from a operator-pending mode map, you can start visual mode and select the desired range of characters. One disadvantage in starting visual mode is that the previous visual region will be lost. 

		56.1.7 Mapping mouse events
You can map mouse events similar to mapping keys to perform some action. The following mouse events can be mapped:

<LeftMouse>     - Left mouse button press
<RightMouse>    - Right mouse button press
<MiddleMouse>   - Middle mouse button press
<LeftRelease>   - Left mouse button release
<RightRelease>  - Right mouse button release
<MiddleRelease> - Middle mouse button release
<LeftDrag>      - Mouse drag while Left mouse button is pressed
<RightDrag>     - Mouse drag while Right mouse button is pressed
<MiddleDrag>    - Mouse drag while Middle mouse button is pressed
<2-LeftMouse>   - Left mouse button double-click
<2-RightMouse>  - Right mouse button double-click
<3-LeftMouse>   - Left mouse button triple-click
<3-RightMouse>  - Right mouse button triple-click
<4-LeftMouse>   - Left mouse button quadruple-click
<4-RightMouse>  - Right mouse button quadruple-click
<X1Mouse>       - X1 button press
<X2Mouse>       - X2 button press
<X1Release>     - X1 button release
<X2Release>     - X2 button release
<X1Drag>        - Mouse drag while X1 button is pressed
<X2Drag>        - Mouse drag while X2 button is pressed

Few examples for mapping the above mouse events is given below.

To jump to the tag under the cursor when the tag is double clicked, you can use the following map:

:nnoremap <2-LeftMouse> :exe "tag ". expand("<cword>")<CR>

The above map uses the expand() function to get the keyword under the cursor and then invokes the "tag" command with the current keyword. The "execute" command is used to concatenate the tag command and the output of the expand() function.

To map the X1 and X2 buttons to go forward and backward in the jump list, you can use the following map:

:nnoremap <X1Mouse> <C-O>
:nnoremap <X2Mouse> <C-I>

The above maps use the <C-O> and <C-I> normal mode commands to walk the jump list.

When you paste text using the middle mouse button, the text is pasted at the current cursor position. To paste at the position of the middle mouse button click, you can use the following map:

:nnoremap <MiddleMouse> <LeftMouse><MiddleMouse>

The above map first moves the cursor to the point where the click is made and then invokes the <MiddleMouse> functionality.

If you create a map for one of these mouse events, it overrides the internal default handling of that event by Vim. To pass the event to Vim, so that the default handling is also done, you can use "nnoremap" and specify the event in the {rhs} of the map. For example,

:nnoremap <LeftRelease> <LeftRelease>:call MyFunc()<CR>

With the above map, when the Left mouse button is pressed, the cursor is moved to that location and then the function MyFunc() is called.

You can disable a mouse event, by mapping it to <Nop> If you have a scrollwheel and often accidentally paste text when scrolling text, you can use the following mappings to disable the pasting with the middle mouse button:

:nnoremap <MiddleMouse> <Nop>
:inoremap <MiddleMouse> <Nop>

		56.1.8 Nested (recursive) maps
You can map mouse events similar to mapping keys to perform some action. The following mouse events can be mapped:

<LeftMouse>     - Left mouse button press
<RightMouse>    - Right mouse button press
<MiddleMouse>   - Middle mouse button press
<LeftRelease>   - Left mouse button release
<RightRelease>  - Right mouse button release
<MiddleRelease> - Middle mouse button release
<LeftDrag>      - Mouse drag while Left mouse button is pressed
<RightDrag>     - Mouse drag while Right mouse button is pressed
<MiddleDrag>    - Mouse drag while Middle mouse button is pressed
<2-LeftMouse>   - Left mouse button double-click
<2-RightMouse>  - Right mouse button double-click
<3-LeftMouse>   - Left mouse button triple-click
<3-RightMouse>  - Right mouse button triple-click
<4-LeftMouse>   - Left mouse button quadruple-click
<4-RightMouse>  - Right mouse button quadruple-click
<X1Mouse>       - X1 button press
<X2Mouse>       - X2 button press
<X1Release>     - X1 button release
<X2Release>     - X2 button release
<X1Drag>        - Mouse drag while X1 button is pressed
<X2Drag>        - Mouse drag while X2 button is pressed

Few examples for mapping the above mouse events is given below.

To jump to the tag under the cursor when the tag is double clicked, you can use the following map:

:nnoremap <2-LeftMouse> :exe "tag ". expand("<cword>")<CR>

The above map uses the expand() function to get the keyword under the cursor and then invokes the "tag" command with the current keyword. The "execute" command is used to concatenate the tag command and the output of the expand() function.

To map the X1 and X2 buttons to go forward and backward in the jump list, you can use the following map:

:nnoremap <X1Mouse> <C-O>
:nnoremap <X2Mouse> <C-I>

The above maps use the <C-O> and <C-I> normal mode commands to walk the jump list.

When you paste text using the middle mouse button, the text is pasted at the current cursor position. To paste at the position of the middle mouse button click, you can use the following map:

:nnoremap <MiddleMouse> <LeftMouse><MiddleMouse>

The above map first moves the cursor to the point where the click is made and then invokes the <MiddleMouse> functionality.

If you create a map for one of these mouse events, it overrides the internal default handling of that event by Vim. To pass the event to Vim, so that the default handling is also done, you can use "nnoremap" and specify the event in the {rhs} of the map. For example,

:nnoremap <LeftRelease> <LeftRelease>:call MyFunc()<CR>

With the above map, when the Left mouse button is pressed, the cursor is moved to that location and then the function MyFunc() is called.

You can disable a mouse event, by mapping it to <Nop> If you have a scrollwheel and often accidentally paste text when scrolling text, you can use the following mappings to disable the pasting with the middle mouse button:

:nnoremap <MiddleMouse> <Nop>
:inoremap <MiddleMouse> <Nop>

		56.1.9 Comments

	56.2 Part 2
		56.2.1 Finding unused keys
In your private maps you should use key sequences that are not used by Vim and by other Vim plugins.

Many of the key sequences that you can enter from the keyboard are used by Vim to implement the various internal commands. If you use a key sequence in your map that is already used by Vim, then you will not be able to use the functionality provided by Vim for that key sequence. To get a list of the key sequences used by Vim, read the following help topic:

:help index.txt

If you don't use some Vim functionality invoked by a particular key sequence or you have an alternate key sequence to use that functionality then you can use that key sequence in your maps.

Some of the key sequences may be used by the existing Vim scripts and plugins. To display the list of keys that are currently mapped, use the following commands:

:map
:map!

To determine the script or plugin that defines a map for a key sequence, use the following command.

:verbose map <key>

In the above command, replace <key> with the desired key sequence. For example, to list all the locations where maps beginning with "," are defined, use the following command:

:verbose map ,

Try to use an unused key sequence in your maps. Typically, the <F2>, <F3>, ... etc function keys are unused. The function keys in combination with Control, Alt and Shift can also be used. But some of the key combinations may not work in all the terminal emulators. Most of the key combinations should work in GUI Vim.

You can also prefix the desired key sequence with a backslash (\) or comma (,) or underscore (_), etc. and use that in your maps.

Note that you cannot map the Shift or Alt or Ctrl keys alone as they are key modifiers. You have to combine these key modifiers with other keys to create a map.

You should not use a frequently used Vim key sequence at the start of your maps. For example, you should not start your normal mode map key sequence with "j" or "k" or "l" or "h". These keys are used for moving the cursor in normal mode. If you use any of these keys at the beginning of your maps, then you will obseve a delay when you enter a single "j" or "k" or "l" or "h". 

		56.2.2 Key notation
When defining a map command, you can enter printable characters like 'a', 'V', etc. literally. You can enter non-printable control characters (like Ctrl-G, Alt-U, Ctrl-Shift-F2, F2, etc.) in several different ways.

You can enter a non-printable control character in a map command by preceding it with CTRL-V. For example, to map the Ctrl-K key to display the buffer list, you can use the following map command:

:map <press Ctrl-V><press Ctrl-K> :ls<press Ctrl-V><press Enter>

The Ctrl-V key sequence is used to escape the following control character.

The following table shows the mapping between some of the keys on the keyboard and the equivalent Ctrl-key combination:

Ctrl-I      Tab
Ctrl-[      Esc
Ctrl-M      Enter
Ctrl-H      Backspace

If you use one of the Ctrl-key combination in the above table in a map, the map also applies to the corresponding key. Both the keys produce the same key scan code. For example, if you create a map for CTRL-I, then you can invoke the map by pressing Ctrl-I or the Tab key.

On Unix like systems, the Ctrl-S and Ctrl-Q keys may be used for terminal flow control. If you map these keys in Vim, then when you invoke them, Vim will not receive these key sequences. To use these keys in Vim, you have to change the flow control characters used by the terminal using the 'stty start' and stty stop' commands to some other character or disable the terminal flow control using the following command:

$ stty -ixon

Similarly, Ctrl-Z is used to suspend Vim on Unix-like systems. To use Ctrl-Z in your maps, you can change the suspend character using the 'stty susp' command.

On MS-Windows, if the mswin.vim file is used, then CTRL-V is mapped to paste text from the clipboard. In this case, you can use CTRL-Q instead of CTRL-V to escape control characters.

To create a map for the Ctrl-v key, you have to enter it four times:

:imap ^V^V^V^V EscapeCharacter

In the above command to enter a single ^V, you have to press Ctrl and v. When Vim parses the above command, it replaces the ^V^V^V^V sequence with ^V^V (two Ctrl-V characters). When the map is invoked, Vim replaces the two Ctrl-V characters with a single Ctrl-V character.

The Ctrl-J character represents the linefeed and is internally used by Vim to represent the Nul character. You cannot create a map for Ctrl-J by using the following command:

"The following command doesn't work 
"
:imap <press Ctrl-V><press Ctrl-j> Newlinecharacter

You can also enter a control character by pressing Ctrl-V followed by the decimal or octal or hexadecimal value of the character. For example, to enter CTRL-P, you can press Ctrl-V followed by 016 (decimal) or x10 (hexadecimal) or o020.

Instead of entering the control characters directly in a map command as described above, it is preferable to use symbolic key notation for the control characters for readability. Vim supports representing control characters using symbolic notation like <F1>, <C-W>, <C-S-F1>, etc.

To determine the special key code representation that can be used in a map command, in insert mode, press the <CTRL-K> key followed by the key.

A key with the Ctrl key modifier is represented using the <C-key> notation. For example Ctrl-R is represented using <C-R>. A key with the Shift key modifier is represented using the <S-key> notation. For example Shift-F2 is represented using <S-F2>. A key with the Alt key modifier is represented using <A-key> or <M-key> notation. You can combine one or more key modifiers. For example, to represent Ctrl+Shift+F3 you can use <C-S-F3>.

The Vim key notation for other special characters is listed below:

<BS>           Backspace
<Tab>          Tab
<CR>           Enter
<Enter>        Enter
<Return>       Enter
<Esc>          Escape
<Space>        Space
<Up>           Up arrow
<Down>         Down arrow
<Left>         Left arrow
<Right>        Right arrow
<F1> - <F12>   Function keys 1 to 12
#1, #2..#9,#0  Function keys F1 to F9, F10
<Insert>       Insert
<Del>          Delete
<Home>         Home
<End>          End
<PageUp>       page-up
<PageDown>     page-down

Note that Vim understands only those keys that are supplied by the operating system to Vim. If a particular key sequence is handled by a window manager or is intercepted by the operating system, then Vim will not see that key sequence. Then, you can not use that key sequence in Vim.

To determine whether Vim receives a key sequence, in insert mode press <CTRL-V> followed by the key sequence. If you see some characters in the buffer, then Vim is receiving the entered key sequence.

If the escape sequence received by Vim is not a standard sequence, you can set the sequence to the desired key. For example, let us say <PageUp> is generating a non-standard key sequence in your system. Then you can use the following command:

:set <PageUp>=<type Ctrl-V><type PageUp>

In the above command, the first <PageUp> is inserted literally (8 characters). The argument after = is entered by pressing Ctrl-V followed by the <PageUp> key.

You can also specify a character by its numeric value in a map. A character is represented by <Char-xxx>, where xxx is the value of the character in decimal or octal or hexadecimal.

For example, the key CTRL-P has a value of 16 (decimal). This is represented by <Char-16> (in decimal), <Char-020> (in octal) and <Char-0x10> (in hexadecimal). You can create a map for <CTRL-P> using any one of the following commands:

:nnoremap <C-P> {
:nnoremap <Char-16> {
:nnoremap <Char-020> {
:nnoremap <Char-0x10> {

You can also use the termcap entry for a key in the map. The termcap entries are represented using the format <t_xx> where 'xx' is replaced with the key. You can get a list of termcap keys using the ":set termcap" command. For example, to map F8 you can use <t_F8>:

:nnoremap <t_F8> :make<CR>

But it is preferable to use key notations instead of terminal codes for special keys. 

		56.2.3 Maps with the same prefix
If more than one mapped key sequence starts with the same sequence of keys then when invoking the map you will notice a delay. For example, the ";" (semi-colon) command in normal mode repeats the previous f or t or F or T command. Assume that your map commands also start with ";". When you press ";", Vim needs to wait for you to enter sufficient number of characters to distinguish between the built-in internal command and your mapped commands.

When the 'timeout' option is set (which is the default), then Vim waits for the number of milliseconds specified in the 'timeoutlen' option for a mapped key sequence to complete. The default setting for 'timeoutlen' is one second.

If the 'timeout' option is reset, then Vim will not timeout for mapped key sequences. But it is better not to change the 'timeout' option setting and leave the option in its default value. Instead, if you want more or less delay before a mapped key sequence times out, you can try increasing or decreasing the 'timeoutlen' setting.

Consider the following maps:

:nnoremap ;g :echo 'First command'<CR>
:nnoremap ;k :echo 'Second command'<CR>

When you press ';' to repeat the last 't' or 'f' or 'T' or 'F' command, Vim will now wait for 'timeoutlen' milliseconds to check whether you are going to enter 'g' or 'k'. If you enter any other character or don't enter any character for a second, then Vim will repeat the last 't' or 'f' or 'T' or 'F' command. If you enter 'g' or 'k' after ';', then Vim will execute the corresponding map.

For the above described reason, it is better to avoid starting your mapped key sequence with a frequently used Vim command like j, k, l, etc. 

		56.2.4 Map comments
You cannot add a Vim comment in the same line as the map command. The comment will be included in the map command and executed when the key sequence is entered. For example, using the following command, when you press <F2>, Vim will try to execute the comment also as a series of key presses (resulting in error).

:map <F2> :ls<CR>     " Map to display the list of buffers

You can add the comment before the line that defines the map:

"Map to display the list of buffers
:map <F2> :ls<CR>

		56.2.5 Supplying a count to a map
To repeat a normal mode Vim command, you can specify a count before the command. For example, to move the cursor 3 lines up, you can use the '3k' command. If you specify a count before a mapped key sequence, the map may not be repated by the specified count.

When a count is entered before invoking a map, the count will be prepended to the key sequence executed for the map. For example, assume you have mapped <F7> to move the cursor by 5 characters to the right:

:nnoremap <F7> 5l

If you invoke the above map with a count of 2 using 2<F7>, the cursor will not be moved 10 characters to the right. Instead, the cursor will be moved 25 characters to the right. This is because the count 2 is prepended to the 5 in the map resulting in 25.

To allow repeating a map by a specified count, you have to define your map using either the '=' expression register or using a Vim function.

The '=' expression register allows you to specify an expression for the register contents. To use the expression register in your map, you have to combine that with the '@' operator. The '@' operator executes the contents of a register. If a count is specified before the '@' operator, then it executes the contents of a register by the specified count.

For example, change the above map command to:

:nnoremap <F7> @='5l'<CR>

Now, if you use 2<F7>, the cursor will be moved 10 characters to the right.

Some things to note about using the '=' register in your map. After specifying an expression, you have to use <CR> to end the command-line. If you want to use the escape character in the expression, you have to escape it using CTRL-V. For example, if you want to define a map to add the '#' character at the beginning of the current line, exit the insert mode and move the cursor one line down, you can use the following command:

:nnoremap <F4> @='I#<C-V><Esc>j'<CR>

Now if you press 3<F4>, the 3 lines starting from the current line are prefixed with the '#' character.

In the above map, if you specify a key sequence after the contents of the expression register, then those keys will not be executed by the '@' operator. So the specified count doesn't apply to those keys. For example, in the above map, if you move the 'j' out of the contents of the expression register:

:nnoremap <F4> @='I#<C-V><Esc>'<CR>j

Now, if you execute '3<F4>', three '#' characters will be added to the beginning of the current line and the cursor is moved to the following line.

Another approach to allow repeating a map is to use a Vim function to define the map. A Vim function can be defined to accept a count and repeat a operation that many number of times. You can use the "range" attribute to define a function that accepts a count.

If you supply a count to a function that doesn't accept a range, then you will get the 'Invalid range' error message. Example:

function! Myfunc()
    " Function that doesn't accept a range
    "
endfunction
:nnoremap _w :call Myfunc()<CR>

If you specify a count to the _w command, then you will see the 'Invalid range' error message.

If you want your map to accept a range, then you have to specify the range attribute when defining the function as shown below:

function! Myfunc() range
    echo 'range = ' . a:firstline . ',' . a:lastline
endfunction
:nnoremap _w :call Myfunc()<CR>

Now you can pass a count to the _w map. The a:firstline and a:lastline variables in the function refer to the starting line number and ending line number of the range supplied to the function. The default is the current line number.

You can also use the internal v:count and v:count1 Vim variables in your function to get the count specified to the last normal mode command or map. Example:

:nnoremap <C-W> :<C-U>call Myfunc()<CR>
function! Myfunc()
    let c = v:count
    " Do something count number of times
    "
endfunction

The v:count variable returns 0 if a count is not specified to the last normal mode command. The v:count1 variable returns 1 if a count is not specified to the last normal mode command/map. In the above map, <C-U> is used to erase the text on the command-line before invoking the function. 

		56.2.6 Using multiple Ex commands in a map
You can specify multiple Ex commands separated by "|" (bar) in the Ex command line (":"). The "|" is used as the command separator. For example,

:set invignorecase | set ignorecase?

If you specify "|" in the {rhs} of a map, then Vim will treat it as a command separator and only the first command will be part of the map and the subsequent commands will be executed when defining the map. For example,

:nnoremap <F9> :set invignorecase | set ignorecase?<CR>

In the above command, "set ignorecase?" will not be part of the map for <F9>.

You have to escape the "|" by using backslash (\) or by using the <Bar> symbolic notation or by using CTRL-V. The following commands will work:

:nnoremap <F9> :set invignorecase \| set ignorecase?<CR>

:nnoremap <F9> :set invignorecase <Bar> set ignorecase?<CR>
:nnoremap <F9> :set invignorecase <press Ctrl-V>| set ignorecase?<CR>

Some Ex commands use the command that follows them (separated by |) as part of the command itself. For example, the ":global" (or ":g") command repeats the command that follows it for every matched pattern. In the following command,

:g/foo/s/abc/xyz/g | echo 'Completed substitution'

The ":echo" command is repeated for every 'foo' found in the current buffer. To execute the ":echo" command only once after the ":g" command completes, you have to use the ":exe" command.

:exe 'g/foo/s/abc/xyz/ge' | echo 'Completed substitution'

If your map uses one of these commands like ":g" then you have to use ":exe" in your map command.

Another way to invoke multiple Ex commands from a map is to invoke them separately as shown below:

:nnoremap <F9> :set invignorecase<CR>:set ignorecase?<CR>

Ex commands invoked from a map are not added to the command history. You can't recall the individual commands invoked by a map from the command-line. 
		56.2.7 Using space characters in a map
If you want to use a space character in the {lhs} of a map command, then you have to use <Space> or escape the space character with CTRL-V (need to use two CTRL-Vs). Example:

nnoremap q<Space> M

The above command creates a normal mode map for the key sequence "q" followed by the space character to move the cursor to the middle of the page.

If you want to use the space character at the beginning of the {rhs} of a map command, then use <Space>. In other places in the {rhs}, you can use the space character by pressing the space bar. Example:

inoremap <C-F4> <Space><Space><Space>

The above command creates an insert mode map for the key sequence CTRL-F4 to enter three space characters.

Note that if you inadvertently use a space character at the end of the {rhs} in a map command, then the map may behave differently. For example, the following command maps the backspace character in normal mode to behave like the 'X' command and delete the character before the cursor:

nnoremap <BS> X

If there is a space character after "X" in the above command, then the map will delete the character before the cursor but leave the cursor at the current location instead of moving it back by one position. You can locate these kinds of errors, by looking at the output of the ":map" command. In the ":map" output, the space character at the end of the {rhs} in a map will be shown as "<Space>". 

		56.2.8 Disabling key and mouse events
You can disable key and mouse events by mapping them to the special string "<Nop>". For example, to disable the <F4> key in normal mode, you can use the following command:

:nmap <F4> <Nop>

You can use the mode specific map command to disable a key in a particular mode.

The <Nop> sequence has a special meaning only if it appears by itself in the {rhs} of a map. You cannot use <Nop> with other keys in the {rhs} of a map. For example, the following command will not disable the <F1> key:

:inoremap <F1> <Nop><Nop>

You can disable mouse buttons and mouse events by mapping them to <Nop>. For example to disable the <MiddleMouse> button, you can use the following command:

:imap <MiddleMouse> <Nop>

		56.2.9 Error in mapped key sequences
When executing the key sequences in a key map, if Vim encounters an error, then the map will be aborted and the remaining key sequences will not be executed. You will not see any error message indicating that this has happened. If you have the 'errorbells' or 'visualbell' option set, then you will see the screen flash or hear the audio beep.

For example, consider the following key map that maps <F5> to toggle the case of the first letter of the current word.

nmap <F5> wb~

In most cases the above map will work as desired. But when the cursor is at the last word in the last line of a file, the above map will not work. In the last word of a file, the "w" command will fail and will not move the cursor to the next word. So the remaining part of the map will not be executed.

One way to workaround this problem is to split the command into two parts and execute them using the ":exec" command:

nmap <F5> :exec 'normal w'<Bar>exec 'normal b~'<CR>

		56.2.10 Maps and 'cpoptions' option
The 'cpoptions' Vim option contains many flags that control the compatibility level of Vim with the Vi behavior. To get the current value of the 'cpoptions' option, use the following command:

:set cpoptions?

When Vim is running in Vi-compatible mode, all the possible flags are set in the 'cpoptions' option.

The flags in the 'cpoptions' Vim option affect map definitions and their usage. These flags are described below.

If the flag 'b' is present in 'cpoptions', then a "|" character in a map command is treated as the end of the map command. This means that you cannot use backslash (\) to escape the "|" character in map command definitions.

Example:

:nnoremap <F5> :set invhlsearch \| set hlsearch?<CR>

If the 'b' flag is present in 'cpoptions', then the above map command definition will fail. All the characters after the backslash will not be part of the map.

If the flag 'B' is present in 'cpoptions', then the backslash character is not treated as a special character in map commands. For example, let us say you want to create an insert-mode map for the <F6> key to insert the text "Press <Home> to go to first character". For this, you can try using the following command:

imap <F6> Press <Home> to go to first character

When you press <F6> in the insert mode, the <Home> in the above map will cause Vim to move the cursor to the first character in the line and insert the reminder of the text there. To literally enter the text "<Home>", you need to escape it:

imap <F6> Press \<Home> to go to first character

If the flag 'B' is not present in 'cpoptions', then the above map command will insert the correct text. If the flag 'B' is present, then the backslash character is not treated as a special character and the above map will not insert the correct text. To treat <Home> literally independent of the 'cpoptions' setting, you can use the following command:

imap <F6> Press <lt>Home> to go to first character

In the above command, the notation <lt> is used for "<" in "<Home>".

If the flag 'K' is present in 'cpoptions', then you can cancel the invocation of a map in the middle of the key sequence by pressing <Esc>. For example, let us say you have the following map command:

:nnoremap <F3><F3> :ls<CR>

If the flag 'K' is present, then after entering the first <F3>, you can cancel the map by pressing <Esc>. If the flag 'K' is not present, then if you don't press any key after the first <F3>, Vim will wait for 'timeoutlen' milliseconds before cancelling the map (assuming the 'timeout' option is set).

If the flag 'k' is present in 'cpoptions', then raw key codes are not recognized in map commands. You can enter raw key code in a map command by pressing Ctrl-V followed by a control key. For example, consider the following map command:

nnoremap <press Ctrl-V><press Up arrow> gk

The above command maps the raw key code for the up arrow key to invoke the gk command. If the 'k' flag is not present in 'cpoptions', then the above command will properly work. If the 'k' flag is present in 'cpoptions', then the above map command will not work.

If the flag '<' is present in 'cpoptions', then special keys codes like <Tab>, <C-K>, <F1>, etc. are not recognized in maps. For example, consider the following maps:

:nnoremap <M-Right> <C-W>l
:nnoremap <M-Left> <C-W>h

If the '<' flag is present in 'cpoptions', then the above map commands will not work as the special key codes <M-Right>, <M-Left> and <C-W> will not be recognized. 

		56.2.11 Maps and 'paste' option
While pasting text into a Vim buffer, to disable automatic indentation and interpreting mapped key sequences in the inserted text, you can set the 'paste' option. When the 'paste' option is set, mapped key sequences are ignored. By default, the 'paste' option is disabled. If your mapped keys are not working in a buffer, check whether the 'paste' option is set. 

		56.2.12 Map attributes
You can modify the behavior of a key map by specifying several attributes in the map command. The supported attributes are <buffer>, <silent>, <special>, <script>, <expr>, and <unique>. You can specify one or more of these attributes in a map command immediately after the map command name. 

			56.2.12.1 Buffer-local maps
When you create a map, the mapped key can be used in all the Vim buffers. To create a map that is applicable only to specific buffers, use the <buffer> attribute to the map command. For example,

:setlocal makeprg=gcc\ -o\ %<
:nnoremap <buffer> <F3> :make<CR>

The above command creates a map to compile the file opened in the current buffer. You can add the above set of commands to a filetype plugin. For example, you can add it to the ~/.vim/after/filetype/c.vim. Now, you can compile a C file in the current buffer, by pressing the <F3> key. When you open a Java file, this command will not be available.

When a buffer is deleted, the buffer local mappings for that buffer are removed. When a buffer is unloaded or hidden, you will not lose the mappings.

When you remove a buffer local map, you have to specify the <buffer> attribute to the ":unmap" or ":mapclear" command. Without the <buffer> attribute you cannot remove the map.

To display all the buffer-local mappings for the current buffer, use the following commands:

:map <buffer>
:map! <buffer>

To display the mode specific buffer-local maps, use the map command for that mode in the above command. 

			56.2.12.2 Silent maps
When a map is invoked, the sequence of keys executed is displayed on the screen. If an Ex command is invoked by the map, then you can see the Ex command at the Vim status line. To silently execute a map, use the <silent> attribute for the map. For example,

:nnoremap <silent> <F2> :lchdir %:p:h<CR>:pwd<CR>

The above command maps the <F2> key to change to the directory of the current file and then display the current directory. When you invoke the above command, due to the <silent> attribute, you will not see the commands that are executed.

If the commands invoked by the map display a message, then those messages will be visible even though <silent> attribute is specified for the map command. For example, in the above command, the current directory displayed by the ":pwd" command will be visible. 

			56.2.12.3 Expression maps
For simple maps, the action to be carried out for a key sequence can be defined without using a Vim function. But for complex maps, it is simpler to use a Vim function to implement the action for the map.

You can use the <expr> attribute to a map command to invoke a Vim function and use the returned value as the key sequence to execute.

For example, the following code creates a normal mode map to change to the directory of the current buffer.

function! ChangeToLocalDir()
    lchdir %:p:h
    return ' '
endfunction

nnoremap <expr> _c ChangeToLocalDir()

Note that if the function used with the <expr> attribute returns an empty string, then the map becomes a <Nop> and no action is performed.

The <expr> attribute can be used with all the mode specific map commands. 

			56.2.12.4 Special characters in maps
To use non-printable characters using the <> notation like <F5> in a map command, the '<' flag should not be present in the 'cpoptions' option. For example, the following map command will not work:

:set cpo+=<
:inoremap <F7> <C-X><C-N>

In insert mode, if you press <F7>, instead of executing the map, the characters <F7> will be inserted. To prevent this, you can use the <special> map attribute:

:inoremap <special> <F7> <C-X><C-N>

With the <special> map attribute, independent of the 'cpoptions' option setting, Vim will correctly process the <> key codes in the {rhs} of a map command. 

		56.2.13 Comments

	56.3 Part 3

		56.3.1 Using maps in Vim plugins and scripts
A Vim plugin or script can define new key maps to let the user invoke the commands and functions provided by the plugin. A Vim plugin can also invoke key maps defined by other Vim plugins.

A plugin can choose to map any available key. But to avoid surprising (annoying) the user, it is better not to use the keys that already have pre-defined functionality in Vim.

In a Vim plugin, the ":normal" command is used to execute normal mode commands. For example, the "gqip" normal mode command is used to format a paragraph. To invoke this command from a Vim plugin, the following line can be used:

normal gqip

If any of the keys in "gqip" is mapped, then the mapped key sequence will be executed. This may change the expected behavior of the "gqip" command. To avoid this, add the "!" suffix to the "normal" command:

normal! gqip

With the "!" suffix, the "normal" command executes the built-in functionality provided by Vim for the specified sequence of keys.

To invoke a script local function, defined with the "s:" prefix, from a map, you have to prefix the function name with <SID>. You cannot use the "s:" prefix for the script-local function, as the map will be invoked from outside of the script context.

:inoremap <expr> <C-U> <SID>InsertFunc()

A plugin may map one or more keys to easily invoke the functionality provided by the plugin. In the plugin functions used by these types of maps, it is advisable not to alter user Vim option settings, register contents and marks. Otherwise, the user will be surprised to see that some options are changed after invoking a plugin provided map. 

			56.3.1.1 Map leader
If the key maps provided by all the Vim plugins start with a same key, then it is easier for a user to distinguish between his own key maps and the ones provided by plugins. To facilitate this, Vim provides a special keyword that can be used in a map command.

If the {lhs} key sequence of a map command starts with the string "<Leader>", then Vim replaces it with the key set in the 'mapleader' variable. The default setting for the 'mapleader' variable is backslash ('\'). Note that 'mapleader' is a Vim variable and not a Vim option. The value of this variable can be changed using the 'let' command. For example, to set it to '_' (underscore), you can use the following command in your vimrc file:

let mapleader = "_"

Vim replaces <Leader> with the 'mapleader' value only when defining the map and not when the map is invoked. This means that after several map commands are defined if the 'mapleader' variable is changed, it will not affect the previously defined maps.

For example, consider the following map command defined by a plugin:

nnoremap <Leader>f :call <SID>JumpToFile()<CR>

When defining the above command, Vim replaces <Leader> with the value of the 'mapleader' variable. If the user didn't set the 'mapleader' variable then the above map can be invoked by entering \f. If the user sets the 'mapleader' to a comma (','), then it can be invoked using ,f.

The <Leader> prefix should be used for global mappings (applicable to all buffers) defined by a plugin. For buffer-local mappings, the <LocalLeader> prefix should be used. Vim will replace this with the value set in the 'maplocalleader' variable. The default value for this variable is backslash ('\'). The <LocalLeader> is generally used in mappings defined by a Vim filetype plugin.

The 'mapleader' and 'maplocalleader' variables allow the user to choose different keys as starting keys for global mappings and buffer-local mappings defined by Vim plugins. 

			56.3.1.2 Script maps
If you want to use recursive maps in your map command, but want to use only those keys mapped in your script or plugin, then you can use the <script> attribute in the map definition. For example, consider the following two map commands in a script file:

nnoremap \x /Topic
nmap <script> ,f \x<CR>

In the second map command, ',f' is mapped to invoke \x which is replaced with '/Topic'. If the user or some other plugin has defined a mapping for '\x', then it is not used by ',f'.

If you use the <script> attribute with a ":noremap" command, then the <script> attribute overrides the ":noremap" command. The {rhs} of the map is still scanned for script-local key mappings. But the maps defined outside of the script are not used. 

			56.3.1.3 Unique maps
If you want to make sure that the mapped key is unique and doesn't interfere with other existing mappings, use the <unique> map attribute. This attribute is particularly useful with the maps defined by a Vim plugin. A map definition with the <unique> attribute will fail if the specified key is already mapped.

:nnoremap <unique> \s :set invhlsearch<CR>

The above command will fail, if the user already has a mapping for the "\s" key sequence. 

			56.3.1.4 Use of <Plug>
If you are developing a Vim plugin or script and you want to provide the user with the flexibility of assigning his own key map to invoke a function provided by your script, then you can prefix the map with <Plug>.

For example, let us say a plugin has a function s:VimScriptFn() and the user has to create a map to assign a key to invoke this function. The plugin can provide the following map to simplify this:

noremap <unique> <Plug>ScriptFunc :call <SID>VimScriptFn()<CR>

Note that in the above map command, instead of the typical key sequence for the {lhs} of the map, the <Plug>ScriptFunc text is used. The <Plug> generates a unique key sequence that a user cannot enter from a keyboard. The above map is visible outside of the script where it is defined.

With the above command, the user can assign _p to invoke the script function as shown below:

:nnoremap _p <Plug>ScriptFunc

			56.3.1.5 Map related functions
Vim provides built-in functions to check whether a key sequence is mapped or not and to get the mapped key sequence. 

			56.3.1.6 maparg()
To get the {rhs} of a map command from a script or plugin, use the maparg() function. For example, consider the following commands:

:nnoremap <C-F2> 2<C-G>
:let x = maparg("<C-F2>", "n")
:echo x

The variable 'x' will be set to the mapped key sequence "2<C-G>".

The first argument to the maparg() function specifies the key sequence and the second argument specifies the editing mode. The maparg() function checks whether the specified key sequence is mapped in the specified mode and returns the {rhs} of the map if it is defined. If the mode is not specified, then the maparg() function checks for the map in the normal, visual and operator pending modes.

The maparg() function can be used to chain map commands. For example, let us say you want to define a map for <Tab>. But at the same time you don't want to lose the existing map (if any) for <Tab>. Then you can do the following:

:exe 'nnoremap <Tab> ==' . maparg('<Tab>', 'n')

The above command maps <Tab> to invoke the == command and then invoke the existing map for <Tab> in normal mode. 

			56.3.1.7 mapcheck()
To check whether a map is defined for a key sequence, you can use the mapcheck() function. Example:

:echo mapcheck(';g', 'n')

			56.3.1.8 mode()
In a map command, you can use the mode() Vim function to get the current editing mode. But this function returns 'n' (normal) or 'c (command-line) in most cases. So this function cannot be used reliably from a map command to get the current mode. Instead, you should pass the current mode as an argument to the called function. For example, if you want to use a Vim function Somefunc() in several mode-specific map commands and want to distinguish between the modes in the function, then you can do the following:

:nnoremap _g :call Somefunc('n')<CR>
:inoremap _g <C-O>:call Somefunc('i')<CR>
:vnoremap _g :<C-U>call Somefunc('v')<CR>

			56.3.1.9 hasmapto()
To check whether a map is defined for a particular key sequence, you can use the hasmapto() function. Note that this function checks for the key sequence in the {rhs} of a map. Example:

if !hasmapto(":grep")
    " Define a mapping to invoke the :grep command
endif

The hasmapto() function checks for the specified key sequence anywhere in the {rhs} of a map (not necessarily at the beginning of the map).

The hasmapto() function also accepts an optional {mode} argument which allows you to check whether a map definition exists in a particular mode.

if !hasmapto(":grep", 'n')
    " Define a normal mode map to invoke :grep
endif

		56.3.2 Comments

57. Working with VIM Tabs. Tab pages

	57.1 Basics
:h tabs 


	    57.1.1  open tabs


vim -p fred.php joe.php             : open files in tabs
:tabe fred.php                      : open fred.php in a new tab
:tab ball                           : tab open files
" vim 7 forcing use of tabs from .vimrc
:nnoremap gf <C-W>gf
:cab      e  tabe
:tabdo %s/foo/bar/		    : replace over multiple tabs

CTRL-W gf	Open a new tab page and edit the file name under the cursor.
		See |CTRL-W_gf|.

CTRL-W gF	Open a new tab page and edit the file name under the cursor
		and jump to the line number following the file name.
		See |CTRL-W_gF|.

	    57.1.2 close tabs
:tabc		:close tab page
:tabo		:close all other tab pages

	    57.1.3 navigating tabs
:tabn		:go to next tab can accept count. First tab is 1. tabn1 will go to first tab
gt
{count}gt

:tabp[revious] {count}
:tabN[ext] {count}
{count}<C-PageUp>
{count}gT	Go {count} tab pages back.  Wraps around from the first one
		to the last one.

:tabr[ewind]			*:tabfir* *:tabfirst* *:tabr* *:tabrewind*
:tabfir[st]	Go to the first tab page.

							*:tabl* *:tablast*
:tabl[ast]	Go to the last tab page.

:tabs		List the tab pages and the windows they contain.
		Shows a ">" for the current window.
		Shows a "+" for modified buffers.

	    57.1.4


	57.2 Tabs configuration
map <leader>tn :tabnew %<cr>
map <leader>te :tabedit
map <leader>tc :tabclose<cr>
map <leader>tm :tabmove
try
  set switchbuf=usetab
  set stal=2
catch
endtry


	57.3 Reordering tab pages

:tabm[ove] [N]						*:tabm* *:tabmove*
		Move the current tab page to after tab page N.  Use zero to
		make the current tab page the first one.  Without N the tab
		page is made the last one.

	57.4 LOOPING OVER TAB PAGES:

							*:tabd* *:tabdo*
:tabd[o] {cmd}	Execute {cmd} in each tab page.
		It works like doing this: >
			:tabfirst
			:{cmd}
			:tabnext
			:{cmd}
			etc.
<		This only operates in the current window of each tab page.
		When an error is detected on one tab page, further tab pages
		will not be visited.
		The last tab page (or where an error occurred) becomes the
		current tab page.
		{cmd} can contain '|' to concatenate several commands.
		{cmd} must not open or close tab pages or reorder them.
		{not in Vi} {not available when compiled without the
		|+listcmds| feature}
		Also see |:windo|, |:argdo| and |:bufdo|.


		"
58. Nuts and bolts

	58.1 Change VIM session title
Example:
set titlestring=Yosi_Izaq_KB

More info:
h titlestring

Default title:
:set titlestring=%t%(\ %M%)%(\ (%{expand(\"%:~:.:h\")})%)%(\ %a%)

	
	58.2 File format, unix vs. dos question
Q:
think I have messed up one too many settings in my .vimrc :)
I have noticed lately very strange errors in bash scripts I wrote
under linux.
It took me some time to realize that bash refuses to run my scripts b/
c it sees all kinda dos thingies in there (mainly or maybe only
		carriage returns at end of line).
Strangely the replacement %s/\r//g found 0 matches yet the errors
persisted.
Even stranger, after running dos2unix the errors went away.

I think this has to do with the format shown in the status line, I
have noticed that my old scripts and C sources show format=unix while
my new scripts that don't work show format=dos.
Last, I noticed that after I run dos2unix on a new script (one that
		showed format=dos) that script now shows format=unix.

How can I get to help section re. this?
Are there any insights as to what is going on or what in .vimrc can
lead to that?
Last, how do I fix this so that new files I edit in Linux are set to
unix and not dos format?

A:
For recent version of vim, it is suffice to type
 :set ff=unix
 and save the file to convert from dos to unix format.
 ... and check the 'fileformats' option
 :h 'ffs

	58.3



59. Tutorials

	59.1 Video, Derek Wyatt's videos
http://vimeo.com/user1690209/videos

		59.1.1 Apply (operate) commands to (over) multiple files
load a vim session with all files, like gvim *.h
record a macro that you want to opearate on all files. Remember to make it generic enough to acheive the same end result on all the files!
with recording still on save and move to next file, :wn
Now run the macro on as many file as were left, say 10 so, 10@q  (assuming the default record register q, replace with named register if you used one)

Its also possible to use :argdo 
like:
vim -c "argdo %s/ABC/DEF/ge | update" *.c


		59.1.2

	59.2
60. Advacned regexps (regular expressions)

	60.1 match Some text & more text & (some white space) & ...
Some text & more text & (some white space) & ...
Some text & more text & (some numbers, :, or -) & ...

Some text & more text & (    ) & ...
match with 
^\(\w\+\s*\)\+&\(\s*\w\+\s*\)\+&\s*(\s\+)\s*&

Some text & more text & (1221-3435-12312)  & ...
match with:
^\(\w\+\s*\)\+&\(\s*\w\+\s*\)\+&\s*([[:digit:]:-]\+)\s*&


	60.2
61. vimrc examples

	61.1  My own

		61.1.1  Work Laptop updated Mon Jan 25 18:16:46 JST 2010
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Author	Yosi Izaq
" Cisco R&D
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"set ignorecase -- turns out, I like case sensitivity 
"set list " turns out, I don't like listchars -- show chars on end of line, whitespace, etc
"autocmd GUIEnter * :simalt ~x -- having it auto maximize the screen is annoying
"autocmd BufEnter * :lcd %:p:h -- switch to current dir (breaks some scripts)

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" General
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

"------------------------------------------------------------
" Must have options {{{1
"
" These are highly recommended options.

" One of the most important options to activate. Allows you to switch from an
" unsaved buffer without saving it first. Also allows you to keep an undo
" history for multiple files. Vim will complain if you try to quit without
" saving, and swap files will keep you safe if your computer crashes.
set hidden

" Better command-line completion
set wildmenu

" Show partial commands in the last line of the screen
" set showcmd

" Highlight searches (use <C-L> to temporarily turn off highlighting; see the
" mapping of <C-L> below)
set hlsearch

" Modelines have historically been a source of security vulnerabilities.  As
" such, it may be a good idea to disable them and use the securemodelines
" script, <http://www.vim.org/scripts/script.php?script_id=1876>.
" set nomodeline
"------------------------------------------------------------
"------------------------------------------------------------
" Usability options {{{1
"
" These are options that users frequently set in their .vimrc. Some of them
" change Vim's behaviour in ways which deviate from the true Vi way, but
" which are considered to add usability. Which, if any, of these options to
" use is very much a personal preference, but they are harmless.

" Use case insensitive search, except when using capital letters
set ignorecase
set smartcase

" Allow backspacing over autoindent, line breaks and start of insert action
set backspace=indent,eol,start

" When opening a new line and no filetype-specific indenting is enabled, keep
" the same indent as the line you're currently on. Useful for READMEs, etc.
set autoindent

" Stop certain movements from always going to the first character of a line.
" While this behaviour deviates from that of Vi, it does what most users
" coming from other editors would expect.
"set nostartofline

" Display the cursor position on the last line of the screen or in the status
" line of a window
"set ruler

" Always display the status line, even if only one window is displayed
"set laststatus=2

" Instead of failing a command because of unsaved changes, instead raise a
" dialogue asking if you wish to save changed files.
set confirm

" Use visual bell instead of beeping when doing something wrong
set visualbell

" And reset the terminal code for the visual bell.  If visualbell is set, and
" this line is also included, vim will neither flash nor beep.  If visualbell
" is unset, this does nothing.
set t_vb=

" Enable use of the mouse for all modes
"set mouse=a

" Set the command window height to 2 lines, to avoid many cases of having to
" "press <Enter> to continue"
set cmdheight=2

" Display line numbers on the left
"set number

" Quickly time out on keycodes, but never time out on mappings
set notimeout ttimeout ttimeoutlen=200

" Use <F11> to toggle between 'paste' and 'nopaste'
"set pastetoggle=<F11>
"------------------------------------------------------------

" When started as "evim", evim.vim will already have done these settings.
if v:progname =~? "evim"
  finish
endif

set nocompatible " get out of horrible vi-compatible mode

filetype on " detect the type of file
set history=1000 " How many lines of history to remember
set cf " enable error files and error jumping
set clipboard+=unnamed " turns out I do like is sharing windows clipboard
set ffs=dos,unix,mac " support all three, in this order
filetype plugin on " load filetype plugins
set viminfo+=! " make sure it can save viminfo
set isk+=_,$,@,%,#,- " none of these should be word dividers, so make them not be

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Theme/Colors
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"set background=dark " we are using a dark background
set t_Co=256
"syntax on " syntax highlighting on
" Switch syntax highlighting on, when the terminal has colors
" Also switch on highlighting the last used search pattern.
if &t_Co > 2 || has("gui_running")
  syntax on
  set hlsearch
endif

"colorscheme breeze " my theme
"colorscheme morning " my theme
"colorscheme darkblue " my theme
"colorscheme gothic " my theme
"colorscheme aqua " my theme
"colorscheme earth " my theme
"colorscheme black_angus " my theme
"colorscheme relaxedgreen " my theme
"colorscheme darkblack  " my theme
"colorscheme freya  " my theme
"colorscheme fog  " my theme
"colorscheme motus  " my theme
"colorscheme impact  " my theme
"colorscheme less  " my theme
colorscheme desert256  " my theme

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Files/Backups
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if has("vms")
  set nobackup		" do not keep a backup file, use versions instead
else
  set backup		" keep a backup file
endif
"set backup " make backup file
"set backupdir=$VIM\vimfiles\backup " where to put backup file
"set directory=$VIM\vimfiles\temp " directory is the directory for temp file
set backupdir=~/vim_backup_files/ " where to put backup file
set directory=~/vim_swap_files/ " directory is the directory for temp file
set makeef=error.err " When using make, where should it dump the file
set showcmd		" display incomplete commands

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Vim UI
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set lsp=0 " space it out a little more (easier to read)
set wildmenu " turn on wild menu
set ruler " Always show current positions along the bottom 
set cmdheight=2 " the command bar is 2 high
set number " turn on line numbers
set lz " do not redraw while running macros (much faster) (LazyRedraw)
set hid " you can change buffer without saving
"set backspace=2 " make backspace work normal
" allow backspacing over everything in insert mode
"if has("win32")
"set backspace=indent,eol,start
"endif
""set backspace=indent,eol,start
set whichwrap+=<,>,h,l  " backspace and cursor keys wrap to

"set mouse=a " use mouse everywhere
" In many terminal emulators the mouse works just fine, thus enable it.
if has('mouse')
  set mouse=a
endif

set shortmess=atI " shortens messages to avoid 'press a key' prompt 
set report=0 " tell us when anything is changed via :...
set noerrorbells " don't make noise
" make the splitters between windows be blank
set fillchars=vert:\ ,stl:\ ,stlnc:\ 

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Visual Cues
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set showmatch " show matching brackets
set mat=5 " how many tenths of a second to blink matching brackets for
set nohlsearch " do not highlight searched for phrases
set incsearch " BUT do highlight as you type you search phrase
"set ignorecase "set ic, ignore case in searches
"set hlsearch "highlight searched patterns
set listchars=tab:\|\ ,trail:.,extends:>,precedes:<,eol:$ " what to show when I hit :set list
"set lines=80 " 80 lines tall
"set columns=160 " 160 cols wide
set so=10 " Keep 10 lines (top/bottom) for scope
set novisualbell " don't blink
set noerrorbells " no noises
"Conventional status line:
set statusline=%F%m%r%h%w\ [FORMAT=%{&ff}]\ [TYPE=%Y]\ [ASCII=\%03.3b]\ [HEX=\%02.2B]\ [POS=%04l,%04v][%p%%]\ [LEN=%L]
"
""Detailed stats line, including current function:
"
"function! SyntaxItem()
"  return synIDattr(synID(line("."),col("."),1),"name")
"endfunction
"
"
"if has('statusline')
"  set statusline=%#Question#                   " set highlighting
"  set statusline+=%-2.2n\                      " buffer number
"  set statusline+=%#WarningMsg#                " set highlighting
"  set statusline+=%f\                          " file name
"  set statusline+=%#Question#                  " set highlighting
"  set statusline+=%h%m%r%w\                    " flags
"  set statusline+=%{strlen(&ft)?&ft:'none'},   " file type
"  set statusline+=%{(&fenc==\"\"?&enc:&fenc)}, " encoding
"  set statusline+=%{((exists(\"+bomb\")\ &&\ &bomb)?\"B,\":\"\")} " BOM
"  set statusline+=%{&fileformat},              " file format
"  set statusline+=%{&spelllang},               " language of spelling checker
"  set statusline+=%{SyntaxItem()}              " syntax highlight group under cursor
"  set statusline+=%=                           " ident to the right
"  set statusline+=[LEN=%L]\                    " File length in lines
"  set statusline+=[ASCII=\%03.3b]\	       " ASCII code for character under cursor
"  set statusline+=0x%-8B\                      " character hexadecimal code 
"  set statusline+=%-7.(%l,%c%V%)\ %<%P         " cursor position/offset
"endif
"
""end of 
""Detailed stats line, including current function:

set laststatus=2 " always show the status line

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Text Formatting/Layout
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set fo=tcrqn " See Help (complex)
set ai " autoindent
set si " smartindent 
set cindent " do c-style indenting
set tabstop=8 " tab spacing (settings below are just to unify it)
set softtabstop=8 " unify
set shiftwidth=8 " unify 
set noexpandtab " real tabs please!
"Settings for ACS code conventions no tabs, instead four spaces.
"set tabstop=4
"set expandtab
"set nowrap " do not wrap lines  
set smarttab " use tabs at the start of a line, spaces elsewhere

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Folding
"    Enable folding, but by default make it act like folding is off, because folding is annoying in anything but a few rare cases
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set foldenable " Turn on folding
set foldmethod=indent " Make folding indent sensitive
set foldlevel=100 " Don't autofold anything (but I can still fold manually)
set foldopen-=search " don't open folds when you search into them
set foldopen-=undo " don't open folds when you undo stuff

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" File Explorer
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let g:explVertical=1 " should I split verticially
let g:explWinSize=35 " width of 35 pixels

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Win Manager
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let g:winManagerWidth=35 " How wide should it be( pixels)
let g:winManagerWindowLayout = 'FileExplorer,TagsExplorer|BufExplorer' " What windows should it

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" CTags
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" only set Tlist_Ctags_Cmd if its not in path. 
"let Tlist_Ctags_Cmd = '/usr/local/bin/'.'\ctags.exe' " Location of ctags
let Tlist_Sort_Type = "name" " order by 
let Tlist_Use_Right_Window = 1 " split to the right side of the screen
let Tlist_Compart_Format = 1 " show small meny
let Tlist_Exist_OnlyWindow = 1 " if you are the last, kill yourself
let Tlist_File_Fold_Auto_Close = 0 " Do not close tags for other files
let Tlist_Enable_Fold_Column = 0 " Do not show folding tree

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Minibuf
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let g:miniBufExplTabWrap = 1 " make tabs show complete (no broken on two lines)
let g:miniBufExplModSelTarget = 1

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Matchit
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let b:match_ignorecase = 1

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Perl
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let perl_extended_vars=1 " highlight advanced perl vars inside strings

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Custom Functions
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Select range, then hit :SuperRetab($width) - by p0g and FallingCow
function! SuperRetab(width) range
	silent! exe a:firstline . ',' . a:lastline . 's/\v%(^ *)@<= {'. a:width .'}/\t/g'
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Mappings, maps, my maps
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"map <right> <ESC>:MBEbn<RETURN> " right arrow (normal mode) switches buffers  (excluding minibuf)
"map <left> <ESC>:MBEbp<RETURN> " left arrow (normal mode) switches buffers (excluding minibuf) 
"map <up> <ESC>:Sex<RETURN><ESC><C-W><C-W> " up arrow (normal mode) brings up a file list
"map <down> <ESC>:Tlist<RETURN> " down arrow  (normal mode) brings up the tag list
"map <A-i> i <ESC>r " alt-i (normal mode) inserts a single char, and then switches back to normal
"map <F2> <ESC>ggVG:call SuperRetab()<left>
"map <F12> ggVGg? " encypt the file (toggle)

"Send output of the last g/patter/ search to a new window
nmap <F3> :redir @a<CR>:g//<CR>:redir END<CR>:new<CR>:put! a<CR><CR>

"Map F5 to add new entry to TOC based on following logic, take the previous entry and add 1 to the last digit
map <F5> ?^\s*\(\d\+\.\)\+\d*<CR>0y/\d\+\.\?\zs\s<CR>``o<ESC>p0E<C-A>a<ESC>
"Map F6 to add new entry to TOC based on following logic, take the previous entry and add .1 after the last digit
"map <F6> ?^\s*\(\d\+\.\)\+\d*<CR>0y/\d\+\.\?\zs\s<CR>``o    <ESC>p0Ea.1 
map <F6> <ESC>ms?^\s*\(\d\+\.\)\+\d*<CR>Y<CR>`so<ESC>PI<TAB><ESC>Ea.1<ESC>WDo<ESC>

"Map ctrl-s+d to add [done] to end of line, this usefull for filling done status for
" p -> pending, o -> open, w - work in progress
map <C-s><C-d> A [Done]<esc>
map <C-s><C-p> A [Pending]<esc>
map <C-s><C-o> A [Open]<esc>
map <C-s><C-w> A [Work In Progress]<esc>

"Maps for quoting a visuall selected text with ',", (), [] and {} 
vnoremap qq <Esc>`>a'<Esc>`<i'<Esc>
vnoremap q" <Esc>`>a"<Esc>`<i"<Esc>
vnoremap q( <Esc>`>a)<Esc>`<i(<Esc>
vnoremap q[ <Esc>`>a]<Esc>`<i[<Esc>
vnoremap q{ <Esc>`>a}<Esc>`<i{<Esc>

"Maps for getting current time. t? in normal mode and ctrl+t in insert mode
map t? :echo 'Current time is ' . strftime('%c')<CR>
map! <C-t><C-t>		<C-R>=strftime('%c')<CR><Esc>
" The following command maps ctrl+d to insert the directory name of the current buffer:
inoremap <C-d> <C-R>=expand('%:p:h')<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Autocommands
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
autocmd BufEnter * :syntax sync fromstart " ensure every file does syntax highlighting (full)
au BufNewFile,BufRead *.asp :set ft=aspjscript " all my .asp files ARE jscript
au BufNewFile,BufRead *.tpl :set ft=html " all my .tpl files ARE html
au BufNewFile,BufRead *.hta :set ft=html " all my .tpl files ARE html

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Useful abbrevs
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
iab xasp <%@language=jscript%><CR><%<CR><TAB><CR><BS>%><ESC><<O<TAB>
iab xdate <c-r>=strftime("%d/%m/%y %H:%M:%S")<cr> 

"csuppot plugin.
let g:C_AuthorName      = 'Yosi Izaq'    
let g:C_AuthorRef       = 'Y.I.'                         
let g:C_Email           = 'yizaq@cisco.com, izaqyos@gmail.com'                    
let g:C_Company         = 'Cisco, NMTG'     
let g:C_Template_Directory  =  $HOME."/.vim/plugin/templates/"

"Python support
"au FileType python /cygdrive/d/Documents\ and\ Settings/yytzhak/.vim/plugin/python.vim 
au FileType python $HOME."plugin/python.vim"

"perl support plugin
let g:Perl_AuthorName      = 'Yosi Izaq'     
let g:Perl_AuthorRef       = 'YI'                         
let g:Perl_Email           = 'yytzhak@cisco.com'            
let g:Perl_Company         = 'Cisco, NMTG'    

"Latex suite plugin
" REQUIRED. This makes vim invoke latex-suite when you open a tex file.
filetype plugin on

" IMPORTANT: win32 users will need to have 'shellslash' set so that latex
" can be called correctly.
set shellslash

" IMPORTANT: grep will sometimes skip displaying the file name if you
" search in a singe file. This will confuse latex-suite. Set your grep
" program to alway generate a file-name.
set grepprg=grep\ -nH\ $*

" OPTIONAL: This enables automatic indentation as you type.
filetype indent on

" For recording
:nnoremap <space> @q

" Auto save and load working session
" function! MakeSession()
"     let b:sessiondir = $HOME . "/.vim/sessions" . getcwd()
"     if (filewritable(b:sessiondir) != 2)
"         exe 'silent !mkdir -p ' b:sessiondir
"         redraw!
"     endif
"     let b:filename = b:sessiondir . '/session.vim'
"     exe "mksession! " . b:filename
" endfunction
" 
" function! LoadSession()
"     let b:sessiondir  = $HOME . "/.vim/sessions" . getcwd()
"     let b:sessionfile = b:sessiondir . "/session.vim"
"     if (filereadable(b:sessionfile))
"         exe 'source ' b:sessionfile
"     else
"         echo "No session loaded."
"     endif
" endfunction
" 
" au VimEnter * :call LoadSession()
" au VimLeave * :call MakeSession()
"

" For cppomnicomplete
"set nocp
"filetype plugin on
"map <C-F12> :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q
" settings based on tip 1608
" configure tags - add additional tags here or comment out not-used ones
set tags+=~/.vim/tags/cpp/tags
set tags+=~/.vim/tags/acs_5_1/tags
" build tags of your own project with CTRL+F12
map <C-F12> :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .<CR>

" OmniCppComplete
let OmniCpp_NamespaceSearch = 1
let OmniCpp_GlobalScopeSearch = 1
let OmniCpp_ShowAccess = 1
let OmniCpp_MayCompleteDot = 1
let OmniCpp_MayCompleteArrow = 1
let OmniCpp_MayCompleteScope = 1
let OmniCpp_DefaultNamespaces = ["std", "_GLIBCXX_STD"]
" automatically open and close the popup menu / preview window
au CursorMovedI,InsertLeave * if pumvisible() == 0|silent! pclose|endif
set completeopt=menuone,menu,longest,preview

" To view word docs with vim, uses antiword
autocmd BufReadPre *.doc set ro
autocmd BufReadPre *.doc set hlsearch!
autocmd BufReadPost *.doc %!antiword "%"

" To view and diff PDF files using xpdf
autocmd BufReadPre *.pdf set ro
autocmd BufReadPost *.pdf %!pdftotext -nopgbrk "%" -

" grep mappings
map <leader>n :cn<cr>
map <leader>p :cp<cr>
map <leader>c :botright cw 10<cr>

"text.vim plugin
au BufRead,BufNewFile *  setfiletype txt

" XMLFolding plugin
au BufNewFile,BufRead *.xml,*.htm,*.html so XMLFolding

"Compile and build command for systems that use maven
"set makeprg=mvnc\ %<
"
"Compile and build command for systems that use GNU make
set makeprg=makec\ %<

"for dbext
let g:dbext_default_profile_usual = 'type=SYBASE:user=DBA:passwd=sql'


" My personal menu
amenu MyMenu.HighlighCtxt       :match ToDo /^\s\+-\+>.*$/<cr>
amenu MyMenu.KBEntries          :match StatusLine /^\s*\d\+\..*$/<cr>
amenu MyMenu.-SEP-      :   
amenu MyMenu.ArchiveBuffers     :silent bufdo !tar -rvf ~/temp/vim_archive.tar %:p<cr>
amenu MyMenu.-SEP-      :   
amenu MyMenu.highlight          :set cursorline<cr>
amenu MyMenu.highlightV         :set cursorcolumn<cr>
amenu MyMenu.-SEP-      :   
vmenu MyMenu.makeArrowList              :call ArrowList()<cr>
vmenu MyMenu.makeNumberList             :call NumberList()<cr>
amenu MyMenu.-SEP-      :   
amenu MyMenu.InsertFileLink             :s/^.*$/&\r<URL:[File Path]><cr>
amenu MyMenu.InsertLocalLink            :s/^.*$/&\r<URL:#tn=[pattern in file]><cr>
amenu MyMenu.-SEP-      :   
amenu MyMenu.ArchiveModifiedBuffers            :call Archive_all_modified_buffers()<cr>

" My ACS 5, linux develoment environment clearcase menu
amenu MyCCMenu.checkout       :! co % <cr>
amenu MyCCMenu.checkin       :! ci % <cr>
amenu MyCCMenu.-SEP-      :   
amenu MyCCMenu.version_tree       :! ct lsvtree -g % <cr>
amenu MyCCMenu.diff_pred       :! ct diff -pred -graph % <cr>
amenu MyCCMenu.-SEP-      :   
amenu MyCCMenu.checkin_all       :call CheckIn_all__buffers()<cr>
amenu MyCCMenu.manually_set_tags_for_auto_complete       :set tags+=~/.vim/tags/acs_5_1/tags<cr>:set tags+=~/.vim/tags/cpp/tags<cr>

"Custom functions
function! Archive_all_modified_buffers()
    set hidden
    let archive=[]
    bufdo if &modified |  call add(archive, shellescape(expand("%"),1))| endif
    
    if len(archive) > 0
       exe "!tar -cvjf archive.tar.bz2 " . join(archive, " ")
    endif
endfunction

function! Perform_Shell_Test_all__buffers()
bufdo exe "!test -f " . expand("%") ."  > /dev/null"
    \ | if !v:shell_error
    \ | echo "passed"
    \ | endif
endfunction

function! CheckIn_all__buffers()
bufdo exe "!ct ls  " . expand("%") ." | grep -i checkedout > /dev/null"
    \ | if !v:shell_error
    \ | echo "file is checked out"
    \ | exe "!ci " . expand("%")
    \ | endif
endfunction

if has("win32")
	set dictionary-=c:\work\dictionary\brit-a-z.txt dictionary+=c:\work\dictionary\brit-a-z.txt 
else
	set dictionary-=/cygdrive/c/work/dictionary/brit-a-z.txt dictionary+=/cygdrive/c/work/dictionary/brit-a-z.txt
endif
set complete-=k complete+=k

if has("win32unix") "Tip will only take effect on cygwin
set complete=.,w,b,u,k
elseif  has("win32") 
set complete=.,w,b,u,k
else "Unix, where my source code is
set complete=.,w,b,u,k,i,]
endif

set viewdir=$HOME/.vim/views

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Creating lists
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! ArrowList()
        let lineno = line(".")
        call setline(lineno, "    -> " . getline(lineno))
endfunction

function! NumberList() range
        "Set line numbers in front of lines
        let begining=line("'<")
        let ending=line("'>")
        let difsize = ending -begining +1
        let pre = ' ' 
        while (begining <= ending)
                if match(difsize, '^9*$') == 0
                        let pre = pre . ' ' 
                endif
                call setline(ending, pre . difsize . "\t" . getline(ending))
                let ending = ending-1
                let difsize = difsize-1
        endwhile
endfunction

""" VIM commander map
noremap <silent> <F11> :cal VimCommanderToggle()<CR>
let b:vimcommander_install_doc=0

""" C support turn off annoying messages
let s:C_TemplateOverwrittenMsg='no'

"Functions
"" Commenting of #endifs etc
"" Author: Ben Schmidt, minor modifications by A. S. Budden.
"command SmartPreProcCommenter call SmartPreProcCommenter()
"
"function! SmartPreProcCommenter()
"  mark y
"  let saved_wrapscan=&wrapscan
"  set nowrapscan
"  let elsecomment=""
"  let endcomment=""
"  try
"    " Find the last #if in the buffer
"    $?^\s*#if
"    while 1
"      " Build the comments for later use, based on current line
"      let content=getline('.')
"      let elsecomment=BuildElseComment(content,elsecomment)
"      let endcomment=BuildEndComment(content,endcomment)
"      " Change # into ## so we know we've already processed this one
"      " and don't find it again
"      s/^\s*\zs#/##
"      " Find the next #else, #elif, #endif which must belong to this #if
"      /^\s*#\(elif\|else\|endif\)
"      let content=getline('.')
"      if match(content,'^\s*#elif') != -1
"        " For #elif, treat the same as #if, i.e. build new comments
"        continue
"      elseif match(content,'^\s*#else') != -1
"        " For #else, add/replace the comment
"        call setline('.',ReplaceComment(content,elsecomment))
"        s/^\s*\zs#/##
"        " Find the #endif
"        /^\s*#endif
"      endif
"      " We should be at the #endif now; add/replace the comment
"      call setline('.',ReplaceComment(getline('.'),endcomment))
"      s/^\s*\zs#/##
"      " Find the previous #if
"      ?^\s*#if
"    endwhile
"  catch /search hit TOP/
"    " Once we have an error (pattern not found, i.e. no more left)
"    " Change all our ## markers back to #
"    silent! %s/^\s*\zs##/#
"  endtry
"  let &wrapscan=saved_wrapscan
"  normal `y
"endfunc
"
"let s:PreProcCommentMatcher = '#\a\+\s\+\zs.\{-}\ze\(\s*\/\*.\{-}\*\/\)\?\s*$'
"
"function! BuildElseComment(content,previous)
"  let expression=escape(matchstr(a:content,s:PreProcCommentMatcher), '\~&')
"  if match(a:content,'#ifdef') != -1
"    return "/* NOT def ".expression." */"
"  elseif match(a:content,'#ifndef') != -1
"    return "/* def ".expression." */"
"  elseif match(a:content,'#if') != -1
"    return "/* NOT ".expression." */"
"  elseif match(a:content,'#elif') != -1
"    return substitute(a:previous,' \*/',', '.expression.' */','')
"  else
"    return ""
"  endif
"endfunc
"
"function! BuildEndComment(content,previous)
"  let expression=escape(matchstr(a:content,s:PreProcCommentMatcher), '\~&')
"  if match(a:content,'#ifdef') != -1
"    return "/* def ".expression." */"
"  elseif match(a:content,'#ifndef') != -1
"    return "/* NOT def ".expression." */"
"  elseif match(a:content,'#if') != -1
"    return "/* ".expression." */"
"  elseif match(a:content,'#elif') != -1
"    return substitute(a:previous,' \*/',', '.expression.' */','')
"  else
"    return ""
"  endif
"endfunc
"
"function! ReplaceComment(content,comment)
"  let existing=escape(matchstr(a:content,'#\a\+\s\+\zs.\{-}\s*$'), '\~&')
"  if existing == ""
"    return substitute(a:content,'^\s*#\a\+\zs.*'," ".a:comment,'')
"  elseif existing != a:comment && match(existing,'XXX') == -1
"    return a:content." /* XXX */"
"  else
"    return a:content
"  endif
"endfunc
"
"

"Cscope auto mapping
nmap <F12> :!find . -iname '*.c' -o -iname '*.cpp' -o -iname '*.h' -o -iname '*.hpp' > cscope.files ;
  \ cs kill -1<CR>:cs add cscope.out<CR>

"Cscope qury results go to quickfix
if has('cscope')
" In case cscope.out is in home dir
 "if filereadable(expand("$HOME/cscope.out"))
" In case cscope.out is in dir from which VIM is opned
 if filereadable(expand("cscope.out"))
   cs kill -1
   cs add ~/cscope.out
 endif
 set cscopeverbose
 set cscopequickfix=s-,c-,d-,i-,t-,e-,g-
endif

set tags+=tags,~/tags,~/stl-tags

"switch back to normal mode automatically after inaction
"au! CursorHoldI * stopinsert

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Source explorer http://www.vim.org/scripts/script.php?script_id=2179 
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" // The switch of the Source Explorer
nmap <F8> :SrcExplToggle<CR>

" // Set the window height of Source Explorer
  let g:SrcExpl_winHeight = 8

" // Set 100 ms for refreshing the Source Explorer
let g:SrcExpl_refreshTime = 100

" // Let the Source Explorer update the tags file when opening
let g:SrcExpl_updateTags = 1

" // Set "Enter" key to jump into the exact definition context
let g:SrcExpl_jumpKey = "<ENTER>"

" // Set "Space" key for back from the definition context
let g:SrcExpl_gobackKey = "<SPACE>"

" // In order to Avoid conflicts, the Source Explorer should know what plugins
" // are using buffers. And you need add their bufname into the list below
" // according to the command ":buffers!"
let g:SrcExpl_pluginList = [
          \ "__Tag_List__",
          \ "_NERD_tree_",
          \ "Source_Explorer"
      \ ]

" // Enable or disable local definition searching, and note that this is not
" // guaranteed to work, the Source Explorer does not check the syntax for now,
" // it only searches for a match with the keyword according to command 'gd'.
let g:SrcExpl_searchLocalDef = 1 

"Use python math module as calculator
command! -nargs=+ Calc :!python -c "from math import *; print <args>"


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" TIPS Section
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Edit another file in the same directory as the current file 
" type %/ in command prompt (:) and it will be expanded to path of current
" open buffer
if has("unix")
  cmap %/ <C-R>=expand("%:p:h") . '/'<CR>
else
  cmap %/ <C-R>=expand("%:p:h") . '\'<CR>
endif
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Improved Hex editing, Tip 1518 created October 3, 2007 · author Fritzophrenic 
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
nnoremap <LEADER>hx :Hexmode<CR>
inoremap <LEADER>hx <Esc>:Hexmode<CR>
vnoremap <LEADER>hx :<C-U>Hexmode<CR>

" ex command for toggling hex mode - define mapping if desired
command -bar Hexmode call ToggleHex()

" helper function to toggle hex mode
function ToggleHex()
  " hex mode should be considered a read-only operation
  " save values for modified and read-only for restoration later,
  " and clear the read-only flag for now
  let l:modified=&mod
  let l:oldreadonly=&readonly
  let &readonly=0
  let l:oldmodifiable=&modifiable
  let &modifiable=1
  if !exists("b:editHex") || !b:editHex
    " save old options
    let b:oldft=&ft
    let b:oldbin=&bin
    " set new options
    setlocal binary " make sure it overrides any textwidth, etc.
    let &ft="xxd"
    " set status
    let b:editHex=1
    " switch to hex editor
    %!xxd
  else
    " restore old options
    let &ft=b:oldft
    if !b:oldbin
      setlocal nobinary
    endif
    " set status
    let b:editHex=0
    " return to normal editing
    %!xxd -r
  endif
  " restore values for modified and read only state
  let &mod=l:modified
  let &readonly=l:oldreadonly
  let &modifiable=l:oldmodifiable
endfunction
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Easily switch between two styles of color scheme Tip 955 and 341
" The setcolors.vim should be put in plugin/ dir and then its auto loaded. The
" manually load it uncomment the next line:
":source setcolors.vim

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Frequently when I go to save with :w I am flying to fast and I type :W
" which gives me an obvious error.
"
" How can I map :W to :w ???
" How can I map :Q to :q ???
"
" I know there is :ZZ but I like the :w more.
"
:command! -bang W w<bang>
:command! -bang Q q<bang>
:command! -bang Wa wa<bang>
:command! -bang Qa qa<bang>
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" often make the mistake of typing w1 instead of w!.
" Can you please suggest how to map w1 to w!?
if version<  700
        cnoreabbrev w1 w!
else
        cnoreabbrev  <expr>  w1  ((getcmdtype() == ':'  &&  getcmdpos()  <= 2)?   'w!' : 'w1')
endif
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" How can I detect my current platform in Vim? I share my configuration across platforms, and I need to set the font selectively
" Well, the key here is the has() function.
"For a quick and dirty test, use
"
"       if has('unix')
"               " unix-like platform (including Cygwin)
"       else
"               " probably Windows
"       endif
"
"For the 'guifont' option, however, you need to take care of the five
"different incompatible formats used by various versions of Vim:
    if has('gui')
        " we use has('gui') rather than has('gui_running') here
        " so it will work even if we start Console Vim first
        " then run :gui manually (which is only possible on Unix)
        if has('gui_gtk2')
            "set gfn=DejaVu\ Sans\ Mono\ 11
            "set gfn=Courier_New:h11:cDEFAULT
            set gfn=Courier_New:b:h12:cDEFAULT
        elseif has('gui_photon')
            set gfn=DejaVu\ Sans\ Mono:s11
        elseif has('gui_kde')
            " the obsolete kvim
            " just make sure it works correctly if it hits our vimrc
            set gfn=DejaVu\ Sans\ Mono/11/-1/5/50/0/0/0/1/0
        elseif has('x11')
            " I'm guessing the following (other-X11 including GTK1)
            " please check, and correct if necessary.
            " On GTK1 (and maybe some others) you can use :set gfn=*
            " Replace by asterisks like here
            " to make it a little more general:
            set gfn=-*-dejavu-medium-r-normal-*-*-110-*-*-m-*-*
            " add another elseif here
            " if you want DejaVu on mac-without-x11
       else
            " not x11 (probably Windows)
            set gfn=Courier_New:b:h12:cDEFAULT
        endif
    endif
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" VIM and BASH compatability
" Tell VIM to run shell in interactive mode thus allowing for aliases to be
" loaded
"set shellcmdflag=-ic
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" For UTL 3.x 
"--- Suggested mappings for most frequent commands  [id=suggested_mappings] [
"
nmap <unique> <Leader>ge :Utl openLink underCursor edit<CR>
nmap <unique> <Leader>gu :Utl openLink underCursor edit<CR>
nmap <unique> <Leader>gE :Utl openLink underCursor split<CR>
nmap <unique> <Leader>gS :Utl openLink underCursor vsplit<CR>
nmap <unique> <Leader>gt :Utl openLink underCursor tabedit<CR>
nmap <unique> <Leader>gv :Utl openLink underCursor view<CR>
nmap <unique> <Leader>gr :Utl openLink underCursor read<CR>

vmap <unique> <Leader>ge "*y:Utl openLink visual edit<CR>
vmap <unique> <Leader>gu "*y:Utl openLink visual edit<CR>
vmap <unique> <Leader>gE "*y:Utl openLink visual split<CR>
vmap <unique> <Leader>gS "*y:Utl openLink visual vsplit<CR>
vmap <unique> <Leader>gt "*y:Utl openLink visual tabedit<CR>
vmap <unique> <Leader>gv "*y:Utl openLink visual view<CR>
vmap <unique> <Leader>gr "*y:Utl openLink visual read<CR>


nmap <unique> <Leader>cfn :Utl copyFileName underCursor native<CR>
nmap <unique> <Leader>cfs :Utl copyFileName underCursor slash<CR>
nmap <unique> <Leader>cfb :Utl copyFileName underCursor backSlash<CR>

vmap <unique> <Leader>cfn "*y:Utl copyFileName visual native<CR>
vmap <unique> <Leader>cfs "*y:Utl copyFileName visual slash<CR>
vmap <unique> <Leader>cfb "*y:Utl copyFileName visual backSlash<CR>


nmap <unique> <Leader>cl :Utl copyLink underCursor<CR>

vmap <unique> <Leader>cl "*y:Utl copyLink visual<CR>

"]
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Enter Tip
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Enter Tip
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Enter Tip
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Enter Tip
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


" Only do this part when compiled with support for autocommands.
if has("autocmd")

  " Enable file type detection.
  " Use the default filetype settings, so that mail gets 'tw' set to 72,
  " 'cindent' is on in C files, etc.
  " Also load indent files, to automatically do language-dependent indenting.
  filetype plugin indent on

  " Put these in an autocmd group, so that we can delete them easily.
  augroup vimrcEx
  au!

  " For all text files set 'textwidth' to 78 characters.
  autocmd FileType text setlocal textwidth=78

  " When editing a file, always jump to the last known cursor position.
  " Don't do it when the position is invalid or when inside an event handler
  " (happens when dropping a file on gvim).
  " Also don't do it when the mark is in the first line, that is the default
  " position when opening a file.
  autocmd BufReadPost *
    \ if line("'\"") > 1 && line("'\"") <= line("$") |
    \   exe "normal! g`\"" |
    \ endif

  augroup END

else
  set autoindent		" always set autoindenting on
endif " has("autocmd")

" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
" Only define it when not defined already.

if !exists(":DiffOrig")
  command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
		  \ | wincmd p | diffthis
endif

" Tip 1623 Previous Next created April 10, 2009 · complexity basic · author Ir0nh34d · version 7.0 
" Using the Windows clipboard in Cygwin Vim
if has("win32unix") "Tip will only take effect on cygwin
function! Putclip(type, ...) range
  let sel_save = &selection
  let &selection = "inclusive"
  let reg_save = @@
  if a:type == 'n'
    silent exe a:firstline . "," . a:lastline . "y"
  elseif a:type == 'c'
    silent exe a:1 . "," . a:2 . "y"
  else
    silent exe "normal! `<" . a:type . "`>y"
  endif
  call system('putclip', @@)
  let &selection = sel_save
  let @@ = reg_save
endfunction

vnoremap <silent> <leader>y :call Putclip(visualmode(), 1)<CR>
nnoremap <silent> <leader>y :call Putclip('n', 1)<CR>

com! -nargs=0 -range=% Putclip call Putclip('c', <line1>, <line2>)

function! Getclip()
  let reg_save = @@
  let @@ = system('getclip')
  setlocal paste
  exe 'normal p'
  setlocal nopaste
  let @@ = reg_save
endfunction

nnoremap <silent> <leader>p :call Getclip()<CR>
endif "if has("win32unix")

" End Tip 1623

" bye bye message
 au VimLeave * :call PrintAtExit()
   function! PrintAtExit()
       echo "Hope you had a good VIM session :) "
   endfun

		61.1.2 Linux development enviorment update: Mon Jan 25 18:16:18 JST 2010
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Author	Yosi Izaq
" Cisco R&D
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"set ignorecase -- turns out, I like case sensitivity 
"set list " turns out, I don't like listchars -- show chars on end of line, whitespace, etc
"autocmd GUIEnter * :simalt ~x -- having it auto maximize the screen is annoying
"autocmd BufEnter * :lcd %:p:h -- switch to current dir (breaks some scripts)

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" General
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"------------------------------------------------------------
" Must have options {{{1
"
" These are highly recommended options.

" One of the most important options to activate. Allows you to switch from an
" unsaved buffer without saving it first. Also allows you to keep an undo
" history for multiple files. Vim will complain if you try to quit without
" saving, and swap files will keep you safe if your computer crashes.
set hidden

" Better command-line completion
set wildmenu

" Show partial commands in the last line of the screen
" set showcmd

" Highlight searches (use <C-L> to temporarily turn off highlighting; see the
" mapping of <C-L> below)
set hlsearch

" Modelines have historically been a source of security vulnerabilities.  As
" such, it may be a good idea to disable them and use the securemodelines
" script, <http://www.vim.org/scripts/script.php?script_id=1876>.
" set nomodeline
"------------------------------------------------------------
"------------------------------------------------------------
" Usability options {{{1
"
" These are options that users frequently set in their .vimrc. Some of them
" change Vim's behaviour in ways which deviate from the true Vi way, but
" which are considered to add usability. Which, if any, of these options to
" use is very much a personal preference, but they are harmless.

" Use case insensitive search, except when using capital letters
set ignorecase
set smartcase

" Allow backspacing over autoindent, line breaks and start of insert action
set backspace=indent,eol,start

" When opening a new line and no filetype-specific indenting is enabled, keep
" the same indent as the line you're currently on. Useful for READMEs, etc.
set autoindent

" Stop certain movements from always going to the first character of a line.
" While this behaviour deviates from that of Vi, it does what most users
" coming from other editors would expect.
"set nostartofline

" Display the cursor position on the last line of the screen or in the status
" line of a window
"set ruler

" Always display the status line, even if only one window is displayed
"set laststatus=2

" Instead of failing a command because of unsaved changes, instead raise a
" dialogue asking if you wish to save changed files.
set confirm

" Use visual bell instead of beeping when doing something wrong
set visualbell

" And reset the terminal code for the visual bell.  If visualbell is set, and
" this line is also included, vim will neither flash nor beep.  If visualbell
" is unset, this does nothing.
set t_vb=

" Enable use of the mouse for all modes
"set mouse=a

" Set the command window height to 2 lines, to avoid many cases of having to
" "press <Enter> to continue"
set cmdheight=2

" Display line numbers on the left
"set number

" Quickly time out on keycodes, but never time out on mappings
set notimeout ttimeout ttimeoutlen=200

" Use <F11> to toggle between 'paste' and 'nopaste'
"set pastetoggle=<F11>
"------------------------------------------------------------

" When started as "evim", evim.vim will already have done these settings.
if v:progname =~? "evim"
  finish
endif

set nocompatible " get out of horrible vi-compatible mode

filetype on " detect the type of file
set history=1000 " How many lines of history to remember
set cf " enable error files and error jumping
set clipboard+=unnamed " turns out I do like is sharing windows clipboard
set ffs=dos,unix,mac " support all three, in this order
filetype plugin on " load filetype plugins
set viminfo+=! " make sure it can save viminfo
set isk+=_,$,@,%,#,- " none of these should be word dividers, so make them not be

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Theme/Colors
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"set background=dark " we are using a dark background
set t_Co=256
"syntax on " syntax highlighting on
" Switch syntax highlighting on, when the terminal has colors
" Also switch on highlighting the last used search pattern.
if &t_Co > 2 || has("gui_running")
  syntax on
  set hlsearch
endif

"colorscheme breeze " my theme
"colorscheme morning " my theme
"colorscheme darkblue " my theme
"colorscheme gothic " my theme
"colorscheme aqua " my theme
"colorscheme earth " my theme
"colorscheme black_angus " my theme
"colorscheme relaxedgreen " my theme
"colorscheme darkblack  " my theme
"colorscheme freya  " my theme
"colorscheme fog  " my theme
"colorscheme motus  " my theme
"colorscheme impact  " my theme
"colorscheme less  " my theme
colorscheme desert256  " my theme

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Files/Backups
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if has("vms")
  set nobackup		" do not keep a backup file, use versions instead
else
  set backup		" keep a backup file
endif
"set backup " make backup file
"set backupdir=$VIM\vimfiles\backup " where to put backup file
"set backupdir=/tmp/vimbackup " where to put backup file
"set directory=$VIM\vimfiles\temp " directory is the directory for temp file
set backupdir=~/vim_backup_files/ " where to put backup file
set directory=~/vim_swap_files/ " directory is the directory for temp file
"set directory=/tmp/vimtemp " directory is the directory for temp file
set makeef=error.err " When using make, where should it dump the file
set showcmd		" display incomplete commands

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Vim UI
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set lsp=0 " space it out a little more (easier to read)
set wildmenu " turn on wild menu
set ruler " Always show current positions along the bottom 
set cmdheight=2 " the command bar is 2 high
set number " turn on line numbers
set lz " do not redraw while running macros (much faster) (LazyRedraw)
set hid " you can change buffer without saving
"set backspace=2 " make backspace work normal
" allow backspacing over everything in insert mode
set backspace=indent,eol,start
set whichwrap+=<,>,h,l  " backspace and cursor keys wrap to

"set mouse=a " use mouse everywhere
" In many terminal emulators the mouse works just fine, thus enable it.
if has('mouse')
  set mouse=a
endif

set shortmess=atI " shortens messages to avoid 'press a key' prompt 
set report=0 " tell us when anything is changed via :...
set noerrorbells " don't make noise
" make the splitters between windows be blank
set fillchars=vert:\ ,stl:\ ,stlnc:\ 

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Visual Cues
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set showmatch " show matching brackets
set mat=5 " how many tenths of a second to blink matching brackets for
set nohlsearch " do not highlight searched for phrases
set incsearch " BUT do highlight as you type you search phrase
set ignorecase "set ic, ignore case in searches
"set hlsearch "highlight searched patterns
set listchars=tab:\|\ ,trail:.,extends:>,precedes:<,eol:$ " what to show when I hit :set list
"set lines=80 " 80 lines tall
"set columns=160 " 160 cols wide
set so=10 " Keep 10 lines (top/bottom) for scope
set novisualbell " don't blink
set noerrorbells " no noises
"Conventional status line:
set statusline=%F%m%r%h%w\ [FORMAT=%{&ff}]\ [TYPE=%Y]\ [ASCII=\%03.3b]\ [HEX=\%02.2B]\ [POS=%04l,%04v][%p%%]\ [LEN=%L]
"
""Detailed stats line, including current function:
"
"function! SyntaxItem()
"  return synIDattr(synID(line("."),col("."),1),"name")
"endfunction
"
"
"if has('statusline')
"  set statusline=%#Question#                   " set highlighting
"  set statusline+=%-2.2n\                      " buffer number
"  set statusline+=%#WarningMsg#                " set highlighting
"  set statusline+=%f\                          " file name
"  set statusline+=%#Question#                  " set highlighting
"  set statusline+=%h%m%r%w\                    " flags
"  set statusline+=%{strlen(&ft)?&ft:'none'},   " file type
"  set statusline+=%{(&fenc==\"\"?&enc:&fenc)}, " encoding
"  set statusline+=%{((exists(\"+bomb\")\ &&\ &bomb)?\"B,\":\"\")} " BOM
"  set statusline+=%{&fileformat},              " file format
"  set statusline+=%{&spelllang},               " language of spelling checker
"  set statusline+=%{SyntaxItem()}              " syntax highlight group under cursor
"  set statusline+=%=                           " ident to the right
"  set statusline+=[LEN=%L]\                    " File length in lines
"  set statusline+=[ASCII=\%03.3b]\	       " ASCII code for character under cursor
"  set statusline+=0x%-8B\                      " character hexadecimal code 
"  set statusline+=%-7.(%l,%c%V%)\ %<%P         " cursor position/offset
"endif
"
""end of 
""Detailed stats line, including current function:

set laststatus=2 " always show the status line

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Text Formatting/Layout
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set fo=tcrqn " See Help (complex)
set ai " autoindent
set si " smartindent 
set cindent " do c-style indenting
set tabstop=8 " tab spacing (settings below are just to unify it)
set softtabstop=8 " unify
set shiftwidth=8 " unify 
"Settings for ACS code conventions no tabs, instead four spaces.
"set noexpandtab " real tabs please!
set tabstop=4
set expandtab
"set nowrap " do not wrap lines  
set smarttab " use tabs at the start of a line, spaces elsewhere

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Folding
"    Enable folding, but by default make it act like folding is off, because folding is annoying in anything but a few rare cases
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set foldenable " Turn on folding
set foldmethod=indent " Make folding indent sensitive
set foldlevel=100 " Don't autofold anything (but I can still fold manually)
set foldopen-=search " don't open folds when you search into them
set foldopen-=undo " don't open folds when you undo stuff

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" File Explorer
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let g:explVertical=1 " should I split verticially
let g:explWinSize=35 " width of 35 pixels

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Win Manager
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let g:winManagerWidth=35 " How wide should it be( pixels)
let g:winManagerWindowLayout = 'FileExplorer,TagsExplorer|BufExplorer' " What windows should it

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" CTags
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" only set Tlist_Ctags_Cmd if its not in path. 
"let Tlist_Ctags_Cmd = '/usr/local/bin/'.'\ctags.exe' " Location of ctags
let Tlist_Sort_Type = "name" " order by 
let Tlist_Use_Right_Window = 1 " split to the right side of the screen
let Tlist_Compart_Format = 1 " show small meny
let Tlist_Exist_OnlyWindow = 1 " if you are the last, kill yourself
let Tlist_File_Fold_Auto_Close = 0 " Do not close tags for other files
let Tlist_Enable_Fold_Column = 0 " Do not show folding tree

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Minibuf
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let g:miniBufExplTabWrap = 1 " make tabs show complete (no broken on two lines)
let g:miniBufExplModSelTarget = 1

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Matchit
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let b:match_ignorecase = 1

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Perl
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let perl_extended_vars=1 " highlight advanced perl vars inside strings

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Custom Functions
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Select range, then hit :SuperRetab($width) - by p0g and FallingCow
function! SuperRetab(width) range
	silent! exe a:firstline . ',' . a:lastline . 's/\v%(^ *)@<= {'. a:width .'}/\t/g'
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Mappings, maps, my maps
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"map <right> <ESC>:MBEbn<RETURN> " right arrow (normal mode) switches buffers  (excluding minibuf)
"map <left> <ESC>:MBEbp<RETURN> " left arrow (normal mode) switches buffers (excluding minibuf) 
"map <up> <ESC>:Sex<RETURN><ESC><C-W><C-W> " up arrow (normal mode) brings up a file list
"map <down> <ESC>:Tlist<RETURN> " down arrow  (normal mode) brings up the tag list
"map <A-i> i <ESC>r " alt-i (normal mode) inserts a single char, and then switches back to normal
"map <F2> <ESC>ggVG:call SuperRetab()<left>
"map <F12> ggVGg? " encypt the file (toggle)
"
"Send output of the last g/patter/ search to a new window
nmap <F3> :redir @a<CR>:g//<CR>:redir END<CR>:new<CR>:put! a<CR><CR>

"Map F5 to add new entry to TOC based on following logic, take the previous entry and add 1 to the last digit
map <F5> ?^\s*\(\d\+\.\)\+\d*<CR>0y/\d\+\.\?\zs\s<CR>``o<ESC>p0E<C-A>a<ESC>
"Map F6 to add new entry to TOC based on following logic, take the previous entry and add .1 after the last digit
"map <F6> ?^\s*\(\d\+\.\)\+\d*<CR>0y/\d\+\.\?\zs\s<CR>``o    <ESC>p0Ea.1 
map <F6> <ESC>ms?^\s*\(\d\+\.\)\+\d*<CR>Y<CR>`so<ESC>PI<TAB><ESC>Ea.1<ESC>WDo<ESC>

"Map ctrl-s+d to add [done] to end of line, this usefull for filling done status for
" p -> pending, o -> open, w - work in progress
map <C-s><C-d> A [Done]<esc>
map <C-s><C-p> A [Pending]<esc>
map <C-s><C-o> A [Open]<esc>
map <C-s><C-w> A [Work In Progress]<esc>

"Maps for quoting a visuall selected text with ',", (), [] and {} 
vnoremap qq <Esc>`>a'<Esc>`<i'<Esc>
vnoremap q" <Esc>`>a"<Esc>`<i"<Esc>
vnoremap q( <Esc>`>a)<Esc>`<i(<Esc>
vnoremap q[ <Esc>`>a]<Esc>`<i[<Esc>
vnoremap q{ <Esc>`>a}<Esc>`<i{<Esc>

"Maps for getting current time. t? in normal mode and ctrl+t in insert mode
map t? :echo 'Current time is ' . strftime('%c')<CR>
map! <C-t><C-t>		<C-R>=strftime('%c')<CR><Esc>
" The following command maps ctrl+d to insert the directory name of the current buffer:
inoremap <C-d> <C-R>=expand('%:p:h')<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Autocommands
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
autocmd BufEnter * :syntax sync fromstart " ensure every file does syntax highlighting (full)
au BufNewFile,BufRead *.asp :set ft=aspjscript " all my .asp files ARE jscript
au BufNewFile,BufRead *.tpl :set ft=html " all my .tpl files ARE html
au BufNewFile,BufRead *.hta :set ft=html " all my .tpl files ARE html

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Useful abbrevs
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
iab xasp <%@language=jscript%><CR><%<CR><TAB><CR><BS>%><ESC><<O<TAB>
iab xdate <c-r>=strftime("%d/%m/%y %H:%M:%S")<cr> 

"csuppot plugin.
let g:C_AuthorName      = 'Yosi Izaq'    
let g:C_AuthorRef       = 'Y.I.'                         
let g:C_Email           = 'yizaq@cisco.com, izaqyos@gmail.com'                    
let g:C_Company         = 'Cisco, NMTG'     
let g:C_Template_Directory  =  $HOME."/.vim/plugin/templates/"

"Python support
"au FileType python /cygdrive/d/Documents\ and\ Settings/yytzhak/.vim/plugin/python.vim 
au FileType python $HOME."plugin/python.vim"

"perl support plugin
let g:Perl_AuthorName      = 'Yosi Izaq'     
let g:Perl_AuthorRef       = 'YI'                         
let g:Perl_Email           = 'yytzhak@cisco.com'            
let g:Perl_Company         = 'Cisco, NMTG'    

"Latex suite plugin
" REQUIRED. This makes vim invoke latex-suite when you open a tex file.
filetype plugin on

" IMPORTANT: win32 users will need to have 'shellslash' set so that latex
" can be called correctly.
set shellslash

" IMPORTANT: grep will sometimes skip displaying the file name if you
" search in a singe file. This will confuse latex-suite. Set your grep
" program to alway generate a file-name.
set grepprg=grep\ -nH\ $*

" OPTIONAL: This enables automatic indentation as you type.
filetype indent on

" For recording
:nnoremap <space> @q

" Auto save and load working session
" function! MakeSession()
"     let b:sessiondir = $HOME . "/.vim/sessions" . getcwd()
"     if (filewritable(b:sessiondir) != 2)
"         exe 'silent !mkdir -p ' b:sessiondir
"         redraw!
"     endif
"     let b:filename = b:sessiondir . '/session.vim'
"     exe "mksession! " . b:filename
" endfunction
" 
" function! LoadSession()
"     let b:sessiondir  = $HOME . "/.vim/sessions" . getcwd()
"     let b:sessionfile = b:sessiondir . "/session.vim"
"     if (filereadable(b:sessionfile))
"         exe 'source ' b:sessionfile
"     else
"         echo "No session loaded."
"     endif
" endfunction
" 
" au VimEnter * :call LoadSession()
" au VimLeave * :call MakeSession()
"

" For cppomnicomplete
"set nocp
"filetype plugin on
"map <C-F12> :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q
" settings based on tip 1608
" configure tags - add additional tags here or comment out not-used ones
set tags+=~/.vim/tags/cpp/tags
set tags+=~/.vim/tags/acs_5_1/tags
" build tags of your own project with CTRL+F12
map <C-F12> :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .<CR>

" OmniCppComplete
let OmniCpp_NamespaceSearch = 1
let OmniCpp_GlobalScopeSearch = 1
let OmniCpp_ShowAccess = 1
let OmniCpp_MayCompleteDot = 1
let OmniCpp_MayCompleteArrow = 1
let OmniCpp_MayCompleteScope = 1
let OmniCpp_DefaultNamespaces = ["std", "_GLIBCXX_STD"]
" automatically open and close the popup menu / preview window
au CursorMovedI,InsertLeave * if pumvisible() == 0|silent! pclose|endif
set completeopt=menuone,menu,longest,preview

" To view word docs with vim, uses antiword
autocmd BufReadPre *.doc set ro
autocmd BufReadPre *.doc set hlsearch!
autocmd BufReadPost *.doc %!antiword "%"

" To view and diff PDF files using xpdf
autocmd BufReadPre *.pdf set ro
autocmd BufReadPost *.pdf %!pdftotext -nopgbrk "%" -

" grep mappings
map <leader>n :cn<cr>
map <leader>p :cp<cr>
map <leader>c :botright cw 10<cr>

"text.vim plugin
au BufRead,BufNewFile *  setfiletype txt

" XMLFolding plugin
au BufNewFile,BufRead *.xml,*.htm,*.html so XMLFolding

"Compile and build command for systems that use maven
"set makeprg=mvnc\ %<
"
"Compile and build command for systems that use GNU make
set makeprg=makec\ %<

"for dbext
let g:dbext_default_profile_usual = 'type=SYBASE:user=DBA:passwd=sql'


" My personal menu
amenu MyMenu.HighlighCtxt       :match ToDo /^\s\+-\+>.*$/<cr>
amenu MyMenu.KBEntries          :match StatusLine /^\s*\d\+\..*$/<cr>
amenu MyMenu.-SEP-      :   
amenu MyMenu.ArchiveBuffers     :silent bufdo !tar -rvf ~/temp/vim_archive.tar %:p<cr>
amenu MyMenu.-SEP-      :   
amenu MyMenu.highlight          :set cursorline<cr>
amenu MyMenu.highlightV         :set cursorcolumn<cr>
amenu MyMenu.-SEP-      :   
vmenu MyMenu.makeArrowList              :call ArrowList()<cr>
vmenu MyMenu.makeNumberList             :call NumberList()<cr>
amenu MyMenu.-SEP-      :   
amenu MyMenu.InsertFileLink             :s/^.*$/&\r<URL:[File Path]><cr>
amenu MyMenu.InsertLocalLink            :s/^.*$/&\r<URL:#tn=[pattern in file]><cr>
amenu MyMenu.-SEP-      :   
amenu MyMenu.ArchiveModifiedBuffers            :call Archive_all_modified_buffers()<cr>

" My ACS 5, linux develoment environment clearcase menu
amenu MyCCMenu.checkout       :! co % <cr>
amenu MyCCMenu.checkin       :! ci % <cr>
amenu MyCCMenu.-SEP-      :   
amenu MyCCMenu.version_tree       :! ct lsvtree -g % <cr>
amenu MyCCMenu.diff_pred       :! ct diff -pred -graph % <cr>
amenu MyCCMenu.-SEP-      :   
amenu MyCCMenu.checkin_all       :call CheckIn_all__buffers()<cr>
amenu MyCCMenu.manually_set_tags_for_auto_complete       :set tags+=~/.vim/tags/acs_5_1/tags<cr>:set tags+=~/.vim/tags/cpp/tags<cr>

"Custom functions
function! Archive_all_modified_buffers()
    set hidden
    let archive=[]
    bufdo if &modified |  call add(archive, shellescape(expand("%"),1))| endif
    
    if len(archive) > 0
       exe "!tar -cvjf archive.tar.bz2 " . join(archive, " ")
    endif
endfunction

function! Perform_Shell_Test_all__buffers()
bufdo exe "!test -f " . expand("%") ."  > /dev/null"
    \ | if !v:shell_error
    \ | echo "passed"
    \ | endif
endfunction

function! CheckIn_all__buffers()
bufdo exe "!ct ls  " . expand("%") ." | grep -i checkedout > /dev/null"
    \ | if !v:shell_error
    \ | echo "file is checked out"
    \ | exe "!ci " . expand("%")
    \ | endif
endfunction

set dictionary-=/cygdrive/z/work/dictionary/brit-a-z.txt dictionary+=/cygdrive/z/work/dictionary/brit-a-z.txt
set complete-=k complete+=k

if has("win32unix") "Tip will only take effect on cygwin
set complete=.,w,b,u,k
elseif  has("win32") 
set complete=.,w,b,u,k
else "Unix, where my source code is
set complete=.,w,b,u,k,i,]
endif

set viewdir=$HOME/.vim/views

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Creating lists
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! ArrowList()
        let lineno = line(".")
        call setline(lineno, "    -> " . getline(lineno))
endfunction

function! NumberList() range
        "Set line numbers in front of lines
        let begining=line("'<")
        let ending=line("'>")
        let difsize = ending -begining +1
        let pre = ' ' 
        while (begining <= ending)
                if match(difsize, '^9*$') == 0
                        let pre = pre . ' ' 
                endif
                call setline(ending, pre . difsize . "\t" . getline(ending))
                let ending = ending-1
                let difsize = difsize-1
        endwhile
endfunction

""" VIM commander map
noremap <silent> <F11> :cal VimCommanderToggle()<CR>
let b:vimcommander_install_doc=0

""" C support turn off annoying messages
let s:C_TemplateOverwrittenMsg='no'

"Functions
"" Commenting of #endifs etc
"" Author: Ben Schmidt, minor modifications by A. S. Budden.
"command SmartPreProcCommenter call SmartPreProcCommenter()
"
"function! SmartPreProcCommenter()
"  mark y
"  let saved_wrapscan=&wrapscan
"  set nowrapscan
"  let elsecomment=""
"  let endcomment=""
"  try
"    " Find the last #if in the buffer
"    $?^\s*#if
"    while 1
"      " Build the comments for later use, based on current line
"      let content=getline('.')
"      let elsecomment=BuildElseComment(content,elsecomment)
"      let endcomment=BuildEndComment(content,endcomment)
"      " Change # into ## so we know we've already processed this one
"      " and don't find it again
"      s/^\s*\zs#/##
"      " Find the next #else, #elif, #endif which must belong to this #if
"      /^\s*#\(elif\|else\|endif\)
"      let content=getline('.')
"      if match(content,'^\s*#elif') != -1
"        " For #elif, treat the same as #if, i.e. build new comments
"        continue
"      elseif match(content,'^\s*#else') != -1
"        " For #else, add/replace the comment
"        call setline('.',ReplaceComment(content,elsecomment))
"        s/^\s*\zs#/##
"        " Find the #endif
"        /^\s*#endif
"      endif
"      " We should be at the #endif now; add/replace the comment
"      call setline('.',ReplaceComment(getline('.'),endcomment))
"      s/^\s*\zs#/##
"      " Find the previous #if
"      ?^\s*#if
"    endwhile
"  catch /search hit TOP/
"    " Once we have an error (pattern not found, i.e. no more left)
"    " Change all our ## markers back to #
"    silent! %s/^\s*\zs##/#
"  endtry
"  let &wrapscan=saved_wrapscan
"  normal `y
"endfunc
"
"let s:PreProcCommentMatcher = '#\a\+\s\+\zs.\{-}\ze\(\s*\/\*.\{-}\*\/\)\?\s*$'
"
"function! BuildElseComment(content,previous)
"  let expression=escape(matchstr(a:content,s:PreProcCommentMatcher), '\~&')
"  if match(a:content,'#ifdef') != -1
"    return "/* NOT def ".expression." */"
"  elseif match(a:content,'#ifndef') != -1
"    return "/* def ".expression." */"
"  elseif match(a:content,'#if') != -1
"    return "/* NOT ".expression." */"
"  elseif match(a:content,'#elif') != -1
"    return substitute(a:previous,' \*/',', '.expression.' */','')
"  else
"    return ""
"  endif
"endfunc
"
"function! BuildEndComment(content,previous)
"  let expression=escape(matchstr(a:content,s:PreProcCommentMatcher), '\~&')
"  if match(a:content,'#ifdef') != -1
"    return "/* def ".expression." */"
"  elseif match(a:content,'#ifndef') != -1
"    return "/* NOT def ".expression." */"
"  elseif match(a:content,'#if') != -1
"    return "/* ".expression." */"
"  elseif match(a:content,'#elif') != -1
"    return substitute(a:previous,' \*/',', '.expression.' */','')
"  else
"    return ""
"  endif
"endfunc
"
"function! ReplaceComment(content,comment)
"  let existing=escape(matchstr(a:content,'#\a\+\s\+\zs.\{-}\s*$'), '\~&')
"  if existing == ""
"    return substitute(a:content,'^\s*#\a\+\zs.*'," ".a:comment,'')
"  elseif existing != a:comment && match(existing,'XXX') == -1
"    return a:content." /* XXX */"
"  else
"    return a:content
"  endif
"endfunc
"
"

"Cscope auto mapping
nmap <F12> :!find . -iname '*.c' -o -iname '*.cpp' -o -iname '*.h' -o -iname '*.hpp' > cscope.files ;
  \ cs kill -1<CR>:cs add cscope.out<CR>

"Cscope qury results go to quickfix
if has('cscope')
" In case cscope.out is in home dir
 "if filereadable(expand("$HOME/cscope.out"))
" In case cscope.out is in dir from which VIM is opned
 if filereadable(expand("cscope.out"))
   cs kill -1
   cs add ~/cscope.out
 endif
 set cscopeverbose
 set cscopequickfix=s-,c-,d-,i-,t-,e-,g-
endif

set tags+=tags,~/tags,~/stl-tags

"switch back to normal mode automatically after inaction
"au! CursorHoldI * stopinsert

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Source explorer http://www.vim.org/scripts/script.php?script_id=2179 
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" // The switch of the Source Explorer
nmap <F8> :SrcExplToggle<CR>

" // Set the window height of Source Explorer
  let g:SrcExpl_winHeight = 8

" // Set 100 ms for refreshing the Source Explorer
let g:SrcExpl_refreshTime = 100

" // Let the Source Explorer update the tags file when opening
let g:SrcExpl_updateTags = 1

" // Set "Enter" key to jump into the exact definition context
let g:SrcExpl_jumpKey = "<ENTER>"

" // Set "Space" key for back from the definition context
let g:SrcExpl_gobackKey = "<SPACE>"

" // In order to Avoid conflicts, the Source Explorer should know what plugins
" // are using buffers. And you need add their bufname into the list below
" // according to the command ":buffers!"
let g:SrcExpl_pluginList = [
          \ "__Tag_List__",
          \ "_NERD_tree_",
          \ "Source_Explorer"
      \ ]

" // Enable or disable local definition searching, and note that this is not
" // guaranteed to work, the Source Explorer does not check the syntax for now,
" // it only searches for a match with the keyword according to command 'gd'.
let g:SrcExpl_searchLocalDef = 1 

"Use python math module as calculator
command! -nargs=+ Calc :!python -c "from math import *; print <args>"


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" TIPS Section
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Edit another file in the same directory as the current file 
" type %/ in command prompt (:) and it will be expanded to path of current
" open buffer
if has("unix")
  cmap %/ <C-R>=expand("%:p:h") . '/'<CR>
else
  cmap %/ <C-R>=expand("%:p:h") . '\'<CR>
endif
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Improved Hex editing, Tip 1518 created October 3, 2007 · author Fritzophrenic 
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
nnoremap <LEADER>hx :Hexmode<CR>
inoremap <LEADER>hx <Esc>:Hexmode<CR>
vnoremap <LEADER>hx :<C-U>Hexmode<CR>

" ex command for toggling hex mode - define mapping if desired
command -bar Hexmode call ToggleHex()

" helper function to toggle hex mode
function ToggleHex()
  " hex mode should be considered a read-only operation
  " save values for modified and read-only for restoration later,
  " and clear the read-only flag for now
  let l:modified=&mod
  let l:oldreadonly=&readonly
  let &readonly=0
  let l:oldmodifiable=&modifiable
  let &modifiable=1
  if !exists("b:editHex") || !b:editHex
    " save old options
    let b:oldft=&ft
    let b:oldbin=&bin
    " set new options
    setlocal binary " make sure it overrides any textwidth, etc.
    let &ft="xxd"
    " set status
    let b:editHex=1
    " switch to hex editor
    %!xxd
  else
    " restore old options
    let &ft=b:oldft
    if !b:oldbin
      setlocal nobinary
    endif
    " set status
    let b:editHex=0
    " return to normal editing
    %!xxd -r
  endif
  " restore values for modified and read only state
  let &mod=l:modified
  let &readonly=l:oldreadonly
  let &modifiable=l:oldmodifiable
endfunction
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Easily switch between two styles of color scheme Tip 955 and 341
" The setcolors.vim should be put in plugin/ dir and then its auto loaded. The
" manually load it uncomment the next line:
":source setcolors.vim

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Frequently when I go to save with :w I am flying to fast and I type :W
" which gives me an obvious error.
"
" How can I map :W to :w ???
" How can I map :Q to :q ???
"
" I know there is :ZZ but I like the :w more.
"
:command! -bang W w<bang>
:command! -bang Q q<bang>
:command! -bang Wa wa<bang>
:command! -bang Qa qa<bang>
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" often make the mistake of typing w1 instead of w!.
" Can you please suggest how to map w1 to w!?
if version<  700
        cnoreabbrev w1 w!
else
        cnoreabbrev  <expr>  w1  ((getcmdtype() == ':'  &&  getcmdpos()  <= 2)?   'w!' : 'w1')
endif
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" How can I detect my current platform in Vim? I share my configuration across platforms, and I need to set the font selectively
" Well, the key here is the has() function.
"For a quick and dirty test, use
"
"       if has('unix')
"               " unix-like platform (including Cygwin)
"       else
"               " probably Windows
"       endif
"
"For the 'guifont' option, however, you need to take care of the five
"different incompatible formats used by various versions of Vim:
"    if has('gui')
"        " we use has('gui') rather than has('gui_running') here
"        " so it will work even if we start Console Vim first
"        " then run :gui manually (which is only possible on Unix)
"        if has('gui_gtk2')
"            set gfn=DejaVu\ Sans\ Mono\ 11
"        elseif has('gui_photon')
"            set gfn=DejaVu\ Sans\ Mono:s11
"        elseif has('gui_kde')
"            " the obsolete kvim
"            " just make sure it works correctly if it hits our vimrc
"            set gfn=DejaVu\ Sans\ Mono/11/-1/5/50/0/0/0/1/0
"        elseif has('x11')
"            " I'm guessing the following (other-X11 including GTK1)
"            " please check, and correct if necessary.
"            " On GTK1 (and maybe some others) you can use :set gfn=*
"            " Replace by asterisks like here
"            " to make it a little more general:
"            set gfn=-*-dejavu-medium-r-normal-*-*-110-*-*-m-*-*
"            " add another elseif here
"            " if you want DejaVu on mac-without-x11
"       else
"            " not x11 (probably Windows)
"            set gfn=Courier_New:h11:cDEFAULT
"        endif
"    endif
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" VIM and BASH compatability
" Tell VIM to run shell in interactive mode thus allowing for aliases to be
" loaded
set shellcmdflag=-ic
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" For UTL 3.x 
"--- Suggested mappings for most frequent commands  [id=suggested_mappings] [
"
nmap <unique> <Leader>ge :Utl openLink underCursor edit<CR>
nmap <unique> <Leader>gu :Utl openLink underCursor edit<CR>
nmap <unique> <Leader>gE :Utl openLink underCursor split<CR>
nmap <unique> <Leader>gS :Utl openLink underCursor vsplit<CR>
nmap <unique> <Leader>gt :Utl openLink underCursor tabedit<CR>
nmap <unique> <Leader>gv :Utl openLink underCursor view<CR>
nmap <unique> <Leader>gr :Utl openLink underCursor read<CR>

vmap <unique> <Leader>ge "*y:Utl openLink visual edit<CR>
vmap <unique> <Leader>gu "*y:Utl openLink visual edit<CR>
vmap <unique> <Leader>gE "*y:Utl openLink visual split<CR>
vmap <unique> <Leader>gS "*y:Utl openLink visual vsplit<CR>
vmap <unique> <Leader>gt "*y:Utl openLink visual tabedit<CR>
vmap <unique> <Leader>gv "*y:Utl openLink visual view<CR>
vmap <unique> <Leader>gr "*y:Utl openLink visual read<CR>


nmap <unique> <Leader>cfn :Utl copyFileName underCursor native<CR>
nmap <unique> <Leader>cfs :Utl copyFileName underCursor slash<CR>
nmap <unique> <Leader>cfb :Utl copyFileName underCursor backSlash<CR>

vmap <unique> <Leader>cfn "*y:Utl copyFileName visual native<CR>
vmap <unique> <Leader>cfs "*y:Utl copyFileName visual slash<CR>
vmap <unique> <Leader>cfb "*y:Utl copyFileName visual backSlash<CR>


nmap <unique> <Leader>cl :Utl copyLink underCursor<CR>

vmap <unique> <Leader>cl "*y:Utl copyLink visual<CR>

"]
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Enter Tip
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Enter Tip
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Enter Tip
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Enter Tip
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


" Only do this part when compiled with support for autocommands.
if has("autocmd")

  " Enable file type detection.
  " Use the default filetype settings, so that mail gets 'tw' set to 72,
  " 'cindent' is on in C files, etc.
  " Also load indent files, to automatically do language-dependent indenting.
  filetype plugin indent on

  " Put these in an autocmd group, so that we can delete them easily.
  augroup vimrcEx
  au!

  " For all text files set 'textwidth' to 78 characters.
  autocmd FileType text setlocal textwidth=78

  " When editing a file, always jump to the last known cursor position.
  " Don't do it when the position is invalid or when inside an event handler
  " (happens when dropping a file on gvim).
  " Also don't do it when the mark is in the first line, that is the default
  " position when opening a file.
  autocmd BufReadPost *
    \ if line("'\"") > 1 && line("'\"") <= line("$") |
    \   exe "normal! g`\"" |
    \ endif

  augroup END

else

  set autoindent		" always set autoindenting on

endif " has("autocmd")

" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
" Only define it when not defined already.
if !exists(":DiffOrig")
  command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
		  \ | wincmd p | diffthis
endif

" bye bye message
 au VimLeave * :call PrintAtExit()
   function! PrintAtExit()
       echo "Hope you had a good VIM session :) "
   endfun


		61.1.3
	61.2 Other

		61.2.1 "The ultimate vimrc" 
http://amix.dk/vim/vimrc.html

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Maintainer: amix the lucky stiff
"             http://amix.dk - amix@amix.dk
"
" Version: 3.3 - 21/01/10 01:05:46
"
" Blog_post: 
"       http://amix.dk/blog/post/19486#The-ultimate-vim-configuration-vimrc
" Syntax_highlighted:
"       http://amix.dk/vim/vimrc.html
" Raw_version: 
"       http://amix.dk/vim/vimrc.txt
"
" How_to_Install:
"    $ mkdir ~/.vim_runtime
"    $ svn co svn://orangoo.com/vim ~/.vim_runtime
"    $ cat ~/.vim_runtime/install.sh
"    $ sh ~/.vim_runtime/install.sh <system>
"      <sytem> can be `mac`, `linux` or `windows`
"
" How_to_Upgrade:
"    $ svn update ~/.vim_runtime
"
" Sections:
"    -> General
"    -> VIM user interface
"    -> Colors and Fonts
"    -> Files and backups
"    -> Text, tab and indent related
"    -> Visual mode related
"    -> Command mode related
"    -> Moving around, tabs and buffers
"    -> Statusline
"    -> Parenthesis/bracket expanding
"    -> General Abbrevs
"    -> Editing mappings
"
"    -> Cope
"    -> Minibuffer plugin
"    -> Omni complete functions
"    -> Python section
"    -> JavaScript section
"
" Plugins_Included:
"     > minibufexpl.vim - http://www.vim.org/scripts/script.php?script_id=159
"       Makes it easy to get an overview of buffers:
"           info -> :e ~/.vim_runtime/plugin/minibufexpl.vim
"
"     > bufexplorer - http://www.vim.org/scripts/script.php?script_id=42
"       Makes it easy to switch between buffers:
"           info -> :help bufExplorer
"
"     > yankring.vim - http://www.vim.org/scripts/script.php?script_id=1234
"       Emacs's killring, useful when using the clipboard:
"           info -> :help yankring
"
"     > surround.vim - http://www.vim.org/scripts/script.php?script_id=1697
"       Makes it easy to work with surrounding text:
"           info -> :help surround
"
"     > snipMate.vim - http://www.vim.org/scripts/script.php?script_id=2540
"       Snippets for many languages (similar to TextMate's):
"           info -> :help snipMate
"
"     > fuzzyfinder - http://www.vim.org/scripts/script.php?script_id=1984
"       Find files fast (similar to TextMate's feature):
"           info -> :help fuzzyfinder@en
"
"  Revisions:
"     > 3.3: Added syntax highlighting for Mako mako.vim
"     > 3.2: Turned on python_highlight_all for better syntax
"            highlighting for Python
"     > 3.1: Added revisions ;) and bufexplorer.vim
"
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => General
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Sets how many lines of history VIM has to remember
set history=300

" Enable filetype plugin
filetype plugin on
filetype indent on

" Set to auto read when a file is changed from the outside
set autoread

" With a map leader it's possible to do extra key combinations
" like <leader>w saves the current file
let mapleader = ","
let g:mapleader = ","

" Fast saving
nmap <leader>w :w!<cr>

" Fast editing of the .vimrc
map <leader>e :e! ~/.vim_runtime/vimrc<cr>

" When vimrc is edited, reload it
autocmd! bufwritepost vimrc source ~/.vim_runtime/vimrc


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => VIM user interface
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Set 7 lines to the curors - when moving vertical..
set so=7

set wildmenu "Turn on WiLd menu

set ruler "Always show current position

set cmdheight=2 "The commandbar height

set hid "Change buffer - without saving

" Set backspace config
set backspace=eol,start,indent
set whichwrap+=<,>,h,l

set ignorecase "Ignore case when searching

set hlsearch "Highlight search things

set incsearch "Make search act like search in modern browsers

set magic "Set magic on, for regular expressions

set showmatch "Show matching bracets when text indicator is over them
set mat=2 "How many tenths of a second to blink

" No sound on errors
set noerrorbells
set novisualbell
set t_vb=


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Colors and Fonts
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
syntax enable "Enable syntax hl

" Set font according to system
if MySys() == "mac"
  set gfn=Bitstream\ Vera\ Sans\ Mono:h13
  set shell=/bin/bash
elseif MySys() == "windows"
  set gfn=Bitstream\ Vera\ Sans\ Mono:h10
elseif MySys() == "linux"
  set gfn=Monospace\ 10
  set shell=/bin/bash
endif

if has("gui_running")
  set guioptions-=T
  set background=dark
  set t_Co=256
  set background=dark
  colorscheme peaksea

  set nu
else
  colorscheme zellner
  set background=dark
  
  set nonu
endif

set encoding=utf8
try
    lang en_US
catch
endtry

set ffs=unix,dos,mac "Default file types


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Files and backups
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Turn backup off, since most stuff is in SVN, git anyway...
set nobackup
set nowb
set noswapfile


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Text, tab and indent related
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set expandtab
set shiftwidth=4
set tabstop=4
set smarttab

set lbr
set tw=500

set ai "Auto indent
set si "Smart indet
set wrap "Wrap lines

map <leader>t2 :setlocal shiftwidth=2<cr>
map <leader>t4 :setlocal shiftwidth=4<cr>
map <leader>t8 :setlocal shiftwidth=4<cr>


""""""""""""""""""""""""""""""
" => Visual mode related
""""""""""""""""""""""""""""""
" Really useful!
"  In visual mode when you press * or # to search for the current selection
vnoremap <silent> * :call VisualSearch('f')<CR>
vnoremap <silent> # :call VisualSearch('b')<CR>

" When you press gv you vimgrep after the selected text
vnoremap <silent> gv :call VisualSearch('gv')<CR>
map <leader>g :vimgrep // **/*.<left><left><left><left><left><left><left>


function! CmdLine(str)
    exe "menu Foo.Bar :" . a:str
    emenu Foo.Bar
    unmenu Foo
endfunction 

" From an idea by Michael Naumann
function! VisualSearch(direction) range
    let l:saved_reg = @"
    execute "normal! vgvy"

    let l:pattern = escape(@", '\\/.*$^~[]')
    let l:pattern = substitute(l:pattern, "\n$", "", "")

    if a:direction == 'b'
        execute "normal ?" . l:pattern . "^M"
    elseif a:direction == 'gv'
        call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.')
    elseif a:direction == 'f'
        execute "normal /" . l:pattern . "^M"
    endif

    let @/ = l:pattern
    let @" = l:saved_reg
endfunction



"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Command mode related
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Smart mappings on the command line
cno $h e ~/
cno $d e ~/Desktop/
cno $j e ./
cno $c e <C-\>eCurrentFileDir("e")<cr>

" $q is super useful when browsing on the command line
cno $q <C-\>eDeleteTillSlash()<cr>

" Bash like keys for the command line
cnoremap <C-A>      <Home>
cnoremap <C-E>      <End>
cnoremap <C-K>      <C-U>

cnoremap <C-P> <Up>
cnoremap <C-N> <Down>

" Useful on some European keyboards
map ½ $
imap ½ $
vmap ½ $
cmap ½ $


func! Cwd()
  let cwd = getcwd()
  return "e " . cwd
endfunc

func! DeleteTillSlash()
  let g:cmd = getcmdline()
  if MySys() == "linux" || MySys() == "mac"
    let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*", "\\1", "")
  else
    let g:cmd_edited = substitute(g:cmd, "\\(.*\[\\\\]\\).*", "\\1", "")
  endif
  if g:cmd == g:cmd_edited
    if MySys() == "linux" || MySys() == "mac"
      let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*/", "\\1", "")
    else
      let g:cmd_edited = substitute(g:cmd, "\\(.*\[\\\\\]\\).*\[\\\\\]", "\\1", "")
    endif
  endif  
  return g:cmd_edited
endfunc

func! CurrentFileDir(cmd)
  return a:cmd . " " . expand("%:p:h") . "/"
endfunc


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Moving around, tabs and buffers
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Map space to / (search) and c-space to ? (backgwards search)
map <space> /
map <c-space> ?
map <silent> <leader><cr> :noh<cr>

" Smart way to move btw. windows
map <C-j> <C-W>j
map <C-k> <C-W>k
map <C-h> <C-W>h
map <C-l> <C-W>l

" Close the current buffer
map <leader>bd :Bclose<cr>

" Close all the buffers
map <leader>ba :1,300 bd!<cr>

" Use the arrows to something usefull
map <right> :bn<cr>
map <left> :bp<cr>

" Tab configuration
map <leader>tn :tabnew %<cr>
map <leader>te :tabedit
map <leader>tc :tabclose<cr>
map <leader>tm :tabmove

" When pressing <leader>cd switch to the directory of the open buffer
map <leader>cd :cd %:p:h<cr>


command! Bclose call <SID>BufcloseCloseIt()
function! <SID>BufcloseCloseIt()
   let l:currentBufNum = bufnr("%")
   let l:alternateBufNum = bufnr("#")

   if buflisted(l:alternateBufNum)
     buffer #
   else
     bnext
   endif

   if bufnr("%") == l:currentBufNum
     new
   endif

   if buflisted(l:currentBufNum)
     execute("bdelete! ".l:currentBufNum)
   endif
endfunction

" Specify the behavior when switching between buffers
try
  set switchbuf=usetab
  set stal=2
catch
endtry


""""""""""""""""""""""""""""""
" => Statusline
""""""""""""""""""""""""""""""
" Always hide the statusline
set laststatus=2

" Format the statusline
set statusline=\ %F%m%r%h\ %w\ \ CWD:\ %r%{CurDir()}%h\ \ \ Line:\ %l/%L:%c


function! CurDir()
    let curdir = substitute(getcwd(), '/Users/amir/', "~/", "g")
    return curdir
endfunction


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Parenthesis/bracket expanding
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
vnoremap $1 <esc>`>a)<esc>`<i(<esc>
vnoremap $2 <esc>`>a]<esc>`<i[<esc>
vnoremap $3 <esc>`>a}<esc>`<i{<esc>
vnoremap $$ <esc>`>a"<esc>`<i"<esc>
vnoremap $q <esc>`>a'<esc>`<i'<esc>
vnoremap $e <esc>`>a"<esc>`<i"<esc>

" Map auto complete of (, ", ', [
inoremap $1 ()<esc>i
inoremap $2 []<esc>i
inoremap $3 {}<esc>i
inoremap $4 {<esc>o}<esc>O
inoremap $q ''<esc>i
inoremap $e ""<esc>i


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => General Abbrevs
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
iab xdate <c-r>=strftime("%d/%m/%y %H:%M:%S")<cr>


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Editing mappings
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Remap VIM 0
map 0 ^

"Move a line of text using ALT+[jk] or Comamnd+[jk] on mac
nmap <M-j> mz:m+<cr>`z
nmap <M-k> mz:m-2<cr>`z
vmap <M-j> :m'>+<cr>`<my`>mzgv`yo`z
vmap <M-k> :m'<-2<cr>`>my`<mzgv`yo`z

if MySys() == "mac"
  nmap <D-j> <M-j>
  nmap <D-k> <M-k>
  vmap <D-j> <M-j>
  vmap <D-k> <M-k>
endif

"Delete trailing white space, useful for Python ;)
func! DeleteTrailingWS()
  exe "normal mz"
  %s/\s\+$//ge
  exe "normal `z"
endfunc
autocmd BufWrite *.py :call DeleteTrailingWS()


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Cope
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Do :help cope if you are unsure what cope is. It's super useful!
map <leader>cc :botright cope<cr>
map <leader>n :cn<cr>
map <leader>p :cp<cr>


""""""""""""""""""""""""""""""
" => bufExplorer plugin
""""""""""""""""""""""""""""""
let g:bufExplorerDefaultHelp=0
let g:bufExplorerShowRelativePath=1


""""""""""""""""""""""""""""""
" => Minibuffer plugin
""""""""""""""""""""""""""""""
let g:miniBufExplModSelTarget = 1
let g:miniBufExplorerMoreThanOne = 2
let g:miniBufExplModSelTarget = 0
let g:miniBufExplUseSingleClick = 1
let g:miniBufExplMapWindowNavVim = 1
let g:miniBufExplVSplit = 25
let g:miniBufExplSplitBelow=1

let g:bufExplorerSortBy = "name"

autocmd BufRead,BufNew :call UMiniBufExplorer

map <leader>u :TMiniBufExplorer<cr>:TMiniBufExplorer<cr>


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Omni complete functions
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
autocmd FileType css set omnifunc=csscomplete#CompleteCSS


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Spell checking
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Pressing ,ss will toggle and untoggle spell checking
map <leader>ss :setlocal spell!<cr>

"Shortcuts using <leader>
map <leader>sn ]s
map <leader>sp [s
map <leader>sa zg
map <leader>s? z=


""""""""""""""""""""""""""""""
" => Python section
""""""""""""""""""""""""""""""
au FileType python set nocindent
let python_highlight_all = 1
au FileType python syn keyword pythonDecorator True None False self

au BufNewFile,BufRead *.jinja set syntax=htmljinja
au BufNewFile,BufRead *.mako set ft=mako

au FileType python inoremap <buffer> $r return
au FileType python inoremap <buffer> $i import
au FileType python inoremap <buffer> $p print
au FileType python inoremap <buffer> $f #--- PH ----------------------------------------------<esc>FP2xi
au FileType python map <buffer> <leader>1 /class
au FileType python map <buffer> <leader>2 /def
au FileType python map <buffer> <leader>C ?class
au FileType python map <buffer> <leader>D ?def


""""""""""""""""""""""""""""""
" => JavaScript section
"""""""""""""""""""""""""""""""
au FileType javascript call JavaScriptFold()
au FileType javascript setl fen
au FileType javascript setl nocindent

au FileType javascript imap <c-t> AJS.log();<esc>hi
au FileType javascript imap <c-a> alert();<esc>hi

au FileType javascript inoremap <buffer> $r return
au FileType javascript inoremap <buffer> $f //--- PH ----------------------------------------------<esc>FP2xi

function! JavaScriptFold() 
    setl foldmethod=syntax
    setl foldlevelstart=1
    syn region foldBraces start=/{/ end=/}/ transparent fold keepend extend

    function! FoldText()
    return substitute(getline(v:foldstart), '{.*', '{...}', '')
    endfunction
    setl foldtext=FoldText()
endfunction


""""""""""""""""""""""""""""""
" => Fuzzy finder
""""""""""""""""""""""""""""""
try
    call fuf#defineLaunchCommand('FufCWD', 'file', 'fnamemodify(getcwd(), ''%:p:h'')')
    map <leader>t :FufCWD **/<CR>
catch
endtry


""""""""""""""""""""""""""""""
" => Vim grep
""""""""""""""""""""""""""""""
let Grep_Skip_Dirs = 'RCS CVS SCCS .svn generated'
set grepprg=/bin/grep\ -nH


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => MISC
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Remove the Windows ^M - when the encodings gets messed up
noremap <Leader>m mmHmt:%s/<C-V><cr>//ge<cr>'tzt'm

"Quickly open a buffer for scripbble
map <leader>q :e ~/buffer<cr>

		61.2.2 Tony Mechelnyk's
OK, so here are my vimrc and colorscheme, over which I worked since the times of Vim 6.1 (but of course extensively reworked for 7):
http://users.skynet.be/antoine.mechelynck/other/.vimrc
http://users.skynet.be/antoine.mechelynck/other/almost-default.vim
They work together with the CSApprox plugin (which I added relatively recently), and I use matchit as explained in the Vim help and wiki.

I may have published them already, but of course I make small changes now and then: I don't think I'll ever regard them as "never to be touched again". These are today's versions, which I uploaded anew a few minutes ago. Their sizes (including comments and "unix-style" ends of lines) are: vimrc 18711 bytes, "almost-default" colorscheme 5719.

I'm not saying that my vimrc, or even my vimrc and colorscheme, are "the ultimate" or even "ultimative", whatever that might be, because I deny that there may exist a single "best vimrc" for everyone -- if there were one, why not compile it into Vim and be done with it? Rather, I agree with Bram's decision of making his editor extremely customizable by means of scripts in what is actually a programming language, and one which is easy to understand for whoever is familiar with the editor's commands. This way, different users may customize Vim in different ways, and obtain each what is best for him or her, without being constrained by a single choice of settings, as in Notepad, where "one size fits all", maybe, but fits all equally badly. These scripts suit me, they may or may not suit each of you, and they will probably not suit you all perfectly.


			61.2.2.1 http://users.skynet.be/antoine.mechelynck/other/.vimrc
" use 'nocompatible' mode even if sourced with -u
set nocompatible

" this script is in Latin1 even when 'encoding' is UTF-8
scriptencoding latin1

" remember where I keep my sources:
" this means the parent of src/ runtime/ etc.
if 1 | let $VIMSRC = '/root/.build/vim/vim' . (version / 100) . (version % 100) | endif

" I think the following two were fixed by patches 6.0.064 and 7.1b.002 (or some such)
" I leave them in in case I happened to run an unfixed Vim
" I don't think they can hurt
if &mm < 256
	set mm=20000000
endif
if &mmt < 256
	set mmt=20000000
endif

" set menus & messages to English even on a multilingual Vim run on a non-English locale
if has("multi_lang")
	if has("unix")
		language messages C
	else
		language messages en
	endif
	language time en_GB
endif

if 1	" expression evaluation compiled-in
	runtime! menu.vim
endif

" use 256 colors in Console mode if we think the terminal supports it
if &term =~? 'mlterm\|xterm'
	let &t_Co = 256
endif

" the example vimrc sets a lot of useful settings
runtime vimrc_example.vim
" ... and a few that we don't want
unmap! <C-U>
" the example vimrc doesn't set syntax highlighting on mono terminals --
" let's correct that
if has('syntax') && !(exists('syntax_on') && syntax_on)
	syntax on
endif

" set my own color scheme
if has('autocmd') && has('syntax')
	color almost-default
	let my_colors_name = "almost-default"
endif

" (try to) detect whether we have clipboard and X
if has('gui_running')
	function TestForX()
		return 1
	endfunction
elseif has('clipboard')
	function TestForX()
		let @+ = " "
		let x = @+
		let @+ = '--' . x
		redir @"
		silent reg
		redir END
		let @+ = x
	"	unlet x
		return (@" =~ '\n"+ ')
	endfunction
else
	function TestForX()
		return 0
	endfunction
endif


if has("autocmd")
	" remove the 'textwidth' setting set by vimrc_example.vim on text files
	au! vimrcEx FileType text

	" define a few additional autocommands
	augroup vimrclocal

	" complete the try-to-detect-Xwindows started earlier
	au VimEnter *
		\   let clipboard_present = TestForX()
		\ | let X_available = has('x11') && clipboard_present

	" this one is unnecessary on recent Vim versions
	au FileType *.* exe substitute(expand('<amatch>'), '^\(.*\)\.\(.*\)$', 'doau Filetype \1 | doau Filetype \2', '')

	" remove filetype-indenting autocommands set by the vimrc_example.vim
	filetype indent off

	" set verbosity to at least 1, except during startup and closedown
	if ! &verbose
		au vimEnter * set verbose=1
		au vimLeave * set verbose=0
	endif

	" close all cscope connections (if any) at closedown
	if has('cscope')
		au vimLeave * cs kill -1
	endif

	" use matchit correctly on C (etc.) sources
	au Filetype c,cpp,css,javascript
	\ let b:match_words = &matchpairs

	" this was fixed by patch 7.1.261 but doesn't hurt,
	" and will make Vim open UTF-16 files with BOM correctly even without that patch
	if has('multi_byte')
		au BufReadPost * if (&fenc == 'ucs-2le') && &bomb | e ++enc=utf-16le | endif
		au BufReadPost * if (&fenc == 'ucs-2')   && &bomb | e ++enc=utf-16   | endif
		set imi=0 ims=-1
	endif
endif

if has("gui_running")
	" set the GUI font, using the correct format for the build we're on
	if has("gui_gtk2")
		set gfn=Bitstream\ Vera\ Sans\ Mono\ 8
		let s:pfn = 'Bitstream\ Vera Sans Mono'
	"	set gfn=Monaco\ 7
	"	let s:pfn='Monaco'
	elseif has("gui_photon")
		set gfn=Bitstream\ Vera\ Sans\ Mono:s8
		let s:pfn = 'Bitstream\ Vera Sans Mono'
	"	set gfn=Monaco=s7
	"	let s:pfn='Monaco'
	elseif has("gui_kde")
		set gfn=Bitstream\ Vera\ Sans\ Mono/8/-1/5/50/0/0/0/1/0
		let s:pfn = 'Bitstream\ Vera Sans Mono'
	"	set gfn=Monaco/7/-1/5/50/0/0/0/1/0
	"	let s:pfn='Monaco'
	elseif has("x11")
		set gfn=-*-lucidatypewriter-medium-r-normal-*-*-90-*-*-m-*-*
		let s:pfn = 'Lucida'
	else
		set gfn=Lucida_Console:h9:cDEFAULT
		let s:pfn = 'Lucida Console'
	endif

	" set GUI cursor shape
	set guicursor=n-v-c:block-Cursor/lCursor,ve:ver35-Cursor,o:hor50-Cursor
	set guicursor+=i-ci:ver25-Cursor/lCursor,r-cr:hor20-Cursor/lCursor
	set guicursor+=sm:block-Cursor,a:blinkwait750-blinkoff750-blinkon750

	" maximize the Vim GUI
	set lines=999 columns=999

	set keywordprg=MANPAGER=more\ man\ -a\  " command to be used for the K command
else
	" print font for Console mode
	let s:pfn = 'Courier'

	if (&term == "pcterm") || (&term == "win32")
		" if exists("+guicursor")
		" Console cursor shape (Windows only)
		set guicursor=n-v-c:block,o:hor50,i-ci:hor15,r-cr:hor30
		set guicursor+=sm:block,a:blinkwait750-blinkoff750-blinkon750

	elseif &term == "linux"
		" don't try running CSApprox on Linux text-only console
		let g:CSApprox_loaded = 1

		" avoid some line-depth screwups
		if &lines > 47
			set lines=47
		endif

	elseif &term == "mlterm"	" the true-bidi terminal
		let &t_kb = "\x7F"	" termcap patch for mlterm backspace key
	endif

	" some more Console-mode-only settings
	set keywordprg=man
	set title titleold= titlestring=%t\ -\ VIM
	" change cursor color for Insert (commented out, doesn't work for me)
	if &term == 'xterm' && 0
		let &t_SI = "\e]12;CursorShape=1\x07"
		let &t_EI = "\e]50;CursorShape=0\x07"
	endif
endif	" has("gui_running") ... else ...

" override previous 'keywordprg' settings if not on Unix
if !has('unix')
	set keywordprg=:help
endif

" printer settings
if has("printer")
	set popt=duplex:off,formfeed:y
	let &pfn = s:pfn
endif

" switch to UTF-8 if possible (and not already done by the OS)
if has("multi_byte")
	let g:locale_encoding = &encoding
	if &encoding !~? '^u'		" ... if not already Unicode ...
		if &termencoding == ""
			let &termencoding = &encoding
		endif
		set encoding=utf-8
	endif
	set fileencodings=ucs-bom,utf-8,latin1
	setg bomb fileencoding=utf-8
"	if has("printer")
"		set penc=utf-8
"	endif
endif

" additional options
set autowriteall			" save (if possible) when |abandon|ing a file
set backup				" back up old versions
if has('writebackup')			" but only if not equipped with the more advanced 'writebackup'
	set nobackup writebackup
endif

" indent settings (we do NOT want filetype-related indent)
set autoindent
if has('smartindent')
	set smartindent
endif

set errorbells visualbell			" use both audio and visual bell
if 1			" has arithmetic evaluation
	let &t_vb = "\x07" . &t_vb		" 07 is the BEL character, rings the terminal bell
endif
if has('autocmd') && has('gui')
	" must set it again for the GUI
	au GUIEnter * let &t_vb = "\<C-G>\e|50f"
	" where 50 is the flash time in milliseconds
endif

if exists("+modelines")
	" the following is required because of SuSE's paranoid /etc/vimrc
	" and to force 'modeline' on even for root in Vim 7.0.237 and later
	set modeline modelines=5
	" the following disables a dangerous modeline in one helpfile
	" shipped with some obsolete versions of Vim
	if has ('autocmd')
		au BufReadPost ada.txt setl nomodeline ft=help
	endif
endif

set report=0		" report # of :substitute changes even if only one
set nojoinspaces	" don't use double spaces (e.g. after periods) when joining
set selection=inclusive keymodel=startsel selectmode=key	" :behave tonymec	;-)
set laststatus=2	" always display bottom status line
set display=lastline	" if the last line (with 'wrap') overshoots the window bottom,
			" display as much of it as possible
set timeout timeoutlen=5000 ttimeoutlen=100	" timeouts: 0.1s on keycodes, 5s on mappings
set scrolloff=3		" display at least 3 lines of context above & below cursor if possible
set nrformats=		" have ^A and ^X increment/decrement only in decimal
set formatoptions-=c	" autowrap comments using textwidth
set tags=tags,./tags	" ignore emacs-style tagfiles by default

" set 'list' and 'listchars' options
set list listchars=eol:$		" $ should work on all 8-byte encodings
if has('multi_byte')
	set listchars=eol:		" on multibyte Vim (where 'encoding' is UTF-8)
					" we can use the prettier Pilcrow mark
endif
set listchars+=tab:\|_			" show tabs as |_______|_______
silent! set listchars+=nbsp:~		" show no-break space as tilde if supported
" silent! set listchars+=precedes:<,extends:>

set ignorecase smartcase	" ignore case when search text is all-lowercase

" case adjust in Insert completion
if exists("+infercase")
	set infercase
endif

" add atsign to 'isfname' characters
set isfname+=@-@

" path search settings
if has('file_in_path')
	set path=.,,
	if has('path_extra')
		set path^=$HOME/**
	else
		set path^=$HOME
	endif
endif

set whichwrap=<,>,[,],~,b,s	" allow line-wrapping on <Left> <Right> <BS> <Space> and tilde
				" beware: we map <Left> to <BS> so < is not really necessary

if has("mouse")
	set mouse=a mousemodel=popup selectmode+=mouse
endif

if exists("+cursorcolumn")
	set cuc cul
endif

if has("diff")
	set diffopt+=context:0
endif

if exists("+imsearch")
	setg ims=-1	" set 'imsearch' to mimic 'iminsert' by default
endif

" set up Rolodex Vim
if has("windows")
    " this one must be set before loading files or running a session script
    " in case we want to open many windows
    set wmh=0
    if has("autocmd")
      augroup rolodex
	au VimEnter * set noea wh=99999 hh=99999 cwh=99999
      augroup vimrclocal
    else
	set noea wmh=0 wh=99999 hh=99999 cwh=99999
    endif
endif

" display up to 4 combining chars merged with a given spacing char
if exists("+maxcombine")
	set mco=4
endif

" allow removing combining chars one-by-one
if exists("+delcombine")
	set deco
endif

" set 'wildmenu' option, to get completion-by-menu (on the status line when hitting Tab)
if has("wildmenu")
	set wildmenu wildmode=longest:full,full
else
	set wildmode=longest,list:longest,full
endif

if has("wildignore")
	set wildoptions=tagfile		" display tag kind if possible
endif

if exists("+clipboard")
	set clipboard=exclude:cons\\\|linux
"	if has('multi_byte') && has('gui_gtk2') && (((version == 702) && has('patch201')) || (version > 702))
"		set clipboard^=html
"	endif
endif

if has('cscope')
	set cst
	if has('quickfix')
		set csqf=s-,c-,d-,i-,t-,e-
	endif
	if version < 700
		cnoreabbrev csf cs find
		cnoreabbrev csk cs kill
		cnoreabbrev css cs show
		cnoreabbrev csh cs help
	else
		cnoreabbrev <expr> csa ((getcmdtype() == ':' && getcmdpos() <= 4)? 'cs add'  : 'csa')
		cnoreabbrev <expr> csf ((getcmdtype() == ':' && getcmdpos() <= 4)? 'cs find' : 'csf')
		cnoreabbrev <expr> csk ((getcmdtype() == ':' && getcmdpos() <= 4)? 'cs kill' : 'csk')
		cnoreabbrev <expr> css ((getcmdtype() == ':' && getcmdpos() <= 4)? 'cs show' : 'css')
		cnoreabbrev <expr> csh ((getcmdtype() == ':' && getcmdpos() <= 4)? 'cs help' : 'csh')
	endif
	command -bar Cscope cs add $VIMSRC/src/cscope.out $VIMSRC/src
	set csverb
endif

if exists("+guioptions")
	set go-=a go-=e go+=tc
	" remove a	no autoselect to * register
	" remove e	always use text-style tabs
	" add    t	include tearoff menu items if possible
	" add    c	avoid popup dialogs for small choices
endif

if exists("+guiheadroom")
	set ghr=0
endif

" define our text-style tabline
" this is adapted (with some enhancements) from the example at :help setting-tabline
if exists("+showtabline")
	function MyTabLine()
		let s = ''
		let t = tabpagenr()
		let i = 1
		while i <= tabpagenr('$')
			let buflist = tabpagebuflist(i)
			let winnr = tabpagewinnr(i)
			let s .= '%' . i . 'T'
			let s .= (i == t ? '%1*' : '%2*')
			let s .= ' '
			let s .= i . ':'
			let s .= winnr . '/' . tabpagewinnr(i,'$')
			let s .= ' %*'
			let s .= (i == t ? '%#TabLineSel#' : '%#TabLine#')
			let file = bufname(buflist[winnr - 1])
			let file = fnamemodify(file, ':p:t')
			if file == ''
				let file = '[No Name]'
			endif
			let s .= file
			let i = i + 1
		endwhile
		let s .= '%T%#TabLineFill#%='
		let s .= (tabpagenr('$') > 1 ? '%999XX' : 'X')
		return s
	endfunction
	set stal=2
	set tabline=%!MyTabLine()
"	map	<F10>	:tabnext<CR>
"	map!	<F10>	<C-O>:tabnext<CR>
"	map	<S-F10>	:tabprev<CR>
"	map!	<S-F10>	<C-O>:tabprev<CR>
endif

" when splitting, put new window after current by default
if exists("+splitbelow")
	set splitbelow
endif
if exists("+splitright")
	set splitright
endif

" avoid too-frequent "more?" prompts
if &cmdheight < 2
	set cmdheight=2
endif

" custom status line, see :help 'statusline' for details
if has("statusline")
	set statusline=%<%f\ %h%m%r%=%k[%{(&fenc\ ==\ \"\"?&enc:&fenc).(&bomb?\",BOM\":\"\")}][U+%04B]\ %-12.(%l,%c%V%)\ %P
endif

" session options
if has('mksession')
	set ssop-=curdir ssop+=sesdir,globals,localoptions
endif

" highlight syntax all the way, even on very long lines
if exists("+synmaxcol")
	set synmaxcol=0
endif

if exists("+completeopt")
	set completeopt=menuone,preview
endif

" history and viminfo options
set history=500
if has('viminfo')
	set vi-=h vi+=!,%
	if has("unix")
		set vi+=r/media/dvdrecorder,r/mnt/floppy
	else
		set vi+=ra:,rb:
	endif
endif

if 1			" only if has arithmetic evaluation
	" netrw settings
	let netrw_alto		= 1
	let netrw_altv		= 1
	let netrw_liststyle	= 1
	" let netrw_keepdir	= 0
	let netrw_longlist	= 1
	let netrw_mousemaps	= 0
	let netrw_noretmap	= 1	" disable going back by double clicking
	let netrw_timefmt	= '%a %d %b %Y %T'

	" syntax settings for shell syntax
	let is_bash		= 1 " our 'sh' Bourne shell is alias to bash
	let sh_fold_enabled	= 7 " enable all kinds of syntax folding
endif

" Mappings and abbreviations

" make Ctrl-arrows move by words not WORDS
" (like they already do in Insert mode).
map	<C-Left>	b
map	<C-Right>	w

if exists('+iminsert')
	" map F8 to toggle keymap (Ctrl-^ not present on keyboard)
	noremap  <F8> :let &l:iminsert = ! &l:iminsert<CR>
	lnoremap <F8> <C-O>:let &l:iminsert = ! &l:iminsert<CR>
	noremap! <F8> <C-O>:let &l:iminsert = ! &l:iminsert<CR>
	cnoremap <F8> <C-^>
endif

" unmap ZZ (exit). We have :qa anyway.
map ZZ <Nop>

set wildcharm=<C-T>		" or any key not needed in Command-line mode
if has('menu')
	" override Ctrl-Z (minimize) by a text-mode menu
	map <C-Z> :emenu <C-T>
	imap <C-Z> <C-O>:emenu <C-T>
endif
" F9		follow help link
map	<F9>	<C-]>
" F9		terminate abbreviation
map!	<F9>	<C-]>
" F11		go to next window
" Shift-F11	go to previous window
" (with count) F11 or Shift-F11 both go to nth window
map	<F11>	<C-W>w
map!	<F11>	<C-O><C-W>w
map	<S-F11>	<C-W>W
map!	<S-F11>	<C-O><C-W>W
" move current window up and down
noremap	<C-W>X	<C-W>W<C-W>x
noremap	<C-W>x	<C-W>x<C-W>w
" F2		go to next quickfix line
" Shift-F2	go to previous quickfix line
map	<F2>	:cnext<CR>zv
map	<S-F2>	:cprev<CR>zv
" F4		paste clipboard after last line
" Shift-F4	paste clipboard before 1st line
" omitted if clipboard is inaccessible or not compiled-in
if has('autocmd')
	au VimEnter *
		\ if clipboard_present
			\ | exe 'map	<F4>	:$put +<CR>'
			\ | exe 'map	<S-F4>	:0put +<CR>'
			\ | exe 'imap	<F4>	<C-O>:$put +<CR>'
			\ | exe 'imap	<S-F4>	<C-O>:0put +<CR>'
		\ | endif
endif
" F3		save our work
map	<F3>	:wa<Bar>wv<CR>
imap	<F3>	<C-O>:wa<Bar>wv<CR>
map	<S-F3>	8<Bar>v/\.<CR>hy/\/<C-R>"\.<CR>
imap	<S-F3>	<Esc>8<Bar>v/\.<CR>hy/\/<C-R>"<CR>a
if 1
	function Fortune()
		" In order to remember them in the viminfo,
		" the first two variables defined below
		" must have names starting with an uppercase letter
		" and containing no lowercase letters.
		if !exists("g:FORTUNE")
			let g:FORTUNE = 0
		endif
		if !exists("g:FORTUNECYCLE")
			let g:FORTUNECYCLE = 5
		endif
		if !exists("s:sysFortunes")
			let s:sysFortunes =
			\ (system("which fortune") != "") && (!v:shell_error)
		endif
		if !exists("s:bramFortunes")
			let s:bramFortunes =
			\ filereadable(expand("~/fortunes.txt"))
		endif
		if s:sysFortunes && (g:FORTUNE || (!s:bramFortunes))
			let @+ = "-- \n" . system("fortune -a")
		elseif s:bramFortunes
			new ~/fortunes.txt
			silent 1;/^-- $/-1d +
			$put +
			wq
		else
			let @+ = ""
		endif
		let g:FORTUNE = g:FORTUNE + 1
		if g:FORTUNE >= g:FORTUNECYCLE
			let g:FORTUNE = 0
		endif
		return @+
	endfunction
map <F5> :echo Fortune()<CR>
endif
"
" Up, Down	move up/down by "screen lines"
" j k 		(default) move down/up by "file lines"
map	<Down>	gj
map	<Up>	gk
" if exists("*pumvisible")
"	inoremap <expr>	<Down>	pumvisible() ? "\<lt>Down>" : "\<lt>C-O>gj"
"	inoremap <expr>	<Up>	pumvisible() ? "\<lt>Up>"   : "\<lt>C-O>gk"
" else
"	inoremap	<Down>	<C-O>gj
"	inoremap	<Up>	<C-O>gk
"endif

" scroll mouse by single lines
if has('mouse')
	noremap		<MouseUp>	<C-E>
	inoremap	<MouseUp>	<C-O><C-E>
	noremap		<MouseDown>	<C-Y>
	inoremap	<MouseDown>	<C-O><C-Y>
endif

" make left-arrow work over indent/eol/start
noremap	<Left>	<BS>
" open help window at bottom unless :help typed in full
if version < 700
	cnoreabbrev	h	bot h
else
	cnoreabbrev	<expr>	h	((getcmdtype() == ':' && getcmdpos() <= 2)? 'bot h' : 'h')
endif
map	<F1>	:bot help<CR>
" map Ctrl-L to invoke :diffupdate when in diff mode (disabled)
" if has("diff")
" 	map	<C-L>	:if &diff <Bar> diffu <Bar> else <Bar> redraw <Bar> endif <CR>
" 	imap	<C-L>	<C-O>:if &diff <Bar> diffu <Bar> else <Bar> redraw <Bar> endif <CR>
" endif

" Make a simple "search" text object.
" With the cursor at the start of the current match, move to the end of the
" same match; then remove the newly added //e from the search history, so that
" n will find the _next_ match
if 1 " has expression evaluation
	vnoremap <silent> s //e<C-R>=&selection == 'exclusive' ? '+1' : ''<CR><CR>
		\:<C-U>call histdel('search',-1)<Bar>let @/ = histget('search',-1)<CR>gv
	omap s :normal vs<CR>
endif

" Ctrl-K comma colon (in Insert mode): UTF-8 single-codepoint ellipsis "..."
" disregard error if (for instance) not in UTF-8
if has("digraphs")
	silent!	dig	,:	8230		" HORIZONTAL ELLIPSIS
	silent!	dig	qi	64259		" LATIN SMALL LIGATURE FFI
	silent!	dig	ql	64260		" LATIN SMALL LIGATURE FFL
endif

if has('insert_expand')
	" mappings for ordinary Insert-mode completion
	inoremap	<F12>		<C-X><C-N>
	inoremap	<S-F12>		<C-X><C-P>
	" mapping for Omni completion
	inoremap	<F6>		<C-X><C-O>
endif

" repeat latest substitute
map		:&&<CR>
" find non-UTF8 in 8-bit files
map		8g8

" the following are to force-break autocomplete on these keys
inoremap	<C-Y>	<Space><BS><C-Y>
inoremap	<C-E>	<Space><BS><C-E>
" Add some undo points in Insert mode
imap	<CR>		<CR><Up><Down>
imap	<Space>		<Space><Left><Right>
imap	<Tab>		<Tab><Left><Right>

if has("user_commands")
	command -nargs=0 -bar WhatSyntax echomsg synIDattr(synID(line("."),col("."),0),"name") synIDattr(synIDtrans(synID(line("."),col("."),0)),"name") synIDattr(synID(line("."),col("."),1),"name") synIDattr(synIDtrans(synID(line("."),col("."),1)),"name")
	command -nargs=0 -bar -bang -range -reg Put exe ((<q-bang> == '!') ? <q-line1> : <q-line2>) . 'put' . <q-bang> <q-reg>
	command -nargs=* -bar -bang -range Iline <line1>,<line2>Put<bang> =<q-args>
endif

if has('autocmd')
	augroup END
endif

if 1
  finish
endif
" the following is only for Vim versions without expression evaluation
runtime! plugin/zzsplash.vim

			61.2.2.2 http://users.skynet.be/antoine.mechelynck/other/almost-default.vim
" Vim color file
" Maintainer:   Tony Mechelynck <antoine.mechelynck@gmail.com>
" Last Change:  2009 Oct 28
" This is almost the default color scheme.  It doesn't define the Normal
" highlighting, it uses whatever the colors used to be.

" Only the highlight groups named below are defined; the rest
" are left at their compiled-in default settings.

let s:colors_name = "almost-default"
if exists("g:debug") && g:debug
  echomsg s:colors_name "start"
endif

" Set 'background' back to the default.  The value can't always be estimated
" and is then guessed.
hi clear Normal
set bg&

" Remove all existing highlighting and set the defaults.
hi clear

" Load the syntax highlighting defaults, if it's enabled.
if exists("syntax_on")
  syntax reset
endif

" Set our own highlighting settings
hi SpecialKey                   guibg=NONE
" white on red is not always distinct in the GUI: use black on red then
hi Error                        guibg=red           guifg=black
hi clear ErrorMsg
hi link  ErrorMsg       Error
" display matchit messages
hi def link MatchError  WarningMsg
" show cursor line/column (if enabled) in very light grey in the GUI,
" underlined in the console
if has("gui_running")
  hi clear CursorLine
  hi CursorLine                 guibg=#F4F4F4
endif
hi clear CursorColumn
hi link  CursorColumn   CursorLine
" do not make help bars and stars invisible
hi clear helpBar
hi link  helpBar        helpHyperTextJump
hi clear helpStar
hi link  helpStar       helpHyperTextEntry
" the following were forgotten in the syntax/vim.vim (and ended up cleared)
hi clear vimVar
hi link  vimVar         Identifier
hi clear vimGroupName
hi link  vimGroupName   vimGroup
hi clear vimHiClear
hi link  vimHiClear     vimHighlight
" in the GUI only, display the Ignore group as very slightly visible
hi clear Ignore
  exe "hi Ignore term=NONE guibg=white guifg=#999999 ctermbg=NONE ctermfg="
    \ . (&bg == "dark" ? "black" : "white")
" display the status line of the active window in a distinctive color:
" bold black on bright red in the GUI, white on green in the console
" (where the bg is never bright, and dark red is sometimes an ugly sort
" of reddish brown).
hi StatusLine   gui=NONE,bold   guibg=red           guifg=black
        \       cterm=NONE,bold ctermbg=darkgreen   ctermfg=white
hi WildMenu     gui=NONE,bold   guibg=green         guifg=black
        \       cterm=NONE,bold ctermbg=black       ctermfg=white
" make the status line bold-reverse (but B&W) for inactive windows
hi StatusLineNC gui=reverse,bold
        \       cterm=NONE      ctermbg=black       ctermfg=lightgrey
" make the active status line colours alternate between two settings
" to give a visual notice of the CursorHold/CursorHoldI events
if ! exists("s:statuslineflag")
  let s:statuslineflag = 0
endif
"
" The following 'fancy footwork' is needed to have our CursorHold autocommand
" work smoothly with 256-color cterms handled by the 3rd-party csapprox.vim plugin
if exists('g:CSApprox_approximator_function')
    let s:ctbg1 = g:CSApprox_approximator_function(0,   255, 0) " green
    let s:ctbg2 = g:CSApprox_approximator_function(255, 0,   0) " red
    let s:ctfg  = g:CSApprox_approximator_function(0,   0,   0) " black
else
    let s:ctbg1 = 'darkgreen'
    let s:ctbg2 = 'black'
    let s:ctfg  = 'white'
endif

function! ToggleStatusLine()
    if s:statuslineflag
        exe 'hi StatusLine'
          \     'cterm=NONE,bold ctermbg=' . s:ctbg1 'ctermfg=' . s:ctfg
          \     'gui=NONE,bold   guibg=green          guifg=black'
        exe 'hi WildMenu'
          \     'cterm=NONE,bold ctermbg=' . s:ctbg2 'ctermfg=' . s:ctfg
          \     'gui=NONE,bold   guibg=red            guifg=black'
    else
        exe 'hi StatusLine'
          \     'cterm=NONE,bold ctermbg=' . s:ctbg2 'ctermfg=' . s:ctfg
          \     'gui=NONE,bold   guibg=red            guifg=black'
        exe 'hi WildMenu'
          \     'cterm=NONE,bold ctermbg=' . s:ctbg1 'ctermfg=' . s:ctfg
          \     'gui=NONE,bold   guibg=green          guifg=black'
    endif
    let s:statuslineflag = ! s:statuslineflag
endfunction

exe "augroup" s:colors_name
    au! CursorHold,CursorHoldI * call ToggleStatusLine()
    au! ColorScheme *
        \ if g:colors_name != s:colors_name | exe "au!" s:colors_name | endif
augroup END

" define colors for the tab line:
" file name of unselected tab
hi TabLine      gui=NONE        guibg=#EEEEEE       guifg=black
        \       cterm=NONE,bold ctermbg=lightgrey   ctermfg=white
" file name of selected tab (GUI default is bold black on white)
hi TabLineSel   cterm=NONE,bold ctermbg=green       ctermfg=white
" fillup and tab-delete "X" at right
hi TabLineFill  gui=NONE,bold   guibg=#CCCCCC       guifg=#990000
        \       cterm=NONE      ctermbg=lightgrey   ctermfg=red
" tab and file number 1:2/3 (meaning "tab 1: window 2 of 3) for selected tab
hi User1        gui=bold        guibg=white         guifg=magenta
        \                       ctermbg=green       ctermfg=black
" tab and file number 1:2/3 for unselected tab
hi User2                        guibg=#EEEEEE       guifg=magenta
        \                       ctermbg=lightgrey   ctermfg=black
" additional override for manpages  la Dr. Chip
hi manSubSectionStart           guibg=white         guifg=yellow
        \                       ctermbg=black       ctermfg=darkblue

" remember the current colorscheme name
let g:colors_name = s:colors_name
if 0
" the following is required e.g. if we have debug on
if exists("syntax_on")
  syntax on
endif

if exists("g:debug") && g:debug
  echomsg s:colors_name "end"
endif
endif

" vim: sw=2 et

			61.2.2.3
		61.2.3

	61.3

62. Colorschemes

	62.1 h colorscheme
						*:colo* *:colorscheme* *E185*
:colo[rscheme]		Output the name of the currently active color scheme.
			This is basically the same as >
				:echo g:colors_name
<			In case g:colors_name has not been defined :colo will
			output "default".  When compiled without the |+eval|
			feature it will output "unknown".

:colo[rscheme] {name}	Load color scheme {name}.  This searches 'runtimepath'
			for the file "colors/{name}.vim.  The first one that
			is found is loaded.
			To see the name of the currently active color scheme: >
				:colo
<			The name is also stored in the g:colors_name variable.
			Doesn't work recursively, thus you can't use
			":colorscheme" in a color scheme script.
			After the color scheme has been loaded the
			|ColorScheme| autocommand event is triggered.
			For info about writing a colorscheme file: >
				:edit $VIMRUNTIME/colors/README.txt

				"
:hi[ghlight]		List all the current highlight groups that have
			attributes set.

:hi[ghlight] {group-name}
			List one highlight group.

:hi[ghlight] clear	Reset all highlighting to the defaults.  Removes all
			highlighting for groups added by the user!
			Uses the current value of 'background' to decide which
			default colors to use.

:hi[ghlight] clear {group-name}
:hi[ghlight] {group-name} NONE
			Disable the highlighting for one highlight group.  It
			is _not_ set back to the default colors.

:hi[ghlight] [default] {group-name} {key}={arg} ..
			Add a highlight group, or change the highlighting for
			an existing group.
			See |highlight-args| for the {key}={arg} arguments.
			See |:highlight-default| for the optional [default]
			argument.

Normally a highlight group is added once when starting up.  This sets the
default values for the highlighting.  After that, you can use additional
highlight commands to change the arguments that you want to set to non-default
values.  The value "NONE" can be used to switch the value off or go back to
the default value.

A simple way to change colors is with the |:colorscheme| command.  This loads
a file with ":highlight" commands such as this: >

   :hi Comment	gui=bold

Note that all settings that are not included remain the same, only the
specified field is used, and settings are merged with previous ones.  So, the
result is like this single command has been used: >
   :hi Comment	term=bold ctermfg=Cyan guifg=#80a0ff gui=bold
<
							*:highlight-verbose*
When listing a highlight group and 'verbose' is non-zero, the listing will
also tell where it was last set.  Example: >
	:verbose hi Comment
<	Comment        xxx term=bold ctermfg=4 guifg=Blue ~
	   Last set from /home/mool/vim/vim7/runtime/syntax/syncolor.vim ~

When ":hi clear" is used then the script where this command is used will be
mentioned for the default values. See |:verbose-cmd| for more information.

					*highlight-args* *E416* *E417* *E423*
There are three types of terminals for highlighting:
term	a normal terminal (vt100, xterm)
cterm	a color terminal (MS-DOS console, color-xterm, these have the "Co"
	termcap entry)
gui	the GUI

For each type the highlighting can be given.  This makes it possible to use
the same syntax file on all terminals, and use the optimal highlighting.


	62.2

63. From books

	63.1 From vimbook-OPL

		63.1.1 help
Finally, there’s one more important command, the help command.To get help, enter
the following:
:help
:h

If you don’t supply a subject, :help displays the general help window.The creators of Vim did something very clever (or very lazy) with the help system.
They made the help window a normal editing window.You can use all the normal Vim commands to move through the help information.
Therefore h, k, j, and l move left, up, down, right, and so on.
To get out of the help system, use the same command you use to get out of the editor: ZZ. Or ctrl-W q

As you read the help text, you will notice some text enclosed in vertical bars (for example, |:help|).This indicates a hyperlink. If you position the cursor anywhere between the bars and press CTRL+] (jump to tag), the help system takes you to the indicated subject.
(For reasons not discussed here, the Vim terminology for a hyperlink is tag. So CTRL+] jumps to the location of the tag given by the word under the cursor.)
After a few jumps, you might want to go back. CTRL+T (pop tag) takes you back to the preceding screen. Or in Vim terms, it “pops a tag off the tag stack.”
At the top of this screen, there is the notation *help.txt*.This is used by the help system to define a tag (hyperlink destination). Chapter 7, “Commands for Programmers,” explains tags in detail.
To get help on a given subject, use the following command:
:help subject
To get help on the x command, for example, enter the following:
:help x
To find out how to delete text, use this command:
:help deleting
To get a complete index of what is available, use the following command:
:help index
When you need to get help for a control character command (for example, CTRL-A,
you need to spell it with the prefix CTRL-.
:help CTRL-A
The Vim editor has many different modes. By default, the help system displays the normal-mode commands. For example, the following command displays help for
the normal-mode CTRL-H command:
:help CTRL-H

To identify other modes, use a mode prefix.
If you want the help for the insert-mode version of this command, prefix the key
with i_.This gives you the following command:
:help i_CTRL-H
Table 1.1 lists several other mode prefixes.

When you start the Vim editor, you can use several command-line options.These
all begin with a dash (-).To find what the -t command-line option does, for example,
use the command
:help -t
The Vim editor has a number of options that enable you to configure and customize
the editor. If you want help for an option, you need to enclose it in single quotation
marks.To find out what the number option does, for example, use the following
command:
:help ‘number’
The following table summarizes the special prefixes.
Table 1.1 Help Prefixes
What Prefix Example
Normal-mode commands (nothing) :help x
Control character CTRL- :help CTRL-u
Visual-mode commands v :help v_u
Insert-mode commands i :help i_<Esc>
ex-mode commands : :help :quit
Command-line editing c :help c_<Del>
Vim command arguments - :help -r
Options ‘ (both ends) :help ‘textwidth’
Special keys are enclosed in angle brackets.To find help on the up-arrow key, for
instance, use this command:
:help <Up>
Appendix B, “The <> Key Names,” provides a complete list of the key names.
Other Ways to Get Help
You can get to the help screen by pressing the <F1> key.This displays the general
help screen, and you can navigate from there. If your keyboard has a <Help> key, you
can use it as well.

		63.1.2 Using a Count to Edit Faster
Suppose you want to move up nine lines.You can type kkkkkkkkk or you can enter
the command 9k.
In fact, you can precede all the movement commands with a number. Earlier in this
chapter, for instance, you added three exclamation points to the end of a line by typing
a!!!<Esc>. Another way to do this is to use the command 3a!<Esc>.The count of
3 tells the a command to insert what follows (!) three times.
Similarly, to delete three characters, use the command 3x.

ex: 120i*<esc> - insert 120* as below
************************************************************************************************************************

replace 5 chars, 5ra, ex:
5ib:
bbbbb 

b5ra:
aaaaa

		63.1.3 Moving to the Start or End of a Line
The $ command moves the cursor to the end of a line. Actually, a bunch of keys
map to the “end-of-line” command.The Vim names for these keys are $, <End>,
and <kEnd>. (The <kEnd> key is Vim’s name for the keypad End key.)
The $ command takes a numeric argument as well. If present, it causes the editor to
move to the end of the next line. For example, 1$ moves you to the end of the first
line (the one you’re on), 2$ to the end of the next line, and so on. 
The ^ command moves to the first nonblank character of the line.The <Home> or
<kHome> key moves to the first character of the line. (The 0
[zero] command does the same thing.)
Like every other command previously discussed, these three commands can take a
numeric argument.They do not do anything with it, but you can specify it if you
want to.

both $ and ^ can be preceded by [-]N to jump to end/start of N lines [backward]forward

		63.1.4 Scrolling Up and Down

The CTRL-U command scrolls up half a screen of text. (Up in this case is backward in
the file; the text moves down on the screen. Don’t worry if you have a little trouble
remembering which end is up. Most programmers have the same problem.)
The CTRL-D command scrolls you down half a screen.

full screen down/up CTRL-F / CTRL-B 

		63.1.5 f,F,t,T revised
Note that they are useful not only for jumping around. They're also considered as motion so go along with all the commands the expect motion.

Ex. d a <> tag,
<aaa> klklk <\aaa>
go to first < and dype df> then go to next < and press .

		63.1.6 Saving Your Setting
After performing all your :map, :abbreviate, and :set commands, it would be nice if
you could save them and use them again.
The command :mkvimrc writes all your settings to a file.The format of this command
is as follows:
:mkvimrc file
file is the name of the file to which you want to write the settings.
You can read this file by using the following command:
:source file
During startup, the Vim editor looks for an initialization file. If it is found, it is automatically
executed. (Only the first file found is read.)
The initialization files are as follows:
UNIX
$HOME/.vimrc
$HOME/_vimrc
$HOME/.exrc
$HOME/_exrc
MS-DOS
$HOME/_vimrc
$HOME/.vimrc
$VIM/_vimrc
$VIM/.vimrc
$HOME/_exrc
$HOME/.exrc
$VIM/_exrc
$VIM/.exrc
When you are running the GUI version, some other files are also read.The gvimrc
file is found in the same location as the vimrc files mentioned in the list.The
$VIMRUNTIME/menu.vim is read too.
One way you can find out which initialization files are read is to use the :version
command:
:version
In the middle of all the junk it lists out is a list of the initialization files .
----------------------------------------------------------------------------------------------------
:version
VIM - Vi IMproved 7.3 (2010 Aug 15, compiled Aug 16 2010 12:01:47)
Compiled by yizaq@yizaq-lnx
Huge version with GTK2 GUI.  Features included (+) or not (-):
+arabic +autocmd +balloon_eval +browse ++builtin_terms +byte_offset +cindent +clientserver +clipboard +cmdline_compl
+cmdline_hist +cmdline_info +comments +conceal +cryptv +cscope +cursorbind +cursorshape +dialog_con_gui +diff +digraphs +dnd
-ebcdic +emacs_tags +eval +ex_extra +extra_search +farsi +file_in_path +find_in_path +float +folding -footer +fork() +gettext
-hangul_input +iconv +insert_expand +jumplist +keymap +langmap +libcall +linebreak +lispindent +listcmds +localmap -lua +menu
+mksession +modify_fname +mouse +mouseshape +mouse_dec +mouse_gpm -mouse_jsbterm +mouse_netterm -mouse_sysmouse +mouse_xterm
+multi_byte +multi_lang -mzscheme +netbeans_intg -osfiletype +path_extra +perl +persistent_undo +postscript +printer +profile
+python -python3 +quickfix +reltime +rightleft -ruby +scrollbind +signs +smartindent -sniff +startuptime +statusline
-sun_workshop +syntax +tag_binary +tag_old_static -tag_any_white -tcl +terminfo +termresponse +textobjects +title +toolbar
+user_commands +vertsplit +virtualedit +visual +visualextra +viminfo +vreplace +wildignore +wildmenu +windows +writebackup +X11
 -xfontset +xim +xsmp_interact +xterm_clipboard -xterm_save
   system vimrc file: "$VIM/vimrc"
     user vimrc file: "$HOME/.vimrc"
      user exrc file: "$HOME/.exrc"
  system gvimrc file: "$VIM/gvimrc"
    user gvimrc file: "$HOME/.gvimrc"
    system menu file: "$VIMRUNTIME/menu.vim"
  fall-back for $VIM: "/usr/local/share/vim"
Compilation: gcc -c -I. -Iproto -DHAVE_CONFIG_H -DFEAT_GUI_GTK  -DXTHREADS -D_REENTRANT -DXUSE_MTSAFE_API -I/usr/include/gtk-2.0
 -I/usr/lib/gtk-2.0/include -I/usr/X11R6/include -I/usr/include/atk-1.0 -I/usr/include/pango-1.0 -I/usr/include/freetype2 -I/usr
/include/freetype2/config -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include     -g -O2  -I/usr/X11R6/include
Linking: gcc  -L/usr/X11R6/lib   -rdynamic   -L/usr/local/lib -o vim   -Wl,--export-dynamic -lgtk-x11-2.0 -lgdk-x11-2.0 -latk-1.
0 -lgdk_pixbuf-2.0 -lpangoxft-1.0 -lpangox-1.0 -lpango-1.0 -lgobject-2.0 -lgmodule-2.0 -lglib-2.0   -lXt -lncurses -lselinux  -l
acl -lgpm -rdynamic  /usr/cisco/packages/perl/perl-5.8.6/lib/5.8.6/i686-linux/auto/DynaLoader/DynaLoader.a -L/usr/cisco/packages
/perl/perl-5.8.6/lib/5.8.6/i686-linux/CORE -lperl -lcrypt -lutil -lc -L/usr/lib/python2.3/config -lpython2.3 -lpthread -lutil -l
m -Xlinker -export-dynamic
----------------------------------------------------------------------------------------------------
One other initialization file has not yet been discussed: .exrc.The old Vi editor used
this file for initialization.This is only read if Vim cannot find any other initialization
file. Because the old Vi program does not understand many of the Vim commands,
you will probably want to put everything in the .vimrc file.
The :mkexrc command writes the mappings to the .exrc file. If you want to use all
the power of Vim, however, you must use the :mkvimrc command instead.

		63.1.7 The :shell Command
The :shell command takes you to the command prompt.You can return to Vim by
executing the exit command.
For example:
:shell
$ date
Mon Jan 17 18:55:45 PST 2000
$ exit

		63.1.8 Inserting Text
If you type CTRL-A, the editor inserts the text you typed the last time you were in
insert mode.
Assume, for example, that you have a file that begins with the following:
“file.h”
/* Main program begins */
You edit this file by inserting #include at the beginning of the first line:
#include “file.h”
/* Main program begins */
You go down to the beginning of the next line using the command j^.You now start
to insert a new line that contains a new include line. So you type iCTRL-A.The result
is as follows:
#include “file.h”
#include /* Main program begins */
The #include was inserted because CTRL-A inserts the contents of the previous insert.
Now you type “main.c”<Enter> to finish the line:
#include “file.h”
#include “main.h”
/* Main program begins */
The CTRL-@ command does a CTRL-A and then exits insert mode.
The CTRL-V command is used to quote the next character. In other words, any
special meaning the character has, it will be ignored. For example, CTRL-V<Esc> inserts
an escape.You can also use the command CTRL-Vdigits to insert the character
number digits. For example, the character number 64 is @. So CTRL-V64 inserts @.The
CTRL-Vdigits uses “decimal” digits by default, but you can also insert the “hex” digits.
For example,
CTRL-V123
and
CTRL-Vx7b
both insert the { character.
The CTRL-Y command inserts the character above the cursor.This is useful when
you are duplicating a previous line.
One of my favorite tricks is to use ASCII art to explain complex things such as
regular expressions. For example:
[0-9]*[a-z]*
|||||||||||+—— Repeat 0 or more times
||||||+++++——- Any lower case letter
|||||+————— Repeat 0 or more times
+++++—————- Any digit

Take a look at how you can use CTRL-Y to create this file.You start by entering the
first two lines:
[0-9]*[a-z]*
|||||||||||+—— Repeat 0 or more times
Now you type CTRL-Y six times.This copies the | from the previous line down six
times:
[0-9]*[a-z]*
|||||||||||+—— Repeat 0 or more times
||||||
The CTRL-E command acts like CTRL-Y except it inserts the character below the cursor.

		63.1.9 The viminfo File

The problem with global marks is that they disappear when you exit Vim. It would be
nice if they stuck around.
The viminfo file is designed to store information on marks as well as the following:
	-> Command-line history
	-> Search-string history
	-> Input-line history
	-> Registers
	-> Marks
	-> Buffer list
	-> Global variables
The trick is that you have to enable it.This is done through the following command:
:set viminfo=string
The string specifies what to save.
The syntax of this string is an option character followed by an argument.The
option/argument pairs are separated by commas.
Take a look at how you can build up your own viminfo string.
First, the ‘ option is used to specify how many files for which you save local marks
(a–z). Pick a nice even number for this option (1000, for instance).Your viminfo
option now looks like this:
:set viminfo=’1000
The f option controls whether global marks (A–Z 0–9) are stored. If this option is 0,
none are stored. If it is 1 or you do not specify an f option, the marks are stored.You
want this feature, so now you have this:
:set viminfo=’1000,f1
The r option tells Vim about removable media. Marks for files on removable media
are not stored.The idea here is that jump to mark is a difficult command to execute if
the file is on a floppy disk that you have left in your top desk drawer at home.You can
specify the r option multiple times; therefore, if you are on a Microsoft Windows system,
you can tell Vim that floppy disks A and B are removable with the r option:
:set viminfo=’1000,f1,rA:,rB:
UNIX has no standard naming convention for floppy disks. On my system, however,
the floppy disk is named /mnt/floppy; therefore, to exclude it, I use this option:
:set viminfo=’1000,f1,r/mnt/floppy
Note
There is a 50-character limit on the names of the removable media.
The \” option controls how many lines are saved for each of the registers. By default,
all the lines are saved. If 0, nothing is saved.You like the default, so you will not be
adding a \” specification to the viminfo line.
The : option controls the number of lines of : history to save. 100 is enough for us:
:set viminfo=’1000,f1,r/mnt/floppy,:100,
The / option defines the size of the search history. Again 100 is plenty:
:set viminfo=’1000,f1,r/mnt/floppy,:100,/100
Note that Vim will never store more lines than it remembered.This is set with the
'history' option.
Generally, when Vim starts, if you have the 'hlsearch' option set, the editor highlights
the previous search string (left over from the previous editing sessions).To turn
off this feature, put the h flag in your 'viminfo' option list. (Or you can just start Vim,
see the highlighting, and decide you do not like it and execute a :nohlsearch.)
The '@' option controls the number of items to save in the input-line history. (The
input history records anything you type as result of an input function call.) For this
example, let this default to the size of the input-line history.
If the '%' option is present, save and restore the buffer list.The buffer list is restored
only if you do not specify a file to edit on the command line:
:set viminfo=’1000,f1,r/mnt/floppy,:100,/100,%
The '!' option saves and restores global variables. (These are variables whose names
are all uppercase.)
:set viminfo=’1000,f1,r/mnt/floppy,:100,/100,%,!
Finally, the n option specifies the name of the viminfo file. By default, this is
$HOME/.viminfo on UNIX. On Microsoft Windows, the file is as follows:
$HOME\_viminfo if $HOME is set
$VIM\_viminfo if $VIM is set
C:\_viminfo otherwise
The 'n' option must be the last option parameter. Because we like the default filename,
we leave this option off.Therefore, the full viminfo line is this:
:set viminfo=’1000,f1,r/mnt/floppy,:100,/100,%,!

You can put this command and other initializations into a vimrc initialization file.The
viminfo file is automatically written when the editor exits, and read upon initialization.
But you may want to write and read it explicitly.
The following command writes the viminfo file:
:wviminfo[!] [file]
If a file is specified, the information is written to that file.
Similarly, you can read the viminfo file using this command:
:rviminfo [file]
This reads all the settings from file. If any settings conflict with currently existing
settings, however, the file settings will not be used. If you want the information in the
viminfo file to override the current settings, use the following command:
:rviminfo! [file]

Note, my settings:
:set viminfo='1000,f1,<500,:500,/500,%,!

Note, this is :h viminfo & go to section 21.3
*21.3*	Remembering information; viminfo

After editing for a while you will have text in registers, marks in various
files, a command line history filled with carefully crafted commands.  When
you exit Vim all of this is lost.  But you can get it back!

The viminfo file is designed to store status information:

	Command-line and Search pattern history
	Text in registers
	Marks for various files
	The buffer list
	Global variables

Each time you exit Vim it will store this information in a file, the viminfo
file.  When Vim starts again, the viminfo file is read and the information
restored.

The 'viminfo' option is set by default to restore a limited number of items.
You might want to set it to remember more information.  This is done through
the following command: >

	:set viminfo=string

The string specifies what to save.  The syntax of this string is an option
character followed by an argument.  The option/argument pairs are separated by
commas.
   Take a look at how you can build up your own viminfo string.  First, the '
option is used to specify how many files for which you save marks (a-z).  Pick
a nice even number for this option (1000, for instance).  Your command now
looks like this: >

	:set viminfo='1000

The f option controls whether global marks (A-Z and 0-9) are stored.  If this
option is 0, none are stored.  If it is 1 or you do not specify an f option,
the marks are stored.  You want this feature, so now you have this: >

	:set viminfo='1000,f1

The < option controls how many lines are saved for each of the registers.  By
default, all the lines are saved.  If 0, nothing is saved.  To avoid adding
thousands of lines to your viminfo file (which might never get used and makes
starting Vim slower) you use a maximum of 500 lines: >

	:set viminfo='1000,f1,<500
<
Other options you might want to use:
	:	number of lines to save from the command line history
	@	number of lines to save from the input line history
	/	number of lines to save from the search history
	r	removable media, for which no marks will be stored (can be
		used several times)
	!	global variables that start with an uppercase letter and
		don't contain lowercase letters
	h	disable 'hlsearch' highlighting when starting
	%	the buffer list (only restored when starting Vim without file
		arguments)
	c	convert the text using 'encoding'
	n	name used for the viminfo file (must be the last option)

See the 'viminfo' option and |viminfo-file| for more information.

When you run Vim multiple times, the last one exiting will store its
information.  This may cause information that previously exiting Vims stored
to be lost.  Each item can be remembered only once.


GETTING BACK TO WHERE YOU STOPPED VIM

You are halfway editing a file and it's time to leave for holidays.  You exit
Vim and go enjoy yourselves, forgetting all about your work.  After a couple
of weeks you start Vim, and type:
>
	'0

And you are right back where you left Vim.  So you can get on with your work.
   Vim creates a mark each time you exit Vim.  The last one is '0.  The
position that '0 pointed to is made '1.  And '1 is made to '2, and so forth.
Mark '9 is lost.
   The |:marks| command is useful to find out where '0 to '9 will take you.


GETTING BACK TO SOME FILE

If you want to go back to a file that you edited recently, but not when
exiting Vim, there is a slightly more complicated way.  You can see a list of
files by typing the command: >

	:oldfiles
<	1: ~/.viminfo ~
	2: ~/text/resume.txt ~
	3: /tmp/draft ~

Now you would like to edit the second file, which is in the list preceded by
"2:".  You type: >

	:e #<2

Instead of ":e" you can use any command that has a file name argument, the
"#<2" item works in the same place as "%" (current file name) and "#"
(alternate file name).  So you can also split the window to edit the third
file: >

	:split #<3

That #<123 thing is a bit complicated when you just want to edit a file.
Fortunately there is a simpler way: >

	:browse oldfiles
<	1: ~/.viminfo ~
	2: ~/text/resume.txt ~
	3: /tmp/draft ~
	-- More --

You get the same list of files as with |:oldfiles|.  If you want to edit
"resume.txt" first press "q" to stop the listing.  You will get a prompt:

	Type number and <Enter> (empty cancels): ~

Type "2" and press <Enter> to edit the second file.

More info at |:oldfiles|, |v:oldfiles| and |c_#<|.


MOVE INFO FROM ONE VIM TO ANOTHER

You can use the ":wviminfo" and ":rviminfo" commands to save and restore the
information while still running Vim.  This is useful for exchanging register
contents between two instances of Vim, for example.  In the first Vim do: >

	:wviminfo! ~/tmp/viminfo

And in the second Vim do: >

	:rviminfo! ~/tmp/viminfo

Obviously, the "w" stands for "write" and the "r" for "read".
   The ! character is used by ":wviminfo" to forcefully overwrite an existing
file.  When it is omitted, and the file exists, the information is merged into
the file.
   The ! character used for ":rviminfo" means that all the information is
used, this may overwrite existing information.  Without the ! only information
that wasn't set is used.
   These commands can also be used to store info and use it again later.  You
could make a directory full of viminfo files, each containing info for a
different purpose.

		63.1.10 Advacned Visual Mode
You can yank, put, and delete commands with registers.You can do similar things with the visual-mode commands.
To delete a block of text, for instance, highlight in visual mode and then use the d command.To delete the text into a register, use the command “register d.
To yank the text into a register, use the y command.
The D and the Y commands act like their lowercase counterparts, except they work
on entire lines, whereas d and y work on just the highlighted section.

			63.1.10.1 The $ Command
In block visual mode, the $ command causes the selection to be extended to the end
of all the lines in the selection. Moving the cursor up or down extends the select text
to the end of the line.This extension occurs even if the new lines are longer than the
current ones. 

			63.1.10.2 Repeating a Visual Selection
The gv command repeats the preceding visual mode selection. If you are already in
visual mode, it selects the preceding selection. Repeated gv commands toggle between
the current and preceding selection. 
The steps are as follows:
| 1. First visual selection.
| 2. Finished with visual.
| 3. gv reselects the old visual.
| 4. Define new visual. 

			63.1.10.3 Selecting Objects
A number of commands in visual mode are designed to help you highlight the text
you want.
The aw command, for example, highlights the next word. Actually it highlights not
only the word, but also the space after it. At first this may seem a bit useless. After all,
the w command moves you forward one word, so why not just use it?
That is because when you perform a selection, the text selected is from the old
cursor location to the new one inclusive. Now if you use the w command to move, the
result is that the cursor is placed on the first character of the next word.Therefore if
you delete the text, you not only get the words you selected, but the first character of
the next word.
The aw command leaves the cursor positioned just before the first character of
the next word. In other words, it selects the word and the spaces beyond it, but not the
next word.
Another reason to use aw rather than w is that aw selects the whole word, no matter
which part of the word the cursor is on, whereas w just selects from the current location
to the end of the word.
If you want to just select the word, and nothing but the word, use the iw (inner
word) command.

You can use the following commands to select text:
countaw Select a word and the space after it.
countiw Select a word only (inner word).
countaW Select a WORD and the space after it.
countiW Select inner WORD (the word only)
countas Select a sentence (and spaces after it.)
countis Select the sentence only.
countap Select a paragraph and the following space.
countip Select a paragraph only.
counta( From within text enclosed in (), select the text up to and including
the ().
counti( Like ab, except the () characters are not selected.
counta< Select matching <> pair, include the <>.
counti< Select matching <> pair, excluding the <>.
counta[ Select matching [] pair, including the [].
counti[ Select matching [] pair, excluding the [].
counta{ Select matching {} pair, including the {}.
counti{ Select matching {} pair, excluding the {}.

			63.1.10.4 Moving to the Other End of a Selection
The o command moves the cursor to the other end of a selection.
You can then move back to the other end (where you came from) with another o.
The O command moves the cursor to the other corner of the selection in block visual
mode . In other words, the O command moves to the other end of the
selection on the same line.

			63.1.10.5 Case Changes
The ~ command inverts the case of the selection.The U command makes the text
uppercase and the u command turns the text into lowercase. 

			63.1.10.6 Joining Lines
The J command joins all the highlighted lines into one long line. Spaces are used to
separate the lines.
If you want to join the lines without adding spaces, use the gJ command.

q. vim join lines in range using global operator
|  a. To join lines in a specific range using a global operator in Vim, you can utilize the `:normal` command. Here's the process:
|  1. Open the file you want to edit in Vim.
|  2. Press `:` to enter command-line mode.
|  3. Specify the range of lines where you want to join the lines. For example, to join lines 5 to 10, you can enter `:5,10`.
|  4. After specifying the range, enter the `normal` command followed by the keystrokes you want to execute on each line. In this case, you'll use the `J` command to join lines. So, the complete command would be `:5,10normal! J`.
|  5. Press Enter to execute the command.

Vim will apply the `J` command to each line in the specified range, joining them together.

Note that the `:normal` command allows you to execute normal mode commands on multiple lines specified by a range. The `!` after `normal` is used to ensure that any mappings or abbreviations defined for `J` are ignored and the default behavior of the command is used.
			63.1.10.7 Formatting a Block
The gq command formats the text

			63.1.10.8 The Encode (g?) Command
The g? command encodes or decodes the highlighted text using the rot13 encoding.
(This primitive encoding scheme is frequently used to obscure potentially offensive
Usenet news postings.)
With rot13, if you encode something twice, you decode it.Therefore if the text is
encoded, g? decodes it. If it is in plain text, g? encodes it. 

			63.1.10.9 The Colon (:) Commands
The : command starts a command-mode command with a range already specified. If
you want to write a block to a file, for example, select the text using visual mode, and
then execute the following command:
:write block.txt
This writes the text to the file block.txt.
Note:The : command only works on whole lines.


			63.1.10.10 Pipe (!) Command
The ! command pipes a region of text through an external program. For example, the
!sort pipes the selection through the UNIX sort program.

		63.1.11 Select Mode
Select mode is yet another visual mode that allows for quick deletion or replacement
of the selected text.The way you use select mode is simple.You highlight the text and
then type <BS> to delete it. Or you can highlight the text, and then replace it by just
typing the replacement.
How does select mode compare with visual mode? With visual mode, you highlight
the text and then perform an operation. In other words, you need to end the visual
mode operation with a command.With select mode, the commands are limited to
<BS> (for delete) and printable characters (for replacement).This makes things faster
because you do not need to enter a command, but it is much more limited than visual
mode.
You can choose from three select-mode flavors.The commands to start the various
flavors of the select mode are as follows:
gh Start characterwise selection.
gH Start linewise selection.
gCTRL-H Start block selection.
Moving the cursor in select mode is a little more difficult than moving it in normal
visual mode because if you type any printable character, you delete the selected text
and start inserting.Therefore, to select text, you must use the arrow, CTRL, and
function keys.
You can also use the mouse to select text if you set the 'selectmode' option to
mouse, as follows:
:set selectmode=mouse
(Without this option, the mouse performs a visual selection rather than a select-mode
selection.)
You can also use the 'selectmode' option to let the shifted cursor keys enter select
mode.

-> After selection is made, backspace will delete it
-> After selection is made, start typing to replace
-> Switching Modes
The CTRL-O command switches from selection mode to visual mode for one command.
The CTRL-G command switches to visual mode without returning.To switch
from visual mode to select mode, use the CTRL-G command.
-> Avoiding Automatic Reselection
Usually when you select text, the text remains selected. Even if you execute a command,
	the selection remains.The gV command causes the selection to disappear after
		the command is executed.This proves extremely useful for macros that make a selection,
	do something with it, and then want it to disappear.
	
		63.1.12 Comparing Two Files, scroll two windows at same time
Suppose you want to compare two files that differ by a just a few edits.To do this, start
by opening two windows, one for each edit. Next, execute the following command in
each window:
:set scrollbind
Now when one window scrolls, so does the other. 
As you scroll through both windows, you might encounter a place where you must
move one window without moving the other.To do so, all you have to do is execute
the following command in the window you want to move and move it:
:set noscrollbind
Then to synchronize scrolling, you execute this command:
:set scrollbind

The ‘scrollopt’ option controls how ‘scrollbind’ works. It is a set of the following
keywords:
ver Vertical scrolling
hor Horizontal scrolling
jump When switching between windows, make sure the offsets are 0.
Finally, the following command synchronizes the two windows:
:syncbind
Suppose, for example, that you have been looking at two versions of a file, moving
both around.To look at some things, you turned off ‘scrollbind’. Now the files
point at two different places.
You want to go back to synchronized scrolling.You could synchronize the windows
by going to each and moving it to the right location; you let Vim do the work. In this
case, you set scrollbind in both windows and then execute the following:
:syncbind
Vim then synchronizes the two files.

		63.1.13 The Preview Window
Suppose you are going through a program and find a function call that you do not
understand.You could do a CTRL-] on the identifier and jump to the location represented
by the tag. But there is a problem with this.The current file disappears because
the file with the function definition replaces it.
A solution to this is to use a special window called the “preview” window. By executing
the following command, you open a preview window and display the function
definition:
:ptag {function}
(If you already have a preview window up, it is switched to the definition of the function.)
Assume that you have just executed the
following command:
:ptag copy_p_date
After you have finished with the preview window, execute the following command:
:pclose
(CTRL-Wz or ZZ accomplishes the same thing.)
A whole set of commands is designed to manipulate the file in the preview
window.The commands are as follows:
:ppop Do a :pop command in the preview window.
:ptselect {identifier} Open a preview window and do a :tselect.
:ptjump {identifier} Open a preview window and do a :tjump.
:[count] ptnext Do a :[count] tnext in the preview window.
:[count] ptprevious Do a :[count] tprevious in the preview window.
:[count] ptrewind Do a :[count] trewind in the preview window.
:ptlast Do a :tlast in the preview window.
CTRL-W} Do a :ptag on the word under the cursor.
CTRL-Wg} Do a :ptjump on the word under the cursor.

		63.1.14 Match Options
The ‘matchpairs’ option controls what characters are matched by the % command.
The default value of this option is as follows:
:set matchpairs = (:),{:},[:]
This tells Vim to match pairs of (), [], and {}.
To match <> (useful if you are editing HTML documents), for example, use the
following command:
:set matchpairs=<:>
This matches just <> pairs. If you want to match <> in addition to the other characters,
you need this command:
:set matchpairs=(:),{:},[:],<:>
This is a little long and awkward to type.The += flavor of the :set command adds characters
to an option.Therefore, to add <> to the match list, use the following command:
:set matchpairs+=<:>

		63.1.15 Showing Matches
If you execute the following command, when you enter any type of bracket ( (, ), [,
], {, }),Vim will cause the cursor to jump to the matching bracket briefly when
entering:
:set showmatch
Generally this jump lasts only for a half second, but you can change it with the
‘matchtime’ option. If you want to make it 1.5 seconds, for instance, use the following
command:
:set matchtime=15
The value of this option is 1/10 second.

		63.1.16 Dealing with Multiple Directories
As programming projects grow larger and larger, you might find it convenient to
organize things in different directories.Take a look at a small project.You have a main
directory that contains main.c and main.h.The other directory is lib and it contains
lib.c and lib.h. (This naming has no imagination, but it does make a good example.)

You start editing in the directory main.The first thing you need to do is tell Vim
about your new directory.You use the :set ^= command to put the directory at the
top of the search path with the following command:
:set path ^= ../lib
Suppose you are editing the file main.c.The file looks like this:
#include “main.h”
#include “lib.h”
int main(int argc, char *argv[])
Now you need to check out a subroutine declaration in lib.h. One way of going to
that file is to execute the following command:
:vi ../lib/lib.h
This assumes you know where lib.h resides. But there is a better way. First, you
position the cursor over the filename in the following line:
#include “lib.h”
Now you execute the command gf.The Vim editor tries to edit the filename which is
under the cursor.The editor searches for the file in each directory in the path variable.
Suppose, however, that you want to edit the file lib.c.This name does not appear
in the text, so you cannot use the gf command. Instead, you execute the following
command:
:find lib.c
This acts just like the :vi command, except the editor searches for the file along the
path.The following command does the same thing, but it splits the window and then
does a :find:
:sfind lib.c
The gf command acts like a :find command but use the word under the cursor as the
name of the file to edit. If there is more than one file along the ‘path’ that matches
the given file name, then you can select which one Vim edits by giving the gf
command a count.
In other words if you position the cursor on the name param.h and execute the
command 2gf, Vim will edit the second param.h file it finds looking through the
directories specified by the ‘path’ option.
The ]f and [f command are older, depreciated versions of the gf command.

			63.1.16.1 The include Path
The path option is used by Vim to tell it where to look for files that were included in
the current file.The format of this option is as follows:
:set path=directory,directory,... 

Directory is a directory to search. For example:
:set path=/usr/include,/usr/X11R6/include
You can use wildcards (*) in any directory of the path specification:
:set path=/usr/include,/usr/include/*
There are a number of special directories:
** Match an entire tree. For example:
:set path=/usr/include/**
This command searches /usr/include and all its subdirectories.The following
path specification searches the files in any directory that starts with
/home/oualline/progs and ends with include:
:set path=/home/oualline/progs/**/include
“” The empty string indicates the current directory. (For example, the middle
directory of the trio “first,, last”.)
. The directory in which the file being edited resides.
For example, the following command tells Vim to search /usr/include and all it is
subdirectories, the directory in which the file resides (.), and the current directory
(,,).
:set path=/usr/include/**,.,,

**/
			63.1.16.2 Checking the Path
To make sure that you can find all the #include files, you can execute the following
command:
:checkpath
This command works not only on the #include directives in the file you are editing,
but also on any files that they #include and so on.The result is that all #include files
are checked.
In this case, a number of files include the files stddef.h and stdarg.h. But Vim
cannot find these files. If you want to tell Vim to search the Linux-specific include
directory, you can execute the following command:
:set path+=/usr/include/linux

This command lists only the files that cannot be found. If you want to list all #include
files, use this command:
:checkpath!

			63.1.16.3 My settings
Note, For working on ACS in clearcase views, assuming that VIM is launched from /view/[view name]/vob/nm_acs/acs, ex: /view/yizaq1__int.acs5_0.lx/vob/nm_acs/acs

-> Check current settings
:set path?

-> Set to find h files in view
set path=./**,/usr/include,$PWD/**,
Now gf will find the h files, BUT, it will be much slower than cscope or etags
so, three methods to find h file, once cursor is positioned on it:
a. gf (assume path is set correctly)
b. ctrl-] - use tags
c. ctrl-\ f , use cscope mapping

**/

		63.1.17 Complete Regular Expressions

The search logic of Vim uses regular expressions.You saw some simple ones in
Chapter 3,“Searching,” but this chapter goes into them in extreme detail. Regular
expressions enable you to search for more than simple strings. By specifying a regular
expression in your search command, you can search for a character pattern, such as “all
words that begin with t and end in ing” (regular expression = \<t[^ ]*ing\>).
However, the power of regular expressions comes with a price. Regular expressions
are quite cryptic and terse. It may take some time for you to get used to all the ins and
outs of this powerful tool.
While learning regular expressions, you should execute the following command:
:set hlsearch
This causes Vim to highlight the text you matched with your last search.Therefore,
when you search for a regular expression, you can tell what you really matched (as
opposed to what you thought you matched).
A regular expression consists of a series of atoms. An atom is the smallest matching
unit in a regular expression. Atoms can be things like a single character, such as a
(which matches the letter a), or a special character, such as $ (which matches the end
of the line). Other atoms, such as \< (word start, see the following section), consist of
multiple characters.

			63.1.17.1 Beginning (\<) and End (\>) of a Word
The atom \< matches the beginning of a word.The atom \> matches the end of a
word.
For example, a search for the expression for finds all occurrences of for, even those
in other words, such as Californian and Unfortunately. Figure 19.9 shows the results of
this search.
If you use the regular expression \<for\>, however, you match only the actual word


			63.1.17.2 Modifiers and Grouping

The modifier * is used to indicate that an atom is to be matched 0 or more times.The
match is “greedy.” In other words, the editor will try to match as much as possible.
Thus, the regular expression te* matches te, tee, teee, and so on.
The expression te* also matches the string t.Why? Because e* can match a zerolength
string of e’s. And t is the letter t followed by zero e’s.
Figure 19.11 shows the results of the search for te*.
Calls and letters to the company failed to correct
this problem. Finally the fellow just gave up and
wrote a check for $0.00 and the bills ceased.
A Californian who loved sailing went down and applied
for a personalized license plate. He filled in his
three choices as 1)SAIL 2)SAILING and 3)NONE. He got
a new plate labeled "NONE."
Unfortunately, when the police write out a ticket
/\<for\>

----------------------------------------------------------------------------------------------------
This is a test.
te tee teee teee
~~
/te*
Figure 19.11 Search for /te*.
----------------------------------------------------------------------------------------------------

The \+ modifier indicates that the atom is to be matched one or more times.
Therefore, te\+ matches te, tee, and teee, but not t. (te\+ is the same as tee*.).
Figure 19.12 illustrates what is matched for the search /te\+.

----------------------------------------------------------------------------------------------------
This is a test.
te tee teee teee
~~
/te\+
Figure 19.12 Search for /te\+.
----------------------------------------------------------------------------------------------------

Finally, there is the \= modifier. It causes the preceding atom to be matched zero or
one time.This means that te\= matches t and te, but not tee. (Although it will match
the first two characters of tee.) Figure 19.13 shows a typical search.

			63.1.17.3 Special Atoms
A number of special escaped characters match a range of characters. For example, the
\a atom matches any letter, and the \d option matches any digit.The regular expression
\a\a\a matches any three letters.
Now try a search for any four digits. Figure 19.14 displays the results.

----------------------------------------------------------------------------------------------------
1
2 // Read at most 10MB
3 const unsigned int MAX_READ = (10 * 1024 *1024);
4
5 // Size of a buffer
6 const unsigned int BUF_SIZE = (62 * 1024);
7
8 // Buffer to be written
9 static unsigned char buffer[BUF_SIZE];
10
Figure 19.14 Search for /\d\d\d\d.
----------------------------------------------------------------------------------------------------

Now try a search for any three letters followed by an underscore. 


			63.1.17.4 Character Ranges
The \a atom matches all the letters (uppercase and lowercase). But suppose you want
to match only the vowels.The range operator enables you to match one of a series of
characters. For example, the range [aeiou] matches a single lowercase vowel.The
string t[aeiou]n matches tan, ten, tin, ton and tun.

You can specify a range of characters inside the brackets ([]) by using a dash. For
example, the pattern [0-9], matches the characters 0 through 9. (That is
0,1,2,3,4,5,6,7,8,9.)
You can combine ranges with other characters. For example, [0-9aeiou] matches
any digit or lowercase vowel.
The ^ character indicates a set of characters that match everything except the indicated
characters.To match the constants, for example, you can specify [^aeioAEIOU].
Pattern Matches
one[\-]way one-way, but not one way or one+way
2\^4 2^4
2[\^*]4 2^4, 2*4

			63.1.17.5 Character Classes
Suppose you want to specify all the uppercase letters. One way to do this is to use the
expression [A-Z]. Another way is to use one of the predefined character classes.The
class [:upper:] matches the uppercase characters.Therefore, you can write [A-Z] as
[[:upper:]].
You can write the entire alphabet, upper- and lowercase, [[:upper:][:lower:]].
There are a large number of different character classes.
Note
To match the ^, you need to escape it. For example, [\^$.] matches any one of the three symbols
^, $, or ..

Note
You cannot use the special atoms like \a and \d in a range. For example, [\a\d] matches the characters
\, a, \, and d. It does not match the letters (\a) and digits (\d).

			63.1.17.6 Repeat Modifiers
You can specify how many times an atom is to be repeated.The general form of a
repeat is as follows:
\{minimum, maximum}
For example, the regular expression a\{3,5} will match 3 to 5 a’s. (that is, aaa, aaaa, or
aaaaa.) By default, the Vim editor tries to match as much as possible. So a\{3,5} will
match as many a’s as it can (up to 5).
The minimum can be omitted, in which case it defaults to zero.Therefore, a,\{,5}
matches 0–5 repeats of the letter.The maximum can be omitted as well, in which case
it defaults to infinity. So a\{3,} matches at least 3 a’s, but will match as many a’s as
you have got on the line.

If only one number is specified, the atom must match exactly that number of times.
Therefore, a\{5} matches 5 a’s, exactly.

				63.1.17.6.1 Repeating as Little as Possible
If you put a minus sign (-) before any of the numbers, the Vim editor tries to match as
little as possible.
Therefore, a\{-3,5} will match 3 to 5 a’s, as little as possible. Actually if this expression
is by itself, it will always match just three a’s.That is because even if you have the
word aaaaa, the editor will match as little as possible.
The specification a\{-3,} matches 3 or more a’s, as little as possible.The expression
a\{-,5} matches 0–5 letters.
The expression a\{-} matches 0 to infinity number of characters, as little as possible.
Note that this pattern by itself will always match zero characters. It only makes
sense when there is something after it. For example: [a-z]\{-}x will match cx in cxcx.
Using [a-z]*x would have matched the whole cxcx.
Finally, the specification a\{-5} matches exactly 5 a’s, as little as possible. Because as
little as possible is exactly 5, the expression a\{-5} acts just like a\{5}.

			63.1.17.7 Grouping ( \(\) )
You can specify a group by enclosing it in a \( and \). For example, the expression
a*b matches b, ab, aab, aaab, and so on.The expression a\(XY\)*b matches ab, aXYb,
aXYXYb, aXYXYXYb, and so on.
When you define a group using \(\), the first enclosed string is assigned to the
atom \1.To match the string the the, for instance, use the regular expression \(the\)
\1.To find repeated words, you can get a bit more general and use the expression

\(\<\a\+\>\) \1. 

Figure 19.16 breaks this into its components.
Put matching text in \1
Match beginning of a word
Match a single letter
Repeat 1 or more times
Ending of a word
Match space
Match what was in the first \ (... \ )
\ ( \ < \ a + \ > \ ) \ 1
Figure 19.16 The repeat (\1) expression.
The first group is assigned to \1, the second \2, and so on.

			63.1.17.8 The Or Operator (\|)
The \| operator enables you to specify two or more possible matches.The regular
expression foo\|bar matches foo or bar.
For example, the search
/procedure\|function
searches for either procedure or function.


			63.1.17.9 Putting It All Together
Let’s create a regular expression to match California license plate numbers. A sample
license plate looks like 1MGU103.The pattern is one digit, three uppercase letters,
and three digits.There are several ways of doing this.
Start by specifying the digit as [0-9], now add the uppercase letter: [0-9][A-Z].
There are three of them, so you get [0-9][A-Z]\{3}. Finally, you add the three digits
on the end, resulting in [0-9][A-Z]\{3}[0-9]\{3}.
Another way to do this is to recognize that \d represents any digit and \u any
uppercase character.The result is \d\u\{3}\d\{3}.
The experts tell us that this form is faster than using the [] form. If you are editing
a file where this speed up makes a difference, however, your file might be too big.
You can accomplish this without repeats as well: \d\u\u\u\d\d\d.
Finally, you can use the character classes, yielding
[[:digit:]][[:upper:]]\{3][[:digit:]]\{3}.
All four of these expressions work.Which version should you use? Whichever one
you can remember.You should remember this old adage:The simple way you can
remember is much faster than the fancy way you can’t.


			63.1.17.10 The magic Option
The expressions discussed so far assume that the 'magic' option is on.When this
option is turned off, many of the symbols used in regular expressions lose their magic
powers.They only get them back when escaped.
Specifically, if you execute the command
:set nomagic
the *, ., [, and ] characters are not treated as special characters. If you want to use the *
for “0 or more repeats,” you need to escape it: \*.
You should keep the 'magic' option on (the default) for portability and macro
files.


			63.1.17.11

		63.1.18 references


			63.1.18.1 Offset Specification Reference
[num]
+[num] Down [num] lines. Cursor is placed at the beginning of the line.
-[num] Up [num] lines. Cursor is placed at the beginning of the line.
e End of the match.
e[num] End of the match, the move [num]. If [num] is positive, move right,
negative, move left.
b
s Start of the match.
b[num]
s[num] Start of the match, then move [num]. If [num] is positive, move right;
negative, move left.

			63.1.18.2 Regular Expressions Reference
The following table assumes that the 'magic' option is on (the default).

				63.1.18.2.1 Simple Atoms
x The literal character x.
^ Start of line.
$ End of line.
. A single character.
\< Start of a word.
\> End of word.

				63.1.18.2.2 Range Atoms
[abc] Match either a, b, or c.
[^abc] Match anything except a, b, or c.
[a-z] Match all characters from a through z.
[a-zA-Z] Match all characters from a through z and A through Z.

				63.1.18.2.3 Character Classes
[:alnum:] Match all letters and digits.
[:alpha:] Match letters.
[:ascii:] Match all ASCII characters.
[:backspace:] Match the backspace character (<BS>).
[:blank:] Match the space and tab characters.
[:cntrl:] Match all control characters.
[:digit:] Match digits.
[:escape:] Matches the escape character (<Esc>).
[:graph:] Match the printable characters, excluding space.
[:lower:] Match lowercase letters.
[:print:] Match printable characters, including space.
[:punct:] Match the punctuation characters.
[:return:] Matches the end-of-line (carriage return, <Enter>, <CR>, <NL>).
[:space:] Match all whitespace characters.
[:tab:] Match the tab character (<Tab>).
[:upper:] Match the uppercase letters.
[:xdigit:] Match hexadecimal digits.

				63.1.18.2.4 Patterns (Used for Substitutions)
\(pattern\) Mark the pattern for later use.The first set of \(\) marks a
subexpression as \1, the second \2, and so on.
\1 Match the same string that was matched by the first subexpression
in \( and \). For example: \([a-z]\).\1 matches ata,
ehe, tot, and so forth.
\2 Like \1, but uses second subexpression,
\9 Like \1, but uses ninth subexpression.

				63.1.18.2.5 Special Character Atoms
\a Alphabetic character (A-Za-z).
\A Non-alphabetic character (any character except A-Za-z).
\b <BS>.
\d Digit.
\D Non-digit.
\e <Esc>.
\f Any filename character as defined by the isfname option.
\F Any filename character, but does not include the digits.
\h Head of word character (A-Za-z_).
\H Non-head of word character (any character except A-Za-z_).
\i Any identifier character as defined by the isident option.
\I Any identifier character, but does not include the digits.
\k Any keyword character as defined by the iskeyword option.
\K Any keyword character, but does not include the digits.
\l Lowercase character (a-z).
\L Non-lowercase character (any character except a-z).
\o Octal digit (0-7).
\O Non-octal digit.
\p Any printable character as defined by the isprint option.
\P Any printable character, but does not include the digits.
\r <CR>.
\s Whitespace (<Space> and <Tab>).
\S Non-whitespace character. (Any character except <Space> and
<Tab>).
\t <Tab>.
\u Uppercase character (A-Z).
\U Non-uppercase character (any character except A-Z).
\w Word character (0-9A-Za-z_).
\W Non-word character (any character except 0-9A-Za-z_).
\x Hexadecimal digit (0-9 a-f A-F).
\X Non-hexadecimal digit.
\~ Matches the last given substitute string.

				63.1.18.2.6 Modifiers
* Match the previous atom 0 or more times.As much as possible.
\+ Match the previous atom 1 or more times.As much as possible.
\= Match the previous atom 0 or 1 times.
\{} Match the previous atom 0 or more times. (Same as the *
modifier.)
\{n}
\{-n} Match the previous atom n times.
\{n,m} Match the previous atom n to m times.
\{n,} Match the previous atom n or more times.
\{,m} Match the previous atom from 0 to m times.
\{-n,m} Match the previous atom n to m times. Match as little as
possible.
\{-n,} Match the previous atom at least n times. Match as little as
possible.
\{-,m} Match the previous atom up to m times. Match as little as
possible.
\{-} Match the previous atom 0 or more times. Match as little as
possible.
str1\|str2 Match str1 or str2.

				63.1.18.2.7

			63.1.18.3
		63.1.19 Special Registers
Vim has a number of special registers.The first is the unnamed register, whose name is
double quote (“).
Others include the registers 1 through 9. Register 1 contains the last text you
deleted; register 2 the next to last, and so on.
(Back in the bad old days of Vi, these registers were a lifesaver.You see, Vi had only
one level of undo. So if you deleted three lines by executing dd three times, you were
out of luck if you wanted to undo the delete using the u command. Fortunately, the
three lines were stored in registers 1, 2, and 3, so you could put them back with
“1P”2P”3P.You can also use the command “”P.. (“”P and two dots).
Other special registers include the following:
Register Description Writeable
0 The last yanked text Yes
- The last small delete No
. The last inserted text No
% The name of the current file No
# The name of the alternate file No
/ The last search string No
: The last “:” command No
_ The black hole (more on this later) Yes
= An expression (see next page) No
* The text selected with the mouse Yes

			63.1.19.1 The Black Hole Register (_)
Placing text into the black hole register causes it to disappear.You can also “put” the
black hole register, but this is pretty much useless because the black hole register
always contains nothing.
The black hole register is useful when you want to delete text without having it go
into the 1 through 9 registers. For example, dd deletes a line and stores it in 1.The
command “_dd deletes a line and leaves 1 alone.

			63.1.19.2 The Expression Register (=)
The expression register (=) is designed so that you can enter expressions into text.
When you enter a command beginning with an expression register specification, the
Vim editor displays the prompt = at the end of the screen.This gives you an opportunity
to type in an expression such as 38*56, and you can then put the result into the
text with the p command. For example “=38*56<Enter>p gives you 2128. Figure 20.5
shows this register in action.

Another usages is while inserting text hit ctrl+r, then =, put expression and press enter
An expression can contain all the usual arithmetic operators (*, +, -, /, and so on) as
well as a ton of specialized Vim functions and operators. If you are doing more than
simple arithmetic, you will want to check the full expression documentation.
You can specify the value of an environment variable, for example, by using the
expression $NAME (for instance, $HOME).You can determine the value of a Vim variable
by just specifying the variable (LineSize, for instance).


			63.1.19.3 The Clipboard Register (*)
The clipboard register (*) enables you to read and write data to the system clipboard.
This can be the X selection (UNIX) or the Microsoft Windows Clipboard.This
enables you to cut and paste text between the Vim editor and other applications


			63.1.19.4 How to Edit All the Files That Contain a
Given Word
If you are a UNIX user, you can use a combination of Vim and Grep to edit all the
files that contain a given word.This proves extremely useful if you are working on a
program and want to view or edit all the files that contain a specified variable.
Suppose, for example, that you want to edit all the C program files that contain the
word frame_counter.To do this, you use the following command:
$ vim `grep -l ‘frame_counter’ *.c`
Consider this command in detail.The grep command searches through a set of files
for a given word. Because the -l option is specified, the command will list only the
files containing the word and not print the line itself.The word it is searching for is
frame_counter. Actually, this can be any regular expression. (Note that what Grep uses for
regular expressions is not as complete or complex as what Vim uses.)
The entire command is enclosed in backticks (`).This tells the UNIX shell to run
this command and pretend that the results were typed on the command line. So what
happens is that the grep command is run and produces a list of files; these files are put
on the Vim command line.This results in Vim editing the file list that is the output of
Grep.
You might be asking, “Why show this here?”This is a feature of the UNIX shell
(for example, bash), and is not part of Vim’s repertoire.The way to accomplish something
similar within Vim, and which works on Win32 as well, is as follows:
:arg `grep –l ‘frame_counter’ *.c`
This command sets the argument list (for example, the files “on the command
line,” as it were).
Note
The Vim command :grep can perform a similar function.


				63.1.19.4.1 Editing a Specific File
To edit a specific file in this list (file 2, for instance), you need the following
command:
:argument 2 


				63.1.19.4.2 This command enables you to specify a file by its position in the argument list.
Suppose, for instance, that you start Vim with this command:
$ gvim one.c two.c three.c four.c five.c six.c seven.c
The following command causes you to be thrown into the file four.c.
:argument 4
Changing the File List
The file list is initially set to the list of files you specify on the command line.You can
change this list by specifying a new list to the :args command. For example:
:args alpha.c beta.c gamma.c
After executing this command, you start editing alpha.c; the next file is beta.c and so
on. (The previous file list is lost.)
Note
The :next file-list command will do the same thing.


				63.1.19.4.3 The +cmd Argument
Suppose that you want to start editing a file at line 97.You can start Vim and execute a
97G, or you can tell Vim to start editing with the cursor on line 97.You can do this by
using the option +linenumber on the command line. For example:
$ gvim +97 file.c
You can also use the +cmd to search for a string by using +/string on the command
line.To start editing a file with the cursor positioned on the first line containing
#include, for instance, use this command:
$ vim +/#include file.c
Finally, you can put any command-mode command after the plus sign (+).
You can specify the +cmd argument in a number of commands. For example, the
general form of the :vi command is as follows:
:vi [+cmd] {file}
These other commands can take a +cmd:
:next [+cmd]
:wnext [+cmd]
:previous [+cmd]
:wprevious [+cmd]
:Next [+cmd]
:wNext [+cmd]
:rewind [+cmd]
:last [+cmd]


				63.1.19.4.4

			63.1.19.5 Complete Command-Mode (:) Commands
ALTHOUGH THEVIMEDITOR IS SUPERBwhen it comes to doing things visually,
sometimes you need to use command mode. For example, command-mode commands
are much easier to use in scripts. Also, a number of other specialized commands are
found only in command mode.
Being expert in the command-mode command means that you are a Vim power
user with the ability to execute a number of amazing high-speed editing commands.

				63.1.19.5.1 Editing Commands
The :delete command deletes a range of lines.To delete lines 1 through 5 (inclusive),
for example, use the following command:
:1,5 delete
The general form of the :delete command is as follows:
: range delete register count
The register parameter specifies the text register in which to place the deleted text.This
is one of the named registers (a–z). If you use the uppercase version of the name
(A–Z), the text is appended to what is already in the register. If this parameter is not
specified, the unnamed register is used.
The count parameter specifies the number of lines to delete (more on this later in
this section).
The range parameter specifies the lines to use. Consider the following example
(spaces added for readability):
:1, 3 delete

You have learned how to use search patterns for line specification. For example, the
following command deletes starting from the first line with hello to the first line that
contains goodbye.
:/hello/,/goodbye/ delete
Note: If goodbye comes before hello, the line range will be backwards, and the command
will not work.
You can refine the search string specification by adding an offset. For example,
/hello/+1 specifies the line one line after the line with the word hello in it.Therefore,
the following command results in the screen shown in Figure 25.2.
:/beach/+1, /seashore/-1 delete

----------------------------------------------------------------------------------------------------
1 A UNIX sales lady, Lenore,
2 Enjoys work, but she likes the beach more.
3 She found a good way
4 To combine work and play:
5 She sells C shells by the seashore.
~
1 To combine work and play:
2 She sells C shells by the seashor
~~~~ 3
fewer lines
1 A UNIX sales lady, Lenore,
2 Enjoys work, but she likes the beach more.
3 She sells C shells by the seashore.
~~~
: /beach/+1, /seashore/–1 delete
Figure 25.2 Results of :/beach/+1, /seashore/-1 delete.
----------------------------------------------------------------------------------------------------

You can also use special shorthand operators for patterns, as follows:
\/ Search forward for the last pattern used.
\? Search backward for the last pattern used.
\& Search forward for the pattern last used as substitute pattern.
You can also chain patterns.The following command, for example, finds the string
first and then searches for the string second.
/first//second/
Figure 25.3 shows the result of this command:
:/found//work/ delete

----------------------------------------------------------------------------------------------------
1 A UNIX sales lady, Lenore,
2 Enjoys work, but she likes the beach more.
3 She found a good way
4 She sells C shells by the seashore.
~~ :/found//work/ delete
Figure 25.3 :/found//word/delete.
----------------------------------------------------------------------------------------------------

You can also specify a line number on which to start.To start the search at line 7, for
instance, use the following command-line specification:
7/first/

				-> Other Ways to Specify Ranges
If you execute a : command with no count (as most users generally do), the Vim
editor puts you into command mode and enables you to specify the range. If you give
the command a count(5:, for example), the range is count lines (including the current
one).The actual specification of this arrangement is that if you include a count, your
line range is as follows:
:.,count - 1
In the example original file, for instance, if you move to the top line and then execute
the following command, you get the results shown in Figure 25.4:

----------------------------------------------------------------------------------------------------
3:delete
1 To combine work and play:
2 She sells C shells by the seashore.
~~~~ 3
fewer lines
Figure 25.4 3:delete.
----------------------------------------------------------------------------------------------------

				-> Deleting with a Count
Another form of the delete command is as follows:
:line delete count
In this case, the :delete command goes to line (default = the current line) and then
deletes count lines.
If you execute the following command on the original example file, for instance,
you get the results shown in Figure 25.5:
----------------------------------------------------------------------------------------------------
:3 delete 2
1 A UNIX sales lady, Lenore,
2 Enjoys work, but she likes the beach more.
3 She sells C shells by the seashore.
~~~ :
3
delete 2
Figure 25.5 :3 delete 2.
----------------------------------------------------------------------------------------------------

				63.1.19.5.2 Copy and Move
The :copy command copies a set of lines from one point to another.The general form
of the copy command is as follows:
:range copy address
If not specified, range defaults to the current line.This command copies the line in
range to the line specified after address. Consider the following command, for example:
:1,3 copy 4
Executed on the original joke, you get the results shown in Figure 25.6.
Note
You can specify a line range for this type of command, but the first line is ignored and the second one is
used
The :move command is much like the :copy command, except the lines are moved
rather than copied.The following command results in what is shown in Figure 25.7:
:1,3 move 4

				63.1.19.5.3 Inserting Text
Suppose that you want to insert a bunch of lines and for some reason you want to use
command mode.You need to go to the line above where you want the new text to
appear. In other words, you want the text to be inserted after the current line.
Now start the insert by executing the :append command.Type the lines that you
want to add and finish by typing a line that consists of just a period (.).
The following example illustrates the :append command.
:% print
A UNIX sales lady, Lenore,
Enjoys work, but she likes the beach more.
She found a good way
To combine work and play:
She sells C shells by the seashore.
:1append
This line is appended.
.
:% print
A UNIX sales lady, Lenore,
This line is appended.
Enjoys work, but she likes the beach more.
She found a good way
To combine work and play:
She sells C shells by the seashore.
The general form of the :append command is as follows:
:line append
The line is the line after which to insert the new text.

The :insert command also inserts text. It has a similar form:
:line insert
It works just like :append except that :append inserts after and :insert inserts before
the current line

				63.1.19.5.4 Printing with Line Numbers
You do not have to turn on the number option to print the text with line numbers.
The :# command accomplishes the same thing as :print but includes line numbers:
:1 print
A UNIX sales lady, Lenore,
:1 #
1 A UNIX sales lady, Lenore,

				63.1.19.5.5 Printing with list Enabled
The 'list' option causes invisible characters to be visible.The :list command lists
the specified lines, assuming that this option is on:
:1,5 list


				63.1.19.5.6 Print the Text and Then Some
The :z command prints a range of lines (the current one being the default) and the
lines surrounding them. For example, the following command prints line 100 and then
a screen full of data:
:100 z
The :z command takes a count of the number of extra lines to list. For example, the
following command lists line 100 and three additional lines:
:100 z 3
The :z command can be followed by a code indicating how much to display.The
following table lists the codes:
Code Listing Start Listing End New Current Line
+ Current line One screen forward One screen forward
- One screen back Current line Current line
^ Two screens back One screen back One screen back
. One-half screen back One-half screen forward One-half screen forward
= One-half screen back One-half screen forward Current line


			63.1.19.6 Substitute
The format of the basic substitute command is as follows:
:range substitute /from/to/flags count
Note
This example uses a slash (/) to separate the patterns. Actually you can use almost any character that
does not appear in the patterns. The following, for example, is perfectly valid:
:substitute +from+to+
This can prove extremely useful when you are dealing with patterns that contain slashes, such as
filenames:
:1,$ substitute +/home/user+/apps/product+
Delimiters can be any character except letters, digits, backslash, double quote, or
vertical bar.
The Vim editor uses a special set of magic characters to represent special things. For
example, star (*) stands for “repeat 0 or more times.”
If you set the 'nomagic' option, however, the magic meanings of some of these
characters are turned off. (For a complete list of the magic characters and how the
'nomagic' option affects them, see Chapter 19, “Advanced Searching Using Regular
Expressions.”)

is set during the command.
For example, start in command mode with a one-line file.You start by printing the
entire file:
:%print
Test aaa* aa* a*
Now set the 'magic' option and perform a substitution.The p flag tells the editor to
print the line it changed:
:set magic
:1 substitute /a*/b/p
bTest aaa* aa* a*
This command made only one change at the beginning of the line. So why did it
change Test to b*Test when there is no a around? The answer is that the magic character
star (*) matches zero or more times. Test begins with zero a’s.
But why did it make only one change? Because the :substitute command
changes only the first occurrence unless the g flag is present. Now undo the change
and try again:
:undo
:1 substitute /a*/b/pg
bTbebsbtb b*b b*b b*b
This time you got what you wanted. Now try it again with the 'nomagic' option set:
:undo
:set nomagic
:1 substitute /a*/b/pg
Test aab ab b
Without 'magic', a star (*) is just a star. It is substituted directly.
The :smagic command forces magic on the star (*) and other characters while the
substitution is being made, resulting in the following:
:undo
:1 smagic /a*/b/pg
bTbebsbtb b*b b*b b*b
The :snomagic forces 'magic' off.
:undo
:set magic
:1 snomagic /a*/b/pg
Test aab ab b
The & command repeats the substitution.This enables you to keep your old from and
to strings, but also to supply a different range or flags. The general form of this command
is as follows:
:range& flags count
For example:
:1 substitute /a\+/b/p
Test b* aa* a*

The command changes the first occurrence of from on the line.You want the entire
line, so you repeat the substitution with the g option:
:&g
Of course, this does not print (because the new flags—in this case g—replaces the flags
and you did not specify p or, more specifically, pg).Take a look at the result:
:1 print
Test b* b* b*
This is what you wanted.
The :& command and the :substitute command with no from or to specified acts
the same.
The normal-mode & command repeats the last :substitute command. If you were
to execute the following command, for instance, you would change the first manager
on line 5 to an idiot:
:5 substitute /manager/idiot/
Now if you enter normal mode (through the :vi command) and execute an & command,
the next manager on this line would change as well. If you were to move down
to another line and execute an & command, you would change that line as well. If you
give & a count, it will work on that many lines.
The :~ command acts just like the &g command, except that it uses as from the last
search pattern (used for a / or ? search) rather than the last :substitute from string.
The general form of this command is as follows:
:range~ flags count

	-> Repeat Substitution
The & command repeats the last substitution.

				63.1.19.6.1 Making g the Default
Generally the :substitute command changes only the first occurrence of the word
unless you use the 'g' option.To make the 'g' option the default, use the following
command:
:set gdefault
Note:This can break some scripts you may use.

				63.1.19.6.2 Global Changes
The command-mode commands covered so far have one limitation:They work only
on a contiguous set of lines. Suppose, however, that you want to change just the lines
that contain a certain pattern. In such a case, you need the :global command. The
general form of this command is as follows:
:range global /pattern/ command
This tells Vim to perform the given command on all lines that contain the pattern in
the specified range.To print all the lines within a file that contain the word Professor,
for instance, use the following command:
:% global /Professor/ print
Professor: Yes.
Professor: You mean it’s not supposed to do that?
Professor: Well there was no Computer Center Bulletin
Professors of mathematics will prove the existence of
The :global! command applies the command to all the lines that do not match the
given pattern, as will the :vglobal command.

			63.1.19.7
		63.1.20 Directory Manipulation
To change the current working directory, use the following command:
:cd dir
This command acts just like the system cd command.
On UNIX, it changes the current working directory to the given directory. If no
directory is specified, it goes to the user’s home directory.
On Microsoft Windows, it goes to the indicated directory. If no directory is specified,
it prints the current working directory.
The following command changes the directory to the previous path:
:cd -
In other words, it does a cd to the last directory you used as the current working
directory.
To find out which directory Vim is currently using, use this command:
:pwd
Start deep in the directory tree, for instance:
:pwd
/mnt/sabina/sdo/writing/book/vim/book/11

You are working on a UNIX system, so go to your $home directory:
:cd
:pwd
/home/sdo
Jump into another directory:
:cd tmp
:pwd
/home/sdo/tmp
Return to the previous directory:
:cd -
:pwd
/home/sdo
Return to the previous directory before this one:
:cd -
:pwd
/home/sdo/tmp

		63.1.21 Files
			63.1.21.1 Current File


The following command prints out the current file and line information:
:file
Note that ctrl+G does the same

If you want to change the name of what Vim thinks is the filename, use this command:
:file name
Suppose, for example, that you start editing a file called complete.txt.You get this file
just right, so you write it out using the :write command. Now you want shorten the
file and write it out as summary.txt. So now you execute this command:
:file summary.txt
Now when you continue to edit, any changes are saved to summary.txt.
Take a look at how this works.You start by editing the file star.txt.
:file
“star.txt” line 1 of 1 —100%— col 1
The :write command with no arguments writes the file to the current filename (in
this case, star.txt).
:write
“star.txt” 1 line, 18 characters written
Now you want to change the filename to new.txt.The editor tells you that this is a
new filename.
:file new.txt
“new.txt” [Not edited] line 1 of 1 —100%— col 1
The :write command is used to write the file. In this case, the current filename
differs; it is new.txt.
:write
“NEW.TXT” [New File] 1 line, 18 characters written
There is another command similar to :file; the following command prints the current
line number:
:=
For example:
:=
line 1

			63.1.21.2 Advanced :write Commands
The :write command writes the buffer (or a selected range of lines) to a file. It has
some additional options.The following command, for example, appends the contents
of the file you are editing to the file named collect.txt:
:write >> collect.txt
If the collect.txt file does not exist, this command aborts with an error message. If
you want to “append” to the file even if does not exist, use the force (!) option:
:write! >> collect.txt
The :write command can not only write to a file, but it can also be used to pipe the
file to another program. On Linux or UNIX, for instance, you can send the file to a
printer by using the following command:
:write !lpr
Warning
The following two commands are different; the difference being only the spacing:
:write! lpr
:write !lpr
The first writes to the file named lpr with the force option in place. The second sends the output to the
command lpr.

			63.1.21.3 Updating Files
The :update command acts just like the :write command, with one exception: If the
buffer is not modified, the command does nothing.

			63.1.21.4 Reading Files
The :read command reads in a file.The general form of this command is as follows:
:line read file
The preceding command reads the file in and inserts it just after line. If no file is specified,
the current file is used. If no line is supplied, the current line is used.
Like :write, the :read command can use a command rather than a file.To read the
output of a command and insert it after the current line, use the following command:
:line read !command

			63.1.21.5 Register Execution
Chapter 2, “Editing a Little Faster,” showed you how to record macros in registers. If
you want to use these macros in command mode, you can execute the contents of a
register with the following command:
:line@register
This command moves the cursor to the specified line, and then executes the register.
This means that the following command executes the previous command line:
:@:
To execute the previous :@register command, use this command:
:line@@

			63.1.21.6 Simple Edits
The following sections describe simple edits.

Shifting
The :> command shifts lines to the right.The :< command shifts lines to the left.
The following command, for example, shifts lines 5 through 10 to the right:
:5, 10 >

			63.1.21.7 Changing Text
The :change command acts just like the :delete command, except that it performs an
:insert as well.

Entering Insert Mode
The :startinsert command starts insert mode as if you were in normal mode and
were to press i.

Joining Lines
The :join command joins a bunch of lines (specified by the range parameter) together
into one line. Spaces are added to separate the lines.
If you do not want the added spaces, use the :join! command.

Yanking Text
The following command yanks the specified lines into the register:
:range yank register
If no register is specified, the unnamed register is used.

Putting Text
The :put command puts the contents of a register after the indicated line.To dump
the contents of register a after line 5, for example, use the following command:
:5put a
If you want to put the text before the line, use this command:
:5put! a

Undo/Redo
The :undo command undoes a change just like the u command does.The :redo
command redoes a change like CTRL-R does.
To mark the beginning of the line, use the
:mark {register}
command. If a line is specified, that line will be marked.The :k command does the
same thing, with the exception that you don’t have to put a space in front of the register
name.The following two commands are equivalent:
:100 mark x
:100 ka

		63.1.22 Miscellaneous Commands
The following sections describe some miscellaneous commands you can use 

			63.1.22.1 The :preserve Command
The :preserve command writes out the entire file to the “swap” file.This makes it
possible to recover a crashed editing session without the original file. (If you do not
use this command, you need both the swap file and the original to perform recovery.)
See Chapter 14, “File Recovery and Command Line Arguments,” for information on
recovering crashed sessions.

			63.1.22.2 The Shell Commands
To execute a single shell command, use the following Vim command (where cmd is the
system command to execute):
:!cmd
To find the current date, for instance, use this command:
:!date
The following command repeats the last shell command you executed:
:!!
Finally, the following command suspends Vim and goes to the command prompt:
:shell
You can now enter as many system commands as you want. After you have finished,
you can return to Vim with the exit command.

			63.1.22.3 Shell Configuration
The following several options control the actual execution of a command.
shell The name of the shell (command processor).
shellcmdflag Flag that comes after the shell.
shellquote The quote characters around the command.
shellxquote The quote characters for the command and the redirection.
shellpipe String to make a pipe.
shellredir String to redirect the output.
shellslash Use forward slashes in filenames (MS-DOS only). 

			63.1.22.4 Command History
The :history command prints out the current command-mode command history:
:history
# cmd history
2 1 print
3 5
4 7 print
5 . print
> 6 history
The Vim editor maintains a set of histories for various commands. A code identifies
each of these:
Code History Type
c cmd : Command-line history (command-mode
commands)
s search / Search strings (See Chapter 3, “Searching”)
e expr = Expression register history
i input @ Input line history (data typed in response to
an :input operator)
a all All histories
Therefore, to get a list of all the various history buffers, use the :history all command:
:history all
# cmd history
2 1 print
3 5
4 7 print
5 . print
6 history
> 7 history all
# search history
1 human
2 uni
3 comp
4 Seem
> 5 \<At\>
# expr history
1 55
2 2*88
> 3 5+99
# input history
Press Return or enter command to continue
The general form of the :history command is as follows:
:history code first , last

If no first and last are specified, the whole history is listed.The first parameter defaults
to the first entry in the history, and the last defaults to the last. Negative numbers indicate
an offset from the end of the history. For example, –2 indicates the next-to-last
history entry.
The following command, for example, list history entries 1 through 5 for
command-mode commands:
:history c 1,5
And, this next command lists the last 5 search strings:
:history s –5,

			63.1.22.5 Setting the Number of Remembered Commands
The 'history' option controls how may commands to remember for commandmode
(: mode) commands.To increase the number of commands to remember (to 50,
for instance), use this command:
:set history=50

			63.1.22.6 Viewing Previous Error Messages
The Vim editor keeps track of the last few error and information messages displayed on
the last line of the screen.To view the message history, use the following command:
:messages
“../joke.txt” 6092 lines, 174700 characters
Entering Ex mode. Type “visual” to go to Normal mode.
search hit BOTTOM, continuing at TOP
Not an editor command: xxxxx
search hit BOTTOM, continuing at TOP
search hit BOTTOM, continuing at TOP
Pattern not found: badbad
Not an editor command: :^H
Invalid address

			63.1.22.7 Redirecting the Output
The following command causes all output messages to be copied to the file as well as
to appear on the screen:
:redir > file
To end the copying, execute the following command:
:redir END
This command proves useful for saving debugging information or messages for inclusion
in a book.

			63.1.22.8 Executing a :normal Command
The :normal command executes a normal-mode command.The following command,
for instance, changes the word where the cursor is located to the word DONE:
:normal cwDONE<Esc>
The group of commands is treated as one for the purposes of undo/redo.
The command should be a complete command. If you leave Vim hanging (suppose
that you executed a command cwDone, for instance), the display will not update until
the command is complete.
If you specify the '!' option, mappings will not be done on the command.

		63.1.23 Getting Out
The following command writes the current file and closes the window:
:exit
When the last window is closed, the editor stops.
If the override flag (!) is given, an attempt will be made to write the file even if it
is marked read-only.
You can also specify a filename on the command line.The data will be written to
this file before exiting.The following command, for example, saves the current file in
save-it-it.txt and exits.
:exit save-it.txt
If you want to save only a portion of the file, you can specify a range of lines to
write.To save only the first 100 lines of a file and exit, for example, use this command:
:1,100 exit save-it.txt

Write and Quit
The following command does the same thing that :exit does, except it always writes
the file:
:range wq! file
The :exit command writes only if the file has been changed.


		63.1.24 Expressions and Functions
THE VIM EDITOR CONTAINS A RICH script language.This command language gives you
tremendous flexibility when it comes to customizing your editor for specialized tasks.
This chapter covers the following:
n Basic variables and expressions
n The :echo statement
n Control statements
n User-defined functions
n A complete list of built-in functions

			63.1.24.1 Basic Variables and Expressions
The Vim editor enables you to define, set, and use your own variables.To assign a
value to a variable, use the :let command.The general form of this command is as
follows:
:let {variable} = {expression}
The Vim editor uses the same style variable names as most other languages—that is, a
variable begins with a letter or underscore and then consists of a series of letters, digits,
and the underscore.
To define the variable line_size, for example, use this command:
:let line_size = 30
To find out what the variable is, use the :echo command:
:echo “line_size is” line_size
When entered, this command results in Vim displaying the following on the last line:
line_size is 30
Variables can contain numbers (such as 30) or strings (such as “foo”). For example:
:let my_name = “Steve Oualline”

			63.1.24.2 Special Variable Names
The Vim editor uses special prefixes to denote different types of variables.The prefixes
are as follows:
Name Use
All uppercase, digits, and Variable which can be stored in the viminfo file.
underscore if the ‘viminfo‘ option contains the “!” flag
Initial uppercase letter Variable saved by the make session (:mksession)
command.
Lowercase letter somewhere
inside
:let Save_this_option = 1 “ Options saved in session
:let forget_this = “yes” “ Discarded between sessions
All lowercase, digits, and A variable not stored in any save file.
underscore
$environment Environment variable.
@register Text register.
&option The name of an option.
b:name The variable is local to the buffer. Each buffer can
have a different value of this variable.
w:name A variable local to a window.
g:name A global variable. (Used inside functions to denote
global variables.)
a:name An argument to a function.
v:name A Vim internal variable.

Some examples:
“ The environment variable $PAGER contains the name of the page viewing command
:let $PAGER = “/usr/local/bin/less”
“ Display the value of the last search pattern
:echo “Last search was “@/
“ The following two commands do the same thing
:let &autoindent = 1
:set autoindent
“ Define the syntax for the current buffer
:let b:current_syntax = c
“Note: This doesn’t handle all the side effects associated with “changing the
language of the buffer
The internal variables (v:name) are used by Vim to store a variety of information.The
following table shows the full list of variables.
Variable Functions
v:count The count given for the last normal-mode command.
v:count1 Like v:count, except that it defaults to 1 if no count is
specified.
v:errmsg The last error message.
v:warningmsg The last warning message.
v:statusmsg The last status message.
v:shell_error Result of the last shell command. If 0, the command worked;
if non-0, the command failed.
v:this_session Full filename of the last loaded or saved session file.
v:version Version number of Vim.Version 5.01 is stored as 501.

Constants
The Vim editor uses a variety of constants.There are the normal integers:
123 “ Simple integer
0123 “ Octal integer
0xAC “ Hexadecimal
There are also string constants:
“string” “ A simple string
‘string’ “ A literal string
The difference between a simple string and a literal string is that in a simple string,
characters escaped by backslash are expanded, whereas in a literal string a backslash is
just a backslash. For example:
:echo “>\100<”
>@<
:echo ‘>\100<’
>\100<
Note
The character number octal 100 is @.

			63.1.24.3 Expressions
You can perform a variety of operations on integers.These include the arithmetic
operators:
int + int Addition
int – int Subtraction
int * int Multiplication
int / int Integer divide (and truncate)
int % int Modulo
– int Negation
Note
Strings are automatically converted to integers when used in conjunction with these operators.
In addition, a number of logical operators work on both strings and integers.These
return a 1 if the comparison succeeds and 0 if it does not.
var == var Check for equality.
var != var Inequality.
var < var Less than.
var <= var Less than or equal to.
var > var Greater than.
var >= var Greater than or equal to.
In addition, the comparison operators compare a string against a regular expression.
For example, the following checks the given string (“word”) against the regular expression
“\w*” and returns a 1 if the string matches the expression:
“word” =~ “\w*”
The two regular expression comparison operators are as follows:
string =~ regexp Regular expression matches.
string !~ regexp Regular expression does not match.
In addition, strings have the following special comparisons:
string ==? string Strings equal, ignore case.
string ==# string Strings equal, case must match.
string !=? string Strings not equal, ignore case.
string !=# string Strings not equal, case must match.
string <? string Strings less than, ignore case.
string <# string Strings less than, case must match.
string <=? string Strings less than or equal, ignore case.
string <=# string Strings less than or equal, case must match.
string >? string Strings greater than, ignore case.
string ># string Strings greater than, case must match.
string >=? string Strings greater than or equal, ignore case.
string >=# string Strings greater than or equal, case must match.
There are three forms of each operator.The bare form (i.e. ==) honors the
‘ignorecase’ option.The “?” form (i.e.==?) always ignores case differences while
the “#” form (i.e.==#) never ignores different case characters.

Deleting a Variable
The following command deletes a variable:
:unlet[!] {name}
Generally, if you try to delete a variable that does not exist, an error result. If the override
(!) character is present, no error message results.

			63.1.24.4 Entering Filenames
When you are entering a filename, you can use a number of special words and characters,
as follows:
% Current filename
# Alternate filename
<cword> The word under the cursor.
<cWORD> The WORD under the cursor.
<cfile> The filename under the cursor.
<afile> The name of a file being read or written during the execution of a
related autocommand. (See Chapter 13,“Autocommands,” for more
information.)
<abuf> The current buffer number in an autocommand.
<amatch> Like <abuf>, but when used with a FileType or Syntax event it is
not the file name, but the file type or syntax name.
<sfile> The name of the file currently being :sourced.
You can modify each of these words by one or more of the modifiers listed here (for
example, the :p modifier, which turns a filename into a full pathname). If the name of
the file under the cursor is test.c, for instance, <cfile> would be test.c. On the
other hand, <cfile:p> would be /home/oualline/examples/test.c.
You can use the following modifiers:
:p Turn a filename into a full path. Must appear first if multiple
modifiers are used.
:~ Turn an absolute path such as /home/oualline/examples/test.c
into a short version using the ~ notation, such as
~oualline/examples/test.c.
:. Turn the path into one relative to the current directory, if
possible.
:h Head of the filename. For example, ../path/test.c yields
../path.
:t Tail of the filename.Therefore, ../path/test.c yields test.c.
:r Filename without extension.Therefore, ../path/test.c yields
test.
:e Extension.
:s?from?to? Substitution changing the pattern from to the pattern to, first
occurrence.
:gs?from?to? Substitution changing the pattern from to the pattern to, all
occurrences.

			63.1.24.5 How to Experiment
You can determine how Vim will apply modifiers to a filename. First create a text file
whose content is the filename on which you want to run experiments. Put the cursor
on this filename and then use the following command to test out a modifier:
:echo expand(“<cword>:p”)
(Change :p to whatever modifier you want to check.)
The following sections discuss the :echo statement and expand function in more
detail.


			63.1.24.6 The :echo Statement
The :echo statement just echoes its arguments. For example:
:echo “Hello world”
Hello world
You can also use it to display the value of a variable:
:let flag=1
:echo flag
1
The :echon command echoes the arguments, but does not output a newline. For
example:
:echo “aa” | echo “bb”
aa
bb
:echon “aa” | echon “bb”
aabb
Note
The bar (|) is used to separate two commands on the same line.
Echoing in Color
You can use the :echohl command to change the color of the output :echo to a
given highlight group. For example:
:echohl ErrorMsg
:echo “A mistake has been made”
:echohl None
Note
Good programming practice dictates that you always reset the highlighting to None after your message.
That way you do not affect other :echo commands.
If you want to see what highlight groups are defined, use this command:
:highlight

			63.1.24.7 Control Statements
The Vim editor has a variety of control statements that enable you to change the flow
of a macro or function.With these, you can make full use of Vim’s sophisticated script
language.

				63.1.24.7.1 The :if Statement
The general form of the :if statement is as follows:
:if {condition}
: “ Statement
: “ Statement
:endif
The statements inside the :if statement are executed if the condition is non-zero.The
four-space indent inside the :if is optional, but encouraged because it makes the program
much more readable.
The :if statement can have an else clause:
:if {condition}
: “ Statement
: “ Statement
:else
: “ Statement
: “ Statement
:endif
Finally, the :elseif keyword is a combination of :if and :else. Using it removes the
need for an extra :endif:
:if &term == “xterm”
: “ Do xterm stuff
:elseif &term == “vt100”
: “ Do vt100 stuff
:else
: “ Do non xterm and vt100 stuff
:endif

				63.1.24.7.2 Looping
The :while command starts a loop.The loop ends with the :endwhile command:
:while counter < 30
: let counter = counter + 1
: “ Do something
:endwhile
The :continue command goes to the top of the loop and continues execution.The
:break command exits the loop:
:while counter <: 30
: if skip_flag
: continue
: endif
: if exit_flag
: break
: endif
: “Do something
:endwhile

				63.1.24.7.3 The :execute Command
The :execute executes the argument as a normal command-mode command:
:let command = “echo ‘Hello world!’”
:execute command
Hello World

			63.1.24.8 Defining Your Own Function
The Vim editor enables you to define your own functions.The basic function declaration
begins as follows:
:function {name}({var1}, {var2}, ...)
Note
Function names must begin with a capital letter.
It ends as follows:
:endfunction
Let’s define a short function to return the smaller of two numbers, starting with this
declaration:
:function Min(num1, num2)
This tells Vim that the function is named Min and it takes two arguments (num1 and
num2).
The first thing you need to do is to check to see which number is smaller:
: if a:num1 < a:num2
The special prefix a: tells Vim that the variable is a function argument. Let’s assign the
variable smaller the value of the smallest number:
: if a:num1 < a:num2
: let smaller = a:num1
: else
: let smaller = a:num2
: endif
The variable smaller is a local variable. All variables used inside a function are local
unless prefixed by a g:.
Warning
A variable outside a function declaration is called var; whereas inside if you want to refer to the same
variable, you need to call it g:var. Therefore, one variable has two different names depending on the
context.
You now use the :return statement to return the smallest number to the user. Finally,
you end the function:
: return smaller
:endfunction
The complete function definition is as follows:
:function Min(num1, num2)
: if a:num1 < a:num2
: let smaller = a:num1
: else
: let smaller = a:num2
: endif
: return smaller
:endfunction
Note
I know that this function can be written more efficiently, but it is designed to be a tutorial of features,
not efficiency.

				63.1.24.8.1 Using a Function
You can now use your function in any Vim expression. For example:
:let tiny = Min(10, 20)
You can also call a function explicitly using the function name with the :call
command:
:[range] call {function}([parameters])
If a [range] is specified, the function is called for each line, unless the function is a special
“range”-type function (as discussed later).
Function Options
If you attempt to define a function that already exists, you will get an error.You can
use the force option (!) to cause the function to silently replace any previous definition
of the function:
:function Max(num1, num2)
: “ Code
:endfunction
:function Max(num1, num2, num3)
— error —
:function! Max(num1, num2, num3)
— no error —

By putting the range keyword after the function definition, the function is considered
a range function. For example:
:function Count_words() range
When run on a range of lines, the variables a:firstline and a:lastline are set to
the first and last line in the range.
If the word abort follows the function definition, the function aborts on the first
error. For example:
:function Do_It() abort
Finally, Vim enables you to define functions that have a variable number of arguments.
The following command, for instance, defines a function that must have 1 argument
(start) and can have up to 20 additional arguments:
:function Show(start, ...)
The variable a:1 contains the first optional argument, a:2 the second, and so on.The
variable a:0 contains the number of extra arguments. For example:
:function Show(start, ...)
: let index = 1 “ Loop index
: echo “Show is” a:start
:
: while (index <= a:0)
: echo “Arg” index “is “ a:index
: let index = index + 1
: endwhile
:endfunction

				63.1.24.8.2 Listing Functions
The :function command lists all the user-defined functions:
:function
function FTCheck_nroff()
function FTCheck_asm()
To see what is in a single function, execute this command:
:function {name}
For example:
:function Show
function Show
let index = 1 “ Loop index
echo “Show is” a:start
while (index <= a:0)
echo “Arg” index “is “a:.index
let index = index + 1
endwhile
endfunction

				63.1.24.8.3 Deleting a Function
To delete a function, use this command:
:delfunction name

Note: There's more information re. VIM programming in the OPL book and more Addendum for lists of commands etc.
Plus, there's a handy quick reference that can be printed.

			63.1.24.9

		63.1.25

	63.2 http://joyrex.spc.uchicago.edu/bookshelves/vim/regex.html#news

 	
Contents

 	
| I. News
| II. Introduction
| 2.1 What is VIM?
| 2.2 About this Tutorial
| 2.3 Credits
| III. Substitute Command
| 3.1 Search & Replace
| 3.2 Line Ranges & Addressing
| IV. Pattern Description 
| 4.1 Anchors
| 4.2 "Escaped" characters or metacharacters
| 4.3 Quantifiers, Greedy and Non-Greedy
| 4.4 Character ranges
| 4.5 Grouping and Backreferences
| 4.6 Alternations
| 4.7 Operator Precedence
| V. Global Command
| 5.1 Global search and execution
| 5.2 Examples
| VI. Examples
| 6.1 Tips & Techniques
| 6.2 Creating Outline
| 6.3 Working with Tables
| VII. Other Regexp Flavors
| VIII. Links
| 
I. News

 	
Finally, I've moved this page from City College's physlab server, which is no longer maintained.
VIM 6.0 is now official. A lot of changes and new features were introduced. I'll try to bring this page in a line with the current VIM version.
I no longer support the VIM reference guide. Stephan Heffner has voluntereed to update the guide.
II. Introduction

	63.2.2.1 What is VIM?

 	
Vim is an improved (in many ways) version of vi, a ubiquitous text editor found on any UNIX system. VIM was created by Bram Moolenaar with a help of other people. It's free but if you like it you can make a charitable contribution to orphans in Uganda.

Vim has its own web site, www.vim.org and several mailing lists, with a wealth of information on every aspect of VIM. Vim was successfully ported to nearly all existing OS. It is a default editor in many Linux distributions (e.g. RedHat).

VIM has all features of a modern programmer's editor - macro language, syntax highlighting, customizable user interface, easy integration with various IDEs plus a set of features which makes VIM so attractive to its users: crash recovery, automatic commands, session management.

VIM has a very broad and loyal user base. Over 10 million people have it installed (counting only Linux users). Estimation is that there are about half a million people using Vim as their main editor. And this number is growing.

	63.2.2.2 About this Tutorial

 	
I started this tutorial for one simple reason - I like regular expressions. Nothing compares to the satisfaction from a well-crafted regexp which does exactly what you wanted it to do :-). I hope it's passable as a foreword.

Speaking more seriously, regular expressions (or regexps for short) are tools used to manipulate text and data. They don't exist as a standalone product but usually are a part of some program/utility. The best known example is UNIX grep, a program to search files for lines that match certain pattern. The search pattern is described in terms of regular expressions. You can think of regexps as a specialized pattern language. Regexps are quite useful and can greatly reduce time it takes to do some tedious text editing.

(Regexp terminology is largely borrowed from Jeffrey Friedl "Mastering Regular Expressions.")

	63.2.2.3 Credits

 	
Many thanks (in no particular order): Benji Fisher, Zdenek Sekera, Preben "Peppe" Guldberg, Steve Kirkendall, Shaul Karl and all others who helped me with their comments.

Feel free to send me (volontir at yahoo dot com) your comments. suggestions, examples...

III. Substitute Command

 	
	63.2.3.1 Search & Replace

So, what can you do with regular expressions? The most common task is to make replacements in a text following some certain rules. For this tutorial you need to know VIM search and replace command (S&R) :substitute. Here is an excerpt from VIM help:

:range s[ubstitute]/pattern/string/cgiI
For each line in the range replace a match of the pattern with the string where:
c
Confirm each substitution
g
Replace all occurrences in the line (without g - only first).
i
Ignore case for the pattern.
I
Don't ignore case for the pattern.
Part of the command word enclosed in the "[" & "]" can be omitted.

	63.2.3.2 Range of Operation, Line Addressing and Marks

Before I begin with a pattern description let's talk about line addresses in Vim. Some Vim commands can accept a line range in front of them. By specifying the line range you restrict the command execution to this particular part of text only. Line range consists of one or more line specifiers, separated with a comma or semicolon. You can also mark your current position in the text typing ml , where "l" can be any letter, and use it later defining the line address.

Specifier
Description
number
an absolute line number
.
the current line
$
the last line in the file
%
the whole file. The same as 1,$
't
position of mark "t"
/pattern[/]
the next line where text "pattern" matches.
?pattern[?]
the previous line where text "pattern" matches
\/
the next line where the previously used search pattern matches
\?
the previous line where the previously used search pattern matches
\&
the next line where the previously used substitute pattern matches
If no line range is specified the command will operate on the current line only.

Here are a few examples:

10,20

- from 10 to 20 line.

Each may be followed (several times) by "+" or "-" and an optional number. This number is added or subtracted from the preceding line number. If the number is omitted, 1 is used.

/Section 1/+,/Section 2/-

- all lines between Section 1 and Section 2, non-inclusively, i.e. the lines containing Section 1 and Section 2 will not be affected.

The /pattern/ and ?pattern? may be followed by another address separated by a semicolon. A semicolon between two search patterns tells Vim to find the location of the first pattern, then start searching from that location for the second pattern.

/Section 1/;/Subsection/-,/Subsection/+

- first find Section 1, then the first line with Subsection, step one line down (beginning of the range) and find the next line with Subsection, step one line up (end of the range).

The next example shows how you can reuse you search pattern:

:/Section/+ y

- this will search for the Section line and yank (copy) one line after into the memory.

:// normal p

- and that will search for the next Section line and put (paste) the saved text on the next line.

 	
Tip 1: frequently you need to do S&R in a text which contains UNIX file paths - text strings with slashes ("/") inside. Because S&R command uses slashes for pattern/replacement separation you have to escape every slash in your pattern, i.e. use "\/" for every "/" in your pattern:

s/\/dir1\/dir2\/dir3\/file/dir4\/dir5\/file2/g

To avoid this so-called "backslashitis" you can use different separators in S&R (I prefer ":")

s:/dir1/dir2/dir3/file:/dir4/dir5/file2:g

Tip 2: You may find these mappings useful (put them in your .vimrc file)

noremap ;; :%s:::g<Left><Left><Left>
noremap ;' :%s:::cg<Left><Left><Left><Left>

These mappings save you some keystrokes and put you where you start typing your search pattern. After typing it you move to the replacement part , type it and hit return. The second version adds confirmation flag.

IV. Pattern Description

 	
	63.2.4.1 Anchors

Suppose you want to replace all occurrences of vi with VIM. This can be easily done with

s/vi/VIM/g

If you've tried this example then you, no doubt, noticed that VIM replaced all occurrences of vi even if it's a part of the word (e.g. navigator). If we want to be more specific and replace only whole words vi then we need to correct our pattern. We may rewrite it by putting spaces around vi:

s: vi : VIM :g

But it will still miss vi followed by the punctuation or at the end of the line/file. The right way is to put special word boundary symbols "\<" and "\>" around vi.

s:\<vi\>:VIM:g

The beginning and the end of the line have their own special anchors - "^" and "$", respectively. So, for all vi only at the start of the line:

s:^vi\>:VIM:

To match the lines where vi is the only word:

s:^vi$:VIM:

Now suppose you want to replace not only all vi but also Vi and VI. There are several ways to do this:

probably the simplest way is to put "i" - ignore case in a pattern %s:vi:VIM:gi
define a class of characters. This is a sequence of characters enclosed by square brackets "[" and "]". It matches any character from this set. So :%s:[Vv]i:VIM: will match vi and Vi. More on character ranges in the following section.
 	
	63.2.4.2 "Escaped" characters or metacharacters

So far our pattern strings were constructed from normal or literal text characters. The power of regexps is in the use of metacharacters. These are types of characters which have special meaning inside the search pattern. With a few exceptions these metacharacters are distinguished by a "magic" backslash in front of them. The table below lists some common VIM metacharacters.

#
Matching
#
Matching
.
any character except new line	 	 
\s
whitespace character	
\S
non-whitespace character
\d
digit	
\D
non-digit
\x
hex digit	
\X
non-hex digit
\o
octal digit	
\O
non-octal digit
\h
head of word character (a,b,c...z,A,B,C...Z and _)	
\H
non-head of word character
\p
printable character	
\P
like \p, but excluding digits
\w
word character	
\W
non-word character
\a
alphabetic character	
\A
non-alphabetic character
\l
lowercase character	
\L
non-lowercase character
\u
uppercase character	
\U
non-uppercase character
So, to match a date like 09/01/2000 you can use (assuming you don't use "/" as a separator in the S&R)

\d\d/\d\d/\d\d\d\d

To match 6 letter word starting with a capital letter

\u\w\w\w\w\w

Obviously, it is not very convenient to write \w for any character in the pattern - what if you don't know how many letters in your word? This can be helped by introducing so-called quantifiers.

 	
	63.2.4.3 Quantifiers, Greedy and Non-Greedy

Using quantifiers you can set how many times certain part of you pattern should repeat by putting the following after your pattern:

Quantifier
Description
*
matches 0 or more of the preceding characters, ranges or metacharacters .* matches everything including empty line
\+
matches 1 or more of the preceding characters...
\=
matches 0 or 1 more of the preceding characters...
\{n,m}
matches from n to m of the preceding characters...
\{n}
matches exactly n times of the preceding characters...
\{,m}
matches at most m (from 0 to m) of the preceding characters...
\{n,}
matches at least n of of the preceding characters...
where n and m are positive integers (>0)
Now it's much easier to define a pattern that matches a word of any length \u\w\+.

These quantifiers are greedy - that is your pattern will try to match as much text as possible. Sometimes it presents a problem. Let's consider a typical example - define a pattern to match delimited text, i.e. text enclosed in quotes, brackets, etc. Since we don't know what kind of text is inside the quotes we'll use

/".*"/

But this pattern will match everything between the first " and the last " in the following line:

this file is normally "$VIM/.gvimrc". You can check this with ":version".

This problem can be resolved by using non-greedy quantifiers:

Quantifier
Description
\{-}
matches 0 or more of the preceding atom, as few as possible
\{-n,m}
matches 1 or more of the preceding characters...
\{-n,}
matches at lease or more of the preceding characters...
\{-,m}
matches 1 or more of the preceding characters...
where n and m are positive integers (>0)
Let's use \{-} in place of * in our pattern. So, now ".\{-}" will match the first quoted text:

this file is normally "$VIM/gvimrc". You can check this with ":version".

.\{-} pattern is not without surprises. Look what will happen to the following text after we apply:

:s:.\{-}:_:g

Before:

n and m are decimal numbers between

After:

_n_ _a_n_d_ _m_ _a_r_e_ _d_e_c_i_m_a_l_ _n_u_m_b_e_r_s_ _b_e_t_w_e_e_n_

"As few as possible" applied here means zero character replacements. However match does occur between characters! To explain this behavior I quote Bram himself:

Matching zero characters is still a match. Thus it will replace zero characters with a "_". And then go on to the next position, where it will match again.

It's true that using "\{-}" is mostly useless. It works this way to be consistent with "*", which also matches zero characters. There are more useless ones: "x\{-1,}" always matches one x. You could just use "x". More useful is something like "x\{70}". The others are just consistent behavior: ..., "x\{-3,}", "x\{-2,}", "x\{-1,}.

- Bram

But what if we want to match only the second occurrence of quoted text? Or we want to replace only a part of the quoted text keeping the rest untouched? We will need grouping and backreferences. But before let's talk more about character ranges.

 	
	63.2.4.4 Character ranges

Typical character ranges:

[012345] will match any of the numbers inside the brackets. The same range can be written as [0-5], where dash indicates a range of characters in ASCII order. Likewise, we can define the range for all lowercase letters: [a-z], for all letters: [a-zA-Z], letters and digits: [0-9a-zA-Z] etc. Depending on your system locale you can define range which will include characters like à, Ö, ß and other non ASCII characters.

Note that the range represents just one character in the search pattern, that is [0123] and 0123 are not the same. Likewise the order (with a few exceptions) is not important: [3210] and [0123] are the same character ranges, while 0123 and 3210 are two different patterns. Watch what happens when we apply

s:[65]:Dig:g

to the following text:

Before:

High 65 to 70. Southeast wind around 10

After:

High DigDig to 70. Southeast wind around 10

and now:

s:65:Dig:g

Before:

High 65 to 70. Southeast wind around 10

After:

High Dig to 70. Southeast wind around 10

Sometimes it's easier to define the characters you don't want to match. This is done by putting a negation sign "^" (caret) as a first character of the range

/[^A-Z]/

- will match any character except capital letters. We can now rewrite our pattern for quoted text using

/"[^"]\+"/

Note: inside the [ ] all metacharacters behave like ordinary characters. If you want to include "-" (dash) in your range put it first

/[-0-9]/

- will match all digits and -. "^" will lose its special meaning if it's not the first character in the range.

Now, let's have some real life example. Suppose you want to run a grammar check on your file and find all places where new sentence does not start with a capital letter. The pattern that will catch this:

\.\s\+[a-z]

- a period followed by one or more blanks and a lowercase word. We know how to find an error, now let's see how we can correct it. To do this we need some ways to remember our matched pattern and recall it later. That is exactly what backreferences are for.

 	
	63.2.4.5 Grouping and Backreferences

You can group parts of the pattern expression enclosing them with "\(" and "\)" and refer to them inside the replacement pattern by their special number \1, \2 ... \9. Typical example is swapping first two words of the line:

s:\(\w\+\)\(\s\+\)\(\w\+\):\3\2\1:
where \1 holds the first word, \2 - any number of spaces or tabs in between and \3 - the second word. How to decide what number holds what pair of \(\) ? - count opening "\(" from the left.

Replacement Part of :substitute

Replacement part of the S&R has its own special characters which we are going to use to fix grammar:

#
Meaning
#
Meaning
&
the whole matched pattern	
\L
the following characters are made lowercase
\0
the whole matched pattern	
\U
the following characters are made uppercase
\1
the matched pattern in the first pair of \(\)	
\E
end of \U and \L
\2
the matched pattern in the second pair of \(\)	
\e
end of \U and \L
...
...	
\r
split line in two at this point
\9
the matched pattern in the ninth pair of \(\)	
\l
next character made lowercase
~
the previous substitute string	
\u
next character made uppercase
Now the full S&R to correct non-capital words at the beginning of the sentences looks like

s:\([.!?]\)\s\+\([a-z]\):\1  \u\2:g

We have corrected our grammar and as an extra job we replaced variable number of spaces between punctuation and the first letter of the next sentence with exactly two spaces.

 	
	63.2.4.6 Alternations

Using "\|" you can combine several expressions into one which matches any of its components. The first one matched will be used.

\(Date:\|Subject:\|From:\)\(\s.*\)

will parse various mail headings and their contents into \1 and \2, respectively. The thing to remember about VIM alternation that it is not greedy. It won't search for the longest possible match, it will use the first that matched. That means that the order of the items in the alternation is important!
 	
Tip 3: Quick mapping to put \(\) in your pattern string

cmap ;\ \(\)<Left><Left>

 	
	63.2.4.7 Regexp Operator Precedence

As in arithmetic expressions, regular expressions are executed in a certain order of precedence. Here the table of precedence, from highest to lowest:

Precedence
Regexp
Description
1
\( \)
grouping
2
\=,\+,*,\{n} etc.
quantifiers
3
abc\t\.\w
sequence of characters/ metacharacters, not containing quantifiers or grouping operators
4
\|
alternation
V. Global Command

 	
	63.2.5.1 Global search and execution

I want to introduce another quite useful and powerful Vim command which we're going to use later

:range g[lobal][!]/pattern/cmd
Execute the Ex command cmd (default ":p") on the lines within [range] where pattern matches. If pattern is preceded with a ! - only where match does not occur.
The global commands work by first scanning through the [range] of of the lines and marking each line where a match occurs. In a second scan the [cmd] is executed for each marked line with its line number prepended. If a line is changed or deleted its mark disappears. The default for the [range] is the whole file.

Note: Ex commands are all commands you are entering on the Vim command line like :s[ubstitute], :co[py] , :d[elete], :w[rite] etc. Non-Ex commands (normal mode commands) can be also executed via

:norm[al]non-ex command

mechanism.

	63.2.5.2 Examples

Some examples of :global usage:

:g/^$/ d

- delete all empty lines in a file

:g/^$/,/./-j

- reduce multiple blank lines to a single blank

:10,20g/^/ mo 10

- reverse the order of the lines starting from the line 10 up to the line 20.

Here is a modified example from Walter Zintz vi tutorial:

:'a,'b g/^Error/ . w >> errors.txt

- in the text block marked by 'a and 'b find all the lines starting with Error and copy (append) them to "errors.txt" file. Note: . (current line address) in front of the w is very important, omitting it will cause :write to write the whole file to "errors.txt" for every Error line found.

You can give multiple commands after :global using "|" as a separator. If you want to use "|' in an argument, precede it with "\'. Another example from Zintz tutorial:

:g/^Error:/ copy $ | s /Error/copy of the error/

- will copy all Error line to the end of the file and then make a substitution in the copied line. Without giving the line address :s will operate on the current line, which is the newly copied line.

:g/^Error:/ s /Error/copy of the error/ | copy $

- here the order is reversed: first modify the string then copy to the end.

 	 
VI. Examples

 	
	63.2.6.1 Tips and Techniques

A collection of some useful S&R tips:

(1) sent by Antonio Colombo:

"a simple regexp I use quite often to clean up a text: it drops the blanks at the end of the line:"

s:\s*$::

or (to avoid acting on all lines):

s:\s\+$::

 	
	63.2.6.2 Creating outline

For this example you need to know a bit of HTML. We want to make a table of contents out of h1 and h2 headings, which I will call majors and minors. HTML heading h1 is a text enclosed by <h1> tags as in <h1>Heading</h1>.

(1) First let's make named anchors in all headings, i.e. put <h1><a name="anchor">Heading</a></h1> around all headings. The "anchor" is a unique identifier of this particular place in HTML document. The following S&R does exactly this:

:s:\(<h[12]>\)\(.*\s\+\([-a-zA-Z]\+\)\)\s*\(</h[12]>\):\1<a name="\3">\2</a>\4:

Explanation: the first pair of \(\) saves the opening tag (h1 or h2) to the \1, the second pair saves all heading text before the closing tag, the third pair saves the last word in the heading which we will later use for "anchor" and the last pair saves the closing tag. The replacement is quite obvious - we just reconstruct a new "named" heading using \1-\4 and link tag <a>.

(2) Now let's copy all headings to one place:

:%g/<h[12]>/ t$

This command searches our file for the lines starting with <h1> or <h2> and copies them to the end of the file. Now we have a bunch of lines like:

<h1><a name="anchor1">Heading1></a></h1>
<h2><a name="anchor2">Heading2></a></h2>
<h2><a name="anchor3">Heading3></a></h2>
..........................
<h1><a name="anchorN">HeadingN></a></h1>

First, we want to convert all name=" to href="# in order to link table entries to their respective places in the text:

s:name=":href="#:

Second, we want our h1 entries look different from h2. Let's define CSS classes "majorhead" and "minorhead" and do the following:

g/<h1>/ s:<a:& class="majorhead":
g/<h2>/ s:<a:& class="minorhead":

Now our entries look like:

<h1><a class="majorhead" name="anchor1">Heading1></a></h1>
<h2><a class="minorhead" name="anchor2">Heading2></a></h2>

We no longer need h1 and h2 tags:

s:<h[21]>::

and replace closing tags with breaklines <br>

s:/h[21]:br:

<a class="majorhead" name="anchor1">Heading1></a><br>
<a class="minorhead" name="anchor2">Heading2></a><br>

 	
	63.2.6.3 Working with Tables

Quite often you have to work with a text organized in tables/columns. Consider, for example, the following text

Asia
America
Africa
Europe
Africa
Europe
Europe
Africa
Europe
Asia
Europe
Europe
Suppose we want to change all "Europe" cells in the third column to "Asia":

:%s:\(\(\w\+\s\+\)\{2}\)Europe:\1Asia:

Asia
America
Africa
Europe
Africa
Europe
Asia
Africa
Europe
Asia
Asia
Europe
 

To swap the first and the last columns:

:%s:\(\w\+\)\(.*\s\+\)\(\w\+\)$:\3\2\1:

Europe
America
Africa
Asia
Africa
Europe
Europe
Africa
Europe
Asia
Europe
Europe
 

To be continued...

 	 
VII. Other Regexp Flavors

 	
Here I would like to compare Vim's regexp implementation with others, in particular, Perl's. You can't talk about regular expressions without mentioning Perl.

(with a help from Steve Kirkendall) The main differences between Perl and Vim are:

Perl doesn't require backslashes before most of its operators. Personally, I think it makes regexps more readable - the less backlashes are there the better.
Perl allows you to convert any quantifier into a non-greedy version by adding an extra ? after it. So *? is a non-greedy *.
Perl supports a lots of weird options that can be appended to the regexp, or even embedded in it.
You can also embed variable names in a Perl regular expression. Perl replaces the name with its value; this is called "variable interpolation".
VIII. Links

 	
Read VIM documentation about pattern and searching. To get this type ":help pattern" in VIM normal mode.

There are currently two books on the market that deal with VIM regular expressions:

"Learning the vi Editor" by Linda Lamb and Arnold Robbins.
"vi Improved - VIM" by Steve Oualline
Definitive reference on regular expressions is Jeffrey Friedl's "Mastering Regular Expressions" published by O'Reilly & Associates, but it mostly deals with Perl regular expressions. O'Reilly has one of the book chapters available online.

 	

	63.3

64. FAQ

	64.1 How to delete, as in close buffers?
:1,nbd
1,n range
bd - buffer delete

	64.2 command line file name modifiers , %: operator

		64.2.1 :h filename-modifiers
 *filename-modifiers*

	 *:_%:* *::8* *::p* *::.* *::~* *::h* *::t* *::r* *::e* *::s* *::gs*

	        *%:8* *%:p* *%:.* *%:~* *%:h* *%:t* *%:r* *%:e* *%:s* *%:gs*
The file name modifiers can be used after "%", "#", "#n", "<cfile>", "<sfile>",
"<afile>" or "<abuf>".  They are also used with the |fnamemodify()| function.
These are not available when Vim has been compiled without the |+modify_fname|
feature.
These modifiers can be given, in this order:
	:p	Make file name a full path.  Must be the first modifier.  Also
		changes "~/" (and "~user/" for Unix and VMS) to the path for
		the home directory.  If the name is a directory a path
		separator is added at the end.  For a file name that does not
		exist and does not have an absolute path the result is
		unpredictable.
	:8	Converts the path to 8.3 short format (currently only on
		win32).  Will act on as much of a path that is an existing
		path.
	:~	Reduce file name to be relative to the home directory, if
		possible.  File name is unmodified if it is not below the home
		directory.
	:.	Reduce file name to be relative to current directory, if
		possible.  File name is unmodified if it is not below the
		current directory.
		For maximum shortness, use ":~:.".
	:h	Head of the file name (the last component and any separators
		removed).  Cannot be used with :e, :r or :t.
		Can be repeated to remove several components at the end.
		When the file name ends in a path separator, only the path
		separator is removed.  Thus ":p:h" on a directory name results
		on the directory name itself (without trailing slash).
		When the file name is an absolute path (starts with "/" for
		Unix; "x:\" for MS-DOS, WIN32, OS/2; "drive:" for Amiga), that
		part is not removed.  When there is no head (path is relative
		to current directory) the result is empty.
	:t	Tail of the file name (last component of the name).  Must
		precede any :r or :e.
	:r	Root of the file name (the last extension removed).  When
		there is only an extension (file name that starts with '.',
		e.g., ".vimrc"), it is not removed.  Can be repeated to remove
		several extensions (last one first).
	:e	Extension of the file name.  Only makes sense when used alone.
		When there is no extension the result is empty.
		When there is only an extension (file name that starts with
		'.'), the result is empty.  Can be repeated to include more
		extensions.  If there are not enough extensions (but at least
		one) as much as possible are included.
	:s?pat?sub?
		Substitute the first occurrence of "pat" with "sub".  This
		works like the |:s| command.  "pat" is a regular expression.
		Any character can be used for '?', but it must not occur in
		"pat" or "sub".
		After this, the previous modifiers can be used again.  For
		example ":p", to make a full path after the substitution.
	:gs?pat?sub?
		Substitute all occurrences of "pat" with "sub".  Otherwise
		this works like ":s".

Examples, when the file name is "src/version.c", current dir
"/home/mool/vim":
  :p			/home/mool/vim/src/version.c
  :p:.				       src/version.c
  :p:~				 ~/vim/src/version.c
  :h				       src
  :p:h			/home/mool/vim/src
  :p:h:h		/home/mool/vim
  :t					   version.c
  :p:t					   version.c
  :r				       src/version
  :p:r			/home/mool/vim/src/version
  :t:r					   version
  :e						   c
  :s?version?main?		       src/main.c
  :s?version?main?:p	/home/mool/vim/src/main.c
  :p:gs?/?\\?		\home\mool\vim\src\version.c

Examples, when the file name is "src/version.c.gz":
  :p			/home/mool/vim/src/version.c.gz
  :e						     gz
  :e:e						   c.gz
  :e:e:e					   c.gz
  :e:e:r					   c
  :r				       src/version.c
  :r:e						   c
  :r:r				       src/version
  :r:r:r			       src/version
 

					*extension-removal* *:_%<*
If a "<" is appended to "%", "#", "#n" or "CTRL-V p" the extension of the file
name is removed (everything after and including the last '.' in the file
name).  This is included for backwards compatibility with version 3.0, the
":r" form is preferred.  Examples:

	%		current file name
	%<		current file name without extension
	#		alternate file name for current window
	#<		idem, without extension
	#31		alternate file number 31
	#31<		idem, without extension
	<cword>		word under the cursor
	<cWORD>		WORD under the cursor (see |WORD|)
	<cfile>		path name under the cursor
	<cfile><	idem, without extension

Note: Where a file name is expected wildcards expansion is done.  On Unix the
shell is used for this, unless it can be done internally (for speed).
Backticks also work, like in
	:n `echo *.c`
(backtick expansion is not possible in |restricted-mode|)
But expansion is only done if there are any wildcards before expanding the
'%', '#', etc..  This avoids expanding wildcards inside a file name.  If you
want to expand the result of <cfile>, add a wildcard character to it.
Examples: (alternate file name is "?readme?")
	command		expands to  
	:e #		:e ?readme?
	:e `ls #`	:e {files matching "?readme?"}
	:e #.*		:e {files matching "?readme?.*"}
	:cd <cfile>	:cd {file name under cursor}
	:cd <cfile>*	:cd {file name under cursor plus "*" and then expanded}

When the expanded argument contains a "!" and it is used for a shell command
(":!cmd", ":r !cmd" or ":w !cmd"), the "!" is escaped with a backslash to
avoid it being expanded into a previously used command.  When the 'shell'
option contains "sh", this is done twice, to avoid the shell trying to expand
the "!".


							*filename-backslash*
For filesystems that use a backslash as directory separator (MS-DOS, Windows,
OS/2), it's a bit difficult to recognize a backslash that is used to escape
the special meaning of the next character.  The general rule is: If the
backslash is followed by a normal file name character, it does not have a
special meaning.  Therefore "\file\foo" is a valid file name, you don't have
to type the backslash twice.

An exception is the '$' sign.  It is a valid character in a file name.  But
to avoid a file name like "$home" to be interpreted as an environment variable,
it needs to be preceded by a backslash.  Therefore you need to use "/\$home"
for the file "$home" in the root directory.  A few examples:

	FILE NAME	INTERPRETED AS	
	$home		expanded to value of environment var $home
	\$home		file "$home" in current directory
	/\$home		file "$home" in root directory
	\\$home		file "\\", followed by expanded $home

		64.2.2 How to echo or print filename with modifies
Register % contains the name of the current file, and register # contains the name of the alternate file. These registers allow the name of the current or alternate files to be displayed or inserted. The name, or full path, or directory containing the file can be used.

For example, in directory /abc the command vim def/my.txt would edit file /abc/def/my.txt. The following commands could be entered to display the information shown.

:echo @% 	def/my.txt	directory/name of file (relative to the current working directory of /abc)
:echo expand('%:t') 	my.txt	name of file ('tail')
:echo expand('%:p') 	/abc/def/my.txt	full path
:echo expand('%:p:h')	/abc/def	directory containing file ('head')
:echo expand('%:p:h:t')	def	First get the full path with :p (/abc/def/my.txt), then get the head of that with :h (/abc/def), then get the tail of that with :t (def)
For more info run :help expand

If all that is wanted is to display the name of the current file, type Ctrl-G (or press 1 then Ctrl-G for the full path).

When using @%, the name is displayed relative to the current directory.

In insert mode, type Ctrl-R then % to insert the name of the current file.

In command mode (after typing a colon), type Ctrl-R then % to insert the name of the current file. The inserted name can then be edited to create a similar name.

In normal mode, type "%p to put the name of the current file after the cursor (or "%P to insert the name before the cursor).

The following commands insert lines consisting of the full path of the current and alternate files into the buffer:

:put =expand('%:p')
:put =expand('#:p')
		64.2.3

	64.3 Make-compile current buffer
Compile with gccEdit
If you use
set makeprg=gcc\ -o\ %<\ %
in your vimrc, and your actual file is file.c, then :make will compile file.c with the output file. (gcc file.c -o file).
If you use GNU make the above change is not required. Instead, simply use the following command to compile the current file (you need to save it first):

:make %:r
When using other compilers, like Sun cc, you can adapt the tip to suit your compiler.

my example:
amenu &MyMenu.SetAcsMake            :set makeprg=makec\ %< <cr>
amenu &MyMenu.SetSingleFileMake            :set makeprg=g++\ -g\ -O2\ -fPIC\ -o\ %.o\ -c\ % <cr>
amenu &MyMenu.SetDefaultMakeCurrDirFromRoot            :cd %:p:h <CR> :set makeprg=makec  <cr> : cd - <cr>

	64.4 E464: Ambiguous use of user-defined command
> Hello, 
> Using the standard windows _vimrc and typing 
> :V 
> generates the message 
> E464: Ambiguous use of user-defined command 
> 
> Typing 
> :h :V 
> only gives netrw command :Vexplore 
> 
> In the list in index.txt, I found no other command starting with :V 
> 
> Why this E464 error? 

In the command line, type :V followed by a Tab. This lists all commands 
that start with :V 
(You probably also have :VimballList and :Vimuntar) 

You can then use :verbose :com <command-name> to find out, where this 
command was defined. 

	64.5 Setting a Language for vim Syntax Highlighting
One can force the language for vim syntax highlighting with

:setf  language
Examples

For C:

:setf c
For PHP:

:setf php
For XML:

:setf xml
Update: An Alternative

In the comments below, Vladimir wrote:

Another way is :set filetype=language

Simple executing :set filetype will show current language used for syntax highlighting.	
	64.6 Changing case with regular expressions


There are times that you might like to go through a file and change the case of characters that match some arbitrary criteria. If you understand regular expressions well, you can actually do this fairly easily.

It's as simple as placing \U or \L in front of backreferences which you want to change the case of, and \E at the end. Vim will make the text in the backreference uppercase or lowercase (respectively). Use \u and \l (without the \E at the end) to just change the case of the very first character in the backreference.

(A "backreference" is a part of a regular expression that refers to a previous part of a regular expression. The most common backreferences are &, \1, \2, \3, ... , \9).

Some examples that demonstrate the power of this technique:

Lowercase the entire file

:%s/.*/\L&/g
(& is a handy backreference that refers to the complete text of the match.)

Uppercase all words that are preceded by a < (i.e. opening HTML tag names):

:%s/<\(\w*\)/<\U\1/g
ReferencesEdit
:help sub-replace-special
CommentsEdit
Note also the gu<motion> and gU<motion> commands.

For example, ggguG will lowercase the entire file. (gg = go to top, gu = lowercase, G = go to EOF).

By using the \0 general backref instead of the name ones (\1, \2 etc) you can save some typing for on replace stanza of the regex.

This regex upper cases an explicit set of words to uppercase in a file.
:%s/\(select\)\|\(order)\|\(by\)\|\(from\)\|\(where\)/\U\0/g

Not rocket science, but otherwise you'd have to do this:
:%s/\(select\)\|\(order)\|\(by\)\|\(from\)\|\(where\)/\U\1\U\2\U\3\U\4\U\5/g

[edit:  Much easier to just use this, where either 0 or 1 will work:]
:%s/\(select\|order\|by\|from\|where\)/\U\1/g
convert HTML-Tags to uppercase

:%s/<\/\=\(\w\+\)\>/\U&/g
or to lowercase

:%s/<\/\=\(\w\+\)\>/\L&/g
	64.7 Copy the full path of current buffer to clipboard
You can assign to the clipboard with the special + register:

:let @+ = expand('%:p')
If you want to make this easier, you could create a command, so you only have to type :CopyBuffer:

:command! CopyBuffer let @+ = expand('%:p')
and/or map it to a key:

:nnoremap <Leader>c :let @+=expand('%:p')<CR>

	64.8 Why does vim always say 'Already at oldest change' when I try to undo?

		64.8.1  Negative undolevels
This happens when undolevels is negative which is apparently used to keep vim undo from using up memory. For some reason my undolevels was set to -123456.

Set your undolevels to a big positive number like 999999 and everything will return to normal.

You may also want to check your .vim file trees and such, if you're using plugins and states that do this, to persist settings on a per file basis, that they don't have 'setlocal' undolevel settings inside them. I had to clear out several dozen such nefarious configurations.

-> Fix:
set undolevels=9999

-> echo value
set undolevels

	64.9 yank current buffer file name and path 
To clipboard:
:let @" = expand("%")
this will copy the file name to the unamed register, then you can use good old 'p' to paste it. and of course you can map this to a key for quicker use.

:nmap cp :let @" = expand("%")
you can also use this for full path

:let @" = expand("%:p")

replace " w/ a-z for named registers.
e.g. 
let @a=@% 
or to guarantee full path
:let @a = expand("%:p")

	64.10 remove new line at the end of file
Run these following commands in VIM:

:set binary
:set noeol
:wq
Please NOTE that the above commands are VIM commands and not shell commands.

Basically, we set the file as a binary file, then we command VIM not to have EOL (End Of Line) and then write and quit the file.

This will change only for the particular file that you open explicitly. If you want to have these changes set for all the file you edit with VIM then you need to add the following lines to your ~/.vimrc file:

set binary
set noeol


Read more https://www.explorelinux.com/vim-removing-new-line-end-file-vimRun these following commands in VIM:

:set binary
:set noeol
:wq
Please NOTE that the above commands are VIM commands and not shell commands.

Basically, we set the file as a binary file, then we command VIM not to have EOL (End Of Line) and then write and quit the file.

This will change only for the particular file that you open explicitly. If you want to have these changes set for all the file you edit with VIM then you need to add the following lines to your ~/.vimrc file:

set binary
set noeol


Read more https://www.explorelinux.com/vim-removing-new-line-end-file-vim//

	64.11 vim buftype option is set (can't save file)
    to fix
    : set bt=

65.  Working Productively in Bash's Vi Command Line Editing Mode (with Cheat Sheet)

	65.1  Brief overview


bash readline vi editing mode default keyboard shortcut cheat sheet

Bash provides two modes for command line editing - emacs and vi. Emacs editing mode is the default and I already wrote an article and created a cheat sheet for this mode.

This time I am going to introduce you to bash's vi editing mode and give out a detailed cheat sheet with the default keyboard mappings for this mode.

The difference between the two modes is what command each key combination (or key) gets bound to. You may inspect your current keyboard mappings with bash's built in bind command:

$ bind -P

abort can be found on "\C-g", "\C-x\C-g", "\M-\C-g".
accept-line can be found on "\C-j", "\C-m".
alias-expand-line is not bound to any keys
...

To get into the vi editing mode type

 
$ set -o vi

in your bash shell (to switch back to emacs editing mode, type set -o emacs).

If you are used to a vi text editor you will feel yourself at home.

The editing happens in two modes - command mode and insert mode. In insert mode everything you type gets output to the terminal, but in the command mode the keys are used for various commands.

Here are a few examples with screenshots to illustrate the vi editing mode.

Let '[i]' be the position of cursor in insert mode in all the examples and '[c]' be the position of cursor in command mode.

Examples:

Once you have changed the readline editing mode to vi (by typing set -o vi), you will be working in insert mode.

The example will be performed on this command:

$ echo arg1 arg2 arg3 arg4[i]

Example 1:

Suppose you have typed a command with a few arguments and want to insert another argument before an argument which is three words backward.

$ echo arg1 (want to insert arg5 here) arg2 arg3 arg4[i]

Hit 'ESC' to switch to command mode and press '3' followed by 'B':

$ echo arg1 [c]arg2 arg3 arg4

Alternatively you could have hit 'B' three times: 'BBB'.

Now, enter insert mode by hitting 'i' and type 'arg5 '

$ echo arg1 arg5 [i]arg2 arg3 arg4

Example 2:

Suppose you wanted to change arg2 to arg5:

$ echo arg1 [c]arg2 arg3 arg4

To do this, you can type 'cw' which means 'change word' and just type out 'arg5':

$ echo arg1 arg5[c] arg3 arg4

Or even quicker, you can type 'f2r5', where 'f2' moves the cursor right to next occurrence of character '2' and 'r5' replaces the character under the cursor with character '5'.

Example 3:

Suppose you typed a longer command and you noticed that you had made several mistakes, and wanted to do the correction in the vi editor itself. You can type 'v' to edit the command in the editor and not on the command line!

Example 4:

Suppose you typed a long command and remembered that you had to execute another one before it. No need to erase the current command! You can switch to command mode by hitting ESC and then type '#' which will send the current command as a comment in the command history. After you type the command you had forgotten, you may go two commands back in history by typing 'kk' (or '2k'), erase the '#' character which was appended as a comment and execute the command, this makes the whole command look like 'ESC 2k0x ENTER'.

These are really basic examples, and it doesn't get much more complex than this. You should check out the cheat sheet for other tips and examples, and try them out!

To create the cheat sheet, I downloaded bash-2.05b source code and scanned through lib/readline/vi_keymap.c source code file and lib/readline/vi_mode.c to find all the default key bindings.

It turned out that the commands documented in vi_keymap.c were all documented in man 3 readline and I didn't find anything new.

After that I checked bashline.c source file function initialize_readline to find how the default keyboard shortcuts were changed. I found that 'CTRL-e' (which switched from vi mode to emacs) got undefined, 'v' got defined which opens the existing command in the editor, and '@' which replaces a macro key (char) with the corresponding string.

The cheat sheet includes:

    Commands for entering input mode,
    Basic movement commands,
    Character finding commands,
    Character finding commands,
    Deletion commands,
    Undo, redo and copy/paste commands,
    Commands for history manipulation,
    Completion commands,
    A few misc. commands, and
    Tips and examples

	65.2 CheatSheet

.---------------------------------------------------------------------------.
|                                                                           |
|                          Readline VI Editing Mode                         |
|                     Default Keyboard Shortcuts for Bash                   |
|                               Cheat Sheet                                 |
|                                                                           |
'---------------------------------------------------------------------------'
| Peteris Krumins (peter@catonmat.net), 2008.01.08                          |
| http://www.catonmat.net  -  good coders code, great reuse                 |
|                                                                           |
| Released under the GNU Free Document License                              |
'---------------------------------------------------------------------------'

 ======================== Keyboard Shortcut Summary ========================

.--------------.------------------------------------------------------------.
|              |                                                            |
| Shortcut     | Description                                                |
|              |                                                            |
'--------------'------------------------------------------------------------'
| Switching to COMMAND Mode:                                                |
'--------------.------------------------------------------------------------'
| ESC          | Switch to command mode.                                    |
'--------------'------------------------------------------------------------'
| Commands for Entering INPUT Mode:                                         |
'--------------.------------------------------------------------------------'
| i            | Insert before cursor.                                      |
'--------------+------------------------------------------------------------'
| a            | Insert after cursor.                                       |
'--------------+------------------------------------------------------------'
| I            | Insert at the beginning of line.                           |
'--------------+------------------------------------------------------------'
| A            | Insert at the end of line.                                 |
'--------------+------------------------------------------------------------'
| c<mov. comm> | Change text of a movement command <mov. comm> (see below). |
'--------------+------------------------------------------------------------'
| C            | Change text to the end of line (equivalent to c$).         |
'--------------+------------------------------------------------------------'
| cc or S      | Change current line (equivalent to 0c$).                   |
'--------------+------------------------------------------------------------'
| s            | Delete a single character under the cursor and enter input |
|              | mode (equivalent to c[SPACE]).                             |
'--------------+------------------------------------------------------------'
| r            | Replaces a single character under the cursor (without      |
|              | leaving command mode).                                     |
'--------------+------------------------------------------------------------'
| R            | Replaces characters under cursor.                          |
'--------------+------------------------------------------------------------'
| v            | Edit (and execute) the current command in the text editor. |
|              | (an editor defined in $VISUAL or $EDITOR variables, or vi  |
'--------------'------------------------------------------------------------'
| Basic Movement Commands (in command mode):                                |
'--------------.------------------------------------------------------------'
| h            | Move one character right.                                  |
'--------------+------------------------------------------------------------'
| l            | Move one character left.                                   |
'--------------+------------------------------------------------------------'
| w            | Move one word or token right.                              |
'--------------+------------------------------------------------------------'
| b            | Move one word or token left.                               |
'--------------+------------------------------------------------------------'
| W            | Move one non-blank word right.                             |
'--------------+------------------------------------------------------------'
| B            | Move one non-blank word left.                              |
'--------------+------------------------------------------------------------'
| e            | Move to the end of the current word.                       |
'--------------+------------------------------------------------------------'
| E            | Move to the end of the current non-blank word.             |
'--------------+------------------------------------------------------------'
| 0            | Move to the beginning of line                              |
'--------------+------------------------------------------------------------'
| ^            | Move to the first non-blank character of line.             |
'--------------+------------------------------------------------------------'
| $            | Move to the end of line.                                   |
'--------------+------------------------------------------------------------'
| %            | Move to the corresponding opening/closing bracket.         |
'--------------'------------------------------------------------------------'
| Character Finding Commands (these are also Movement Commands):            |
'--------------.------------------------------------------------------------'
| fc           | Move right to the next occurance of char c.                |
'--------------+------------------------------------------------------------'
| Fc           | Move left to the previous occurance of c.                  |
'--------------+------------------------------------------------------------'
| tc           | Move right to the next occurance of c, then one char       |
|              | backward.                                                  |
'--------------+------------------------------------------------------------'
| Tc           | Move left to the previous occurance of c, then one char    |
|              | forward.                                                   |
'--------------+------------------------------------------------------------'
| ;            | Redo the last character finding command.                   |
'--------------+------------------------------------------------------------'
| ,            | Redo the last character finding command in opposite        |
|              | direction.                                                 |
'--------------+------------------------------------------------------------'
| |            | Move to the n-th column (you may specify the argument n by |
|              | typing it on number keys, for example, 20|)                |
'--------------'------------------------------------------------------------'
| Deletion Commands:                                                        |
'--------------.------------------------------------------------------------'
| x            | Delete a single character under the cursor.                |
'--------------+------------------------------------------------------------'
| X            | Delete a character before the cursor.                      |
'--------------+------------------------------------------------------------'
| d<mov. comm> | Delete text of a movement command <mov. comm> (see above). |
'--------------+------------------------------------------------------------'
| D            | Delete to the end of the line (equivalent to d$).          |
'--------------+------------------------------------------------------------'
| dd           | Delete current line (equivalent to 0d$).                   |
'--------------+------------------------------------------------------------'
| CTRL-w       | Delete the previous word.                                  |
'--------------+------------------------------------------------------------'
| CTRL-u       | Delete from the cursor to the beginning of line.           |
'--------------'------------------------------------------------------------'
| Undo, Redo and Copy/Paste Commands:                                       |
'--------------.------------------------------------------------------------'
| u            | Undo previous text modification.                           |
'--------------+------------------------------------------------------------'
| U            | Undo all previous text modifications.                      |
'--------------+------------------------------------------------------------'
| .            | Redo the last text modification.                           |
'--------------+------------------------------------------------------------'
| y<mov. comm> | Yank a movement into buffer (copy).                        |
'--------------+------------------------------------------------------------'
| yy           | Yank the whole line.                                       |
'--------------+------------------------------------------------------------'
| p            | Insert the yanked text at the cursor.                      |
'--------------+------------------------------------------------------------'
| P            | Insert the yanked text before the cursor.                  |
'--------------'------------------------------------------------------------'
| Commands for Command History:                                             |
'--------------.------------------------------------------------------------'
| k            | Insert the yanked text before the cursor.                  |
'--------------+------------------------------------------------------------'
| j            | Insert the yanked text before the cursor.                  |
'--------------+------------------------------------------------------------'
| G            | Insert the yanked text before the cursor.                  |
'--------------+------------------------------------------------------------'
| /string or   | Search history backward for a command matching string.     |
| CTRL-r       |                                                            |
'--------------+------------------------------------------------------------'
| ?string or   | Search history forward for a command matching string.      |
| CTRL-s       | (Note that on most machines Ctrl-s STOPS the terminal      |
|              | output, change it with `stty' (Ctrl-q to resume)).         |
'--------------+------------------------------------------------------------'
| n            | Repeat search in the same direction as previous.           |
'--------------+------------------------------------------------------------'
| N            | Repeat search in the opposite direction as previous.       |
'--------------'------------------------------------------------------------'
| Completion commands:                                                      |
'--------------.------------------------------------------------------------'
| TAB or = or  | List all possible completions.                             |
| CTRL-i       |                                                            |
'--------------+------------------------------------------------------------'
| *            | Insert all possible completions.                           |
'--------------'------------------------------------------------------------'
| Miscellaneous commands:                                                   |
'--------------.------------------------------------------------------------'
| ~            | Invert case of the character under cursor and move a       |
|              | character right.                                           |
'--------------+------------------------------------------------------------'
| #            | Prepend '#' (comment character) to the line and send it to |
|              | the history.                                               |
'--------------+------------------------------------------------------------'
| _            | Inserts the n-th word of the previous command in the       |
|              | current line.                                              |
'--------------+------------------------------------------------------------'
| 0, 1, 2, ... | Sets the numeric argument.                                 |
'--------------+------------------------------------------------------------'
| CTRL-v       | Insert a character literally (quoted insert).              |
'--------------+------------------------------------------------------------'
| CTRL-r       | Transpose (exchange) two characters.                       |
'--------------'------------------------------------------------------------'


 ===========================================================================

.---------------------------------------------------------------------------.
| Peteris Krumins (peter@catonmat.net), 2008.01.08.                         |
| http://www.catonmat.net  -  good coders code, great reuse                 | 
|                                                                           |
| Released under the GNU Free Document License                              |
'---------------------------------------------------------------------------'

	65.3
66.  cscope

	66.1 Man cscope
cscope [ -bCcdehkLlqRTUuV ] [-Fsymfile] [-freffile] [-Iincdir] [-inamefile] [-numpattern] [-pn] [-sdir]  
DESCRIPTION
cscope is an interactive, screen-oriented tool that allows the user to browse through C source files for specified elements of code.

By default, cscope examines the C (.c and .h), lex (.l), and yacc (.y) source files in the current directory. cscope may also be invoked for source files named on the command line. In either case, cscope searches the standard directories for #include files that it does not find in the current directory. cscope uses a symbol cross-reference, cscope.out by default, to locate functions, function calls, macros, variables, and preprocessor symbols in the files.

cscope builds the symbol cross-reference the first time it is used on the source files for the program being browsed. On a subsequent invocation, cscope rebuilds the cross-reference only if a source file has changed or the list of source files is different. When the cross-reference is rebuilt, the data for the unchanged files are copied from the old cross-reference, which makes rebuilding faster than the initial build.  
OPTIONS
The following options can appear in any combination:

-b
    Build the cross-reference only. 
-C
    Ignore letter case when searching. 
-c
    Use only ASCII characters in the cross-reference file, that is, do not compress the data. 
-d
    Do not update the cross-reference. 
-e
    Suppress the <Ctrl>-e command prompt between files. 
-F symfile
    Read symbol reference lines from symfile. (A symbol reference file is created by > and >>, and can also be read using the < command, described under ``Issuing Subsequent Requests,'' below.) 
-f reffile
    Use reffile as the cross-reference file name instead of the default cscope.out. 
-h
    View the long usage help display. 
-I incdir
    Look in incdir (before looking in INCDIR, the standard place for header files, normally /usr/include) for any #include files whose names do not begin with ``/'' and that are not specified on the command line or in namefile below. (The #include files may be specified with either double quotes or angle brackets.) The incdir directory is searched in addition to the current directory (which is searched first) and the standard list (which is searched last). If more than one occurrence of -I appears, the directories are searched in the order they appear on the command line. 
-i namefile
    Browse through all source files whose names are listed in namefile (file names separated by spaces, tabs, or new-lines) instead of the default (cscope.files). If this option is specified, cscope ignores any files appearing on the command line. The argument namefile can be set to ``-'' to accept a list of files from stdio. Filenames in the namefile that contain whitespace have to be enclosed in "double quotes". Inside such quoted filenames, any double-quote and backslash characters have to be escaped by backslashes. 
-k
    ``Kernel Mode'', turns off the use of the default include dir (usually /usr/include) when building the database, since kernel source trees generally do not use it. 
-L
    Do a single search with line-oriented output when used with the -num pattern option. 
-l
    Line-oriented interface (see ``Line-Oriented Interface'' below). 
-num pattern
    Go to input field num (counting from 0) and find pattern. 
-P path
    Prepend path to relative file names in a pre-built cross-reference file so you do not have to change to the directory where the cross-reference file was built. This option is only valid with the -d option. 
-p n
    Display the last n file path components instead of the default (1). Use 0 to not display the file name at all. 
-q
    Enable fast symbol lookup via an inverted index. This option causes cscope to create 2 more files (default names ``cscope.in.out'' and ``cscope.po.out'') in addition to the normal database. This allows a faster symbol search algorithm that provides noticeably faster lookup performance for large projects. 
-R
    Recurse subdirectories for source files. 
-s dir
    Look in dir for additional source files. This option is ignored if source files are given on the command line. 
-T
    Use only the first eight characters to match against C symbols. A regular expression containing special characters other than a period (.) will not match any symbol if its minimum length is greater than eight characters. 
-U
    Check file time stamps. This option will update the time stamp on the database even if no files have changed. 
-u
    Unconditionally build the cross-reference file (assume that all files have changed). 
-V
    Print on the first line of screen the version number of cscope. 

The -I, -c, -k, -p, -q, and -T options can also be in the cscope.files file.

Requesting the initial search

After the cross-reference is ready, cscope will display this menu:

Find this C symbol:

Find this function definition:
Find functions called by this function:
Find functions calling this function:
Find this text string:
Change this text string:
Find this egrep pattern:
Find this file:
Find files #including this file:

Press the <Up> or <Down> keys repeatedly to move to the desired input field, type the text to search for, and then press the <Return> key.

 
Issuing subsequent requests
If the search is successful, any of these single-character commands can be used:

0-9a-zA-Z
    Edit the file referenced by the given line number. 
<Space>
    Display next set of matching lines. 
<Tab>
    Alternate between the menu and the list of matching lines 
<Up>
    Move to the previous menu item (if the cursor is in the menu) or move to the previous matching line (if the cursor is in the matching line list.) 
<Down>
    Move to the next menu item (if the cursor is in the menu) or move to the next matching line (if the cursor is in the matching line list.) 
+
    Display next set of matching lines. 
-
    Display previous set of matching lines. 
^e
    Edit displayed files in order. 
>
    Write the displayed list of lines to a file. 
>>
    Append the displayed list of lines to a file. 
<
    Read lines from a file that is in symbol reference format (created by > or >>), just like the -F option. 
^
    Filter all lines through a shell command and display the resulting lines, replacing the lines that were already there. 
|
    Pipe all lines to a shell command and display them without changing them. 

At any time these single-character commands can also be used:

<Return>
    Move to next input field. 
^n
    Move to next input field. 
^p
    Move to previous input field. 
^y
    Search with the last text typed. 
^b
    Move to previous input field and search pattern. 
^f
    Move to next input field and search pattern. 
^c
    Toggle ignore/use letter case when searching. (When ignoring letter case, search for ``FILE'' will match ``File'' and ``file''.) 
^r
    Rebuild the cross-reference. 
!
    Start an interactive shell (type ^d to return to cscope). 
^l
    Redraw the screen. 
?
    Give help information about cscope commands. 
^d
    Exit cscope. 

NOTE: If the first character of the text to be searched for matches one of the above commands, escape it by typing a (backslash) first.

Substituting new text for old text

After the text to be changed has been typed, cscope will prompt for the new text, and then it will display the lines containing the old text. Select the lines to be changed with these single-character commands:

0-9a-zA-Z
    Mark or unmark the line to be changed. 
*
    Mark or unmark all displayed lines to be changed. 
<Space>
    Display next set of lines. 
+
    Display next set of lines. 
-
    Display previous set of lines. 
a
    Mark or unmark all lines to be changed. 
^d
    Change the marked lines and exit. 
<Esc>
    Exit without changing the marked lines. 
!
    Start an interactive shell (type ^d to return to cscope). 
^l
    Redraw the screen. 
?
    Give help information about cscope commands. 
Special keys

If your terminal has arrow keys that work in vi, you can use them to move around the input fields. The up-arrow key is useful to move to the previous input field instead of using the <Tab> key repeatedly. If you have <CLEAR>, <NEXT>, or <PREV> keys they will act as the ^l, +, and - commands, respectively.

Line-Oriented interface

The -l option lets you use cscope where a screen-oriented interface would not be useful, for example, from another screen-oriented program.

cscope will prompt with >> when it is ready for an input line starting with the field number (counting from 0) immediately followed by the search pattern, for example, ``lmain'' finds the definition of the main function.

If you just want a single search, instead of the -l option use the -L and -num pattern options, and you won't get the >> prompt.

For -l, cscope outputs the number of reference lines cscope: 2 lines

For each reference found, cscope outputs a line consisting of the file name, function name, line number, and line text, separated by spaces, for example, main.c main 161 main(argc, argv)

Note that the editor is not called to display a single reference, unlike the screen-oriented interface.

You can use the c command to toggle ignore/use letter case when searching. (When ignoring letter case, search for ``FILE'' will match ``File'' and ``file''.)

You can use the r command to rebuild the database.

cscope will quit when it detects end-of-file, or when the first character of an input line is ``^d'' or ``q''.

 
ENVIRONMENT VARIABLES

CSCOPE_EDITOR
    Overrides the EDITOR and VIEWER variables. Use this if you wish to use a different editor with cscope than that specified by your EDITOR/VIEWER variables. 
CSCOPE_LINEFLAG
    Format of the line number flag for your editor. By default, cscope invokes your editor via the equivalent of ``editor +N file'', where ``N'' is the line number that the editor should jump to. This format is used by both emacs and vi. If your editor needs something different, specify it in this variable, with ``%s'' as a placeholder for the line number. Ex: if your editor needs to be invoked as ``editor -#103 file'' to go to line 103, set this variable to ``-#%s''. 
CSCOPE_LINEFLAG_AFTER_FILE
    Set this variable to ``yes'' if your editor needs to be invoked with the line number option after the filename to be edited. To continue the example from CSCOPE_LINEFLAG, above: if your editor needs to see ``editor file -#number'', set this environment variable. Users of most standard editors (vi, emacs) do not need to set this variable. 
EDITOR
    Preferred editor, which defaults to vi. 
HOME
    Home directory, which is automatically set at login. 
INCLUDEDIRS
    Colon-separated list of directories to search for #include files. 
SHELL
    Preferred shell, which defaults to sh. 
SOURCEDIRS
    Colon-separated list of directories to search for additional source files. 
TERM
    Terminal type, which must be a screen terminal. 
TERMINFO
    Terminal information directory full path name. If your terminal is not in the standard terminfo directory, see curses and terminfo for how to make your own terminal description. 
TMPDIR
    Temporary file directory, which defaults to /var/tmp. 
VIEWER
    Preferred file display program (such as less), which overrides EDITOR (see above). 
VPATH
    A colon-separated list of directories, each of which has the same directory structure below it. If VPATH is set, cscope searches for source files in the directories specified; if it is not set, cscope searches only in the current directory. 

 
FILES

cscope.files
    Default files containing -I, -p, -q, and -T options and the list of source files (overridden by the -i option). 
cscope.out
    Symbol cross-reference file (overridden by the -f option), which is put in the home directory if it cannot be created in the current directory. 
    cscope.in.out 
cscope.po.out
    Default files containing the inverted index used for quick symbol searching (-q option). If you use the -f option to rename the cross-reference file (so it's not cscope.out), the names for these inverted index files will be created by adding
     .in and .po to the name you supply with -f. For example, if you indicated -f xyz, then these files would be named xyz.in and xyz.po. 
INCDIR
    Standard directory for #include files (usually /usr/include). 

 
Notices
cscope recognizes function definitions of the form:

fname blank ( args ) white arg_decs white {
where:
    fname is the function name 
blank
    is zero or more spaces or tabs, not including newlines 
args
    is any string that does not contain a ``"'' or a newline 
white
    is zero or more spaces, tabs, or newlines 
arg_decs
    are zero or more argument declarations (arg_decs may include comments and white space) 

It is not necessary for a function declaration to start at the beginning of a line. The return type may precede the function name; cscope will still recognize the declaration. Function definitions that deviate from this form will not be recognized by cscope.

The ``Function'' column of the search output for the menu option Find functions called by this function: input field will only display the first function called in the line, that is, for this function


 e()
 {
         return (f() + g());
 }

the display would be


   Functions called by this function: e
   File Function Line
   a.c f 3 return(f() + g());

Occasionally, a function definition or call may not be recognized because of braces inside #if statements. Similarly, the use of a variable may be incorrectly recognized as a definition.

A typedef name preceding a preprocessor statement will be incorrectly recognized as a global definition, for example,


 LDFILE  *
 #if AR16WR

Preprocessor statements can also prevent the recognition of a global definition, for example,


 char flag
 #ifdef ALLOCATE_STORAGE
      = -1
 #endif
 ;

A function declaration inside a function is incorrectly recognized as a function call, for example,


 f()
 {
         void g();
 }

is incorrectly recognized as a call to g.

cscope recognizes C++ classes by looking for the class keyword, but doesn't recognize that a struct is also a class, so it doesn't recognize inline member function definitions in a structure. It also doesn't expect the class keyword in a typedef , so it incorrectly recognizes X as a definition in


 typedef class X  *  Y;

It also doesn't recognize operator function definitions


 Bool Feature::operator==(const Feature & other)
 {
   ...
 }

Nor does it recognize function definitions with a function pointer argument


 ParseTable::Recognize(int startState, char *pattern,
   int finishState, void (*FinalAction)(char *))
 {
   ...
 } 
	66.2 Troubleshoot

		66.2.1 crash w/ core - buffer overflow
- reason - bug in ver 15.5

- Fix - install ver. 15.8
 117  gunzip cscope-15.8a.tar 
  118  tar xvf cscope-15.8a.tar
  119  cd cscope-15.8a
  120  cat README 
  121  cat INSTALL
  122  ./configure 
  123  make
  124  make install


		66.2.2

	66.3 Install cscope on MAC
http://macappstore.org/cscope/
Install cscope on Mac OSX
JUNE 23, 2017
AMBER
About the App

App name: cscope
App description: Tool for browsing source code
App website: http://cscope.sourceforge.net/
Install the App

Press Command+Space and type Terminal and press enter/return key.
Run in Terminal app:
ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" < /dev/null 2> /dev/null
and press enter/return key. Wait for the command to finish.
Run:
brew install cscope
Done! You can now use cscope.


My procedure
 511  ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" < /dev/null 2> /dev/null
  512  brew install cscope

67. VIM as IDE

	67.1  C++

		67.1.1  CLANG

			67.1.1.1 clang complete : Use of Clang for completing C, C++, Objective-C and Objective-C++  
http://www.vim.org/scripts/script.php?script_id=3302

clang is required for many C++ related plugins like youCompleteMe

To install CLANG on MAC:
Apple's development tools are all built on LLVM, and clang is part of Xcode (Apple's development tools). The easiest way to install them is to simply install the Xcode command line tools:

Open a Terminal window.
Type xcode-select --install
A dialog will appear telling you that it requires the command line developer tools, and asks if you would like to install them. Click on the "Install" button.
When the installation is complete, it will have installed LLVM, the standard compilers (including clang), git, svn, and all the usually C/C++/Objective-C/Swift command-line development tools. You can test with:

clang --version

				67.1.1.1.1 This plugin use clang for accurately completing C, C++, Objective-C and Objective-C++ code. 

You don't need any ctags for it to work! Only clang is needed. Clang version 2.8 or higher is recommended for c++ completion. After a . , -> and :: it is automatically trying to complete the code. If you want to "force" the completion, use <C-X><C-U> which is the mapping for user defined completion. Because clang is parsing your source file, it can detect errors inside your code, and highlight them! Plus it can open the quickfix window automatically. 

Since version 1.4, snippets can be used to complete function arguments. It is triggered after a completion, and you can go to the next argument with the <Tab> key in normal mode. 

If you've got special flags for a project (especially -I and -D ones), clang may be unable to complete your code. To overcome this limitation put the flags inside the file .clang_complete at the root of your project. 

Latest version will always be on github: http://github.com/Rip-Rip/clang_complete 

Do not hesitate to report bugs or ask for features. 

For more information about the configuration, look at the help (:h clang_complete)
 
install details
If you have installed vimscript #1520, please remove it, as it is confliting with this one. 
To install: vim clang_complete.vmb -c 'so %' -c 'q'

				67.1.1.1.2 Completion kinds    				*clang_complete-compl_kinds*

Because libclang provides a lot of information about completion, there are
some additional kinds of completion along with standard ones (see
|complete-items| for details):
 '+' - constructor
 '~' - destructor
 'e' - enumerator constant
 'a' - parameter ('a' from "argument") of a function, method or template
 'u' - unknown or buildin type (int, float, ...)
 'n' - namespace or its alias
 'p' - template ('p' from "pattern")

		67.1.2 eclim

		67.1.3
	67.2 Java

	67.3 Python 


		67.3.1 http://sontek.net/blog/detail/turning-vim-into-a-modern-python-ide
Turning Vim into a modern Python IDE

Posted by sontek on 2011-05-07 04:37:55

Contents

Intro
Basic Editing and Debugging
Code Folding
Window Splits
Snippets
Task lists
Revision History
Syntax Highlighting and Validation
Pep8
Tab Completion and Documentation
Code Navigation
Buffers
Fuzzy Text File Search
File Browser
Refactoring and Go to definition
Searching
Integration with Git
Test Integration
django nose
py.test
Virtualenv
Django
Random Tips
TL;DR:

$ git clone https://github.com/sontek/dotfiles.git
$ cd dotfiles
$ ./install.sh vim
Download PDF Version

Intro

Back in 2008, I wrote the article Python with a modular IDE (Vim). Years later, I have people e-mailing me and commenting daily asking for more information, even though most of the information in it is outdated. Here is the modern way to work with Python and Vim to achieve the perfect environment.

Because one of the most important parts about a development environment is the ability to easily reproduce across machines, we are going to store our vim configuration in git:

$ mkdir ~/.vim/
$ mkdir ~/.vim/{autoload,bundle}
$ cd ~/.vim/
$ git init
The purpose of the autoload directory is to automatically load the vim plugin Pathogen, which we'll then use to load all other plugins that are located in the bundle directory. So download pathogen and put it in your autoload folder.

You'll need to add the following to your ~/.vimrc so that pathogen will be loaded properly. Filetype detection must be off when you run the commands so its best to execute them first:

filetype off
call pathogen#runtime_append_all_bundles()
call pathogen#helptags()
Now lets add all of the vim plugins we plan on using as submodules to our git repository:

git submodule add http://github.com/tpope/vim-fugitive.git bundle/fugitive
git submodule add https://github.com/msanders/snipmate.vim.git bundle/snipmate
git submodule add https://github.com/tpope/vim-surround.git bundle/surround
git submodule add https://github.com/tpope/vim-git.git bundle/git
git submodule add https://github.com/ervandew/supertab.git bundle/supertab
git submodule add https://github.com/sontek/minibufexpl.vim.git bundle/minibufexpl
git submodule add https://github.com/wincent/Command-T.git bundle/command-t
git submodule add https://github.com/mitechie/pyflakes-pathogen.git
git submodule add https://github.com/mileszs/ack.vim.git bundle/ack
git submodule add https://github.com/sjl/gundo.vim.git bundle/gundo
git submodule add https://github.com/fs111/pydoc.vim.git bundle/pydoc
git submodule add https://github.com/vim-scripts/pep8.git bundle/pep8
git submodule add https://github.com/alfredodeza/pytest.vim.git bundle/py.test
git submodule add https://github.com/reinh/vim-makegreen bundle/makegreen
git submodule add https://github.com/vim-scripts/TaskList.vim.git bundle/tasklist
git submodule add https://github.com/vim-scripts/The-NERD-tree.git bundle/nerdtree
git submodule add https://github.com/sontek/rope-vim.git bundle/ropevim
git submodule init
git submodule update
git submodule foreach git submodule init
git submodule foreach git submodule update
Thats it! Now that we've got our vim configuration in git!

Now lets look at how to use each of these plugins to improve the power of vim:

Basic Editing and Debugging

Code Folding

Lets first enable code folding. This makes it a lot easier to organize your code and hide portions that you aren't interested in working on. This is quite easy for Python, since whitespace is required.

In your ~/.vimrc just add:

set foldmethod=indent
set foldlevel=99
Then you will be able to be inside a method and type 'za' to open and close a fold.

Window Splits

Sometimes code folding isn't enough; you may need to start opening up multiple windows and working on multiple files at once or different locations within the same file. To do this in vim, you can use these shortcuts:

Vertical Split : Ctrl+w + v
Horizontal Split: Ctrl+w + s
Close current windows: Ctrl+w + q
I also like to bind Ctrl+<movement> keys to move around the windows, instead of using Ctrl+w + <movement>:

map <c-j> <c-w>j
map <c-k> <c-w>k
map <c-l> <c-w>l
map <c-h> <c-w>h
 http://i.imgur.com/krj0l.png
Snippets

The next tweak that really speeds up development is using snipmate. We've already included it in our bundle/ folder so its already enabled. Try opening up a python file and typing 'def<tab>'. It should stub out a method definition for you and allow you to tab through and fill out the arguments, doc string, etc.

I also like to create my own snippets folder to put in some custom snippets:

$ mkdir ~/.vim/snippets
$ vim ~/.vim/snippets/python.snippets
Put this in the file:

snippet pdb
    import pdb; pdb.set_trace()
Now you can type pdb<tab> and it'll insert your breakpoint!

Task lists

Another really useful thing is to mark some of your code as TODO or FIXME! I know we all like to think we write perfect code, but sometimes you just have to settle and leave a note for yourself to come back later. One of the plugins we included was the tasklist plugin that will allow us to search all open buffers for things to fix. Just add a mapping to open it in ~/.vimrc:

map <leader>td <Plug>TaskList
Now you can hit <leader>td to open your task list and hit 'q' to close it. You can also hit enter on the task to jump to the buffer and line that it is placed on.

Revision History

The final basic editing tweak I suggest everyone start utilizing is the Gundo plugin. It'll allow you to view diff's of every save on a file you've made and allow you to quickly revert back and forth:

http://i.imgur.com/2NrPS.png
Just bind a key in your .vimrc to toggle the Gundo window:

map <leader>g :GundoToggle<CR>
Syntax Highlighting and Validation

Simply enable syntax highlighting in your ~/.vimrc:

syntax on                           " syntax highlighing
filetype on                          " try to detect filetypes
filetype plugin indent on    " enable loading indent file for filetype
Because we enabled pyflakes when we added it as a submodule in ~/.vim/bundle, it will notify you about unused imports and invalid syntax. It will save you a lot of time saving and running just to find out you missed a colon. I like to tell it not use the quickfix window:

let g:pyflakes_use_quickfix = 0
 http://i.imgur.com/ZfjFe.png
Pep8

The final plugin that really helps validate your code is the pep8 plugin, it'll make sure your code is consistent across all projects. Add a key mapping to your ~/.vimrc and then you'll be able to jump to each of the pep8 violations in the quickfix window:

let g:pep8_map='<leader>8'
 http://i.imgur.com/VU9AB.png
Tab Completion and Documentation

Vim has many different code completion options. We are going to use the SuperTab plugin to check the context of the code you are working on and choose the best for the situation. We've already enabled the SuperTab plugin in the bundle/ folder, so we just have to configure it to be context sensitive and to enable omni code completion in your ~/.vimrc:

au FileType python set omnifunc=pythoncomplete#Complete
let g:SuperTabDefaultCompletionType = "context"
Now we just enable the menu and pydoc preview to get the most useful information out of the code completion:

set completeopt=menuone,longest,preview
 http://i.imgur.com/g4lxP.png
We also enabled the pydoc plugin at the beginning with all the submodules; that gives us the ability to hit <leader>pw when our cursor is on a module and have a new window open with the whole documentation page for it.

Code Navigation

Buffers

The most important part about navigating code within vim, is to completely understand how to use buffers. There is no reason to use tabs. Open files with :e <filename> to place in a buffer. We already installed the minibufexpl plugin, so you will already visually see every buffer opened. You can also get a list of them doing :buffers.

You can switch between the buffers using b<number>, such as :b1 for the first buffer. You can also use its name to match, so you can type :b mod<tab> to autocomplete opening the models.py buffer. You need to make sure you are using the minibufexpl from my github since it has patches that make it much better to work with.

To close a buffer you use :bd or :bw.

Fuzzy Text File Search

To make finding and opening files within your project even easier, we are going to use the command-t plugin. It does have some parts that need to be compiled, so its not already installed by adding it as a submodule. Go to your ~/.vim/bundle/command-t folder and run 'rake make'. Yes you need ruby installed. By default, command-t is bound to <leader>t. This will use fuzzy text matching to find any file in your project.

It also supports searching only through opened buffers, instead of files using <leader>b.

http://i.imgur.com/hUcSl.png
File Browser

NERD Tree is a project file browser. I must admit I used this heavily back when I was migrating from Visual Studio and used to the Solution Explorer, but I rarely use it anymore. Command-T is usually all you'll need. It is useful when you are getting to know a new codebase for the first time though. Lets bind a shortcut key for opening it:

map <leader>n :NERDTreeToggle<CR>
 http://i.imgur.com/R4ZzQ.png
Refactoring and Go to definition

Ropevim is also a great tool that will allow you to navigate around your code. It supports automatically inserting import statements, goto definition, refactoring, and code completion. You'll really want to read up on everything it does, but the two big things I use it for is to jump to function or class definitions quickly and to rename things (including all their references).

For instance, if you are using django and you place your cursor over the class models.Model you reference and then called :RopeGotoDefintion, it would jump you straight to the django library to that class definition. We already have it installed in our bundles, so we bind it to a key to use it:

map <leader>j :RopeGotoDefinition<CR>
map <leader>r :RopeRename<CR>
Searching

The final tool that really speeds up navigating your code is the Ack plugin. Ack is similar to grep, but much better in my opinion. You can fuzzy text search for anything in your code (variable name, class, method, etc) and it'll give you a list of files and line numbers where they are defined so you can quickly cycle through them. Just bind the searching to a key:

nmap <leader>a <Esc>:Ack!
We use ! at the end of it so it doesn't open the first result automatically.

Integration with Git

We installed 2 plugins, git.vim and fugitive, that give us all the integration we need. Git.vim will provide us syntax highlighting for git configuration files; fugitive provides a great interface for interacting with git including getting diffs, status updates, committing, and moving files.

Fugitive also allows you to view what branch you are working in directly from vim. Add this to your statusline in ~/.vimrc:

%{fugitive#statusline()}
The big commands you need to know:

Gblame: This allows you to view a line by line comparison of who the last person to touch that line of code is.
Gwrite: This will stage your file for commit, basically doing git add <filename>
Gread: This will basically run a git checkout <filename>
Gcommit: This will just run git commit. Since its in a vim buffer, you can use keyword completion (Ctrl-N), like test_all<Ctrl-N> to find the method name in your buffer and complete it for the commit message. You can also use + and - on the filenames in the message to stage/unstage them for the commit.
http://i.imgur.com/NuRRj.png
Test Integration

django nose

Test runner integration really depends on the testing library you are using and what type of tests you are running but we included a great generic plugin called MakeGreen that executes off of vim's makeprg variable. So for instance, if you are using django with django-nose you could define a shortcut key in your ~/.vimrc like this:

map <leader>dt :set makeprg=python\ manage.py\ test\|:call MakeGreen()<CR>
This will just give you a green bar at the bottom of vim if your test passed or a red bar with the message of the failed test if it doesn't. Very simple.

py.test

I also included the py.test vim plugin for those who prefer it. This plugin has a lot more functionality including executing individual tests by class, file, or method. You can also cycle through the individual assertion errors. I have the following bindings:

" Execute the tests
nmap <silent><Leader>tf <Esc>:Pytest file<CR>
nmap <silent><Leader>tc <Esc>:Pytest class<CR>
nmap <silent><Leader>tm <Esc>:Pytest method<CR>
" cycle through test errors
nmap <silent><Leader>tn <Esc>:Pytest next<CR>
nmap <silent><Leader>tp <Esc>:Pytest previous<CR>
nmap <silent><Leader>te <Esc>:Pytest error<CR>
 http://i.imgur.com/RAE7v.png
Virtualenv

Vim doesn't realize that you are in a virtualenv so it wont give you code completion for libraries only installed there. Add the following script to your ~/.vimrc to fix it:

" Add the virtualenv's site-packages to vim path
py << EOF
import os.path
import sys
import vim
if 'VIRTUAL_ENV' in os.environ:
    project_base_dir = os.environ['VIRTUAL_ENV']
    sys.path.insert(0, project_base_dir)
    activate_this = os.path.join(project_base_dir, 'bin/activate_this.py')
    execfile(activate_this, dict(__file__=activate_this))
EOF
Django

The only true django tweak I make is before I open vim I'll export the DJANGO_SETTINGS_MODULE environment so that I get code completion for django modules as well:

export DJANGO_SETTINGS_MODULE=project.settings
Random Tips

If you want to find a new color scheme just go to http://code.google.com/p/vimcolorschemetest/ to preview a large selection.

© John Anderson <sontek@gmail.com> 2011

		67.3.2
	67.4
68. receips, cookbook

	68.1 g, global operator


		68.1.1 Join lines between patterns


I have a text file which looks like this:

A.
text
text
text


A.
more text

more text

A.
more text
I want to join all lines between the "markers" A. so that it looks like:

A.texttexttext
A.more textmore text
A.more text
How can I do this in Vim?

Two ways:
-> 
:%s/\n\(\(A\.$\)\@!.*\)/\1/
Substitute a pattern matching:

newline,
a group containing of

not the string A. directly followed by end-of-line, then
any character until end of line
with:

everything matched except the starting newline (i.e. the group above),
and do this globally.

	-> This also works (when the first line starts with A.)
:v/^A/-1j!

		68.1.2
	68.2
69. Platform specific 

	69.1  MAC

		69.1.1  Transperancy

if has("gui_macvim")
    set transparency=15
    "set guifont=Monaco:h10
    set guifont=Lucida\ Sans\ Typewriter:h11
    set noantialias
endif
These settings are specific to MacVIM. They set the font to size 10 Monaco, non anti aliased, and sets the window to have 85% opacity.
		69.1.2

	69.2

70. Integration with source control systems

	
	70.1 ClearCase

	/Users/yizaq/.vimrc
" My ACS 5, linux develoment environment clearcase menu
amenu M&yCCMenu.checkout       :! co % <cr>
amenu M&yCCMenu.checkin       :! ci % <cr>
amenu M&yCCMenu.-SEP-      :   
amenu M&yCCMenu.version_tree       :! ct lsvtree -g % <cr>
amenu M&yCCMenu.diff_pred       :! ct diff -pred -graph % <cr>
amenu M&yCCMenu.diff_pred_txt       :! ct diff -pred -diff % <cr>
amenu M&yCCMenu.-SEP1-      :   
amenu M&yCCMenu.checkin_all       :call CheckIn_all__buffers()<cr>
amenu M&yCCMenu.manually_set_tags_for_auto_complete       :set tags+=~/.vim/tags/acs_5/tags<cr>:set tags+=~/.vim/tags/cpp/tags<cr>

	70.2 Perforce
:!p4 login
	- checkout:
:!p4 edit -c <change #> %

	- Add file
:!p4 add -c <change #> %

	- submit 
:!p4 submit -c <change #>

	- update workspace
:!p4 synch

	- opened files
:!p4 opened

	- diff file agains depot version
:!p4 diff % 

	70.3
71. Troubelshooting

    71.1  crashes

        71.1.1  got deadly signal sigabrt

        on vim 7.2 its a know bug. Triggered by airline plugin
fix: move airline bundle to unused
other fix install vim 8

        71.1.2


    71.2


72. match white spaces

    72.1 https://vim.fandom.com/wiki/Highlight_unwanted_spaces


    72.2
73. JSON

    73.1 pretty format JSON
whole file:
:%!python -m json.tool
:%!jq .

one line
:.!python -m json.tool
:.!jq .

    73.2

74. Neo vim, NVIM, neovim

    74.1 Getting started

GUI:
https://github.com/equalsraf/neovim-qt

    74.2 Common issues

        74.2.1 cm_start.py nvim error invalid syntax
https://github.com/luan/vimfiles/issues/124

What happened
I open vim and I see:

"~/workspace/bam-workstation/.git/COMMIT_EDITMSG" 66L, 1847C
Error detected while processing function <SNR>266_on_core_channel_error:
line    1:
Traceback (most recent call last):^@  File "/Users/pivotal/.vim/plugged/nvim-completion-manager/pythonx/cm_start.py", line 10
, in <module>^@    from cm import getLogger, start_and_run_channel^@  File "/Users/pivotal/workspace/vimfiles/plugged/nvim-completion-manager/pythonx/cm.py", line 151^@    self.nvim.call('cm#complete', name, ctx, startcol, matches, refresh, async=True)^@                                                                             ^^@SyntaxError: invalid syntax
Error detected while processing function <SNR>266_on_core_channel_error:
line    1:
nvim-completion-manager core channel terminated.
Why
You upgraded Python 3.7. Since Python 3.7, async is a keyword. This means that nvim-completion-manager now has syntax errors.

Resolution
?


Workaround
I've worked around this for the time being by fixing the syntax errors:

sed -i.bu 's/async=True/**{"async": True}/' ~/.vim/plugged/nvim-completion-manager/pythonx/cm.py
sed -i.bu 's/async=True/**{"async": True}/' ~/.vim/plugged/nvim-completion-manager/pythonx/cm_core.py
You could also drop your python version to 3.6

[i500695@C02X632CJGH6:2020-06-23 11:12:52:~/work/code/ML/UdemyNodeJS_ML/MLKits/knn-tf:]2026$ sed -i.bu 's/async=True/**{"async": True}/' ~/.vim/plugged/nvim-completion-manager/pythonx/cm.py
[i500695@C02X632CJGH6:2020-06-23 11:12:55:~/work/code/ML/UdemyNodeJS_ML/MLKits/knn-tf:]2027$ sed -i.bu 's/async=True/**{"async": True}/' ~/.vim/plugged/nvim-completion-manager/pythonx/cm_core.py


        74.2.2 error caught in async handler deoplete_auto_completion_begin
RC: python-client not latest version
Fix: pip3 --no-cache-dir install -U git+https://github.com/neovim/python-client.git
update client

        74.2.3 ImportError: No module named neovim


            74.2.3.1 my fix
RC: Turns out I have two python3

This misses neovim
$ /usr/bin/python3 -c 'import neovim'
Traceback (most recent call last):
  File "<string>", line 1, in <module>
ModuleNotFoundError: No module named 'neovim'

This is ok.
$ /usr/local/bin/python3 -c 'import neovim'


Fix:
/Users/i500695/.config/nvim/init.vim
set
let g:python3_host_prog = '/usr/local/bin/python3'



            74.2.3.2 reddit 
https://www.reddit.com/r/neovim/comments/an1kjt/importerror_no_module_named_neovim/

problem:
function provider#python#Call[9]..remote#host#Require[10]..provider#pythonx#Require, line 15
Vim(if):ch 1 was closed by the client
Traceback (most recent call last):
  File "<string>", line 1, in <module>
ImportError: No module named neovim
Failed to load python host. You can try to see what happened by starting nvim with $NVIM_PYTHON_LOG_FILE set and opening the generated log file. Also, the host stderr is available in messages.
Press ENTER or type command to continue

A1.
ind your vim startup file:



Neovim has it at $HOME/.config/nvim/init.vim

Vim has it at $HOME/.vimrc



And add this:

let g:python3_host_prog = '/usr/bin/python3' (change path to your python)

A2. pip3 uninstall neovim pynvim
pip3 install pynvim

A3.  :checkhealth. This command showed potential problems

let g:python_host_prog = '/usr/bin/python2'
let g:python3_host_prog = '/usr/bin/python3'

            74.2.3.3 copy to clipboard

"+y

This is what I personally use

" " Copy to clipboard
vnoremap  <leader>y  "+y
nnoremap  <leader>Y  "+yg_
nnoremap  <leader>y  "+y
nnoremap  <leader>yy  "+yy

" " Paste from clipboard
nnoremap <leader>p "+p
nnoremap <leader>P "+P
vnoremap <leader>p "+p
vnoremap <leader>P "+P
Map your leader key to something comfortable and convenient


            74.2.3.4

        74.2.4

    74.3 enhanced features vs vim

        74.3.1 live substitution
https://blog.kdheepak.com/three-built-in-neovim-features.html

By default, vim’s :substitute command only modifies the document when you execute the command by pressing Enter (<CR>). In neovim, you can update the document interactively. neovim also shows you a preview window of all the changes you are going to make in the document.


Just add the following option to your vimrc file.

set inccommand=nosplit

        74.3.2 # Highlight Yanked Text
With the latest version of neovim, you have the ability to highlight yanked text without using any plugins
If you want to use this feature in neovim v0.4.x or in vim 8, you can do so with this plugin: https://github.com/machakann/vim-highlightedyank..


At the time of writing, you’ll need a v0.5.0 or nightly release of neovim for this feature.

$ nvim --version | head -1
NVIM v0.5.0-556-ge78658348
You can add the following in your vimrc to enable this feature:

augroup LuaHighlight
  autocmd!
  autocmd TextYankPost * silent! lua require'vim.highlight'.on_yank()
augroup END


        74.3.3 # Language Server Protocol
neovim has a built-in implementation of the Language Server Protocol client and default configurations for over 50 languages.

Completion, diagnostics and jump to references in lua.
At the time of writing, you’ll need a v0.5.0 or nightly release of neovim for this feature.

$ nvim --version | head -1
NVIM v0.5.0-556-ge78658348
In order to set this up you need to do 3 things:

Add the neovim/nvim-lsp plugin:

Plug 'neovim/nvim-lsp'
Run :LspInstall {servername}:

:LspInstall sumneko_lua
:LspInstall julials
:LspInstall nimls
:LspInstall rust_analyzer
:LspInstall vimls
:LspInstall pyls
Set up configurations with options in your vimrc:

lua <<EOF
    local nvim_lsp = require'nvim_lsp'
    nvim_lsp.sumneko_lua.setup()
    nvim_lsp.julials.setup()
    nvim_lsp.nimls.setup()
    nvim_lsp.vimls.setup()
    nvim_lsp.pyls.setup{
        settings = {
            pyls = {
                configurationSources = {
                    pycodestyle,
                    flake8
                }
            }
        }
    }
EOF

        74.3.4
    74.4 plugins

        74.4.1 update plugins
I use Plug plugin manager so
:PlugUpdate       " Update all plugins
:PlugUpgrade      " Upgrade Plug itself

        74.4.2

    74.5
75. vim versions 

    75.1  
    75.2 
    75.3 
    75.4 
    75.5 
    75.6 
    75.7 
    75.8 
    75.9 vim version 9 

        75.9.1  install
brew install vim 

        75.9.2 features

        75.9.3
    75.10

76.  Vim presentations 

    76.1 presentation to team
    20/10/22 17:27:26  

        76.1.1 redit discussion as preparation 
https://www.reddit.com/r/vim/comments/y854zj/best_selling_features_of_vim_for_programmers/

            76.1.1.1 Buffers! ... and modes!!

I think one problem with listing features is just that, listing features. It just becomes another program you compare lists of features. This does not really show how Vim works and the appeal of it. I like the way to think in Vim with the modes and commands and how the compose them together.

In example fg to jump to "g" character on the line, and then cvfg (Edit: I am little embarrassed. I meant vfgc.) to enter into visual selection mode for changing the selection, that is from current position to "g" character. And this whole logic of commands and composition throughout the entire program and feature sets is one of the primary reason why I love using Vim so much. Plus off course that I can do a lot of stuff with keyboard only (still using mouse too!).

So just listing features does not Vim justice. It is the way how you can combine these features that makes it really powerful. In example you can combine repetition of operations with macros and marks, buffers and Vim windows.
--
It is not just to see the change, but I can adjust it further. In example with ; to jump to next occurence of "," (or "g").

            76.1.1.2 I really like the IntelliJ vim extension.
                If you can demo in there, and show a .ideavimrc config that binds editor functions to keymaps, then you will be showing an approachable entry into vim experience. Not every feature of vim is supported, but a lot are, including macros, marks, find/replace.

Personally, I've never liked the vscode vim extension though (It seems to stay in insert mode when I would otherwise expect it to switch back to normal mode, which I found hard to deal with)

            76.1.1.3 I wouldn't try to show that vim can do anything their IDEs can. If that was the only competition, they'll most likely stay with their IDE. I'd show various editing in normal mode, and the power of text objects. Maybe an example of some advanced editing of lots of similar, but not identical lines, using a macro (I find recording the macro is a fun sort of meta programming, and then the rewars when repeating it with N@q).

            76.1.1.4 Pretty much this. I also find that a lot of times it's the smaller things / script editing that really showcases how much power Vim has. Some examples:

It could be something as simple as needing to do a quick and dirty refactor/edit on some code and my macro did it in literally no time. Because it's a relatively complex refactor, it would be hard to use builtin IDE features, and too cumbersome to write scripts to do it for you. I could also easily edit the Vim macro (it's just in the register) if I found a bug and just redo it.

There was one time a coworker had a super time-sensitive investigation to figure out why a config file wasn't working, and I helped him figure it out just by opening it in my Vim and doing :set list and found all the places where spaces were somehow mistyped as non-breaking whitespace (nbsp) in some copy-pasting error.

My last job often required SSH-ing into a remote device and following logs by doing something like ssh <some_machine>; tail -F /var/logs. It's just kind of a PITA, but with Vim terminal you can do that in Vim terminal to get live updates of the logs, and when need be, you can quickly filter out lines using something like :v/my_feature:/d or do quick navigation in the log file, whereas others would still be trying to download the log file, open in a text editor, etc. (This also answers the frequent "why does Vim have a terminal" question btw)

There are times where say I want to process 40 files with some shell commands and string them together. You could write a Bash script to do it but it takes forever to debug, or you could write a proper Python one which takes even longer, or you could just painstakingly type out all 40 lines of Bash commands with some bugs in them. Meanwhile, with Vim I can easily string together those 40 lines using all sorts of tools (macros, :put =range(1,40) to generate 40 lines of numbers, visual block, search-and-replace, etc) and just paste them into the shell.

Those examples all have alternative means to accomplish but I always find that they would have taken much longer, and are hard to do with existing tooling since these situations come up regularly but are always kind of ad-hoc. It's harder to convince someone just on raw IDE functionality because honestly that's a high bar if the IDE has code completion, proper semantics-based code highlighting, etc and you need to get a souped up Vim with LSP support just to have some feature parity. It's easier to convince someone why Vim is powerful first, and then see if they want to do the work to make it work for their workflow for coding etc and learn the editor. And honestly, even though I love using Vim, I see no problem of using IDE for regular coding if they work better in the environment.

Those situations do require you to have a good baseline Vim knowledge though, as they just kind of come up. If you have to spend 30 minutes to research how to do it in front of your coworkers just to save 10 minutes of time that's not so impressive.

For a prepared demo, perhaps try jotting down personal notes to see what actually came up that you felt was impressive (or when other people just went "how did you do that?" when seeing you code), so you can have a list of real examples that you encountered during editing your code base.

            76.1.1.5
        76.1.2


            76.1.2.1
            76.1.2.1 neat tips and tricks 

                76.1.2.1.1 reverse file
	:g/^/m 0

                76.1.2.1.2 sort file
Sort entire file	!G sort
or			:%!sort

                76.1.2.1.3 generate lines with incrementing numbers
:put = range(1,100) 

        76.1.3 presentation structure 

            76.1.3.1 vim history
ed -> ex -> vi (1978 - bundled w/ unix distros) -> vim (1991) 

why the name vi?
in ex editor, going to full screen mode you type visual :) 

            76.1.3.2 vim philosophy 
vim has 12 different editing modes, 6 of which are variants of the 6 basic modes.[35] The most important modes are:
Normal mode – used for editor commands. This is also the default mode, unless the insertmode option is specified.
Visual mode – similar to normal mode, but used to highlight areas of text. Normal commands can be run on the highlighted area, for instance to move or edit a selection.
Insert mode – similar to editing in most modern editors. In this mode, buffers can be modified with the text inserted.
Command-line or Cmdline mode – supports a single line input at the bottom of the Vim window. Normal commands (beginning with :), and some other keys for specific actions (including pattern search and the filter command) activate this mode. On completion of the command, Vim returns to the previous mode.
                    

            76.1.3.3 vim history reference 1 - https://gist.github.com/lettertwo/813e765a9f68127b0807d1d6619c5ab0
Philosophy of Vim
most of programming time is spent editing, not writing.
editing is a process of manipulating text in ways beyond just writing, such as deletion, replacement, reordering, duplication, formatting, etc.
since writing (input) is a relatively small part of the whole of programming, making the other tasks easier by default can be a productivity win.
os shortcuts for editing can't get 'shadowed' by custom actions, since they take the form of commands in 'normal' (command) mode
A Modal Editor
Command Mode
You will almost always be in this mode, so much so that it is useful to think of this mode as the 'normal' mode. In fact, Vim calls it Normal Mode. In general, the other modes can be thought of transitional or temporary–you are always in the process of returning to Command Mode.

Return to Command Mode by pressing esc (or ctrl+c).

A Repertoire of Movements
Command Mode is centered on the concept of 'movements'

Basic movements:
left: h
down: j
up: k
right: l
WTF hjkl???

There are apparently historical reasons for this–early terminals often lacked arrow keys. However, a side affect of this is that the most common movement comes without having to even leave the 'home row'

Word boundary movements:
next word: w
end of word: e
beginning of word: b
Grouping movements:
beginning of line: ^
end of line: $
next paragraph: }
previous paragraph: {
matching bracket: %
targeted movements:
move to next occurrence of the current word: *
move to previous occurrence of the current word: #
move (un)til character: t<char>
move back (un)til character: T<char>
move to found character: f<char>
move back to found character: F<char>
move to match: /<regex>
move back to match: ?<regex>
move to next occurrence of a match: n
move to previous occurrence of a match: N
Insert Mode
This mode works the way text editing works throughout the OS. Same shortcuts (cmd+c, cmd+p, etc), same movements (arrow keys, page up/down, ctrl+a, ctrl+e, etc).

There are many movement commands that can result in switching to Insert Mode:

insert: i
insert after: a
insert at the start of the line: I
insert at the end of the line: A
insert on new line: o
insert on new line above: O
substitute: s
change: c
Visual Mode
A mode for creating selections. It's a modified version of Command mode, where commands either result in modifications to a selection range, or perform an editing task on the selection.

To enter Visual Mode (starting from Command Mode):

v to select by character
V to select by line
While in visual mode, most movement commands can be used to expand or contract the selection. Commands that make edits do so on the current selection, and automatically switch to either Command Mode or Insert Mode, depending on the command. For example, pressing i

A Language of Text Editing
Command Mode presents a sort of "language" that allows describing text editing tasks with combinations of commands. Many commands can be conveniently thought of as the "verbs", "nouns" and "prepositions" that make up the "language".

Examples of "verbs":
change (c)
replace (r)
substitute (s)
delete (d)
yank (y)
put (p)
WTF 'change', 'replace', AND 'substitute'? aren't these all the same thing?

Nope!

Change deletes everything in the next movement and puts you in Insert Mode (though with a selection, it behaves like substitute).
Substitute immediately deletes the current character (or selection) and puts you in Insert Mode.
Replace never enters Insert Mode at all, but just replaces the current character (or every character in a selection) with the provided character.
Examples of "nouns":
word (w)
end (e)
beginning (b)
"Nouns" can be any of the available movements!

Examples of "prepositions":
inside (i)
around (a)
(un)til (t)
WTF i thought i and a were insert commands!

Many Vim commands expect to be appended with a movement. When waiting for that movement, the command is 'pending', during which time "prepositional" commands become available. So, when a command like d (delete) is entered, nothing will happen because the command is 'pending' a movement. Pressing i next won't enter Insert Mode, as you might expect when starting out. In fact, it will leave the command 'pending', because i in this context is the 'inside' command, which requires a subject (such as w) to complete the movement!

You can combine these parts of the "language" to perform editing tasks:

delete to the end of a word: dw (or de)
delete the current word: diw
yank to the end of word: ye
change inside parentheses: ci) (or ci()
delete around brackets: da] (or da[)
There are many other ways to combine commands. For example:

delete 3 words: d3w (or 3dw)
change a visual selection: v<movement>c
yank the next 5 characters: y5l (or 5yl)
auto-indent inside a block: =i} (or =i{)
delete back through the word 'foo': d?foo
duplicate this line plus the 3 lines above:y3kp
replace the entire document with a bunch of Qs: ggvGrQ
Tips & Tricks
repeat the last command with .
undo with u
redo with ctrl+r
jump to top of the document with gg
jump to the bottom with G
jump to a line number with <number>G
Some commands can be performed on the current line by repeating them:
delete the current line: dd
change the current line: cc
yank the current line: yy
remap CAPSLOCK to ESC
open the key binding resolver in Atom (cmd+.) to learn what various keys do.


            76.1.3.4 https://dev.to/gypsydave5/the-unix-way-or-why-you-actually-want-to-use-vim-3n8p 

unix philosophy: Write programs that do one thing and do it well.

power of pipes:
$ls | sort -r 
cat | pbopy 
[i500695@WYLQRXL9LQ:2022-11-21 14:55:34:~/git/portal-cf-transport-service:]2035$ cat test/unit/cdm/resources/page_section_text_mismatch.json | jq '.payload'

vim supports pipes as well 
:%! sort -u 
:%! jq '.'
            76.1.3.5

77. 

78. chatgpt

    78.1  query: Error detected while processing BufReadPost Autocommands for "*.py"..FileType Autocommands for "*":
Error executing lua callback: ...lugged/nvim-treesitter/lua/nvim-treesitter/highlight.lua:14: attempt to index local 'hlmap' (a nil value)
stack traceback:

A:
This error message suggests that there is a problem with the nvim-treesitter plugin in your Neovim configuration. Specifically, there seems to be an issue with the highlight.lua file in the nvim-treesitter plugin directory.

To troubleshoot this issue, here are a few steps you can take:

Check that you have installed the nvim-treesitter plugin correctly. You can verify this by running the :PlugStatus command in Neovim, which will show you a list of all the plugins you have installed and their status.

Make sure that you have the latest version of the nvim-treesitter plugin installed. You can update your plugins by running the :PlugUpdate command in Neovim.

If you have recently updated the nvim-treesitter plugin, try running the :TSUpdate command in Neovim to update the syntax parsers and other files used by the plugin.

Check that the highlight.lua file in the nvim-treesitter plugin directory is not corrupted or missing. You can try reinstalling the plugin to see if this resolves the issue.

If none of these steps resolve the issue, you may need to seek further help from the Neovim or nvim-treesitter communities.
    78.2 query: neovim fix cmp_nvim_lsp.update_capabilities is deprecated, use cmp_nvim_lsp.default_capabilities instead. See :h deprecated
This function will be removed in cmp-nvim-lsp version 1.0.0
stack traceback:
        ...nfig/nvim/plugged/cmp-nvim-lsp/lua/cmp_nvim_lsp/init.lua:89: in function 'update_capabilities'
        [string ":lua"]:45: in main chunk

A: This error message indicates that the cmp_nvim_lsp.update_capabilities function is deprecated and will be removed in version 1.0.0 of the cmp-nvim-lsp plugin. The error message also suggests that you should use the cmp_nvim_lsp.default_capabilities function instead.

To fix this error, you need to update your Neovim configuration to use the cmp_nvim_lsp.default_capabilities function instead of cmp_nvim_lsp.update_capabilities. Here's an example of how to do this:

-- Replace this line
-- require('cmp_nvim_lsp').update_capabilities(vim.lsp.protocol.make_client_capabilities())

-- With this line
require('cmp_nvim_lsp').setup({
  capabilities = require('cmp_nvim_lsp').default_capabilities()
})
The cmp_nvim_lsp.setup() function takes a table of options, including the capabilities option. You can set the capabilities option to cmp_nvim_lsp.default_capabilities() to use the default capabilities provided by the plugin.

By making this change to your configuration, you should no longer see the deprecation warning for cmp_nvim_lsp.update_capabilities.


    78.3 Query: neovim fix [LSP] Accessing client.resolved_capabilities is deprecated, update your plugins or configuration to access client.server_capabilities instead.The new key/value
 pairs in server_capabilities directly match those defined in the language server protocol 

A: 
This error message indicates that the Neovim plugin you are using is accessing the client.resolved_capabilities attribute, which has been deprecated. Instead, it is recommended to update your plugins or configuration to access the client.server_capabilities attribute, which contains the same information as client.resolved_capabilities but follows the latest specification of the Language Server Protocol (LSP).

To fix this error, you can try updating your Neovim plugin to the latest version or modifying your configuration to use the client.server_capabilities attribute instead. The specific steps to do this will depend on the plugin you are using and how you have configured it.

If you're unsure how to proceed, you can try searching for the plugin documentation or reaching out to the plugin developer for support. Additionally, the Neovim community forums and subreddit can be great resources for finding help with common issues like this.


    78.4
79. hebrew, utf8, encodings, tags:hebrew, utf8, encodings 

    79.1 vim hebrew text is shown in reverse

It's likely that Vim is not set up to handle Hebrew text properly. By default, Vim assumes that text is written from left to right, which is the standard direction for languages like English. However, Hebrew is a right-to-left language, and this can cause issues with text rendering in Vim.

To fix this issue, you need to configure Vim to properly handle right-to-left languages like Hebrew. You can do this by adding the following lines to your .vimrc configuration file:

set rightleft
set arabicshape
set guifont=*Arial\ Hebrew*

The set rightleft command tells Vim to handle text from right to left. The set arabicshape command sets the shape of the text characters to be appropriate for languages like Arabic and Hebrew. The set guifont=*Arial\ Hebrew* command sets the font for Hebrew text to Arial Hebrew.

Once you've made these changes, you should be able to view Hebrew text correctly in Vim.

q. vim unset rightleft
a. If you want to unset the rightleft option in Vim, you can use the command:

arduino
Copy code
:set norightleft
This will disable the rightleft option and return Vim to its default behavior of handling text from left to right.

It's worth noting that if you frequently work with right-to-left languages like Hebrew, Arabic, or Farsi, you may want to keep the rightleft option enabled and instead adjust your Vim configuration to better handle right-to-left text. This can make it easier to edit and view text in these languages.


    79.2
80.

