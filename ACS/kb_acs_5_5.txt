.........................................Table Of Contents...............................................................
1. features <URL:#tn=1. features>
	1.1 CSCtw87143 LDAP server spoofing with valid certificate <URL:#tn=	1.1 CSCtw87143 LDAP server spoofing with valid certificate>
		1.1.1 http://www.ietf.org/rfc/rfc4513.txt <URL:#tn=		1.1.1 http://www.ietf.org/rfc/rfc4513.txt>
			1.1.1.1 3.1.3.  Server Identity Check <URL:#tn=			1.1.1.1 3.1.3.  Server Identity Check>
				1.1.1.1.1 3.1.3.1.  Comparison of DNS Names <URL:#tn=				1.1.1.1.1 3.1.3.1.  Comparison of DNS Names>
				1.1.1.1.2 3.1.3.2.  Comparison of IP Addresses <URL:#tn=				1.1.1.1.2 3.1.3.2.  Comparison of IP Addresses>
				1.1.1.1.3 3.1.3.3.  Comparison of Other subjectName Types <URL:#tn=				1.1.1.1.3 3.1.3.3.  Comparison of Other subjectName Types>
			1.1.1.2 Compare to souece code of existing implementations <URL:#tn=			1.1.1.2 Compare to souece code of existing implementations>
				1.1.1.2.1 Open LDAP <URL:#tn=				1.1.1.2.1 Open LDAP>
					1.1.1.2.1.1  source code <URL:#tn=					1.1.1.2.1.1  source code>
						1.1.1.2.1.1.1 /cygdrive/c/work/ldap/openldap-2.4.32/libraries/libldap/tls_m.c   <URL:#tn=						1.1.1.2.1.1.1 /cygdrive/c/work/ldap/openldap-2.4.32/libraries/libldap/tls_m.c  >
					1.1.1.2.1.2 Callbacks struct <URL:#tn=					1.1.1.2.1.2 Callbacks struct>
					1.1.1.2.1.3 host name check <URL:#tn=					1.1.1.2.1.3 host name check>
					1.1.1.2.1.4 Wiring of hostname check <URL:#tn=					1.1.1.2.1.4 Wiring of hostname check>
					1.1.1.2.1.5 <URL:#tn=					1.1.1.2.1.5>
				1.1.1.2.2 Mozilla LDAP <URL:#tn=				1.1.1.2.2 Mozilla LDAP>
					1.1.1.2.2.1 source code <URL:#tn=					1.1.1.2.2.1 source code>
					1.1.1.2.2.2 <URL:#tn=					1.1.1.2.2.2>
				1.1.1.2.3 <URL:#tn=				1.1.1.2.3>
			1.1.1.3 <URL:#tn=			1.1.1.3>
		1.1.2 Implementation <URL:#tn=		1.1.2 Implementation>
			1.1.2.1 research <URL:#tn=			1.1.2.1 research>
				1.1.2.1.1  Similar examples <URL:#tn=				1.1.2.1.1  Similar examples>
				1.1.2.1.2 Peer certificate verification callback <URL:#tn=				1.1.2.1.2 Peer certificate verification callback>
				1.1.2.1.3 <URL:#tn=				1.1.2.1.3>
			1.1.2.2 Clearcase details <URL:#tn=			1.1.2.2 Clearcase details>
			1.1.2.3 code <URL:#tn=			1.1.2.3 code>
				1.1.2.3.1  callback to check peer cert. <URL:#tn=				1.1.2.3.1  callback to check peer cert.>
				1.1.2.3.2 Set callback in SSLContext::init <URL:#tn=				1.1.2.3.2 Set callback in SSLContext::init>
				1.1.2.3.3  Wire it to handshake server certificate validation callback <URL:#tn=				1.1.2.3.3  Wire it to handshake server certificate validation callback>
				1.1.2.3.4 set LDAP callback <URL:#tn=				1.1.2.3.4 set LDAP callback>
					1.1.2.3.4.1 Compare to how EAP connection related info is passed to callback (since LDAP CB requires the hostname which is per LDAPConnection ) <URL:#tn=					1.1.2.3.4.1 Compare to how EAP connection related info is passed to callback (since LDAP CB requires the hostname which is per LDAPConnection )>
					1.1.2.3.4.2 Verify LDAP callback is wired so that connection info (for hostname) is passed <URL:#tn=					1.1.2.3.4.2 Verify LDAP callback is wired so that connection info (for hostname) is passed>
					1.1.2.3.4.3 <URL:#tn=					1.1.2.3.4.3>
				1.1.2.3.5 Adapt callback API to make sure required SSL objects are reachable  <URL:#tn=				1.1.2.3.5 Adapt callback API to make sure required SSL objects are reachable >
					1.1.2.3.5.1 modify getSAN. return a vector of struct {TypesOfSAN pType, string sResult} for types IP and DNS <URL:#tn=					1.1.2.3.5.1 modify getSAN. return a vector of struct {TypesOfSAN pType, string sResult} for types IP and DNS>
				1.1.2.3.6 Code review recent changes <URL:#tn=				1.1.2.3.6 Code review recent changes>
				1.1.2.3.7 Implement server certificate checks <URL:#tn=				1.1.2.3.7 Implement server certificate checks>
				1.1.2.3.8 <URL:#tn=				1.1.2.3.8>
			1.1.2.4 SSL_CTX_set_cert_verify_callback() approach <URL:#tn=			1.1.2.4 SSL_CTX_set_cert_verify_callback() approach>
				1.1.2.4.1 background  <URL:#tn=				1.1.2.4.1 background >
					1.1.2.4.1.1 http://stackoverflow.com/questions/2729254/ssl-ctx-set-cert-verify-callback-vs-ssl-ctx-set-verify  <URL:#tn=					1.1.2.4.1.1 http://stackoverflow.com/questions/2729254/ssl-ctx-set-cert-verify-callback-vs-ssl-ctx-set-verify >
					1.1.2.4.1.2 SSL_CTX_set_verify issue  <URL:#tn=					1.1.2.4.1.2 SSL_CTX_set_verify issue >
						1.1.2.4.1.2.1 SSL_CTX_set_verify issue   <URL:#tn=						1.1.2.4.1.2.1 SSL_CTX_set_verify issue  >
						1.1.2.4.1.2.2 http://etutorials.org/Programming/secure+programming/Chapter+10.+Public+Key+Infrastructure/10.7+Verifying+an+SSL+Peer+s+Certificate/ <URL:#tn=						1.1.2.4.1.2.2 http://etutorials.org/Programming/secure+programming/Chapter+10.+Public+Key+Infrastructure/10.7+Verifying+an+SSL+Peer+s+Certificate/>
10.7.3 Discussion <URL:#tn=10.7.3 Discussion>
						1.1.2.4.1.2.3 SSL_CTX_set_verify example <URL:#tn=						1.1.2.4.1.2.3 SSL_CTX_set_verify example>
					1.1.2.4.1.3 <URL:#tn=					1.1.2.4.1.3>
				1.1.2.4.2  <URL:#tn=				1.1.2.4.2 >
			1.1.2.5 SSL_CTX_set_verify() - again <URL:#tn=			1.1.2.5 SSL_CTX_set_verify() - again>
			1.1.2.6 <URL:#tn=			1.1.2.6>
		1.1.3 Functional Specification <URL:#tn=		1.1.3 Functional Specification>
1.2.3.4	1.2.3.4	yes <URL:#tn=1.2.3.4	1.2.3.4	yes>
		1.1.4 Task breakdown <URL:#tn=		1.1.4 Task breakdown>
		1.1.5 Tests <URL:#tn=		1.1.5 Tests>
			1.1.5.1 Test "Hello callback"  <URL:#tn=			1.1.5.1 Test "Hello callback" >
				1.1.5.1.1  Setup & material <URL:#tn=				1.1.5.1.1  Setup & material>
					1.1.5.1.1.1   10.56.62.173 <URL:#tn=					1.1.5.1.1.1   10.56.62.173>
					1.1.5.1.1.2 10.56.24.149 <URL:#tn=					1.1.5.1.1.2 10.56.24.149>
						1.1.5.1.1.2.1  details <URL:#tn=						1.1.5.1.1.2.1  details>
						1.1.5.1.1.2.2 Admin Server <URL:#tn=						1.1.5.1.1.2.2 Admin Server>
						1.1.5.1.1.2.3 <URL:#tn=						1.1.5.1.1.2.3>
					1.1.5.1.1.3 <URL:#tn=					1.1.5.1.1.3>
				1.1.5.1.2 1st try <URL:#tn=				1.1.5.1.2 1st try>
				1.1.5.1.3 2nd try <URL:#tn=				1.1.5.1.3 2nd try>
				1.1.5.1.4 3rd try <URL:#tn=				1.1.5.1.4 3rd try>
				1.1.5.1.5 <URL:#tn=				1.1.5.1.5>
			1.1.5.2 Test extraction of data from server certificate <URL:#tn=			1.1.5.2 Test extraction of data from server certificate>
				1.1.5.2.1 1st try <URL:#tn=				1.1.5.2.1 1st try>
				1.1.5.2.2 2nd try <URL:#tn=				1.1.5.2.2 2nd try>
				1.1.5.2.3 <URL:#tn=				1.1.5.2.3>
			1.1.5.3  Full coverage <URL:#tn=			1.1.5.3  Full coverage>
		1.1.6 Code review <URL:#tn=		1.1.6 Code review>
			1.1.6.1 change set Wed 01/02/2013  <URL:#tn=			1.1.6.1 change set Wed 01/02/2013 >
			1.1.6.2 emails <URL:#tn=			1.1.6.2 emails>
				1.1.6.2.1  Sasha <URL:#tn=				1.1.6.2.1  Sasha>
				1.1.6.2.2 Sergey <URL:#tn=				1.1.6.2.2 Sergey>
			1.1.6.3 <URL:#tn=			1.1.6.3>
		1.1.7 Odds and ends <URL:#tn=		1.1.7 Odds and ends>
			1.1.7.1  Add control checkbox <URL:#tn=			1.1.7.1  Add control checkbox>
			1.1.7.2 <URL:#tn=			1.1.7.2>
		1.1.8 final tests <URL:#tn=		1.1.8 final tests>
			1.1.8.1  SAN IP Negative <URL:#tn=			1.1.8.1  SAN IP Negative>
				1.1.8.1.1  1st try <URL:#tn=				1.1.8.1.1  1st try>
				1.1.8.1.2 2nd try <URL:#tn=				1.1.8.1.2 2nd try>
	10.56.63.69 <URL:#tn=	10.56.63.69>
				1.1.8.1.3 <URL:#tn=				1.1.8.1.3>
			1.1.8.2 SAN IP Positive  <URL:#tn=			1.1.8.2 SAN IP Positive >
			1.1.8.3 Multi SAN FQDN DNS Positive  <URL:#tn=			1.1.8.3 Multi SAN FQDN DNS Positive >
			1.1.8.4 Multi SAN FQDN DNS Negative  <URL:#tn=			1.1.8.4 Multi SAN FQDN DNS Negative >
			1.1.8.5 Disable Server Certificate check  <URL:#tn=			1.1.8.5 Disable Server Certificate check >
			1.1.8.6 Multi SAN FQDN wildcard DNS Positive  <URL:#tn=			1.1.8.6 Multi SAN FQDN wildcard DNS Positive >
			1.1.8.7 Multi SAN FQDN wildcard DNS Negative  <URL:#tn=			1.1.8.7 Multi SAN FQDN wildcard DNS Negative >
			1.1.8.9 CN FQDN DNS positive  <URL:#tn=			1.1.8.9 CN FQDN DNS positive >
			1.1.8.10 CN FQDN DNS Negative  <URL:#tn=			1.1.8.10 CN FQDN DNS Negative >
			1.1.8.9 CN FQDN wildcard DNS positive  <URL:#tn=			1.1.8.9 CN FQDN wildcard DNS positive >
			1.1.8.10 CN FQDN wildcard DNS Negative  <URL:#tn=			1.1.8.10 CN FQDN wildcard DNS Negative >
			1.1.8.11 <URL:#tn=			1.1.8.11>
		1.1.9 ToI to Anatoly  <URL:#tn=		1.1.9 ToI to Anatoly >
		1.1.10 refactor code to cryptoLib <URL:#tn=		1.1.10 refactor code to cryptoLib>
			1.1.10.1 Design <URL:#tn=			1.1.10.1 Design>
			1.1.10.2 <URL:#tn=			1.1.10.2>
		1.1.11 Customer logs <URL:#tn=		1.1.11 Customer logs>
			1.1.11.1 Flow for intercepting SSL Connection establishment <URL:#tn=			1.1.11.1 Flow for intercepting SSL Connection establishment>
			1.1.11.2 <URL:#tn=			1.1.11.2>
		1.1.12 Close bug <URL:#tn=		1.1.12 Close bug>
			1.1.12.1  R comment <URL:#tn=			1.1.12.1  R comment>
			1.1.12.2 Mail Nabin <URL:#tn=			1.1.12.2 Mail Nabin>
			1.1.12.3 <URL:#tn=			1.1.12.3>
		1.1.13 LDAP Server ID check. Add customer logs  <URL:#tn=		1.1.13 LDAP Server ID check. Add customer logs >
		1.1.14 <URL:#tn=		1.1.14>
	1.2 CSCtw89837 acs patch install does not verify signature of patches <URL:#tn=	1.2 CSCtw89837 acs patch install does not verify signature of patches>
		1.2.1 Description <URL:#tn=		1.2.1 Description>
		1.2.2 SFS <URL:#tn=		1.2.2 SFS>
			1.2.2.1  ISE <URL:#tn=			1.2.2.1  ISE>
				1.1.1.1.1	CLI verification of Software Packages <URL:#tn=				1.1.1.1.1	CLI verification of Software Packages>
			1.2.2.2 ACS <URL:#tn=			1.2.2.2 ACS>
			1.2.2.3 acs_ctrl.c <URL:#tn=			1.2.2.3 acs_ctrl.c>
		1.2.3 Code Review <URL:#tn=		1.2.3 Code Review>
			1.2.3.1 email <URL:#tn=			1.2.3.1 email>
			1.2.3.2 Code <URL:#tn=			1.2.3.2 Code>
				1.2.3.2.1 cars_install.c <URL:#tn=				1.2.3.2.1 cars_install.c>
			1.2.3.3 <URL:#tn=			1.2.3.3>
		1.2.4 <URL:#tn=		1.2.4>
	1.3 MAR Cache Persistency  <URL:#tn=	1.3 MAR Cache Persistency >
		1.3.1  Functional Specification <URL:#tn=		1.3.1  Functional Specification>
		1.3.2 Design <URL:#tn=		1.3.2 Design>
			1.3.2.1  Task breakdown <URL:#tn=			1.3.2.1  Task breakdown>
			1.3.2.1 trigger save upon acs stop <URL:#tn=			1.3.2.1 trigger save upon acs stop>
			1.3.2.2 <URL:#tn=			1.3.2.2>
		1.3.3 <URL:#tn=		1.3.3>
	1.4 Centrify automatic integration to patches <URL:#tn=	1.4 Centrify automatic integration to patches>
	1.5 P1-R26 ACS MUST NOT expose “backup” or “Database” encryption keys publicly in any way, shape or form <URL:#tn=	1.5 P1-R26 ACS MUST NOT expose “backup” or “Database” encryption keys publicly in any way, shape or form>
		1.5.1 Functional Specification <URL:#tn=		1.5.1 Functional Specification>
		1.5.2 Task breakdown <URL:#tn=		1.5.2 Task breakdown>
	1.6 TCP/TCPSecure Syslog <URL:#tn=	1.6 TCP/TCPSecure Syslog>
		1.6.1 Code review  <URL:#tn=		1.6.1 Code review >
		1.6.2 <URL:#tn=		1.6.2>
2. Bugs <URL:#tn=2. Bugs>
	2.1 For FC <URL:#tn=	2.1 For FC>
		2.1.1 CSCua34208 ACS returns different username in access-accept than what client sent <URL:#tn=		2.1.1 CSCua34208 ACS returns different username in access-accept than what client sent>
		2.1.2 <URL:#tn=		2.1.2>
	2.2 <URL:#tn=	2.2>
3. Machines <URL:#tn=3. Machines>
	3.1  Virtual dev Machines <URL:#tn=	3.1  Virtual dev Machines>
		3.1.1  pmbu-dev-vm22  <URL:#tn=		3.1.1  pmbu-dev-vm22 >
			3.1.1.1   Install gcc <URL:#tn=			3.1.1.1   Install gcc>
			3.1.1.2 Copy JNI headers to gcc <URL:#tn=			3.1.1.2 Copy JNI headers to gcc>
			3.1.1.3 Python headers <URL:#tn=			3.1.1.3 Python headers>
			3.1.1.4 uuid <URL:#tn=			3.1.1.4 uuid>
			3.1.1.5 Boost link errors <URL:#tn=			3.1.1.5 Boost link errors>
			3.1.1.6 <URL:#tn=			3.1.1.6>
		3.1.2 Virtual test Machines <URL:#tn=		3.1.2 Virtual test Machines>
			3.1.2.1 vinson1, 10.56.14.235, 5.5 FCS <URL:#tn=			3.1.2.1 vinson1, 10.56.14.235, 5.5 FCS>
			3.1.2.2 ISE 10.56.14.80    <URL:#tn=			3.1.2.2 ISE 10.56.14.80   >
			3.1.2.3 ESX license for our team <URL:#tn=			3.1.2.3 ESX license for our team>
			3.1.2.4 AcsFarm VMWARE FARM: SNSBU-C220-C21 NEW CIMC: https://10.56.54.92  <URL:#tn=			3.1.2.4 AcsFarm VMWARE FARM: SNSBU-C220-C21 NEW CIMC: https://10.56.54.92 >
		3.1.3 Sustaining <URL:#tn=		3.1.3 Sustaining>
		3.1.4 Support for machines - http://nmtg-vm1.cisco.com/CFApps/LabRAT2/main-noheader.cfm <URL:#tn=		3.1.4 Support for machines - http://nmtg-vm1.cisco.com/CFApps/LabRAT2/main-noheader.cfm>
			3.1.4.1 email <URL:#tn=			3.1.4.1 email>
			3.1.4.2 <URL:#tn=			3.1.4.2>
		3.1.5 <URL:#tn=		3.1.5>
	3.2 <URL:#tn=	3.2>
4. FAQS <URL:#tn=4. FAQS>
	4.1 ActiveDirectory <URL:#tn=	4.1 ActiveDirectory>
		4.1.1 Centrify joined but can't connect, adinfo shows Not found in DNS!Make sure it is in Reverse Lookup Zone. <URL:#tn=		4.1.1 Centrify joined but can't connect, adinfo shows Not found in DNS!Make sure it is in Reverse Lookup Zone.>
127.0.0.1               localhost.localdomain localhost <URL:#tn=127.0.0.1               localhost.localdomain localhost>
10.56.24.231  acs-sus-e7e <URL:#tn=10.56.24.231  acs-sus-e7e>
127.0.0.1               localhost.localdomain localhost <URL:#tn=127.0.0.1               localhost.localdomain localhost>
10.56.24.231  acs-sus-e7e.sustain.com acs-sus-e7e <URL:#tn=10.56.24.231  acs-sus-e7e.sustain.com acs-sus-e7e>
10.56.24.231            acs-sus-e7e #ACS5 Host <URL:#tn=10.56.24.231            acs-sus-e7e #ACS5 Host>
		4.1.2 <URL:#tn=		4.1.2>
	4.2 authentication <URL:#tn=	4.2 authentication>
		4.2.1 Zero touch, zt <URL:#tn=		4.2.1 Zero touch, zt>
			4.2.1.1  Kill current run <URL:#tn=			4.2.1.1  Kill current run>
			4.2.1.2 <URL:#tn=			4.2.1.2>
		4.2.2 <URL:#tn=		4.2.2>
	4.3 Patches <URL:#tn=	4.3 Patches>
		4.3.1 where’s filesToReplace of the patch on the machine? <URL:#tn=		4.3.1 where’s filesToReplace of the patch on the machine?>
	4.4 Protocols <URL:#tn=	4.4 Protocols>
		4.4.1 RADIUS <URL:#tn=		4.4.1 RADIUS>
			4.4.1.1 DTLS support for Radius  <URL:#tn=			4.4.1.1 DTLS support for Radius >
			4.4.1.2 configuration steps in ACS to restrict the users based on the received calling-station-id(radius)/remote-host-address(tacacs <URL:#tn=			4.4.1.2 configuration steps in ACS to restrict the users based on the received calling-station-id(radius)/remote-host-address(tacacs>
			4.4.1.3 <URL:#tn=			4.4.1.3>
		4.4.2 <URL:#tn=		4.4.2>
	4.5 <URL:#tn=	4.5>
5. Guides <URL:#tn=5. Guides>
	5.1  GUI <URL:#tn=	5.1  GUI>
		5.1.1   Add checkbox <URL:#tn=		5.1.1   Add checkbox>
			5.1.1.1    Entry point - page <URL:#tn=			5.1.1.1    Entry point - page>
			5.1.1.2 Labels (.properties) <URL:#tn=			5.1.1.2 Labels (.properties)>
			5.1.1.3 GUI - jsp <URL:#tn=			5.1.1.3 GUI - jsp>
			5.1.1.4 <URL:#tn=			5.1.1.4>
		5.1.2 <URL:#tn=		5.1.2>
	5.2 <URL:#tn=	5.2>
6. PKI <URL:#tn=6. PKI>
	6.1 Certificate generators  <URL:#tn=	6.1 Certificate generators >
		6.1.1 CertGen <URL:#tn=		6.1.1 CertGen>
			6.1.1.1  Usage example, make certificates for LDAP Server <URL:#tn=			6.1.1.1  Usage example, make certificates for LDAP Server>
				6.1.1.1.1  root CA <URL:#tn=				6.1.1.1.1  root CA>
				6.1.1.1.2  policy CA <URL:#tn=				6.1.1.1.2  policy CA>
				6.1.1.1.3  issuing CA <URL:#tn=				6.1.1.1.3  issuing CA>
				6.1.1.1.4  Server certificate <URL:#tn=				6.1.1.1.4  Server certificate>
				6.1.1.1.5 Bundle certs for Michael's LDAP server <URL:#tn=				6.1.1.1.5 Bundle certs for Michael's LDAP server>
				6.1.1.1.6 <URL:#tn=				6.1.1.1.6>
			6.1.1.2 <URL:#tn=			6.1.1.2>
		6.1.2 CryptoLib <URL:#tn=		6.1.2 CryptoLib>
			6.1.2.1  Error translation in CryptoLib <URL:#tn=			6.1.2.1  Error translation in CryptoLib>
			6.1.2.2 <URL:#tn=			6.1.2.2>
		6.1.3 <URL:#tn=		6.1.3>
	6.2 <URL:#tn=	6.2>
7. Setups <URL:#tn=7. Setups>
	7.1 ActiveDirectory <URL:#tn=	7.1 ActiveDirectory>
		7.1.1 2012 <URL:#tn=		7.1.1 2012>
		7.1.2 <URL:#tn=		7.1.2>
	7.2 <URL:#tn=	7.2>
8. Build <URL:#tn=8. Build>
	8.1 Hudson  <URL:#tn=	8.1 Hudson >
		8.1.1  Patches <URL:#tn=		8.1.1  Patches>
			8.1.1.1  5.4 patch config <URL:#tn=			8.1.1.1  5.4 patch config>
			8.1.1.2 <URL:#tn=			8.1.1.2>
		8.1.2 <URL:#tn=		8.1.2>
	8.2 <URL:#tn=	8.2>
9. Infrastructure <URL:#tn=9. Infrastructure>
	9.1 Threading model <URL:#tn=	9.1 Threading model>
		9.1.1 EventDispatcher <URL:#tn=		9.1.1 EventDispatcher>
			9.1.1.1 header <URL:#tn=			9.1.1.1 header>
			9.1.1.2 ThreadPools <URL:#tn=			9.1.1.2 ThreadPools>
				9.1.1.2.1 class ThreadPools <URL:#tn=				9.1.1.2.1 class ThreadPools>
					9.1.1.2.1.1 ReactorThreadPtr <URL:#tn=					9.1.1.2.1.1 ReactorThreadPtr>
					9.1.1.2.1.2 WorkerThreadPoolPtr <URL:#tn=					9.1.1.2.1.2 WorkerThreadPoolPtr>
					9.1.1.2.1.3 <URL:#tn=					9.1.1.2.1.3>
				9.1.1.2.2 <URL:#tn=				9.1.1.2.2>
			9.1.1.3 <URL:#tn=			9.1.1.3>
		9.1.2 EventHandler  <URL:#tn=		9.1.2 EventHandler >
			9.1.2.1  header <URL:#tn=			9.1.2.1  header>
		9.1.3 WorkerThreadPool <URL:#tn=		9.1.3 WorkerThreadPool>
			9.1.3.1 header <URL:#tn=			9.1.3.1 header>
			9.1.3.2 ACE_TSS <URL:#tn=			9.1.3.2 ACE_TSS>
			9.1.3.3 <URL:#tn=			9.1.3.3>
		9.1.4 event <URL:#tn=		9.1.4 event>
		9.1.5 AcsEvent <URL:#tn=		9.1.5 AcsEvent>
			9.1.5.1 Header <URL:#tn=			9.1.5.1 Header>
			9.1.5.2 Suspend/Resume example <URL:#tn=			9.1.5.2 Suspend/Resume example>
			9.1.5.3 <URL:#tn=			9.1.5.3>
		9.1.6 RefCountedObject <URL:#tn=		9.1.6 RefCountedObject>
		9.1.7 Context <URL:#tn=		9.1.7 Context>
			9.1.7.1 Header <URL:#tn=			9.1.7.1 Header>
			9.1.7.2 usage <URL:#tn=			9.1.7.2 usage>
			9.1.7.3 <URL:#tn=			9.1.7.3>
		9.1.8 <URL:#tn=		9.1.8>
	9.2 <URL:#tn=	9.2>
10. Code Reviews <URL:#tn=10. Code Reviews>
	10.1 Management  <URL:#tn=	10.1 Management >
		10.1.1 Subject: Code review for bug Bug CSCuf74902 (Remotesyslog Directoryfiles in secondary not deleted during Register) <URL:#tn=		10.1.1 Subject: Code review for bug Bug CSCuf74902 (Remotesyslog Directoryfiles in secondary not deleted during Register)>
	10.2 <URL:#tn=	10.2>
11. <URL:#tn=11.>
.................................................END TOC..............................................








Description: 	ACS, AAA server application of Cisco, SAMPG versions 5.x related knowledge.
Author:		Yosi Izaq.

1. features

	1.1 CSCtw87143 LDAP server spoofing with valid certificate
Use case: User authentication/authorization (attribute/group retrieval) against LDAP server.

LDAP server can be spoofed if an attacker have ability to establish rogue LDAP server on a real LDAP server IP address (can be achieved by another attack on the network) and have a valid certificate issued by the same CA as valid LDAP server certificate.


		1.1.1 http://www.ietf.org/rfc/rfc4513.txt

			1.1.1.1 3.1.3.  Server Identity Check
In order to prevent man-in-the-middle attacks, the client MUST verify
   the server's identity (as presented in the server's Certificate
   message).  In this section, the client's understanding of the
   server's identity (typically the identity used to establish the
   transport connection) is called the "reference identity".

   The client determines the type (e.g., DNS name or IP address) of the
   reference identity and performs a comparison between the reference
   identity and each subjectAltName value of the corresponding type
   until a match is produced.  Once a match is produced, the server's
   identity has been verified, and the server identity check is
   complete.  Different subjectAltName types are matched in different
   ways.  Sections 3.1.3.1 - 3.1.3.3 explain how to compare values of
   various subjectAltName types.

   The client may map the reference identity to a different type prior
   to performing a comparison.  Mappings may be performed for all
   available subjectAltName types to which the reference identity can be
   mapped; however, the reference identity should only be mapped to
   types for which the mapping is either inherently secure (e.g.,
   extracting the DNS name from a URI to compare with a subjectAltName
   of type dNSName) or for which the mapping is performed in a secure
   manner (e.g., using DNSSEC, or using user- or admin-configured host-
   to-address/address-to-host lookup tables).

   The server's identity may also be verified by comparing the reference
   identity to the Common Name (CN) [RFC4519] value in the leaf Relative
   Distinguished Name (RDN) of the subjectName field of the server's
   certificate.  This comparison is performed using the rules for
   comparison of DNS names in Section 3.1.3.1, below, with the exception
   that no wildcard matching is allowed.  Although the use of the Common
   Name value is existing practice, it is deprecated, and Certification
   Authorities are encouraged to provide subjectAltName values instead.
   Note that the TLS implementation may represent DNs in certificates
   according to X.500 or other conventions.  For example, some X.500
   implementations order the RDNs in a DN using a left-to-right (most
   significant to least significant) convention instead of LDAP's
   right-to-left convention.

   If the server identity check fails, user-oriented clients SHOULD
   either notify the user (clients may give the user the opportunity to
   continue with the LDAP session in this case) or close the transport
   connection and indicate that the server's identity is suspect.
   Automated clients SHOULD close the transport connection and then
   return or log an error indicating that the server's identity is
   suspect or both.

   Beyond the server identity check described in this section, clients
   should be prepared to do further checking to ensure that the server
   is authorized to provide the service it is requested to provide.  The
   client may need to make use of local policy information in making
   this determination.

				1.1.1.1.1 3.1.3.1.  Comparison of DNS Names

   If the reference identity is an internationalized domain name,
   conforming implementations MUST convert it to the ASCII Compatible
   Encoding (ACE) format as specified in Section 4 of RFC 3490 [RFC3490]
   before comparison with subjectAltName values of type dNSName.
   Specifically, conforming implementations MUST perform the conversion
   operation specified in Section 4 of RFC 3490 as follows:

      * in step 1, the domain name SHALL be considered a "stored
        string";
      * in step 3, set the flag called "UseSTD3ASCIIRules";
      * in step 4, process each label with the "ToASCII" operation; and
      * in step 5, change all label separators to U+002E (full stop).
      After performing the "to-ASCII" conversion, the DNS labels and names
   MUST be compared for equality according to the rules specified in
   Section 3 of RFC3490.

   The '*' (ASCII 42) wildcard character is allowed in subjectAltName
   values of type dNSName, and then only as the left-most (least
   significant) DNS label in that value.  This wildcard matches any
   left-most DNS label in the server name.  That is, the subject
   *.example.com matches the server names a.example.com and
   b.example.com, but does not match example.com or a.b.example.com.

				1.1.1.1.2 3.1.3.2.  Comparison of IP Addresses

   When the reference identity is an IP address, the identity MUST be
   converted to the "network byte order" octet string representation
   [RFC791][RFC2460].  For IP Version 4, as specified in RFC 791, the
   octet string will contain exactly four octets.  For IP Version 6, as
   specified in RFC 2460, the octet string will contain exactly sixteen
   octets.  This octet string is then compared against subjectAltName
   values of type iPAddress.  A match occurs if the reference identity
   octet string and value octet strings are identical.

				1.1.1.1.3 3.1.3.3.  Comparison of Other subjectName Types

   Client implementations MAY support matching against subjectAltName
   values of other types as described in other documents.

			1.1.1.2 Compare to souece code of existing implementations

				1.1.1.2.1 Open LDAP
http://www.openldap.org/software/download/
/cygdrive/c/work/ldap/openldap-2.4.32

vim session: 
[yizaq@yizaq-WS:Wed Sep 19:/cygdrive/c/work/ldap/openldap-2.4.32:]$ resume_edit  /cygdrive/c/work/vim_sessions/open_ldap
Resuming editing session on files: 
/cygdrive/c/work/vim_sessions/open_ldap
/cygdrive/c/work/ldap/openldap-2.4.32/include/ldap.h
/cygdrive/c/work/ldap/openldap-2.4.32/include/lber.h
/cygdrive/c/work/ldap/openldap-2.4.32/libraries/libldap/tls_m.c
/cygdrive/c/work/ldap/openldap-2.4.32/libraries/libldap/util-int.c
/cygdrive/c/work/ldap/openldap-2.4.32/libraries/libldap/init.c
/cygdrive/c/work/ldap/openldap-2.4.32/servers/slapd/main.c
using GVIM
7 files to edit

					1.1.1.2.1.1  source code

						1.1.1.2.1.1.1 /cygdrive/c/work/ldap/openldap-2.4.32/libraries/libldap/tls_m.c  
/* what kind of hostname were we given? */
#define	IS_DNS	0
#define	IS_IP4	1
#define	IS_IP6	2

static int
tlsm_session_chkhost( LDAP *ld, tls_session *session, const char *name_in )
{
	tlsm_session *s = (tlsm_session *)session;
	CERTCertificate *cert;
	const char *name, *domain = NULL, *ptr;
	int ret, ntype = IS_DNS, nlen, dlen;
#ifdef LDAP_PF_INET6
	struct in6_addr addr;
#else
	struct in_addr addr;
#endif
	SECItem altname;
	SECStatus rv;

	if( ldap_int_hostname &&
		( !name_in || !strcasecmp( name_in, "localhost" ) ) )
	{
		name = ldap_int_hostname;
	} else {
		name = name_in;
	}
	nlen = strlen( name );

	cert = SSL_PeerCertificate( s );
	if (!cert) {
		Debug( LDAP_DEBUG_ANY,
			"TLS: unable to get peer certificate.\n",
			0, 0, 0 );
		/* if this was a fatal condition, things would have
		 * aborted long before now.
		 */
		return LDAP_SUCCESS;
	}

#ifdef LDAP_PF_INET6
	if (inet_pton(AF_INET6, name, &addr)) {
		ntype = IS_IP6;
	} else 
#endif
	if ((ptr = strrchr(name, '.')) && isdigit((unsigned char)ptr[1])) {
		if (inet_aton(name, (struct in_addr *)&addr)) ntype = IS_IP4;
	}
	if (ntype == IS_DNS ) {
		domain = strchr( name, '.' );
		if ( domain )
			dlen = nlen - ( domain - name );
	}

	ret = LDAP_LOCAL_ERROR;

	rv = CERT_FindCertExtension( cert, SEC_OID_X509_SUBJECT_ALT_NAME,
		&altname );
	if ( rv == SECSuccess && altname.data ) {
		PRArenaPool *arena;
		CERTGeneralName *names, *cur;

		arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
		if ( !arena ) {
			ret = LDAP_NO_MEMORY;
			goto fail;
		}

		names = cur = CERT_DecodeAltNameExtension(arena, &altname);
		if ( !cur )
			goto altfail;

		do {
			char *host;
			int hlen;

			/* ignore empty */
			if ( !cur->name.other.len ) continue;

			host = (char *)cur->name.other.data;
			hlen = cur->name.other.len;

			if ( cur->type == certDNSName ) {
				if ( ntype != IS_DNS )	continue;

				/* is this an exact match? */
				if ( nlen == hlen && !strncasecmp( name, host, nlen )) {
					ret = LDAP_SUCCESS;
					break;
				}

				/* is this a wildcard match? */
				if ( domain && host[0] == '*' && host[1] == '.' &&
					dlen == hlen-1 && !strncasecmp( domain, host+1, dlen )) {
					ret = LDAP_SUCCESS;
					break;
				}
			} else if ( cur->type == certIPAddress ) {
				if ( ntype == IS_DNS )	continue;
				
#ifdef LDAP_PF_INET6
				if (ntype == IS_IP6 && hlen != sizeof(struct in6_addr)) {
					continue;
				} else
#endif
				if (ntype == IS_IP4 && hlen != sizeof(struct in_addr)) {
					continue;
				}
				if (!memcmp(host, &addr, hlen)) {
					ret = LDAP_SUCCESS;
					break;
				}
			}
		} while (( cur = CERT_GetNextGeneralName( cur )) != names );
altfail:
		PORT_FreeArena( arena, PR_FALSE );
		SECITEM_FreeItem( &altname, PR_FALSE );
	}
	/* no altnames matched, try the CN */
	if ( ret != LDAP_SUCCESS ) {
		/* find the last CN */
		CERTRDN *rdn, **rdns;
		CERTAVA *lastava = NULL;
		char buf[2048];

		buf[0] = '\0';
		rdns = cert->subject.rdns;
		while ( rdns && ( rdn = *rdns++ )) {
			CERTAVA *ava, **avas = rdn->avas;
			while ( avas && ( ava = *avas++ )) {
				if ( CERT_GetAVATag( ava ) == SEC_OID_AVA_COMMON_NAME )
					lastava = ava;
			}
		}
		if ( lastava ) {
			SECItem *av = CERT_DecodeAVAValue( &lastava->value );
			if ( av ) {
				if ( av->len == nlen && !strncasecmp( name, (char *)av->data, nlen )) {
					ret = LDAP_SUCCESS;
				} else if ( av->data[0] == '*' && av->data[1] == '.' &&
					domain && dlen == av->len - 1 && !strncasecmp( domain,
						(char *)(av->data+1), dlen )) {
					ret = LDAP_SUCCESS;
				} else {
					int len = av->len;
					if ( len >= sizeof(buf) )
						len = sizeof(buf)-1;
					memcpy( buf, av->data, len );
					buf[len] = '\0';
				}
				SECITEM_FreeItem( av, PR_TRUE );
			}
		}
		if ( ret != LDAP_SUCCESS ) {
			Debug( LDAP_DEBUG_ANY, "TLS: hostname (%s) does not match "
				"common name in certificate (%s).\n", 
				name, buf, 0 );
			ret = LDAP_CONNECT_ERROR;
			if ( ld->ld_error ) {
				LDAP_FREE( ld->ld_error );
			}
			ld->ld_error = LDAP_STRDUP(
				_("TLS: hostname does not match CN in peer certificate"));
		}
	}

fail:
	CERT_DestroyCertificate( cert );
	return ret;
}

Summary:
Check Comparison of IPv4/IPv6 or DNS host name to subjectAltName fields, if that fails try comparison to CN
Support wildcard chars in DNS comparison

					1.1.1.2.1.2 Callbacks struct
tls_impl ldap_int_tls_impl = {
	"MozNSS",

	tlsm_init,
	tlsm_destroy,

	tlsm_ctx_new,
	tlsm_ctx_ref,
	tlsm_ctx_free,
	tlsm_ctx_init,

	tlsm_session_new,
	tlsm_session_connect,
	tlsm_session_accept,
	tlsm_session_upflags,
	tlsm_session_errmsg,
	tlsm_session_my_dn,
	tlsm_session_peer_dn,
	tlsm_session_chkhost,
	tlsm_session_strength,

	&tlsm_sbio,

#ifdef LDAP_R_COMPILE
	tlsm_thr_init,
#else
	NULL,
#endif

	0
};

					1.1.1.2.1.3 host name check
libraries/libldap/tls2.c

int
ldap_pvt_tls_check_hostname( LDAP *ld, void *s, const char *name_in )
{
	tls_session *session = s;

	return tls_imp->ti_session_chkhost( ld, session, name_in );
}

ldap_int_tls_start() -> ldap_pvt_tls_check_hostname() -> tls_imp->ti_session_chkhost()


					1.1.1.2.1.4 Wiring of hostname check
- Struct for function pointers
tls_impl ldap_int_tls_impl 

- Defined at libraries/libldap/ldap-tls.h
typedef struct tls_impl {
	const char *ti_name;

	TI_tls_init *ti_tls_init;	/* library initialization */
	TI_tls_destroy *ti_tls_destroy;

	TI_ctx_new *ti_ctx_new;
	TI_ctx_ref *ti_ctx_ref;
	TI_ctx_free *ti_ctx_free;
	TI_ctx_init *ti_ctx_init;

	TI_session_new *ti_session_new;
	TI_session_connect *ti_session_connect;
	TI_session_accept *ti_session_accept;
	TI_session_upflags *ti_session_upflags;
	TI_session_errmsg *ti_session_errmsg;
	TI_session_dn *ti_session_my_dn;
	TI_session_dn *ti_session_peer_dn;
	TI_session_chkhost *ti_session_chkhost;
	TI_session_strength *ti_session_strength;

	Sockbuf_IO *ti_sbio;

	TI_thr_init *ti_thr_init;

	int ti_inited;
} tls_impl;

- wrapper

int
ldap_pvt_tls_check_hostname( LDAP *ld, void *s, const char *name_in )
{
	tls_session *session = s;

	return tls_imp->ti_session_chkhost( ld, session, name_in );
}

- Called from
ldap_new_connection()
	|
	V
ldap_int_open_connection()
	|
	V
ldap_int_tls_start ( LDAP *ld, LDAPConn *conn, LDAPURLDesc *srv )
...
	/* 
	 * compare host with name(s) in certificate
	 */
	if (ld->ld_options.ldo_tls_require_cert != LDAP_OPT_X_TLS_NEVER &&
	    ld->ld_options.ldo_tls_require_cert != LDAP_OPT_X_TLS_ALLOW) {
		ld->ld_errno = ldap_pvt_tls_check_hostname( ld, ssl, host );
		if (ld->ld_errno != LDAP_SUCCESS) {
			return ld->ld_errno;
		}

-
					1.1.1.2.1.5
				1.1.1.2.2 Mozilla LDAP
https://wiki.mozilla.org/LDAP_C_SDK#Checking_Out_the_Source_Code
/cygdrive/c/work/ldap/mozilla

pull source:
[yizaq@yizaq-WS:Sun Sep 16:/cygdrive/c/work/ldap/mozilla:]$ export  CVSROOT=":pserver:anonymous@cvs-mirror.mozilla.org:/cvsroot"
[yizaq@yizaq-WS:Sun Sep 16:/cygdrive/c/work/ldap/mozilla:]$ echo $CVSROOT
:pserver:anonymous@cvs-mirror.mozilla.org:/cvsroot
[yizaq@yizaq-WS:Sun Sep 16:/cygdrive/c/work/ldap/mozilla:]$ cvs co -P -r LDAPCSDK_6_0_6_RTM DirectorySDKSourceC
cvs checkout: CVS password file /home/yizaq/.cvspass does not exist - creating a new file
U mozilla/directory/ldapsdk.mak
U mozilla/directory/ldapsdk.mk
cvs checkout: warning: new-born mozilla/directory/buildsdk.txt has disappeared
U mozilla/directory/Makefile
cvs checkout: Updating mozilla/directory/c-sdk
U mozilla/directory/c-sdk/.cvsignore
U mozilla/directory/c-sdk/Makefile.in
U mozilla/directory/c-sdk/README.configure
U mozilla/directory/c-sdk/README.rpm
...

[yizaq@yizaq-WS:Wed Sep 19:/cygdrive/c/work/ldap/mozilla:]$ 

vim session:
[yizaq@yizaq-WS:Wed Sep 19:/cygdrive/c/work/ldap/mozilla:]$  resume_edit /cygdrive/c/work/vim_sessions/mozilla_ldap 
Resuming editing session on files: 
/cygdrive/c/work/vim_sessions/mozilla_ldap
/cygdrive/c/work/ldap/mozilla/mozilla/directory/c-sdk/ldap/libraries/libprldap/ldappr-io.c
/cygdrive/c/work/ldap/mozilla/mozilla/directory/c-sdk/ldap/libraries/libssldap/clientinit.c


					1.1.1.2.2.1 source code
mozilla/directory/c-sdk/ldap/libraries/libssldap/ldapsinit.c
/* this function provides cert authentication.  This is called during 
 * the SSL_Handshake process.  Once the cert has been retrieved from
 * the server, the it is checked, using VerifyCertNow(), then 
 * the cn is checked against the host name, set with SSL_SetURL()
 */

static int
ldapssl_AuthCertificate(void *sessionarg, PRFileDesc *fd, PRBool checkSig,
	PRBool isServer)
{
    SECStatus		rv = SECFailure;
    LDAPSSLSessionInfo	*sseip;
    CERTCertificate	*cert;
    SECCertUsage	certUsage;
    char		*hostname = (char *)0;

    if (!sessionarg || !fd) {
	return rv;
    }

    sseip = (LDAPSSLSessionInfo *)sessionarg;

    if (LDAPSSL_AUTH_WEAK == sseip->lssei_ssl_strength ) { /* no check */
	return SECSuccess;
    }

    if ( isServer ) {
	certUsage = certUsageSSLClient;
    } else {
	certUsage = certUsageSSLServer;
    }
    cert = SSL_PeerCertificate( fd );
    
    rv = CERT_VerifyCertNow(sseip->lssei_certdbh, cert, checkSig,
			certUsage, NULL);

    if ( rv != SECSuccess || isServer ) {
	/* must destroy cert to avoid mem leak */
	CERT_DestroyCertificate(cert);
	return rv;
    }
  
    if ( LDAPSSL_AUTH_CNCHECK == sseip->lssei_ssl_strength ) {
	/* cert is OK.  This is the client side of an SSL connection.
	 * Now check the name field in the cert against the desired hostname.
	 * NB: This is our only defense against Man-In-The-Middle (MITM) 
	 * attacks!
	 */

	hostname = SSL_RevealURL( fd );

	if (hostname && hostname[0]) {
	  rv = CERT_VerifyCertName(cert, hostname);
	} else  {
	  rv = SECFailure;
     	}
        if (hostname) {
	  PL_strfree(hostname);
        }
	if (rv != SECSuccess) {
	  PORT_SetError(SSL_ERROR_BAD_CERT_DOMAIN);
        }
    }

    /* must destroy cert to avoid mem leak */
    CERT_DestroyCertificate(cert);
    return((int)rv);
}

- When:
CERT_VerifyCertName
Compares the common name specified in the subject DN for a certificate with a specified hostname.

Syntax

#include <cert.h>

SECStatus CERT_VerifyCertName(
   CERTCertificate *cert, 
   char *hostname);

Parameters
This function has the following parameters:

cert

	

A pointer to the certificate against which to check the hostname referenced by hostname.

hostname

	

The hostname to be checked.

Returns
The function returns one of these values:

    If the common name in the subject DN for the certificate matches the domain name passed in the hostname parameter, SECSuccess.
    If the common name in the subject DN for the certificate is not identical to the domain name passed in the hostname parameter, SECFailure. Use PR_GetError to obtain the error code. 

Description
The comparison performed by CERT_VerifyCertName is not a simple string comparison. Instead, it takes account of the following rules governing the construction of common names in SSL server certificates:

    * matches anything

    ? matches one character

    \ escapes a special character

    $ matches the end of the string

    [abc] matches one occurrence of a, b, or c. The only character that needs to be escaped in this is ], all others are not special.

    [a-z] matches any character between a and z

    [^az] matches any character except a or z

    ~ followed by another shell expression removes any pattern matching the shell expression from the match list

    (foo|bar) matches either the substring foo or the substring bar. These can be shell expressions as well.


- summary 
Basic check for CN 

					1.1.1.2.2.2


				1.1.1.2.3

Conclusion: adopt a model that is similar to openldap
Need to modify our peer verify callback in SSL
_cb
ocsp
			1.1.1.3
		1.1.2 Implementation

			1.1.2.1 research
- related classes:
LdapSslContext
LdapSslConnectionContext

				1.1.2.1.1  Similar examples
- Session tickets

	-- Add callback function:
SSLContext.h:        tls_session_ticket_ext_cb_fn    getTlsSessionTicketExtentionsCB() const;
SSLContext.h:        tls_session_secret_cb_fn        getTlsSessionSecretCB() const;
SSLContext.h:        tls_newsession_ticket_cb_fn     getTlsNewSessionTicketCB() const;

SSLInterface.h:        tls_session_ticket_ext_cb_fn    fnTlsSessionTicketExtentionsCB;
SSLInterface.h:        tls_session_secret_cb_fn        fnTlsSessionSecretCB;
SSLInterface.h:        tls_newsession_ticket_cb_fn     fnTlsNewSessionTicketCB;

SSLInterface.h:        virtual tls_session_ticket_ext_cb_fn    getTlsSessionTicketExtentionsCB() const = 0;
SSLInterface.h:        virtual tls_session_secret_cb_fn        getTlsSessionSecretCB() const = 0;
SSLInterface.h:        virtual tls_notification_cb_fn          getTlsNotifyCB() const = 0;

runtime/build/lnx26/include/EapFastProtocol.h|355| <<global>> static int sessionTicketExtensionCB(INOUT SSL* ssl,
runtime/build/lnx26/include/EapTlsProtocol.h|68| <<global>> static int sessionTicketExtensionCB(INOUT SSL* ssl,
runtime/flow/eap/src/EapFastConfigObject.cpp|66| <<global>> pSSLInitiParams->fnTlsSessionTicketExtentionsCB = EapFastProtocol::sessionTicketExtensionCB;
runtime/flow/eap/src/EapFastProtocol.cpp|1133| <<global>>  int EapFastProtocol::sessionTicketExtensionCB(SSL* ssl,
/view/yizaq__int.acs5_0.lx/vob/nm_acs/acs/runtime/flow/eap/src/EapFastProtocol.h|355| <<global>> static int sessionTicketExtensionCB(INOUT SSL* ssl,
runtime/flow/eap/src/EapTlsConfigObject.cpp|63| <<global>> pSSLInitiParams->fnTlsSessionTicketExtentionsCB = EapTlsProtocol::sessionTicketExtensionCB;
runtime/flow/eap/src/EapTlsProtocol.cpp|1359| <<global>>  int EapTlsProtocol::sessionTicketExtensionCB(INOUT SSL* ssl,
runtime/flow/eap/src/EapTlsProtocol.h|68| <<global>> static int sessionTicketExtensionCB(INOUT SSL* ssl,
runtime/infrastructure/cryptoLib/test/TestTLS.h|64| <<global>> static int sessionTicketExtensionCB( SSL *s, const unsigned char *data, int len, void *arg ) ;
runtime/infrastructure/cryptoLib/test/TestTLS.cpp|404| <<testSSLHelloExtension>> serverParams.fnTlsSessionTicketExtentionsCB = sessionTicketExtensionCB;
runtime/infrastructure/cryptoLib/test/TestTLS.cpp|498| <<sessionTicketExtensionCB>> int TestTLS::sessionTicketExtensionCB(SSL *s, const unsigned char *data, int len, void *arg)
-

				1.1.2.1.2 Peer certificate verification callback

- Set to be called in handshake flow - runtime/infrastructure/cryptoLib/src/SSLContext.cpp
Result SSLContext::init(IN SSLInitParameters *pSSLInitParams)

    if ( true /* m_nLibraryInitOptions & SSLInitParameters::CHECK_CRL */ )
    {
        g_pILog->logDebug(__FILE__,__LINE__, RESULT_OK,
                          "Crypto.SSLContext.init - Setting X509 extended-verification callback" );
        pfVerifyX509_CB = CSSL::x509ExceptionStaticCallback;

        g_pILog->logDebug(__FILE__,__LINE__, RESULT_OK,
                          "Crypto.SSLContext.init - Setting to check X509 with flags 0x%X",
                          X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL );
        X509_STORE_set_flags(SSL_CTX_get_cert_store(m_pSSL_CTX), 
                             X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);
    }

    g_pILog->logDebug(__FILE__,__LINE__, RESULT_OK,
                      "Crypto.SSLContext.init - Setting verification options 0x%X and callback", nVerifyFlags );
    SSL_CTX_set_verify( m_pSSL_CTX, nVerifyFlags, pfVerifyX509_CB );

- Implementation
runtime/build/lnx26/include/SSL.h|66| <<global>> static int x509ExceptionStaticCallback(IN int nOK, IN X509_STORE_CTX* pX509StoreCtx);
/view/yizaq__int.acs5_0.lx/vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSL.h|66| <<global>> static int x509ExceptionStaticCallback(IN int nOK, IN X509_STORE_CTX* pX509StoreCtx);
/view/yizaq__int.acs5_0.lx/vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSL.cpp|1226| <<x509ExceptionStaticCallback>> int CSSL::x509ExceptionStaticCallback(IN int nOK, IN X509_STORE_CTX* pX509StoreCtx)
runtime/infrastructure/cryptoLib/src/SSLContext.cpp|981| <<init>> pfVerifyX509_CB = CSSL::x509ExceptionStaticCallback;

void CSSL::x509ExceptionCallback(INOUT int& nOK, IN X509_STORE_CTX* pX509StoreCtx) 
{
    g_pILog->logDebug(__FILE__, __LINE__, RESULT_OK, "CryptoLib.CSSL.x509ExceptionCallback");

    X509* pErrorCert = NULL;
    X509_NAME* pX509Name = NULL;
    char cn[CN_MAX_LEN] = {'\0'}; 
    int cnSize = 0;

    if (pX509StoreCtx == NULL)
    {
        return; 
    }

    SSL* pSSL = (SSL*)X509_STORE_CTX_get_ex_data(pX509StoreCtx, SSL_get_ex_data_X509_STORE_CTX_idx());
    
    switch (pX509StoreCtx->error)
    {
    case X509_V_ERR_UNABLE_TO_GET_CRL:
    case X509_V_ERR_CRL_HAS_EXPIRED:
    case X509_V_ERR_CRL_NOT_YET_VALID:
    case X509_V_ERR_CERT_HAS_EXPIRED:
    case X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION:
    case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:
    case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:
        pErrorCert = X509_STORE_CTX_get_current_cert(pX509StoreCtx);
        if (pErrorCert == NULL)
        {
            g_pILog->logWarn(__FILE__, __LINE__, RESULT_CANT_FIND_CERT, 
                             "Crypto.CSSL.x509ExceptionCallback - Failed to get current certificate=%d", 
                             pX509StoreCtx->error);
            return;
        }

        char buf[CN_MAX_LEN];
        X509_NAME_oneline(X509_get_subject_name(pErrorCert), buf, sizeof(buf));
        g_pILog->logDebug(__FILE__, __LINE__, RESULT_OK, "CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=%s, error=%d", buf, pX509StoreCtx->error);
        
        pX509Name = X509_get_issuer_name(pErrorCert);
        if (pX509Name == NULL)
        {
            g_pILog->logWarn(__FILE__, __LINE__, RESULT_FAILED_TO_GET_X509_CN, 
                             "CryptoLib.CSSL.x509ExceptionCallback - Failed extracting name=%d", 
                             pX509StoreCtx->error);
            return;
        }

        X509_NAME_oneline(pX509Name, buf, sizeof(buf));
        g_pILog->logDebug(__FILE__, __LINE__, RESULT_OK, "CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=%s", buf);
        
        cnSize = X509_NAME_get_text_by_NID(pX509Name, NID_commonName, cn, sizeof(cn));
        cn[sizeof(cn)-1]= '\0';
        break;

    case X509_V_ERR_CERT_REVOKED:   // certificate is revoked by preceeding OCSP check
    case X509_V_ERR_CERT_REJECTED:  // in case of certificate is unknown to OCSP 
        // just mark nOK=0 to be failed and stop processing
        nOK = 0;
        return;
        
    default:
        g_pILog->logDebug(__FILE__, __LINE__, RESULT_OK, "CryptoLib.CSSL.x509ExceptionCallback - un-handled error 0x%X, nOK=%d",pX509StoreCtx->error, nOK);
        return;
    }

    if (pX509Name == NULL)
    {
        return;
    }

    // for CRL related exceptions:
    // get current certificate issuer certificate to verify that it is situated in current SSL Context trust certificate store
    if (pX509StoreCtx->error == X509_V_ERR_UNABLE_TO_GET_CRL ||
        pX509StoreCtx->error == X509_V_ERR_CRL_HAS_EXPIRED ||
        pX509StoreCtx->error == X509_V_ERR_CRL_NOT_YET_VALID )
    {
        X509 *pIssuerCert = NULL;
        if ( X509_STORE_CTX_get1_issuer(&pIssuerCert, pX509StoreCtx, pErrorCert) != 1 )
        {
            g_pILog->logDebug(__FILE__, __LINE__, RESULT_OK, "CryptoLib.CSSL.x509ExceptionCallback - failed getting issuer certificate, means that it is not configured in CTL for this OpenSSL Context. Skipping it.");
            nOK = 1;
            return;
        }
    }

        
    CertificateIdentifier certificateIdentifierUser;
    certificateIdentifierUser.m_pSubjectName = pX509Name;
    
    AUTHORITY_KEYID *keyAKI = (AUTHORITY_KEYID*)X509_get_ext_d2i( 
                                    pErrorCert, NID_authority_key_identifier, NULL, NULL );
    SslAutoFree<AUTHORITY_KEYID> autofree(keyAKI);
                                    
    if( (keyAKI != NULL) && (keyAKI->keyid != NULL) && 
        (keyAKI->keyid->length > 0) && (keyAKI->keyid->data != NULL) )
    {
        certificateIdentifierUser.m_SKI.length = keyAKI->keyid->length;
        certificateIdentifierUser.m_SKI.data   = keyAKI->keyid->data;
    }

    AutoMutex ex(m_pLockCaStore);
    CAsInfo::iterator it = m_caStore.find(certificateIdentifierUser);
    bool found = (it != m_caStore.end());
/*    
    CAsInfo::iterator it;
    for ( it = m_caStore.begin() ; it != m_caStore.end() ; ++it )
    {
        CertificateIdentifierCmp temp;
        if( temp.operator()(it->first, certificateIdentifierUser) == 0 )
        {
            found = true;
            break;
        }
    }   
*/
    
    g_pILog->logDebug(__FILE__, __LINE__, RESULT_OK, "CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=%s, the issuer certificate found=%d", cn, found);
    

    switch (pX509StoreCtx->error)
    {
    case X509_V_ERR_UNABLE_TO_GET_CRL:
        if (found)
        {
            CAInfo ca = it->second;
            if (!ca.m_bLoadCrl)
            {
                nOK = 1;
                g_pILog->logDebug(__FILE__, __LINE__, RESULT_OK, 
                                  "CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=%s", cn);
            }
            else if (ca.m_bAllowedAuthenWithoutCrl)
            {
                nOK = 1;
                g_pILog->logDebug(__FILE__, __LINE__, RESULT_OK, 
                                  "CryptoLib.CSSL.x509ExceptionCallback - allow authentication before CRL received on CN=%s", cn);

                SSLConnection::_pvServerX509NotificationCB(pSSL, pX509StoreCtx->error, TLS_NOTIFY_CRL_BYPASSED);
            }
        }
        else
        {
            // If CRL is not configured for this CA:
            nOK = 1;
            g_pILog->logDebug(__FILE__, __LINE__, RESULT_OK, 
                              "CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=%s", cn);
        }
        break;
    case X509_V_ERR_CRL_HAS_EXPIRED:
    case X509_V_ERR_CRL_NOT_YET_VALID:
        if (found)
        {
            CAInfo ca = it->second;
            if (ca.m_bLoadCrl && ca.m_bIgnoreCrlExpiration)
            {
                nOK = 1;
                g_pILog->logDebug(__FILE__, __LINE__, RESULT_OK,
                                  "CryptoLib.CSSL.x509ExceptionCallback - bypass expired or not yet valid CRL on CN=%s", cn);

                SSLConnection::_pvServerX509NotificationCB(pSSL, pX509StoreCtx->error, TLS_NOTIFY_CRL_IGNORE_EXPIRED);
            }
        }
        break;
    case X509_V_ERR_CERT_HAS_EXPIRED:
        if (found)
        {
            CAInfo ca = it->second;
            if (ca.m_bIgnoreCertificateExpiration)
            {
                nOK = 1;
                g_pILog->logDebug(__FILE__, __LINE__, RESULT_OK,
                                  "CryptoLib.CSSL.x509ExceptionCallback - bypass expired certificate on CN=%s", cn);
            }
        }
        break;

    case X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION:
        if (found)
        {
            CAInfo ca = it->second;
            if (ca.m_bIgnoreCriticalExtensions)
            {
                nOK = 1;
                g_pILog->logDebug(__FILE__, __LINE__, RESULT_OK,
                                  "CryptoLib.CSSL.x509ExceptionCallback - bypass critical extension on CN=%s or in CRL", cn);
            }
        }
        break;
    case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY: // nothing to do, we just wanted to print certificate info into debug log
        break;
    default:
        g_pILog->logDebug(__FILE__, __LINE__, RESULT_OK, "CryptoLib.CSSL.x509ExceptionCallback - the exception was not processed");
        break;
    }
}

- Example of callback planted in the above
/view/yizaq__int.acs5_0.lx/vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSLConnection.h
        static void           _pvServerX509NotificationCB(const SSL *pSSLStruct, int x509Error, TLS_NOTIFY nTlsNotify);

- Implementation
// A static callback. Called from SSL.cpp when x509 certificate verification has an exception (e.g. crl verification failed)
void SSLConnection::_pvServerX509NotificationCB(const SSL *pSSLStruct, int x509Error, TLS_NOTIFY nTlsNotify)
{
    SSLConnection* pSSLConnection = (SSLConnection*)SSL_get_ex_data(pSSLStruct, s_ConnectionDataIndex);
    if (pSSLConnection!=NULL)
    {
        pSSLConnection->pvServerX509NotificationCB(x509Error, nTlsNotify);
    }
}

// A real callback. Uses TLS notify mechanism to write message to customer log
void SSLConnection::pvServerX509NotificationCB(int x509Error, TLS_NOTIFY nTlsNotify)
{
    g_pILog->logDebug(__FILE__,__LINE__, RESULT_OK, "Crypto.SSLConnection.pvServerX509NotificationCB - x509Error %d, TLS notify %d", x509Error, nTlsNotify);

    if ( m_pISSLContext->getTlsNotifyCB() )
    {
        if ( nTlsNotify != TLS_NOTIFY_UNKNOWN )
        {
            // CRL bypassed exception is called more than once for the same certificate. Prevent to write it more than once to customer logDebug
            if ( nTlsNotify == TLS_NOTIFY_CRL_BYPASSED )
            {
                if ( m_bCrlBypassed )
                {
                    return;
                }

                m_bCrlBypassed = true;
            }

            (*m_pISSLContext->getTlsNotifyCB())(this, nTlsNotify, NULL);
        }
    }
}

- setting the verify callback
runtime/infrastructure/cryptoLib/src/SSLContext.cpp|610| <<<unknown>>>     VerifyX509_CB_Type                  pfVerifyX509_CB = NULL;
runtime/infrastructure/cryptoLib/src/SSLContext.cpp|992| <<<unknown>>>         pfVerifyX509_CB = CSSL::x509ExceptionStaticCallback;
runtime/infrastructure/cryptoLib/src/SSLContext.cpp|1003| <<<unknown>>>     SSL_CTX_set_verify( m_pSSL_CTX, nVerifyFlags, pfVerifyX509_CB );

- Need to do something similar for ldap, as in 
Add callback function to 
runtime/infrastructure/cryptoLib/src/SSLInterface.h

    // LDAP certificate spoofing check callback
    typedef void (*ldap_cert_check_cb_fn)(IN ISSLConnection* pSSLConnection, IN Crypto::TLS_NOTIFY nTlsNotify, IN void* param);

and add it to init struct:
    struct SSLInitParameters
    {
...
        ldap_cert_check_cb_fn          fnLDAP_CERT_CHECK_CB;

- Add helper test, like:
int TestTLS::sessionTicketExtensionCB(SSL *s, const unsigned char *data, int len, void *arg)

UT are broken - this is a deadened

- Wire it to handshake server certificate validation callback:
runtime/infrastructure/cryptoLib/src/SSL.h|66| <<global>> static int x509ExceptionStaticCallback(IN int nOK, IN X509_STORE_CTX* pX509StoreCtx);
runtime/infrastructure/cryptoLib/src/SSL.cpp|1292| <<x509ExceptionStaticCallback>> int CSSL::x509ExceptionStaticCallback(IN int nOK, IN X509_STORE_CTX* pX509StoreCtx)
runtime/infrastructure/cryptoLib/src/SSLContext.cpp|981| <<init>> pfVerifyX509_CB = CSSL::x509ExceptionStaticCallback;


runtime/infrastructure/cryptoLib/src/SSLContext.cpp|981| <<init>> pfVerifyX509_CB = CSSL::x509ExceptionStaticCallback;
void CSSL::x509ExceptionCallback(INOUT int& nOK, IN X509_STORE_CTX* pX509StoreCtx) 

This is how the CB is wired:
runtime/infrastructure/cryptoLib/src/SSLContext.cpp|610| <<init>> VerifyX509_CB_Type pfVerifyX509_CB = NULL;
runtime/infrastructure/cryptoLib/src/SSLContext.cpp|981| <<init>> pfVerifyX509_CB = CSSL::x509ExceptionStaticCallback;
runtime/infrastructure/cryptoLib/src/SSLContext.cpp|992| <<init>> SSL_CTX_set_verify( m_pSSL_CTX, nVerifyFlags, pfVerifyX509_CB );

- Set function pointer from LDAP SSL Wrapper
LdapSslContext::init(VersionID nVersionID, const GenericConfigObject* pCertObj)
...
    Crypto::SSLInitParameters clientParams;
    clientParams.fnLDAP_CERT_CHECK_CB = LdapSslContext::verify_server_identity_CB;
	
- Implement callback in LDAP
Need to pass struct/ptr that contains server certificate


ex:
runtime/flow/eap/src/EapFastConfigObject.cpp|66| <<global>> pSSLInitiParams->fnTlsSessionTicketExtentionsCB = EapFastProtocol::sessionTicketExtensionCB;
runtime/flow/eap/src/EapTlsConfigObject.cpp|63| <<global>> pSSLInitiParams->fnTlsSessionTicketExtentionsCB = EapTlsProtocol::sessionTicketExtensionCB;
runtime/infrastructure/cryptoLib/src/SSLInterface.h|215| <<global>> tls_session_ticket_ext_cb_fn fnTlsSessionTicketExtentionsCB;
runtime/infrastructure/cryptoLib/src/SSLContext.cpp|632| <<init>> if ((pSSLInitParams->fnTlsSessionTicketExtentionsCB==NULL && pSSLInitParams->fnTlsSessionSecretCB!=NULL) ||
runtime/infrastructure/cryptoLib/src/SSLContext.cpp|633| <<init>> (pSSLInitParams->fnTlsSessionTicketExtentionsCB!=NULL && pSSLInitParams->fnTlsSessionSecretCB==NULL))
runtime/infrastructure/cryptoLib/src/SSLContext.cpp|639| <<init>> m_fnTlsSessionTicketExtensionCB= pSSLInitParams->fnTlsSessionTicketExtentionsCB;
runtime/infrastructure/cryptoLib/src/SSLContext.cpp|716| <<init>> if (pSSLInitParams->fnTlsSessionTicketExtentionsCB == NULL && !m_bIsClientMode)
/view/yizaq__yizaq_5_5_dev.int.acs5_0.lx/vob/nm_acs/acs/runtime/infrastructure/cryptoLib/test/TestTLS.cpp|404| <<testSSLHelloExtension>> serverParams.fnTlsSessionTicketExtentionsCB = sessionTicketExtensionCB;

- structure

ISSLContext  <---------------------------------------------------------------------------ISSL
    |                                                                                      |
    |                                                                                      \/
   \/                                                                                    CSSL::x509ExceptionStaticCallback
-->SSLContext -----> callback functions                                                      ::x509ExceptionCallback
|                                                                                             ::m_pCertificate
|  SSLContext::init() uses SSLInitParameters struct                                           ::m_pContexts
|
|
SSLConnection
				1.1.2.1.3

			1.1.2.2 Clearcase details
==================================================================================================================================
||        Stream yizaq_5_5_dev.int.acs5_0                                                                                       ||
==================================================================================================================================
||        View yizaq__yizaq_5_5_dev.int.acs5_0.lx                                                                               ||
==================================================================================================================================
||        Activity yizaq_CSCtw87143_LDAP_Spoofing                                                                               ||
==================================================================================================================================

			1.1.2.3 code


				1.1.2.3.1  callback to check peer cert.
:! ct diff -pred -diff runtime/infrastructure/cryptoLib/src/SSLInterface.h
139a140,142
>
>     // LDAP driven certificate spoofing check callback
>     typedef void (*tls_ldap_cert_check_cb_fn)(IN ISSLConnection* pSSLConnection, IN Crypto::TLS_NOTIFY nTlsNotify, IN void* param);
218a222
>         tls_ldap_cert_check_cb_fn       fnTlsLDAP_CertCheckCB;
341a346
>         virtual tls_ldap_cert_check_cb_fn       getTlsLDAP_CertCheckCB() const = 0;

:! ct diff -pred -diff runtime/infrastructure/cryptoLib/src/SSLContext.h
71a72
>         tls_ldap_cert_check_cb_fn       getTlsLDAP_CertCheckCB() const;
138a140
>         tls_ldap_cert_check_cb_fn                       m_fnTlsLDAP_CertCheckCB;


:! ct diff -pred -diff runtime/infrastructure/cryptoLib/src/SSLContext.cpp
1470a1471,1475
> tls_ldap_cert_check_cb_fn SSLContext::getTlsLDAP_CertCheckCB() const
> {
>     return m_fnTlsLDAP_CertCheckCB;
> }
>       
				1.1.2.3.2 Set callback in SSLContext::init
:! ct diff -pred -diff runtime/infrastructure/cryptoLib/src/SSLContext.cpp
643a644,654
>     if (pSSLInitParams->fnTlsLDAP_CertCheckCB==NULL )
>     {
>         g_pILog->logWarn(__FILE__,__LINE__, RESULT_INVALID_INPUT, "Crypto.SSLContext.init - LDAP server certificate check callback is no
t set");
>         return RESULT_INVALID_INPUT;
>     }
>     else // could just cont. w/o else but this way more robust (i.e. return removed)
>     {
>         g_pILog->logDebug(__FILE__,__LINE__, RESULT_INVALID_INPUT, "Crypto.SSLContext.init - LDAP server certificate check callback is s
et");
>         m_fnTlsLDAP_CertCheckCB = pSSLInitParams->fnTlsLDAP_CertCheckCB ;
>     }
>
1468a1480,1484
> }
>
> tls_ldap_cert_check_cb_fn SSLContext::getTlsLDAP_CertCheckCB() const
> {
>     return m_fnTlsLDAP_CertCheckCB;     

				1.1.2.3.3  Wire it to handshake server certificate validation callback
- Call callback from pSSL->x509ExceptionCallback
- Obtain the SSLConnection instance 
	-- Example:
// A static callback. Called from SSL.cpp when x509 certificate verification has an exception (e.g. crl verification failed)
void SSLConnection::_pvServerX509NotificationCB(const SSL *pSSLStruct, int x509Error, TLS_NOTIFY nTlsNotify)
{
    SSLConnection* pSSLConnection = (SSLConnection*)SSL_get_ex_data(pSSLStruct, s_ConnectionDataIndex);
    if (pSSLConnection!=NULL)
    {
        pSSLConnection->pvServerX509NotificationCB(x509Error, nTlsNotify);
    }
}

	--
- and from it call getContext() 
something like

    SSL* pSSL = (SSL*)X509_STORE_CTX_get_ex_data(pX509StoreCtx, SSL_get_ex_data_X509_STORE_CTX_idx());

    SSLConnection* pSSLConnection = (SSLConnection*)SSL_get_ex_data(pSSL, SSLConnection::s_SessionDataIndex);
    if (pSSLConnection!=NULL)
    {
	if (pSSLConnection->getContext()->getTlsLDAP_CertCheckCB())
	{
		(* (pSSLConnection->getContext() )) (pSSLConnection, TLS_NOTIFY_READ_CERTIFICATE_VERIFY, (void *) pSSL) ;
	}

code:
:! ct diff -pred -diff runtime/infrastructure/cryptoLib/src/SSL.cpp
1289a1290,1306
>
>         // Call LDAP certificate validation callback
>
>     g_pILog->logDebug(__FILE__, __LINE__, RESULT_OK, "CryptoLib.CSSL.x509ExceptionCallback - Attempting to call LDAP server certificate
validation callback");
>     SSLConnection* pSSLConnection = (SSLConnection*)SSL_get_ex_data(pSSL, SSL_get_ex_data_X509_STORE_CTX_idx());
>     if (pSSLConnection!=NULL)
>     {
>           if (pSSLConnection->getContext()->getTlsLDAP_CertCheckCB())
>           {
>             g_pILog->logDebug(__FILE__, __LINE__, RESULT_OK, "CryptoLib.CSSL.x509ExceptionCallback - calling LDAP server certificate val
idation callback");
>               ((* (pSSLConnection->getContext() )).getTlsLDAP_CertCheckCB()) (pSSLConnection, TLS_NOTIFY_READ_CERTIFICATE_VERIFY, (void
*) pSSL) ;
>           }
>     else
>         {
>             g_pILog->logWarn(__FILE__, __LINE__, RESULT_OK, "CryptoLib.CSSL.x509ExceptionCallback - calling LDAP server certificate vali
dation callback failed because no valid SSLConnection could be found");
>         }
>     }

				1.1.2.3.4 set LDAP callback
- Which classes are crypto aware?
[yizaq@yizaq-lnx:Thu Sep 27:/view/yizaq__yizaq_5_5_dev.int.acs5_0.lx/vob/nm_acs/acs/runtime/idstores/ldapIDStore/src]$ grep include *.h | grep -i cryptol
LdapSslContext.h:#include "CryptoLib.h"
A: 

- Add static callback

					1.1.2.3.4.1 Compare to how EAP connection related info is passed to callback (since LDAP CB requires the hostname which is per LDAPConnection )

- EAP setup for passing connection related info to callbacks
a. Interface, 
Crypto::ISSLConnection

- Interface defined:
Crypto::ISSLConnection

    // SSL connection class
    struct /* interface */ ISSLConnection
    {  
        virtual bool            isClientMode() const = 0 ;
        virtual bool            isServerMode() const = 0 ;

        virtual Result          getPeerCertificate(OUT ICertificate **ppCertificate) const = 0;
        virtual Result          setConnectionCertificate(IN unsigned char* pCertData, IN int nCertSize, 
                                                         IN const unsigned char* pKeyBLOB, IN int nKeyBLOBSize) = 0;

        virtual Result          getEAPTLSSessionKey(IN EAPTLSKeyPurpose keyPurpose, OUT unsigned char* pEncKey) = 0;
        virtual Result          getEAPFASTSessionKey(IN EAPTLSKeyPurpose keyPurpose, OUT unsigned char* pEncKey) = 0;
        virtual Result          getADHPMSCHAPChallenge(IN ADHPMSCHAPChallengeType chType, OUT unsigned char* pChallenge) = 0;

        virtual Result          deriveSessionKeySeed() = 0;
        virtual Result          calculateNextInnerMethodCompoundKey_EAP_FAST(IN const unsigned char* pInnerSessionKey) = 0;
        virtual Result          calculateNextInnerMethodCompoundKey_PEAP(IN const unsigned char* pInnerSessionKey) = 0;
        virtual Result          calculateCompoundMAC(IN const unsigned char* pInBuffer, OUT int nInBufferSize, 
                                                     OUT unsigned char* pCompoundMAC) const = 0;
        virtual Result          setClientHelloExtension(IN unsigned char* pExtData, IN int nExtDataSize, IN char *szCipherSuites) = 0;
        virtual void            setConnectionUserData (IN void* pData ) = 0;
        virtual void*           getConnectionUserData () = 0;

        // Connection configuration
        virtual Result          setTLSRenegotiationEnabling( IN bool bIsAllowTLSRenegotiation ) = 0;
        
        // SSL connection processing function prototypes
        // -------------------------------------------------------------------------------

        virtual Result          processData(IN unsigned char *pInData, IN int nInDataSize,
                                            OUT unsigned char *pOutData, INOUT int *pnOutDataSize) = 0;
        virtual Result          readData   (IN unsigned char *pInData, IN int nInDataSize,
                                            OUT unsigned char *pOutData, INOUT int *pnOutDataSize, 
                                            OUT bool *pbMore=NULL) = 0;
        virtual Result          writeData  (IN unsigned char *pInData, IN int nInDataSize,
                                            OUT unsigned char *pOutData, INOUT int *pnOutDataSize) = 0;

        // This code is Obsolete - old style interface to stay compatible with EAP old behavior
        virtual Result OBSOLETE processData(INOUT unsigned char **pInOutData, INOUT int *pnInOutDataSize) = 0;
        virtual Result OBSOLETE readData   (INOUT unsigned char **pInOutData, INOUT int *pnInOutDataSize) = 0;
        virtual Result OBSOLETE writeData  (INOUT unsigned char **pInOutData, INOUT int *pnInOutDataSize) = 0;

        // connection session id management
        virtual bool            isSessionReused() = 0;
        virtual Result          removeSessionIDFromCache() const = 0;
        virtual Result          addSessionIDToCache() const = 0;
        virtual Result          setSessionExData(IN ISSLSessionExData* pExData) const = 0;
        virtual ISSLSessionExData* getSessionExData() const = 0;

        virtual Result          logSession() const = 0;

        //  client side session management
        virtual SSL*            getSSL() = 0;
        virtual SSL_SESSION*    getSSL_SESSION(IN bool bIncrementRefCount=false) = 0 ;
        virtual Result          setSSL_SESSION(IN SSL_SESSION *pSSL_SESSION) = 0 ;

        // EAPFAST/PAC-related functionality
        // -------------------------------------------------------------------------------
        virtual bool            isPACProvisioningRequired() const = 0;
        virtual bool            isAuthenticatedHandshake() const = 0;

        virtual unsigned char*  getPACOpaqueHash() = 0;
        virtual Result          tlsRenegotiate(OUT unsigned char** pOutData, OUT int* pOutDataSize) = 0;
        virtual Result          setEAPFASTProvisioningMode(IN EAPFASTProvisioningMode mode) = 0;

        // EAPFAST/PAC functions for debugging purposes only
        virtual unsigned char*  getSessionKeySeed() = 0;
        virtual unsigned char*  getSIMCKn(IN int nNumber) = 0;
        virtual const unsigned char* getTLSKeyBlock() = 0;
        virtual unsigned char*  getDHPrivateKey() = 0;
        virtual unsigned char*  getDHPublicKey() = 0;

        virtual const unsigned char*    getMasterSecret() const = 0;
        virtual Result          setMasterSecret(IN const unsigned char* secret, IN int len) = 0;

        virtual void            removeSession() = 0;

        virtual const ISSLContext*      getContext() const = 0;

        virtual bool            getRequireProvisioning() const = 0;
        virtual void            setRequireProvisioning(IN bool requireProvisioning) = 0;

        virtual int             getPACType() const = 0;
        virtual void            setPACType(IN int pacType) = 0;

        // Connection state and errors

        virtual void            setConnectionState(IN SSLState state) = 0;
        virtual SSLState        getConnectionState() const = 0;

        virtual int             getLastSSLError() const = 0;
        virtual char*           getLastSSLErrorMessage() = 0;
        virtual Result          getLastVerboseSSLError( OUT int *pnOpenSSLError,
                                                        OUT int *pnOpenSSLAlertCode,
                                                        OUT int *pnOpenSSLVerifyResult,
                                                        OUT AlertDirection *pAlertDirection ) = 0 ;

        virtual AlertDirection  getLastSSLAlertDirection() const = 0;

        virtual void            setLastExError(IN Result err) = 0;
        virtual Result          getLastExError() const = 0;
        // virtual char*           getLastExErrorMessage() = 0;

        virtual Result          resetForEAPFAST( IN CipherSuiteForRecreatedEAPFAST cipherEnum ) =0 ;

        virtual Result          regenerateServerRandom() = 0 ;
        virtual Result          setServerRandom(IN unsigned char *pRandomBuffer, IN int randomBufferSize) = 0 ;
        virtual Result          getServerRandom(OUT unsigned char *pRandomBuffer, INOUT int *pRandomBufferSize) const = 0 ;
        virtual Result          getClientRandom(OUT unsigned char *pRandomBuffer, INOUT int *pRandomBufferSize) const = 0;
        virtual Result          setVerifyPeer(IN bool bVerify) = 0;

        //  virtual void            setTicketExtensionFlag(IN bool bFlag) = 0;
        //  virtual bool            getTicketExtensionFlag() = 0;



        protected:
        virtual ~ISSLConnection(){} ;
    };

- notice 
        virtual void            setConnectionUserData (IN void* pData ) = 0;
        virtual void*           getConnectionUserData () = 0;
They are used to pass higher level (EAP, LDAP etc) connection instance

- Important note:
SSLConnection extends the interface

b. EAP example of setting concrete ISSLConnection
- runtime/flow/eap/src/EapTlsProtocol.h member:
    Crypto::ISSLConnection*                 m_pSSLConnection;
EapFastProtocol -> EapTlsProtocol so has the member as well

- Set connection EapFastProtocol::onCreateConnection(Context *pContext):
    m_pSSLConnection = pSSLContextEapFast->createConnection();
    if (m_pSSLConnection==NULL )
    {
        EAPLOG(__FILE__, __LINE__, AcsDebugLogAAA::ERR, pContext, 
               "onCreateConnection: Failed to create ISSLConnection" );
        return false;
    }

    m_pSSLConnection->setConnectionUserData(this);

- 
c. retrieve the connection for using it (this scheme dictates that the callback will need it)
- ex:
/* static */ int EapFastProtocol::sessionTicketExtensionCB(SSL* ssl, 
    Crypto::ISSLConnection* pSSLConnection = (Crypto::ISSLConnection*)arg;
    EapFastProtocol* pEapFastProtocol = (EapFastProtocol*)pSSLConnection->getConnectionUserData();

void EapTlsProtocol::tlsNotifyCB(Crypto::ISSLConnection* pSSLConnection, Crypto::TLS_NOTIFY nTlsNotify, void* param)

Note, here the callback requires EapTlsProtocol protocol object, not connection

-
d. Putting it all together, executing the callback
- ex:
void SSLConnection::tlsNotifyLog(const SSL* m_pSSL, int nWhere, int nRet)
    if ( m_pISSLContext->getTlsNotifyCB() )
    {
        if ( nTlsNotify != TLS_NOTIFY_UNKNOWN )
        {
            (*m_pISSLContext->getTlsNotifyCB())(this, nTlsNotify, (void*)m_pSSL);
        }

-
e. 
					1.1.2.3.4.2 Verify LDAP callback is wired so that connection info (for hostname) is passed
a. Where is ISSLConnection?
       LdapSslConnection
            ^
            |
            |           |--- m_pSSLConnection-
LdapSslConnectionContext|
                        |--- m_sslContext 


b. set LDAP connection context on SSLConnection
in LdapSslConnectionContext::initSslSession()
{
    m_pSslConnection = m_sslContext.createConnection(m_hSocket);

    if(m_pSslConnection)
    {
        m_pSslConnection->setTLSRenegotiationEnabling(true) ;

        m_log.log_msg(__FILE__, __LINE__, AcsDebugLog::INFO, "LdapSslConnectionContext::initSslSession: setting connection context on SSLConnection");
        m_pSslConnection->setConnectionUserData(this);
    }    
    
    return (m_pSslConnection ? LdapOK : LdapUnexpected);
}

This won't work since we actualy need the initialized instance of ConfigLDAPConnectionAdapter (member of LdapServerConfig). It holds the required hostname

conveniently both it and the LdapSslContext are initialized in LdapServerConfig CTOR.
so, need to:
-- add ConfigLDAPConnectionAdapter member +get/set to LdapSslContext. Set in LdapServerConfig CTOR and get in LdapSslConnectionContext::initSslSession
for passing to SSLConnection
	--- getters:
const ConfigLDAPConnectionAdapter  & LdapSslConnectionContext::getConfigLDAPConnectionAdapter() 
{
    return m_cfg_adapter;
}

void LdapSslConnectionContext::setConfigLDAPConnectionAdapter(const ConfigLDAPConnectionAdapter & adapter  )
{
    m_cfg_adapter = adapter;
}

	--- set
LdapServerConfig::LdapServerConfig(VersionID                  nVersionID,
		...
    // init ssl if configured
    if (m_connection.enableSecureConnection())
    {
	    ...
        m_pSslContext->setConfigLDAPConnectionAdapter(m_connection);

	--- get
void LdapSslContext::tlsLDAP_Cert_Check_CB(Crypto::ISSLConnection* pSSLConnection, Crypto::TLS_NOTIFY nTlsNotify, void* param)
{
	AcsDebugLog TempLogger ("Acs.RT.idstores.LDAP.SSLContext.tlsLDAP_Cert_Check_CB");
    //TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Checking server certificate validity against the configured host name: %s", m_hostname.c_str() );

    if ( pSSLConnection )
    {
       LdapSslConnectionContext * pLSCC = (LdapSslConnectionContext *) pSSLConnection->getConnectionUserData(); 
       string s_hostname = pLSCC->getConfigLDAPConnectionAdapter().hostName();

--
c. executing the callback
CSSL::x509ExceptionCallback() -> 
...
        // Call LDAP certificate validation callback

    g_pILog->logDebug(__FILE__, __LINE__, RESULT_OK, "CryptoLib.CSSL.x509ExceptionCallback - Attempting to call LDAP server certificate validation callback");
    SSLConnection* pSSLConnection = (SSLConnection*)SSL_get_ex_data(pSSL, SSL_get_ex_data_X509_STORE_CTX_idx());
    if (pSSLConnection!=NULL)
    {
	    if (pSSLConnection->getContext()->getTlsLDAP_CertCheckCB())
	    {
            g_pILog->logDebug(__FILE__, __LINE__, RESULT_OK, "CryptoLib.CSSL.x509ExceptionCallback - calling LDAP server certificate validation callback");
	    	((* (pSSLConnection->getContext() )).getTlsLDAP_CertCheckCB()) (pSSLConnection, TLS_NOTIFY_READ_CERTIFICATE_VERIFY, (void *) pSSL) ;
	    }
    else
        {
            g_pILog->logWarn(__FILE__, __LINE__, RESULT_OK, "CryptoLib.CSSL.x509ExceptionCallback - calling LDAP server certificate validation callback failed because no valid SSLConnection could be found");
        }
    }

					1.1.2.3.4.3
				1.1.2.3.5 Adapt callback API to make sure required SSL objects are reachable 
- server certificate is available on SSLConnection:
Result SSLConnection::getPeerCertificate(OUT ICertificate **ppCertificate) const
{
    Crypto::Result  rc= RESULT_OK;
    Crypto::ICertificate *pCertificate = NULL ;

    g_pManager->waitOperational() ;

    X509* pX509 = SSL_get_peer_certificate(m_pSSL);
    if (pX509 == NULL)
    {
        g_pILog->logDebug(__FILE__,__LINE__, RESULT_NO_PEER_CERTIFICATE,
                          "Crypto.SSLConnection.getPeerCertificate - Peer sent no certificate");
        
        return RESULT_NO_PEER_CERTIFICATE;
    }
    
    rc = Crypto::getCertificateManagerInterface()->createCertificate( &pCertificate, pX509 ) ;    

    X509_free(pX509);

    if ( rc != Crypto::RESULT_OK )
    {
        return rc ;
    }

    // all is ok

    *ppCertificate = pCertificate ;

    return RESULT_OK;
}


- usage example
bool EapTlsProtocol::handleUserCertificate(Context* ctx, bool bSaveInCache)
	...
	Crypto::ICertificate* pCertificate = 0;
...
	// get peer certificate
	rc = m_pSSLConnection->getPeerCertificate(&pCertificate);
	if (rc != Crypto::RESULT_OK) 
    {
		EAPLOG(__FILE__, __LINE__, AcsDebugLogAAA::VERBOSE, ctx, 
            "EAP-TLS: Error getting peer certificate from SSL Connection; rc=%d", rc);

		return false;
	}

	// get peer certificate blob
    size_t certSize = 10240;
    byte_t certBlob[certSize];

	rc = pCertificate->getCertificateBlob(certBlob, &certSize, Crypto::ENCODING_DER);
	if (rc == Crypto::RESULT_OK) 
    {
        if (bSaveInCache)
        {
            // save user certificate in cache for subsequent session resume
            pSessionExtData = new EapTlsSSLSessionExData();
            pSessionExtData->m_pPeerCertificate = new CertificateBlob(certBlob, certSize);
            
            //  we need decrease reference count because 'operator=' increase it
            pSessionExtData->m_pPeerCertificate->release();
            
            // populate the context with the relevant fields from the peer certificate
            setPeerCertificateOnContext(ctx, pCertificate, pSessionExtData->m_pPeerCertificate.get());

            // cache peer certificate on SSL session	
            rc = m_pSSLConnection->setSessionExData(pSessionExtData);
            if (rc == Crypto::RESULT_OK) 
            {
                EAPLOG(__FILE__, __LINE__, AcsDebugLogAAA::VERBOSE, ctx, 
                    "EAP-TLS: Cache peer certificate");
            }
            else
            {
                EAPLOG(__FILE__, __LINE__, AcsDebugLogAAA::WARN, ctx, 
                    "EAP-TLS: Failed to cache peer certificate");	
            }
        }
        else
        {
            // don't save user certificate in cache, just fill all its fields to the context
            CertificateBlob* pCertBlob = new CertificateBlob(certBlob, certSize);
            setPeerCertificateOnContext(ctx, pCertificate, pCertBlob);
            pCertBlob->release();
        }
    }
    else
	{
    	// populate the context with the relevant fields from the peer certificate
	    setPeerCertificateOnContext(ctx, pCertificate, 0);

		EAPLOG(__FILE__, __LINE__, AcsDebugLogAAA::VERBOSE, ctx, 
            "EAP-TLS: Unable to retrieve Binary of peer certificate");

        return false;
    }


- Certificate functions
runtime/infrastructure/cryptoLib/src/SSLInterface.h
    // X.509 Certificate
    struct /* interface */ ICertificate
    {  
        virtual Result extendExpirationTime(IN unsigned long nNewTTLSec) = 0;

        // Read a private-key using password from from file 
        virtual Result  validateAndAttachPrivateKey(IN const char    *pPrivateKeyFileName,
                                                    IN const char    *szPrivateKeyPassword) = 0;
        // Read a private-key using password from from memory 
        virtual Result  validateAndAttachPrivateKey(IN const void    *pPrivateKeyBlob,
                                                    IN const size_t  nPrivateKeyBlobSize,
                                                    IN const char    *szPrivateKeyPassword) = 0;

        // Verify if signer 
        virtual Result checkSigner( IN ICertificate *pSignCertificate, OUT int *pnComparisonResult ) = 0 ;

        // Verify signer and signature
        virtual Result checkSignerAndSignature( IN ICertificate *pSignCertificate, OUT bool *pbMatch ) = 0 ;

        // Get the OpenSSL internal object
        virtual void    *getX509() const = 0 ;
        virtual void    *getPVK() const = 0 ;

        // Export Certificate, private-key encrypted with the supplied private-key-password
        virtual Result  getCertificateBlob( OUT void* pBlob, 
                                            INOUT size_t *pnBlobSize, 
                                            IN EncodingType encodingType=ENCODING_PEM ) const = 0;
        virtual Result  getPrivateKeyBlob ( OUT void *pBlob, 
                                            INOUT size_t *pnBlobSize, 
                                            IN const char *szPrivateKeyPassword, 
                                            IN EncodingType encodingType=ENCODING_PEM ) const = 0 ;
        virtual Result  getRequestBlob    ( OUT void* pBlob, 
                                            INOUT size_t *pnBlobSize, 
                                            IN EncodingType encodingType=ENCODING_PEM ) const = 0 ;
        virtual Result  getPKCS12Blob (     OUT void *pBlob, 
                                            INOUT size_t *pnBlobSize, 
                                            IN const char *szPassword, 
                                            IN ICertificate **ppTempChainCertificates,
                                            IN EncodingType encodingType=ENCODING_PEM ) const = 0 ;

        // Extract certificate attributes
        virtual Result  getSerialNumber         ( OUT unsigned char* pResult, INOUT size_t* pnResultSize ) const = 0;

        // Extract Subject Attributes
        virtual Result  getSubject              ( OUT char* pResult, INOUT size_t* pnResultSize ) const = 0;
        virtual Result  getIssuer               ( OUT char* pResult, INOUT size_t* pnResultSize ) const = 0;    
        virtual Result  getSubjectCN            ( OUT char* pResult, INOUT size_t* pnResultSize ) const = 0;
        virtual Result  getSubjectSerialNumber  ( OUT char* pResult, INOUT size_t* pnResultSize ) const = 0;

        // For SAN, ACS would return the first known name as the SAN.
        virtual Result  getSAN                  ( OUT char* pResult, INOUT size_t* pnResultSize, 
                                                  OUT TypesOfSAN *pType, 
                                                  IN bool bGetLast=false,
                                                  IN TypesOfSAN requestedTypeOfSAN=SAN_TYPE_ANY ) const = 0;

        virtual Result  getSubjectO             ( OUT char* pResult, INOUT size_t* pnResultSize ) const = 0;
        virtual Result  getSubjectOU            ( OUT char* pResult, INOUT size_t* pnResultSize ) const = 0;
        virtual Result  getSubjectL             ( OUT char* pResult, INOUT size_t* pnResultSize ) const = 0;
        virtual Result  getSubjectC             ( OUT char* pResult, INOUT size_t* pnResultSize ) const = 0;
        virtual Result  getSubjectST            ( OUT char* pResult, INOUT size_t* pnResultSize ) const = 0;
        virtual Result  getSubjectEmailAddress  ( OUT char* pResult, INOUT size_t* pnResultSize ) const = 0;

        protected:
        virtual ~ICertificate(){} ;
    };

- Note getSAN & getSubjectCN 
Result  Certificate::getSAN( OUT char* pResult, INOUT size_t* pnResultSize, 
                             OUT TypesOfSAN *pType, 
                             IN bool bGetLast, IN TypesOfSAN requestedTypeOfSAN ) const 

					1.1.2.3.5.1 modify getSAN. return a vector of struct {TypesOfSAN pType, string sResult} for types IP and DNS

typedef struct GENERAL_NAME_st {

#define GEN_OTHERNAME	0
#define GEN_EMAIL	1
#define GEN_DNS		2
#define GEN_X400	3
#define GEN_DIRNAME	4
#define GEN_EDIPARTY	5
#define GEN_URI		6
#define GEN_IPADD	7
#define GEN_RID		8

int type;
union {
	char *ptr;
	OTHERNAME *otherName; /* otherName */
	ASN1_IA5STRING *rfc822Name;
	ASN1_IA5STRING *dNSName;
	ASN1_TYPE *x400Address;
	X509_NAME *directoryName;
	EDIPARTYNAME *ediPartyName;
	ASN1_IA5STRING *uniformResourceIdentifier;
	ASN1_OCTET_STRING *iPAddress;
	ASN1_OBJECT *registeredID;

	/* Old names */
	ASN1_OCTET_STRING *ip; /* iPAddress */
	X509_NAME *dirn;		/* dirn */
	ASN1_IA5STRING *ia5;/* rfc822Name, dNSName, uniformResourceIdentifier */
	ASN1_OBJECT *rid; /* registeredID */
	ASN1_TYPE *other; /* x400Address */
} d;
} GENERAL_NAME;

typedef STACK_OF(GENERAL_NAME) GENERAL_NAMES;


				1.1.2.3.6 Code review recent changes


Generating code review information
Make sure you're in corresponding stream and view and set to the activity you'd like reviewed



==================================================================================================================================
||        Code Review Information. Optimized for Linux View                                                                     ||
==================================================================================================================================
||        Stream yizaq_5_5_dev.int.acs5_0                                                                                       ||
==================================================================================================================================
||        View yizaq__yizaq_5_5_dev.int.acs5_0.lx                                                                               ||
==================================================================================================================================
||        Activity yizaq_CSCtw87143_LDAP_Spoofing                                                                               ||
==================================================================================================================================
||        Files:                                                                                                                ||
||        /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapServerConfig.cpp                                                 ||
||        /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslConnectionContext.cpp                                         ||
||        /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslConnectionContext.h                                           ||
||        /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslContext.cpp                                                   ||
||        /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslContext.h                                                     ||
||        /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/Certificate.cpp                                                  ||
||        /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/Certificate.h                                                    ||
||        /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSLContext.cpp                                                   ||
||        /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSLContext.h                                                     ||
||        /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSL.cpp                                                          ||
||        /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSLInterface.h                                                   ||
==================================================================================================================================
Diff of recent activity:
----------------------------------------------------------------------------------------------------
Usage: ct_diff_act_txt <act>, ex: Phase2Bugs2 will search on vob @/vob/nmtgre_proj
Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapServerConfig.cpp
68c68
<         m_pSslContext = new LdapSslContext (); 
---
>         m_pSslContext = new LdapSslContext; 
71d70
<         m_pSslContext->setConnectionConfig(m_connection);
Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslConnectionContext.cpp
42,44d41
< 
<         m_log.log_msg(__FILE__, __LINE__, AcsDebugLog::INFO, "LdapSslConnectionContext::initSslSession: setting connection context on SSLConnection");
<         m_pSslConnection->setConnectionUserData((void *) &m_sslContext);
260,261d256
< 
< 
Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslConnectionContext.h
67d66
< 
Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslContext.cpp
Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslContext.h
8d7
< #include <string>
12d10
< #include "LdapDefinitions.h"
17d14
< using namespace std;
46,64d42
< 
<     /*
<      *--------------------------------------------------------------------------------------
<      *       Class:  LdapSslContext
<      *      Method:  LdapSslContext :: getConnectionConfig
<      * Description:  return ConfigLDAPConnectionAdapter member
<      *--------------------------------------------------------------------------------------
<      */
<      const ConfigLDAPConnectionAdapter & getConnectionConfig() const;
< 
<     /*
<      *--------------------------------------------------------------------------------------
<      *       Class:  LdapSslContext
<      *      Method:  LdapSslContext :: setConnectionConfig
<      * Description:  return ConfigLDAPConnectionAdapter member
<      *--------------------------------------------------------------------------------------
<      */
<      void setConnectionConfig(ConfigLDAPConnectionAdapter & cfg);
< 
83,90d60
<     /* 
<      * ===  FUNCTION  ======================================================================
<      *         Name:   tlsLDAP_Cert_Check_CB
<      *  Description:   LDAP certificate spoofing check callback
<      * =====================================================================================
<      */
<     static int tlsLDAP_Cert_Check_CB(Crypto::ISSLConnection* pSSLConnection, Crypto::TLS_NOTIFY nTlsNotify, void* param );
< 
93,94d62
<     ConfigLDAPConnectionAdapter m_ConfigConnection;
< 
Diff of file /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/Certificate.cpp
Diff of file /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/Certificate.h
Diff of file /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSLContext.cpp
Diff of file /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSLContext.h
Diff of file /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSL.cpp
Diff of file /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSLInterface.h
----------------------------------------------------------------------------------------------------
Diff of full activity (changes from baseline):
Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapServerConfig.cpp
68c68
<         m_pSslContext = new LdapSslContext (); 
---
>         m_pSslContext = new LdapSslContext; 
71d70
<         m_pSslContext->setConnectionConfig(m_connection);

Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslConnectionContext.cpp
42,44d41
< 
<         m_log.log_msg(__FILE__, __LINE__, AcsDebugLog::INFO, "LdapSslConnectionContext::initSslSession: setting connection context on SSLConnection");
<         m_pSslConnection->setConnectionUserData((void *) &m_sslContext);
260,261d256
< 
< 

Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslConnectionContext.h
67d66
< 

Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslContext.cpp

Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslContext.h
8d7
< #include <string>
12d10
< #include "LdapDefinitions.h"
17d14
< using namespace std;
46,64d42
< 
<     /*
<      *--------------------------------------------------------------------------------------
<      *       Class:  LdapSslContext
<      *      Method:  LdapSslContext :: getConnectionConfig
<      * Description:  return ConfigLDAPConnectionAdapter member
<      *--------------------------------------------------------------------------------------
<      */
<      const ConfigLDAPConnectionAdapter & getConnectionConfig() const;
< 
<     /*
<      *--------------------------------------------------------------------------------------
<      *       Class:  LdapSslContext
<      *      Method:  LdapSslContext :: setConnectionConfig
<      * Description:  return ConfigLDAPConnectionAdapter member
<      *--------------------------------------------------------------------------------------
<      */
<      void setConnectionConfig(ConfigLDAPConnectionAdapter & cfg);
< 
83,90d60
<     /* 
<      * ===  FUNCTION  ======================================================================
<      *         Name:   tlsLDAP_Cert_Check_CB
<      *  Description:   LDAP certificate spoofing check callback
<      * =====================================================================================
<      */
<     static int tlsLDAP_Cert_Check_CB(Crypto::ISSLConnection* pSSLConnection, Crypto::TLS_NOTIFY nTlsNotify, void* param );
< 
93,94d62
<     ConfigLDAPConnectionAdapter m_ConfigConnection;
< 

Diff of file /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/Certificate.cpp

Diff of file /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/Certificate.h

Diff of file /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSLContext.cpp

Diff of file /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSLContext.h

Diff of file /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSL.cpp

Diff of file /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSLInterface.h

----------------------------------------------------------------------------------------------------
==================================================================================================================================
				1.1.2.3.7 Implement server certificate checks

				1.1.2.3.8
			1.1.2.4 SSL_CTX_set_cert_verify_callback() approach

				1.1.2.4.1 background 

					1.1.2.4.1.1 http://stackoverflow.com/questions/2729254/ssl-ctx-set-cert-verify-callback-vs-ssl-ctx-set-verify 

Can anyone tell me what is the difference between SSL_CTX_set_cert_verify_callback and SSL_CTX_set_verify? From OpenSSL docs:

    SSL_CTX_set_cert_verify_callback() sets the verification callback function for ctx. SSL objects that are created from ctx inherit the setting valid at the time when SSL_new(3) is called.

and:

    SSL_CTX_set_verify() sets the verification flags for ctx to be mode and specifies the verify_callback function to be used. If no callback function shall be specified, the NULL pointer can be used for verify_callback.

So I'm trying to understand which callback to send for each one (from client side).

Thanks experts.

----------------------------------------------------------------------------------------------------
SSL_CTX_set_cert_verify_callback() means you're specifying a function to do the entire validation process (walking the certificate chain validating each cert in turn). [ you probably don't want to be doing this, per the warning below ]

SSL_CTX_set_verify(), on the other hand, specifies a function that's called when the default validator checks each certificate, with preverify_ok set to 0 or 1 to indicate if verification of the certificate in question worked.

From the doc for SSL_CTX_set_cert_verify_callback()

    WARNINGS

    Do not mix the verification callback described in this function with the verify_callback function called during the verification process. The latter is set using the SSL_CTX_set_verify(3) family of functions.

    Providing a complete verification procedure including certificate purpose settings etc is a complex task. The built-in procedure is quite powerful and in most cases it should be sufficient to modify its behaviour using the verify_callback function.


----------------------------------------------------------------------------------------------------
SSL_CTX_set_verify() is called only when the default validator discovers that a particular cert has failed to validate? So it willbe called only when something is not OK with the certificate? – BreakPoint Apr 28 '10 at 12:35
	
See my answer. It will be called for client cert regardless validation result. OpenSSL passes the result to the callback in preverify_ok argument. – ZZ Coder Apr 28 '10 at 12:46
----------------------------------------------------------------------------------------------------

					1.1.2.4.1.2 SSL_CTX_set_verify issue 

						1.1.2.4.1.2.1 SSL_CTX_set_verify issue  
I am using SSL_CTX_set_verify() function to set my static C callback verify function. During HTTPS transaction, my callback is also getting called with first parameter 0 or 1 (depending upon of the certificate verification is success or failure). But even if my certification verification is failure I want to continue. So I have hard coded  return value as 1 always from my callback function. But still I see the certification error and I don't get the page. Any suggestion please? 

----------------------------------------------------------------------------------------------------
You might want to try

X509_STORE_CTX_set_error(ctx, X509_V_OK) ; 
						1.1.2.4.1.2.2 http://etutorials.org/Programming/secure+programming/Chapter+10.+Public+Key+Infrastructure/10.7+Verifying+an+SSL+Peer+s+Certificate/

|10.7 Verifying an SSL Peer's Certificate
|10.7.1 Problem

You are using OpenSSL to support SSL-enabled communication between a client and a server. You want to instruct OpenSSL to verify the certificate received from the peer.
|10.7.2 Solution

Every SSL connection has an SSL object, which in turn has an SSL_CTX object, and that object, in turn, has an X509_STORE object. OpenSSL uses the X509_STORE object as a container for any certificates and CRLs required to verify another certificate. OpenSSL creates an X509_STORE_CTX object and calls X509_verify_cert( ) for you, but not by default.

OpenSSL's default behavior is to not verify peer certificates, which is the worst default behavior that any SSL implementation could possibly provide. By not verifying certificates in an SSL connection, the strength of the security provided by SSL is severely reduced, to the point where the two parties in the conversation might as well be using nothing more than a symmetric cipher with keys exchanged in the clear. Without verifying certificates, you will have security against passive eavesdroppers, but that is all. With a small amount of effort, anyone could hijack the TCP connection before the SSL session is established and act as a man-in-the-middle.
10.7.3 Discussion

To have OpenSSL verify a peer's certificate, you must issue a call to SSL_CTX_set_verify( ). SSL_CTX_set_verify( ) accepts a bitmask of flags that tell OpenSSL how to deal with certificates. Depending on whether the SSL_CTX object is being used as a client or as a server, the meanings of the flags are somewhat different:

SSL_VERIFY_NONE

    When the SSL_CTX object is being used in server mode, no request for a certificate is sent to the client, and the client should not send a certificate.

    When the SSL_CTX object is being used in client mode, any certificate received from the server will be verified, but failure will not terminate the handshake.

    This flag should never be combined with any of the others, and it should normally be used only in server mode (if it is ever used at all). When operating in client mode, you should always be verifying the server's certificate. When operating in server mode, you may not have any use for a client certificate, and requesting one may cause confusion for users. For example, if an SSL-enabled web site requests a certificate from a client, the user's browser may ask the user for a certificate to send to the server.
SSL_VERIFY_PEER

    When the SSL_CTX object is being used in server mode, a request for a certificate will be sent to the client. The client may opt to ignore the request, but if a certificate is sent back, it will be verified. If the verification fails, the handshake will be terminated immediately.

When the SSL_CTX object is being used in client mode, if the server sends a certificate, it will be verified. If the verification fails, the handshake will be terminated immediately. The only time that a server would not send a certificate is when an anonymous cipher is in use. Anonymous ciphers are disabled by default. Any other flags combined with this one in client mode are ignored.

SSL_VERIFY_FAIL_IF_NO_PEER_CERT

    If the SSL_CTX object is not being used in server mode or if SSL_VERIFY_PEER is not set, this flag is ignored. Use of this flag will cause the handshake to terminate immediately if the client provides no certificate.
SSL_VERIFY_CLIENT_ONCE

    If the SSL_CTX object is not being used in server mode, or if SSL_VERIFY_PEER is not set, this flag is ignored. Use of this flag will prevent the server from requesting a certificate from the client in the case of a renegotiation. A certificate will still be requested during the initial handshake.

Using this knowledge of SSL_CTX_set_verify( ) and the code from Recipe 10.5, we'll build a new function, spc_create_sslctx( ), that will create an SSL_CTX object and initialize it with secure settings. In addition to calling SSL_CTX_set_verify( ), we'll disable the SSLv2 protocol, leaving only SSLv3 and TLSv1 enabled. We want to disable SSLv2 because it is well known to be insecure. It was the first publicly released version of the protocol and was not designed or adequately reviewed by security experts before its deployment. SSLv3 was designed and reviewed by security experts, and it corrects all of the known problems in SSLv2. Finally, we'll call SSL_CTX_set_cipher_list( ) to ensure that only secure ciphers will be used.

Before we can build spc_create_sslctx( ), we need to extend and complete the implementation of the spc_x509store_t object introduced in Recipe 10.5. Some additional flags are necessary for spc_create_sslctx( ), so we'll define those first:

SPC_X509STORE_USE_CERTIFICATE

    If this flag is set, an SSL_CTX created by spc_create_sslctx( ) will be loaded with a private key and certificates to be sent to the peer if they're requested. This should always be set for a server context, but it may also be set for a client context.
SPC_X509STORE_SSL_VERIFY_NONE

    This flag corresponds to OpenSSL's SSL_VERIFY_NONE flag and is used to construct the flags that are passed in the call to SSL_CTX_set_verify( ) by spc_create_sslctx( ).
SPC_X509STORE_SSL_VERIFY_PEER

    This flag corresponds to OpenSSL's SSL_VERIFY_PEER flag and is used to construct the flags that are passed in the call to SSL_CTX_set_verify( ) by spc_create_sslctx( ).
SPC_X509STORE_SSL_VERIFY_FAIL_IF_NO_PEER_CERT

    This flag corresponds to OpenSSL's SSL_VERIFY_FAIL_IF_NO_PEER_CERT flag and is used to construct the flags that are passed in the call to SSL_CTX_set_verify( ) by spc_create_sslctx( ).
SPC_X509STORE_SSL_VERIFY_CLIENT_ONCE

    This flag corresponds to OpenSSL's SSL_VERIFY_CLIENT_ONCE flag and is used to construct the flags that are passed in the call to SSL_CTX_set_verify( ) by spc_create_sslctx( ).
SPC_X509STORE_SSL_VERIFY_MASK

    This is simply a combination of all the SSL verification flags that is intended for internal use only.

We will also need an additional set of functions to add certificate and key information into the context for presenting to a peer when it is requested. The information will be used by spc_create_sslctx( ) when creating an SSL_CTX object, but only if SPC_X509STORE_USE_CERTIFICATE is set in the spc_x509store_t's flags.

void spc_x509store_setusecertfile(spc_x509store_t *spc_store, char *file) {
  if (spc_store->use_certfile) free(spc_store->use_certfile);
  spc_store->use_certfile = (file ? strdup(file) : 0);
}
   
void spc_x509store_addusecert(spc_x509store_t *spc_store, X509 *cert) {
  sk_X509_push(spc_store->certs, cert);
}
   
void spc_x509store_setusekeyfile(spc_x509store_t *spc_store, char *file) {
  if (spc_store->use_keyfile) free(spc_store->use_keyfile);
  spc_store->use_keyfile = (file ? strdup(file) : 0);
}
   
void spc_x509store_setusekey(spc_x509store_t *spc_store, EVP_PKEY *key) {
  if (spc_store->use_key) EVP_PKEY_free(key);
  spc_store->use_key = key;
  CRYPTO_add(&(key->references), 1, CRYPTO_LOCK_EVP_PKEY);
}

Both the certificates and the keys can be specified either as a file from which to load the information, or as preexisting OpenSSL objects of the appropriate type (X509 objects for certificates, and EVP_PKEY objects for keys). If a filename is specified, it will take precedence over a preexisting OpenSSL object. If a preexisting key object is used, it is the caller's responsibility to free it using EVP_PKEY_free( ) at any point after it is added into the spc_x509store_t object because it is reference counted, and spc_x509store_setusekey( ) increments its reference count.

When specifying the certificates to be sent to a peer (whether the peer will be a server or a client), multiple certificates may be specified. The first certificate specified should always be the certificate belonging to your program. Any additional certificates should be certificates in the chain that may be needed to verify the validity of your own certificate. This is true whether the certificates are loaded from a file and specified via spc_x509store_setusecertfile( ), or are added to the spc_x509store_t one at a time using spc_x509store_addusecert( ). Note also that the certificates and the required private key may be contained within the same file. For both certificate and key files, PEM format should be used, because the alternative binary ASN.1 format (also known as DER) does not allow multiple objects to be present in the same file.

At this point, spc_create_sslctx( ) has everything it needs. It takes a single argument?the spc_x509store_t object?to get its information from, and it returns a new SSL_CTX object that can be used to establish SSL-enabled connections.

#include <openssl/ssl.h>

#define SPC_X509STORE_USE_CERTIFICATE                 0x04
#define SPC_X509STORE_SSL_VERIFY_NONE                 0x10
#define SPC_X509STORE_SSL_VERIFY_PEER                 0x20
#define SPC_X509STORE_SSL_VERIFY_FAIL_IF_NO_PEER_CERT 0x40
#define SPC_X509STORE_SSL_VERIFY_CLIENT_ONCE          0x80
#define SPC_X509STORE_SSL_VERIFY_MASK                 0xF0
   
SSL_CTX *spc_create_sslctx(spc_x509store_t *spc_store) {
  int                       i, verify_flags = 0;
  SSL_CTX                   *ctx = 0;
  X509_STORE                *store = 0;
  spc_x509verifycallback_t  verify_callback;
   
  if (!(ctx = SSL_CTX_new(SSLv23_method(  )))) goto error_exit;
  if (!(store = spc_create_x509store(spc_store))) goto error_exit;
  SSL_CTX_set_cert_store(ctx, store);  store = 0;
  SSL_CTX_set_options(ctx, SSL_OP_ALL | SSL_OP_NO_SSLv2);
  SSL_CTX_set_cipher_list(ctx, "ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH");
   
  if (!(verify_callback = spc_store->callback))
    verify_callback = spc_verify_callback;
  if (!(spc_store->flags & SPC_X509STORE_SSL_VERIFY_MASK))
    verify_flags = SSL_VERIFY_NONE;
  else {
    if (spc_store->flags & SPC_X509STORE_SSL_VERIFY_NONE)
      verify_flags |= SSL_VERIFY_NONE;
    if (spc_store->flags & SPC_X509STORE_SSL_VERIFY_PEER)
      verify_flags |= SSL_VERIFY_PEER;
    if (spc_store->flags & SPC_X509STORE_SSL_VERIFY_FAIL_IF_NO_PEER_CERT)
      verify_flags |= SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
    if (spc_store->flags & SPC_X509STORE_SSL_VERIFY_CLIENT_ONCE)
      verify_flags |= SSL_VERIFY_CLIENT_ONCE;
  }
  SSL_CTX_set_verify(ctx, verify_flags, verify_callback);
   
  if (spc_store->flags & SPC_X509STORE_USE_CERTIFICATE) {
    if (spc_store->use_certfile)
      SSL_CTX_use_certificate_chain_file(ctx, spc_store->use_certfile);
    else {
      SSL_CTX_use_certificate(ctx, sk_X509_value(spc_store->use_certs, 0));
      for (i = 1; i < sk_X509_num(spc_store->use_certs); i++) {
        SSL_CTX_add_extra_chain_cert(ctx, sk_X509_value(spc_store->use_certs, i));
      } 
    }
    if (spc_store->use_keyfile) {
      SSL_CTX_use_PrivateKey_file(ctx, spc_store->use_keyfile, SSL_FILETYPE_PEM);
    } else { 
      if (spc_store->use_key)
        SSL_CTX_use_PrivateKey(ctx, spc_store->use_key);
    } 
  }
   
  SSL_CTX_set_app_data(ctx, spc_store);
  return ctx;
   
error_exit:
  if (store) X509_STORE_free(store);  /* not ref counted */
  if (ctx) SSL_CTX_free(ctx);         /* ref counted */
  return 0;
}
						1.1.2.4.1.2.3 SSL_CTX_set_verify example

EXAMPLES
       The following code sequence realizes an example verify_callback
       function that will always continue the TLS/SSL handshake regardless of
       verification failure, if wished. The callback realizes a verification
       depth limit with more informational output.

       All verification errors are printed, informations about the certificate
       chain are printed on request.  The example is realized for a server
       that does allow but not require client certificates.

       The example makes use of the ex_data technique to store application
       data into/retrieve application data from the SSL structure (see
       SSL_get_ex_new_index(3), SSL_get_ex_data_X509_STORE_CTX_idx(3)).

	...
	typedef struct {
	  int verbose_mode;
	  int verify_depth;
	  int always_continue;
	} mydata_t;
	int mydata_index;
	...
	static int verify_callback(int preverify_ok, X509_STORE_CTX *ctx)
	{
	   char    buf[256];
	   X509   *err_cert;
	   int	   err, depth;
	   SSL	  *ssl;
	   mydata_t *mydata;

	   err_cert = X509_STORE_CTX_get_current_cert(ctx);
	   err = X509_STORE_CTX_get_error(ctx);
	   depth = X509_STORE_CTX_get_error_depth(ctx);

	   /*
	    * Retrieve the pointer to the SSL of the connection currently treated
	    * and the application specific data stored into the SSL object.
	    */
	   ssl = X509_STORE_CTX_get_ex_data(ctx, SSL_get_ex_data_X509_STORE_CTX_idx());
	   mydata = SSL_get_ex_data(ssl, mydata_index);

	   X509_NAME_oneline(X509_get_subject_name(err_cert), buf, 256);

	   /*
	    * Catch a too long certificate chain. The depth limit set using
	    * SSL_CTX_set_verify_depth() is by purpose set to "limit+1" so
	    * that whenever the "depth>verify_depth" condition is met, we
	    * have violated the limit and want to log this error condition.
	    * We must do it here, because the CHAIN_TOO_LONG error would not
	    * be found explicitly; only errors introduced by cutting off the
	    * additional certificates would be logged.
	    */
	   if (depth > mydata->verify_depth) {
	       preverify_ok = 0;
	       err = X509_V_ERR_CERT_CHAIN_TOO_LONG;
	       X509_STORE_CTX_set_error(ctx, err);
	   }
	   if (!preverify_ok) {
	       printf("verify error:num=%d:%s:depth=%d:%s\n", err,
			X509_verify_cert_error_string(err), depth, buf);
	   }
	   else if (mydata->verbose_mode)
	   {
	       printf("depth=%d:%s\n", depth, buf);
	   }

	   /*
	    * At this point, err contains the last verification error. We can use
	    * it for something special
	    */
	   if (!preverify_ok && (err == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT))
	   {
	     X509_NAME_oneline(X509_get_issuer_name(ctx->current_cert), buf, 256);
	     printf("issuer= %s\n", buf);
	   }

	   if (mydata->always_continue)
	     return 1;
	   else
	     return preverify_ok;
	}
	...

	mydata_t mydata;

	...
	mydata_index = SSL_get_ex_new_index(0, "mydata index", NULL, NULL, NULL);

	...
	SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER|SSL_VERIFY_CLIENT_ONCE,
			   verify_callback);

	/*
	 * Let the verify_callback catch the verify_depth error so that we get
	 * an appropriate error in the logfile.
	 */
	SSL_CTX_set_verify_depth(verify_depth + 1);

	/*
	 * Set up the SSL specific data into "mydata" and store it into th SSL
	 * structure.
	 */
	mydata.verify_depth = verify_depth; ...
	SSL_set_ex_data(ssl, mydata_index, &mydata);

	...
	SSL_accept(ssl);       /* check of success left out for clarity */
	if (peer = SSL_get_peer_certificate(ssl))
	{
	  if (SSL_get_verify_result(ssl) == X509_V_OK)
	  {
	    /* The client sent a certificate which verified OK */
	  }
	}


					1.1.2.4.1.3
				1.1.2.4.2 

Conclusion: use SSL_CTX_set_verify() is ok for positive flow also

			1.1.2.5 SSL_CTX_set_verify() - again
runtime/infrastructure/cryptoLib/src/SSLContext.cpp|1003| <<<unknown>>>     SSL_CTX_set_verify( m_pSSL_CTX, nVerifyFlags, pfVerifyX509_CB );

runtime/infrastructure/cryptoLib/src/SSLContext.cpp|610| <<init>> VerifyX509_CB_Type pfVerifyX509_CB = NULL;
runtime/infrastructure/cryptoLib/src/SSLContext.cpp|992| <<init>> pfVerifyX509_CB = CSSL::x509ExceptionStaticCallback;

runtime/build/lnx26/include/SSL.h|66| <<global>> static int x509ExceptionStaticCallback(IN int nOK, IN X509_STORE_CTX* pX509StoreCtx);
runtime/infrastructure/cryptoLib/src/SSL.cpp|1309| <<x509ExceptionStaticCallback>> int CSSL::x509ExceptionStaticCallback(IN int nOK, IN X509_STORE_CTX* pX509StoreCtx)

int CSSL::x509ExceptionStaticCallback(IN int nOK, IN X509_STORE_CTX* pX509StoreCtx)
{
    CSSL* pSSL= dynamic_cast<CSSL*>(Crypto::getSSLInterface());

    if (pSSL != NULL)
    {
        pSSL->x509ExceptionCallback(nOK, pX509StoreCtx);
    }

    return nOK;
}

- use int preverify_ok value to check if verify is ok (in our code it's nOK)
- get certificate: X509_STORE_CTX_get_current_cert(pX509StoreCtx);
- check it's not CA. see:
" 
The basicConstraints extension CA flag is used to determine whether the certificate can be used as a CA. If the CA flag is true then it is a CA, if the CA flag is false then it is not a CA. All CAs should have the CA flag set to true.
"
or use depth (== 0 ?), see:
	   depth = X509_STORE_CTX_get_error_depth(ctx);

- pass the certificate to getTlsServer_CertCheckCB() callback, either change API or use SSL_set_ex_data and SSL_get_ex_data

			1.1.2.6
		1.1.3 Functional Specification
|     When ACS performs user authentication/authorization (attribute/group retrieval) against LDAP server it is susceptible to a spoofing attack.
|     LDAP server can be spoofed if an attacker has the ability to establish rogue LDAP server using a real LDAP server IP address (which can be achieved by another attack on the network) and have a valid certificate issued by the same CA as valid LDAP server certificate.
|     ACS is required to perform identify verification on the LDAP server's certificate according to rfc-4513 - Lightweight Directory Access Protocol (LDAP): Authentication Methods and Security Mechanisms.
|     The identity verification consists of:					
|     1. Check format of hostname in LDAP configuration and classify it as either DNS or IPv4.
|     	1.1 If DNS format then extract host name and domain
|     2. From incoming server certificate extract the names from x509 SUBJECT_ALT_NAME section 
|     3. Iterate over the list acquired in step 2. 
|     	3.1 If current alt. name is of DNS type and step 1 classification is DNS then compare both host names. If they are equal then flag successful verification and stop checking further.
|     	3.2 If current alt. name is of DNS type and step 1 classification is DNS then check for '*' prefix (wildcard). If so, do two sanity checks: a. 2nd character of alt. name is '.'. ; and b. The lengths match; 
	After the sanity checks compare the domain parts and if matches then flag successful verification and stop checking further.
|     	3.3 If current alt. name is of IPv4 type and step 1 classification is IPv4 then compare both host names IP addresses. If they are equal then flag successful verification and stop checking further.
|     4. If no x509 SUBJECT_ALT_NAME section is found then extract the CN 
|     	4.1 If CN is equal to the LDAP configuration hostname then flag successful verification, if not then
|     	4.2 check for '*' prefix (wildcard). If so, do two sanity checks: a. 2nd character of alt. name is '.'. ; and b. The lengths match; 
	After the sanity checks compare the domain parts and if matches then flag successful verification and stop checking further.
|     5. If all previous checks have failed then flag failed verification

See examples
LDAP hostname configuration	SAN (or CN) hostname	Match?
Host.domain.com	Host.domain.com	yes
Host.domain.com	*.domain.com	yes
1.2.3.4	1.2.3.4	yes
Host.domain.com	OtherHost.domain.com	no
Host.domain.com	*.other.domain.com	no

		1.1.4 Task breakdown
| 1. Study requirement (RFC) - 1d [Done]
| 2. Analyze solution in open LDAP and in Mozilla LDAP - 3d [Done]
| 3. Add callback to check peer cert - 1d
| 4. Set callback in SSLContext::init - 0.5d
| 5. Wire it to handshake server certificate validation callback - 1.5d
| 6. Set LDAP callback - 4d  [Done]
| 7. Build LDAP secured by SSL setup - 3d  [Done]
| 8. Test "Hello callback" on setup to verify 1-6 steps work - 2d
| 9. Adapt callback API to make sure required SSL objects are reachable - 2d  [Done]
| 10. Code the verification logic into LDAP callback - 2d
| 11. E2E tests - 2d
| 12. Code review + incorporate comments (already have some) - 2d
| 13. Deliver - 0.5d

		1.1.5 Tests

			1.1.5.1 Test "Hello callback" 

				1.1.5.1.1  Setup & material

					1.1.5.1.1.1  LDAP Server - 10.56.62.173


\\ntn01-netapp01a\workspace\wslocal1\mfaer\Projects\NMTG\Tools\DB_LDAP\LDAPS_ISE_connect_cert\LDAPS_CA_Certs_ISE 
| 10.56.62.173
dc=test,dc=ru  
abergin  
cisco123 

[yizaq@yizaq-lnx:Mon Jan 14:513:15:/view/yizaq__yizaq_5_5_dev.int.acs5_0.lx/vob/nm_acs/acs]$ nslookup !$
nslookup 10.56.62.173
Server:         10.56.60.150
Address:        10.56.60.150#53

| 173.62.56.10.in-addr.arpa       name = cd-acs-ldap01.north.auto.acs.com.

Users and Identity Stores > 	Certificate Authorities
 	policyCa_CAforLDAP 	08:16 22.03.2015 	policyCa_CAforLDAP 	CAforLDAP 	 
	CAforLDAP 	08:16 22.03.2015 	CAforLDAP 	CAforLDAP 	 
	issuingCa_CAforLDAP 	08:16 22.03.2015 	issuingCa_CAforLDAP 	policyCa_CAforLDAP 	 

LDAP configuration:
port 636
 	Use Secure Authentication, root-CA CAforLDAP 
Name: System_LDAP_Users
Schema: Custom
Subject Objectclass: Person
Subject Name Attribute: uid
Group Name Attribute: cn
Certificate Attribute: userCertificate
Group Objectclass: GroupOfUniqueNames
Group Map Attribute: UniqueMember
*-Group Objects Contain Reference To Subjects 
Subjects In Groups Are Stored In Member Attribute As: Distinguished Name
Hostname/IP: 10.56.62.173
Subject Search Base: dc=test,dc=ru
Group Search Base: dc=test,dc=ru
Search for MAC Address in Format: xxxx.xxxx.xxxx

					1.1.5.1.1.2 10.56.24.149

						1.1.5.1.1.2.1  details


-----Original Message-----
From: Michael Faer (mfaer)
Sent: Monday, February 27, 2012 11:17 AM
To: Alexander Shabanov (ashabano)
Subject: LDAP

vnc
| 10.56.62.8:1 acS100%
ssh root/acS100%
LDAP management password: secret
cn=Manager,dc=test,dc=ru



ISE structure:
Name: System_LDAP_Users
Schema: Custom
Subject Objectclass: Person
Subject Name Attribute: uid
Certificate Attribute: usersertificate
Group Objectclass: GroupOfUniqueNames
Group Map Attribute: UniqueMember
*-Group Objects Contain Reference To Subjects Subjects In Groups Are Stored In Member Attribute As: Distinguished Name
Hostname/IP:
Subject Search Base: dc=test,dc=ru
Group Search Base: dc=test,dc=ru
Search for MAC Address in Format: xxxx.xxxx.xxxx

						1.1.5.1.1.2.2 Admin Server
- start
[root@csi-ldap-server-64 openldap]# chown ldap.ldap /var/lib/ldap/*
[root@csi-ldap-server-64 openldap]# chown ldap.ldap /etc/openldap/slapd.con
[root@csi-ldap-server-64 openldap]#  /etc/rc.d/init.d/slapd start


*/
						1.1.5.1.1.2.3
					1.1.5.1.1.3
				1.1.5.1.2 1st try
- Fix too strict check:
Crypto,31/10/2012,11:46:40:279,WARN ,2998602640,NIL-CONTEXT,Crypto::Result=203, Crypto.SSLContext.init - LDAP server certificate check callback is not set,SSLContext.cpp:646
Eap,31/10/2012,11:46:40:279,ERROR,2998602640,NIL-CONTEXT,init - failed to initialize the ISSLContext,EapConfigObjectBase.cpp:116
Crypto,31/10/2012,11:46:40:279,WARN ,2998602640,NIL-CONTEXT,Crypto::Result=203, Crypto.SSLContext.init - LDAP server certificate check callback is not set,SSLContext.cpp:646
Eap,31/10/2012,11:46:40:279,ERROR,2998602640,NIL-CONTEXT,init - failed to initialize the ISSLContext,EapConfigObjectBase.cpp:116
Crypto,31/10/2012,11:46:40:279,WARN ,2998602640,NIL-CONTEXT,Crypto::Result=203, Crypto.SSLContext.init - LDAP server certificate check callback is not set,SSLContext.cpp:646
Eap,31/10/2012,11:46:40:279,ERROR,2998602640,NIL-CONTEXT,init - failed to initialize the ISSLContext,EapConfigObjectBase.cpp:116
Crypto,31/10/2012,11:53:12:426,WARN ,2998602640,NIL-CONTEXT,Crypto::Result=203, Crypto.SSLContext.init - LDAP server certificate check callback is not set,SSLContext.cpp:646
Eap,31/10/2012,11:53:12:426,ERROR,2998602640,NIL-CONTEXT,init - failed to initialize the ISSLContext,EapConfigObjectBase.cpp:116
Crypto,31/10/2012,11:53:12:426,WARN ,2998602640,NIL-CONTEXT,Crypto::Result=203, Crypto.SSLContext.init - LDAP server certificate check callback is not set,SSLContext.cpp:646
Eap,31/10/2012,11:53:12:426,ERROR,2998602640,NIL-CONTEXT,init - failed to initialize the ISSLContext,EapConfigObjectBase.cpp:116
Crypto,31/10/2012,11:53:12:427,WARN ,2998602640,NIL-CONTEXT,Crypto::Result=203, Crypto.SSLContext.init - LDAP server certificate check callback is not set,SSLContext.cpp:646
Eap,31/10/2012,11:53:12:427,ERROR,2998602640,NIL-CONTEXT,init - failed to initialize the ISSLContext,EapConfigObjectBase.cpp:116
Crypto,31/10/2012,11:54:13:911,WARN ,3012201360,NIL-CONTEXT,Crypto::Result=1, Crypto.SSLConnection.pvClientInfoCB - Alert raised: code=0x230=560, where=0x4008=16392, source=local,SSLConnection.cpp:2723

:! ct diff -pred -diff runtime/infrastructure/cryptoLib/src/SSLContext.cpp
646,647c646,647
<         g_pILog->logWarn(__FILE__,__LINE__, RESULT_INVALID_INPUT, "Crypto.SSLContext.init - LDAP server certificate check callback is not set");
<         return RESULT_INVALID_INPUT;
---
>         g_pILog->logDebug(__FILE__,__LINE__, RESULT_INVALID_INPUT, "Crypto.SSLContext.init - LDAP server certificate check callback is not set");

>         //return RESULT_INVALID_INPUT;

- logs
EventHandler,31/10/2012,17:06:35:076,DEBUG,3000138640,Stack: 0xaf2c06a0 Destroy stack,EventStack.cpp:37
RT,31/10/2012,17:06:45:444,DEBUG,2976201616,NIL-CONTEXT,Received data from 64.103.126.140:63106 to 10.56.24.159:1812 :
NIL-CONTEXT,0000: 01 03 00 63 ab 26 f8 44  1a 79 33 d2 7a 80 ce 14  ...c.&.D.y3.z...
NIL-CONTEXT,0010: ad fd b4 48 01 09 61 62  65 72 67 69 6e 04 06 0a  ...H..abergin...
NIL-CONTEXT,0020: 38 3f 45 05 06 00 00 00  02 02 12 2c 7e eb 6b 7e  8?E........,~.k~
NIL-CONTEXT,0030: f0 40 ce e9 d9 e7 8f 7f  6c 46 54 1f 04 31 31 1e  .@......lFT..11.
NIL-CONTEXT,0040: 04 31 31 20 04 35 36 57  04 38 39 3d 06 00 00 00  .11 .56W.89=....
NIL-CONTEXT,0050: 01 50 12 43 32 e7 3a 01  26 1d c1 70 77 38 aa bd  .P.C2.:.&..pw8..
NIL-CONTEXT,0060: 75 7e 6d                                          u~m ,UDPListener.cpp:239
RadiusListener,31/10/2012,17:06:45:444,DEBUG,2976201616,NIL-CONTEXT,[RADIUSListener::dataArrived] called.,RADIUSListener.cpp:148
ConfigVersionManager,31/10/2012,17:06:45:444,DEBUG,2976201616,VersionManager::getCurrVerIDAndIncrementVersionRef: version ID=17, ref count=2,VersionManager.cpp:237
ConfigVersionManager,31/10/2012,17:06:45:444,DEBUG,2976201616,VersionManager::incrementVersionRef: version ID=17, ref count=3,VersionManager.cpp:130
ConfigVersionManager,31/10/2012,17:06:45:444,DEBUG,2976201616,VersionManager::incrementVersionRef: version ID=17, ref count=4,VersionManager.cpp:130
EventHandler,31/10/2012,17:06:45:444,DEBUG,2976201616,Stack: 0x9b3ff10 Create new stack,EventStack.cpp:27
EventHandler,31/10/2012,17:06:45:444,DEBUG,3045886864,Stack: 0x9b3ff10 Calling RADIUSHandler: Method MethodCaller<RADIUSHandler, RADIUSRawBufferEvent> in thread: 3045886864,EventStack.cpp:204
AuthenStateManager,31/10/2012,17:06:45:445,DEBUG,3045886864,cancelTimer: sessionID=,AuthenStateManager.cpp:260
ConfigVersionManager,31/10/2012,17:06:45:445,DEBUG,3045886864,VersionManager::getCurrVerIDAndIncrementVersionRef: version ID=17, ref count=5,VersionManager.cpp:237
ConfigVersionManager,31/10/2012,17:06:45:445,DEBUG,3045886864,VersionManager::incrementVersionRef: version ID=17, ref count=6,VersionManager.cpp:130
ConfigVersionManager,31/10/2012,17:06:45:445,DEBUG,3045886864,VersionManager::decrementVersionRef: version ID=17, ref count=5,VersionManager.cpp:159
AuthenStateManager,31/10/2012,17:06:45:445,DEBUG,3045886864,acquireOrCreateState: created sessionID=acs-yizaq-01/140983376/3,AuthenStateManager.cpp:62
ConfigVersionManager,31/10/2012,17:06:45:445,DEBUG,3045886864,VersionManager::incrementVersionRef: version ID=17, ref count=6,VersionManager.cpp:130
ConfigVersionManager,31/10/2012,17:06:45:445,DEBUG,3045886864,VersionManager::incrementVersionRef: version ID=17, ref count=7,VersionManager.cpp:130
ConfigVersionManager,31/10/2012,17:06:45:445,DEBUG,3045886864,VersionManager::incrementVersionRef: version ID=17, ref count=8,VersionManager.cpp:130
ConfigVersionManager,31/10/2012,17:06:45:445,DEBUG,3045886864,VersionManager::decrementVersionRef: version ID=17, ref count=7,VersionManager.cpp:159
ConfigVersionManager,31/10/2012,17:06:45:445,DEBUG,3045886864,VersionManager::decrementVersionRef: version ID=17, ref count=6,VersionManager.cpp:159
ConfigVersionManager,31/10/2012,17:06:45:445,DEBUG,3045886864,VersionManager::decrementVersionRef: version ID=17, ref count=5,VersionManager.cpp:159
Radius,31/10/2012,17:06:45:445,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,New raw buffer arrived,RADIUSHandler.cpp:398
Logging,31/10/2012,17:06:45:445,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,msg_code=[11001], LogNotificationCenter::logBE - Best-Effort ONLY Requested, msg_id=[926],LogNotificationCenter.cpp:394
Logging,31/10/2012,17:06:45:445,INFO ,3045886864,Request for configuration 0xa73a498 of version: 17,LoggingConfiguration.cpp:712
Logging,31/10/2012,17:06:45:445,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,msg_code=[11001], LogNotificationCenter::logBE - NO BE Targets,LogNotificationCenter.cpp:455
Logging,31/10/2012,17:06:45:445,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,msg_code=[11017], LogNotificationCenter::logBE - Best-Effort ONLY Requested, msg_id=[927],LogNotificationCenter.cpp:394
Logging,31/10/2012,17:06:45:445,INFO ,3045886864,Request for configuration 0xa73a498 of version: 17,LoggingConfiguration.cpp:712
Logging,31/10/2012,17:06:45:445,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,msg_code=[11017], LogNotificationCenter::logBE - NO BE Targets,LogNotificationCenter.cpp:455
inboundProtocolManager,31/10/2012,17:06:45:445,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,Start Lookup for NAS with IP = 64.103.126.140,ProtocolDataUtils.cpp:362
inboundProtocolManager,31/10/2012,17:06:45:445,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3, getAAAClientByIP : before lookup in mask. version ID = 17,ProtocolDataUtils.cpp:383
inboundProtocolManager,31/10/2012,17:06:45:445,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,NAS with IP = 64.103.126.140 matches AAAClient with IP = 1.1.1.1 and mask 0,ProtocolDataUtils.cpp:495
inboundProtocolManager,31/10/2012,17:06:45:445,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,ProtocolDataUtils::getDefaultDeviceObject: getDefaultDeviceObject is Null,ProtocolDataUtils.cpp:348
inboundProtocolManager,31/10/2012,17:06:45:446,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,NDG's attributes were successfully put on the context.,ProtocolDataUtils.cpp:628
inboundProtocolManager,31/10/2012,17:06:45:446,INFO ,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,ProtocolDataUtils::setDefaultNDGValues start,ProtocolDataUtils.cpp:681
StateSerialization,31/10/2012,17:06:45:446,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,State attribute isn't on context, ignoring deserialization of SGACLsIndex,SGACLSerializer.cpp:48
StateSerialization,31/10/2012,17:06:45:446,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,State attribute isn't on context, ignoring deserialization of SgaclListIndex,SGACLListSerializer.cpp:48
StateSerialization,31/10/2012,17:06:45:446,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,State attribute isn't on context, ignoring deserialization of DACLIndex,DACLSerializer.cpp:50
Radius,31/10/2012,17:06:45:446,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,RADIUS PACKET:: Code=1(AccessRequest) Identifier=3 Length=99,RADIUSHandler.cpp:1330
Radius,31/10/2012,17:06:45:446,DEBUG,3045886864,NIL-CONTEXT,     [1] User-Name - value: [abergin] ,AttributePrintHelper.cpp:75
Radius,31/10/2012,17:06:45:446,DEBUG,3045886864,NIL-CONTEXT,     [2] User-Password - value: [****] ,AttributePrintHelper.cpp:75
Radius,31/10/2012,17:06:45:446,DEBUG,3045886864,NIL-CONTEXT,     [4] NAS-IP-Address - value: [10.56.63.69] ,AttributePrintHelper.cpp:75
Radius,31/10/2012,17:06:45:446,DEBUG,3045886864,NIL-CONTEXT,     [5] NAS-Port - value: [2] ,AttributePrintHelper.cpp:75
Radius,31/10/2012,17:06:45:446,DEBUG,3045886864,NIL-CONTEXT,     [30] Called-Station-ID - value: [11] ,AttributePrintHelper.cpp:75
Radius,31/10/2012,17:06:45:446,DEBUG,3045886864,NIL-CONTEXT,     [31] Calling-Station-ID - value: [11] ,AttributePrintHelper.cpp:75
Radius,31/10/2012,17:06:45:446,DEBUG,3045886864,NIL-CONTEXT,     [32] NAS-Identifier - value: [56] ,AttributePrintHelper.cpp:75
Radius,31/10/2012,17:06:45:446,DEBUG,3045886864,NIL-CONTEXT,     [61] NAS-Port-Type - value: [Sync] ,AttributePrintHelper.cpp:75
Radius,31/10/2012,17:06:45:446,DEBUG,3045886864,NIL-CONTEXT,     [80] Message-Authenticator - value: [43:32:e7:3a:01:26:1d:c1:70:77:38:aa:bd:75:7e:6d] ,AttributePrintHelper.cpp:75
Radius,31/10/2012,17:06:45:446,DEBUG,3045886864,NIL-CONTEXT,     [87] NAS-Port-Id - value: [89] ,AttributePrintHelper.cpp:75
Radius,31/10/2012,17:06:45:446,DEBUG,3045886864,NIL-CONTEXT,CTS_pac_opaque = false,RADIUSHandler.cpp:498
Radius,31/10/2012,17:06:45:447,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,Validate integrity related RADIUS attributes,RADIUSHandler.cpp:1022
Radius,31/10/2012,17:06:45:447,DEBUG,3045886864,NIL-CONTEXT,RadiusRequestFlow::validateContext was called,RadiusRequestFlow.cpp:88
EventHandler,31/10/2012,17:06:45:447,DEBUG,3045886864,Stack: 0x9b3ff10 Calling RadiusRequestFlow: Method MethodCaller<RadiusRequestFlow, RadiusPacketEvent> in thread: 3045886864,EventStack.cpp:204
Radius,31/10/2012,17:06:45:447,DEBUG,3045886864,NIL-CONTEXT,RadiusRequestFlow::onRadiusPacketEvent was called,RadiusRequestFlow.cpp:148
DACLFlow,31/10/2012,17:06:45:447,DEBUG,3045886864,NIL-CONTEXT,DACLFlow::shouldInvoke,DACLFlow.cpp:60
DACLFlow,31/10/2012,17:06:45:447,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,DACLFlow::validUserNamePrefix not a dACL request,DACLFlow.cpp:88
Radius,31/10/2012,17:06:45:447,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,NOT DACL Request, continue onRadiusPacketEvent,RadiusRequestFlow.cpp:177
Service,31/10/2012,17:06:45:447,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,Service::serviceSelection, Initiating service selection process.,Service.cpp:157
Logging,31/10/2012,17:06:45:447,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,msg_code=[15008], LogNotificationCenter::logBE - Best-Effort ONLY Requested, msg_id=[928],LogNotificationCenter.cpp:394
Logging,31/10/2012,17:06:45:447,INFO ,3045886864,Request for configuration 0xa73a498 of version: 17,LoggingConfiguration.cpp:712
Logging,31/10/2012,17:06:45:447,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,msg_code=[15008], LogNotificationCenter::logBE - NO BE Targets,LogNotificationCenter.cpp:455
NumericPolicyAdapter,31/10/2012,17:06:45:447,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,uint32, left value = 0, EqualOperator, right value = 0, result = 1,NumericPolicyAdapter.cpp:278
Statistics,31/10/2012,17:06:45:447,INFO ,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,Statistics::incrementRuleHit(): ruleName = Rule-1, ruleId = 905, policyId = 1903,Statistics.cpp:219
Statistics,31/10/2012,17:06:45:447,INFO ,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,Statistics::incrementRuleHit(): creating new RuleIdMap for PolicyId 1903,Statistics.cpp:242
Statistics,31/10/2012,17:06:45:448,INFO ,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,Statistics::incrementRuleHit(): ruleName = Rule-1, ruleId = 905, count = 1,Statistics.cpp:258
PolicyRule,31/10/2012,17:06:45:448,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,PolicyRule - matched, RuleID=905 RuleIndex=1 RuleName=Rule-1 Status=3 adding rule results. PolicyResults=Result#0-TypeID=1154 ObjectID=909,PolicyRule.cpp:201
Logging,31/10/2012,17:06:45:448,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,msg_code=[15004], LogNotificationCenter::logBE - Best-Effort ONLY Requested, msg_id=[929],LogNotificationCenter.cpp:394
Logging,31/10/2012,17:06:45:448,INFO ,3045886864,Request for configuration 0xa73a498 of version: 17,LoggingConfiguration.cpp:712
Logging,31/10/2012,17:06:45:448,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,msg_code=[15004], LogNotificationCenter::logBE - NO BE Targets,LogNotificationCenter.cpp:455
Service,31/10/2012,17:06:45:448,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,Service::serviceSelection ServiceCategory=1, ServiceID=1900, ServiceObjectTypedID=1015,Service.cpp:222
Logging,31/10/2012,17:06:45:448,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,msg_code=[15012], LogNotificationCenter::logBE - Best-Effort ONLY Requested, msg_id=[930],LogNotificationCenter.cpp:394
Logging,31/10/2012,17:06:45:448,INFO ,3045886864,Request for configuration 0xa73a498 of version: 17,LoggingConfiguration.cpp:712
Logging,31/10/2012,17:06:45:448,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,msg_code=[15012], LogNotificationCenter::logBE - NO BE Targets,LogNotificationCenter.cpp:455
Radius,31/10/2012,17:06:45:448,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,Service is selected,RadiusRequestFlow.cpp:197
Service,31/10/2012,17:06:45:448,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,Service::getRejectedFlagAndServiceCategory(): ServiceCategory=1,Service.cpp:328
Service,31/10/2012,17:06:45:448,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,Service::getRejectedFlagAndServiceCategory(): getting NetworkAccess or DeviceAdministration service info,Service.cpp:331
PolicyUtils,31/10/2012,17:06:45:448,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,PolicyUtils::getServiceObject serviceID=1900, nVersionID = 17, ServiceObjectTypeID=1015,PolicyUtils.cpp:69
Radius,31/10/2012,17:06:45:448,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,Network Access Service is selected,RadiusRequestFlow.cpp:233
Radius,31/10/2012,17:06:45:448,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,RadiusAccountingFlow::validateContext was called,RadiusAccountingFlow.cpp:125
RadiusCTSFlow,31/10/2012,17:06:45:448,DEBUG,3045886864,NIL-CONTEXT,RadiusCTSFlow::shouldInvoke EventName=RadiusRequestEvent,RadiusCTSFlow.cpp:71
RadiusEapFlow,31/10/2012,17:06:45:448,DEBUG,3045886864,NIL-CONTEXT,RadiusEapFlow::shouldInvoke,RadiusEapFlow.cpp:69
RadiusAuthenFlow,31/10/2012,17:06:45:449,DEBUG,3045886864,NIL-CONTEXT,RadiusAuthenFlow::shouldInvoke,RadiusAuthenFlow.cpp:75
EventHandler,31/10/2012,17:06:45:449,DEBUG,3045886864,Stack: 0x9b3ff10 Calling RadiusAuthenFlow: Method MethodCaller<RadiusAuthenFlow, RadiusRequestEvent> in thread: 3045886864,EventStack.cpp:204
RadiusAuthenFlow,31/10/2012,17:06:45:449,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,RadiusAuthenFlow::onRadiusRequestEvent invoking RadiusHostLookupFlow or RadiusPAPFlow,RadiusAuthenFlow.cpp:89
PolicyUtils,31/10/2012,17:06:45:449,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,PolicyUtils::getServiceObject serviceID=1900, nVersionID = 17, ServiceObjectTypeID=1015,PolicyUtils.cpp:69
RadiusHostLookupFlow,31/10/2012,17:06:45:449,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,RadiusHostLookupFlow::shouldInvoke() returned false,RadiusHostLookupFlow.cpp:72
RadiusMSCHAPFlow,31/10/2012,17:06:45:449,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,RadiusMSCHAPv2Flow::shouldInvoke,RadiusMSCHAPv2Flow.cpp:77
RadiusMSCHAPFlow,31/10/2012,17:06:45:449,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,RadiusMSCHAPv2Flow::validateContext,RadiusMSCHAPv2Flow.cpp:85
RadiusMSCHAPFlow,31/10/2012,17:06:45:449,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,RadiusMSCHAPv2Flow::validateContext could not find Radius MSCHAP v2 attributes,RadiusMSCHAPv2Flow.cpp:100
RadiusMSCHAPFlow,31/10/2012,17:06:45:449,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,RadiusMSCHAPv1Flow::shouldInvoke,RadiusMSCHAPv1Flow.cpp:72
RadiusMSCHAPFlow,31/10/2012,17:06:45:449,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,RadiusMSCHAPv1Flow::validateContext,RadiusMSCHAPv1Flow.cpp:80
RadiusMSCHAPFlow,31/10/2012,17:06:45:449,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,RadiusMSCHAPv1Flow::validateContext could not find Radius MSCHAP v1 attributes,RadiusMSCHAPv1Flow.cpp:97
RadiusCHAPFlow,31/10/2012,17:06:45:449,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,RadiusCHAPFlow::shouldInvoke,RadiusCHAPFlow.cpp:70
RadiusCHAPFlow,31/10/2012,17:06:45:449,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,ChapPassword is missing or invalid,RadiusCHAPFlow.cpp:112
RadiusPAPFlow,31/10/2012,17:06:45:449,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,RadiusPAPFlow::validateContext,RadiusPAPFlow.cpp:89
EventHandler,31/10/2012,17:06:45:449,DEBUG,3045886864,Stack: 0x9b3ff10 Calling RadiusPAPFlow: Method MethodCaller<RadiusPAPFlow, AuthenticateEvent> in thread: 3045886864,EventStack.cpp:204
RadiusPAPFlow,31/10/2012,17:06:45:449,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,RadiusPAPFlow::validateContext,RadiusPAPFlow.cpp:89
PolicyUtils,31/10/2012,17:06:45:449,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,PolicyUtils::getServiceObject serviceID=1900, nVersionID = 17, ServiceObjectTypeID=1015,PolicyUtils.cpp:69
RadiusPAPFlow,31/10/2012,17:06:45:450,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,RADIUSUserPasswordValidator::decryptUserPassword,RADIUSUserPasswordValidator.cpp:44
EventHandler,31/10/2012,17:06:45:450,DEBUG,3045886864,Stack: 0x9b3ff10 Calling PAPAuthenticator: Method MethodCaller<Authenticator<PAPAuthenticator>, AuthenticateEvent> in thread: 3045886864,EventStack.cpp:204
EventHandler,31/10/2012,17:06:45:450,DEBUG,3045886864,Stack: 0x9b3ff10 Calling ComposableWorkflow: Method MethodCaller<ComposableWorkflow, WorkflowEvent> in thread: 3045886864,EventStack.cpp:204
ComposableWorkflow,31/10/2012,17:06:45:450,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,***************  ComposableWorkflow::onWorkflowAuthenticateEvent ****,ComposableWorkflow.cpp:92
EventHandler,31/10/2012,17:06:45:450,DEBUG,3045886864,Stack: 0x9b3ff10 Calling IdentitySequenceWorkflow: Method MethodCaller<IdentitySequenceWorkflow, WorkflowAuthenticateEvent> in thread: 3045886864,EventStack.cpp:204
IdentitySequence,31/10/2012,17:06:45:450,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,***** Going to remove ID Stores attribute from possible previous authentications/attribute retriving.,IdentitySequenceWorkflow.cpp:301
IdentitySequence,31/10/2012,17:06:45:450,DEBUG,3045886864,NIL-CONTEXT,IDStoresAttributeRemoveHelper::removeAttributes,IDStoresAttributeRemoveHelper.cpp:59
IdentitySequence,31/10/2012,17:06:45:450,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,***** Going to run authentication policy for IDStore selection.,IdentitySequenceWorkflow.cpp:307
PolicyUtils,31/10/2012,17:06:45:450,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,PolicyUtils::getServiceObject serviceID=1900, nVersionID = 17, ServiceObjectTypeID=1015,PolicyUtils.cpp:69
Logging,31/10/2012,17:06:45:450,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,msg_code=[15041], LogNotificationCenter::logBE - Best-Effort ONLY Requested, msg_id=[931],LogNotificationCenter.cpp:394
Logging,31/10/2012,17:06:45:450,INFO ,3045886864,Request for configuration 0xa73a498 of version: 17,LoggingConfiguration.cpp:712
Logging,31/10/2012,17:06:45:450,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,msg_code=[15041], LogNotificationCenter::logBE - NO BE Targets,LogNotificationCenter.cpp:455
Policy,31/10/2012,17:06:45:450,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,Policy - No match, adding catch all rule results.,Policy.cpp:114
Statistics,31/10/2012,17:06:45:450,INFO ,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,Statistics::incrementRuleHit(): ruleName = Default, ruleId = 0, policyId = 1900,Statistics.cpp:219
Statistics,31/10/2012,17:06:45:450,INFO ,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,Statistics::incrementRuleHit(): creating new RuleIdMap for PolicyId 1900,Statistics.cpp:242
Statistics,31/10/2012,17:06:45:450,INFO ,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,Statistics::incrementRuleHit(): ruleName = Default, ruleId = 0, count = 1,Statistics.cpp:258
Logging,31/10/2012,17:06:45:450,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,msg_code=[15006], LogNotificationCenter::logBE - Best-Effort ONLY Requested, msg_id=[932],LogNotificationCenter.cpp:394
Logging,31/10/2012,17:06:45:451,INFO ,3045886864,Request for configuration 0xa73a498 of version: 17,LoggingConfiguration.cpp:712
Logging,31/10/2012,17:06:45:451,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,msg_code=[15006], LogNotificationCenter::logBE - NO BE Targets,LogNotificationCenter.cpp:455
IdentitySequence,31/10/2012,17:06:45:451,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,******* Authen IDStoreName:SecLdap,IdentitySequenceWorkflow.cpp:381
Logging,31/10/2012,17:06:45:451,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,msg_code=[15013], LogNotificationCenter::logBE - Best-Effort ONLY Requested, msg_id=[933],LogNotificationCenter.cpp:394
Logging,31/10/2012,17:06:45:451,INFO ,3045886864,Request for configuration 0xa73a498 of version: 17,LoggingConfiguration.cpp:712
Logging,31/10/2012,17:06:45:451,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,msg_code=[15013], LogNotificationCenter::logBE - NO BE Targets,LogNotificationCenter.cpp:455
IdentitySequence,31/10/2012,17:06:45:451,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,******* workflow is calling:<PAPAuthenticator> ************,IdentitySequenceWorkflow.h:90
EventHandler,31/10/2012,17:06:45:451,DEBUG,3045886864,Stack: 0x9b3ff10 Calling PAPAuthenticator: Method MethodCaller<Authenticator<PAPAuthenticator>, WorkflowAuthenticateEvent> in thread: 3045886864,EventStack.cpp:204
PAPAuthenticator,31/10/2012,17:06:45:451,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,PAPAuthenticator::handleAuthenticateEvent,PAPAuthenticator.cpp:83
PAPAuthenticator,31/10/2012,17:06:45:451,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,PAPAuthenticator send PlainAuthenticateAndQueryEvent.,../../../../build/lnx26/include/Authenticator.h:251
PAPAuthenticator,31/10/2012,17:06:45:451,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,Attempting calling SecLdap IDStore,../../../../build/lnx26/include/Authenticator.h:140
EventHandler,31/10/2012,17:06:45:451,DEBUG,3045886864,Stack: 0x9b3ff10 Calling IDStoreEventDispatcher<LDAPIDStore>: Method MethodCaller<IDStoreEventDispatcher<LDAPIDStore>, AcsEvent> in thread: 3045886864,EventStack.cpp:204
IDStoreManager,31/10/2012,17:06:45:451,DEBUG,3045886864,NIL-CONTEXT,[IDStoreEventDispatcher::onAnyEvent] new Event arrived,IDStoreEventDispatcher.h:103
EventHandler,31/10/2012,17:06:45:451,DEBUG,3045886864,Stack: 0x9b3ff10 Calling LDAPIDStore: Method MethodCaller<LDAPIDStore, PlainAuthenticateAndQueryEvent> in thread: 3045886864,EventStack.cpp:204
IDStore,31/10/2012,17:06:45:451,DEBUG,3045886864,NIL-CONTEXT,LDAPIDStore::onPlainAuthenticateAndQueryEvent: <SecLdap_17> invoked,LDAPIDStore.cpp:145
IDStore,31/10/2012,17:06:45:451,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,Send event to SecLdap_17_Primary server,LDAPIDStore.h:205
Logging,31/10/2012,17:06:45:451,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,msg_code=[24031], LogNotificationCenter::logBE - Best-Effort ONLY Requested, msg_id=[934],LogNotificationCenter.cpp:394
Logging,31/10/2012,17:06:45:451,INFO ,3045886864,Request for configuration 0xa73a498 of version: 17,LoggingConfiguration.cpp:712
Logging,31/10/2012,17:06:45:451,DEBUG,3045886864,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,msg_code=[24031], LogNotificationCenter::logBE - NO BE Targets,LogNotificationCenter.cpp:455
EventHandler,31/10/2012,17:06:45:452,DEBUG,3012201360,Stack: 0x9b3ff10 Calling LdapServer: Method MethodCaller<LdapServer, PlainAuthenticateAndQueryEvent> in thread: 3012201360,EventStack.cpp:204
Server,31/10/2012,17:06:45:452,DEBUG,3012201360,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,LdapServer::onPlainAuthenticateAndQueryEvent,LdapServer.cpp:153
Logging,31/10/2012,17:06:45:452,DEBUG,3012201360,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,msg_code=[24015], LogNotificationCenter::logBE - Best-Effort ONLY Requested, msg_id=[935],LogNotificationCenter.cpp:394
Logging,31/10/2012,17:06:45:452,INFO ,3012201360,Request for configuration 0xa73a498 of version: 17,LoggingConfiguration.cpp:712
Logging,31/10/2012,17:06:45:452,DEBUG,3012201360,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,msg_code=[24015], LogNotificationCenter::logBE - NO BE Targets,LogNotificationCenter.cpp:455
Server,31/10/2012,17:06:45:452,DEBUG,3012201360,cntx=0000004484,sesn=acs-yizaq-01/140983376/3,user=abergin,LdapServer::acquireConnection,LdapServer.cpp:658
State,31/10/2012,17:06:45:452,DEBUG,3012201360,LdapConnectionInitState::connect(id = -1),LdapConnectionStates.cpp:172
State,31/10/2012,17:06:45:452,DEBUG,3012201360,LdapConnectionOpeningState::onState(id = -1),LdapConnectionStates.cpp:187
Crypto,31/10/2012,17:06:45:452,DEBUG,3012201360,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.SSLConnection - Setting client parameters,SSLConnection.cpp:153
Crypto,31/10/2012,17:06:45:452,DEBUG,3012201360,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.SSLConnection - Setting socket 512,SSLConnection.cpp:189
Connection,31/10/2012,17:06:45:452,INFO ,3012201360,LdapSslConnectionContext::initSslSession: setting connection context on SSLConnection,LdapSslConnectionContext.cpp:43
Connection,31/10/2012,17:06:45:452,INFO ,3012201360,LdapConnectionContext::openConnection(id = 512): connecting to 10.56.62.173:636,LdapConnectionContext.cpp:261
Connection,31/10/2012,17:06:45:452,INFO ,3012201360,LdapConnectionContext::openConnection(id = 512): connection is in progress,LdapConnectionContext.cpp:269
State,31/10/2012,17:06:45:454,INFO ,3012201360,LdapConnectionOpeningState::onOutput(id = 512): succeeded to establish connection,LdapConnectionStates.cpp:205
State,31/10/2012,17:06:45:454,DEBUG,3012201360,LdapConnectionOpenedState::onState(id = 512),LdapConnectionStates.cpp:245
State,31/10/2012,17:06:45:454,DEBUG,3012201360,LdapConnectionBindingState::onState(id = 512),LdapConnectionStates.cpp:353
Connection,31/10/2012,17:06:45:454,DEBUG,3012201360,LdapConnectionContext::sendBindRequest(id = 512): dn = anonymous,LdapConnectionContext.cpp:368
Crypto,31/10/2012,17:06:45:454,DEBUG,3012201360,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.writeData - nInDataSize=14, entity=client,SSLConnection.cpp:894
Crypto,31/10/2012,17:06:45:455,DEBUG,3012201360,NIL-CONTEXT,Crypto::Result=106, Crypto.SSLConnection.writeData - want read,SSLConnection.cpp:921
Crypto,31/10/2012,17:06:45:457,DEBUG,3012201360,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.writeData - nInDataSize=14, entity=client,SSLConnection.cpp:894
Crypto,31/10/2012,17:06:45:457,DEBUG,3012201360,NIL-CONTEXT,Crypto::Result=106, Crypto.SSLConnection.writeData - want read,SSLConnection.cpp:921
Crypto,31/10/2012,17:06:45:459,DEBUG,3012201360,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.writeData - nInDataSize=14, entity=client,SSLConnection.cpp:894
Crypto,31/10/2012,17:06:45:461,DEBUG,3012201360,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback,SSL.cpp:1098
Crypto,31/10/2012,17:06:45:461,DEBUG,3012201360,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - un-handled error 0x13, nOK=0,SSL.cpp:1157
Crypto,31/10/2012,17:06:45:461,WARN ,3012201360,NIL-CONTEXT,Crypto::Result=1, Crypto.SSLConnection.pvClientInfoCB - Alert raised: code=0x230=560, where=0x4008=16392, source=local,SSLConnection.cpp:2723
Crypto,31/10/2012,17:06:45:461,WARN ,3012201360,NIL-CONTEXT,Crypto::Result=102, Crypto.SSLConnection.writeData - failed write the data,SSLConnection.cpp:933
Connection,31/10/2012,17:06:45:461,ERROR,3012201360,LdapSslConnectionContext::checkCryptoResult(id = 512): crypto result = 102,LdapSslConnectionContext.cpp:206
Connection,31/10/2012,17:06:45:461,ERROR,3012201360,LdapSslConnectionContext::checkCryptoResult(id = 512): error message = SSL alert: code=0x230=560 ; source=local ; type=fatal ; message="Unknown CA - error self-signed certificate in chain",LdapSslConnectionContext.cpp:215
AcsLogs,31/10/2012,17:06:45:462,DEBUG,3012201360,cntx=0000004486,Log_Message=[2012-10-31 17:06:45.461 +02:00 0000000937 24003 ERROR External-LDAP: Cannot bind connection with anonymous credentials, ACSVersion=acs-5.4.0.41-B.223, ConfigVersionId=17, LdapIDStore=SecLdap, LdapServer=10.56.62.173, ],MessageFormatter.cpp:75
EventHandler,31/10/2012,17:06:45:462,DEBUG,3012201360,Stack: 0xa6f9630 Create new stack,EventStack.cpp:27
ConfigVersionManager,31/10/2012,17:06:45:462,DEBUG,3012201360,VersionManager::decrementVersionRef: version ID=17, ref count=12,VersionManager.cpp:159
EventHandler,31/10/2012,17:06:45:462,DEBUG,3044834192,Stack: 0xa6f9630 Calling BestEffortLoggingDispatcher: Method MethodCaller<BestEffortLoggingDispatcher, LogMessageWrapper> in thread: 3044834192,EventStack.cpp:204
Logging,31/10/2012,17:06:45:462,DEBUG,3044834192,msg_code=[24003], BestEffortLoggingDispatcher::onLogMessageWrapper - Invoke 1st BE Logger,BestEffortLoggingDispatcher.cpp:53
ConfigVersionManager,31/10/2012,17:06:45:462,DEBUG,3012201360,VersionManager::decrementVersionRef: version ID=17, ref count=11,VersionManager.cpp:159
EventHandler,31/10/2012,17:06:45:462,DEBUG,2991586192,Stack: 0xa6f9630 Calling LocalStoreLogger: Method MethodCaller<Logger, LogMessageWrapper> in thread: 2991586192,EventStack.cpp:204
ConfigVersionManager,31/10/2012,17:06:45:462,DEBUG,3012201360,VersionManager::decrementVersionRef: version ID=17, ref count=10,VersionManager.cpp:159
ConfigVersionManager,31/10/2012,17:06:45:462,DEBUG,3012201360,VersionManager::decrementVersionRef: version ID=17, ref count=9,VersionManager.cpp:159
State,31/10/2012,17:06:45:462,ERROR,3012201360,LdapConnectionBindingState::onInput(id = 512): bind ended with an error: 116,LdapConnectionStates.cpp:427
State,31/10/2012,17:06:45:462,DEBUG,3012201360,LdapConnectionErrorState::onState(id = 512),LdapConnectionStates.cpp:692
Logging,31/10/2012,17:06:45:462,DEBUG,2991586192,msg_code=[24003], FileLogger::send - to FileLogger=[/opt/CSCOacs/logs/localStore//acsLocalStore.log], from component=[LdapConnection], status=[1],  iSysLogId=[746],FileLogger.cpp:580
Logging,31/10/2012,17:06:45:462,DEBUG,2991586192,msg_code=[24003], LocalStore::send - component=[LdapConnection], result=[1],LocalStore.cpp:422
Connection,31/10/2012,17:06:45:462,INFO ,3012201360,LdapSslConnectionContext::destroySession(id = 512): ,LdapSslConnectionContext.cpp:86
Connection,31/10/2012,17:06:45:463,INFO ,3012201360,LdapConnectionContext::closeConnection(id = 512): unbind the connection,LdapConnectionContext.cpp:231
Logging,31/10/2012,17:06:45:463,DEBUG,2991586192,msg_code=[24003], Logger::onLogMessageWrapper - key=[LocalStoreLogger], result=[1],Logger.cpp:39
Crypto,31/10/2012,17:06:45:463,DEBUG,3012201360,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.writeData - nInDataSize=7, entity=client,SSLConnection.cpp:894
EventHandler,31/10/2012,17:06:45:463,DEBUG,3045886864,Stack: 0xa6f9630 Calling back BestEffortLoggingDispatcher: Method MethodCaller<BestEffortLoggingDispatcher, LogMessageWrapper> in thread: 3045886864,EventStack.cpp:242
Logging,31/10/2012,17:06:45:463,DEBUG,3045886864,msg_code=[24003], BestEffortLoggingDispatcher::onLogMessageWrapperCallback - Invoke 2nd to Last BE Loggers,BestEffortLoggingDispatcher.cpp:86
EventHandler,31/10/2012,17:06:45:463,DEBUG,2990533520,Stack: 0xa6f9630 Calling SyslogLogger: Method MethodCaller<Logger, LogMessageWrapper> in thread: 2990533520,EventStack.cpp:204
Logging,31/10/2012,17:06:45:463,DEBUG,2990533520,dst=10.56.24.159:20514, msg=[<179>Oct 31 17:06:45 acs-yizaq-01 CSCOacs_Identity_Stores_Diagnostics 0000000746 1 0 2012-10-31 17:06:45.461 +02:00 0000000937 24003 ERROR External-LDAP: Cannot bind connection with anonymous credentials, ACSVersion=acs-5.4.0.41-B.223, ConfigVersionId=17, LdapIDStore=SecLdap, LdapServer=10.56.62.173, ], length=302,SyslogLogger.cpp:90

- verify CB setup

 set LDAP connection context on SSLConnection
Connection,31/10/2012,17:06:45:452,INFO ,3012201360,LdapSslConnectionContext::initSslSession: setting connection context on SSLConnection,LdapSslConnectionContext.cpp:43

- executing the callback
Fail b/c of wrong CA configure (should be CAforLDAP )

Connection,31/10/2012,17:06:45:461,ERROR,3012201360,LdapSslConnectionContext::checkCryptoResult(id = 512): error message = SSL alert: code=0x230=560 ; source=local ; type=fatal ; message="Unknown CA - error self-signed certificate in chain",LdapSslConnectionContext.cpp:215

- Fix CB signature to return int 


				1.1.5.1.3 2nd try

Server,01/11/2012,12:07:34:796,DEBUG,3012000656,cntx=0000000016,sesn=acs-yizaq-01/141138880/1,user=abergin,LdapServer::acquireConnection,LdapServer.cpp:658
State,01/11/2012,12:07:34:796,DEBUG,3012000656,LdapConnectionInitState::connect(id = -1),LdapConnectionStates.cpp:172
State,01/11/2012,12:07:34:796,DEBUG,3012000656,LdapConnectionOpeningState::onState(id = -1),LdapConnectionStates.cpp:187
Crypto,01/11/2012,12:07:34:796,DEBUG,3012000656,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.SSLConnection - first time initilizing connection ex-index to 0,SSLConnection.cpp:91
Crypto,01/11/2012,12:07:34:797,DEBUG,3012000656,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.SSLConnection - first time initilizing session ex-index to 0,SSLConnection.cpp:100
Crypto,01/11/2012,12:07:34:797,DEBUG,3012000656,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.SSLConnection - Setting client parameters,SSLConnection.cpp:153
Crypto,01/11/2012,12:07:34:797,DEBUG,3012000656,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.SSLConnection - Setting socket 512,SSLConnection.cpp:189
Connection,01/11/2012,12:07:34:797,INFO ,3012000656,LdapSslConnectionContext::initSslSession: setting connection context on SSLConnection,LdapSslConnectionContext.cpp:43
Connection,01/11/2012,12:07:34:798,INFO ,3012000656,LdapConnectionContext::openConnection(id = 512): connecting to 10.56.62.173:636,LdapConnectionContext.cpp:261
Connection,01/11/2012,12:07:34:798,INFO ,3012000656,LdapConnectionContext::openConnection(id = 512): connection is in progress,LdapConnectionContext.cpp:269
State,01/11/2012,12:07:34:799,INFO ,3012000656,LdapConnectionOpeningState::onOutput(id = 512): succeeded to establish connection,LdapConnectionStates.cpp:205
State,01/11/2012,12:07:34:799,DEBUG,3012000656,LdapConnectionOpenedState::onState(id = 512),LdapConnectionStates.cpp:245
State,01/11/2012,12:07:34:800,DEBUG,3012000656,LdapConnectionBindingState::onState(id = 512),LdapConnectionStates.cpp:353
Connection,01/11/2012,12:07:34:800,DEBUG,3012000656,LdapConnectionContext::sendBindRequest(id = 512): dn = anonymous,LdapConnectionContext.cpp:368
Crypto,01/11/2012,12:07:34:800,DEBUG,3012000656,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.writeData - nInDataSize=14, entity=client,SSLConnection.cpp:894
Crypto,01/11/2012,12:07:34:802,DEBUG,3012000656,NIL-CONTEXT,Crypto::Result=106, Crypto.SSLConnection.writeData - want read,SSLConnection.cpp:921
Crypto,01/11/2012,12:07:34:804,DEBUG,3012000656,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.writeData - nInDataSize=14, entity=client,SSLConnection.cpp:894
Crypto,01/11/2012,12:07:34:804,DEBUG,3012000656,NIL-CONTEXT,Crypto::Result=106, Crypto.SSLConnection.writeData - want read,SSLConnection.cpp:921
Crypto,01/11/2012,12:07:34:806,DEBUG,3012000656,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.writeData - nInDataSize=14, entity=client,SSLConnection.cpp:894
Crypto,01/11/2012,12:07:34:807,DEBUG,3012000656,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback,SSL.cpp:769
Crypto,01/11/2012,12:07:34:807,DEBUG,3012000656,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - current certificate=/C=IL/ST=State Or Province Name/L=Natania/O=Cisco/OU=PMBU/CN=cd-cam-bc/emailAddress=cd-cam-bc@cisco.com,SSL.cpp:782
Crypto,01/11/2012,12:07:34:807,DEBUG,3012000656,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - current certificate's issuer=/C=IL/ST=State Or Province Name/L=Natania/O=Cisco/OU=ACS Devision/CN=issuingCa_CAforLDAP/emailAddress=issuingCa_CAforLDAP@cisco.com,SSL.cpp:807
Crypto,01/11/2012,12:07:34:807,DEBUG,3012000656,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - OCSP check is off,SSL.cpp:1060
Crypto,01/11/2012,12:07:34:808,DEBUG,3012000656,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - final OCSP status is: OCSP status is unknown, continue to CRL,SSL.cpp:1076
Crypto,01/11/2012,12:07:34:808,DEBUG,3012000656,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.pvServerX509NotificationCB - x509Error 0, TLS notify 41,SSLConnection.cpp:3275
Crypto,01/11/2012,12:07:34:808,DEBUG,3012000656,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback,SSL.cpp:1098
Crypto,01/11/2012,12:07:34:808,DEBUG,3012000656,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/C=IL/ST=State Or Province Name/L=Natania/O=Cisco/OU=PMBU/CN=cd-cam-bc/emailAddress=cd-cam-bc@cisco.com, error=3,SSL.cpp:1132
Crypto,01/11/2012,12:07:34:808,DEBUG,3012000656,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/C=IL/ST=State Or Province Name/L=Natania/O=Cisco/OU=ACS Devision/CN=issuingCa_CAforLDAP/emailAddress=issuingCa_CAforLDAP@cisco.com,SSL.cpp:1144
Crypto,01/11/2012,12:07:34:808,DEBUG,3012000656,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=issuingCa_CAforLDAP, the issuer certificate found=1,SSL.cpp:1212
Crypto,01/11/2012,12:07:34:808,DEBUG,3012000656,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=issuingCa_CAforLDAP,SSL.cpp:1224
Crypto,01/11/2012,12:07:34:808,DEBUG,3012000656,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - Attempting to call LDAP server certificate validation callback,SSL.cpp:1293
Crypto,01/11/2012,12:07:34:808,DEBUG,3012000656,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - calling LDAP server certificate validation callback,SSL.cpp:1299

- Verify callback is set on SSL context
grep "LDAP server certificate check callback is set" /opt/CSCOacs/logs/acsRuntime.log
Crypto,01/11/2012,12:17:46:154,DEBUG,2998180752,NIL-CONTEXT,Crypto::Result=203, Crypto.SSLContext.init - LDAP server certificate check callback is set,SSLContext.cpp:651

- missing * in
grep "LDAP server certificate check callback is set" /opt/CSCOacs/logs/acsRuntime.log
Crypto,01/11/2012,12:17:46:154,DEBUG,2998180752,NIL-CONTEXT,Crypto::Result=203, Crypto.SSLContext.init - LDAP server certificate check callback is set,SSLContext.cpp:651


				1.1.5.1.4 3rd try

- logs: "c:\work\acs\5.5\features\CSCtw87143 LDAP server spoofing with valid certificate\logs"  ldap_auth.log

- success :) 
Crypto,06/11/2012,11:30:49:279,DEBUG,3011828624,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - Attempting to call LDAP server certificate validation callback,SSL.cpp:1293
Crypto,06/11/2012,11:30:49:279,DEBUG,3011828624,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - calling LDAP server certificate validation callback,SSL.cpp:1299
tlsLDAP_Cert_Check_CB,06/11/2012,11:30:49:279,DEBUG,3011828624,Received configured host name: 10.56.62.173,LdapSslContext.cpp:65

				1.1.5.1.5
			1.1.5.2 Test extraction of data from server certificate

				1.1.5.2.1 1st try
[yizaq@yizaq-WS:Tue Nov 13:/cygdrive/c/work/acs/5.5/features/CSCtw87143 LDAP server spoofing with valid certificate/logs:]$ grep tlsLDAP_Cert_Check_CB ldap_auth1.log
tlsLDAP_Cert_Check_CB,13/11/2012,15:41:54:818,DEBUG,3012774800,Received configured host name: 10.56.62.173, type IP Address,LdapSslContext.cpp:98
tlsLDAP_Cert_Check_CB,13/11/2012,15:41:54:818,WARN ,3012774800,Error getting peer certificate from SSL Connection; rc=39,LdapSslContext.cpp:107

Crypto,13/11/2012,15:41:54:867,DEBUG,3012774800,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - calling server certificate validation callback,SSL.cpp:1299
tlsLDAP_Cert_Check_CB,13/11/2012,15:41:54:867,DEBUG,3012774800,Received configured host name: 10.56.62.173, type IP Address,LdapSslContext.cpp:98
Crypto,13/11/2012,15:41:54:867,DEBUG,3012774800,NIL-CONTEXT,Crypto::Result=39, Crypto.SSLConnection.getPeerCertificate - Peer sent no certificate,SSLConnection.cpp:442
tlsLDAP_Cert_Check_CB,13/11/2012,15:41:54:867,WARN ,3012774800,Error getting peer certificate from SSL Connection; rc=39,LdapSslContext.cpp:107
Crypto,13/11/2012,15:41:54:869,DEBUG,3012774800,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback,SSL.cpp:1098
Crypto,13/11/2012,15:41:54:869,DEBUG,3012774800,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/C=IL/ST=State Or Province Name/L=Natania/O=Cisco/OU=ACS Devision/CN=issuingCa_CAforLDAP/emailAddress=issuingCa_CAforLDAP@cisco.com, error=3,SSL.cpp:1132
Crypto,13/11/2012,15:41:54:869,DEBUG,3012774800,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/C=IL/ST=State Or Province Name/L=Natania/O=Cisco/OU=ACS Devision/CN=policyCa_CAforLDAP/emailAddress=policyCa_CAforLDAP@cisco.com,SSL.cpp:1144
Crypto,13/11/2012,15:41:54:869,DEBUG,3012774800,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=policyCa_CAforLDAP, the issuer certificate found=1,SSL.cpp:1212
Crypto,13/11/2012,15:41:54:869,DEBUG,3012774800,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=policyCa_CAforLDAP,SSL.cpp:1224
Crypto,13/11/2012,15:41:54:869,DEBUG,3012774800,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - Attempting to call server certificate validation callback,SSL.cpp:1293
Crypto,13/11/2012,15:41:54:869,DEBUG,3012774800,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - calling server certificate validation callback,SSL.cpp:1299
tlsLDAP_Cert_Check_CB,13/11/2012,15:41:54:869,DEBUG,3012774800,Received configured host name: 10.56.62.173, type IP Address,LdapSslContext.cpp:98
Crypto,13/11/2012,15:41:54:869,DEBUG,3012774800,NIL-CONTEXT,Crypto::Result=39, Crypto.SSLConnection.getPeerCertificate - Peer sent no certificate,SSLConnection.cpp:442
tlsLDAP_Cert_Check_CB,13/11/2012,15:41:54:869,WARN ,3012774800,Error getting peer certificate from SSL Connection; rc=39,LdapSslContext.cpp:107
Crypto,13/11/2012,15:41:54:871,DEBUG,3012774800,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback,SSL.cpp:1098
Crypto,13/11/2012,15:41:54:871,DEBUG,3012774800,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/C=IL/ST=State Or Province Name/L=Natania/O=Cisco/OU=PMBU/CN=cd-cam-bc/emailAddress=cd-cam-bc@cisco.com, error=3,SSL.cpp:1132
Crypto,13/11/2012,15:41:54:871,DEBUG,3012774800,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/C=IL/ST=State Or Province Name/L=Natania/O=Cisco/OU=ACS Devision/CN=issuingCa_CAforLDAP/emailAddress=issuingCa_CAforLDAP@cisco.com,SSL.cpp:1144
Crypto,13/11/2012,15:41:54:871,DEBUG,3012774800,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=issuingCa_CAforLDAP, the issuer certificate found=1,SSL.cpp:1212
Crypto,13/11/2012,15:41:54:871,DEBUG,3012774800,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=issuingCa_CAforLDAP,SSL.cpp:1224
Crypto,13/11/2012,15:41:54:871,DEBUG,3012774800,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - Attempting to call server certificate validation callback,SSL.cpp:1293
Crypto,13/11/2012,15:41:54:871,DEBUG,3012774800,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - calling server certificate validation callback,SSL.cpp:1299
tlsLDAP_Cert_Check_CB,13/11/2012,15:41:54:871,DEBUG,3012774800,Received configured host name: 10.56.62.173, type IP Address,LdapSslContext.cpp:98
Crypto,13/11/2012,15:41:54:871,DEBUG,3012774800,NIL-CONTEXT,Crypto::Result=39, Crypto.SSLConnection.getPeerCertificate - Peer sent no certificate,SSLConnection.cpp:442

Error reason:
Crypto,13/11/2012,15:41:54:871,DEBUG,3012774800,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/C=IL/ST=State Or Province Name/L=Natania/O=Cisco/OU=PMBU/CN=cd-cam-bc/emailAddress=cd-cam-bc@cisco.com, error=3,SSL.cpp:1132

runtime/prebuilt/lnx26/include/openssl/x509_vfy.h
#define		X509_V_ERR_UNABLE_TO_GET_CRL			3

reason: client must set SSL_VERIFY_PEER flag on SSLContext of current connection. see ex:

      if(verify_server)
            SSL_CTX_set_verify(pCtx, SSL_VERIFY_PEER|SSL_VERIFY_FAIL_IF_NO_PEER_CERT, 0);
        else
            SSL_CTX_set_verify(pCtx, SSL_VERIFY_NONE, 0);

SSLInitParameters::VERIFY_PEER
SSLContext::init 
initParams.nInitOptions 


    // set the peer verification options
    if (m_nLibraryInitOptions & SSLInitParameters::VERIFY_PEER)
...
    g_pILog->logDebug(__FILE__,__LINE__, RESULT_OK,
                      "Crypto.SSLContext.init - Setting verification options 0x%X and callback", nVerifyFlags );
    SSL_CTX_set_verify( m_pSSL_CTX, nVerifyFlags, pfVerifyX509_CB );

logs:
[root@acs-yizaq-01 ~]# grep 'Crypto.SSLContext.init'  /opt/CSCOacs/logs/acsRuntime.log  
Crypto,13/11/2012,16:29:24:058,DEBUG,2997083024,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLContext.init,SSLContext.cpp:614
Crypto,13/11/2012,16:29:24:058,DEBUG,2997083024,NIL-CONTEXT,Crypto::Result=203, Crypto.SSLContext.init - server certificate check callback is set,SSLContext.cpp:651
Crypto,13/11/2012,16:29:24:058,DEBUG,2997083024,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLContext.init - Set SSL 2,3 client method,SSLContext.cpp:684
Crypto,13/11/2012,16:29:24:058,DEBUG,2997083024,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLContext.init - Set SSL options 0x1500FFF,SSLContext.cpp:732
Crypto,13/11/2012,16:29:24:058,DEBUG,2997083024,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLContext.init - Configuring Non-ADHP,SSLContext.cpp:799
Crypto,13/11/2012,16:29:24:058,DEBUG,2997083024,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLContext.init - Setting ACS default cipher-list,SSLContext.cpp:810
Crypto,13/11/2012,16:29:24:058,DEBUG,2997083024,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLContext.init - Cipher list being used: AES256-SHA+AES128-SHA+DHE-RSA-AES256-SHA+DHE-RSA-AES128-SHA+DES-CBC3-SHA+DHE-DSS-AES256-SHA+DHE-DSS-AES128-SHA+EDH-RSA-DES-CBC3-SHA+EDH-DSS-DES-CBC3-SHA+RC4-SHA+RC4-MD5+RC4-MD5+EDH-RSA-DES-CBC-SHA+EDH-DSS-DES-CBC-SHA+DES-CBC-SHA+EXP-EDH-RSA-DES-CBC-SHA+EXP-EDH-DSS-DES-CBC-SHA+EXP-DES-CBC-SHA+EXP-RC2-CBC-MD5+EXP-RC2-CBC-MD5+EXP-RC4-MD5+EXP-RC4-MD5,SSLContext.cpp:816
Crypto,13/11/2012,16:29:24:058,DEBUG,2997083024,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLContext.init - Examine peer verification,SSLContext.cpp:962
Crypto,13/11/2012,16:29:24:058,DEBUG,2997083024,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLContext.init - Setting verification to SSL_VERIFY_PEER + SSL_VERIFY_FAIL_IF_NO_PEER_CERT for non-ADHP,SSLContext.cpp:974
Crypto,13/11/2012,16:29:24:058,DEBUG,2997083024,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLContext.init - Setting X509 extended-verification callback,SSLContext.cpp:990
Crypto,13/11/2012,16:29:24:058,DEBUG,2997083024,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLContext.init - Setting to check X509 with flags 0xC,SSLContext.cpp:994
Crypto,13/11/2012,16:29:24:058,DEBUG,2997083024,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLContext.init - Setting verification options 0x3 and callback,SSLContext.cpp:1001
Crypto,13/11/2012,16:29:24:058,DEBUG,2997083024,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLContext.init - Done,SSLContext.cpp:1010

- capture traffic
[root@acs-yizaq-01 ~]# tcpdump -n -i eth0 -s 0 -w output.pcap 

[yizaq@yizaq-WS:Tue Nov 13:/cygdrive/c/work/acs/5.5/features/CSCtw87143 LDAP server spoofing with valid certificate/logs:]$ scp root@10.56.24.159:/root/output.pcap  output.pcap

- Problems found:
a. getPeerCertificate fails since at this point certificate is not yet stored on connection
b. x509ExceptionCallback is not the right place to plant the server certificate validation callback. It is wired to verify CB via SSL_CTX_set_verify which is only called for errors.
see spec:
http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html
SSL_CTX_set_verify(3)

    NAME
    SYNOPSIS
    DESCRIPTION
    NOTES
    BUGS
    RETURN VALUES
    EXAMPLES
    SEE ALSO 

NAME

SSL_CTX_set_verify, SSL_set_verify, SSL_CTX_set_verify_depth, SSL_set_verify_depth - set peer certificate verification parameters

SYNOPSIS

 #include <openssl/ssl.h>

 void SSL_CTX_set_verify(SSL_CTX *ctx, int mode,
                         int (*verify_callback)(int, X509_STORE_CTX *));
 void SSL_set_verify(SSL *s, int mode,
                     int (*verify_callback)(int, X509_STORE_CTX *));
 void SSL_CTX_set_verify_depth(SSL_CTX *ctx,int depth);
 void SSL_set_verify_depth(SSL *s, int depth);

 int verify_callback(int preverify_ok, X509_STORE_CTX *x509_ctx);

DESCRIPTION

SSL_CTX_set_verify() sets the verification flags for ctx to be mode and specifies the verify_callback function to be used. If no callback function shall be specified, the NULL pointer can be used for verify_callback.

SSL_set_verify() sets the verification flags for ssl to be mode and specifies the verify_callback function to be used. If no callback function shall be specified, the NULL pointer can be used for verify_callback. In this case last verify_callback set specifically for this ssl remains. If no special callback was set before, the default callback for the underlying ctx is used, that was valid at the time ssl was created with SSL_new(3).

SSL_CTX_set_verify_depth() sets the maximum depth for the certificate chain verification that shall be allowed for ctx. (See the BUGS section.)

SSL_set_verify_depth() sets the maximum depth for the certificate chain verification that shall be allowed for ssl. (See the BUGS section.)

NOTES

The verification of certificates can be controlled by a set of logically or'ed mode flags:

SSL_VERIFY_NONE

    Server mode: the server will not send a client certificate request to the client, so the client will not send a certificate.

    Client mode: if not using an anonymous cipher (by default disabled), the server will send a certificate which will be checked. The result of the certificate verification process can be checked after the TLS/SSL handshake using the SSL_get_verify_result(3) function. The handshake will be continued regardless of the verification result.
SSL_VERIFY_PEER

    Server mode: the server sends a client certificate request to the client. The certificate returned (if any) is checked. If the verification process fails, the TLS/SSL handshake is immediately terminated with an alert message containing the reason for the verification failure. The behaviour can be controlled by the additional SSL_VERIFY_FAIL_IF_NO_PEER_CERT and SSL_VERIFY_CLIENT_ONCE flags.

    Client mode: the server certificate is verified. If the verification process fails, the TLS/SSL handshake is immediately terminated with an alert message containing the reason for the verification failure. If no server certificate is sent, because an anonymous cipher is used, SSL_VERIFY_PEER is ignored.
SSL_VERIFY_FAIL_IF_NO_PEER_CERT

    Server mode: if the client did not return a certificate, the TLS/SSL handshake is immediately terminated with a ``handshake failure'' alert. This flag must be used together with SSL_VERIFY_PEER.

    Client mode: ignored
SSL_VERIFY_CLIENT_ONCE

    Server mode: only request a client certificate on the initial TLS/SSL handshake. Do not ask for a client certificate again in case of a renegotiation. This flag must be used together with SSL_VERIFY_PEER.

    Client mode: ignored

Exactly one of the mode flags SSL_VERIFY_NONE and SSL_VERIFY_PEER must be set at any time.

The actual verification procedure is performed either using the built-in verification procedure or using another application provided verification function set with SSL_CTX_set_cert_verify_callback(3). The following descriptions apply in the case of the built-in procedure. An application provided procedure also has access to the verify depth information and the verify_callback() function, but the way this information is used may be different.

SSL_CTX_set_verify_depth() and SSL_set_verify_depth() set the limit up to which depth certificates in a chain are used during the verification procedure. If the certificate chain is longer than allowed, the certificates above the limit are ignored. Error messages are generated as if these certificates would not be present, most likely a X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY will be issued. The depth count is ``level 0:peer certificate'', ``level 1: CA certificate'', ``level 2: higher level CA certificate'', and so on. Setting the maximum depth to 2 allows the levels 0, 1, and 2. The default depth limit is 9, allowing for the peer certificate and additional 9 CA certificates.

The verify_callback function is used to control the behaviour when the SSL_VERIFY_PEER flag is set. It must be supplied by the application and receives two arguments: preverify_ok indicates, whether the verification of the certificate in question was passed (preverify_ok=1) or not (preverify_ok=0). x509_ctx is a pointer to the complete context used for the certificate chain verification.

The certificate chain is checked starting with the deepest nesting level (the root CA certificate) and worked upward to the peer's certificate. At each level signatures and issuer attributes are checked. Whenever a verification error is found, the error number is stored in x509_ctx and verify_callback is called with preverify_ok=0. By applying X509_CTX_store_* functions verify_callback can locate the certificate in question and perform additional steps (see EXAMPLES). If no error is found for a certificate, verify_callback is called with preverify_ok=1 before advancing to the next level.

The return value of verify_callback controls the strategy of the further verification process. If verify_callback returns 0, the verification process is immediately stopped with ``verification failed'' state. If SSL_VERIFY_PEER is set, a verification failure alert is sent to the peer and the TLS/SSL handshake is terminated. If verify_callback returns 1, the verification process is continued. If verify_callback always returns 1, the TLS/SSL handshake will not be terminated with respect to verification failures and the connection will be established. The calling process can however retrieve the error code of the last verification error using SSL_get_verify_result(3) or by maintaining its own error storage managed by verify_callback.

If no verify_callback is specified, the default callback will be used. Its return value is identical to preverify_ok, so that any verification failure will lead to a termination of the TLS/SSL handshake with an alert message, if SSL_VERIFY_PEER is set. 

- Two alternatives for solution

a. Try to plant in the correct callback
http://www.openssl.org/docs/ssl/SSL_CTX_set_cert_verify_callback.html#
SSL_CTX_set_cert_verify_callback
	
SSL_CTX_set_cert_verify_callback(3)

    NAME
    SYNOPSIS
    DESCRIPTION
    NOTES
    WARNINGS
    BUGS
    RETURN VALUES
    SEE ALSO
    HISTORY 

NAME

SSL_CTX_set_cert_verify_callback - set peer certificate verification procedure

SYNOPSIS

 #include <openssl/ssl.h>

 void SSL_CTX_set_cert_verify_callback(SSL_CTX *ctx, int (*callback)(X509_STORE_CTX *,void *), void *arg);

DESCRIPTION

SSL_CTX_set_cert_verify_callback() sets the verification callback function for ctx. SSL objects that are created from ctx inherit the setting valid at the time when SSL_new(3) is called.

NOTES

Whenever a certificate is verified during a SSL/TLS handshake, a verification function is called. If the application does not explicitly specify a verification callback function, the built-in verification function is used. If a verification callback callback is specified via SSL_CTX_set_cert_verify_callback(), the supplied callback function is called instead. By setting callback to NULL, the default behaviour is restored.

When the verification must be performed, callback will be called with the arguments callback(X509_STORE_CTX *x509_store_ctx, void *arg). The argument arg is specified by the application when setting callback.

callback should return 1 to indicate verification success and 0 to indicate verification failure. If SSL_VERIFY_PEER is set and callback returns 0, the handshake will fail. As the verification procedure may allow to continue the connection in case of failure (by always returning 1) the verification result must be set in any case using the error member of x509_store_ctx so that the calling application will be informed about the detailed result of the verification procedure!

Within x509_store_ctx, callback has access to the verify_callback function set using SSL_CTX_set_verify(3).

WARNINGS

Do not mix the verification callback described in this function with the verify_callback function called during the verification process. The latter is set using the SSL_CTX_set_verify(3) family of functions.

Providing a complete verification procedure including certificate purpose settings etc is a complex task. The built-in procedure is quite powerful and in most cases it should be sufficient to modify its behaviour using the verify_callback function.

BUGS

RETURN VALUES

SSL_CTX_set_cert_verify_callback() does not provide diagnostic information.

SEE ALSO

ssl(3), SSL_CTX_set_verify(3), SSL_get_verify_result(3), SSL_CTX_load_verify_locations(3) 

- 

				1.1.5.2.2 2nd try

/cygdrive/c/work/acs/5.5/features/CSCtw87143 LDAP server spoofing with valid certificate/logs/ldap_spoof_test.log

Crypto,10/12/2012,10:07:46:566,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.pvServerX509NotificationCB - x509Error 0, TLS notify 41,SSLConnection.cpp:3275
Crypto,10/12/2012,10:07:46:566,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback, CryptoLib custom certificate verification callback, called with preverify_ok value 0,SSL.cpp:1098
Crypto,10/12/2012,10:07:46:566,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/C=IL/ST=State Or Province Name/L=Natania/O=Cisco/OU=PMBU/CN=cd-cam-bc/emailAddress=cd-cam-bc@cisco.com, error=3,SSL.cpp:1132
Crypto,10/12/2012,10:07:46:566,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/C=IL/ST=State Or Province Name/L=Natania/O=Cisco/OU=ACS Devision/CN=issuingCa_CAforLDAP/emailAddress=issuingCa_CAforLDAP@cisco.com,SSL.cpp:1144
Crypto,10/12/2012,10:07:46:566,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=issuingCa_CAforLDAP, the issuer certificate found=1,SSL.cpp:1212
Crypto,10/12/2012,10:07:46:566,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=issuingCa_CAforLDAP,SSL.cpp:1224
Crypto,10/12/2012,10:07:46:566,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: 0,SSL.cpp:1294
Crypto,10/12/2012,10:07:46:566,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - Proceeding to further server certificate checks,SSL.cpp:1297
Crypto,10/12/2012,10:07:46:566,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - calling server certificate validation callback,SSL.cpp:1311
tlsLDAP_Cert_Check_CB,10/12/2012,10:07:46:566,DEBUG,3006163856,Received configured host name: 10.56.62.173, type IP Address,LdapSslContext.cpp:104
tlsLDAP_Cert_Check_CB,10/12/2012,10:07:46:566,DEBUG,3006163856,Extracted server certificate:
subject: E=cd-cam-bc@cisco.com,CN=cd-cam-bc,OU=PMBU,O=Cisco,L=Natania,S=State Or Province Name,C=IL
serial number: f)
CN: cd-cam-bc,LdapSslContext.cpp:140
Crypto,10/12/2012,10:07:46:566,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback,SSL.cpp:769
Crypto,10/12/2012,10:07:46:566,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - current certificate=/C=IL/ST=State Or Province Name/L=Natania/O=Cisco/OU=ACS Devision/CN=issuingCa_CAforLDAP/emailAddress=issuingCa_CAforLDAP@cisco.com,SSL.cpp:782
Crypto,10/12/2012,10:07:46:567,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - current certificate's issuer=/C=IL/ST=State Or Province Name/L=Natania/O=Cisco/OU=ACS Devision/CN=policyCa_CAforLDAP/emailAddress=policyCa_CAforLDAP@cisco.com,SSL.cpp:807
Crypto,10/12/2012,10:07:46:567,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - OCSP check is off,SSL.cpp:1060
Crypto,10/12/2012,10:07:46:567,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - final OCSP status is: OCSP status is unknown, continue to CRL,SSL.cpp:1076
Crypto,10/12/2012,10:07:46:567,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.pvServerX509NotificationCB - x509Error 3, TLS notify 41,SSLConnection.cpp:3275
Crypto,10/12/2012,10:07:46:567,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback, CryptoLib custom certificate verification callback, called with preverify_ok value 0,SSL.cpp:1098
Crypto,10/12/2012,10:07:46:567,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/C=IL/ST=State Or Province Name/L=Natania/O=Cisco/OU=ACS Devision/CN=issuingCa_CAforLDAP/emailAddress=issuingCa_CAforLDAP@cisco.com, error=3,SSL.cpp:1132
Crypto,10/12/2012,10:07:46:567,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/C=IL/ST=State Or Province Name/L=Natania/O=Cisco/OU=ACS Devision/CN=policyCa_CAforLDAP/emailAddress=policyCa_CAforLDAP@cisco.com,SSL.cpp:1144
Crypto,10/12/2012,10:07:46:567,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=policyCa_CAforLDAP, the issuer certificate found=1,SSL.cpp:1212
Crypto,10/12/2012,10:07:46:567,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=policyCa_CAforLDAP,SSL.cpp:1224
Crypto,10/12/2012,10:07:46:567,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: 1,SSL.cpp:1294
Crypto,10/12/2012,10:07:46:567,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback,SSL.cpp:769
Crypto,10/12/2012,10:07:46:567,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - current certificate=/C=IL/ST=State Or Province Name/L=Natania/O=Cisco/OU=ACS Devision/CN=policyCa_CAforLDAP/emailAddress=policyCa_CAforLDAP@cisco.com,SSL.cpp:782
Crypto,10/12/2012,10:07:46:567,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - current certificate's issuer=/C=IL/ST=State Or Provice Name/L=Natania/O=Cisco Systems./OU=ISE, Identity Division/CN=CAforLDAP/emailAddress=CAforLDAP@cisco.com,SSL.cpp:807
Crypto,10/12/2012,10:07:46:567,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - OCSP check is off,SSL.cpp:1060
Crypto,10/12/2012,10:07:46:567,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - final OCSP status is: OCSP status is unknown, continue to CRL,SSL.cpp:1076
Crypto,10/12/2012,10:07:46:567,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.pvServerX509NotificationCB - x509Error 3, TLS notify 41,SSLConnection.cpp:3275
Crypto,10/12/2012,10:07:46:568,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/C=IL/ST=State Or Province Name/L=Natania/O=Cisco/OU=ACS Devision/CN=policyCa_CAforLDAP/emailAddress=policyCa_CAforLDAP@cisco.com, error=3,SSL.cpp:1132
Crypto,10/12/2012,10:07:46:568,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/C=IL/ST=State Or Provice Name/L=Natania/O=Cisco Systems./OU=ISE, Identity Division/CN=CAforLDAP/emailAddress=CAforLDAP@cisco.com,SSL.cpp:1144
Crypto,10/12/2012,10:07:46:568,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=CAforLDAP, the issuer certificate found=1,SSL.cpp:1212
Crypto,10/12/2012,10:07:46:568,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=CAforLDAP,SSL.cpp:1224
Crypto,10/12/2012,10:07:46:568,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: 2,SSL.cpp:1294
Crypto,10/12/2012,10:07:46:568,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback,SSL.cpp:769
Crypto,10/12/2012,10:07:46:568,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - current certificate=/C=IL/ST=State Or Provice Name/L=Natania/O=Cisco Systems./OU=ISE, Identity Division/CN=CAforLDAP/emailAddress=CAforLDAP@cisco.com,SSL.cpp:782
Crypto,10/12/2012,10:07:46:568,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - current certificate's issuer=/C=IL/ST=State Or Provice Name/L=Natania/O=Cisco Systems./OU=ISE, Identity Division/CN=CAforLDAP/emailAddress=CAforLDAP@cisco.com,SSL.cpp:807
Crypto,10/12/2012,10:07:46:568,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - OCSP check is off,SSL.cpp:1060
Crypto,10/12/2012,10:07:46:568,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - final OCSP status is: OCSP status is unknown, continue to CRL,SSL.cpp:1076
Crypto,10/12/2012,10:07:46:568,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.pvServerX509NotificationCB - x509Error 3, TLS notify 41,SSLConnection.cpp:3275
Crypto,10/12/2012,10:07:46:568,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback, CryptoLib custom certificate verification callback, called with preverify_ok value 0,SSL.cpp:1098
Crypto,10/12/2012,10:07:46:568,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/C=IL/ST=State Or Provice Name/L=Natania/O=Cisco Systems./OU=ISE, Identity Division/CN=CAforLDAP/emailAddress=CAforLDAP@cisco.com, error=3,SSL.cpp:1132
Crypto,10/12/2012,10:07:46:568,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/C=IL/ST=State Or Provice Name/L=Natania/O=Cisco Systems./OU=ISE, Identity Division/CN=CAforLDAP/emailAddress=CAforLDAP@cisco.com,SSL.cpp:1144
Crypto,10/12/2012,10:07:46:568,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=CAforLDAP, the issuer certificate found=1,SSL.cpp:1212
Crypto,10/12/2012,10:07:46:568,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=CAforLDAP,SSL.cpp:1224
Crypto,10/12/2012,10:07:46:568,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: 3,SSL.cpp:1294
Crypto,10/12/2012,10:07:46:569,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback, CryptoLib custom certificate verification callback, called with preverify_ok value 1,SSL.cpp:1098
Crypto,10/12/2012,10:07:46:569,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/C=IL/ST=State Or Provice Name/L=Natania/O=Cisco Systems./OU=ISE, Identity Division/CN=CAforLDAP/emailAddress=CAforLDAP@cisco.com, error=3,SSL.cpp:1132
Crypto,10/12/2012,10:07:46:569,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/C=IL/ST=State Or Provice Name/L=Natania/O=Cisco Systems./OU=ISE, Identity Division/CN=CAforLDAP/emailAddress=CAforLDAP@cisco.com,SSL.cpp:1144
Crypto,10/12/2012,10:07:46:569,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=CAforLDAP, the issuer certificate found=1,SSL.cpp:1212
Crypto,10/12/2012,10:07:46:569,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=CAforLDAP,SSL.cpp:1224
Crypto,10/12/2012,10:07:46:569,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: 3,SSL.cpp:1294
Crypto,10/12/2012,10:07:46:570,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback, CryptoLib custom certificate verification callback, called with preverify_ok value 1,SSL.cpp:1098
Crypto,10/12/2012,10:07:46:570,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/C=IL/ST=State Or Province Name/L=Natania/O=Cisco/OU=ACS Devision/CN=policyCa_CAforLDAP/emailAddress=policyCa_CAforLDAP@cisco.com, error=3,SSL.cpp:1132
Crypto,10/12/2012,10:07:46:570,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/C=IL/ST=State Or Provice Name/L=Natania/O=Cisco Systems./OU=ISE, Identity Division/CN=CAforLDAP/emailAddress=CAforLDAP@cisco.com,SSL.cpp:1144
Crypto,10/12/2012,10:07:46:570,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=CAforLDAP, the issuer certificate found=1,SSL.cpp:1212
Crypto,10/12/2012,10:07:46:570,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=CAforLDAP,SSL.cpp:1224
Crypto,10/12/2012,10:07:46:570,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: 2,SSL.cpp:1294
Crypto,10/12/2012,10:07:46:571,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback, CryptoLib custom certificate verification callback, called with preverify_ok value 1,SSL.cpp:1098
Crypto,10/12/2012,10:07:46:571,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/C=IL/ST=State Or Province Name/L=Natania/O=Cisco/OU=ACS Devision/CN=issuingCa_CAforLDAP/emailAddress=issuingCa_CAforLDAP@cisco.com, error=3,SSL.cpp:1132
Crypto,10/12/2012,10:07:46:571,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/C=IL/ST=State Or Province Name/L=Natania/O=Cisco/OU=ACS Devision/CN=policyCa_CAforLDAP/emailAddress=policyCa_CAforLDAP@cisco.com,SSL.cpp:1144
Crypto,10/12/2012,10:07:46:571,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=policyCa_CAforLDAP, the issuer certificate found=1,SSL.cpp:1212
Crypto,10/12/2012,10:07:46:571,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=policyCa_CAforLDAP,SSL.cpp:1224
Crypto,10/12/2012,10:07:46:571,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: 1,SSL.cpp:1294
Crypto,10/12/2012,10:07:46:572,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback, CryptoLib custom certificate verification callback, called with preverify_ok value 1,SSL.cpp:1098
Crypto,10/12/2012,10:07:46:572,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/C=IL/ST=State Or Province Name/L=Natania/O=Cisco/OU=PMBU/CN=cd-cam-bc/emailAddress=cd-cam-bc@cisco.com, error=3,SSL.cpp:1132
Crypto,10/12/2012,10:07:46:572,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/C=IL/ST=State Or Province Name/L=Natania/O=Cisco/OU=ACS Devision/CN=issuingCa_CAforLDAP/emailAddress=issuingCa_CAforLDAP@cisco.com,SSL.cpp:1144
Crypto,10/12/2012,10:07:46:572,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=issuingCa_CAforLDAP, the issuer certificate found=1,SSL.cpp:1212
Crypto,10/12/2012,10:07:46:572,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=issuingCa_CAforLDAP,SSL.cpp:1224
Crypto,10/12/2012,10:07:46:572,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: 0,SSL.cpp:1294
Crypto,10/12/2012,10:07:46:572,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - Proceeding to further server certificate checks,SSL.cpp:1297
Crypto,10/12/2012,10:07:46:572,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - calling server certificate validation callback,SSL.cpp:1311
tlsLDAP_Cert_Check_CB,10/12/2012,10:07:46:572,DEBUG,3006163856,Received configured host name: 10.56.62.173, type IP Address,LdapSslContext.cpp:104
tlsLDAP_Cert_Check_CB,10/12/2012,10:07:46:572,DEBUG,3006163856,Extracted server certificate:
subject: E=cd-cam-bc@cisco.com,CN=cd-cam-bc,OU=PMBU,O=Cisco,L=Natania,S=State Or Province Name,C=IL
serial number: f)
CN: cd-cam-bc,LdapSslContext.cpp:140
Crypto,10/12/2012,10:07:46:589,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.writeData - nInDataSize=14, entity=client,SSLConnection.cpp:894
Crypto,10/12/2012,10:07:46:590,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.writeData - success,SSLConnection.cpp:1000
Crypto,10/12/2012,10:07:46:591,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.readData - nInDataSize=0, entity=client,SSLConnection.cpp:767
Crypto,10/12/2012,10:07:46:591,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.readData - output-size=14,SSLConnection.cpp:848
Connection,10/12/2012,10:07:46:591,DEBUG,3006163856,LdapBindResponse::update: bind result = 0 (Success),LdapConnectionResponses.cpp:108
Connection,10/12/2012,10:07:46:591,DEBUG,3006163856,LdapBindResponse::update: password policy control is not returned by the server,LdapConnectionResponses.cpp:139
State,10/12/2012,10:07:46:591,DEBUG,3006163856,LdapConnectionBindingState::onInput(id = 512): bind succeeded,LdapConnectionStates.cpp:447
State,10/12/2012,10:07:46:591,DEBUG,3006163856,LdapConnectionBoundState::onState(id = 512),LdapConnectionStates.cpp:469
Server,10/12/2012,10:07:46:591,DEBUG,3006163856,cntx=0000016290,sesn=vinson1/144180479/4,user=abergin,LdapServer::onAcquireConnectionResponse: succeeded to acquire connection,LdapServer.cpp:698
Logging,10/12/2012,10:07:46:592,INFO ,3006163856,Request for configuration 0xace1b650 of version: 20,LoggingConfiguration.cpp:712
State,10/12/2012,10:07:46:592,DEBUG,3006163856,LdapConnectionBoundState::search(id = 512),LdapConnectionStates.cpp:478
Connection,10/12/2012,10:07:46:592,DEBUG,3006163856,LdapConnectionContext::sendSearchRequest(id = 512): base = dc=test,dc=ru, filter = (&(objectclass=Person)(uid=abergin)),LdapConnectionContext.cpp:393
Crypto,10/12/2012,10:07:46:592,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.writeData - nInDataSize=84, entity=client,SSLConnection.cpp:894
Crypto,10/12/2012,10:07:46:592,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.writeData - success,SSLConnection.cpp:1000
State,10/12/2012,10:07:46:592,DEBUG,3006163856,LdapSearchingState::onState(id = 512),LdapConnectionStates.cpp:535
Crypto,10/12/2012,10:07:46:595,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.readData - nInDataSize=0, entity=client,SSLConnection.cpp:767
Crypto,10/12/2012,10:07:46:595,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.readData - output-size=46,SSLConnection.cpp:848
Crypto,10/12/2012,10:07:46:595,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.readData - nInDataSize=0, entity=client,SSLConnection.cpp:767
Crypto,10/12/2012,10:07:46:595,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.readData - output-size=14,SSLConnection.cpp:848
State,10/12/2012,10:07:46:595,DEBUG,3006163856,LdapSearchingState::onInput(id = 512): search finished,LdapConnectionStates.cpp:581
State,10/12/2012,10:07:46:595,DEBUG,3006163856,LdapConnectionBoundState::onState(id = 512),LdapConnectionStates.cpp:469
Logging,10/12/2012,10:07:46:595,INFO ,3006163856,Request for configuration 0xace1b650 of version: 20,LoggingConfiguration.cpp:712
Server,10/12/2012,10:07:46:595,DEBUG,3006163856,cntx=0000016290,sesn=vinson1/144180479/4,user=abergin,LdapSubjectSearchAssistant::processAttributes: found uid=abergin,ou=People,dc=test,dc=ru entry matching abergin subject,LdapSubjectSearchAssistant.cpp:202
Server,10/12/2012,10:07:46:596,DEBUG,3006163856,cntx=0000016290,sesn=vinson1/144180479/4,user=abergin,LdapServer::acquireConnection,LdapServer.cpp:658
State,10/12/2012,10:07:46:596,DEBUG,3006163856,LdapConnectionInitState::connect(id = -1),LdapConnectionStates.cpp:172
State,10/12/2012,10:07:46:596,DEBUG,3006163856,LdapConnectionOpeningState::onState(id = -1),LdapConnectionStates.cpp:187
Crypto,10/12/2012,10:07:46:596,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.SSLConnection - Setting client parameters,SSLConnection.cpp:153
Crypto,10/12/2012,10:07:46:596,DEBUG,3006163856,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.SSLConnection - Setting socket 513,SSLConnection.cpp:189
Connection,10/12/2012,10:07:46:596,INFO ,3006163856,LdapSslConnectionContext::initSslSession: setting connection context on SSLConnection,LdapSslConnectionContext.cpp:43
Connection,10/12/2012,10:07:46:596,INFO ,3006163856,LdapConnectionContext::openConnection(id = 513): connecting to 10.56.62.173:636,LdapConnectionContext.cpp:261
Connection,10/12/2012,10:07:46:596,INFO ,3006163856,LdapConnectionContext::openConnection(id = 513): connection is in progress,LdapConnectionContext.cpp:269
State,10/12/2012,10:07:46:597,INFO ,3006163856,LdapConnectionOpeningState::onOutput(id = 513): succeeded to establish connection,LdapConnectionStates.cpp:205
State,10/12/2012,10:07:46:597,DEBUG,3006163856,LdapConnectionOpenedState::onState(id = 513),LdapConnectionStates.cpp:245


- depth 0 - Server certificate, tlsLDAP_Cert_Check_CB() extracts it well. getSANs() seems not to work well. check!

				1.1.5.2.3
			1.1.5.3  Full coverage

One SAN DNS exact-match positive and negative
One SAN DNS wildcard-match positive and negative
>One SAN DNS exact-match positive and negative
>One SAN DNS wildcard-match positive and negative
One SAN IP exact-match positive and negative
>One SAN IP exact-match positive and negative
CN DNS exact-match positive and negative
CN DNS wildcard-match positive and negative
CN IP exact-match positive and negative


		1.1.6 Code review

			1.1.6.1 change set Wed 01/02/2013 
================================================================================
||            Activity  Information                                             
================================================================================
|| Stream:    yizaq_5_5_dev.int.acs5_0                   
================================================================================
|| View:      yizaq__yizaq_5_5_dev.int.acs5_0.lx                   
================================================================================
|| Activity:  yizaq_CSCtw87143_LDAP_Spoofing                 
================================================================================
|| Files:     /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapServerConfig.cpp
/vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslConnectionContext.cpp
/vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslConnectionContext.h
/vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslContext.cpp
/vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslContext.h
/vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/Certificate.cpp
/vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/Certificate.h
/vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSLContext.cpp
/vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSLContext.h
/vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSL.cpp
/vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSLInterface.h                 

"c:\work\acs\5.5\features\CSCtw87143 LDAP server spoofing with valid certificate\src\yizaq_CSCtw87143_LDAP_Spoofing_srcs.tar.bz2" 
Usage: ct_diff_act_txt <act>, ex: Phase2Bugs2 will search on vob @/vob/nmtgre_proj
Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapServerConfig.cpp
68c68
<         m_pSslContext = new LdapSslContext (); 
---
>         m_pSslContext = new LdapSslContext; 
71d70
<         m_pSslContext->setConnectionConfig(m_connection);
Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslConnectionContext.cpp
42,44d41
< 
<         m_log.log_msg(__FILE__, __LINE__, AcsDebugLog::INFO, "LdapSslConnectionContext::initSslSession: setting connection context on SSLConnection");
<         m_pSslConnection->setConnectionUserData((void *) &m_sslContext);
260,261d256
< 
< 
Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslConnectionContext.h
67d66
< 
Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslContext.cpp
15,18d14
< #include <sys/socket.h>
< #include <netinet/in.h>
< #include <arpa/inet.h>
< 
36,226d31
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  LdapSslContext :: getConnectionConfig
<  * Description:  return ConfigLDAPConnectionAdapter member
<  *--------------------------------------------------------------------------------------
<  */
< const ConfigLDAPConnectionAdapter & LdapSslContext::getConnectionConfig() const
< {
<         return m_ConfigConnection;
< }
< 
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  LdapSslContext :: setConnectionConfig
<  * Description:  return ConfigLDAPConnectionAdapter member
<  *--------------------------------------------------------------------------------------
<  */
< void LdapSslContext::setConnectionConfig(ConfigLDAPConnectionAdapter & cfg)
< {
<         m_ConfigConnection = cfg;
< }
< 
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  tlsLDAP_Cert_Check_CB
<  * Description:  
<  *     When ACS performs user authentication/authorization (attribute/group retrieval) against LDAP server it is susceptible to a spoofing attack.
<  *     LDAP server can be spoofed if an attacker has the ability to establish rogue LDAP server using a real LDAP server IP address (which can be achieved by another attack on the network) and have a valid certificate issued by the same CA as valid LDAP server certificate.
<  *     ACS is required to perform identify verification on the LDAP server's certificate according to rfc-4513 - Lightweight Directory Access Protocol (LDAP): Authentication Methods and Security Mechanisms.
<  *     The identity verification consists of:					
<  *     1. Check format of hostname in LDAP configuration and classify it as either DNS or IPv4.
<  *     	1.1 If DNS format then extract host name and domain
<  *     2. From incoming server certificate extract the names from x509 SUBJECT_ALT_NAME section 
<  *     3. Iterate over the list acquired in step 2. 
<  *     	3.1 If current alt. name is of DNS type and step 1 classification is DNS then compare both host names. If they are equal then flag successful verification and stop checking further.
<  *     	3.2 If current alt. name is of DNS type and step 1 classification is DNS then check for '*' prefix (wildcard). If so, do two sanity checks: a. 2nd character of alt. name is '.'. ; and b. The lengths match; 
<  *   After the sanity checks compare the domain parts and if matches then flag successful verification and stop checking further.
<  *     	3.3 If current alt. name is of IPv4 type and step 1 classification is IPv4 then compare both host names IP addresses. If they are equal then flag successful verification and stop checking further.
<  *     4. If no x509 SUBJECT_ALT_NAME section is found then extract the CN 
<  *     	4.1 If CN is equal to the LDAP configuration hostname then flag successful verification, if not then
<  *     	4.2 check for '*' prefix (wildcard). If so, do two sanity checks: a. 2nd character of alt. name is '.'. ; and b. The lengths match; 
<  *   After the sanity checks compare the domain parts and if matches then flag successful verification and stop checking further.
<  *     5. If all previous checks have failed then flag failed verification
<  * author: yizaq 
<  *--------------------------------------------------------------------------------------
<  */
< int LdapSslContext::tlsLDAP_Cert_Check_CB(Crypto::ISSLConnection* pSSLConnection, Crypto::TLS_NOTIFY nTlsNotify, void* param)
< {
< 	AcsDebugLog TempLogger ("Acs.RT.idstores.LDAP.SSLContext.tlsLDAP_Cert_Check_CB");
<     //TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Checking server certificate validity against the configured host name: %s", m_hostname.c_str() );
< 
<     if (param == NULL )
<     {
<         TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::ERR, "Error getting peer certificate");
<         return 1;
<     }
< 
<     if ( pSSLConnection )
<     {
<        Crypto::TypesOfSAN h_type = Crypto::SAN_TYPE_DNS; // default to DNS
<        LdapSslContext * pLSC = (LdapSslContext *) pSSLConnection->getConnectionUserData(); 
<        string s_hostname = pLSC->getConnectionConfig().hostName();
<        string s_domain_name ;
<        string s_cert_host ;
< 
<        struct in_addr addr;
<        if (inet_aton(s_hostname.c_str(), (struct in_addr *)&addr)) h_type = Crypto::SAN_TYPE_IP_ADDR;
< 
<        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Received configured host name: %s, type %s",s_hostname.c_str(), h_type == Crypto::SAN_TYPE_DNS ? "DNS" : "IP Address");
< 
<        if (h_type == Crypto::SAN_TYPE_DNS)  
<        {
<            s_domain_name = s_hostname.substr(s_hostname.find('.')); 
<            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Extracted domain: %s",s_domain_name.c_str());
<        }
<        
<    	    Crypto::Result rc = Crypto::RESULT_OK;
<         Crypto::ICertificateManager* pCertMgr = Crypto::getCertificateManagerInterface();
<         if (!pCertMgr)
<         {
<            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::ERR, "Error - failed receiving the cryptographic certificate manager");
<            return 1;
<         }
<         Crypto::ICertificate *pCertificate = NULL;
<         rc = pCertMgr->createCertificate(&pCertificate, param);
<         if (rc != Crypto::RESULT_OK)
<         {
< 
<            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::WARN, "Error initilizing certificate from X509 pointer; rc=%d", rc);
<             return 1;
<         }
<         else // We have a valid certificate
<         {
<            char   sCertField[4096];
<            size_t iCertFieldSize= 0 ;
< 
< 
<            std::vector<Crypto::SAN_GeneralName> vec;
<            rc= pCertificate->getSANs(vec, Crypto::SAN_TYPE_ANY);
<            unsigned int uiSAN_ctr = 0;
<            for (std::vector<Crypto::SAN_GeneralName>::iterator i = vec.begin(); i!= vec.end(); ++i)
<            {
< 
<                s_cert_host = (*i).san_value;
<                TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Extracted SAN field number %d, value %s, type %d", uiSAN_ctr, s_cert_host.c_str(),  (*i).san_type);
< 
<                if ((*i).san_type == Crypto::SAN_TYPE_DNS) {
<                    if (h_type != Crypto::SAN_TYPE_DNS ) continue;
< 
<                    //check exact match
<                    if (s_cert_host == s_hostname )
<                                    {
< 
<                                        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared DNS format host names with exact match");
<                                        return 0;
<                                    }
< 
<                    //check wildcard match
<                    				if ( ( !s_domain_name.empty() ) && s_cert_host[0] == '*' && s_cert_host[1] == '.' && s_domain_name.length() == s_cert_host.length() -1 && (s_domain_name == s_cert_host.substr(1)) ) {
< 
<                                        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared DNS format host names to wildcard expression");
<                                        return 0;
<                                 }
<                    }
<                else if ((*i).san_type == Crypto::SAN_TYPE_IP_ADDR) {
< 
<                    if (h_type != Crypto::SAN_TYPE_IP_ADDR ) continue;
< 
<                    if ( ( s_cert_host.end() - s_cert_host.begin() == sizeof (struct in_addr) ) && ( !memcmp (s_cert_host.data(), &addr, sizeof (struct in_addr)) ) )
<                                    {
<                                        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared IP address format host names ");
<                                        return 0;
< 
<                                    }
<                }
<                        
<            } //for (std::vector<Crypto::SAN_GeneralName>::iterator i = vec.begin(); i!= vec.end(); ++i)
< 
<            iCertFieldSize = sizeof(sCertField) ; memset(sCertField,0,iCertFieldSize ) ;
<            rc= pCertificate->getSerialNumber((unsigned char*)sCertField,&iCertFieldSize );
<            string sCertSerialNumber = sCertField;
< 
<            iCertFieldSize = sizeof(sCertField) ; memset(sCertField,0,iCertFieldSize ) ;
<            rc= pCertificate->getSubject((char*)sCertField,&iCertFieldSize );
<            string sCertSubject = sCertField;
< 
<            iCertFieldSize = sizeof(sCertField) ; memset(sCertField,0,iCertFieldSize ) ;
<            rc= pCertificate->getSubjectCN((char*)sCertField,&iCertFieldSize );
<            string sCertSubjectCN = sCertField;
< 
<            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Extracted server certificate:\nsubject: %s\nserial number: %s\nCN: %s", sCertSubject.c_str(), sCertSerialNumber.c_str(), sCertSubjectCN.c_str());
< 
<            if ( rc==Crypto::RESULT_OK )
<            {
<                TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "CN field found. Checking match...");
< 
<                //check exact match
<                if (sCertSubjectCN == s_hostname )
<                        {
< 
<                            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared CN host name with exact match");
<                            return 0;
<                        }
< 
<                //check wildcard match
<                		if ( ( !s_domain_name.empty() ) && sCertSubjectCN[0] == '*' && sCertSubjectCN[1] == '.' && s_domain_name.length() == sCertSubjectCN.length() -1 && (s_domain_name == sCertSubjectCN) ) {
< 
<                            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared CN host name to wildcard expression");
<                            return 0;
<                     }
<                    
<            }
<            else
<            {
<                TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "CN field not found.");
<            }
<         } //else 
<     }// if ( pSSLConnection )
<     else
<     {
< 
<        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::WARN, "Did not receive a valid SSLConnection object");
<         return 1;
<     }
< 
<     return 1;
< }
< 
262,264d66
< 
<     //set server certificate validation callback
<     clientParams.fnTlsServer_CertCheckCB =  LdapSslContext::tlsLDAP_Cert_Check_CB;
Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslContext.h
8d7
< #include <string>
12d10
< #include "LdapDefinitions.h"
17d14
< using namespace std;
46,64d42
< 
<     /*
<      *--------------------------------------------------------------------------------------
<      *       Class:  LdapSslContext
<      *      Method:  LdapSslContext :: getConnectionConfig
<      * Description:  return ConfigLDAPConnectionAdapter member
<      *--------------------------------------------------------------------------------------
<      */
<      const ConfigLDAPConnectionAdapter & getConnectionConfig() const;
< 
<     /*
<      *--------------------------------------------------------------------------------------
<      *       Class:  LdapSslContext
<      *      Method:  LdapSslContext :: setConnectionConfig
<      * Description:  return ConfigLDAPConnectionAdapter member
<      *--------------------------------------------------------------------------------------
<      */
<      void setConnectionConfig(ConfigLDAPConnectionAdapter & cfg);
< 
83,90d60
<     /* 
<      * ===  FUNCTION  ======================================================================
<      *         Name:   tlsLDAP_Cert_Check_CB
<      *  Description:   LDAP certificate spoofing check callback
<      * =====================================================================================
<      */
<     static int tlsLDAP_Cert_Check_CB(Crypto::ISSLConnection* pSSLConnection, Crypto::TLS_NOTIFY nTlsNotify, void* param );
< 
93,94d62
<     ConfigLDAPConnectionAdapter m_ConfigConnection;
< 
Diff of file /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/Certificate.cpp
16d15
<   Modified: Thu Nov  8 11:13:27 IST 2012, yizaq: Enhance getSAN to return all SAN fields & add support for IP address type
21a21
> #include <string.h>
45d44
< using namespace std;
53,58d51
< SAN_GeneralName::SAN_GeneralName(std::string value, TypesOfSAN type) :
<                san_value(value),
<                san_type(type) 
< {
< }
< 
1871c1864,1866
< Result  Certificate::getSAN( OUT char* pResult, INOUT size_t* pnResultSize, OUT TypesOfSAN *pType, IN bool bGetLast, IN TypesOfSAN requestedTypeOfSAN ) const 
---
> Result  Certificate::getSAN( OUT char* pResult, INOUT size_t* pnResultSize, 
>                              OUT TypesOfSAN *pType, 
>                              IN bool bGetLast, IN TypesOfSAN requestedTypeOfSAN ) const 
2024,2183d2018
<     return RESULT_OK;     
< }
< 
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  Certificate
<  *      Method:  Certificate :: getSANs
<  * Description:  return full list of SAN names
<  * Author:       yizaq
<  *--------------------------------------------------------------------------------------
<  */
< Result  Certificate::getSANs( OUT vector<SAN_GeneralName> & vec , IN TypesOfSAN requestedTypeOfSAN ) const 
< {
<     g_pILog->logDebug(__FILE__,__LINE__, RESULT_OK, "Crypto.Certificate::getSANs - Extracting SAN fields");
< 
<     Result rc = RESULT_OK ;
< 
<     if ( m_pX509==NULL)
<     {
<         rc= RESULT_NOT_INITIALIZED ;
<         g_pILog->logError(__FILE__,__LINE__, rc, "Crypto.Certificate::getSANs - Not initialized");
<         return rc ;
<     }
< 
<     bool bFound= false ;
<     std::string result = "" ;
<     TypesOfSAN resultType = SAN_TYPE_NONE ;
< 
<     STACK_OF(GENERAL_NAME) *pGeneralNames = NULL;
< 
<     // Get the subject-alternative-name extension
<     pGeneralNames= (STACK*)X509_get_ext_d2i(m_pX509, NID_subject_alt_name, NULL, NULL) ;
< 
<     if (pGeneralNames)
<     {
<         int     i, r;
< 
<         int         type = 0 ; 
<         int         asn1type = 0 ; 
<         void        *pData = NULL ;
<         int         len= 0 ;
<         TypesOfSAN  typeOfSAN ;
< 
<         // parse to find the first known type of extension
<         r = sk_GENERAL_NAME_num(pGeneralNames) ;
<         g_pILog->logDebug(__FILE__,__LINE__, RESULT_ERROR, "Found %d SANs in Certificate");
< 
<         for ( i=0 ; i<r ; ++i )
<         {
<             GENERAL_NAME *gn = sk_GENERAL_NAME_value(pGeneralNames, i);
< 
<             if ( gn==NULL )
<                 continue;
< 
<             type= gn->type ;
<             asn1type = 0 ; 
<             pData = NULL ;
<             len= 0 ;
<             typeOfSAN= SAN_TYPE_NONE ;
< 
<             switch ( type )
<             {
<             case GEN_EMAIL:
<                 if( gn->d.uniformResourceIdentifier==NULL || gn->d.uniformResourceIdentifier->data==NULL )
<                     break;
<                 pData= gn->d.uniformResourceIdentifier->data ;
<                 len= gn->d.uniformResourceIdentifier->length ;
<                 asn1type= gn->d.uniformResourceIdentifier->type ;
<                 typeOfSAN= Crypto::SAN_TYPE_EMAIL ;
<                 break;
<             case GEN_URI:
<                 if( gn->d.ia5==NULL || gn->d.ia5->data==NULL)
<                     break;
<                 pData= gn->d.ia5->data ;
<                 len= gn->d.ia5->length ;
<                 asn1type= gn->d.ia5->type ;
<                 typeOfSAN= Crypto::SAN_TYPE_URI ;
<                 break;;
<             case GEN_DNS:
<                 g_pILog->logDebug(__FILE__,__LINE__, RESULT_OK, "Crypto.Certificate::getSANs - Parsing SAN DNS type = %d", asn1type);
<                 if( gn->d.dNSName==NULL || gn->d.dNSName->data==NULL )
<                     break;
<                 pData= gn->d.dNSName->data ;
<                 len= gn->d.dNSName->length ;
<                 asn1type= gn->d.dNSName->type ;
<                 typeOfSAN= Crypto::SAN_TYPE_DNS ;
<                 break;
<             case GEN_OTHERNAME:
<                 if( gn->d.otherName==NULL || gn->d.otherName->value==NULL || gn->d.otherName->value->value.ia5string==NULL ||
<                     gn->d.otherName->value->value.ia5string->data==NULL )
<                     break;
<                 pData= gn->d.otherName->value->value.ia5string->data ; 
<                 len= gn->d.otherName->value->value.ia5string->length ;
<                 asn1type= gn->d.otherName->value->value.ia5string->type ;
<                 typeOfSAN= Crypto::SAN_TYPE_OTHER ;
<                 break;
<             case GEN_IPADD:
<                 g_pILog->logDebug(__FILE__,__LINE__, RESULT_OK, "Crypto.Certificate::getSANs - Parsing SAN IP address type = %d", asn1type);
<                 if( gn->d.iPAddress==NULL || gn->d.iPAddress->data==NULL )
<                     break;
<                 pData= gn->d.iPAddress->data ;
<                 len= gn->d.iPAddress->length ;
<                 asn1type= gn->d.iPAddress->type ;
<                 typeOfSAN= Crypto::SAN_TYPE_DNS ;
<                 break;
<             default:
<                 g_pILog->logWarn(__FILE__,__LINE__, RESULT_ERROR,
<                                  "Crypto.Certificate::getSANs - Unsupported SAN name parsed (skipping): asn1type=%d",
<                                  asn1type );
<                 break;
<             }
< 
<             // printf( "$$$ type=%d => data=[%s] len=%d asn1type=%d $$$\n", type, pData?(char*)pData:"", len, asn1type ) ;
< 
<             if ( pData==NULL )
<             {
<                 GENERAL_NAME_free(gn) ;
<                 continue;
<             }
< 
<             //  g_pILog->logDebug(__FILE__,__LINE__, RESULT_OK,
<             //                    "Crypto.Certificate::getSANs - len=%d, strlen=%d, pData=\"%s\", asn1type=%d", 
<             //                    len, strlen((char*)pData), pData, asn1type);
<             if ( len>0 && strlen((char*)pData)==(size_t)len && 
<                  (asn1type==V_ASN1_UTF8STRING || asn1type==V_ASN1_IA5STRING || asn1type==V_ASN1_OCTET_STRING) )
<             {
<                 if( (!bFound ) && (requestedTypeOfSAN==SAN_TYPE_ANY || requestedTypeOfSAN==typeOfSAN) )
<                 {
<                     // Return the SAN
<                     resultType= typeOfSAN ;
<                     result= std::string((const char*)pData,(size_t)len) ;
<                     bFound= true ;
<                     if( result.size()<=0)
<                     {
<                          g_pILog->logWarn(__FILE__,__LINE__, RESULT_OK,"Crypto.Certificate::getSANs - Note, received SAN extension with empty name");
<                     }
< 
<                     vec.push_back(SAN_GeneralName(result, resultType));
<                     g_pILog->logDebug(__FILE__,__LINE__, RESULT_OK, "Crypto.Certificate::getSANs - Adding SAN to vector of SAN fields. Value %s, type %d", vec.back().san_value.c_str(), vec.back().san_type  );
<                 }
<             }
<             else
<             {
<                 g_pILog->logWarn(__FILE__,__LINE__, RESULT_ERROR,
<                                  "Crypto.Certificate::getSANs - Improper SAN name parsed (skipping): type=%d data=\"%s\" len=%d asn1type=%d",
<                                  type, pData, len, asn1type );
<             }
< 
<             GENERAL_NAME_free(gn) ;
< 
<         } // for ( i=0 ; i<r ; ++i )
< 
<         sk_GENERAL_NAME_free(pGeneralNames);
<     }
<     else
<     {
<                 g_pILog->logDebug(__FILE__,__LINE__, RESULT_ERROR, "SAN field not found in Certificate");
< 
<     }
< 
Diff of file /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/Certificate.h
30d29
< 
33d31
< 
77,78c75,77
<         virtual Result  getSAN                  ( OUT char* pResult, INOUT size_t* pnResultSize, OUT TypesOfSAN *pType, IN bool bGetLast, IN TypesOfSAN requestedTypeOfSAN ) const ;
<         virtual Result  getSANs                  ( OUT std::vector<SAN_GeneralName> & vec , IN TypesOfSAN requestedTypeOfSAN ) const ;
---
>         virtual Result  getSAN                  ( OUT char* pResult, INOUT size_t* pnResultSize, 
>                                                   OUT TypesOfSAN *pType, 
>                                                   IN bool bGetLast, IN TypesOfSAN requestedTypeOfSAN ) const ;
Diff of file /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSLContext.cpp
644,654d643
<     if (pSSLInitParams->fnTlsServer_CertCheckCB==NULL )
<     {
<         g_pILog->logDebug(__FILE__,__LINE__, RESULT_INVALID_INPUT, "Crypto.SSLContext.init - server certificate check callback is not set");
<         //return RESULT_INVALID_INPUT;
<     }
<     else // could just cont. w/o else but this way more robust (i.e. return removed)
<     {
<         g_pILog->logDebug(__FILE__,__LINE__, RESULT_INVALID_INPUT, "Crypto.SSLContext.init - server certificate check callback is set");
<         m_fnTlsServer_CertCheckCB = pSSLInitParams->fnTlsServer_CertCheckCB ;
<     }
< 
1480,1484d1468
< }
< 
< tls_server_cert_check_cb_fn SSLContext::getTlsServer_CertCheckCB() const 
< { 
<     return m_fnTlsServer_CertCheckCB;
Diff of file /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSLContext.h
72d71
<         tls_server_cert_check_cb_fn     getTlsServer_CertCheckCB() const;
140d138
<         tls_server_cert_check_cb_fn                     m_fnTlsServer_CertCheckCB;
Diff of file /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSL.cpp
1098c1098
<     g_pILog->logDebug(__FILE__, __LINE__, RESULT_OK, "CryptoLib.CSSL.x509ExceptionCallback, CryptoLib custom certificate verification callback, called with preverify_ok value %d", nOK);
---
>     g_pILog->logDebug(__FILE__, __LINE__, RESULT_OK, "CryptoLib.CSSL.x509ExceptionCallback");
1289,1318d1288
<     }
< 
<         // Call LDAP certificate validation callback
< 
<     int depth = X509_STORE_CTX_get_error_depth(pX509StoreCtx);
<     g_pILog->logDebug(__FILE__, __LINE__, RESULT_OK, "CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: %d", depth);
<     if (depth == 0) // Peer/server cert
<     {
<         g_pILog->logDebug(__FILE__, __LINE__, RESULT_OK, "CryptoLib.CSSL.x509ExceptionCallback - Proceeding to further server certificate checks");
< 
<         X509 * pCert = X509_STORE_CTX_get_current_cert(pX509StoreCtx);
<         if (pCert == NULL)
<         {
<             g_pILog->logWarn(__FILE__, __LINE__, RESULT_CANT_FIND_CERT, "Crypto.CSSL.x509ExceptionCallback - Failed to get current certificate=%d", pX509StoreCtx->error);
<             return;
<         }
< 
<         SSLConnection* pSSLConnection = (SSLConnection*)SSL_get_ex_data(pSSL, SSL_get_ex_data_X509_STORE_CTX_idx());
<         if (pSSLConnection!=NULL)
<         {
< 	        if (pSSLConnection->getContext()->getTlsServer_CertCheckCB())
< 	        {
<                 g_pILog->logDebug(__FILE__, __LINE__, RESULT_OK, "CryptoLib.CSSL.x509ExceptionCallback - calling server certificate validation callback");
< 	        	(* (* (pSSLConnection->getContext() )).getTlsServer_CertCheckCB()) (pSSLConnection, TLS_NOTIFY_READ_CERTIFICATE_VERIFY, (void *) pCert) ;
< 	        }
<         else
<             {
<                 g_pILog->logWarn(__FILE__, __LINE__, RESULT_OK, "CryptoLib.CSSL.x509ExceptionCallback - calling server certificate validation callback failed because no valid SSLConnection could be found");
<             }
<         }
Diff of file /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSLInterface.h
23,29d22
<     enum TypesOfSAN
<     {
<         SAN_TYPE_NONE = 0,
<         SAN_TYPE_ANY = 0,
<         SAN_TYPE_DNS,
<         SAN_TYPE_EMAIL,
<         SAN_TYPE_URI,
30d22
<         SAN_TYPE_IP_ADDR,
31,34d22
<         SAN_TYPE_OTHER,
<     };
< 
< 
35,41d22
<     struct SAN_GeneralName
<     {
<        SAN_GeneralName(std::string value, TypesOfSAN type);
<        std::string san_value;
<        TypesOfSAN san_type;
<     };
< 
159,161d139
<     
<     // LDAP driven certificate spoofing check callback
<     typedef int (*tls_server_cert_check_cb_fn)(IN ISSLConnection* pSSLConnection, IN Crypto::TLS_NOTIFY nTlsNotify, IN void* param);
241d218
<         tls_server_cert_check_cb_fn     fnTlsServer_CertCheckCB;
365d341
<         virtual tls_server_cert_check_cb_fn       getTlsServer_CertCheckCB() const = 0;
562a539,545
>     enum TypesOfSAN
>     {
>         SAN_TYPE_NONE = 0,
>         SAN_TYPE_ANY = 0,
>         SAN_TYPE_DNS,
>         SAN_TYPE_EMAIL,
>         SAN_TYPE_URI,
562a546,549
>         SAN_TYPE_OTHER,
>     };
> 
> 
613,615c600,603
<         virtual Result  getSAN                  ( OUT char* pResult, INOUT size_t* pnResultSize, OUT TypesOfSAN *pType, IN bool bGetLast=false, IN TypesOfSAN requestedTypeOfSAN=SAN_TYPE_ANY ) const = 0;
<         // return a vector of all SAN names
<         virtual Result  getSANs                  ( OUT std::vector<SAN_GeneralName> & vec , IN TypesOfSAN requestedTypeOfSAN ) const =0;
---
>         virtual Result  getSAN                  ( OUT char* pResult, INOUT size_t* pnResultSize, 
>                                                   OUT TypesOfSAN *pType, 
>                                                   IN bool bGetLast=false,
>                                                   IN TypesOfSAN requestedTypeOfSAN=SAN_TYPE_ANY ) const = 0; 

"
			1.1.6.2 emails

				1.1.6.2.1  Sasha

inline

Thanks!
Yosi

From: Yosi Izaq (yizaq) 
Sent: Wednesday, January 02, 2013 6:18 PM
To: Alexander Shabanov (ashabano); Sergey Emantayev (semantay)
Subject: RE: Code review - CSCtw87143 LDAP Spoofing

One more comment:
-	Make optional, w/ checkbox in LDAP config page and default not to perform test.
In progress?

Thanks,
Yosi

From: Alexander Shabanov (ashabano) 
Sent: Wednesday, January 02, 201

3 5:16 PM
To: Yosi Izaq (yizaq); Sergey Emantayev (semantay)
Subject: RE: Code review - CSCtw87143 LDAP Spoofing

Hi Yosi,

Here are my comments:
|   1.	Certificate::getSANs code duplicates a lot of the code from Certificate::getSAN? Can we refactor the code and reuse the code efficiently?
|   Yes. Due to time constraints it will be postponed.
|   2.	BTW, both existing Certificate::getSAN and new Certificate::getSANs seem to be very long.
|   Yes. As above.
|   3.	[Important] The next 'if' seems problematic in some cases:
|               if ( len>0 && strlen((char*)pData)==(size_t)len && 
|                    (asn1type==V_ASN1_UTF8STRING || asn1type==V_ASN1_IA5STRING || asn1type==V_ASN1_OCTET_STRING) )
|   Order changed.
|   Strlen is ok. See http://www.openssl.org/docs/crypto/ASN1_STRING_length.html
|   4.	 [Important] CSSL::x509ExceptionCallback ignores return code of getTlsServer_CertCheckCB. In other words Cert Check is ignored / missed.
|   Wasn't added at the time of CR. Now handled.
|   5.	Change severity to debug for the next log because there will be normal SSL sessions (e.g. EAP-TLS) without CertCheckCB:
|   g_pILog->logWarn(__FILE__, __LINE__, RESULT_OK, "CryptoLib.CSSL.x509ExceptionCallback - calling server certificate validation callback failed because no valid SSLConnection could be found");
|   done
|   LdapSslContext comments:
|   6.	[Important] LdapSslContext::tlsLDAP_Cert_Check_CB allocates pCertificate but does not free it.
|   Done!
|   7.	The next code is problematic when hostname is short hostname without DNS suffix.
|          if (h_type == Crypto::SAN_TYPE_DNS)  
|          {
|              s_domain_name = s_hostname.substr(s_hostname.find('.')); 
|              TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Extracted domain: %s",s_domain_name.c_str());
|          }
|   Fixed
|   8.	You may pass Crypto::SAN_TYPE_DNS or Crypto::SAN_TYPE_IP_ADDR according to h_type
|   rc= pCertificate->getSANs(vec, Crypto::SAN_TYPE_ANY);
|   This will simplify and optimize a code a bit.
|   For debug purposes I want to fully parse SAN general names.
|   9.	If you prepend "*" to s_domain_name (can be done only once when you extract it) then you can write
|   If (s_domain_name) instead of
|   If ( ( !s_domain_name.empty() ) && s_cert_host[0] == '*' && s_cert_host[1] == '.' && s_domain_name.length() == s_cert_host.length() -1 && (s_domain_name == s_cert_host.substr(1)) )
|   Also if/check against sCertSubjectCN can be simplified.
|   Yes. This will rearrange the ifs but the checks will remain (is empty?, length match etc).
|   10.	If you do not use rc from the next calls please remove 'rc ='
|   rc= pCertificate->getSerialNumber((unsigned char*)sCertField,&iCertFieldSize );
|   rc= pCertificate->getSubject((char*)sCertField,&iCertFieldSize );
|   Fixed


Thanks,
Sasha

				1.1.6.2.2 Sergey

			1.1.6.3

		1.1.7 Odds and ends

			1.1.7.1  Add control checkbox
- IM PRRQ: http://wwwin-tools.cisco.com/prrq/viewReview.do?queueName=ACS_5_4_System_Specs&bugId=DRRaa25877 11:50 AM 
- IM: http://acs-build1-lnx/auto/acs/acsmodel_il/20/Indexs/indexLeft.html 11:52 AM 

Please add a new field enableServerIdentityCheck to LDAPConnection 
type: boolean
default: true
upgrade default: false

			1.1.7.2

		1.1.8 final tests

- Package CA chain 
<URL:/cygdrive/c/work/KB/Network/sslKB#r=__bundle_certs__>
			1.1.8.1  SAN IP Negative

subject:
OU = ACS
O = Cisco
L = Natania
S = State
C = IL
CN = ACS_LDAP_Server
San:
DNS Name=acsldap01.acs.com
IP Address=1.2.3.7
URL=aso

				1.1.8.1.1  1st try

Crypto,10/03/2013,12:25:17:365,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=106, Crypto.SSLConnection.writeData - want read,SSLConnection.cpp:921
Crypto,10/03/2013,12:25:17:368,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.writeData - nInDataSize=14, entity=client,SSLConnection.cpp:894
Crypto,10/03/2013,12:25:17:368,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=106, Crypto.SSLConnection.writeData - want read,SSLConnection.cpp:921
Crypto,10/03/2013,12:25:17:368,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.writeData - nInDataSize=14, entity=client,SSLConnection.cpp:894
Crypto,10/03/2013,12:25:17:369,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback,SSL.cpp:745
Crypto,10/03/2013,12:25:17:369,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - current certificate=/CN=ACS_LDAP_Server/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS,SSL.cpp:758
Crypto,10/03/2013,12:25:17:369,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - current certificate's issuer=/CN=ACS_IssuingCAforLDAP/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS,SSL.cpp:783
Crypto,10/03/2013,12:25:17:369,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - OCSP check is off,SSL.cpp:1036
Crypto,10/03/2013,12:25:17:369,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - final OCSP status is: OCSP status is unknown, continue to CRL,SSL.cpp:1052
Crypto,10/03/2013,12:25:17:369,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.pvServerX509NotificationCB - x509Error 0, TLS notify 41,SSLConnection.cpp:3275
Crypto,10/03/2013,12:25:17:369,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback, CryptoLib custom certificate verification callback, called with preverify_ok value 0,SSL.cpp:1074
Crypto,10/03/2013,12:25:17:369,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/CN=ACS_LDAP_Server/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS, error=3,SSL.cpp:1108
Crypto,10/03/2013,12:25:17:369,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/CN=ACS_IssuingCAforLDAP/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS,SSL.cpp:1120
Crypto,10/03/2013,12:25:17:369,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=ACS_IssuingCAforLDAP, the issuer certificate found=1,SSL.cpp:1188
Crypto,10/03/2013,12:25:17:369,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=ACS_IssuingCAforLDAP,SSL.cpp:1200
Crypto,10/03/2013,12:25:17:369,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: 0,SSL.cpp:1270
Crypto,10/03/2013,12:25:17:369,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - Proceeding to further server certificate checks,SSL.cpp:1273
Crypto,10/03/2013,12:25:17:369,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - calling server certificate validation callback,SSL.cpp:1287
tlsLDAP_Cert_Check_CB,10/03/2013,12:25:17:370,DEBUG,3047644048,Received configured host name: cd-acs-ldap01.north.auto.acs.com, type DNS,LdapSslContext.cpp:115
tlsLDAP_Cert_Check_CB,10/03/2013,12:25:17:370,DEBUG,3047644048,Extracted domain: .north.auto.acs.com,LdapSslContext.cpp:122
Crypto,10/03/2013,12:25:17:370,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Extracting SAN fields,Certificate.cpp:2039
Crypto,10/03/2013,12:25:17:370,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=1, Found 85 SANs in Certificate,Certificate.cpp:2070
Crypto,10/03/2013,12:25:17:370,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Parsing SAN DNS type = 0,Certificate.cpp:2104
Crypto,10/03/2013,12:25:17:370,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN to vector of SAN fields. Value acsldap01.acs.com, type 1,Certificate.cpp:2161
Crypto,10/03/2013,12:25:17:370,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Parsing SAN IP address type = 0,Certificate.cpp:2122
Crypto,10/03/2013,12:25:17:370,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN to vector of SAN fields. Value ^A^B^C^G, type 1,Certificate.cpp:2161
tlsLDAP_Cert_Check_CB,10/03/2013,12:25:17:370,DEBUG,3047644048,Extracted SAN field number 0, value acsldap01.acs.com, type 1,LdapSslContext.cpp:162
tlsLDAP_Cert_Check_CB,10/03/2013,12:25:17:370,DEBUG,3047644048,Extracted SAN field number 0, value ^A^B^C^G, type 1,LdapSslContext.cpp:162
tlsLDAP_Cert_Check_CB,10/03/2013,12:25:17:370,DEBUG,3047644048,Extracted server certificate:
subject: OU=ACS,O=Cisco,L=Natania,S=State,C=IL,CN=ACS_LDAP_Server
serial number: c^O<9b>
CN: ACS_LDAP_Server,LdapSslContext.cpp:211
tlsLDAP_Cert_Check_CB,10/03/2013,12:25:17:370,DEBUG,3047644048,CN field found. Checking match...,LdapSslContext.cpp:215
tlsLDAP_Cert_Check_CB,10/03/2013,12:25:17:370,WARN ,3047644048,Server certificate check has failed.,LdapSslContext.cpp:249
Crypto,10/03/2013,12:25:17:370,DEBUG,3047644048,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - server certificate validation has failed.,SSL.cpp:1290
Crypto,10/03/2013,12:25:17:370,WARN ,3047644048,NIL-CONTEXT,Crypto::Result=1, Crypto.SSLConnection.pvClientInfoCB - Alert raised: code=0x230=560, where=0x4008=16392, source=local,SSLConnection.cpp:2723
Crypto,10/03/2013,12:25:17:370,WARN ,3047644048,NIL-CONTEXT,Crypto::Result=102, Crypto.SSLConnection.writeData - failed write the data,SSLConnection.cpp:933
Connection,10/03/2013,12:25:17:370,ERROR,3047644048,LdapSslConnectionContext::checkCryptoResult(id = 512): crypto result = 102,LdapSslConnectionContext.cpp:206
Connection,10/03/2013,12:25:17:370,ERROR,3047644048,LdapSslConnectionContext::checkCryptoResult(id = 512): error message = SSL alert: code=0x230=560 ; source=local ; type=fatal ; message="Unknown CA - Unable to get CRL",LdapSslConnectionContext.cpp:215

				1.1.8.1.2 2nd try
- RT logs
Crypto,18/03/2013,17:16:59:825,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback, CryptoLib custom certificate verification callback, called with preverify_ok value 0,SSL.cpp:1074
EventHandler,18/03/2013,17:16:59:825,DEBUG,3081763728,Stack: 0x9e2b170 Destroy stack,EventStack.cpp:37
Crypto,18/03/2013,17:16:59:826,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/CN=ACS_LDAP_Server/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS, error=3,SSL.cpp:1108
Crypto,18/03/2013,17:16:59:826,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/CN=ACS_IssuingCAforLDAP/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS,SSL.cpp:1120
Crypto,18/03/2013,17:16:59:826,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=ACS_IssuingCAforLDAP, the issuer certificate found=1,SSL.cpp:1188
Crypto,18/03/2013,17:16:59:826,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=ACS_IssuingCAforLDAP,SSL.cpp:1200
Crypto,18/03/2013,17:16:59:826,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: 0,SSL.cpp:1270
Crypto,18/03/2013,17:16:59:826,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - Proceeding to further server certificate checks,SSL.cpp:1273
Crypto,18/03/2013,17:16:59:826,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - calling server certificate validation callback,SSL.cpp:1287
Crypto,18/03/2013,17:16:59:826,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - checking match for cd-acs-ldap01.north.auto.acs.com,SSLConnection.cpp:3287
Crypto,18/03/2013,17:16:59:826,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Received configured host name: cd-acs-ldap01.north.auto.acs.com, type DNS,SSLConnection.cpp:3299
Crypto,18/03/2013,17:16:59:826,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted domain: .north.auto.acs.com,SSLConnection.cpp:3306
Crypto,18/03/2013,17:16:59:826,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Extracting SAN fields,Certificate.cpp:2040
Crypto,18/03/2013,17:16:59:826,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=1, Crypto.Certificate::getSANs - Found 2 SANs in Certificate,Certificate.cpp:2073
Crypto,18/03/2013,17:16:59:826,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Parsing SAN DNS type = 0,Certificate.cpp:2107
Crypto,18/03/2013,17:16:59:826,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - storing SAN value...,Certificate.cpp:2155
Crypto,18/03/2013,17:16:59:826,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Converting SAN to string...,Certificate.cpp:2166
Crypto,18/03/2013,17:16:59:826,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN to vector of SAN fields. Value acsldap01.acs.com, type 1,Certificate.cpp:2178
Crypto,18/03/2013,17:16:59:826,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Parsing SAN IP address type = 0,Certificate.cpp:2125
Crypto,18/03/2013,17:16:59:826,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - storing SAN value...,Certificate.cpp:2155
Crypto,18/03/2013,17:16:59:826,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Converting SAN IP address to string...,Certificate.cpp:2159
Crypto,18/03/2013,17:16:59:826,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN IP address 1.2.3.7,Certificate.cpp:2161
Crypto,18/03/2013,17:16:59:826,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN to vector of SAN fields. Value 1.2.3.7, type 4,Certificate.cpp:2178
Crypto,18/03/2013,17:16:59:826,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted SAN field number 0, value acsldap01.acs.com, type 1,SSLConnection.cpp:3325
Crypto,18/03/2013,17:16:59:826,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted SAN field number 1, value 1.2.3.7, type 4,SSLConnection.cpp:3325
Crypto,18/03/2013,17:16:59:826,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted server certificate:
subject: OU=ACS,O=Cisco,L=Natania,S=State,C=IL,CN=ACS_LDAP_Server
serial number: c�
CN: ACS_LDAP_Server,SSLConnection.cpp:3377
Crypto,18/03/2013,17:16:59:827,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - CN field found. Checking match...,SSLConnection.cpp:3381
Crypto,18/03/2013,17:16:59:827,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - server certificate validation has failed.,SSL.cpp:1290
Crypto,18/03/2013,17:16:59:827,WARN ,3044952976,NIL-CONTEXT,Crypto::Result=1, Crypto.SSLConnection.pvClientInfoCB - Alert raised: code=0x230=560, where=0x4008=16392, source=local,SSLConnection.cpp:2724
Crypto,18/03/2013,17:16:59:827,WARN ,3044952976,NIL-CONTEXT,Crypto::Result=102, Crypto.SSLConnection.writeData - failed write the data,SSLConnection.cpp:934
Connection,18/03/2013,17:16:59:827,ERROR,3044952976,LdapSslConnectionContext::checkCryptoResult(id = 512): crypto result = 102,LdapSslConnectionContext.cpp:206
Connection,18/03/2013,17:16:59:827,ERROR,3044952976,LdapSslConnectionContext::checkCryptoResult(id = 512): error message = SSL alert: code=0x230=560 ; source=local ; type=fatal ; message="Unknown CA - Unable to get CRL",LdapSslConnectionContext.cpp:215
Crypto,18/03/2013,17:16:59:827,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.pvDone,SSLConnection.cpp:248
Crypto,18/03/2013,17:16:59:827,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.pvDone - removing session from cache,SSLConnection.cpp:294
Connection,18/03/2013,17:16:59:827,DEBUG,3044952976,LdapConnectionContext::closeConnection(id = 512): close the socket,LdapConnectionContext.cpp:163
State,18/03/2013,17:16:59:827,DEBUG,3044952976,LdapConnectionInitState::onState(id = -1),LdapConnectionStates.cpp:163
Server,18/03/2013,17:16:59:827,ERROR,3044952976,cntx=0000000031,sesn=vinson1/152994088/1,user=abergin,LdapServer::onAcquireConnectionResponse: failed to acquire connection,LdapServer.cpp:704

									- View report
AAA Protocol > RADIUS Authentication Detail
ACS session ID : 
	
vinson1/152994088/1
Date : 
	
March 18, 2013
Generated on March 18, 2013 5:30:06 PM IST
	
Authentication Summary
Logged At:
	
March 18,2013 5:16:59.873 PM
RADIUS Status:
	RADIUS Request dropped : 24030 SSL connection error was encountered
NAS Failure:
	
Username:
	abergin
MAC/IP Address:
	11
Network Device:
	device : 10.56.63.69 : 89
Access Service:
	Default Network Access
Identity Store:
	
SecLdap
Authorization Profiles:
	
 
CTS Security Group:
	
 
Authentication Method:
	
PAP_ASCII
	
Actions
Troubleshoot Authentication Opens in new window
View Diagnostic Messages
Audit Network Device Configuration Opens in new window
View Network Device Configuration Opens in new window
View ACS Configuration Changes
Authentication Result
RadiusPacketType=Drop
 AuthenticationResult=Error
Session Events
Mar 18,13 5:16:59.873 PM
	
Radius authentication failed for USER: abergin  MAC: 11  AUTHTYPE:
	
Radius authentication failed
Authentication Details
Logged At:
	
March 18,2013 5:16:59.873 PM
ACS Time:
	
March 18,2013 5:16:59.830 PM
ACS Instance:
	vinson1
Authentication Method:
	
PAP_ASCII
EAP Authentication Method :
	
 
EAP Tunnel Method :
	
 
User
ACS Username:
	abergin
RADIUS Username :
	
abergin
Calling Station ID:
	11
Framed IP Address:
	
 
Host Lookup:
	
 
Network Device
Network Device:
	device
Network Device Groups:
	
Device Type:All Device Types
Location:All Locations
NAS IP Address:
	10.56.63.69
NAS Identifier:
	
56
NAS Port:
	
2
NAS Port ID:
	89
NAS Port Type:
	
Sync
Access Policy
Access Service:
	Default Network Access
Identity Store:
	
SecLdap
Authorization Profiles:
	
 
Exception Authorization Profiles:
	
 
Active Directory Domain:
	
 
Identity Group:
	
 
Access Service Selection Matched Rule:
	
Rule-1
Identity Policy Matched Rule:
	
Default
Selected Identity Stores:
	
SecLdap
Query Identity Stores:
	
 
Selected Query Identity Stores:
	
 
Group Mapping Policy Matched Rule:
	
 
Authorization Policy Matched Rule:
	
 
Authorization Exception Policy Matched Rule:
	
 
CTS
CTS Security Group:
	
 
Other
ACS Session ID:
	
vinson1/152994088/1
Audit Session ID:
	
 
Tunnel Details:
	
 
H323 Attributes:
	
 
SSG Attributes:
	
 
Cisco-AVPairs:
	
 
Other Attributes:
	
ACSVersion=acs-5.5.0.6-B.447 
ConfigVersionId=3 
Device Port=62928 
RadiusPacketType=AccessRequest 
Protocol=Radius 
Called-Station-ID=11 
DetailedInfo=SSL alert
code=0x230=560 ; source=local ; type=fatal ; message="Unknown CA - Unable to get CRL" 
Device IP Address=64.103.126.90
Steps
11001  Received RADIUS Access-Request
11017  RADIUS created a new session
Evaluating Service Selection Policy
15004  Matched rule
15012  Selected Access Service - Default Network Access
Evaluating Identity Policy
15006  Matched Default Rule
15013  Selected Identity Store - SecLdap
24031  Sending request to primary LDAP server
24015  Authenticating user against LDAP Server
24030  SSL connection error was encountered
22059  The advanced option that is configured for process failure is used.
22062  The 'Drop' advanced option is configured in case of a failed authentication request.

				1.1.8.1.3

			1.1.8.2 SAN IP Positive 

subject:
OU = ACS
O = Cisco
L = Natania
S = State
C = IL
CN = ACS_LDAP_Server
San:
DNS Name=acsldap01.acs.com
IP Address=10.56.62.173

logs: "c:\work\acs\5.5\features\CSCtw87143 LDAP server spoofing with valid certificate\logs\Multi_SAN_positive_IPv4\ACS_RT_ldap_rep.log"
/cygdrive/c/work/acs/5.5/features/CSCtw87143\ LDAP\ server\ spoofing\ with\ valid\ certificate/logs/Multi_SAN_positive_IPv4/ACS_RT_ldap_rep.log
excerpt:
Crypto,19/03/2013,16:34:39:551,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/CN=ACS_CAforLDAP/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS,SSL.cpp:1120
Crypto,19/03/2013,16:34:39:551,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=ACS_CAforLDAP, the issuer certificate found=1,SSL.cpp:1188
Crypto,19/03/2013,16:34:39:551,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=ACS_CAforLDAP,SSL.cpp:1200
Crypto,19/03/2013,16:34:39:551,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: 3,SSL.cpp:1270
Crypto,19/03/2013,16:34:39:551,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback, CryptoLib custom certificate verification callback, called with preverify_ok value 1,SSL.cpp:1074
Crypto,19/03/2013,16:34:39:551,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/CN=ACS_PolicyCAforLDAP/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS, error=3,SSL.cpp:1108
Crypto,19/03/2013,16:34:39:551,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/CN=ACS_CAforLDAP/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS,SSL.cpp:1120
Crypto,19/03/2013,16:34:39:551,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=ACS_CAforLDAP, the issuer certificate found=1,SSL.cpp:1188
Crypto,19/03/2013,16:34:39:551,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=ACS_CAforLDAP,SSL.cpp:1200
Crypto,19/03/2013,16:34:39:551,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: 2,SSL.cpp:1270
Crypto,19/03/2013,16:34:39:552,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback, CryptoLib custom certificate verification callback, called with preverify_ok value 1,SSL.cpp:1074
Crypto,19/03/2013,16:34:39:552,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/CN=ACS_IssuingCAforLDAP/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS, error=3,SSL.cpp:1108
Crypto,19/03/2013,16:34:39:552,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/CN=ACS_PolicyCAforLDAP/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS,SSL.cpp:1120
Crypto,19/03/2013,16:34:39:552,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=ACS_PolicyCAforLDAP, the issuer certificate found=1,SSL.cpp:1188
Crypto,19/03/2013,16:34:39:552,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=ACS_PolicyCAforLDAP,SSL.cpp:1200
Crypto,19/03/2013,16:34:39:552,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: 1,SSL.cpp:1270
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback, CryptoLib custom certificate verification callback, called with preverify_ok value 1,SSL.cpp:1074
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/CN=ACS_LDAP_Server/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS, error=3,SSL.cpp:1108
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/CN=ACS_IssuingCAforLDAP/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS,SSL.cpp:1120
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=ACS_IssuingCAforLDAP, the issuer certificate found=1,SSL.cpp:1188
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=ACS_IssuingCAforLDAP,SSL.cpp:1200
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: 0,SSL.cpp:1270
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - Proceeding to further server certificate checks,SSL.cpp:1273
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - calling server certificate validation callback,SSL.cpp:1287
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - checking match for 10.56.62.173,SSLConnection.cpp:3287
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Received configured host name: 10.56.62.173, type IP Address,SSLConnection.cpp:3299
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Extracting SAN fields,Certificate.cpp:2040
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=1, Crypto.Certificate::getSANs - Found 2 SANs in Certificate,Certificate.cpp:2073
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Parsing SAN DNS type = 0,Certificate.cpp:2107
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - storing SAN value...,Certificate.cpp:2155
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Converting SAN to string...,Certificate.cpp:2166
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN to vector of SAN fields. Value acs-issuing-ldap01.acs.com, type 1,Certificate.cpp:2178
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Parsing SAN IP address type = 0,Certificate.cpp:2125
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - storing SAN value...,Certificate.cpp:2155
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Converting SAN IP address to string...,Certificate.cpp:2159
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN IP address 10.56.62.173,Certificate.cpp:2161
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN to vector of SAN fields. Value 10.56.62.173, type 4,Certificate.cpp:2178
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted SAN field number 0, value acs-issuing-ldap01.acs.com, type 1,SSLConnection.cpp:3325
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted SAN field number 1, value 10.56.62.173, type 4,SSLConnection.cpp:3325
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Successfuly compared IP address format host names ,SSLConnection.cpp:3353
Crypto,19/03/2013,16:34:39:553,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - server certificate validation has succeeded.,SSL.cpp:1297

			1.1.8.3 Multi SAN FQDN DNS Positive 
"c:\work\acs\5.5\features\CSCtw87143 LDAP server spoofing with valid certificate\logs\Multi_SAN_positive_FQDN_DNS\ldap_rep.log" 

Crypto,20/03/2013,16:20:00:219,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback, CryptoLib custom certificate verification callback, called with preverify_ok value 1,SSL.cpp:1074
Crypto,20/03/2013,16:20:00:219,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/CN=ACS_LDAP_Server/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS, error=3,SSL.cpp:1108
Crypto,20/03/2013,16:20:00:219,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/CN=ACS_IssuingCAforLDAP/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS,SSL.cpp:1120
Crypto,20/03/2013,16:20:00:219,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=ACS_IssuingCAforLDAP, the issuer certificate found=1,SSL.cpp:1188
Crypto,20/03/2013,16:20:00:219,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=ACS_IssuingCAforLDAP,SSL.cpp:1200
Crypto,20/03/2013,16:20:00:220,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: 0,SSL.cpp:1270
Crypto,20/03/2013,16:20:00:220,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - Proceeding to further server certificate checks,SSL.cpp:1273
Crypto,20/03/2013,16:20:00:220,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - calling server certificate validation callback,SSL.cpp:1287
Crypto,20/03/2013,16:20:00:220,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - checking match for cd-acs-ldap01.north.auto.acs.com,SSLConnection.cpp:3287
Crypto,20/03/2013,16:20:00:220,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Received configured host name: cd-acs-ldap01.north.auto.acs.com, type DNS,SSLConnection.cpp:3299
Crypto,20/03/2013,16:20:00:220,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted domain: .north.auto.acs.com,SSLConnection.cpp:3306
Crypto,20/03/2013,16:20:00:220,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Extracting SAN fields,Certificate.cpp:2040
Crypto,20/03/2013,16:20:00:220,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=1, Crypto.Certificate::getSANs - Found 2 SANs in Certificate,Certificate.cpp:2073
Crypto,20/03/2013,16:20:00:220,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Parsing SAN DNS type = 0,Certificate.cpp:2107
Crypto,20/03/2013,16:20:00:220,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - storing SAN value...,Certificate.cpp:2155
Crypto,20/03/2013,16:20:00:220,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Converting SAN to string...,Certificate.cpp:2166
Crypto,20/03/2013,16:20:00:220,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN to vector of SAN fields. Value cd-acs-ldap01.north.auto.acs.com, type 1,Certificate.cpp:2178
Crypto,20/03/2013,16:20:00:220,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Parsing SAN IP address type = 0,Certificate.cpp:2125
Crypto,20/03/2013,16:20:00:220,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - storing SAN value...,Certificate.cpp:2155
Crypto,20/03/2013,16:20:00:220,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Converting SAN IP address to string...,Certificate.cpp:2159
Crypto,20/03/2013,16:20:00:220,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN IP address 10.56.62.1,Certificate.cpp:2161
Crypto,20/03/2013,16:20:00:220,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN to vector of SAN fields. Value 10.56.62.1, type 4,Certificate.cpp:2178
Crypto,20/03/2013,16:20:00:220,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted SAN field number 0, value cd-acs-ldap01.north.auto.acs.com, type 1,SSLConnection.cpp:3325
Crypto,20/03/2013,16:20:00:220,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Successfuly compared DNS format host names with exact match,SSLConnection.cpp:3334
Crypto,20/03/2013,16:20:00:220,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - server certificate validation has succeeded.,SSL.cpp:1297
Crypto,20/03/2013,16:20:00:221,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=106, Crypto.SSLConnection.writeData - want read,SSLConnection.cpp:922
Crypto,20/03/2013,16:20:00:235,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.writeData - nInDataSize=57, entity=client,SSLConnection.cpp:895
Crypto,20/03/2013,16:20:00:235,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.writeData - success,SSLConnection.cpp:1001
Crypto,20/03/2013,16:20:00:236,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.readData - nInDataSize=0, entity=client,SSLConnection.cpp:768
Crypto,20/03/2013,16:20:00:237,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.readData - output-size=14,SSLConnection.cpp:849
Connection,20/03/2013,16:20:00:237,DEBUG,3044952976,LdapBindResponse::update: bind result = 0 (Success),LdapConnectionResponses.cpp:108

			1.1.8.4 Multi SAN FQDN DNS Negative 

Crypto,20/03/2013,16:48:42:338,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Received configured host name: cd-acs-ldap01.north.auto.acs.com, type DNS,SSLConnection.cpp:3299
Crypto,20/03/2013,16:48:42:338,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted domain: .north.auto.acs.com,SSLConnection.cpp:3306
Crypto,20/03/2013,16:48:42:338,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Extracting SAN fields,Certificate.cpp:2040
Crypto,20/03/2013,16:48:42:338,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=1, Crypto.Certificate::getSANs - Found 2 SANs in Certificate,Certificate.cpp:2073
Crypto,20/03/2013,16:48:42:338,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Parsing SAN DNS type = 0,Certificate.cpp:2107
Crypto,20/03/2013,16:48:42:338,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - storing SAN value...,Certificate.cpp:2155
Crypto,20/03/2013,16:48:42:338,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Converting SAN to string...,Certificate.cpp:2166
Crypto,20/03/2013,16:48:42:338,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN to vector of SAN fields. Value unknown-ldap01.north.auto.acs.com, type 1,Certificate.cpp:2178
Crypto,20/03/2013,16:48:42:338,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Parsing SAN IP address type = 0,Certificate.cpp:2125
Crypto,20/03/2013,16:48:42:338,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - storing SAN value...,Certificate.cpp:2155
Crypto,20/03/2013,16:48:42:338,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Converting SAN IP address to string...,Certificate.cpp:2159
Crypto,20/03/2013,16:48:42:338,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN IP address 10.56.62.1,Certificate.cpp:2161
Crypto,20/03/2013,16:48:42:338,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN to vector of SAN fields. Value 10.56.62.1, type 4,Certificate.cpp:2178
Crypto,20/03/2013,16:48:42:338,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted SAN field number 0, value unknown-ldap01.north.auto.acs.com, type 1,SSLConnection.cpp:3325
Crypto,20/03/2013,16:48:42:338,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted SAN field number 1, value 10.56.62.1, type 4,SSLConnection.cpp:3325
Crypto,20/03/2013,16:48:42:338,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted server certificate:
subject: OU=ACS,O=Cisco,L=Natania,S=State,C=IL,CN=ACS_LDAP_Server
serial number: H�
CN: ACS_LDAP_Server,SSLConnection.cpp:3377
Crypto,20/03/2013,16:48:42:338,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - CN field found. Checking match...,SSLConnection.cpp:3381
Crypto,20/03/2013,16:48:42:338,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - server certificate validation has failed.,SSL.cpp:1290
Crypto,20/03/2013,16:48:42:338,WARN ,3044952976,NIL-CONTEXT,Crypto::Result=1, Crypto.SSLConnection.pvClientInfoCB - Alert raised: code=0x230=560, where=0x4008=16392, source=local,SSLConnection.cpp:2724
Crypto,20/03/2013,16:48:42:338,WARN ,3044952976,NIL-CONTEXT,Crypto::Result=102, Crypto.SSLConnection.writeData - failed write the data,SSLConnection.cpp:934
Connection,20/03/2013,16:48:42:338,ERROR,3044952976,LdapSslConnectionContext::checkCryptoResult(id = 512): crypto result = 102,LdapSslConnectionContext.cpp:206
Connection,20/03/2013,16:48:42:338,ERROR,3044952976,LdapSslConnectionContext::checkCryptoResult(id = 512): error message = SSL alert: code=0x230=560 ; source=local ; type=fatal ; message="Unknown CA - Unable to get CRL",LdapSslConnectionContext.cpp:215
Crypto,20/03/2013,16:48:42:338,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.pvDone,SSLConnection.cpp:248
Crypto,20/03/2013,16:48:42:338,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.pvDone - removing session from cache,SSLConnection.cpp:294
Connection,20/03/2013,16:48:42:338,DEBUG,3044952976,LdapConnectionContext::closeConnection(id = 512): close the socket,LdapConnectionContext.cpp:163
State,20/03/2013,16:48:42:338,DEBUG,3044952976,LdapConnectionInitState::onState(id = -1),LdapConnectionStates.cpp:163
Server,20/03/2013,16:48:42:338,ERROR,3044952976,cntx=0000011567,sesn=vinson1/152994088/13,user=abergin,LdapServer::onAcquireConnectionResponse: failed to acquire connection,LdapServer.cpp:704

			1.1.8.5 Disable Server Certificate check 
- rt logs:
Crypto,19/03/2013,17:36:30:267,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=106, Crypto.SSLConnection.writeData - want read,SSLConnection.cpp:922
Crypto,19/03/2013,17:36:30:269,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.writeData - nInDataSize=14, entity=client,SSLConnection.cpp:895
Crypto,19/03/2013,17:36:30:269,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=106, Crypto.SSLConnection.writeData - want read,SSLConnection.cpp:922
Crypto,19/03/2013,17:36:30:269,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.writeData - nInDataSize=14, entity=client,SSLConnection.cpp:895
Crypto,19/03/2013,17:36:30:269,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback,SSL.cpp:745
Crypto,19/03/2013,17:36:30:269,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - current certificate=/CN=ACS_LDAP_Server/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS,SSL.cpp:758
Crypto,19/03/2013,17:36:30:269,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - current certificate's issuer=/CN=ACS_IssuingCAforLDAP/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS,SSL.cpp:783
Crypto,19/03/2013,17:36:30:269,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - OCSP check is off,SSL.cpp:1036
Crypto,19/03/2013,17:36:30:269,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - final OCSP status is: OCSP status is unknown, continue to CRL,SSL.cpp:1052
Crypto,19/03/2013,17:36:30:269,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.pvServerX509NotificationCB - x509Error 0, TLS notify 41,SSLConnection.cpp:3421
Crypto,19/03/2013,17:36:30:269,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback, CryptoLib custom certificate verification callback, called with preverify_ok value 0,SSL.cpp:1074
Crypto,19/03/2013,17:36:30:269,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/CN=ACS_LDAP_Server/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS, error=3,SSL.cpp:1108
Crypto,19/03/2013,17:36:30:269,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/CN=ACS_IssuingCAforLDAP/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS,SSL.cpp:1120
Crypto,19/03/2013,17:36:30:269,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=ACS_IssuingCAforLDAP, the issuer certificate found=1,SSL.cpp:1188
Crypto,19/03/2013,17:36:30:270,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=ACS_IssuingCAforLDAP,SSL.cpp:1200
Crypto,19/03/2013,17:36:30:270,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: 0,SSL.cpp:1270
Crypto,19/03/2013,17:36:30:270,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - Proceeding to further server certificate checks,SSL.cpp:1273
Crypto,19/03/2013,17:36:30:270,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - calling server certificate validation callback,SSL.cpp:1287
tlsLDAP_Cert_Check_CB,19/03/2013,17:36:30:270,INFO ,3044952976,Server Identity check is disabled. No check is required!,LdapSslContext.cpp:102
Crypto,19/03/2013,17:36:30:270,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - server certificate validation has succeeded.,SSL.cpp:1297

			1.1.8.6 Multi SAN FQDN wildcard DNS Positive 

Crypto,20/03/2013,18:24:44:610,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=ACS_IssuingCAforLDAP,SSL.cpp:1200
Crypto,20/03/2013,18:24:44:610,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: 0,SSL.cpp:1270
Crypto,20/03/2013,18:24:44:610,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - Proceeding to further server certificate checks,SSL.cpp:1273
Crypto,20/03/2013,18:24:44:610,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - calling server certificate validation callback,SSL.cpp:1287
Crypto,20/03/2013,18:24:44:610,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - checking match for cd-acs-ldap01.north.auto.acs.com,SSLConnection.cpp:3287
Crypto,20/03/2013,18:24:44:610,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Received configured host name: cd-acs-ldap01.north.auto.acs.com, type DNS,SSLConnection.cpp:3299
Crypto,20/03/2013,18:24:44:610,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted domain: .north.auto.acs.com,SSLConnection.cpp:3306
Crypto,20/03/2013,18:24:44:610,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Extracting SAN fields,Certificate.cpp:2040
Crypto,20/03/2013,18:24:44:610,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=1, Crypto.Certificate::getSANs - Found 2 SANs in Certificate,Certificate.cpp:2073
Crypto,20/03/2013,18:24:44:610,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Parsing SAN DNS type = 0,Certificate.cpp:2107
Crypto,20/03/2013,18:24:44:610,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - storing SAN value...,Certificate.cpp:2155
Crypto,20/03/2013,18:24:44:610,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Converting SAN to string...,Certificate.cpp:2166
Crypto,20/03/2013,18:24:44:610,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN to vector of SAN fields. Value *.north.auto.acs.com, type 1,Certificate.cpp:2178
Crypto,20/03/2013,18:24:44:610,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Parsing SAN IP address type = 0,Certificate.cpp:2125
Crypto,20/03/2013,18:24:44:610,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - storing SAN value...,Certificate.cpp:2155
Crypto,20/03/2013,18:24:44:611,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Converting SAN IP address to string...,Certificate.cpp:2159
Crypto,20/03/2013,18:24:44:611,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN IP address 10.56.62.1,Certificate.cpp:2161
Crypto,20/03/2013,18:24:44:611,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN to vector of SAN fields. Value 10.56.62.1, type 4,Certificate.cpp:2178
Crypto,20/03/2013,18:24:44:611,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted SAN field number 0, value *.north.auto.acs.com, type 1,SSLConnection.cpp:3325
Crypto,20/03/2013,18:24:44:611,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Successfuly compared DNS format host names to wildcard expression,SSLConnection.cpp:3342
Crypto,20/03/2013,18:24:44:611,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - server certificate validation has succeeded.,SSL.cpp:1297
Audit,20/03/2013,18:24:44:611,DEBUG,3044952976,NIL-CONTEXT,Crypto thread state change to state={RNG},FipsControl.cpp:105
Audit,20/03/2013,18:24:44:611,DEBUG,3044952976,NIL-CONTEXT,Suppressing Crypto state transition notifications due to heavy load,WrapperAudit.cpp:42
Crypto,20/03/2013,18:24:44:612,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=106, Crypto.SSLConnection.writeData - want read,SSLConnection.cpp:922
Crypto,20/03/2013,18:24:44:626,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.writeData - nInDataSize=57, entity=client,SSLConnection.cpp:895
Crypto,20/03/2013,18:24:44:626,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.writeData - success,SSLConnection.cpp:1001
Crypto,20/03/2013,18:24:44:627,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.readData - nInDataSize=0, entity=client,SSLConnection.cpp:768
Crypto,20/03/2013,18:24:44:628,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.readData - output-size=14,SSLConnection.cpp:849
Connection,20/03/2013,18:24:44:628,DEBUG,3044952976,LdapBindResponse::update: bind result = 0 (Success),LdapConnectionResponses.cpp:108
Connection,20/03/2013,18:24:44:628,DEBUG,3044952976,LdapBindResponse::update: password policy control is not returned by the server,LdapConnectionResponses.cpp:139
State,20/03/2013,18:24:44:628,DEBUG,3044952976,LdapConnectionBindingState::onInput(id = 513): bind succeeded,LdapConnectionStates.cpp:447
State,20/03/2013,18:24:44:628,DEBUG,3044952976,LdapConnectionBoundState::onState(id = 513),LdapConnectionStates.cpp:469

			1.1.8.7 Multi SAN FQDN wildcard DNS Negative 
"c:\work\acs\5.5\features\CSCtw87143 LDAP server spoofing with valid certificate\logs\Multi_SAN_negative_wildcard_FQDN_DNS\ldap_rep.log" 
Crypto,21/03/2013,11:27:49:698,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Received configured host name: cd-acs-ldap01.north.auto.acs.com, type DNS,SSLConnection.cpp:3299
Crypto,21/03/2013,11:27:49:698,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted domain: .north.auto.acs.com,SSLConnection.cpp:3306
Crypto,21/03/2013,11:27:49:698,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Extracting SAN fields,Certificate.cpp:2040
Crypto,21/03/2013,11:27:49:698,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=1, Crypto.Certificate::getSANs - Found 2 SANs in Certificate,Certificate.cpp:2073
Crypto,21/03/2013,11:27:49:698,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Parsing SAN DNS type = 0,Certificate.cpp:2107
Crypto,21/03/2013,11:27:49:698,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - storing SAN value...,Certificate.cpp:2155
Crypto,21/03/2013,11:27:49:698,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Converting SAN to string...,Certificate.cpp:2166
Crypto,21/03/2013,11:27:49:698,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN to vector of SAN fields. Value *.hacker.com, type 1,Certificate.cpp:2178
Crypto,21/03/2013,11:27:49:698,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Parsing SAN IP address type = 0,Certificate.cpp:2125
Crypto,21/03/2013,11:27:49:698,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - storing SAN value...,Certificate.cpp:2155
Crypto,21/03/2013,11:27:49:698,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Converting SAN IP address to string...,Certificate.cpp:2159
Crypto,21/03/2013,11:27:49:698,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN IP address 10.56.62.1,Certificate.cpp:2161
Crypto,21/03/2013,11:27:49:698,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN to vector of SAN fields. Value 10.56.62.1, type 4,Certificate.cpp:2178
Crypto,21/03/2013,11:27:49:698,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted SAN field number 0, value *.hacker.com, type 1,SSLConnection.cpp:3325
Crypto,21/03/2013,11:27:49:698,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted SAN field number 1, value 10.56.62.1, type 4,SSLConnection.cpp:3325
Crypto,21/03/2013,11:27:49:698,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted server certificate:
subject: OU=ACS,O=Cisco,L=Natania,S=State,C=IL,CN=ACS_LDAP_Server
serial number: h��
CN: ACS_LDAP_Server,SSLConnection.cpp:3377
Crypto,21/03/2013,11:27:49:698,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - CN field found. Checking match...,SSLConnection.cpp:3381
Crypto,21/03/2013,11:27:49:698,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - server certificate validation has failed.,SSL.cpp:1290
Crypto,21/03/2013,11:27:49:698,WARN ,3044952976,NIL-CONTEXT,Crypto::Result=1, Crypto.SSLConnection.pvClientInfoCB - Alert raised: code=0x230=560, where=0x4008=16392, source=local,SSLConnection.cpp:2724
Crypto,21/03/2013,11:27:49:698,WARN ,3044952976,NIL-CONTEXT,Crypto::Result=102, Crypto.SSLConnection.writeData - failed write the data,SSLConnection.cpp:934
Connection,21/03/2013,11:27:49:698,ERROR,3044952976,LdapSslConnectionContext::checkCryptoResult(id = 512): crypto result = 102,LdapSslConnectionContext.cpp:206
Connection,21/03/2013,11:27:49:698,ERROR,3044952976,LdapSslConnectionContext::checkCryptoResult(id = 512): error message = SSL alert: code=0x230=560 ; source=local ; type=fatal ; message="Unknown CA - Unable to get CRL",LdapSslConnectionContext.cpp:215
Crypto,21/03/2013,11:27:49:698,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.pvDone,SSLConnection.cpp:248
Crypto,21/03/2013,11:27:49:698,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.pvDone - removing session from cache,SSLConnection.cpp:294
Connection,21/03/2013,11:27:49:698,DEBUG,3044952976,LdapConnectionContext::closeConnection(id = 512): close the socket,LdapConnectionContext.cpp:163
State,21/03/2013,11:27:49:698,DEBUG,3044952976,LdapConnectionInitState::onState(id = -1),LdapConnectionStates.cpp:163
Server,21/03/2013,11:27:49:698,ERROR,3044952976,cntx=0000017244,sesn=vinson1/152994088/17,user=abergin,LdapServer::onAcquireConnectionResponse: failed to acquire connection,LdapServer.cpp:704

			1.1.8.9 CN FQDN DNS positive 

Crypto,21/03/2013,12:15:33:432,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=ACS_PolicyCAforLDAP,SSL.cpp:1200
Crypto,21/03/2013,12:15:33:432,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: 1,SSL.cpp:1270
Crypto,21/03/2013,12:15:33:434,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback, CryptoLib custom certificate verification callback, called with preverify_ok value 1,SSL.cpp:1074
Crypto,21/03/2013,12:15:33:434,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/CN=cd-acs-ldap01.north.auto.acs.com/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS, error=3,SSL.cpp:1108
Crypto,21/03/2013,12:15:33:434,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/CN=ACS_IssuingCAforLDAP/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS,SSL.cpp:1120
Crypto,21/03/2013,12:15:33:434,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=ACS_IssuingCAforLDAP, the issuer certificate found=1,SSL.cpp:1188
Crypto,21/03/2013,12:15:33:434,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=ACS_IssuingCAforLDAP,SSL.cpp:1200
Crypto,21/03/2013,12:15:33:434,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: 0,SSL.cpp:1270
Crypto,21/03/2013,12:15:33:434,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - Proceeding to further server certificate checks,SSL.cpp:1273
Crypto,21/03/2013,12:15:33:434,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - calling server certificate validation callback,SSL.cpp:1287
Crypto,21/03/2013,12:15:33:434,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - checking match for cd-acs-ldap01.north.auto.acs.com,SSLConnection.cpp:3287
Crypto,21/03/2013,12:15:33:434,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Received configured host name: cd-acs-ldap01.north.auto.acs.com, type DNS,SSLConnection.cpp:3299
Crypto,21/03/2013,12:15:33:434,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted domain: .north.auto.acs.com,SSLConnection.cpp:3306
Crypto,21/03/2013,12:15:33:434,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Extracting SAN fields,Certificate.cpp:2040
Crypto,21/03/2013,12:15:33:434,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=1, Crypto.Certificate::getSANs - Found 2 SANs in Certificate,Certificate.cpp:2073
Crypto,21/03/2013,12:15:33:434,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Parsing SAN DNS type = 0,Certificate.cpp:2107
Crypto,21/03/2013,12:15:33:435,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - storing SAN value...,Certificate.cpp:2155
Crypto,21/03/2013,12:15:33:435,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Converting SAN to string...,Certificate.cpp:2166
Crypto,21/03/2013,12:15:33:435,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN to vector of SAN fields. Value *.hacker.com, type 1,Certificate.cpp:2178
Crypto,21/03/2013,12:15:33:435,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Parsing SAN IP address type = 0,Certificate.cpp:2125
Crypto,21/03/2013,12:15:33:435,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - storing SAN value...,Certificate.cpp:2155
Crypto,21/03/2013,12:15:33:435,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Converting SAN IP address to string...,Certificate.cpp:2159
Crypto,21/03/2013,12:15:33:435,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN IP address 10.56.62.1,Certificate.cpp:2161
Crypto,21/03/2013,12:15:33:435,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN to vector of SAN fields. Value 10.56.62.1, type 4,Certificate.cpp:2178
Crypto,21/03/2013,12:15:33:435,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted SAN field number 0, value *.hacker.com, type 1,SSLConnection.cpp:3325
Crypto,21/03/2013,12:15:33:435,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted SAN field number 1, value 10.56.62.1, type 4,SSLConnection.cpp:3325
Crypto,21/03/2013,12:15:33:435,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted server certificate:
subject: OU=ACS,O=Cisco,L=Natania,S=State,C=IL,CN=cd-acs-ldap01.north.auto.acs.com
serial number: %�
CN: cd-acs-ldap01.north.auto.acs.com,SSLConnection.cpp:3377
Crypto,21/03/2013,12:15:33:435,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - CN field found. Checking match...,SSLConnection.cpp:3381
Crypto,21/03/2013,12:15:33:435,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Successfuly compared CN host name with exact match,SSLConnection.cpp:3387
Crypto,21/03/2013,12:15:33:435,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - server certificate validation has succeeded.,SSL.cpp:1297

			1.1.8.10 CN FQDN DNS Negative 

Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.pvServerX509NotificationCB - x509Error 0, TLS notify 41,SSLConnection.cpp:3421
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback, CryptoLib custom certificate verification callback, called with preverify_ok value 0,SSL.cpp:1074
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/CN=kacker.north.auto.acs.com/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS, error=3,SSL.cpp:1108
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/CN=ACS_IssuingCAforLDAP/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS,SSL.cpp:1120
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=ACS_IssuingCAforLDAP, the issuer certificate found=1,SSL.cpp:1188
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=ACS_IssuingCAforLDAP,SSL.cpp:1200
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: 0,SSL.cpp:1270
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - Proceeding to further server certificate checks,SSL.cpp:1273
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - calling server certificate validation callback,SSL.cpp:1287
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - checking match for cd-acs-ldap01.north.auto.acs.com,SSLConnection.cpp:3287
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Received configured host name: cd-acs-ldap01.north.auto.acs.com, type DNS,SSLConnection.cpp:3299
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted domain: .north.auto.acs.com,SSLConnection.cpp:3306
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Extracting SAN fields,Certificate.cpp:2040
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=1, Crypto.Certificate::getSANs - Found 2 SANs in Certificate,Certificate.cpp:2073
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Parsing SAN DNS type = 0,Certificate.cpp:2107
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - storing SAN value...,Certificate.cpp:2155
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Converting SAN to string...,Certificate.cpp:2166
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN to vector of SAN fields. Value *.hacker.com, type 1,Certificate.cpp:2178
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Parsing SAN IP address type = 0,Certificate.cpp:2125
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - storing SAN value...,Certificate.cpp:2155
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Converting SAN IP address to string...,Certificate.cpp:2159
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN IP address 10.56.62.1,Certificate.cpp:2161
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN to vector of SAN fields. Value 10.56.62.1, type 4,Certificate.cpp:2178
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted SAN field number 0, value *.hacker.com, type 1,SSLConnection.cpp:3325
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted SAN field number 1, value 10.56.62.1, type 4,SSLConnection.cpp:3325
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted server certificate:
subject: OU=ACS,O=Cisco,L=Natania,S=State,C=IL,CN=kacker.north.auto.acs.com
serial number: v>�
CN: kacker.north.auto.acs.com,SSLConnection.cpp:3377
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - CN field found. Checking match...,SSLConnection.cpp:3381
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - server certificate validation has failed.,SSL.cpp:1290
Crypto,21/03/2013,15:45:39:962,WARN ,3044952976,NIL-CONTEXT,Crypto::Result=1, Crypto.SSLConnection.pvClientInfoCB - Alert raised: code=0x230=560, where=0x4008=16392, source=local,SSLConnection.cpp:2724
Crypto,21/03/2013,15:45:39:962,WARN ,3044952976,NIL-CONTEXT,Crypto::Result=102, Crypto.SSLConnection.writeData - failed write the data,SSLConnection.cpp:934
Connection,21/03/2013,15:45:39:962,ERROR,3044952976,LdapSslConnectionContext::checkCryptoResult(id = 512): crypto result = 102,LdapSslConnectionContext.cpp:206
Connection,21/03/2013,15:45:39:962,ERROR,3044952976,LdapSslConnectionContext::checkCryptoResult(id = 512): error message = SSL alert: code=0x230=560 ; source=local ; type=fatal ; message="Unknown CA - Unable to get CRL",LdapSslConnectionContext.cpp:215
Crypto,21/03/2013,15:45:39:962,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.pvDone,SSLConnection.cpp:248
Crypto,21/03/2013,15:45:39:963,DEBUG,3044952976,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.pvDone - removing session from cache,SSLConnection.cpp:294
Connection,21/03/2013,15:45:39:963,DEBUG,3044952976,LdapConnectionContext::closeConnection(id = 512): close the socket,LdapConnectionContext.cpp:163
State,21/03/2013,15:45:39:963,DEBUG,3044952976,LdapConnectionInitState::onState(id = -1),LdapConnectionStates.cpp:163
Server,21/03/2013,15:45:39:963,ERROR,3044952976,cntx=0000018678,sesn=vinson1/152994088/21,user=abergin,LdapServer::onAcquireConnectionResponse: failed to acquire connection,LdapServer.cpp:704

			1.1.8.9 CN FQDN wildcard DNS positive 
checking match for cd-acs-ldap01.north.auto.acs.com
Extracted domain: .north.auto.acs.com
CN: *.north.auto.acs.com

"c:\work\acs\5.5\features\CSCtw87143 LDAP server spoofing with valid certificate\logs\CN_positive_FQDN_wildcard_DNS\ldap_rep.log" 

Crypto,21/03/2013,17:02:36:373,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/CN=ACS_PolicyCAforLDAP/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS, error=3,SSL.cpp:1108
Crypto,21/03/2013,17:02:36:373,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/CN=ACS_CAforLDAP/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS,SSL.cpp:1120
Crypto,21/03/2013,17:02:36:373,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=ACS_CAforLDAP, the issuer certificate found=1,SSL.cpp:1188
Crypto,21/03/2013,17:02:36:373,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=ACS_CAforLDAP,SSL.cpp:1200
Crypto,21/03/2013,17:02:36:373,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: 2,SSL.cpp:1270
Crypto,21/03/2013,17:02:36:374,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback, CryptoLib custom certificate verification callback, called with preverify_ok value 1,SSL.cpp:1074
Crypto,21/03/2013,17:02:36:374,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/CN=ACS_IssuingCAforLDAP/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS, error=3,SSL.cpp:1108
Crypto,21/03/2013,17:02:36:374,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/CN=ACS_PolicyCAforLDAP/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS,SSL.cpp:1120
Crypto,21/03/2013,17:02:36:374,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=ACS_PolicyCAforLDAP, the issuer certificate found=1,SSL.cpp:1188
Crypto,21/03/2013,17:02:36:374,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=ACS_PolicyCAforLDAP,SSL.cpp:1200
Crypto,21/03/2013,17:02:36:374,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: 1,SSL.cpp:1270
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback, CryptoLib custom certificate verification callback, called with preverify_ok value 1,SSL.cpp:1074
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/CN=*.north.auto.acs.com/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS, error=3,SSL.cpp:1108
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/CN=ACS_IssuingCAforLDAP/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS,SSL.cpp:1120
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=ACS_IssuingCAforLDAP, the issuer certificate found=1,SSL.cpp:1188
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=ACS_IssuingCAforLDAP,SSL.cpp:1200
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: 0,SSL.cpp:1270
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - Proceeding to further server certificate checks,SSL.cpp:1273
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - calling server certificate validation callback,SSL.cpp:1287
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - checking match for cd-acs-ldap01.north.auto.acs.com,SSLConnection.cpp:3287
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Received configured host name: cd-acs-ldap01.north.auto.acs.com, type DNS,SSLConnection.cpp:3299
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted domain: .north.auto.acs.com,SSLConnection.cpp:3306
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Extracting SAN fields,Certificate.cpp:2040
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=1, Crypto.Certificate::getSANs - Found 2 SANs in Certificate,Certificate.cpp:2073
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Parsing SAN DNS type = 0,Certificate.cpp:2107
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - storing SAN value...,Certificate.cpp:2155
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Converting SAN to string...,Certificate.cpp:2166
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN to vector of SAN fields. Value *.hacker.com, type 1,Certificate.cpp:2178
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Parsing SAN IP address type = 0,Certificate.cpp:2125
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - storing SAN value...,Certificate.cpp:2155
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Converting SAN IP address to string...,Certificate.cpp:2159
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN IP address 10.56.62.1,Certificate.cpp:2161
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN to vector of SAN fields. Value 10.56.62.1, type 4,Certificate.cpp:2178
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted SAN field number 0, value *.hacker.com, type 1,SSLConnection.cpp:3325
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted SAN field number 1, value 10.56.62.1, type 4,SSLConnection.cpp:3325
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted server certificate:
subject: OU=ACS,O=Cisco,L=Natania,S=State,C=IL,CN=*.north.auto.acs.com
serial number: �f
CN: *.north.auto.acs.com,SSLConnection.cpp:3383
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - CN field found. Checking match...,SSLConnection.cpp:3387
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Successfuly compared CN host name to wildcard expression,SSLConnection.cpp:3400
Crypto,21/03/2013,17:02:36:375,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - server certificate validation has succeeded.,SSL.cpp:1297

			1.1.8.10 CN FQDN wildcard DNS Negative 
"c:\work\acs\5.5\features\CSCtw87143 LDAP server spoofing with valid certificate\logs\CN_negative_FQDN_wildcard_DNS\ldap_rep.log" 

Crypto,21/03/2013,18:30:03:160,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback,SSL.cpp:745
Crypto,21/03/2013,18:30:03:160,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - current certificate=/CN=*.hacker.com/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS,SSL.cpp:758
Crypto,21/03/2013,18:30:03:160,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - current certificate's issuer=/CN=ACS_IssuingCAforLDAP/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS,SSL.cpp:783
Crypto,21/03/2013,18:30:03:160,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - OCSP check is off,SSL.cpp:1036
Crypto,21/03/2013,18:30:03:160,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.OCSP Callback - final OCSP status is: OCSP status is unknown, continue to CRL,SSL.cpp:1052
Crypto,21/03/2013,18:30:03:160,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.pvServerX509NotificationCB - x509Error 0, TLS notify 41,SSLConnection.cpp:3427
Crypto,21/03/2013,18:30:03:160,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback, CryptoLib custom certificate verification callback, called with preverify_ok value 0,SSL.cpp:1074
Crypto,21/03/2013,18:30:03:160,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate=/CN=*.hacker.com/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS, error=3,SSL.cpp:1108
Crypto,21/03/2013,18:30:03:160,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - problematic certificate issuer=/CN=ACS_IssuingCAforLDAP/C=IL/ST=State/L=Natania/O=Cisco/OU=ACS,SSL.cpp:1120
Crypto,21/03/2013,18:30:03:160,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - processing exception for CA CN=ACS_IssuingCAforLDAP, the issuer certificate found=1,SSL.cpp:1188
Crypto,21/03/2013,18:30:03:160,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - allow authentication with no CRL configured on CN=ACS_IssuingCAforLDAP,SSL.cpp:1200
Crypto,21/03/2013,18:30:03:160,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - current depth in chain: 0,SSL.cpp:1270
Crypto,21/03/2013,18:30:03:160,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - Proceeding to further server certificate checks,SSL.cpp:1273
Crypto,21/03/2013,18:30:03:160,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - calling server certificate validation callback,SSL.cpp:1287
Crypto,21/03/2013,18:30:03:160,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - checking match for cd-acs-ldap01.north.auto.acs.com,SSLConnection.cpp:3287
Crypto,21/03/2013,18:30:03:160,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Received configured host name: cd-acs-ldap01.north.auto.acs.com, type DNS,SSLConnection.cpp:3299
Crypto,21/03/2013,18:30:03:160,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted domain: .north.auto.acs.com,SSLConnection.cpp:3306
Crypto,21/03/2013,18:30:03:160,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Extracting SAN fields,Certificate.cpp:2040
Crypto,21/03/2013,18:30:03:161,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=1, Crypto.Certificate::getSANs - Found 2 SANs in Certificate,Certificate.cpp:2073
Crypto,21/03/2013,18:30:03:161,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Parsing SAN DNS type = 0,Certificate.cpp:2107
Crypto,21/03/2013,18:30:03:161,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - storing SAN value...,Certificate.cpp:2155
Crypto,21/03/2013,18:30:03:161,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Converting SAN to string...,Certificate.cpp:2166
Crypto,21/03/2013,18:30:03:161,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN to vector of SAN fields. Value *.hacker.com, type 1,Certificate.cpp:2178
Crypto,21/03/2013,18:30:03:161,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Parsing SAN IP address type = 0,Certificate.cpp:2125
Crypto,21/03/2013,18:30:03:161,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - storing SAN value...,Certificate.cpp:2155
Crypto,21/03/2013,18:30:03:161,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Converting SAN IP address to string...,Certificate.cpp:2159
Crypto,21/03/2013,18:30:03:161,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN IP address 10.56.62.1,Certificate.cpp:2161
Crypto,21/03/2013,18:30:03:161,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.Certificate::getSANs - Adding SAN to vector of SAN fields. Value 10.56.62.1, type 4,Certificate.cpp:2178
Crypto,21/03/2013,18:30:03:161,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted SAN field number 0, value *.hacker.com, type 1,SSLConnection.cpp:3325
Crypto,21/03/2013,18:30:03:161,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted SAN field number 1, value 10.56.62.1, type 4,SSLConnection.cpp:3325
Crypto,21/03/2013,18:30:03:161,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - Extracted server certificate:
subject: OU=ACS,O=Cisco,L=Natania,S=State,C=IL,CN=*.hacker.com
serial number: #d
CN: *.hacker.com,SSLConnection.cpp:3383
Crypto,21/03/2013,18:30:03:161,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.checkServerCertificateIdentity - CN field found. Checking match...,SSLConnection.cpp:3387
Crypto,21/03/2013,18:30:03:161,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, CryptoLib.CSSL.x509ExceptionCallback - server certificate validation has failed.,SSL.cpp:1290
Crypto,21/03/2013,18:30:03:161,WARN ,3047406480,NIL-CONTEXT,Crypto::Result=1, Crypto.SSLConnection.pvClientInfoCB - Alert raised: code=0x230=560, where=0x4008=16392, source=local,SSLConnection.cpp:2724
Crypto,21/03/2013,18:30:03:161,WARN ,3047406480,NIL-CONTEXT,Crypto::Result=102, Crypto.SSLConnection.writeData - failed write the data,SSLConnection.cpp:934
Connection,21/03/2013,18:30:03:161,ERROR,3047406480,LdapSslConnectionContext::checkCryptoResult(id = 512): crypto result = 102,LdapSslConnectionContext.cpp:206
Connection,21/03/2013,18:30:03:161,ERROR,3047406480,LdapSslConnectionContext::checkCryptoResult(id = 512): error message = SSL alert: code=0x230=560 ; source=local ; type=fatal ; message="Unknown CA - Unable to get CRL",LdapSslConnectionContext.cpp:215
Crypto,21/03/2013,18:30:03:161,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.pvDone,SSLConnection.cpp:248
Crypto,21/03/2013,18:30:03:161,DEBUG,3047406480,NIL-CONTEXT,Crypto::Result=0, Crypto.SSLConnection.pvDone - removing session from cache,SSLConnection.cpp:294
Connection,21/03/2013,18:30:03:162,DEBUG,3047406480,LdapConnectionContext::closeConnection(id = 512): close the socket,LdapConnectionContext.cpp:163
State,21/03/2013,18:30:03:162,DEBUG,3047406480,LdapConnectionInitState::onState(id = -1),LdapConnectionStates.cpp:163
Server,21/03/2013,18:30:03:162,ERROR,3047406480,cntx=0000000352,sesn=vinson1/153252549/3,user=abergin,LdapServer::onAcquireConnectionResponse: failed to acquire connection,LdapServer.cpp:704

			1.1.8.11
		1.1.9 ToI to Anatoly 

- rfc rfc4513
- spec
|      When ACS performs user authentication/authorization (attribute/group retrieval) against LDAP server it is susceptible to a spoofing attack.
|      LDAP server can be spoofed if an attacker has the ability to establish rogue LDAP server using a real LDAP server IP address (which can be achieved by another attack on the network) and have a valid certificate issued by the same CA as valid LDAP server certificate.
|      ACS is required to perform identify verification on the LDAP server's certificate according to rfc-4513 - Lightweight Directory Access Protocol (LDAP): Authentication Methods and Security Mechanisms.
|      The identity verification consists of:					
|      1. Check format of hostname in LDAP configuration and classify it as either DNS or IPv4.
|      	1.1 If DNS format then extract host name and domain
|      2. From incoming server certificate extract the names from x509 SUBJECT_ALT_NAME section 
|      3. Iterate over the list acquired in step 2. 
|      	3.1 If current alt. name is of DNS type and step 1 classification is DNS then compare both host names. If they are equal then flag successful verification and stop checking further.
|      	3.2 If current alt. name is of DNS type and step 1 classification is DNS then check for '*' prefix (wildcard). If so, do two sanity checks: a. 2nd character of alt. name is '.'. ; and b. The lengths match; 
|        After the sanity checks compare the domain parts and if matches then flag successful verification and stop checking further.
|      	3.3 If current alt. name is of IPv4 type and step 1 classification is IPv4 then compare both host names IP addresses. If they are equal then flag successful verification and stop checking further.
|      4. If no x509 SUBJECT_ALT_NAME section is found then extract the CN 
|      	4.1 If CN is equal to the LDAP configuration hostname then flag successful verification, if not then
|      	4.2 check for '*' prefix (wildcard). If so, do two sanity checks: a. 2nd character of alt. name is '.'. ; and b. The lengths match; 
|        After the sanity checks compare the domain parts and if matches then flag successful verification and stop checking further.
|      5. If all previous checks have failed then flag failed verification
| 
| See examples
| LDAP hostname configuration	SAN (or CN) hostname	Match?
| Host.domain.com	Host.domain.com	yes
| Host.domain.com	*.domain.com	yes
| 1.2.3.4	1.2.3.4	yes
| Host.domain.com	OtherHost.domain.com	no
| Host.domain.com	*.other.domain.com	no

- Clearcase
Stream:    yizaq_5_5_dev.int.acs5_0                   

- code

==================================================================================================================================
||        View yizaq__yizaq_5_5_dev.int.acs5_0.lx                                                                               ||
==================================================================================================================================
||        Activity yizaq_CSCtw87143_LDAP_Spoofing                                                                               ||
==================================================================================================================================
||        Files:                                                                                                                ||
||        /vob/nm_acs/acs/mgmt/gui/app/src/main/java/com/cisco/nm/acs/mgmt/gui/app/entities/ExternalDBsGUIEntity.java           ||
||        /vob/nm_acs/acs/mgmt/gui/app/src/main/java/com/cisco/nm/acs/mgmt/gui/app/forms/ExternalDBsLPActionForm.java           ||
||        /vob/nm_acs/acs/mgmt/gui/app/src/main/resources/com/cisco/nm/acs/mgmt/gui/app/app_IdentityElements.properties         ||
||        /vob/nm_acs/acs/mgmt/gui/app/src/main/webapp/pages/ExternalDBs/ExternalDBs.js                                         ||
||        /vob/nm_acs/acs/mgmt/gui/app/src/main/webapp/pages/ExternalDBs/ExternalDBs_step2.jsp                                  ||
||        /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapServerConfig.cpp                                                 ||
||        /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslConnectionContext.cpp                                         ||
||        /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslConnectionContext.h                                           ||
||        /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslContext.cpp                                                   ||
||        /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslContext.h                                                     ||
||        /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/Certificate.cpp                                                  ||
||        /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/Certificate.h                                                    ||
||        /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSLContext.cpp                                                   ||
||        /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSLContext.h                                                     ||
||        /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSL.cpp                                                          ||
||        /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSLInterface.h                                                   ||
==================================================================================================================================
Diff of recent activity:
----------------------------------------------------------------------------------------------------
Usage: ct_diff_act_txt <act>, ex: Phase2Bugs2 will search on vob @/vob/nmtgre_proj
NOTE!!! All files must be checked in!!!
Diff of file /vob/nm_acs/acs/mgmt/gui/app/src/main/java/com/cisco/nm/acs/mgmt/gui/app/entities/ExternalDBsGUIEntity.java@@/main/int.acs5_0/yizaq_5_5_dev.int.acs5_0/1 vs. branch base
828,835d827
< 
<                 if (connection.isEnableServerIdentityCheck()) {
<                     actionForm.setPrimaryCheckServerIdentity(
<                             AppConstants.ON_VALUE);
<                 } else {
<                     actionForm.setPrimaryCheckServerIdentity(
<                             AppConstants.OFF_VALUE);
<                 }
872,878d863
<                 if (connection.isEnableServerIdentityCheck()) {
<                     actionForm.setSecondaryCheckServerIdentity(
<                             AppConstants.ON_VALUE);
<                 } else {
<                     actionForm.setSecondPrimaryCheckServerIdentity(
<                             AppConstants.OFF_VALUE);
<                 }
920,926d904
<             if ((actionForm.getPrimaryCheckServerIdentity() != null)
<                     && (actionForm.getPrimaryCheckServerIdentity()
<                             .compareToIgnoreCase(AppConstants.ON_VALUE) == 0)) {
<                 connection.setEnableServerIdentityCheck(true);
<             } else {
<                 connection.setEnableServerIdentityCheck(false);
<             }
967,973d944
<             if ((actionForm.getSecondaryCheckServerIdentity() != null)
<                     && (actionForm.getSecondaryCheckServerIdentity()
<                             .compareToIgnoreCase(AppConstants.ON_VALUE) == 0)) {
<                 connection.setEnableServerIdentityCheck(true);
<             } else {
<                 connection.setEnableServerIdentityCheck(false);
<             }
Diff of file /vob/nm_acs/acs/mgmt/gui/app/src/main/java/com/cisco/nm/acs/mgmt/gui/app/entities/ExternalDBsGUIEntity.java@@/main/int.acs5_0/yizaq_5_5_dev.int.acs5_0/2 vs. branch base
828,835d827
< 
<                 if (connection.isEnableServerIdentityCheck()) {
<                     actionForm.setPrimaryCheckServerIdentity(
<                             AppConstants.ON_VALUE);
<                 } else {
<                     actionForm.setPrimaryCheckServerIdentity(
<                             AppConstants.OFF_VALUE);
<                 }
872,878d863
<                 if (connection.isEnableServerIdentityCheck()) {
<                     actionForm.setSecondaryCheckServerIdentity(
<                             AppConstants.ON_VALUE);
<                 } else {
<                     actionForm.setSecondaryCheckServerIdentity(
<                             AppConstants.OFF_VALUE);
<                 }
920,926d904
<             if ((actionForm.getPrimaryCheckServerIdentity() != null)
<                     && (actionForm.getPrimaryCheckServerIdentity()
<                             .compareToIgnoreCase(AppConstants.ON_VALUE) == 0)) {
<                 connection.setEnableServerIdentityCheck(true);
<             } else {
<                 connection.setEnableServerIdentityCheck(false);
<             }
967,973d944
<             if ((actionForm.getSecondaryCheckServerIdentity() != null)
<                     && (actionForm.getSecondaryCheckServerIdentity()
<                             .compareToIgnoreCase(AppConstants.ON_VALUE) == 0)) {
<                 connection.setEnableServerIdentityCheck(true);
<             } else {
<                 connection.setEnableServerIdentityCheck(false);
<             }
Diff of file /vob/nm_acs/acs/mgmt/gui/app/src/main/java/com/cisco/nm/acs/mgmt/gui/app/forms/ExternalDBsLPActionForm.java@@/main/int.acs5_0/yizaq_5_5_dev.int.acs5_0/1 vs. branch base
98,103d97
<      * If true, this enables verifying server certificate identity
<      */
<     private String primaryCheckServerIdentity;
< 
< 
<     /**
151,156d144
<      * If true, this enables verifying server certificate identity
<      */
<     private String secondaryCheckServerIdentity;
< 
< 
<     /**
806,821d793
<      * @return the  primaryCheckServerIdentity
<      */
<     public final String getPrimaryCheckServerIdentity() {
<         return  primaryCheckServerIdentity;
<     }
< 
<     /**
<      * @param primaryCheckServerIdentity the
<      * primaryCheckServerIdentity to set
<      */
<     public final void setPrimaryCheckServerIdentity(
<             final String primaryCheckServerIdentityParam) {
<         this.primaryCheckServerIdentity = primaryCheckServerIdentityParam;
<     }
< 
<     /**
852,868d823
<     }
< 
<     /**
<      * @return the secondaryCheckServerIdentity
<      */
<     public final String getsecondaryCheckServerIdentity() {
<         return secondaryCheckServerIdentity;
<     }
< 
<     /**
<      * @param secondaryCheckServerIdentityParam the
<      * secondaryCheckServerIdentity to set
<      */
<     public final void setSecondaryCheckServerIdentity(
<             final String secondaryCheckServerIdentityParam) {
<         this.secondaryCheckServerIdentity =
<             secondaryCheckServerIdentityParam;
Diff of file /vob/nm_acs/acs/mgmt/gui/app/src/main/java/com/cisco/nm/acs/mgmt/gui/app/forms/ExternalDBsLPActionForm.java@@/main/int.acs5_0/yizaq_5_5_dev.int.acs5_0/2 vs. branch base
98,103d97
<      * If true, this enables verifying server certificate identity
<      */
<     private String primaryCheckServerIdentity;
< 
< 
<     /**
151,156d144
<      * If true, this enables verifying server certificate identity
<      */
<     private String secondaryCheckServerIdentity;
< 
< 
<     /**
806,821d793
<      * @return the  primaryCheckServerIdentity
<      */
<     public final String getPrimaryCheckServerIdentity() {
<         return  primaryCheckServerIdentity;
<     }
< 
<     /**
<      * @param primaryCheckServerIdentity the
<      * primaryCheckServerIdentity to set
<      */
<     public final void setPrimaryCheckServerIdentity(
<             final String primaryCheckServerIdentityParam) {
<         this.primaryCheckServerIdentity = primaryCheckServerIdentityParam;
<     }
< 
<     /**
852,868d823
<     }
< 
<     /**
<      * @return the secondaryCheckServerIdentity
<      */
<     public final String getSecondaryCheckServerIdentity() {
<         return secondaryCheckServerIdentity;
<     }
< 
<     /**
<      * @param secondaryCheckServerIdentityParam the
<      * secondaryCheckServerIdentity to set
<      */
<     public final void setSecondaryCheckServerIdentity(
<             final String secondaryCheckServerIdentityParam) {
<         this.secondaryCheckServerIdentity =
<             secondaryCheckServerIdentityParam;
Diff of file /vob/nm_acs/acs/mgmt/gui/app/src/main/resources/com/cisco/nm/acs/mgmt/gui/app/app_IdentityElements.properties@@/main/int.acs5_0/yizaq_5_5_dev.int.acs5_0/1 vs. branch base
26d25
< acs.gui.app.external_DBs.label_check_server_identity = Check Server Identity
Diff of file /vob/nm_acs/acs/mgmt/gui/app/src/main/webapp/pages/ExternalDBs/ExternalDBs.js@@/main/int.acs5_0/yizaq_5_5_dev.int.acs5_0/1 vs. branch base
16,27d15
< function enableDisableDualObject(ObjectName1, ObjectName2, state) {
< 
< 	if (state){
< 		cuesManageFormFieldState(ObjectName1,'enable');
< 		cuesManageFormFieldState(ObjectName2,'enable');
< 
< 	} else {
< 		 cuesManageFormFieldState(ObjectName1,'disable');
< 		 cuesManageFormFieldState(ObjectName2,'disable');
< 	}
< }
< 
Diff of file /vob/nm_acs/acs/mgmt/gui/app/src/main/webapp/pages/ExternalDBs/ExternalDBs_step2.jsp@@/main/int.acs5_0/yizaq_5_5_dev.int.acs5_0/1 vs. branch base
279c279
< 								onclick="enableDisableDualObject('primarySecureConnectionCert', 'primaryCheckServerIdentity', this.checked);" />
---
> 								onclick="enableDisableSingleObject('primarySecureConnectionCert', this.checked);" />
283,295d282
< 						</td></tr></table>
< 					</td>
< 				</tr>
< 				<tr>
< 					<td colspan="2">
< 						<table border="0"><tr><td>
< 							<cues:requiredfield required="false"/>
< 								<html:checkbox
< 								property="primaryCheckServerIdentity"
< 								/>
< 						</td><td>
< 							<bean:message bundle="<%=AppConstants.APP_ID_ELEM_PROPERTIES_KEY%>"
< 								key="acs.gui.app.external_DBs.label_check_server_identity" />
461c448
< 								onclick="enableDisableDualObject('secondarySecureConnectionCert', 'secondaryCheckServerIdentity', this.checked);" />
---
> 								onclick="enableDisableSingleObject('secondarySecureConnectionCert',this.checked);" />
465,477d451
< 						</td></tr></table>
< 					</td>
< 				</tr>
< 				<tr>
< 					<td colspan="2">
< 						<table border="0"><tr><td>
< 							<cues:requiredfield required="false"/>
< 								<html:checkbox
< 								property="secondaryCheckServerIdentity"
< 								/>
< 						</td><td>
< 							<bean:message bundle="<%=AppConstants.APP_ID_ELEM_PROPERTIES_KEY%>"
< 								key="acs.gui.app.external_DBs.label_check_server_identity" />
Diff of file /vob/nm_acs/acs/mgmt/gui/app/src/main/webapp/pages/ExternalDBs/ExternalDBs_step2.jsp@@/main/int.acs5_0/yizaq_5_5_dev.int.acs5_0/2 vs. branch base
279c279
< 								onclick="enableDisableDualObject('primarySecureConnectionCert', 'primaryCheckServerIdentity', this.checked);" />
---
> 								onclick="enableDisableSingleObject('primarySecureConnectionCert', this.checked);" />
283,295d282
< 						</td></tr></table>
< 					</td>
< 				</tr>
< 				<tr>
< 					<td colspan="2">
< 						<table border="0"><tr><td>
< 							<cues:requiredfield required="false"/>
< 								<html:checkbox
< 								property="primaryCheckServerIdentity"
< 								/>
< 						</td><td>
< 							<bean:message bundle="<%=AppConstants.APP_ID_ELEM_PROPERTIES_KEY%>"
< 								key="acs.gui.app.external_DBs.label_check_server_identity" />
461c448
< 								onclick="enableDisableDualObject('secondarySecureConnectionCert', 'secondaryCheckServerIdentity', this.checked);" />
---
> 								onclick="enableDisableSingleObject('secondarySecureConnectionCert',this.checked);" />
465,477d451
< 						</td></tr></table>
< 					</td>
< 				</tr>
< 				<tr>
< 					<td colspan="2">
< 						<table border="0"><tr><td>
< 							<cues:requiredfield required="false"/>
< 								<html:checkbox
< 								property="secondaryCheckServerIdentity"
< 								/>
< 						</td><td>
< 							<bean:message bundle="<%=AppConstants.APP_ID_ELEM_PROPERTIES_KEY%>"
< 								key="acs.gui.app.external_DBs.label_check_server_identity" />
563d536
< 		enableDisableSingleObject('primaryCheckServerIdentity', false);
566d538
< 		enableDisableSingleObject('secondarySecureConnectionCert', false);
590d561
< 		    enableDisableSingleObject('primaryCheckServerIdentity', false);
Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapServerConfig.cpp@@/main/int.acs5_0/yizaq_5_5_dev.int.acs5_0/1 vs. branch base
68c68
<         m_pSslContext = new LdapSslContext (); 
---
>         m_pSslContext = new LdapSslContext; 
71d70
<         m_pSslContext->setConnectionConfig(m_connection);
Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslConnectionContext.cpp@@/main/int.acs5_0/yizaq_5_5_dev.int.acs5_0/1 vs. branch base
42,44d41
< 
<         m_log.log_msg(__FILE__, __LINE__, AcsDebugLog::INFO, "LdapSslConnectionContext::initSslSession: setting connection context on SSLConnection");
<         m_pSslConnection->setConnectionUserData((void *) &m_sslContext);
260,261d256
< 
< 
Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslConnectionContext.h@@/main/int.acs5_0/yizaq_5_5_dev.int.acs5_0/1 vs. branch base
67d66
< 
Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslContext.cpp@@/main/int.acs5_0/yizaq_5_5_dev.int.acs5_0/1 vs. branch base
32,76d31
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  LdapSslContext :: getConnectionConfig
<  * Description:  return ConfigLDAPConnectionAdapter member
<  *--------------------------------------------------------------------------------------
<  */
< const ConfigLDAPConnectionAdapter & LdapSslContext::getConnectionConfig() const
< {
<         return m_ConfigConnection;
< }
< 
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  LdapSslContext :: setConnectionConfig
<  * Description:  return ConfigLDAPConnectionAdapter member
<  *--------------------------------------------------------------------------------------
<  */
< void LdapSslContext::setConnectionConfig(ConfigLDAPConnectionAdapter & cfg)
< {
<         m_ConfigConnection = cfg;
< }
< 
< void LdapSslContext::tlsLDAP_Cert_Check_CB(Crypto::ISSLConnection* pSSLConnection, Crypto::TLS_NOTIFY nTlsNotify, void* param)
< {
< 	AcsDebugLog TempLogger ("Acs.RT.idstores.LDAP.SSLContext.tlsLDAP_Cert_Check_CB");
<     //TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Checking server certificate validity against the configured host name: %s", m_hostname.c_str() );
< 
<     if ( pSSLConnection )
<     {
<        LdapSslContext * pLSC = (LdapSslContext *) pSSLConnection->getConnectionUserData(); 
<        string s_hostname = pLSC->getConnectionConfig().hostName();
<        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Received configured host name: %s",s_hostname);
<     }
<     else
<     {
< 
<        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::WARN, "Did not receive a valid SSLConnection object");
<         return;
<     }
< 
< 
< }
< 
112,114d66
< 
<     //set server certificate validation callback
<     clientParams.fnTlsLDAP_CertCheckCB =  LdapSslContext::tlsLDAP_Cert_Check_CB;
Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslContext.cpp@@/main/int.acs5_0/yizaq_5_5_dev.int.acs5_0/2 vs. branch base
32,76d31
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  LdapSslContext :: getConnectionConfig
<  * Description:  return ConfigLDAPConnectionAdapter member
<  *--------------------------------------------------------------------------------------
<  */
< const ConfigLDAPConnectionAdapter & LdapSslContext::getConnectionConfig() const
< {
<         return m_ConfigConnection;
< }
< 
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  LdapSslContext :: setConnectionConfig
<  * Description:  return ConfigLDAPConnectionAdapter member
<  *--------------------------------------------------------------------------------------
<  */
< void LdapSslContext::setConnectionConfig(ConfigLDAPConnectionAdapter & cfg)
< {
<         m_ConfigConnection = cfg;
< }
< 
< int LdapSslContext::tlsLDAP_Cert_Check_CB(Crypto::ISSLConnection* pSSLConnection, Crypto::TLS_NOTIFY nTlsNotify, void* param)
< {
< 	AcsDebugLog TempLogger ("Acs.RT.idstores.LDAP.SSLContext.tlsLDAP_Cert_Check_CB");
<     //TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Checking server certificate validity against the configured host name: %s", m_hostname.c_str() );
< 
<     if ( pSSLConnection )
<     {
<        LdapSslContext * pLSC = (LdapSslContext *) pSSLConnection->getConnectionUserData(); 
<        string s_hostname = pLSC->getConnectionConfig().hostName();
<        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Received configured host name: %s",s_hostname.c_str());
<     }
<     else
<     {
< 
<        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::WARN, "Did not receive a valid SSLConnection object");
<         return 1;
<     }
< 
<     return 0;
< }
< 
112,114d66
< 
<     //set server certificate validation callback
<     clientParams.fnTlsLDAP_CertCheckCB =  LdapSslContext::tlsLDAP_Cert_Check_CB;
Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslContext.cpp@@/main/int.acs5_0/yizaq_5_5_dev.int.acs5_0/3 vs. branch base
15,18d14
< #include <sys/socket.h>
< #include <netinet/in.h>
< #include <arpa/inet.h>
< 
36,149d31
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  LdapSslContext :: getConnectionConfig
<  * Description:  return ConfigLDAPConnectionAdapter member
<  *--------------------------------------------------------------------------------------
<  */
< const ConfigLDAPConnectionAdapter & LdapSslContext::getConnectionConfig() const
< {
<         return m_ConfigConnection;
< }
< 
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  LdapSslContext :: setConnectionConfig
<  * Description:  return ConfigLDAPConnectionAdapter member
<  *--------------------------------------------------------------------------------------
<  */
< void LdapSslContext::setConnectionConfig(ConfigLDAPConnectionAdapter & cfg)
< {
<         m_ConfigConnection = cfg;
< }
< 
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  tlsLDAP_Cert_Check_CB
<  * Description:  
<  *     When ACS performs user authentication/authorization (attribute/group retrieval) against LDAP server it is susceptible to a spoofing attack.
<  *     LDAP server can be spoofed if an attacker has the ability to establish rogue LDAP server using a real LDAP server IP address (which can be achieved by another attack on the network) and have a valid certificate issued by the same CA as valid LDAP server certificate.
<  *     ACS is required to perform identify verification on the LDAP server's certificate according to rfc-4513 - Lightweight Directory Access Protocol (LDAP): Authentication Methods and Security Mechanisms.
<  *     The identity verification consists of:					
<  *     1. Check format of hostname in LDAP configuration and classify it as either DNS or IPv4.
<  *     	1.1 If DNS format then extract host name and domain
<  *     2. From incoming server certificate extract the names from x509 SUBJECT_ALT_NAME section 
<  *     3. Iterate over the list acquired in step 2. 
<  *     	3.1 If current alt. name is of DNS type and step 1 classification is DNS then compare both host names. If they are equal then flag successful verification and stop checking further.
<  *     	3.2 If current alt. name is of DNS type and step 1 classification is DNS then check for '*' prefix (wildcard). If so, do two sanity checks: a. 2nd character of alt. name is '.'. ; and b. The lengths match; 
<  *   After the sanity checks compare the domain parts and if matches then flag successful verification and stop checking further.
<  *     	3.3 If current alt. name is of IPv4 type and step 1 classification is IPv4 then compare both host names IP addresses. If they are equal then flag successful verification and stop checking further.
<  *     4. If no x509 SUBJECT_ALT_NAME section is found then extract the CN 
<  *     	4.1 If CN is equal to the LDAP configuration hostname then flag successful verification, if not then
<  *     	4.2 check for '*' prefix (wildcard). If so, do two sanity checks: a. 2nd character of alt. name is '.'. ; and b. The lengths match; 
<  *   After the sanity checks compare the domain parts and if matches then flag successful verification and stop checking further.
<  *     5. If all previous checks have failed then flag failed verification
<  * author: yizaq 
<  *--------------------------------------------------------------------------------------
<  */
< int LdapSslContext::tlsLDAP_Cert_Check_CB(Crypto::ISSLConnection* pSSLConnection, Crypto::TLS_NOTIFY nTlsNotify, void* param)
< {
< 	AcsDebugLog TempLogger ("Acs.RT.idstores.LDAP.SSLContext.tlsLDAP_Cert_Check_CB");
<     //TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Checking server certificate validity against the configured host name: %s", m_hostname.c_str() );
< 
<     if ( pSSLConnection )
<     {
<        Crypto::TypesOfSAN h_type = Crypto::SAN_TYPE_DNS; // default to DNS
<        LdapSslContext * pLSC = (LdapSslContext *) pSSLConnection->getConnectionUserData(); 
<        string s_hostname = pLSC->getConnectionConfig().hostName();
<        struct in_addr addr;
<        if (inet_aton(s_hostname.c_str(), (struct in_addr *)&addr)) h_type = Crypto::SAN_TYPE_IP_ADDR;
< 
<        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Received configured host name: %s, type %s",s_hostname.c_str(), h_type == Crypto::SAN_TYPE_DNS ? "DNS" : "IP Address");
< 
<        
<    	    Crypto::Result rc = Crypto::RESULT_OK;
< 	    Crypto::ICertificate* pCertificate = 0;
< 	    rc = pSSLConnection->getPeerCertificate(&pCertificate);
<         if (rc != Crypto::RESULT_OK)
<         {
< 
<            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::WARN, "Error getting peer certificate from SSL Connection; rc=%d", rc);
<             return 1;
<         }
<         else // We have a valid certificate
<         {
<            char   sCertField[4096];
<            size_t iCertFieldSize= 0 ;
< 
<            iCertFieldSize = sizeof(sCertField) ; memset(sCertField,0,iCertFieldSize ) ;
<            rc= pCertificate->getSerialNumber((unsigned char*)sCertField,&iCertFieldSize );
<            string sCertSerialNumber = sCertField;
< 
<            iCertFieldSize = sizeof(sCertField) ; memset(sCertField,0,iCertFieldSize ) ;
<            rc= pCertificate->getSubject((char*)sCertField,&iCertFieldSize );
<            string sCertSubject = sCertField;
< 
<            iCertFieldSize = sizeof(sCertField) ; memset(sCertField,0,iCertFieldSize ) ;
<            rc= pCertificate->getSubjectCN((char*)sCertField,&iCertFieldSize );
<            string sCertSubjectCN = sCertField;
< 
< 
<            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Extracted server certificate:\nsubject: %s\nserial number: %s\nCN: %s", sCertSubject.c_str(), sCertSerialNumber.c_str(), sCertSubjectCN.c_str());
< 
<            std::vector<Crypto::SAN_GeneralName> vec;
<            rc= pCertificate->getSANs(vec, Crypto::SAN_TYPE_ANY);
<            unsigned int uiSAN_ctr = 0;
<            for (std::vector<Crypto::SAN_GeneralName>::iterator i = vec.begin(); i!= vec.end(); ++i)
<            {
< 
<                TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Extracted SAN field number %d, value %s, type %d", uiSAN_ctr, (*i).san_value.c_str(),  (*i).san_type);
<            }
<         } //else 
<     }// if ( pSSLConnection )
<     else
<     {
< 
<        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::WARN, "Did not receive a valid SSLConnection object");
<         return 1;
<     }
< 
<     return 0;
< }
< 
185,187d66
< 
<     //set server certificate validation callback
<     clientParams.fnTlsServer_CertCheckCB =  LdapSslContext::tlsLDAP_Cert_Check_CB;
Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslContext.cpp@@/main/int.acs5_0/yizaq_5_5_dev.int.acs5_0/4 vs. branch base
15,18d14
< #include <sys/socket.h>
< #include <netinet/in.h>
< #include <arpa/inet.h>
< 
36,161d31
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  LdapSslContext :: getConnectionConfig
<  * Description:  return ConfigLDAPConnectionAdapter member
<  *--------------------------------------------------------------------------------------
<  */
< const ConfigLDAPConnectionAdapter & LdapSslContext::getConnectionConfig() const
< {
<         return m_ConfigConnection;
< }
< 
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  LdapSslContext :: setConnectionConfig
<  * Description:  return ConfigLDAPConnectionAdapter member
<  *--------------------------------------------------------------------------------------
<  */
< void LdapSslContext::setConnectionConfig(ConfigLDAPConnectionAdapter & cfg)
< {
<         m_ConfigConnection = cfg;
< }
< 
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  tlsLDAP_Cert_Check_CB
<  * Description:  
<  *     When ACS performs user authentication/authorization (attribute/group retrieval) against LDAP server it is susceptible to a spoofing attack.
<  *     LDAP server can be spoofed if an attacker has the ability to establish rogue LDAP server using a real LDAP server IP address (which can be achieved by another attack on the network) and have a valid certificate issued by the same CA as valid LDAP server certificate.
<  *     ACS is required to perform identify verification on the LDAP server's certificate according to rfc-4513 - Lightweight Directory Access Protocol (LDAP): Authentication Methods and Security Mechanisms.
<  *     The identity verification consists of:					
<  *     1. Check format of hostname in LDAP configuration and classify it as either DNS or IPv4.
<  *     	1.1 If DNS format then extract host name and domain
<  *     2. From incoming server certificate extract the names from x509 SUBJECT_ALT_NAME section 
<  *     3. Iterate over the list acquired in step 2. 
<  *     	3.1 If current alt. name is of DNS type and step 1 classification is DNS then compare both host names. If they are equal then flag successful verification and stop checking further.
<  *     	3.2 If current alt. name is of DNS type and step 1 classification is DNS then check for '*' prefix (wildcard). If so, do two sanity checks: a. 2nd character of alt. name is '.'. ; and b. The lengths match; 
<  *   After the sanity checks compare the domain parts and if matches then flag successful verification and stop checking further.
<  *     	3.3 If current alt. name is of IPv4 type and step 1 classification is IPv4 then compare both host names IP addresses. If they are equal then flag successful verification and stop checking further.
<  *     4. If no x509 SUBJECT_ALT_NAME section is found then extract the CN 
<  *     	4.1 If CN is equal to the LDAP configuration hostname then flag successful verification, if not then
<  *     	4.2 check for '*' prefix (wildcard). If so, do two sanity checks: a. 2nd character of alt. name is '.'. ; and b. The lengths match; 
<  *   After the sanity checks compare the domain parts and if matches then flag successful verification and stop checking further.
<  *     5. If all previous checks have failed then flag failed verification
<  * author: yizaq 
<  *--------------------------------------------------------------------------------------
<  */
< int LdapSslContext::tlsLDAP_Cert_Check_CB(Crypto::ISSLConnection* pSSLConnection, Crypto::TLS_NOTIFY nTlsNotify, void* param)
< {
< 	AcsDebugLog TempLogger ("Acs.RT.idstores.LDAP.SSLContext.tlsLDAP_Cert_Check_CB");
<     //TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Checking server certificate validity against the configured host name: %s", m_hostname.c_str() );
< 
<     if (param == NULL )
<     {
<         TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::ERR, "Error getting peer certificate");
<         return 1;
<     }
< 
<     if ( pSSLConnection )
<     {
<        Crypto::TypesOfSAN h_type = Crypto::SAN_TYPE_DNS; // default to DNS
<        LdapSslContext * pLSC = (LdapSslContext *) pSSLConnection->getConnectionUserData(); 
<        string s_hostname = pLSC->getConnectionConfig().hostName();
<        struct in_addr addr;
<        if (inet_aton(s_hostname.c_str(), (struct in_addr *)&addr)) h_type = Crypto::SAN_TYPE_IP_ADDR;
< 
<        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Received configured host name: %s, type %s",s_hostname.c_str(), h_type == Crypto::SAN_TYPE_DNS ? "DNS" : "IP Address");
< 
<        
<    	    Crypto::Result rc = Crypto::RESULT_OK;
<         Crypto::ICertificateManager* pCertMgr = Crypto::getCertificateManagerInterface();
<         if (!pCertMgr)
<         {
<            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::ERR, "Error - failed receiving the cryptographic certificate manager");
<            return 1;
<         }
<         Crypto::ICertificate *pCertificate = NULL;
<         rc = pCertMgr->createCertificate(&pCertificate, param);
<         if (rc != Crypto::RESULT_OK)
<         {
< 
<            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::WARN, "Error initilizing certificate from X509 pointer; rc=%d", rc);
<             return 1;
<         }
<         else // We have a valid certificate
<         {
<            char   sCertField[4096];
<            size_t iCertFieldSize= 0 ;
< 
<            iCertFieldSize = sizeof(sCertField) ; memset(sCertField,0,iCertFieldSize ) ;
<            rc= pCertificate->getSerialNumber((unsigned char*)sCertField,&iCertFieldSize );
<            string sCertSerialNumber = sCertField;
< 
<            iCertFieldSize = sizeof(sCertField) ; memset(sCertField,0,iCertFieldSize ) ;
<            rc= pCertificate->getSubject((char*)sCertField,&iCertFieldSize );
<            string sCertSubject = sCertField;
< 
<            iCertFieldSize = sizeof(sCertField) ; memset(sCertField,0,iCertFieldSize ) ;
<            rc= pCertificate->getSubjectCN((char*)sCertField,&iCertFieldSize );
<            string sCertSubjectCN = sCertField;
< 
< 
<            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Extracted server certificate:\nsubject: %s\nserial number: %s\nCN: %s", sCertSubject.c_str(), sCertSerialNumber.c_str(), sCertSubjectCN.c_str());
< 
<            std::vector<Crypto::SAN_GeneralName> vec;
<            rc= pCertificate->getSANs(vec, Crypto::SAN_TYPE_ANY);
<            unsigned int uiSAN_ctr = 0;
<            for (std::vector<Crypto::SAN_GeneralName>::iterator i = vec.begin(); i!= vec.end(); ++i)
<            {
< 
<                TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Extracted SAN field number %d, value %s, type %d", uiSAN_ctr, (*i).san_value.c_str(),  (*i).san_type);
<            }
<         } //else 
<     }// if ( pSSLConnection )
<     else
<     {
< 
<        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::WARN, "Did not receive a valid SSLConnection object");
<         return 1;
<     }
< 
<     return 0;
< }
< 
197,199d66
< 
<     //set server certificate validation callback
<     clientParams.fnTlsServer_CertCheckCB =  LdapSslContext::tlsLDAP_Cert_Check_CB;
Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslContext.cpp@@/main/int.acs5_0/yizaq_5_5_dev.int.acs5_0/5 vs. branch base
15,18d14
< #include <sys/socket.h>
< #include <netinet/in.h>
< #include <arpa/inet.h>
< 
36,226d31
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  LdapSslContext :: getConnectionConfig
<  * Description:  return ConfigLDAPConnectionAdapter member
<  *--------------------------------------------------------------------------------------
<  */
< const ConfigLDAPConnectionAdapter & LdapSslContext::getConnectionConfig() const
< {
<         return m_ConfigConnection;
< }
< 
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  LdapSslContext :: setConnectionConfig
<  * Description:  return ConfigLDAPConnectionAdapter member
<  *--------------------------------------------------------------------------------------
<  */
< void LdapSslContext::setConnectionConfig(ConfigLDAPConnectionAdapter & cfg)
< {
<         m_ConfigConnection = cfg;
< }
< 
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  tlsLDAP_Cert_Check_CB
<  * Description:  
<  *     When ACS performs user authentication/authorization (attribute/group retrieval) against LDAP server it is susceptible to a spoofing attack.
<  *     LDAP server can be spoofed if an attacker has the ability to establish rogue LDAP server using a real LDAP server IP address (which can be achieved by another attack on the network) and have a valid certificate issued by the same CA as valid LDAP server certificate.
<  *     ACS is required to perform identify verification on the LDAP server's certificate according to rfc-4513 - Lightweight Directory Access Protocol (LDAP): Authentication Methods and Security Mechanisms.
<  *     The identity verification consists of:					
<  *     1. Check format of hostname in LDAP configuration and classify it as either DNS or IPv4.
<  *     	1.1 If DNS format then extract host name and domain
<  *     2. From incoming server certificate extract the names from x509 SUBJECT_ALT_NAME section 
<  *     3. Iterate over the list acquired in step 2. 
<  *     	3.1 If current alt. name is of DNS type and step 1 classification is DNS then compare both host names. If they are equal then flag successful verification and stop checking further.
<  *     	3.2 If current alt. name is of DNS type and step 1 classification is DNS then check for '*' prefix (wildcard). If so, do two sanity checks: a. 2nd character of alt. name is '.'. ; and b. The lengths match; 
<  *   After the sanity checks compare the domain parts and if matches then flag successful verification and stop checking further.
<  *     	3.3 If current alt. name is of IPv4 type and step 1 classification is IPv4 then compare both host names IP addresses. If they are equal then flag successful verification and stop checking further.
<  *     4. If no x509 SUBJECT_ALT_NAME section is found then extract the CN 
<  *     	4.1 If CN is equal to the LDAP configuration hostname then flag successful verification, if not then
<  *     	4.2 check for '*' prefix (wildcard). If so, do two sanity checks: a. 2nd character of alt. name is '.'. ; and b. The lengths match; 
<  *   After the sanity checks compare the domain parts and if matches then flag successful verification and stop checking further.
<  *     5. If all previous checks have failed then flag failed verification
<  * author: yizaq 
<  *--------------------------------------------------------------------------------------
<  */
< int LdapSslContext::tlsLDAP_Cert_Check_CB(Crypto::ISSLConnection* pSSLConnection, Crypto::TLS_NOTIFY nTlsNotify, void* param)
< {
< 	AcsDebugLog TempLogger ("Acs.RT.idstores.LDAP.SSLContext.tlsLDAP_Cert_Check_CB");
<     //TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Checking server certificate validity against the configured host name: %s", m_hostname.c_str() );
< 
<     if (param == NULL )
<     {
<         TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::ERR, "Error getting peer certificate");
<         return 1;
<     }
< 
<     if ( pSSLConnection )
<     {
<        Crypto::TypesOfSAN h_type = Crypto::SAN_TYPE_DNS; // default to DNS
<        LdapSslContext * pLSC = (LdapSslContext *) pSSLConnection->getConnectionUserData(); 
<        string s_hostname = pLSC->getConnectionConfig().hostName();
<        string s_domain_name ;
<        string s_cert_host ;
< 
<        struct in_addr addr;
<        if (inet_aton(s_hostname.c_str(), (struct in_addr *)&addr)) h_type = Crypto::SAN_TYPE_IP_ADDR;
< 
<        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Received configured host name: %s, type %s",s_hostname.c_str(), h_type == Crypto::SAN_TYPE_DNS ? "DNS" : "IP Address");
< 
<        if (h_type == Crypto::SAN_TYPE_DNS)  
<        {
<            s_domain_name = s_hostname.substr(s_hostname.find('.')); 
<            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Extracted domain: %s",s_domain_name.c_str());
<        }
<        
<    	    Crypto::Result rc = Crypto::RESULT_OK;
<         Crypto::ICertificateManager* pCertMgr = Crypto::getCertificateManagerInterface();
<         if (!pCertMgr)
<         {
<            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::ERR, "Error - failed receiving the cryptographic certificate manager");
<            return 1;
<         }
<         Crypto::ICertificate *pCertificate = NULL;
<         rc = pCertMgr->createCertificate(&pCertificate, param);
<         if (rc != Crypto::RESULT_OK)
<         {
< 
<            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::WARN, "Error initilizing certificate from X509 pointer; rc=%d", rc);
<             return 1;
<         }
<         else // We have a valid certificate
<         {
<            char   sCertField[4096];
<            size_t iCertFieldSize= 0 ;
< 
< 
<            std::vector<Crypto::SAN_GeneralName> vec;
<            rc= pCertificate->getSANs(vec, Crypto::SAN_TYPE_ANY);
<            unsigned int uiSAN_ctr = 0;
<            for (std::vector<Crypto::SAN_GeneralName>::iterator i = vec.begin(); i!= vec.end(); ++i)
<            {
< 
<                s_cert_host = (*i).san_value;
<                TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Extracted SAN field number %d, value %s, type %d", uiSAN_ctr, s_cert_host.c_str(),  (*i).san_type);
< 
<                if ((*i).san_type == Crypto::SAN_TYPE_DNS) {
<                    if (h_type != Crypto::SAN_TYPE_DNS ) continue;
< 
<                    //check exact match
<                    if (s_cert_host == s_hostname )
<                                    {
< 
<                                        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared DNS format host names with exact match");
<                                        return 0;
<                                    }
< 
<                    //check wildcard match
<                    				if ( ( !s_domain_name.empty() ) && s_cert_host[0] == '*' && s_cert_host[1] == '.' && s_domain_name.length() == s_cert_host.length() -1 && (s_domain_name == s_cert_host.substr(1)) ) {
< 
<                                        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared DNS format host names to wildcard expression");
<                                        return 0;
<                                 }
<                    }
<                else if ((*i).san_type == Crypto::SAN_TYPE_IP_ADDR) {
< 
<                    if (h_type != Crypto::SAN_TYPE_IP_ADDR ) continue;
< 
<                    if ( ( s_cert_host.end() - s_cert_host.begin() == sizeof (struct in_addr) ) && ( !memcmp (s_cert_host.data(), &addr, sizeof (struct in_addr)) ) )
<                                    {
<                                        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared IP address format host names ");
<                                        return 0;
< 
<                                    }
<                }
<                        
<            } //for (std::vector<Crypto::SAN_GeneralName>::iterator i = vec.begin(); i!= vec.end(); ++i)
< 
<            iCertFieldSize = sizeof(sCertField) ; memset(sCertField,0,iCertFieldSize ) ;
<            rc= pCertificate->getSerialNumber((unsigned char*)sCertField,&iCertFieldSize );
<            string sCertSerialNumber = sCertField;
< 
<            iCertFieldSize = sizeof(sCertField) ; memset(sCertField,0,iCertFieldSize ) ;
<            rc= pCertificate->getSubject((char*)sCertField,&iCertFieldSize );
<            string sCertSubject = sCertField;
< 
<            iCertFieldSize = sizeof(sCertField) ; memset(sCertField,0,iCertFieldSize ) ;
<            rc= pCertificate->getSubjectCN((char*)sCertField,&iCertFieldSize );
<            string sCertSubjectCN = sCertField;
< 
<            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Extracted server certificate:\nsubject: %s\nserial number: %s\nCN: %s", sCertSubject.c_str(), sCertSerialNumber.c_str(), sCertSubjectCN.c_str());
< 
<            if ( rc==Crypto::RESULT_OK )
<            {
<                TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "CN field found. Checking match...");
< 
<                //check exact match
<                if (sCertSubjectCN == s_hostname )
<                        {
< 
<                            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared CN host name with exact match");
<                            return 0;
<                        }
< 
<                //check wildcard match
<                		if ( ( !s_domain_name.empty() ) && sCertSubjectCN[0] == '*' && sCertSubjectCN[1] == '.' && s_domain_name.length() == sCertSubjectCN.length() -1 && (s_domain_name == sCertSubjectCN) ) {
< 
<                            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared CN host name to wildcard expression");
<                            return 0;
<                     }
<                    
<            }
<            else
<            {
<                TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "CN field not found.");
<            }
<         } //else 
<     }// if ( pSSLConnection )
<     else
<     {
< 
<        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::WARN, "Did not receive a valid SSLConnection object");
<         return 1;
<     }
< 
<     return 1;
< }
< 
262,264d66
< 
<     //set server certificate validation callback
<     clientParams.fnTlsServer_CertCheckCB =  LdapSslContext::tlsLDAP_Cert_Check_CB;
Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslContext.cpp@@/main/int.acs5_0/yizaq_5_5_dev.int.acs5_0/6 vs. branch base
15,18d14
< #include <sys/socket.h>
< #include <netinet/in.h>
< #include <arpa/inet.h>
< 
36,242d31
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  LdapSslContext :: getConnectionConfig
<  * Description:  return ConfigLDAPConnectionAdapter member
<  *--------------------------------------------------------------------------------------
<  */
< const ConfigLDAPConnectionAdapter & LdapSslContext::getConnectionConfig() const
< {
<         return m_ConfigConnection;
< }
< 
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  LdapSslContext :: setConnectionConfig
<  * Description:  return ConfigLDAPConnectionAdapter member
<  *--------------------------------------------------------------------------------------
<  */
< void LdapSslContext::setConnectionConfig(ConfigLDAPConnectionAdapter & cfg)
< {
<         m_ConfigConnection = cfg;
< }
< 
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  tlsLDAP_Cert_Check_CB
<  * Description:  
<  *     When ACS performs user authentication/authorization (attribute/group retrieval) against LDAP server it is susceptible to a spoofing attack.
<  *     LDAP server can be spoofed if an attacker has the ability to establish rogue LDAP server using a real LDAP server IP address (which can be achieved by another attack on the network) and have a valid certificate issued by the same CA as valid LDAP server certificate.
<  *     ACS is required to perform identify verification on the LDAP server's certificate according to rfc-4513 - Lightweight Directory Access Protocol (LDAP): Authentication Methods and Security Mechanisms.
<  *     The identity verification consists of:					
<  *     1. Check format of hostname in LDAP configuration and classify it as either DNS or IPv4.
<  *     	1.1 If DNS format then extract host name and domain
<  *     2. From incoming server certificate extract the names from x509 SUBJECT_ALT_NAME section 
<  *     3. Iterate over the list acquired in step 2. 
<  *     	3.1 If current alt. name is of DNS type and step 1 classification is DNS then compare both host names. If they are equal then flag successful verification and stop checking further.
<  *     	3.2 If current alt. name is of DNS type and step 1 classification is DNS then check for '*' prefix (wildcard). If so, do two sanity checks: a. 2nd character of alt. name is '.'. ; and b. The lengths match; 
<  *   After the sanity checks compare the domain parts and if matches then flag successful verification and stop checking further.
<  *     	3.3 If current alt. name is of IPv4 type and step 1 classification is IPv4 then compare both host names IP addresses. If they are equal then flag successful verification and stop checking further.
<  *     4. If no x509 SUBJECT_ALT_NAME section is found then extract the CN 
<  *     	4.1 If CN is equal to the LDAP configuration hostname then flag successful verification, if not then
<  *     	4.2 check for '*' prefix (wildcard). If so, do two sanity checks: a. 2nd character of alt. name is '.'. ; and b. The lengths match; 
<  *   After the sanity checks compare the domain parts and if matches then flag successful verification and stop checking further.
<  *     5. If all previous checks have failed then flag failed verification
<  * author: yizaq 
<  *--------------------------------------------------------------------------------------
<  */
< int LdapSslContext::tlsLDAP_Cert_Check_CB(Crypto::ISSLConnection* pSSLConnection, Crypto::TLS_NOTIFY nTlsNotify, void* param)
< {
< 	AcsDebugLog TempLogger ("Acs.RT.idstores.LDAP.SSLContext.tlsLDAP_Cert_Check_CB");
<     //TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Checking server certificate validity against the configured host name: %s", m_hostname.c_str() );
< 
<     if (param == NULL )
<     {
<         TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::ERR, "Error getting peer certificate");
<         return 1;
<     }
< 
<     if ( pSSLConnection )
<     {
<        Crypto::TypesOfSAN h_type = Crypto::SAN_TYPE_DNS; // default to DNS
<        LdapSslContext * pLSC = (LdapSslContext *) pSSLConnection->getConnectionUserData(); 
<        string s_hostname = pLSC->getConnectionConfig().hostName();
<        string s_domain_name ;
<        string s_cert_host ;
< 
<        struct in_addr addr;
<        if (inet_aton(s_hostname.c_str(), (struct in_addr *)&addr)) h_type = Crypto::SAN_TYPE_IP_ADDR;
< 
<        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Received configured host name: %s, type %s",s_hostname.c_str(), h_type == Crypto::SAN_TYPE_DNS ? "DNS" : "IP Address");
< 
<        if (h_type == Crypto::SAN_TYPE_DNS)  
<        {
<            if (s_hostname.find('.') != string::npos )
<            {
<                s_domain_name = s_hostname.substr(s_hostname.find('.')); 
<                TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Extracted domain: %s",s_domain_name.c_str());
<            }
<            else
<            {
< 
<                TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Short DNS found. domain part is empty. ");
<                s_domain_name.clear() ;
<            }
<        }
<        
<    	    Crypto::Result rc = Crypto::RESULT_OK;
<         Crypto::ICertificateManager* pCertMgr = Crypto::getCertificateManagerInterface();
<         if (!pCertMgr)
<         {
<            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::ERR, "Error - failed receiving the cryptographic certificate manager");
<            return 1;
<         }
<         Crypto::ICertificate *pCertificate = NULL;
<         rc = pCertMgr->createCertificate(&pCertificate, param);
<         if (rc != Crypto::RESULT_OK)
<         {
< 
<            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::WARN, "Error initilizing certificate from X509 pointer; rc=%d", rc);
< 
<             pCertMgr->destroyCertificate(pCertificate);
<             return 1;
<         }
<         else // We have a valid certificate
<         {
<            char   sCertField[4096];
<            size_t iCertFieldSize= 0 ;
< 
< 
<            std::vector<Crypto::SAN_GeneralName> vec;
<            rc= pCertificate->getSANs(vec, Crypto::SAN_TYPE_ANY);
<            unsigned int uiSAN_ctr = 0;
<            for (std::vector<Crypto::SAN_GeneralName>::iterator i = vec.begin(); i!= vec.end(); ++i)
<            {
< 
<                s_cert_host = (*i).san_value;
<                TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Extracted SAN field number %d, value %s, type %d", uiSAN_ctr, s_cert_host.c_str(),  (*i).san_type);
< 
<                if ((*i).san_type == Crypto::SAN_TYPE_DNS) {
<                    if (h_type != Crypto::SAN_TYPE_DNS ) continue;
< 
<                    //check exact match
<                    if (s_cert_host == s_hostname )
<                                    {
< 
<                                        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared DNS format host names with exact match");
<                                        pCertMgr->destroyCertificate(pCertificate);
<                                        return 0;
<                                    }
< 
<                    //check wildcard match
<                    				if ( ( !s_domain_name.empty() ) && s_cert_host[0] == '*' && s_cert_host[1] == '.' && s_domain_name.length() == s_cert_host.length() -1 && (s_domain_name == s_cert_host.substr(1)) ) {
< 
<                                        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared DNS format host names to wildcard expression");
<                                        pCertMgr->destroyCertificate(pCertificate);
<                                        return 0;
<                                 }
<                    }
<                else if ((*i).san_type == Crypto::SAN_TYPE_IP_ADDR) {
< 
<                    if (h_type != Crypto::SAN_TYPE_IP_ADDR ) continue;
< 
<                    if ( ( s_cert_host.end() - s_cert_host.begin() == sizeof (struct in_addr) ) && ( !memcmp (s_cert_host.data(), &addr, sizeof (struct in_addr)) ) )
<                                    {
<                                        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared IP address format host names ");
<                                        pCertMgr->destroyCertificate(pCertificate);
<                                        return 0;
< 
<                                    }
<                }
<                        
<            } //for (std::vector<Crypto::SAN_GeneralName>::iterator i = vec.begin(); i!= vec.end(); ++i)
< 
<            iCertFieldSize = sizeof(sCertField) ; memset(sCertField,0,iCertFieldSize ) ;
<            pCertificate->getSerialNumber((unsigned char*)sCertField,&iCertFieldSize );
<            string sCertSerialNumber = sCertField;
< 
<            iCertFieldSize = sizeof(sCertField) ; memset(sCertField,0,iCertFieldSize ) ;
<            pCertificate->getSubject((char*)sCertField,&iCertFieldSize );
<            string sCertSubject = sCertField;
< 
<            iCertFieldSize = sizeof(sCertField) ; memset(sCertField,0,iCertFieldSize ) ;
<            rc= pCertificate->getSubjectCN((char*)sCertField,&iCertFieldSize );
<            string sCertSubjectCN = sCertField;
< 
<            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Extracted server certificate:\nsubject: %s\nserial number: %s\nCN: %s", sCertSubject.c_str(), sCertSerialNumber.c_str(), sCertSubjectCN.c_str());
< 
<            if ( rc==Crypto::RESULT_OK )
<            {
<                TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "CN field found. Checking match...");
< 
<                //check exact match
<                if (sCertSubjectCN == s_hostname )
<                        {
< 
<                            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared CN host name with exact match");
<                            pCertMgr->destroyCertificate(pCertificate);
<                            return 0;
<                        }
< 
<                //check wildcard match
<                		if ( ( !s_domain_name.empty() ) && sCertSubjectCN[0] == '*' && sCertSubjectCN[1] == '.' && s_domain_name.length() == sCertSubjectCN.length() -1 && (s_domain_name == sCertSubjectCN) ) {
< 
<                            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared CN host name to wildcard expression");
<                            pCertMgr->destroyCertificate(pCertificate);
<                            return 0;
<                     }
<                    
<            }
<            else
<            {
<                TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "CN field not found.");
<            }
<         } //else 
<     }// if ( pSSLConnection )
<     else
<     {
< 
<        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::WARN, "Did not receive a valid SSLConnection object");
<         return 1;
<     }
< 
<     return 1;
< }
< 
278,280d66
< 
<     //set server certificate validation callback
<     clientParams.fnTlsServer_CertCheckCB =  LdapSslContext::tlsLDAP_Cert_Check_CB;
Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslContext.cpp@@/main/int.acs5_0/yizaq_5_5_dev.int.acs5_0/7 vs. branch base
15,18d14
< #include <sys/socket.h>
< #include <netinet/in.h>
< #include <arpa/inet.h>
< 
36,244d31
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  LdapSslContext :: getConnectionConfig
<  * Description:  return ConfigLDAPConnectionAdapter member
<  *--------------------------------------------------------------------------------------
<  */
< const ConfigLDAPConnectionAdapter & LdapSslContext::getConnectionConfig() const
< {
<         return m_ConfigConnection;
< }
< 
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  LdapSslContext :: setConnectionConfig
<  * Description:  return ConfigLDAPConnectionAdapter member
<  *--------------------------------------------------------------------------------------
<  */
< void LdapSslContext::setConnectionConfig(ConfigLDAPConnectionAdapter & cfg)
< {
<         m_ConfigConnection = cfg;
< }
< 
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  tlsLDAP_Cert_Check_CB
<  * Description:  
<  *     When ACS performs user authentication/authorization (attribute/group retrieval) against LDAP server it is susceptible to a spoofing attack.
<  *     LDAP server can be spoofed if an attacker has the ability to establish rogue LDAP server using a real LDAP server IP address (which can be achieved by another attack on the network) and have a valid certificate issued by the same CA as valid LDAP server certificate.
<  *     ACS is required to perform identify verification on the LDAP server's certificate according to rfc-4513 - Lightweight Directory Access Protocol (LDAP): Authentication Methods and Security Mechanisms.
<  *     The identity verification consists of:					
<  *     1. Check format of hostname in LDAP configuration and classify it as either DNS or IPv4.
<  *     	1.1 If DNS format then extract host name and domain
<  *     2. From incoming server certificate extract the names from x509 SUBJECT_ALT_NAME section 
<  *     3. Iterate over the list acquired in step 2. 
<  *     	3.1 If current alt. name is of DNS type and step 1 classification is DNS then compare both host names. If they are equal then flag successful verification and stop checking further.
<  *     	3.2 If current alt. name is of DNS type and step 1 classification is DNS then check for '*' prefix (wildcard). If so, do two sanity checks: a. 2nd character of alt. name is '.'. ; and b. The lengths match; 
<  *   After the sanity checks compare the domain parts and if matches then flag successful verification and stop checking further.
<  *     	3.3 If current alt. name is of IPv4 type and step 1 classification is IPv4 then compare both host names IP addresses. If they are equal then flag successful verification and stop checking further.
<  *     4. If no x509 SUBJECT_ALT_NAME section is found then extract the CN 
<  *     	4.1 If CN is equal to the LDAP configuration hostname then flag successful verification, if not then
<  *     	4.2 check for '*' prefix (wildcard). If so, do two sanity checks: a. 2nd character of alt. name is '.'. ; and b. The lengths match; 
<  *   After the sanity checks compare the domain parts and if matches then flag successful verification and stop checking further.
<  *     5. If all previous checks have failed then flag failed verification
<  * author: yizaq 
<  *--------------------------------------------------------------------------------------
<  */
< int LdapSslContext::tlsLDAP_Cert_Check_CB(Crypto::ISSLConnection* pSSLConnection, Crypto::TLS_NOTIFY nTlsNotify, void* param)
< {
< 	AcsDebugLog TempLogger ("Acs.RT.idstores.LDAP.SSLContext.tlsLDAP_Cert_Check_CB");
<     //TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Checking server certificate validity against the configured host name: %s", m_hostname.c_str() );
< 
<     if (param == NULL )
<     {
<         TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::ERR, "Error getting peer certificate");
<         return 1;
<     }
< 
<     if ( pSSLConnection )
<     {
<        Crypto::TypesOfSAN h_type = Crypto::SAN_TYPE_DNS; // default to DNS
<        LdapSslContext * pLSC = (LdapSslContext *) pSSLConnection->getConnectionUserData(); 
<        string s_hostname = pLSC->getConnectionConfig().hostName();
<        string s_domain_name ;
<        string s_cert_host ;
< 
<        struct in_addr addr;
<        if (inet_aton(s_hostname.c_str(), (struct in_addr *)&addr)) h_type = Crypto::SAN_TYPE_IP_ADDR;
< 
<        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Received configured host name: %s, type %s",s_hostname.c_str(), h_type == Crypto::SAN_TYPE_DNS ? "DNS" : "IP Address");
< 
<        if (h_type == Crypto::SAN_TYPE_DNS)  
<        {
<            if (s_hostname.find('.') != string::npos )
<            {
<                s_domain_name = s_hostname.substr(s_hostname.find('.')); 
<                TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Extracted domain: %s",s_domain_name.c_str());
<            }
<            else
<            {
< 
<                TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Short DNS found. domain part is empty. ");
<                s_domain_name.clear() ;
<            }
<        }
<        
<    	    Crypto::Result rc = Crypto::RESULT_OK;
<         Crypto::ICertificateManager* pCertMgr = Crypto::getCertificateManagerInterface();
<         if (!pCertMgr)
<         {
<            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::ERR, "Error - failed receiving the cryptographic certificate manager");
<            return 1;
<         }
<         Crypto::ICertificate *pCertificate = NULL;
<         rc = pCertMgr->createCertificate(&pCertificate, param);
<         if (rc != Crypto::RESULT_OK)
<         {
< 
<            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::WARN, "Error initilizing certificate from X509 pointer; rc=%d", rc);
< 
<             pCertMgr->destroyCertificate(pCertificate);
<             return 1;
<         }
<         else // We have a valid certificate
<         {
<            char   sCertField[4096];
<            size_t iCertFieldSize= 0 ;
< 
< 
<            std::vector<Crypto::SAN_GeneralName> vec;
<            rc= pCertificate->getSANs(vec, Crypto::SAN_TYPE_ANY);
<            unsigned int uiSAN_ctr = 0;
<            for (std::vector<Crypto::SAN_GeneralName>::iterator i = vec.begin(); i!= vec.end(); ++i)
<            {
< 
<                s_cert_host = (*i).san_value;
<                TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Extracted SAN field number %d, value %s, type %d", uiSAN_ctr, s_cert_host.c_str(),  (*i).san_type);
< 
<                if ((*i).san_type == Crypto::SAN_TYPE_DNS) {
<                    if (h_type != Crypto::SAN_TYPE_DNS ) continue;
< 
<                    //check exact match
<                    if (s_cert_host == s_hostname )
<                                    {
< 
<                                        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared DNS format host names with exact match");
<                                        pCertMgr->destroyCertificate(pCertificate);
<                                        return 0;
<                                    }
< 
<                    //check wildcard match
<                    				if ( ( !s_domain_name.empty() ) && s_cert_host[0] == '*' && s_cert_host[1] == '.' && s_domain_name.length() == s_cert_host.length() -1 && (s_domain_name == s_cert_host.substr(1)) ) {
< 
<                                        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared DNS format host names to wildcard expression");
<                                        pCertMgr->destroyCertificate(pCertificate);
<                                        return 0;
<                                 }
<                    }
<                else if ((*i).san_type == Crypto::SAN_TYPE_IP_ADDR) {
< 
<                    if (h_type != Crypto::SAN_TYPE_IP_ADDR ) continue;
< 
<                    if ( ( s_cert_host.end() - s_cert_host.begin() == sizeof (struct in_addr) ) && ( !memcmp (s_cert_host.data(), &addr, sizeof (struct in_addr)) ) )
<                                    {
<                                        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared IP address format host names ");
<                                        pCertMgr->destroyCertificate(pCertificate);
<                                        return 0;
< 
<                                    }
<                }
<                        
<            } //for (std::vector<Crypto::SAN_GeneralName>::iterator i = vec.begin(); i!= vec.end(); ++i)
< 
<            iCertFieldSize = sizeof(sCertField) ; memset(sCertField,0,iCertFieldSize ) ;
<            pCertificate->getSerialNumber((unsigned char*)sCertField,&iCertFieldSize );
<            string sCertSerialNumber = sCertField;
< 
<            iCertFieldSize = sizeof(sCertField) ; memset(sCertField,0,iCertFieldSize ) ;
<            pCertificate->getSubject((char*)sCertField,&iCertFieldSize );
<            string sCertSubject = sCertField;
< 
<            iCertFieldSize = sizeof(sCertField) ; memset(sCertField,0,iCertFieldSize ) ;
<            rc= pCertificate->getSubjectCN((char*)sCertField,&iCertFieldSize );
<            string sCertSubjectCN = sCertField;
< 
<            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Extracted server certificate:\nsubject: %s\nserial number: %s\nCN: %s", sCertSubject.c_str(), sCertSerialNumber.c_str(), sCertSubjectCN.c_str());
< 
<            if ( rc==Crypto::RESULT_OK )
<            {
<                TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "CN field found. Checking match...");
< 
<                //check exact match
<                if (sCertSubjectCN == s_hostname )
<                        {
< 
<                            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared CN host name with exact match");
<                            pCertMgr->destroyCertificate(pCertificate);
<                            return 0;
<                        }
< 
<                //check wildcard match
<                		if ( ( !s_domain_name.empty() ) && sCertSubjectCN[0] == '*' && sCertSubjectCN[1] == '.' && s_domain_name.length() == sCertSubjectCN.length() -1 && (s_domain_name == sCertSubjectCN) ) {
< 
<                            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared CN host name to wildcard expression");
<                            pCertMgr->destroyCertificate(pCertificate);
<                            return 0;
<                     }
<                    
<            }
<            else
<            {
<                TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "CN field not found.");
<            }
<         } //else 
<     }// if ( pSSLConnection )
<     else
<     {
< 
<        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::WARN, "Did not receive a valid SSLConnection object");
<         return 1;
<     }
< 
< 
<     TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::WARN, "Server certificate check has failed.");
<     return 1;
< }
< 
280,282d66
< 
<     //set server certificate validation callback
<     clientParams.fnTlsServer_CertCheckCB =  LdapSslContext::tlsLDAP_Cert_Check_CB;
Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslContext.cpp@@/main/int.acs5_0/yizaq_5_5_dev.int.acs5_0/8 vs. branch base
15,18d14
< #include <sys/socket.h>
< #include <netinet/in.h>
< #include <arpa/inet.h>
< 
36,252d31
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  LdapSslContext :: getConnectionConfig
<  * Description:  return ConfigLDAPConnectionAdapter member
<  *--------------------------------------------------------------------------------------
<  */
< const ConfigLDAPConnectionAdapter & LdapSslContext::getConnectionConfig() const
< {
<         return m_ConfigConnection;
< }
< 
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  LdapSslContext :: setConnectionConfig
<  * Description:  return ConfigLDAPConnectionAdapter member
<  *--------------------------------------------------------------------------------------
<  */
< void LdapSslContext::setConnectionConfig(ConfigLDAPConnectionAdapter & cfg)
< {
<         m_ConfigConnection = cfg;
< }
< 
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  LdapSslContext
<  *      Method:  tlsLDAP_Cert_Check_CB
<  * Description:  
<  *     When ACS performs user authentication/authorization (attribute/group retrieval) against LDAP server it is susceptible to a spoofing attack.
<  *     LDAP server can be spoofed if an attacker has the ability to establish rogue LDAP server using a real LDAP server IP address (which can be achieved by another attack on the network) and have a valid certificate issued by the same CA as valid LDAP server certificate.
<  *     ACS is required to perform identify verification on the LDAP server's certificate according to rfc-4513 - Lightweight Directory Access Protocol (LDAP): Authentication Methods and Security Mechanisms.
<  *     The identity verification consists of:					
<  *     1. Check format of hostname in LDAP configuration and classify it as either DNS or IPv4.
<  *     	1.1 If DNS format then extract host name and domain
<  *     2. From incoming server certificate extract the names from x509 SUBJECT_ALT_NAME section 
<  *     3. Iterate over the list acquired in step 2. 
<  *     	3.1 If current alt. name is of DNS type and step 1 classification is DNS then compare both host names. If they are equal then flag successful verification and stop checking further.
<  *     	3.2 If current alt. name is of DNS type and step 1 classification is DNS then check for '*' prefix (wildcard). If so, do two sanity checks: a. 2nd character of alt. name is '.'. ; and b. The lengths match; 
<  *   After the sanity checks compare the domain parts and if matches then flag successful verification and stop checking further.
<  *     	3.3 If current alt. name is of IPv4 type and step 1 classification is IPv4 then compare both host names IP addresses. If they are equal then flag successful verification and stop checking further.
<  *     4. If no x509 SUBJECT_ALT_NAME section is found then extract the CN 
<  *     	4.1 If CN is equal to the LDAP configuration hostname then flag successful verification, if not then
<  *     	4.2 check for '*' prefix (wildcard). If so, do two sanity checks: a. 2nd character of alt. name is '.'. ; and b. The lengths match; 
<  *   After the sanity checks compare the domain parts and if matches then flag successful verification and stop checking further.
<  *     5. If all previous checks have failed then flag failed verification
<  * author: yizaq 
<  *--------------------------------------------------------------------------------------
<  */
< int LdapSslContext::tlsLDAP_Cert_Check_CB(Crypto::ISSLConnection* pSSLConnection, Crypto::TLS_NOTIFY nTlsNotify, void* param)
< {
< 	AcsDebugLog TempLogger ("Acs.RT.idstores.LDAP.SSLContext.tlsLDAP_Cert_Check_CB");
<     //TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Checking server certificate validity against the configured host name: %s", m_hostname.c_str() );
< 
<     if (param == NULL )
<     {
<         TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::ERR, "Error getting peer certificate");
<         return 1;
<     }
< 
<     
<     if ( pSSLConnection )
<     {
<        Crypto::TypesOfSAN h_type = Crypto::SAN_TYPE_DNS; // default to DNS
<        LdapSslContext * pLSC = (LdapSslContext *) pSSLConnection->getConnectionUserData(); 
< 
<        if ( !pLSC->getConnectionConfig().enableServerIdentityCheck() )
<        {
<             TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::INFO, "Server Identity check is disabled. No check is required!");
<             return 0;
<        }
< 
<        string s_hostname = pLSC->getConnectionConfig().hostName();
<        string s_domain_name ;
<        string s_cert_host ;
< 
<        struct in_addr addr;
<        if (inet_aton(s_hostname.c_str(), (struct in_addr *)&addr)) h_type = Crypto::SAN_TYPE_IP_ADDR;
< 
<        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Received configured host name: %s, type %s",s_hostname.c_str(), h_type == Crypto::SAN_TYPE_DNS ? "DNS" : "IP Address");
< 
<        if (h_type == Crypto::SAN_TYPE_DNS)  
<        {
<            if (s_hostname.find('.') != string::npos )
<            {
<                s_domain_name = s_hostname.substr(s_hostname.find('.')); 
<                TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Extracted domain: %s",s_domain_name.c_str());
<            }
<            else
<            {
< 
<                TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Short DNS found. domain part is empty. ");
<                s_domain_name.clear() ;
<            }
<        }
<        
<    	    Crypto::Result rc = Crypto::RESULT_OK;
<         Crypto::ICertificateManager* pCertMgr = Crypto::getCertificateManagerInterface();
<         if (!pCertMgr)
<         {
<            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::ERR, "Error - failed receiving the cryptographic certificate manager");
<            return 1;
<         }
<         Crypto::ICertificate *pCertificate = NULL;
<         rc = pCertMgr->createCertificate(&pCertificate, param);
<         if (rc != Crypto::RESULT_OK)
<         {
< 
<            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::WARN, "Error initilizing certificate from X509 pointer; rc=%d", rc);
< 
<             pCertMgr->destroyCertificate(pCertificate);
<             return 1;
<         }
<         else // We have a valid certificate
<         {
<            char   sCertField[4096];
<            size_t iCertFieldSize= 0 ;
< 
< 
<            std::vector<Crypto::SAN_GeneralName> vec;
<            rc= pCertificate->getSANs(vec, Crypto::SAN_TYPE_ANY);
<            unsigned int uiSAN_ctr = 0;
<            for (std::vector<Crypto::SAN_GeneralName>::iterator i = vec.begin(); i!= vec.end(); ++i)
<            {
< 
<                s_cert_host = (*i).san_value;
<                TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Extracted SAN field number %d, value %s, type %d", uiSAN_ctr, s_cert_host.c_str(),  (*i).san_type);
< 
<                if ((*i).san_type == Crypto::SAN_TYPE_DNS) {
<                    if (h_type != Crypto::SAN_TYPE_DNS ) continue;
< 
<                    //check exact match
<                    if (s_cert_host == s_hostname )
<                                    {
< 
<                                        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared DNS format host names with exact match");
<                                        pCertMgr->destroyCertificate(pCertificate);
<                                        return 0;
<                                    }
< 
<                    //check wildcard match
<                    				if ( ( !s_domain_name.empty() ) && s_cert_host[0] == '*' && s_cert_host[1] == '.' && s_domain_name.length() == s_cert_host.length() -1 && (s_domain_name == s_cert_host.substr(1)) ) {
< 
<                                        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared DNS format host names to wildcard expression");
<                                        pCertMgr->destroyCertificate(pCertificate);
<                                        return 0;
<                                 }
<                    }
<                else if ((*i).san_type == Crypto::SAN_TYPE_IP_ADDR) {
< 
<                    if (h_type != Crypto::SAN_TYPE_IP_ADDR ) continue;
< 
<                    if ( ( s_cert_host.end() - s_cert_host.begin() == sizeof (struct in_addr) ) && ( !memcmp (s_cert_host.data(), &addr, sizeof (struct in_addr)) ) )
<                                    {
<                                        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared IP address format host names ");
<                                        pCertMgr->destroyCertificate(pCertificate);
<                                        return 0;
< 
<                                    }
<                }
<                        
<            } //for (std::vector<Crypto::SAN_GeneralName>::iterator i = vec.begin(); i!= vec.end(); ++i)
< 
<            iCertFieldSize = sizeof(sCertField) ; memset(sCertField,0,iCertFieldSize ) ;
<            pCertificate->getSerialNumber((unsigned char*)sCertField,&iCertFieldSize );
<            string sCertSerialNumber = sCertField;
< 
<            iCertFieldSize = sizeof(sCertField) ; memset(sCertField,0,iCertFieldSize ) ;
<            pCertificate->getSubject((char*)sCertField,&iCertFieldSize );
<            string sCertSubject = sCertField;
< 
<            iCertFieldSize = sizeof(sCertField) ; memset(sCertField,0,iCertFieldSize ) ;
<            rc= pCertificate->getSubjectCN((char*)sCertField,&iCertFieldSize );
<            string sCertSubjectCN = sCertField;
< 
<            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Extracted server certificate:\nsubject: %s\nserial number: %s\nCN: %s", sCertSubject.c_str(), sCertSerialNumber.c_str(), sCertSubjectCN.c_str());
< 
<            if ( rc==Crypto::RESULT_OK )
<            {
<                TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "CN field found. Checking match...");
< 
<                //check exact match
<                if (sCertSubjectCN == s_hostname )
<                        {
< 
<                            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared CN host name with exact match");
<                            pCertMgr->destroyCertificate(pCertificate);
<                            return 0;
<                        }
< 
<                //check wildcard match
<                		if ( ( !s_domain_name.empty() ) && sCertSubjectCN[0] == '*' && sCertSubjectCN[1] == '.' && s_domain_name.length() == sCertSubjectCN.length() -1 && (s_domain_name == sCertSubjectCN) ) {
< 
<                            TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "Successfuly compared CN host name to wildcard expression");
<                            pCertMgr->destroyCertificate(pCertificate);
<                            return 0;
<                     }
<                    
<            }
<            else
<            {
<                TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::VERBOSE, "CN field not found.");
<            }
<         } //else 
<     }// if ( pSSLConnection )
<     else
<     {
< 
<        TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::WARN, "Did not receive a valid SSLConnection object");
<         return 1;
<     }
< 
< 
<     TempLogger.log_msg(__FILE__, __LINE__, AcsDebugLog::WARN, "Server certificate check has failed.");
<     return 1;
< }
< 
288,290d66
< 
<     //set server certificate validation callback
<     clientParams.fnTlsServer_CertCheckCB =  LdapSslContext::tlsLDAP_Cert_Check_CB;
Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslContext.h@@/main/int.acs5_0/yizaq_5_5_dev.int.acs5_0/1 vs. branch base
8d7
< #include <string>
12d10
< #include "LdapDefinitions.h"
17d14
< using namespace std;
46,64d42
< 
<     /*
<      *--------------------------------------------------------------------------------------
<      *       Class:  LdapSslContext
<      *      Method:  LdapSslContext :: getConnectionConfig
<      * Description:  return ConfigLDAPConnectionAdapter member
<      *--------------------------------------------------------------------------------------
<      */
<      const ConfigLDAPConnectionAdapter & getConnectionConfig() const;
< 
<     /*
<      *--------------------------------------------------------------------------------------
<      *       Class:  LdapSslContext
<      *      Method:  LdapSslContext :: setConnectionConfig
<      * Description:  return ConfigLDAPConnectionAdapter member
<      *--------------------------------------------------------------------------------------
<      */
<      void setConnectionConfig(ConfigLDAPConnectionAdapter & cfg);
< 
83,90d60
<     /* 
<      * ===  FUNCTION  ======================================================================
<      *         Name:   tlsLDAP_Cert_Check_CB
<      *  Description:   LDAP certificate spoofing check callback
<      * =====================================================================================
<      */
<     static void tlsLDAP_Cert_Check_CB(Crypto::ISSLConnection* pSSLConnection, Crypto::TLS_NOTIFY nTlsNotify, void* param );
< 
93,94d62
<     ConfigLDAPConnectionAdapter m_ConfigConnection;
< 
Diff of file /vob/nm_acs/acs/runtime/idstores/ldapIDStore/src/LdapSslContext.h@@/main/int.acs5_0/yizaq_5_5_dev.int.acs5_0/2 vs. branch base
8d7
< #include <string>
12d10
< #include "LdapDefinitions.h"
17d14
< using namespace std;
46,64d42
< 
<     /*
<      *--------------------------------------------------------------------------------------
<      *       Class:  LdapSslContext
<      *      Method:  LdapSslContext :: getConnectionConfig
<      * Description:  return ConfigLDAPConnectionAdapter member
<      *--------------------------------------------------------------------------------------
<      */
<      const ConfigLDAPConnectionAdapter & getConnectionConfig() const;
< 
<     /*
<      *--------------------------------------------------------------------------------------
<      *       Class:  LdapSslContext
<      *      Method:  LdapSslContext :: setConnectionConfig
<      * Description:  return ConfigLDAPConnectionAdapter member
<      *--------------------------------------------------------------------------------------
<      */
<      void setConnectionConfig(ConfigLDAPConnectionAdapter & cfg);
< 
83,90d60
<     /* 
<      * ===  FUNCTION  ======================================================================
<      *         Name:   tlsLDAP_Cert_Check_CB
<      *  Description:   LDAP certificate spoofing check callback
<      * =====================================================================================
<      */
<     static int tlsLDAP_Cert_Check_CB(Crypto::ISSLConnection* pSSLConnection, Crypto::TLS_NOTIFY nTlsNotify, void* param );
< 
93,94d62
<     ConfigLDAPConnectionAdapter m_ConfigConnection;
< 
Diff of file /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/Certificate.cpp@@/main/int.acs5_0/yizaq_5_5_dev.int.acs5_0/1 vs. branch base
16d15
<   Modified: Thu Nov  8 11:13:27 IST 2012, yizaq: Enhance getSAN to return all SAN fields & add support for IP address type
21a21
> #include <string.h>
45d44
< using namespace std;
53,58d51
< SAN_GeneralName::SAN_GeneralName(std::string value, TypesOfSAN type) :
<                san_value(value),
<                san_type(type) 
< {
< }
< 
1871c1864,1866
< Result  Certificate::getSAN( OUT char* pResult, INOUT size_t* pnResultSize, OUT TypesOfSAN *pType, IN bool bGetLast, IN TypesOfSAN requestedTypeOfSAN ) const 
---
> Result  Certificate::getSAN( OUT char* pResult, INOUT size_t* pnResultSize, 
>                              OUT TypesOfSAN *pType, 
>                              IN bool bGetLast, IN TypesOfSAN requestedTypeOfSAN ) const 
2024,2175d2018
<     return RESULT_OK;     
< }
< 
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  Certificate
<  *      Method:  Certificate :: getSANs
<  * Description:  return full list of SAN names
<  * Author:       yizaq
<  *--------------------------------------------------------------------------------------
<  */
< Result  Certificate::getSANs( OUT vector<SAN_GeneralName> & vec , IN TypesOfSAN requestedTypeOfSAN ) const 
< {
<     Result rc = RESULT_OK ;
< 
<     if ( m_pX509==NULL)
<     {
<         rc= RESULT_NOT_INITIALIZED ;
<         g_pILog->logError(__FILE__,__LINE__, rc,
<                           "Crypto.Certificate::getSAN - Not initialized");
<         return rc ;
<     }
< 
<     bool bFound= false ;
<     std::string result = "" ;
<     TypesOfSAN resultType = SAN_TYPE_NONE ;
< 
<     STACK_OF(GENERAL_NAME) *pGeneralNames = NULL;
< 
<     // Get the subject-alternative-name extension
<     pGeneralNames= (STACK*)X509_get_ext_d2i(m_pX509, NID_subject_alt_name, NULL, NULL) ;
< 
<     if (pGeneralNames)
<     {
<         int     i, r;
< 
<         int         type = 0 ; 
<         int         asn1type = 0 ; 
<         void        *pData = NULL ;
<         int         len= 0 ;
<         TypesOfSAN  typeOfSAN ;
< 
<         // parse to find the first known type of extension
<         r = sk_GENERAL_NAME_num(pGeneralNames) ;
<         for ( i=0 ; i<r ; ++i )
<         {
<             GENERAL_NAME *gn = sk_GENERAL_NAME_value(pGeneralNames, i);
< 
<             if ( gn==NULL )
<                 continue;
< 
<             type= gn->type ;
<             asn1type = 0 ; 
<             pData = NULL ;
<             len= 0 ;
<             typeOfSAN= SAN_TYPE_NONE ;
< 
<             switch ( type )
<             {
<             case GEN_EMAIL:
<                 if( gn->d.uniformResourceIdentifier==NULL || gn->d.uniformResourceIdentifier->data==NULL )
<                     break;
<                 pData= gn->d.uniformResourceIdentifier->data ;
<                 len= gn->d.uniformResourceIdentifier->length ;
<                 asn1type= gn->d.uniformResourceIdentifier->type ;
<                 typeOfSAN= Crypto::SAN_TYPE_EMAIL ;
<                 break;
<             case GEN_URI:
<                 if( gn->d.ia5==NULL || gn->d.ia5->data==NULL)
<                     break;
<                 pData= gn->d.ia5->data ;
<                 len= gn->d.ia5->length ;
<                 asn1type= gn->d.ia5->type ;
<                 typeOfSAN= Crypto::SAN_TYPE_URI ;
<                 break;;
<             case GEN_DNS:
<                 g_pILog->logDebug(__FILE__,__LINE__, RESULT_OK, "Crypto.Certificate::getSAN - Parsing SAN DNS type = %d", asn1type);
<                 if( gn->d.dNSName==NULL || gn->d.dNSName->data==NULL )
<                     break;
<                 pData= gn->d.dNSName->data ;
<                 len= gn->d.dNSName->length ;
<                 asn1type= gn->d.dNSName->type ;
<                 typeOfSAN= Crypto::SAN_TYPE_DNS ;
<                 break;
<             case GEN_OTHERNAME:
<                 if( gn->d.otherName==NULL || gn->d.otherName->value==NULL || gn->d.otherName->value->value.ia5string==NULL ||
<                     gn->d.otherName->value->value.ia5string->data==NULL )
<                     break;
<                 pData= gn->d.otherName->value->value.ia5string->data ; 
<                 len= gn->d.otherName->value->value.ia5string->length ;
<                 asn1type= gn->d.otherName->value->value.ia5string->type ;
<                 typeOfSAN= Crypto::SAN_TYPE_OTHER ;
<                 break;
<             case GEN_IPADD:
<                 g_pILog->logDebug(__FILE__,__LINE__, RESULT_OK, "Crypto.Certificate::getSAN - Parsing SAN IP address type = %d", asn1type);
<                 if( gn->d.iPAddress==NULL || gn->d.iPAddress->data==NULL )
<                     break;
<                 pData= gn->d.iPAddress->data ;
<                 len= gn->d.iPAddress->length ;
<                 asn1type= gn->d.iPAddress->type ;
<                 typeOfSAN= Crypto::SAN_TYPE_DNS ;
<                 break;
<             default:
<                 g_pILog->logWarn(__FILE__,__LINE__, RESULT_ERROR,
<                                  "Crypto.Certificate::getSAN - Unsupported SAN name parsed (skipping): asn1type=%d",
<                                  asn1type );
<                 break;
<             }
< 
<             // printf( "$$$ type=%d => data=[%s] len=%d asn1type=%d $$$\n", type, pData?(char*)pData:"", len, asn1type ) ;
< 
<             if ( pData==NULL )
<             {
<                 GENERAL_NAME_free(gn) ;
<                 continue;
<             }
< 
<             //  g_pILog->logDebug(__FILE__,__LINE__, RESULT_OK,
<             //                    "Crypto.Certificate::getSAN - len=%d, strlen=%d, pData=\"%s\", asn1type=%d", 
<             //                    len, strlen((char*)pData), pData, asn1type);
<             if ( len>0 && strlen((char*)pData)==(size_t)len && 
<                  (asn1type==V_ASN1_UTF8STRING || asn1type==V_ASN1_IA5STRING || asn1type==V_ASN1_OCTET_STRING) )
<             {
<                 if( (!bFound ) && (requestedTypeOfSAN==SAN_TYPE_ANY || requestedTypeOfSAN==typeOfSAN) )
<                 {
<                     // Return the SAN
<                     resultType= typeOfSAN ;
<                     result= std::string((const char*)pData,(size_t)len) ;
<                     bFound= true ;
<                     if( result.size()<=0)
<                     {
<                          g_pILog->logWarn(__FILE__,__LINE__, RESULT_OK,"Crypto.Certificate::getSAN - Note, received SAN extension with empty name");
<                     }
< 
<                     vec.push_back(SAN_GeneralName(result, resultType));
<                     g_pILog->logDebug(__FILE__,__LINE__, RESULT_OK, "Crypto.Certificate::getSAN - Adding SAN to vector of SAN fields. Value %s, type %d", vec.back().san_value.c_str(), vec.back().san_type  );
<                 }
<             }
<             else
<             {
<                 g_pILog->logWarn(__FILE__,__LINE__, RESULT_ERROR,
<                                  "Crypto.Certificate::getSAN - Improper SAN name parsed (skipping): type=%d data=\"%s\" len=%d asn1type=%d",
<                                  type, pData, len, asn1type );
<             }
< 
<             GENERAL_NAME_free(gn) ;
< 
<         } // for ( i=0 ; i<r ; ++i )
< 
<         sk_GENERAL_NAME_free(pGeneralNames);
<     }
< 
Diff of file /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/Certificate.cpp@@/main/int.acs5_0/yizaq_5_5_dev.int.acs5_0/2 vs. branch base
16d15
<   Modified: Thu Nov  8 11:13:27 IST 2012, yizaq: Enhance getSAN to return all SAN fields & add support for IP address type
21a21
> #include <string.h>
45d44
< using namespace std;
53,58d51
< SAN_GeneralName::SAN_GeneralName(std::string value, TypesOfSAN type) :
<                san_value(value),
<                san_type(type) 
< {
< }
< 
1871c1864,1866
< Result  Certificate::getSAN( OUT char* pResult, INOUT size_t* pnResultSize, OUT TypesOfSAN *pType, IN bool bGetLast, IN TypesOfSAN requestedTypeOfSAN ) const 
---
> Result  Certificate::getSAN( OUT char* pResult, INOUT size_t* pnResultSize, 
>                              OUT TypesOfSAN *pType, 
>                              IN bool bGetLast, IN TypesOfSAN requestedTypeOfSAN ) const 
2024,2183d2018
<     return RESULT_OK;     
< }
< 
< /*
<  *--------------------------------------------------------------------------------------
<  *       Class:  Certificate
<  *      Method:  Certificate :: getSANs
<  * Description:  return full list of SAN names
<  * Author:       yizaq
<  *--------------------------------------------------------------------------------------
<  */
< Result  Certificate::getSANs( OUT vector<SAN_GeneralName> & vec , IN TypesOfSAN requestedTypeOfSAN ) const 
< {
<     g_pILog->logDebug(__FILE__,__LINE__, RESULT_OK, "Crypto.Certificate::getSANs - Extracting SAN fields");
< 
<     Result rc = RESULT_OK ;
< 
<     if ( m_pX509==NULL)
<     {
<         rc= RESULT_NOT_INITIALIZED ;
<         g_pILog->logError(__FILE__,__LINE__, rc, "Crypto.Certificate::getSANs - Not initialized");
<         return rc ;
<     }
< 
<     bool bFound= false ;
<     std::string result = "" ;
<     TypesOfSAN resultType = SAN_TYPE_NONE ;
< 
<     STACK_OF(GENERAL_NAME) *pGeneralNames = NULL;
< 
<     // Get the subject-alternative-name extension
<     pGeneralNames= (STACK*)X509_get_ext_d2i(m_pX509, NID_subject_alt_name, NULL, NULL) ;
< 
<     if (pGeneralNames)
<     {
<         int     i, r;
< 
<         int         type = 0 ; 
<         int         asn1type = 0 ; 
<         void        *pData = NULL ;
<         int         len= 0 ;
<         TypesOfSAN  typeOfSAN ;
< 
<         // parse to find the first known type of extension
<         r = sk_GENERAL_NAME_num(pGeneralNames) ;
<         g_pILog->logDebug(__FILE__,__LINE__, RESULT_ERROR, "Found %d SANs in Certificate");
< 
<         for ( i=0 ; i<r ; ++i )
<         {
<             GENERAL_NAME *gn = sk_GENERAL_NAME_value(pGeneralNames, i);
< 
<             if ( gn==NULL )
<                 continue;
< 
<             type= gn->type ;
<             asn1type = 0 ; 
<             pData = NULL ;
<             len= 0 ;
<             typeOfSAN= SAN_TYPE_NONE ;
< 
<             switch ( type )
<             {
<             case GEN_EMAIL:
<                 if( gn->d.uniformResourceIdentifier==NULL || gn->d.uniformResourceIdentifier->data==NULL )
<                     break;
<                 pData= gn->d.uniformResourceIdentifier->data ;
<                 len= gn->d.uniformResourceIdentifier->length ;
<                 asn1type= gn->d.uniformResourceIdentifier->type ;
<                 typeOfSAN= Crypto::SAN_TYPE_EMAIL ;
<                 break;
<             case GEN_URI:
<                 if( gn->d.ia5==NULL || gn->d.ia5->data==NULL)
<                     break;
<                 pData= gn->d.ia5->data ;
<                 len= gn->d.ia5->length ;
<                 asn1type= gn->d.ia5->type ;
<                 typeOfSAN= Crypto::SAN_TYPE_URI ;
<                 break;;
<             case GEN_DNS:
<                 g_pILog->logDebug(__FILE__,__LINE__, RESULT_OK, "Crypto.Certificate::getSANs - Parsing SAN DNS type = %d", asn1type);
<                 if( gn->d.dNSName==NULL || gn->d.dNSName->data==NULL )
<                     break;
<                 pData= gn->d.dNSName->data ;
<                 len= gn->d.dNSName->length ;
<                 asn1type= gn->d.dNSName->type ;
<                 typeOfSAN= Crypto::SAN_TYPE_DNS ;
<                 break;
<             case GEN_OTHERNAME:
<                 if( gn->d.otherName==NULL || gn->d.otherName->value==NULL || gn->d.otherName->value->value.ia5string==NULL ||
<                     gn->d.otherName->value->value.ia5string->data==NULL )
<                     break;
<                 pData= gn->d.otherName->value->value.ia5string->data ; 
<                 len= gn->d.otherName->value->value.ia5string->length ;
<                 asn1type= gn->d.otherName->value->value.ia5string->type ;
<                 typeOfSAN= Crypto::SAN_TYPE_OTHER ;
<                 break;
<             case GEN_IPADD:
<                 g_pILog->logDebug(__FILE

- Tests
| 1. Make sure checkbox works. The code is there but I don't recall state of testing this.
| 2. CN DNS positive 
| 3. CN DNS negative 
| 4. CN DNS wildcard positive 
| 5. CN DNS negative 
| 6. 2-5 for SAN
| 7. 2-5 for SAN w/ multiple fields
| 8. SAN IP positive
| 9. SAN IP negative

Don't do all - choose some minimal set. 

		1.1.10 refactor code to cryptoLib


			1.1.10.1 Design

- In parameters

void * pCert
LdapSslContext * pLSC (or take from pSSLConnection->getConnectionUserData() )
string s_hostname 

- Out parameters

- New function
/view/yizaq__yizaq_5_5_dev.int.acs5_0.lx/vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSLConnection.h
        Result                checkServerCertificate(IN ICertificate *pCertificate,string s_hostname   ) const;


- Return Result
    enum Result
    {
        RESULT_OK                
        = 0,
        RESULT_ERROR                                    = 1,

        RESULT_INVALID_PARAMETERS                       = 11,
        RESULT_INVALID_CERT_SUBJECT_DN_ELEMENT_NAME     = 12,
        RESULT_INVALID_CERT_SUBJECT_DN_ELEMENT_LEN      = 13,
        RESULT_INVALID_CERT_SUBJECT_FORMAT              = 14,
        RESULT_EMPTY_CERT_CHAIN                         = 15,
        RESULT_ALREADY_INITED                           = 16,
        RESULT_RESULT_C_INIT_FAILED                     = 17,
        RESULT_SERVER_CTX_FAILED                        = 18,
        RESULT_PRST_INVALID_PARAMS                      = 19,
        RESULT_CANT_OPEN_CERT_STORAGE                   = 20,
        RESULT_CANT_FIND_CERT                           = 21,
        RESULT_CANT_GET_CERT_CHAIN                      = 22,
        RESULT_ERR_ACQUIRE_CERT_PVK                     = 23,
        RESULT_ERR_GET_USER_KEY                         = 24,
        RESULT_CANT_EXPORT_CERT_KEY                     = 25,
        RESULT_MEM_ALLOC_ERROR                          = 26,
        RESULT_OUT_OF_MEMORY                            = RESULT_MEM_ALLOC_ERROR,
        RESULT_WRONG_LIBRARY_MODE                       = 28,
        RESULT_DN_ELEMENT_MANDATORY                     = 29,
        RESULT_CN_FIELD_IS_ABSENT                       = 30,
        RESULT_PVK_BAD_PASSWORD                         = 31,
        RESULT_FAILED_TO_GET_X509_CN                    = 32,
        RESULT_INVALID_PAC_OPAQUE                       = 33,
        RESULT_INVALID_PAC_AUTH_TAG                     = 34,
        RESULT_FAILED_TO_GET_MASTER_KEY                 = 35,
        RESULT_INVALID_PAC_OPAQUE_SIZE                  = 36,
        RESULT_EAPFAST_TLS_ALERT                        = 37,
        RESULT_INVALID_PAC_OPAQUE_TYPE                  = 38,
        RESULT_NO_PEER_CERTIFICATE                      = 39,
        RESULT_INVALID_AUTHORITY_ID                     = 40,
        RESULT_INVALID_MASTER_KEY                       = 41,
        RESULT_CERT_CONTAINER_OVERFLOW                  = 42,
        RESULT_INVALID_KEY_WRAP                         = 43,
        RESULT_OPENING_DIRECTORY                        = 44,
        RESULT_GETTING_DIRECTORY_FILE                   = 45,
        RESULT_CRL_EXPIRED                              = 46,
        RESULT_CERTIFICATE_EXPIRED                      = 47,
        RESULT_CRL_PKI_VERIFICATION_FAILED              = 48,
        RESULT_FAILED_TO_GET_PUBLIC_KEY                 = 49,
        RESULT_X509_PARSE_ERROR                         = 50,
        RESULT_CA_NOT_FOUND                             = 51,
        RESULT_FAILED_TO_SET_CRL                        = 52,
        RESULT_X509_NON_MATCHING_ISSUER                 = 53,
        RESULT_X509_BAD_SIGNATURE                       = 54,

        RESULT_SSL_HANDSHAKE_ERROR                      = 101,
        RESULT_SSL_WRITE_ERROR                          = 102,
        RESULT_SSL_READ_ERROR                           = 103,
        RESULT_SSL_NOT_IN_PROPER_STATE                  = 104,
        RESULT_SSL_NEW_SESSION_ERROR                    = 105,
        RESULT_SSL_ERROR_WANT_READ                      = 106,
        RESULT_SSL_ERROR_WANT_WRITE                     = 107,

        RESULT_INVALID_CERTIFICATE                      = 110,
        RESULT_INVALID_PRIVATE_KEY                      = 111,
        RESULT_INVALID_CERTIFICATE_FILE_FORMAT          = 112,
        RESULT_INCORRECT_PRIVATE_KEY                    = 113,
        RESULT_INVALID_TIME                             = 114,
        RESULT_TIME_PASS_UNIX_LIMIT                     = 115,

        RESULT_NOT_IMPLEMENTED                          = 201,
        RESULT_NOT_INITIALIZED                          = 202,
        RESULT_INVALID_INPUT                            = 203,
        RESULT_BAD_STATE                                = 204,
        RESULT_OPERATION_NOT_ALLOWED                    = 205,
        RESULT_POWERUP_TEST_FAILED                      = 206,
        RESULT_MODULE_NOT_AT_PROPER_STATE               = 207,
        RESULT_INVALID_STATE_TRANSITION                 = 208,
        RESULT_CONDITIONAL_TEST_FAILED                  = 209,
        RESULT_NO_ROOM                                  = 210,
        RESULT_INVALID_RESULT                           = 211,
        RESULT_NOT_FOUND                                = 212,
        RESULT_INVALID_FORMAT                           = 213,
        RESULT_INVALID_FORMAT_BAD_MAGIC                 = 214,

        RESULT_FILE_NOT_FOUND                           = 220,
        RESULT_FILE_WRITE_FAILED                        = 221,
        RESULT_FILE_READ_FAILED                         = 222,

        RESULT_LAST
    };

-

"
			1.1.10.2

		1.1.11 Customer logs

- /vob/nm_acs/acs/messagecatalog/src/main/resources/msg_cat.xml
                           <message code="24059">
                              <label>LDAP_IDSTORE_SERVER_CERT_ID_CHECK_SUCCEEDED
                              </label>
                              <messageClass>External-LDAP
                              </messageClass>
                              <since>005.005(000.000)
                              </since>
                              <severity>INFO
                              </severity>
                              <text lang="en" country="US">LDAP server certificate identity successfully verified
                              </text>
                              <description lang="en" country="US">LDAP server certificate identity successfully verified
                              </description>
                           </message>
                           <message code="24060">
                              <label>LDAP_IDSTORE_SERVER_CERT_ID_CHECK_FAILED
                              </label>
                              <messageClass>External-LDAP
                              </messageClass>
                              <since>005.005(000.000)
                              </since>
                              <severity>ERROR
                              </severity>
                              <isFailureReason>true
                              </isFailureReason>
                              <text lang="en" country="US">LDAP server certificate identity verification failed
                              </text>
                              <description lang="en" country="US">LDAP server certificate identity verification failed
                              </description>
                              <resolutionText>Make sure that LDAP host name configuration contains either DNS or IP address matching to those provided by LDAP server certificate
                              </resolutionText>
                           </message>

			1.1.11.1 Flow for intercepting SSL Connection establishment
- see example:SyslogSecureTCPConnection::onConnected 

Basically flow is 
A. Create TCP (/ACE) connection
B. Prepare SSL context
C. Create SSL connection w/ TCP socket
D. Trigger SSL handshake by dummy write (read would work to)

			1.1.11.2


		1.1.12 Close bug

			1.1.12.1  R comment

- see Functional Specification
     When ACS performs user authentication/authorization (attribute/group retrieval) against LDAP server it is susceptible to a spoofing attack.
     LDAP server can be spoofed if an attacker has the ability to establish rogue LDAP server using a real LDAP server IP address (which can be achieved by another attack on the network) and have a valid certificate issued by the same CA as valid LDAP server certificate.
     ACS is required to perform identify verification on the LDAP server's certificate according to rfc-4513 - Lightweight Directory Access Protocol (LDAP): Authentication Methods and Security Mechanisms.
     The identity verification consists of:					
|     1. Check format of hostname in LDAP configuration and classify it as either DNS or IPv4.
|     	1.1 If DNS format then extract host name and domain
|     2. From incoming server certificate extract the names from x509 SUBJECT_ALT_NAME section 
|     3. Iterate over the list acquired in step 2. 
|     	3.1 If current alt. name is of DNS type and step 1 classification is DNS then compare both host names. If they are equal then flag successful verification and stop checking further.
|     	3.2 If current alt. name is of DNS type and step 1 classification is DNS then check for '*' prefix (wildcard). If so, do two sanity checks: a. 2nd character of alt. name is '.'. ; and b. The lengths match; 
|       After the sanity checks compare the domain parts and if matches then flag successful verification and stop checking further.
|     	3.3 If current alt. name is of IPv4 type and step 1 classification is IPv4 then compare both host names IP addresses. If they are equal then flag successful verification and stop checking further.
|     4. If no x509 SUBJECT_ALT_NAME section is found then extract the CN 
|     	4.1 If CN is equal to the LDAP configuration hostname then flag successful verification, if not then
|     	4.2 check for '*' prefix (wildcard). If so, do two sanity checks: a. 2nd character of alt. name is '.'. ; and b. The lengths match; 
|       After the sanity checks compare the domain parts and if matches then flag successful verification and stop checking further.
|     5. If all previous checks have failed then flag failed verification

| See examples
| LDAP hostname configuration	SAN (or CN) hostname	Match?
| Host.domain.com	Host.domain.com	yes
| Host.domain.com	*.domain.com	yes
| 1.2.3.4	1.2.3.4	yes
| Host.domain.com	OtherHost.domain.com	no
| Host.domain.com	*.other.domain.com	no

Fix includes:
- new CB invoked from CSSL.x509ExceptionCallback
- new Crypto functionality to check server cert. ID: SSLConnection.checkServerCertificateIdentity. Including wildcard certs.
- support for multi-value SAN + IP adder fields in: Certificate::getSANs
- All the above come together into play from LdapSslContext:tlsLDAP_Cert_Check_CB

			1.1.12.2 Mail Nabin

Hi Nabin,

CSCtw87143 LDAP server spoofing with valid certificate has been delivered to build #13.
Plz refer to R note and UT for details on fix and tests I've conducted.
In DTP are specified many more tests I couldn't cover.

Plz note that in order to generate the required certs. you will need to use a tool that supports multi value SAN fields and IP address fields.
I've used a new too created by Nisim (CC). I recommend it.
You can obtain the latest version from: http://zt-isr-rep/repository/Uploads/Nisim/CertificateGen/CertGen-Latest.jar

Thx,
Yosi



			1.1.12.3
		1.1.13 LDAP Server ID check. Add customer logs 
		http://cdetsweb-prd.cisco.com/apps/dumpcr?identifier=CSCug11725 


		1.1.14
	1.2 CSCtw89837 acs patch install does not verify signature of patches
	Moved to HCL

		1.2.1 Description
The acs patch creation system does not sign acs patches. As consequence,
'acs patch install' command  does not verify a signature of patches.

In some scenarious (e.g. download via ftp) the pacth content can be tempered by an attacker.

		1.2.2 SFS


			1.2.2.1  ISE
				1.1.1.1.1	CLI verification of Software Packages
In ISE 1.2 we need to provide an option for the users to verify the software packages before they are installed. For this we will provide a prompt the user to verify the SHA hash before proceeding with installing the software package. The user will compare the calculated hash with the one posted on CCO (that ensures secure and authenticated access via certificate).
This will be applicable for
| 1.	Application bundle install/upgrade from CLI
| 2.	Patch install from CLI
| 3.	Patch install from UI
For example while  upgrading appbundle from CLI we will prompt the CLI admin for confirming the hash as follows
pmbudev-vm4/admin# app upgrade ise-appbundle-1.2.0.131.i386.tar.gz disk
Save the current ADE-OS running configuration? (yes/no) [yes] ? 
Generating configuration...
Saved the ADE-OS running configuration to startup successfully
Initiating Application Upgrade...
  md5: aa45b77465147028301622e4c590cb84
  sha256: 3b7f30d572433c2ad0c4733a1d1fb55cceb62dc1419b03b1b7ca354feb8bbcfa
% Please confirm above crypto hash with what is posted on download site. 
% Continue? Y/N [Y]?

			1.2.2.2 ACS
CLI verification of Software Packages
ACS 5.5 is required to provide an option for the users to verify the software packages before they are installed. To comply with this requirement the user will be provided with a prompt to verify the SHA and MD5 hashes before proceeding with installing the software package
This will be applicable for both application bundle install/upgrade from CLI and for patch install from CLI.
For example while  upgrading appbundle from CLI we will prompt the CLI admin for confirming the hash as follows
admin# app upgrade acs-5-x.tar.gz local_repo
Save the current ADE-OS running configuration? (yes/no) [yes] ? 
Generating configuration...
Saved the ADE-OS running configuration to startup successfully
Initiating Application Upgrade...
  md5: aa45b77465147028301622e4c590cb84
  sha256: 3b7f30d572433c2ad0c4733a1d1fb55cceb62dc1419b03b1b7ca354feb8bbcfa
% Please confirm above crypto hash with what is posted on download site. 
% Continue? Y/N [Y]?


			1.2.2.3 acs_ctrl.c
//Checking the hash of the patch file
int32 _HashCheck(char *bundle) {
    int32 retval=0;
    static local_buf_t out = LOCAL_BUF_INIT;
    char cmd[DEFAULT_CMD_LEN];
    char md5sum[DEFAULT_CMD_LEN];
    char cmd2[DEFAULT_CMD_LEN];
    char shasum[DEFAULT_CMD_LEN];
    snprintf(cmd, DEFAULT_CMD_LEN, "/usr/bin/md5sum  %s | /bin/awk -F\" \" {'print $1'}", bundle);
    commandOut(cmd, &out);
    if (out.buf) {
        snprintf(md5sum,DEFAULT_CMD_LEN,out.buf);
    }
    lbClear(&out);
    snprintf(cmd2, DEFAULT_CMD_LEN, "/usr/bin/sha256sum  %s | /bin/awk -F\" \" {'print $1'}", bundle);
    commandOut(cmd2, &out);
    if (out.buf) {
        snprintf(shasum,DEFAULT_CMD_LEN,out.buf);
    }
    lbClear(&out);
    printf(" md5: %s",md5sum);
    printf(" sha256: %s",shasum);
    printf("%% Please confirm above crypto hash matches what is posted on Cisco download site.\n");
    printf("%% Continue? Y/N [Y] ? ");
    retval = yes_or_no("Y");
    return retval;
}//_HashCheck

called from:
int32 _acs_patch_install(paraminfo_t *pinfo)
{
  char *repositoryName;
  char *patchName;
  char command[DEFAULT_CMD_LEN];
  char destFile[DEFAULT_CMD_LEN];
  char cleanUpCmd[DEFAULT_CMD_LEN];
  uint32 avoidConfirm = 0;
  int32 rval;

  patchName      = (char *) GET_PARAM_ARG(pinfo, 1); 
  repositoryName = (char *) GET_PARAM_ARG(pinfo, 2);
 
  // Check for the hidden token to avoid confirmation
  if (pinfo->parameter_count == 3) {
    if (((uint32) GET_PARAM_TOKEN_ID(pinfo, 3)) == AVOID_CONFIRM) {
      avoidConfirm = 1;
    }
  } 

#ifdef DEBUG 
  printf ("Number of parameters %d, avoidConfirm %d\n", pinfo->parameter_count,
	avoidConfirm);
#endif 

  // Validate the repository name, must be pre-configured
  if (validate_repository(repositoryName) != VSH_CALLBACK_SUCCESS) {
    VSH_ERROR("Invalid repository name %s\nPlease use a configured repository.\n\n",
           repositoryName);
    return VSH_CALLBACK_ERROR;
  }

  // Obtain lock to prevent other acs CLI
  // to be executed at the same time
  if (get_lock() != CARS_SUCCESS) {
    VSH_ERROR(LOCK_FAILURE_MSG);
    return (VSH_CALLBACK_ERROR);
  }

  // Verify the patch directory exists, otherwise create it
  struct stat st;
  if (stat(PATCHES_DIR, &st) != 0) {
    snprintf(command, DEFAULT_CMD_LEN, "mkdir %s", PATCHES_DIR);
    if (system(command) != 0) {
      VSH_ERROR("Cannot create patches directory (%s).\n", PATCHES_DIR);
      unlock();
      return (VSH_CALLBACK_ERROR);
    }
  } 

  // Get full path to destination including file name 
  snprintf(destFile, MAX_BACKUP_DIR, "%s/%s", PATCHES_DIR, patchName);

  rval = copy_from_repository(destFile, patchName, repositoryName);
  if (rval != CARS_SUCCESS) {

#ifdef DEBUG 
    printf ("After copy from repository - no success\n");
#endif 
    unlock();  
    VSH_ERROR("patch install %s from repository %s - transfer failed (code %d)\n",
                 patchName, repositoryName, rval);
    return VSH_CALLBACK_ERROR;
  }
   
  if(!_HashCheck(destFile)) {
    return VSH_CALLBACK_ERROR;
  }
             
  // Get the patch name w/o extention
  char patchShortName[DEFAULT_CMD_LEN];
  strncpy(patchShortName, patchName, DEFAULT_CMD_LEN);
  //assume that it ends in .tar.gpg, strip it off
  if(strlen(patchShortName) > strlen(BACKUP_EXT)) {
    *(patchShortName + strlen(patchShortName) - strlen(BACKUP_EXT)) = '\0';
  }

#ifdef DEBUG
  printf("Patch short name %s\n", patchShortName);
#endif

  // get confirmation to continue with install
  if (!avoidConfirm) {
    int32 ret = get_confirmation("Installing ACS patch requires a restart of ACS services. Continue? ", 3);

    if (ret != CONFIRM_YES) {
      system(cleanUpCmd);
      unlock();
      return VSH_CALLBACK_ERROR;
    }
  }
  
  // Open the patch bundle and perform validation 
  snprintf(command, DEFAULT_CMD_LEN, "%s %s %s %s %s",
           PATCH_WRAPPER, PATCH_OPEN, PATCHES_DIR, patchShortName, PATCH_LOG);
  if (system(command) != 0) {
    VSH_ERROR("Failure to open / validate the patch\n\n");
    unlock();
    return VSH_CALLBACK_ERROR;
  }   
  
  // Clean up command - done by the script
  snprintf(cleanUpCmd, DEFAULT_CMD_LEN, "rm -rf %s/%s", 
           PATCHES_DIR, patchShortName);

  int pid = fork();
  if (pid == -1) {
    perror("Fork failed");
    system(cleanUpCmd);
    unlock();     
    return VSH_CALLBACK_ERROR;
  } else if (pid == 0) {
         /* child */
    if (execl(PATCH_WRAPPER, PATCH_WRAPPER, PATCH_INSTALL, 
              PATCHES_DIR, patchShortName, PATCH_LOG, NULL) != 0) {
      VSH_ERROR("patch installation failed \n\n");
      unlock();     
      return VSH_CALLBACK_ERROR;
    } 
  } else {
    (void)waitpid(pid, 0, 0);
  }
  
  unlock();
  return VSH_CALLBACK_SUCCESS;

} // _acs_patch_install


		1.2.3 Code Review

			1.2.3.1 email
Hi Eddie/Yosi ,

              Could you please review the fix for CSCtw89837 acs does not verify signature of patches/upgrade/installation bundle

CARS Changes:
                               /ws/munnikri-bgl/cars201x_ACS54_br/smos/apps/install/cars_install.c
                              /ws/munnikri-bgl/cars201x_ACS54_br/smos/apps/install/cli/install_cli.c
                             /ws/munnikri-bgl/cars201x_ACS54_br/smos/apps/common/public/cars_codes.msg

ACS Changes:

Stream Details: 
Stream Name: 5_5_Bug_Fix.int.acs5_0.lx
View Name: munnikri__5_5_Bug_Fix.int.acs5_0.lx
Activity: md5verification
 
Files Modified:

                         /vob/nm_acs/acs/mgmt/cli/cars/src/main/ctrlcmd/acs_ctrl.c

Problem Description:
The acs patch creation system does not sign acs patches. As consequence,
'acs patch install' command  does not verify a signature of patches.

In some scenarios (e.g. download via ftp) the patch/upgrade/Installation content can be tempered by an attacker.

Fix:
        Imported _CarsHashCheck function from CARS trunk and once the upgrade/installation/patch bundle is downloaded to local from repository this function is called which will check the MD5SUM and SHA and display it to the user. Based on it the user can continue or abort the installation.   

Unit Test:
|1.          
1)	Applied the fix 
2)	Tried application upgrade 
       ACS152/admin# application upgrade acsb1.tar.gz manoj
      Save the current ADE-OS running configuration? (yes/no) [yes] ? yes
      Generating configuration...
      Saved the ADE-OS running configuration to startup successfully
      It is strongly recommended to take full backup before upgrade. Do you want to take a backup now ? (yes/no) [yes] ? yes
      % Creating backup with timestamped filename: acs-auto-backup-121130-1814.tar.gpg
       Calculating disk size for /opt/backup/backup-acs-auto-backup-1354299270
       Total size of backup files are 25 M.
       Max Size defined for backup files are 3584 M.
      Saved the backup to repository manoj successfully
      Initiating Application Upgrade...
      md5: 1a4d7037b75b5a4d227af75d62a85650
      sha256: b3dec95821f06801b83eccc54fa57e0bd1b9dcb3371a67cbe4d93d156d65b625
       % Please confirm above crypto hash matches what is posted on Cisco download site.
       % Continue? Y/N [Y] ? N
       %User aborted application upgrade

3)	Tried application install
  ACS170/admin# application install acsb46.tar.gz manoj
 Save the current ADE-OS running configuration? (yes/no) [yes] ? yes
 Generating configuration...
  Saved the ADE-OS running configuration to startup successfully
  Initiating Application installation...
 md5: 2c47fcb0cd7f88ca1db1b782f64ebd45
sha256: 2cf735caabf98ead09bb55c74db35787d35d3ba2bf9a343db1c5aedea2438c29
  % Please confirm above crypto hash matches what is posted on Cisco download site.
  % Continue? Y/N [Y] ? N
  %User aborted application installation 
       
4)	Tried acs patch installation
      ACS170/admin# acs patch install 5-4-0-17-1.tar.gpg repository manoj
     md5: 47e26ccaa29d384dc252174a76d11969
     sha256: 5816783bb9fc0b3ad08c740fd70b01cf03d3bb637139488e09184b3c1b40f223
      % Please confirm above crypto hash matches what is posted on Cisco download site.
      % Continue? Y/N [Y] ? N


Thanks,
Manoj


			1.2.3.2 Code
"c:\work\acs\5.5\features\CSCtw89837 acs patch install does not verify signature of patches\code" 

				1.2.3.2.1 cars_install.c
int _carsHashCheck(char *bundle) {
    int retval=0;
    static local_buf_t out = LOCAL_BUF_INIT;
    char cmd[MAXCOMMAND];
    char md5sum[MAXCOMMAND];
    char cmd2[MAXCOMMAND];
    char shasum[MAXCOMMAND];
    snprintf(cmd, MAXCOMMAND, "/usr/bin/md5sum  %s | /bin/awk -F\" \" {'print $1'}", bundle);
    commandOut(cmd, &out);
    if (out.buf) {
        snprintf(md5sum,MAXCOMMAND,out.buf);
    }
    lbClear(&out);
    snprintf(cmd2, MAXCOMMAND, "/usr/bin/sha256sum  %s | /bin/awk -F\" \" {'print $1'}", bundle);
    commandOut(cmd2, &out);
    if (out.buf) {
        snprintf(shasum,MAXCOMMAND,out.buf);
    }
    lbClear(&out);
    fprintf(stderr," md5: %s",md5sum);
    fprintf(stderr," sha256: %s",shasum);
    fprintf(stderr,"%% Please confirm above crypto hash matches what is posted on Cisco download site.\n");
    fprintf(stderr,"%% Continue? Y/N [Y] ? ");
    retval = yes_or_no("Y");
    return retval;
}

called from:
int carsInstallOrUpgrade (char *bundle, char *reposName, 
                          carsInstallType installtype)
{
    char stage_dir[MAXPATHLEN], 
         bundle_loc[MAXPATHLEN],
         working_file[MAXPATHLEN],
         package_name[MAXPATHLEN],
	 preinstall_dir[MAX_FILE_LEN],
	 postinstall_dir[MAX_FILE_LEN],
         script_type[MAXCOMMAND],
         cmd[MAXCOMMAND];
    int  install_type = 0,
         rpm_count = 0,
         i = 0,
         clean_stage_area = 0,
         release_lock = 0,
         rval = CARS_FAILURE,
         err = CARS_FAILURE;
    manifest_t *manifest = NULL;
    rpm_t *rpms = NULL;
    static local_buf_t out = LOCAL_BUF_INIT;

    /* Check filename and reposname for validity */
    if (!bundle || !reposName) {
        printf("\n Invalid input parameters...quiting\n");
        err = CARS_INVALID_INPUT_OBJECT;
        goto abort;
    }

    carsINFOarg(DBGA_APP_INSTALL, "Install initiated with bundle - %s, repo - %s", 
                bundle, reposName);

    if((err = _carsLockSemafile(&fdInstallLock, INSTALL_LOCK, FALSE)) != CARS_SUCCESS) {
        if(err == CARS_WOULD_BLOCK) 
            err = CARS_INSTALL_INPROGRESS;
        goto abort;
    }
    release_lock = 1;
        
    /* Create staging area */
    err = createStagingArea(stage_dir); 
    if (err != CARS_SUCCESS) {
        goto abort;
    }
    carsINFOarg(DBGA_APP_INSTALL, "Stage area - %s", stage_dir);

    clean_stage_area = 1;

    carsINFO(DBGA_APP_INSTALL, "Getting bundle to local machine");
    /* Get Filename from Repository to staging area */
    snprintf(bundle_loc, MAXPATHLEN, "%s/%s", stage_dir, bundle);
    if ((err = carsCopyIn(bundle_loc, bundle, reposName)) != CARS_SUCCESS) {
        carsERRarg(DBGA_APP_INSTALL, 
                   "Could not get remote bundle %s from repo %s", 
                   bundle, reposName);
        goto abort;
    }
    carsINFOarg(DBGA_APP_INSTALL, "Got bundle at - %s", bundle_loc);   

    /* Verify if the file is in good condition */
    if (!_carsFileExists(bundle_loc)) {
        carsERRarg(DBGA_APP_INSTALL, 
                   "file %s from repo %s not found after copying",
                   bundle, reposName); 
        err = CARS_INSTALL_FILELOST;
        goto abort;
    }
    
    if(!_carsHashCheck(bundle_loc)) {
       carsERRarg(DBGA_APP_INSTALL," User aborted installation of %s bundle failed",bundle);
       err = CARS_INSTALL_USER_ABORT;
       if (installtype == APP_UPGRADE) {
                 carsERRarg(DBGA_APP_INSTALL, "User aborted upgradation of application bundle %s", bundle);
           }else if(installtype == APP_INSTALL){
                 carsERRarg(DBGA_APP_INSTALL, "User aborted installation of application bundle %s", bundle);
           }else if(installtype == APP_PATCH){
                 carsERRarg(DBGA_APP_INSTALL, "User aborted installation of patch bundle %s", bundle);
           }
            goto abort;
         }

    carsINFOarg(DBGA_APP_INSTALL, "Unbundling package %s", bundle);

    /* Unbundle the package */
    snprintf(cmd, MAXCOMMAND, "/bin/tar zxf %s -C %s", bundle_loc, stage_dir);
    err = commandOut(cmd, &out);
    if (err) {
        err = CARS_INSTALL_UNTAR;
        carsERRarg(DBGA_APP_INSTALL, 
                   "Could not Unbundle Pkg %s from repo %s, err = %s", 
                   bundle, reposName, out.buf);
        goto abort;
    }
    carsINFO(DBGA_APP_INSTALL, "Unbundling done. Verifying input parameters...");

    /* See if the checksum file is present and confirm checksums if so */
    snprintf(working_file, MAXPATHLEN, "%s/%s", stage_dir, "checksums.md5");
    if (_carsFileExists(working_file)) {
        snprintf(cmd, MAXCOMMAND, "/opt/system/bin/verifysums.sh %s", stage_dir);
        if(system(cmd) != 0) {        
            err = CARS_INSTALL_BADCHECK;
            carsERR(DBGA_APP_INSTALL, "install bundle checksums invalid");
        goto abort;
        }
    }

    /* Verify if manifest.xml is available in the bundle */
    snprintf(working_file, MAXPATHLEN, "%s/%s", stage_dir, "manifest.xml");
    if (!_carsFileExists(working_file)) {
        carsERRarg(DBGA_APP_INSTALL, " manifest.xml file missing from bundle %s",
                bundle);
        err = CARS_INSTALL_NOMANIFEST;
        goto abort;
    }

    carsINFOarg(DBGA_APP_INSTALL, "Manifest file is at - %s", working_file);   

    /* Read the manifest file and get appname */
    manifest = populateManifestParams(working_file);
    if (manifest == NULL) {
        carsERR(DBGA_APP_INSTALL, "manifest.xml file has errors");
        err = CARS_INSTALL_BADMANIFEST;
        goto abort;
    }

    carsINFOarg(DBGA_APP_INSTALL, "Manifest file appname - %s", manifest->name);   

    /* Verify if appname is already installed on system and <type> tag */
    if (strcmp(manifest->name, SYSTEM_APP_ID) != 0)
        install_type = checkAppInstalled(manifest->name);
    else
        install_type = 1; // We assume the "SYSTEM" is always "installed"  :)

    if (install_type && (installtype == APP_INSTALL)) {
        carsERRarg(DBGA_APP_INSTALL, "App (%s) is already installed, please "
            "re-run with upgrade option", manifest->name, manifest->pkgtype);
        err = CARS_INSTALL_CANTINSTALL;
        goto abort;
    }
    if (!install_type && (installtype == APP_UPGRADE)) {
        carsERRarg(DBGA_APP_INSTALL, "App (%s) is not installed, please "
            "re-run with install option", manifest->name, manifest->pkgtype);
        err = CARS_INSTALL_CANTUPGRADE;
        goto abort;
    }
    if(installtype == APP_UPGRADE) {
        rval = _carsVerifyNewerVersion(manifest);
        if (rval != CARS_SUCCESS) {
            carsERR(DBGA_APP_INSTALL, "UPGRADE: Install aborted because version is the same or older than the current version");
            err = rval;
            goto abort;
        }
    }
    if (!install_type && (installtype == APP_PATCH)) {
        carsERRarg(DBGA_APP_INSTALL,
	    "App (%s) is not installed, patching disallowed "
            , manifest->name, manifest->pkgtype);
        err = CARS_INSTALL_CANTPATCH;
        goto abort;
    }

    if (install_type && (installtype == APP_PATCH)) {
	carsINFOarg(DBGA_APP_INSTALL, " Patch bundle contains patch(%s)  for app version(%s) ",
                 manifest->patchnumber, manifest->versionnum);
        if (!compareAppPatchVersion(manifest->name,manifest->patchnumber,manifest->versionnum)) {
                carsERRarg(DBGA_APP_INSTALL,
                 "Patch  for application version (%s) is not matching the installed app version ", manifest->versionnum, manifest->name );
                 err = CARS_INSTALL_PATCH_APPVER_MISMATCH;
                 goto abort;

        }

       if (checkPatchInstalled(manifest->name,manifest->patchnumber)){
		carsERRarg(DBGA_APP_INSTALL,
		"App (%s) patch (%s) is already installed ", manifest->name, manifest->patchnumber);
		err = CARS_INSTALL_PATCH_EXISTS;
		 goto abort;	
	}
	
       if (_carsCheckForNewerPatches(manifest->name,manifest->patchnumber) != CARS_SUCCESS) {
		carsERRarg(DBGA_APP_INSTALL, " App (%s) patch (%s) cannot be installed as a newer version is already installed",  manifest->name, manifest->patchnumber);
		err = CARS_INSTALL_PATCH_OLDVER;
		goto abort;			 

	}
    }

    carsINFOarg(DBGA_APP_INSTALL, "Manifest file pkgtype - %s", 
                manifest->pkgtype);   

    /* Verify <pkgtype> tag to CARS */
    if (!checkPkgType(manifest->pkgtype)) {
        carsERRarg(DBGA_APP_INSTALL, "App (%s) has invalid platform %s",
                manifest->name, manifest->pkgtype);
        err = CARS_SPECIFIC_PHRASE_NOT_ALLOWED;
        goto abort;
    }

    /* Verify dependency list */
    if (installtype != APP_PATCH) {
        carsINFO(DBGA_APP_INSTALL, "Verify dependency list - ");   
        if (!checkDependency(manifest->dependency_head)) {
            carsERRarg(DBGA_APP_INSTALL,
                   "App (%s) has insufficient dependencies %s",
                   manifest->name, manifest->pkgtype);
            err = CARS_FAILURE;
            goto abort;
        }
    }

    /* Verify and apply license */
    if (installtype != APP_PATCH) {
        carsINFO(DBGA_APP_INSTALL, "Verify app license - ");
        if (!ApplyLicense(manifest->license)) {
            carsERRarg(DBGA_APP_INSTALL, "App (%s) has insufficient license",
                manifest->name);
            err = CARS_FAILURE;
            goto abort;
        }
    }

    if (installtype != APP_PATCH) {
    	carsINFO(DBGA_APP_INSTALL, "Verify app RPM's"); 
    	rpm_count = countRPMList(manifest->rpms_head);
    	if (!rpm_count){
       		 carsERRarg(DBGA_APP_INSTALL, "App (%s) has no RPM's to install", 
                   manifest->name);
       		 err = CARS_INSTALL_NORPMS;
        	 goto abort;
    	}
	carsINFOarg(DBGA_APP_INSTALL, "No of RPM's - %d", rpm_count);
    }else {
	if (!manifest->zip) {
		carsERRarg(DBGA_APP_INSTALL, "There is no zip file to install in App patch (%s)", manifest->name);
		err = CARS_INSTALL_NOZIP;
		goto abort;
	}
    }

    /* Verify disk requirements */
    if (installtype != APP_PATCH) {
        carsINFOarg(DBGA_APP_INSTALL, "Disk - %s", manifest->disk);
        if (!checkDiskAvailable(manifest->disk)) {
            carsERRarg(DBGA_APP_INSTALL, "\n App (%s) has insufficient disk space\n",
                   manifest->name);
            err = CARS_INSTALL_NOSPACE;
            goto abort;
        }
    }

    /* Verify memory requirements */
    if (installtype != APP_PATCH) {
        carsINFOarg(DBGA_APP_INSTALL, "Mem requested by app - %s", manifest->memory);
        if (!checkMemoryAvailable(manifest->memory)) {
            carsERRarg(DBGA_APP_INSTALL, 
                   "App (%s) has insufficient memory to install",
                   manifest->name);
            err = CARS_INSTALL_NOMEMORY;
            goto abort;
        }
    }
	
   if (installtype!= APP_PATCH) {
        if(manifest->preinstallzip)
        {
            carsINFO(DBGA_APP_INSTALL, "Verifying preinstall zip...");
            if(!checkFileExistsForInstall(manifest->preinstallzip,stage_dir))
            {
                carsERRarg(DBGA_APP_INSTALL,
                   "App (%s) is missing preinstall zip file in bundle\n", manifest->name);
                err = CARS_INSTALL_PREINSTALL_FAILURE;
                goto abort;
	        }
        }
        carsINFO(DBGA_APP_INSTALL, "Verifying RPM's...");
	    /* Verify <packages>/<rpm> list and see if all RPM's exists in bundle */
    	if (!checkPackageRPM(manifest->rpms_head, stage_dir)) {
          carsERRarg(DBGA_APP_INSTALL, 
                   "App (%s) has insufficient RPMs available in bundle\n",
                   manifest->name);
           err = CARS_INSTALL_MISSINGRPM;
           goto abort; 
  	    }
        carsINFO(DBGA_APP_INSTALL, "Verifed all RPM's in bundle and manifest");
        if(manifest->postinstallzip)
        {
            carsINFO(DBGA_APP_INSTALL, "Verifying postinstall zip...");
            if(!checkFileExistsForInstall(manifest->postinstallzip,stage_dir))
            {
                carsERRarg(DBGA_APP_INSTALL,
                   "App (%s) is missing postinstall zip file in bundle\n",manifest->name);
                err = CARS_INSTALL_POSTINSTALL_FAILURE;
                goto abort;
            }
        }
	/* Needs to pass to the safeCommandOut as string*/
        if (installtype == APP_UPGRADE) {
            snprintf(script_type, MAXCOMMAND,"UPGRADE");
        }else {
            snprintf(script_type, MAXCOMMAND,"INSTALL"); 
        }

        if (manifest->preinstallzip) {
            carsINFO(DBGA_APP_INSTALL, "Executing preinstall steps...");  
        	snprintf(preinstall_dir, MAX_FILE_LEN, stage_dir,"/preinstall");
            snprintf(cmd, MAXCOMMAND, "cd %s ; /usr/bin/unzip -o %s ; /bin/chmod 755 *.sh ",preinstall_dir, manifest->preinstallzip);
            commandOut(cmd, &out);
            carsDEBUGarg(DBGA_APP_INSTALL, "Unziping preinstall zip file"
                "out - %s", out.buf);
            if (out.buf) {
                if (strstr(out.buf, "End-of-central-directory signature not found") != NULL) {
                    carsERRarg(DBGA_APP_INSTALL,
                        "App (%s) Preinstall zip file is corrupted, out - %s",manifest->name,out.buf);
                    err= CARS_INSTALL_PREINSTALL_FAILURE;
                    lbClear(&out);
                    cleanStageArea(stage_dir, bundle);
                    goto abort;
                }
                lbClear(&out);
            }
            if (!checkFileExistsForInstall(manifest->preinstallscript, preinstall_dir)) {
                carsERRarg(DBGA_APP_INSTALL,
                    "App (%s) does not have preinstall script (%s) available in zip (%s) from bundle\n",
                    manifest->name,manifest->preinstallscript,manifest->preinstallzip);
                err = CARS_INSTALL_PREINSTALL_FAILURE;
                lbClear(&out);
                cleanStageArea(stage_dir, bundle);
                goto abort;
            }
            carsINFOarg(DBGA_APP_INSTALL, "Executing preinstall script %s from %s", manifest->preinstallscript, manifest->preinstallzip);
            snprintf(cmd, MAXCOMMAND, "%s/%s",preinstall_dir, manifest->preinstallscript);
            carsDEBUGarg(DBGA_APP_INSTALL, "Executing preinstall %s",cmd);
            err=  safeInteractiveCommand(cmd,cmd,script_type,NULL);
	        if (err!=0) {
                carsERRarg(DBGA_APP_INSTALL, "App (%s) Preinstall script %s failed; %s ",manifest->name, manifest->preinstallscript,out.buf );
                err= CARS_INSTALL_PREINSTALL_FAILURE;
                lbClear(&out);
                cleanStageArea(stage_dir,bundle);
                goto abort;
            }
            carsINFOarg(DBGA_APP_INSTALL, "Finished preinstall %s",cmd);
       } 

     /* Install or Upgrade RPM */
     for (rpms = manifest->rpms_head, i = 1; rpms != NULL; i++, rpms = rpms->next) {

        carsINFOarg(DBGA_APP_INSTALL, "Installing RPM no %d of %d", i, rpm_count);

        /* Verify if the RPM file is a RPM package */
        snprintf(cmd, MAXCOMMAND, "/bin/rpm -qpi %s/%s", stage_dir, rpms->name);
        commandOut(cmd, &out);
        carsINFOarg(DBGA_APP_INSTALL,
                 "Verify if file %s is a RPM file, out - %s", 
                 rpms->name, out.buf);
        if (out.buf) {
            if (strstr(out.buf, "License:") == NULL) {
                carsERRarg(DBGA_APP_INSTALL, "Problem installing (%s) = %s."
                           " Cleaning up partial install. Please re-install with"
                           " good Application bundle. This version of ADE-OS does not"
                           " support roll-back to previous installed version.",
                           rpms->name, out.buf);
                carsUnInstall(manifest->name);
                err = CARS_INSTALL_CORRUPTED;
                goto abort;
            }
        }
        lbClear(&out);

        /* Save the package name */
        snprintf(cmd, MAXCOMMAND, "/bin/rpm -qp %s/%s", stage_dir, rpms->name);
        commandOut(cmd, &out);
        /* In case there are RPM key warnings, skip to the last line */
        char* tmp_pkgname;
        for ( tmp_pkgname = strtok(out.buf, "\n"); tmp_pkgname != NULL;
              tmp_pkgname = strtok(NULL, "\n") ) {
            strncpy(package_name, tmp_pkgname, MAXPATHLEN);
        }
        carsINFOarg(DBGA_APP_INSTALL, "Package name from RPM, out - %s", package_name);
        lbClear(&out);

        /* Verfiy if the package is already installed */
        snprintf(cmd, MAXCOMMAND, "/bin/rpm -q %s", package_name);
        commandOut(cmd, &out);
        carsINFOarg(DBGA_APP_INSTALL, "Verify if pkg is already installed,"
                 "out - %s", out.buf);
        if (out.buf) {
            if (strstr(out.buf, "not") == NULL) {
                carsINFOarg(DBGA_APP_INSTALL, 
                            "Pkg is already installed, out - %s", out.buf);
            } else {
                /*
                 * If not installed, then install it 
                 * snprintf(cmd, MAXCOMMAND, "/bin/rpm -i %s/%s",
                 *  stage_dir, rpms->name);
                 */
                carsINFOarg(DBGA_APP_INSTALL, 
                            "Pkg is not installed, out - %s", out.buf);
            }
            snprintf(cmd, MAXCOMMAND,"%s/%s",stage_dir, rpms->name);
        }
        lbClear(&out);
        err = safeInteractiveCommand("/bin/rpm","/bin/rpm","-U","--nomd5","--replacepkgs","--force",cmd,NULL);

        /* Verify if RPM got installed properly */
        snprintf(cmd, MAXCOMMAND, "/bin/rpm -V --nofiles %s", package_name);
        commandOut(cmd, &out);
        carsINFOarg(DBGA_APP_INSTALL, 
                    "Post install RPM verify cmd - %s", cmd);
        carsINFOarg(DBGA_APP_INSTALL, 
                    "Post install RPM verify  output - %s", out.buf);
        if (out.buf) {
            if (strstr(out.buf, "is not installed") != NULL) {
                carsERRarg(DBGA_APP_INSTALL,
                        "Install of RPM - %s failed", rpms->name);
                if (installtype == APP_UPGRADE) {
                    carsERRarg(DBGA_APP_INSTALL, "Problem installing (%s) = %s."
                           " Since this is an upgrade installation, this could be "
                           " application logic limiting upgrade.  The existing "
                           " application bundle will not be removed.",
                           rpms->name, out.buf);
                    err = CARS_INSTALL_UPGRADERESTRICTED;
                    goto abort;
                } else {
                    carsERRarg(DBGA_APP_INSTALL, "Problem installing (%s) = %s."
                           " Cleaning up partial install. Please re-install with"
                           " good Application bundle. This version of ADE-OS does not"
                           " support roll-back on failure to previous installed version.",
                           rpms->name, out.buf);
                    carsUnInstall(manifest->name);
                    err = CARS_INSTALL_CORRUPTED;
                    goto abort;
                }
            }
	    if(strstr(out.buf,"error: %verify") != NULL) {
	    carsERRarg(DBGA_APP_INSTALL,"RPM  install verification failed",  rpms->name);
	        if (installtype == APP_UPGRADE) {
                    carsERRarg(DBGA_APP_INSTALL, "Verification of  %s failed, %s."
                           " Since this is an upgrade installation will not proceed further.",
                           rpms->name, out.buf);
                    err = CARS_INSTALL_UPGRADEFAILED;
                    goto abort;
                }
	    }
        }
        lbClear(&out);

     } /* End of for loop */

        if (manifest->postinstallzip) {
            carsINFO(DBGA_APP_INSTALL, "Executing postinstall steps...");
                snprintf(postinstall_dir, MAX_FILE_LEN, stage_dir,"/postinstall");
            snprintf(cmd, MAXCOMMAND, "cd %s ; /usr/bin/unzip -o %s ; /bin/chmod 755 *.sh ",postinstall_dir, manifest->postinstallzip);
            commandOut(cmd, &out);
            carsDEBUGarg(DBGA_APP_INSTALL, "Unziping postinstall zip file"
                "out - %s", out.buf);
            if (out.buf) {
                if (strstr(out.buf, "End-of-central-directory signature not found") != NULL) {
                    carsERRarg(DBGA_APP_INSTALL,
                        "App (%s) Postnstall zip file is corrupted, out - %s",manifest->name,out.buf);
                    err= CARS_INSTALL_POSTINSTALL_FAILURE;
                    lbClear(&out);
                    cleanStageArea(stage_dir, bundle);
                    goto abort;
                }
                lbClear(&out);
            }
            if (!checkFileExistsForInstall(manifest->postinstallscript, postinstall_dir)) {
                carsERRarg(DBGA_APP_INSTALL,
                    "App (%s) does not have postinstall script (%s) available in zip (%s) from bundle\n",
                    manifest->name,manifest->postinstallscript,manifest->postinstallzip);
                err = CARS_INSTALL_POSTINSTALL_FAILURE;
                lbClear(&out);
                cleanStageArea(stage_dir, bundle);
                goto abort;
            }
            carsINFOarg(DBGA_APP_INSTALL, "Executing postinstall script %s from %s", manifest->postinstallscript, manifest->postinstallzip);
            snprintf(cmd, MAXCOMMAND, "%s/%s",postinstall_dir, manifest->postinstallscript);
            carsDEBUGarg(DBGA_APP_INSTALL, "Executing postinstall %s",cmd);
            err=  safeInteractiveCommand(cmd,cmd,script_type,NULL);
                if (err!=0) {
                carsERRarg(DBGA_APP_INSTALL, "App (%s) Postinstall script %s failed: %s",manifest->name, manifest->postinstallscript,out.buf );
                err= CARS_INSTALL_POSTINSTALL_FAILURE;
                cleanStageArea(stage_dir,bundle);
                goto abort;
            }
            carsINFOarg(DBGA_APP_INSTALL, "Finished postinstall %s",cmd);
       }
   }
  if (installtype == APP_PATCH) {
	carsINFO(DBGA_APP_INSTALL, "Verifying zip...");
	if (!checkPackageZip(manifest->zip, stage_dir)) {
		carsERRarg(DBGA_APP_INSTALL,
		   "App (%s) Patch (%s) does not have zip (%s) available in bundle\n",
		   manifest->name,manifest->patchnumber,manifest->zip);
		err = CARS_INSTALL_MISSINGZIP;
		goto abort;
	 }
	snprintf(cmd, MAXCOMMAND, "cd %s ; /usr/bin/unzip -o %s ; /bin/chmod 755 *.sh ",stage_dir, manifest->zip);
	commandOut(cmd, &out);
	carsDEBUGarg(DBGA_APP_INSTALL, "Unziping patch zip file"
		 "out - %s", out.buf);
	if (out.buf) {
	    if (strstr(out.buf, "End-of-central-directory signature not found") != NULL) {
		carsERRarg(DBGA_APP_INSTALL,
			    "App (%s) Patch (%s) zip file is corrupted, out - %s",manifest->name,manifest->patchnumber,out.buf);
		err= CARS_INSTALL_BADZIP;
		lbClear(&out);
		cleanStageArea(stage_dir, bundle);
		goto abort;
	    }
	}
        if (!checkFileExistsForInstall(manifest->patchinstall, stage_dir)) {
                carsERRarg(DBGA_APP_INSTALL,
                   "App (%s) Patch (%s) does not have install script (%s) available in zip (%s) from bundle\n",
                   manifest->name,manifest->patchnumber,manifest->patchinstall,manifest->zip);
                err = CARS_INSTALL_MISSINGFILE;
		lbClear(&out);
		cleanStageArea(stage_dir, bundle);
                goto abort;
         }

	 if (!checkFileExistsForInstall(manifest->patchuninstall, stage_dir)) {
                carsERRarg(DBGA_APP_INSTALL,
                   "App (%s) Patch (%s) does not have uninstall script (%s) available in zip (%s) from bundle\n",
                   manifest->name,manifest->patchnumber,manifest->patchuninstall,manifest->zip);
                err = CARS_INSTALL_MISSINGFILE;
		lbClear(&out);
		cleanStageArea(stage_dir, bundle);
                goto abort;
         }


	carsINFOarg(DBGA_APP_INSTALL, "Executing patch install script %s from %s", manifest->patchinstall, manifest->zip);
	snprintf(cmd, MAXCOMMAND, "%s/%s",stage_dir, manifest->patchinstall);
	carsDEBUGarg(DBGA_APP_INSTALL, "Executing patch install %s",cmd);
	err=  safeCommandOutChildStat(&out,cmd,cmd,NULL);
	if (err!=0) {
		carsERRarg(DBGA_APP_INSTALL, "App (%s) Patch (%s) install  failed: %s",manifest->name, manifest->patchnumber,out.buf );
		err= CARS_INSTALL_PATCH_FAILURE;
		lbClear(&out);
		cleanStageArea(stage_dir,bundle);
		goto abort;
	}
	carsINFOarg(DBGA_APP_INSTALL, "Finished patch install %s",cmd);
    }

    /* Open TCP and UDP ports if any provided in manifest*/
    if (installtype != APP_PATCH) {
        carsINFO(DBGA_APP_INSTALL, "Opening Firewall ports");
        err = carsOpenManifestPorts(manifest);
        if (err) {
            carsERRarg(DBGA_APP_INSTALL, "Error opening ports %d", err);
            err = CARS_INSTALL_OPENPORTS;
            goto abort; 
        }
    }
    
   
    /* Application has option to disable remote auth feature during
     * install.  
     */
    if (installtype != APP_PATCH) {
        carsINFOarg(DBGA_APP_INSTALL, "Application RemoteAuth: - %s",
					manifest->remoteauth);
        if (manifest->remoteauth != NULL &&
	    !checkRemoteAuth(manifest->remoteauth)) {
            carsINFOarg(DBGA_APP_INSTALL, "\n App (%s) disabling remote authentication feature.\n",
                   manifest->name);
            err = rename(CARS_REMOTE_AUTH_PAR, CARS_REMOTE_AUTH_PAR_BACKUP);
            if (err) {
                carsINFOarg(DBGA_APP_INSTALL, "Remote auth CLI file: %s already disabled",
                         CARS_REMOTE_AUTH_PAR);
            }
            err = rename(CARS_REMOTE_AUTH_XML, CARS_REMOTE_AUTH_XML_BACKUP);
            if (err) {
                carsINFOarg(DBGA_APP_INSTALL, "Remote auth CLI file: %s already disabled",
                         CARS_REMOTE_AUTH_XML);
            }        
        }
    }
    
    /* Copy manifest to manifest database */
    carsINFO(DBGA_APP_INSTALL, "Store manifest in db... ");
    storeManifest(stage_dir, manifest);

    /* 
     * Store package names in reverse order to 
     * /storeddata/Installed/<appname> 
     */
    carsINFO(DBGA_APP_INSTALL, "Store package names in db... ");
    storePackageNames(stage_dir, manifest);

    /* Save imp data from staging dir */
    carsINFO(DBGA_APP_INSTALL, "Save bundle and logs in db... ");
    saveStageArea(stage_dir, manifest, bundle_loc);

    /* Clean up staging dir */
    carsINFO(DBGA_APP_INSTALL, "Cleaning staging area");
    cleanStageArea(stage_dir, bundle);
   
    err = safeCommandOut(&out, "/sbin/ldconfig", "ldconfig", NULL);
    if (err != CARS_SUCCESS) {
        carsERRarg(DBGA_APP_INSTALL, "Error configuring library path %d", err);
        err = CARS_INSTALL_LIBPATH;
        goto abort;
    }

    /* Reboot the box if necessary */
    carsINFO(DBGA_APP_INSTALL, "Checking if app needs reboot ");
    err = ApplyReboot(manifest->reboot);
    if (err != CARS_SUCCESS) {
        carsERRarg(DBGA_APP_INSTALL, "Error with Apply Reboot %d", err);
        err = CARS_INSTALL_NOREBOOT;
        goto abort;
    }
    err = ApplyFileBasedReboot();
    if (err != CARS_SUCCESS) {
        carsERRarg(DBGA_APP_INSTALL, "Error with Apply File based Reboot %d", err);
        err = CARS_INSTALL_NOREBOOT;
        goto abort;
    }
    

    if (installtype != APP_PATCH) {
        // Set a flag if we're installing from the setup util.
        // In that case we don't want to start the app.
	// Only attempt the start if we are NOT rebooting
        int notFromSetup = system("/bin/ps -o command |grep -v grep|grep '/etc/init.d/install_apps' > /dev/null 2>&1");
        if (notFromSetup) {
            carsINFO(DBGA_APP_INSTALL, "App being installed from CLI or API (not initial setup)");
        } else {
            carsINFO(DBGA_APP_INSTALL, "App being installed as part of initial setup");
        }
	if ((manifest->reboot == NULL || 
             strcasecmp(manifest->reboot, "no") == 0) && notFromSetup ) {
            carsINFOarg(DBGA_APP_INSTALL,
	      "Starting application %s", manifest->name);
            /* Post install <init> start */
            if (execInitTag(manifest->init, APP_START, &out) != CARS_SUCCESS) {
                carsERRarg(DBGA_APP_INSTALL,
		  "App (%s) has trouble executing <init> tag", manifest->name);
                err = CARS_APP_FAILED_TO_START;
                goto abort;
            }
        }
    }

    err = CARS_INSTALL_SUCCESSFUL_COMPLETE;
    carsINFO(DBGA_APP_INSTALL, "Install successful...");

abort:
    if (manifest) 
        _carsFreeManifest(manifest);
    if (clean_stage_area)
        cleanStageArea(stage_dir, NULL); 
    if(release_lock)
        _carsUnlockSemafile(fdInstallLock, INSTALL_LOCK);
    return err;
}


			1.2.3.3
		1.2.4
	1.3 MAR Cache Persistency 


		1.3.1  Functional Specification
MAR Cache Persistency
ACS 5.5 writes MAR Cache content, list of calling-station-id and corresponding time stamp, to a regular file on disk during controlled stop (e.g. acs stop) of ACS Runtime. ACS 5.5 reads MAR Cache content from the file during ACS Runtime start. In case of non-controlled stop of ACS the MAR Cache content will not be saved. Also when ACS RT is down the MAR cache of this node is not accessible to other ACS nodes.

Note that changes to the machine clock will invalidate the MAR cache content since it relies on time stamps. 

		1.3.2 Design

			1.3.2.1  Task breakdown

| 1. research players. MAR Cache objects, Time stamp etc. - 1d
| 2. Locate right place in code to plant hook for saving cache - 0.5d
| 3. save cache to file - 2d
| 4. optional, secure file w/ cryptographic HMAC (encrypted) - 2d
| 5. Locate right place in code to plant hook for loading cache - 0.5d
| 6. load cache from file - 2d
| 7. Build/arrange setup - 2d
| 8. E2E tests - 2d
| 9. CR + fixes+ deliver - 2d

			1.3.2.1 trigger save upon acs stop
- run.sh
case "$1" in
    'stop')
        timeout=40
        pid=`ps -ef | grep $daemon | grep -v grep | grep -v exec_stop | grep -v exec_wrapper | grep -v /usr/bin/gdb | awk '{print $2;}'`
        if [ -n "$pid" ]; then
            kill $pid
            echo "Waiting for daemon to shut down (max $timeout sec)..."
            for (( i = 0; i <= "$timeout"; i++)); do
                echo -n .
                sleep 1
                rpid=`ps -ef | grep $daemon | grep -v grep | grep -v exec_stop | grep -v exec_wrapper | grep -v /usr/bin/gdb | awk '{print $2;}'`
                if [ -n "$rpid"  ]; then
                    if [ "$i" == "$timeout" ]; then
                        echo .
                        echo "Send kill -9 to daemon to shut down..."
                        logger -p local0.warning "[ACS] Runtime failed to stop" -t MSGCAT58007
                        kill -9 $rpid
                    fi
                else
                    break
                fi
            done
            echo .
            echo "done"
            echo "Runtime daemon stopped"
        else
            echo "Runtime daemon not running"

        fi
    ;;

sends SIGTERM or SIGKILL

- Handling the signal
[yizaq@yizaq-lnx:Mon Nov 05:/view/yizaq__int.acs5_0.lx/vob/nm_acs/acs/runtime]$ search_in_files 'SIGTERM'
./daemons/rt_daemon/src/main.cpp:    ACE_OS::signal( SIGTERM, (ACE_SignalHandler) RTDaemon::handle_signal);
./daemons/rt_daemon/src/RTDaemon.cpp:    sigset.sig_add( SIGTERM);
./daemons/rt_daemon/src/RTDaemon.cpp:  case SIGTERM:
./daemons/rt_daemon/src/RTDaemon.cpp:                                         SIGTERM);
./daemons/logForward/src/Daemon.cpp:    ACE_OS::signal(SIGTERM, &Daemon::handleSignal);
./daemons/logForward/src/Daemon.cpp:        case SIGTERM:

-
			1.3.2.2
		1.3.3

	1.4 Centrify automatic integration to patches


	1.5 P1-R26 ACS MUST NOT expose “backup” or “Database” encryption keys publicly in any way, shape or form


		1.5.1 Functional Specification
ACS backup file will now be encrypted, both when done from CLI and when done from GUI.
The encryption password will be obtained as follows:
CLI: After executing the backup command the user will be prompted twice (for confirmation) to provide an encryption password. 
GUI: Under System Administration > Operations > Scheduled Backups >
the user will be presented with a new field for choosing a backup encryption password. The user will need to input the password twice for confirmation.

The encryption password, together with a static key will be input to HMAC-SHA-256 for generating a 256 bit encryption key.
GPG program will then use this key to encrypt the backup file, either the one specified in CLI or the scheduled backup.

ACS restore will prompt the user for the encryption password and generate the decryption key (same as encryption) for decrypting the backup. 
Decryption of the backup will only be possible from an ACS machine

ACS will enforce a non configurable password policy as follows:
- Password must contain at least one upper case letter.
- Password must contain at least one lower case letter.
- Password should not be less than 8 characters and not be more than 32 characters
- Special characters are allowed with the exception of: ` $ ( ) 
These can be used for command injection


		1.5.2 Task breakdown
| 1. CLI
| a. Add to backup.sh and restore.sh passowrd prompt + pwd policy - 3d
| 
| 2. GUI
| a. Add to GUI 2 passowrd fields - 4d
| b. Add to GUI pwd policy enforcment + error popup - 4d
| c. Pass the pwd to scheduled backup, research + implementation - 3d
| 
| 3. Common
| a. research & implement producing base64 representation of openssl HMAC-SHA-256 for the encryption key - 2d
| b. implement pgp encryption + decryption using pwd key -> encryption key - 2d
| 
| 4. Dev tests:
| a. common - 1d
| a. CLI - 1.5d
| b. GUI - 3d


	1.6 TCP/TCPSecure Syslog

		1.6.1 Code review 


Hi Sveta, Alina &Yosi,


Sveta, please, review the next files:
============================================================================== 
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/SyslogTCPConnectionManager.h
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/SyslogTCPConnectionManager.cpp
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/SyslogTCPConnection.h
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/SyslogTCPConnection.cpp
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/SyslogSettings.h
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/SyslogSettings.cpp
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/SyslogSecureTCPConnection.h
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/SyslogSecureTCPConnection.cpp
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/SyslogMessageBuffering.h
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/SyslogMessageBuffering.cpp
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/SyslogFileManager.h
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/SyslogFileManager.cpp
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/SyslogBaseTCPConnection.h
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/SyslogBaseTCPConnection.cpp
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/GNUmakefile
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/ViewMessagesRecoveryHelper.h
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/ViewMessagesRecoveryHelper.cpp
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/SyslogTarget.h
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/SyslogTarget.cpp
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/SyslogLogger.h
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/SyslogLogger.cpp
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/SyslogFormatter.h
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/SyslogFormatter.cpp
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/SyslogFileManager.h
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/SyslogFileManager.cpp
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/SendToLogEvent.h
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/SendToLogEvent.cpp
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/ScopeHandler.h
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/ScopeHandler.cpp
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/MessageObject.h
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/MessageObject.cpp
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/LogNotificationCenter.cpp
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/LogIOEventHandler.h
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/LogIOEventHandler.cpp
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/LoggingTargets.h
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/LoggingTargets.cpp
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/LoggingForwards.h
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/LoggingConfiguration.cpp
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/FunctionalScopeView.h
    /vob/nm_acs/acs/runtime/infrastructure/logging/src/FunctionalScopeView.cpp
    /vob/nm_acs/acs/runtime/infrastructure/logging/src
    /vob/nm_acs/acs/runtime/infrastructure/cryptoService/src/PKIHelper.h
    /vob/nm_acs/acs/runtime/infrastructure/cryptoService/src/PKIHelper.cpp
    /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSLInterface.h
    /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSL.h
    /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSL.cpp
    /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSLContext.h
    /vob/nm_acs/acs/runtime/infrastructure/cryptoLib/src/SSLContext.cpp
    /vob/nm_acs/acs/runtime/infrastructure/GNUmakefile

view : adubrovs6__adubrovs.int.acs5_0.lx
activity: TCPSyslog@/vob/nmtgre_proj
==============================================================================



Alina, please, review the next files:
==============================================================================
    /vob/nm_acs/acs/mgmt/gui/app/src/main/java/com/cisco/nm/acs/mgmt/gui/app/entities/RemoteLogTargetsGUIEntity.java
    /vob/nm_acs/acs/mgmt/bl/framework/src/main/resources/springConfig.xml
    /vob/nm_acs/acs/messagecatalog/src/main/resources/msg_cat.xml
    /vob/nm_acs/acs/mgmt/bl/framework/src/main/java/com/cisco/nm/acs/mgmt/bl/framework/validation/impl/TargetSyslogKeepAliveValidator.java
    /vob/nm_acs/acs/mgmt/bl/framework/src/main/java/com/cisco/nm/acs/mgmt/bl/framework/validation/impl/TargetSyslogBufferSizeValidator.java
    /vob/nm_acs/acs/mgmt/bl/framework/src/main/java/com/cisco/nm/acs/mgmt/bl/framework/validation/impl
    /vob/nm_acs/acs/mgmt/gui/app/src/main/webapp/pages/RemoteLogTargets/RemoteLogTargets_list.jsp
    /vob/nm_acs/acs/mgmt/gui/app/src/main/webapp/pages/RemoteLogTargets/RemoteLogTargets_js.js
    /vob/nm_acs/acs/mgmt/gui/app/src/main/webapp/pages/RemoteLogTargets/RemoteLogTargets_edit.jsp
    /vob/nm_acs/acs/mgmt/gui/app/src/main/java/com/cisco/nm/acs/mgmt/gui/app/forms/RemoteLogTargetsLPActionForm.java
    /vob/nm_acs/acs/mgmt/gui/app/src/main/resources/com/cisco/nm/acs/mgmt/gui/app/app_LogTargets.properties
    /vob/nm_acs/acs/mgmt/gui/app/src/main/java/com/cisco/nm/acs/mgmt/gui/app/entities/RemoteLogTargetsGUIEntity.java
    /vob/nm_acs/acs/mgmt/distributedmanagement/src/main/java/com/cisco/nm/acs/mgmt/distributedmanagement/ViewMgmt.java
    /vob/nm_acs/acs/mgmt/common/src/main/resources/com/cisco/nm/acs/mgmt/gui/app/app_Errors.properties
    /vob/nm_acs/acs/mgmt/bl/framework/src/main/resources/springConfig.xml
    /vob/nm_acs/acs/mgmt/bl/framework/src/main/java/com/cisco/nm/acs/mgmt/bl/framework/validation/impl/RangeValidator.java
    /vob/nm_acs/acs/mgmt/bl/framework/src/main/java/com/cisco/nm/acs/mgmt/bl/framework/validation/impl/DuplicateProtocolAndIpAndPortValidator.java
    /vob/nm_acs/acs/mgmt/bl/framework/src/main/java/com/cisco/nm/acs/mgmt/bl/framework/validation/ValidationMessage.java
    /vob/nm_acs/acs/mgmt/bl/framework/src/main/java/com/cisco/nm/acs/mgmt/bl/framework/validation/impl

view : adubrovs6__adubrovs.int.acs5_0.lx
activity: TCPSyslog@/vob/nmtgre_proj
==============================================================================


Yosi, please, review the next files:
==============================================================================
    /vob/nm_acs/acs/runtime/daemons/rt_daemon/src/SysStatsEventHandler.h
    /vob/nm_acs/acs/runtime/daemons/rt_daemon/src/SysStatsEventHandler.cpp
   /vob/nm_acs/acs/install/diskQuotas.cfg

view : adubrovs6__adubrovs.int.acs5_0.lx
activity: TCPSyslog@/vob/nmtgre_proj
==============================================================================

		1.6.2
2. Bugs

	2.1 For FC

		2.1.1 CSCua34208 ACS returns different username in access-accept than what client sent

		2.1.2
	2.2

3. Machines

	3.1  Virtual dev Machines

		3.1.1  pmbu-dev-vm22 
Created from kickstart: page http://kickstart.cisco.com

view console by connecting to pmbu-ise-dev-esx3 with vSphere. Credentials: pmbu-dev-vm22/default1A

IP:
ping pmbu-dev-vm22

Pinging pmbu-dev-vm22.cisco.com [10.56.52.12] with 32 bytes of data:

MAC: 00:50:56:a4:28:dd

Kickstart data:
- Give root max size 0 (max) and turn off grow

root, secret

VNC: pmbu-dev-vm22:1 Ermor02

			3.1.1.1   Install gcc
installed pkg:
[root@pmbu-dev-vm22 Downloads]# yum list gcc
Installed Packages
gcc.i386                                                       4.1.2-44.el5                                                        installed

Install older gcc - 
[root@pmbu-dev-vm22 Downloads]# yum install 'compat-gcc-34*'

- adjustment to make it apply:
$ ln -s /usr/bin/g++34  /usr/bin/g++
alias gcc='gcc34' ;

- Install boost

			3.1.1.2 Copy JNI headers to gcc
Error:
DBManager.h:19: error: `JNIEXPORT' does not name a type

Fix:
[yizaq@yizaq-lnx:Thu Feb 21:999:8:~]$ cp /usr/lib/gcc/i386-redhat-linux/3.4.3/include/jni.h ~/temp/
[yizaq@yizaq-lnx:Mon Feb 25:1000:9:~]$ locate 'libgcj-config.h'
/usr/lib/gcc/i386-redhat-linux/3.4.3/include/gcj/libgcj-config.h
[yizaq@yizaq-lnx:Mon Feb 25:1001:10:~]$ cp -r /usr/lib/gcc/i386-redhat-linux/3.4.3/include/gcj ~/temp

and
[root@pmbu-dev-vm22 vim73]# cp ~yizaq/temp/jni.h /usr/lib/gcc/i386-redhat-linux/3.4.6/include/jni.h
[root@pmbu-dev-vm22 vim73]#  cp -r ~yizaq/temp/gcj  /usr/lib/gcc/i386-redhat-linux/3.4.6/include/


			3.1.1.3 Python headers
error: 
[INFO] g++ -I/usr/include/python2.3 -I. -I../../../build/lnx26/include -I../../../prebuilt/lnx26/include -DDEBUG   -Wall -O2 -g -DOPENSSL_FIPS -MD -MT pyut.o -o Debug/pyut.o -c pyut.cpp
[INFO] pyut.cpp:8:20: Python.h: No such file or directory

Fix:
[root@yizaq-lnx vim73]# locate 'Python.h'
/usr/share/doc/swig-1.3.21/Manual/Python.html
/usr/include/python2.3/Python.h
[root@yizaq-lnx vim73]# tar cvf /tmp/python_2.3.tar /usr/include/python2.3/
[root@yizaq-lnx vim73]# scp /tmp/python_2.3.tar root@pmbu-dev-vm22:/tmp/python_2.3.tar
Warning: Permanently added 'pmbu-dev-vm22' (RSA) to the list of known hosts.
root@pmbu-dev-vm22's password: 
python_2.3.tar                                                                                                                                                  100%  390KB 390.0KB/s   00:00    

[root@pmbu-dev-vm22 include]# tar xvf python_2.3.tar

and:
[INFO] g++ -shared -Xlinker -rpath-link -Xlinker ../../../build/lnx26/lib -Xlinker -rpath-link -Xlinker ../../../prebuilt/lnx26/lib -oDebug/libpyut.so \
[INFO]             Debug/pyut.o Debug/pyobj.o Debug/pyutmodule.o   \
[INFO]      -L../../../build/lnx26/lib -L../../../prebuilt/lnx26/lib -lConfigManager -lCryptoLib -lUtility -lException -lpython2.3 -lpthread -lm -ldl
[INFO] /usr/bin/ld: cannot find -lpython2.3

Fix:
[root@yizaq-lnx vim73]# locate 'libpython2.3'
/usr/lib/python2.3/config/libpython2.3.a
/usr/lib/libpython2.3.so.1.0
/usr/lib/libpython2.3.so
[yizaq@yizaq-lnx:Mon Feb 25:1002:11:~]$  cp /usr/lib/libpython2.3* ~/temp/

$ cp ~/temp/libpython2.3* /tmp
[root@pmbu-dev-vm22 include]# cp /tmp/libpython2.3* /usr/lib/

			3.1.1.4 uuid
[INFO] SAMLAttributeQuery.cpp:14:23: uuid/uuid.h: No such file or directory
[root@yizaq-lnx vim73]# ls /usr/include/uuid/uuid.h
/usr/include/uuid/uuid.h
[root@yizaq-lnx vim73]# tar cvf /tmp/uuid.tar /usr/include/uuid/
tar: Removing leading `/' from member names
/usr/include/uuid/
/usr/include/uuid/uuid_types.h
/usr/include/uuid/uuid.h
/usr/include/uuid/uuid_types-i386.h
[root@yizaq-lnx vim73]# scp /tmp/uuid.tar root@pmbu-dev-vm22:/tmp/uuid.tar
root@pmbu-dev-vm22's password: secret 
uuid.tar     

[root@pmbu-dev-vm22 include]# cd /
[root@pmbu-dev-vm22 /]# tar xvf /tmp/uuid.tar 
usr/include/uuid/
usr/include/uuid/uuid_types.h
usr/include/uuid/uuid.h
usr/include/uuid/uuid_types-i386.h
[root@pmbu-dev-vm22 /]# ls /usr/include/uuid/uuid.h
/usr/include/uuid/uuid.h

and lib...
[INFO]             Debug/SOAPMessage.o Debug/GAMEXMLUtils.o Debug/GAMELogger.o Debug/GAMEException.o Debug/xmlstring.o Debug/SAMLAttributeQuery.o Debug/SAMLResponse.o Debug/GAMEResponse.o Debug/TrimString.o   \
[INFO]      -L../../../build/lnx26/lib -L../../../prebuilt/lnx26/lib -lxerces-c -luuid -lAcsDebugLog -llog4cxx -lUtility -lException -lpthread -lm -ldl
[INFO] /usr/bin/ld: cannot find -luuid
[INFO] collect2: ld returned 1 exit status

[root@yizaq-lnx vim73]# locate 'libuuid.so'
/usr/lib/libuuid.so
/lib/libuuid.so.1.2
/lib/libuuid.so.1
/opt/CSCOacs/runtime/lib/libuuid.so.1
/opt/CSCOacs/runtime/adagent/lib/libuuid.so.1.2
/opt/CSCOacs/runtime/adagent/lib/libuuid.so.1
[root@yizaq-lnx vim73]# ls -l /usr/lib/libuuid.so
lrwxrwxrwx  1 root root 17 Sep 26  2008 /usr/lib/libuuid.so -> /lib/libuuid.so.1
[root@yizaq-lnx vim73]# ls -l /usr/lib/libuuid.so*
lrwxrwxrwx  1 root root 17 Sep 26  2008 /usr/lib/libuuid.so -> /lib/libuuid.so.1

[root@yizaq-lnx vim73]# scp /lib/libuuid.so.1 root@pmbu-dev-vm22:/lib/libuuid.so.1
root@pmbu-dev-vm22's password: 
libuuid.so.1     

[root@pmbu-dev-vm22 /]# ln -s /lib/libuuid.so.1 /usr/lib/libuuid.so 
[root@pmbu-dev-vm22 /]# ls -l  /usr/lib/libuuid.so 
lrwxrwxrwx 1 root root 17 Feb 27 08:46 /usr/lib/libuuid.so -> /lib/libuuid.so.1


			3.1.1.5 Boost link errors
[INFO]          -L../../../build/lnx26/lib -L../../../prebuilt/lnx26/lib -lComposableWorkflow -lWorkflowEvents -lAAAClient -lService -lRuleEngine -lSessionCache -lMAR -lPAPAuthenticator -lCHAPAuthenticator -lMSCHAPAuthenticator -lEnableAuthenticator -lIdentityLookupAuthenticator -lAuthenticator -lCertificateAuthenticator -lIdentitySequenceWorkflow -lGroupMapping -lSessionAuthorization -lAuthorizeEvent -laacAuthorization -lHelpers -lIDStoreManager -lLDAPIDStore -lInternalIDStore -lActiveDirectoryIDStore -lRSAIDStore -lRadiusTokenIDStore -lSamlStore -lIDStore -lAdminAuthenFlow -lAdminPAPFlow -lConfigManager -lXmlConfig -lLogging -lFakeAcctStopFlow -lStatistics -lStatisticsFlow -lOCSPServerFlow -lNotificationCenter -lRadiusAuthenFlow -lRadiusEapFlow -lRadiusRequestFlow -lRadiusRequestEvent -lEapEvent -lRadiusServer -lRadiusClient -lRadiusCommon -lCommandSets -lShellProfile -lDeviceCommandAuthorization -lDeviceSessionAuthorization -lRadiusAccountingFlow -lRawPacketEvent -lTacacsPacketEvent -lGetPasswordPromptEvent -lTacacsAccounting -lTacacsAuthorization -lTacacsAuthenFlows -lTacacsProxyFlow -lTacacsFlow -ltacacs -lChangePasswordFlow -lPKIFlow -lPacServices -lInboundProtocols -lNetwork -lMessageBusEvent -lMBSendEvent -lMessageBusConnectedEvent -lMessageBusListener -lMessageBusFlow -lrtControl -lDynamicAuthorizationFlow -lDynamicAuthorizationEvent -lLoggingNotification -lCHAPEvent -lMSCHAPEvent -lPlainChangePasswordEvent -lUserFailedAttemptEvent -lPostureEvents -lgamev2 -lRawMessageBusEvent -lConfigNotification -lStateManager -lEventHandler2 -lDictionary3 -lException -lAAADebugLog -lAcsDebugLog -llog4cxx -lUtility -lMessageCatalog -leap -lCryptoService -lCryptoLib -lACE -lldap60 -lAcsDebugLogConfig -lcrypto -lssl -lxerces-c -lboost_regex -lactivemq-cpp-2.1.3 -luuid -llrpc -lcapi -lRadiusProxyFlow -lpthread -lm -ldl
[INFO] ../../../build/lnx26/lib/libRuleEngine.so: undefined reference to `boost::re_detail::raise_runtime_error(std::runtime_error const&)'
[INFO] ../../../build/lnx26/lib/libInternalIDStore.so: undefined reference to `boost::re_detail::perl_matcher<char const*, std::allocator<boost::sub_match<char const*> >, boost::regex_traits<char, boost::cpp_regex_traits<char> > >::construct_init(boost::basic_regex<char, boost::regex_traits<char, boost::cpp_regex_traits<char> > > const&, boost::regex_constants::_match_flags)'
[INFO] ../../../build/lnx26/lib/libRuleEngine.so: undefined reference to `boost::re_detail::perl_matcher<__gnu_cxx::__normal_iterator<char const*, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<boost::sub_match<__gnu_cxx::__normal_iterator<char const*, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >, boost::regex_traits<char, boost::cpp_regex_traits<char> > >::construct_init(boost::basic_regex<char, boost::regex_traits<char, boost::cpp_regex_traits<char> > > const&, boost::regex_constants::_match_flags)'
[INFO] ../../../build/lnx26/lib/libRuleEngine.so: undefined reference to `boost::re_detail::get_default_error_string(boost::regex_constants::error_type)'
[INFO] ../../../build/lnx26/lib/libRuleEngine.so: undefined reference to `boost::basic_regex<char, boost::regex_traits<char, boost::cpp_regex_traits<char> > >::do_assign(char const*, char const*, unsigned int)'
[INFO] ../../../build/lnx26/lib/libRuleEngine.so: undefined reference to `boost::re_detail::cpp_regex_traits_implementation<char>::transform(char const*, char const*) const'
[INFO] ../../../build/lnx26/lib/libRuleEngine.so: undefined reference to `boost::re_detail::cpp_regex_traits_implementation<char>::transform_primary(char const*, char const*) const'
[INFO] collect2: ld returned 1 exit status

missing right libboost_regex.so


			3.1.1.6
		3.1.2 Virtual test Machines

			3.1.2.1 vinson1, 10.56.14.235, 5.5 FCS
ESX ad-esx-3.cisco.com 10.56.14.29
root/dev100%


admin/Acs5.5
root/Acs5.5
acsadmin/1234


			3.1.2.2 ISE 10.56.14.80   
vsphere: 10.56.14.131; user: pmbu-dev-vm03 (default1A)

admin/default1A
root/a

			3.1.2.3 ESX license for our team
VMware vSphere Hypervisor 5 License 	40087-62284-N8440-0220M-AWT55

			3.1.2.4 AcsFarm VMWARE FARM: SNSBU-C220-C21 NEW CIMC: https://10.56.54.92 
root/admin

ESX: acsfarm (now "snsbu-c220-021")	10.56.53.29
VM: cow1.cisco.com 10.56.53.30
VM: cow2.cisco.com 10.56. 53.31
VM: cow3.cisco.com 10.56.53.32
VM: cow4.cisco.com 10.56.53.33 

old IPs:
HostName	IP Address
AcsFarm	10.56.24.15 , root , cisco123
			yizaq, Gravebone
cow1	10.56.24.16 , root , cisco123 - ISE dev
cow2	10.56.24.17, root , Ise1.2 - ISE test root, Ise1_2
cow3	10.56.24.18, root , Acs5.4 - ACS 5.4 test
cow4	10.56.24.19, root , Ise1.2 - ISE test

		3.1.3 Sustaining
acs-sus-e7e 10.56.24.231, acs-sus-e7f 10.56.24.232



		3.1.4 Support for machines - http://toolbox.cisco.com/cases/new
		old link http://nmtg-vm1.cisco.com/CFApps/LabRAT2/main-noheader.cfm

			3.1.4.1 email
OK ,you have an addresses ,

HostName	IP Address
AcsFarm	10.56.24.15
cow1	10.56.24.16
cow2	10.56.24.17
cow3	10.56.24.18
cow4	10.56.24.19

And about your second case of the UCS’s fan ,I’ve opened the UCS and saw that the fan is now working properly ,and I’ve opened a case at Cisco TAC to see how can we replace the fan to a new one .
Right now ,the UCS is working with 4 fans ,and I saw on CIMC that the temperature is “Good” .
I’ll let you know on any step .
About the IPs ,please let me know if everything is fine ,
Ron B


 
Baduach Ron
Lab Staff

rbaduach@cisco.com 
Phone: 972-9-8927004	32 Hamelacha St.
South Netanya
Israel, 42504	 


		

From: Yosi Izaq (yizaq) 
Sent: Tuesday, November 27, 2012 11:15 AM
To: Ron Baduach -X (rbaduach - SQLink at Cisco)
Subject: RE: Allocate IPs

Thx 

SAMPG, formerly PMBU, formerly NMTG.

From: Ron Baduach -X (rbaduach - SQLink at Cisco) 
Sent: Tuesday, November 27, 2012 11:11 AM
To: Yosi Izaq (yizaq)
Subject: RE: Allocate IPs

Nice Hostnames :]
About the Vlan ,are you PMBU or NMTG ?


 
Baduach Ron
Lab Staff

rbaduach@cisco.com 
Phone: 972-9-8927004	32 Hamelacha St.
South Netanya
Israel, 42504	 



		


From: Yosi Izaq (yizaq) 
Sent: Tuesday, November 27, 2012 11:08 AM
To: Ron Baduach -X (rbaduach - SQLink at Cisco)
Subject: RE: Allocate IPs

Hi Ron,

Which VLANs are available?

Host: AcsFarm
Guest1: cow1
Guest2: cow2
Guest3: cow3
Guest4: cow4

Thx,
Yosi
From: Ron Baduach -X (rbaduach - SQLink at Cisco) 
Sent: Tuesday, November 27, 2012 9:39 AM
To: Yosi Izaq (yizaq)
Subject: Allocate IPs

Hi Yosi ,
You’ve opened a case about 
“I would like to request an IP for the VMWare host
(ESX) I plan to install on this UCS.

In addition I will need 4 more IP addresses for
VMWare guests on the same subnet as the VMWare
host IP. “

please let me know on which Vlan you want those addresses ,and give me hostnames of the ESX and the 4 VM guests ,that I would enter it to the DNS .

Thanks 


 
Baduach Ron
Lab Staff

rbaduach@cisco.com 
Phone: 972-9-8927004	32 Hamelacha St.
South Netanya
Israel, 42504	 



		



			3.1.4.2


		3.1.5
	3.2

4. FAQS

	4.1 ActiveDirectory

		4.1.1 Centrify joined but can't connect, adinfo shows Not found in DNS!Make sure it is in Reverse Lookup Zone.
  FQDN host name:acs-sus-e7e (domain missing?)

Fix, 
[root@acs-sus-e7e bin]# cat /etc/hosts
# Do not remove the following line, or various programs
# that require network functionality will fail.
127.0.0.1               localhost.localdomain localhost
::1             localhost6.localdomain6 localhost6
10.56.24.231  acs-sus-e7e

FQDN is mandatory, so:
[root@acs-sus-e7e bin]# cat /etc/hosts
# Do not remove the following line, or various programs
# that require network functionality will fail.
127.0.0.1               localhost.localdomain localhost
::1             localhost6.localdomain6 localhost6
10.56.24.231  acs-sus-e7e.sustain.com acs-sus-e7e
10.56.24.231            acs-sus-e7e #ACS5 Host

[root@acs-sus-e7e bin]# service nscd restart
Stopping nscd:                                             [  OK  ]
Starting nscd:                                             [  OK  ]

restart ACS
		4.1.2


	4.2 authentication

		4.2.1 Zero touch, zt

			4.2.1.1  Kill current run
SSH to zt machine for example BATS (zt-acs51-bats  root/cisco123) –


[root@cd-acs5-TEdrv02 ~]# ps -aux | grep java                                                                                                                                    
Warning: bad syntax, perhaps a bogus '-'? See /usr/share/doc/procps-3.2.3/FAQ
root     15305  0.7  4.6 198588 96568 ?      Sl   17:00   1:31 /usr/java/jdk1.6.0_07/jre/bin/java -Xbootclasspath:/usr/java/jdk1.6.0_07/jre/lib/resources.jar:/usr/java/jdk1.6.0_07/jre/lib/rt.jar:/usr/java/jdk1.6.0_07/jre/lib/sunrsasign.jar:/usr/java/jdk1.6.0_07/jre/lib/jsse.jar:/usr/java/jdk1.6.0_07/jre/lib/jce.jar:/usr/java/jdk1.6.0_07/jre/lib/charsets.jar:/usr/java/jdk1.6.0_07/jre/classes -cp .:..:../acs50automation.jar:acs50automation.jar:../lib/nastools.jar:lib/nastools.jar:../lib/naslib.jar:lib/naslib.jar:/usr/java/latest/db/lib/derby.jar:/usr/java/latest/db/lib/derbynet.jar:/usr/java/latest/db/lib/derbyrun.jar:/usr/java/latest/db/lib/derbytools.jar:/usr/java/latest/db/lib/:/usr/java/latest/db/lib/derbyclient.jar:JAVA_CP: com.cisco.nas.ams.DatabaseControl
root     15322  0.0  1.3 193440 27124 ?      Sl   17:00   0:03 /usr/java/jdk1.6.0_07/jre/bin/java -Xbootclasspath:/usr/java/jdk1.6.0_07/jre/lib/resources.jar:/usr/java/jdk1.6.0_07/jre/lib/rt.jar:/usr/java/jdk1.6.0_07/jre/lib/sunrsasign.jar:/usr/java/jdk1.6.0_07/jre/lib/jsse.jar:/usr/java/jdk1.6.0_07/jre/lib/jce.jar:/usr/java/jdk1.6.0_07/jre/lib/charsets.jar:/usr/java/jdk1.6.0_07/jre/classes -cp .:..:../acs50automation.jar:acs50automation.jar:../lib/nastools.jar:lib/nastools.jar:../lib/naslib.jar:lib/naslib.jar:/usr/java/latest/db/lib/derby.jar:/usr/java/latest/db/lib/derbynet.jar:/usr/java/latest/db/lib/derbyrun.jar:/usr/java/latest/db/lib/derbytools.jar:/usr/java/latest/db/lib/:/usr/java/latest/db/lib/derbyclient.jar:JAVA_CP: com.cisco.nas.ams.WebServerControl
root     15339  6.3  9.5 1196412 198692 ?    Sl   17:00  13:10 java -Xms64m -Xmx1024m -ea -cp lib/businessdelegate-5.0.jar:lib/dbms-5.0.jar:lib/dbpurge-5.0.jar:lib/jobmanager-5.0.jar:lib/proactive-common-5.0.jar:.:acs50automation.jar:lib/nastools.jar:lib/naslib.jar:lib/acsclient.jar:/usr/java/latest/db/lib/derby.jar:/usr/java/latest/db/lib/derbynet.jar:/usr/java/latest/db/lib/derbyrun.jar:/usr/java/latest/db/lib/derbytools.jar:/usr/java/latest/db/lib/:/usr/java/latest/db/lib/derbyclient.jar:/usr/java/latest/jre/lib/rt.jar:/usr/java/latest/jre/lib/resources.jar:/usr/java/latest/jre/lib/javaws.jar:/usr/java/latest/jre/lib/deploy.jar:/usr/java/latest/jre/lib/charsets.jar:/lib/tools.jar: com.cisco.acs5.test.deploy.Main re zerotouch_51_bats.xml
root     32145  0.0  0.0  5112  648 pts/2    S+   20:27   0:00 grep java
[root@cd-acs5-TEdrv02 ~]#

Then kill the process that run  zerotouch_51_bats.xml -

[root@cd-acs5-TEdrv02 ~]# kill -9 15339

Same process to other machines.

zt-acs51-bats     10.56.62.31
zt-acs51-bd         10.56.62.52
zt-acs51-full        10.56.61.252
zt-isr-ad               10.56.61.251


I killed all the running.h

[yizaq@yizaq-WS:Fri Dec 21:/cygdrive/c/Documents and Settings/yizaq/Desktop:]$ ssh root@zt-acs51-bats ps -aux | grep java | grep zerotouch_51 | awk '{print $2}'
11192
[yizaq@yizaq-WS:Fri Dec 21:/cygdrive/c/Documents and Settings/yizaq/Desktop:]$ ssh root@zt-acs51-bats kill 11192


ssh root@zt-isr-ad ps -aux | grep java | grep zerotouch_51_bats.xml | awk '{print $2}'
			4.2.1.2

		4.2.2


	4.3 Patches


		4.3.1 where’s filesToReplace of the patch on the machine?
In installation directory on the machine, e.g.: /opt/CSCOacs/patches/5.4.0.46.2/

	4.4 Protocols

		4.4.1 RADIUS

			4.4.1.1 DTLS support for Radius 
No ACS versions supports Radius over DTLS.

			4.4.1.2 configuration steps in ACS to restrict the users based on the received calling-station-id(radius)/remote-host-address(tacacs
In ACS 5.x, The End station filters in Authorization profiles is the right candidate for you. Kindly check it. Just configure this policy element, and make use of it in your Access Policy.

<Snippet from user guide>

End Station Filter—Filters end stations, such as a laptop or printer that initiates a connection based on the end station's IP address, MAC address, CLID number, or DNIS number.

The end station identifier can be the IP address, MAC address, or any other string that uniquely identifies the end station. It is a protocol-agnostic attribute of type string that contains a copy of the end station identifier:

•	In a RADIUS request, this identifier is available in Attribute 31 (Calling-Station-Id).
•	In a TACACS request, ACS obtains this identifier from the remote address field of the start request (of every phase). It takes the remote address value before the slash (/) separator, if it is present; otherwise, it takes the entire remote address value.

The end station IPv4 is an IPv4 version of the end station identifier. The end station MAC is a normalized MAC address of the end station identifier.

			4.4.1.3
		4.4.2

	4.5 Cryptography. PKI

		4.5.1 What certificate fields are made available for authorization policy
- Obtain list, login to ACS, Policy Elements >	Session Conditions >	Custom >	Create 
choose Certificate Dictionary,

	Common Name 	
	Country 	
	Email 	
	Issuer 	
	LocationSubject 	
	Organization 	
	Organization Unit 	
	State or Province 	
	Subject 	
	Subject Alternative Name 	
	Subject Alternative Name - DNS 	
	Subject Alternative Name - EMail 	
	Subject Alternative Name - Other Name 	
	Subject Serial Number 	
	
		4.5.2

	4.6
5. Guides

	5.1  GUI

		5.1.1   Add checkbox

			5.1.1.1    Entry point - page
Hover over "drawer" (right hand side menu) - check url in buttom
note action, ex: ExternalDBsLPAction.do

Search in Eclipse (ctrl+shft+r), ExternalDBsLPActionForm.jsp

			5.1.1.2 Labels (.properties)
Search in Eclipse (ctrl+shft+r) for GUI element name, say: "Root CA".
found in: 
mgmt/gui/app/src/main/resources/com/cisco/nm/acs/mgmt/gui/app/app_identityelements.properties

add:
acs.gui.app.external_DBs.label_check_server_identity = Check Server Identity

anchor (similar GUI widget):
acs.gui.app.external_DBs.label_trusted_root_ca = Root CA



			5.1.1.3 GUI - jsp
mgmt/gui/app/src/main/webapp/pages/ExternalDBs/ExternalDBs_step2.jsp

Add:
				<tr>
					<td colspan="2">
						<table border="0"><tr><td>
							<cues:requiredfield required="false"/>
								<html:checkbox
								property="primaryCheckServerIdentity"
								/>
						</td><td>
							<bean:message bundle="<%=AppConstants.APP_ID_ELEM_PROPERTIES_KEY%>"
								key="acs.gui.app.external_DBs.label_check_server_identity" />
						</td></tr></table>
					</td>
				</tr>

				"

			5.1.1.4

		5.1.2

	5.2

6. PKI

	6.1 Certificate generators 

		6.1.1 CertGen
http://zt-isr-rep/repository/Uploads/Nisim/CertificateGen/CertGen-Latest.jar
"c:\work\acs\test tools\CertGen-Latest.jar" 

			6.1.1.1  Usage example, make certificates for LDAP Server

				6.1.1.1.1  root CA

- name ACS_CAforLDAP
( - issuer CN=ACS_CAforLDAP)
- subject - 
CN=ACS_CAforLDAP,C=IL,ST=State,L=Natania,O=Cisco,OU=ACS
- SAN:
DNS::acs-ldap01.acs.com
- Signature Algorithm: sha1WithRSAEncryption
- Key pair method - RSA 2048

				6.1.1.1.2  policy CA

- name ACS_PolicyCAforLDAP
( - issuer ACS_CAforLDAP )
- subject - 
CN=ACS_PolicyCAforLDAP,C=IL,ST=State,L=Natania,O=Cisco,OU=ACS
- SAN:
DNS::acs-policy-ldap01.acs.com;IP::1.2.3.5
- Signature Algorithm: sha1WithRSAEncryption
- Key pair method - RSA 2048



				6.1.1.1.3  issuing CA

- name ACS_IssuingCAforLDAP
( - issuer ACS_PolicyCAforLDAP)
- subject - 
CN=ACS_IssuingCAforLDAP,C=IL,ST=State,L=Natania,O=Cisco,OU=ACS
- SAN:
DNS::acs-issuing-ldap01.acs.com;IP::1.2.3.6
- Signature Algorithm: sha1WithRSAEncryption
- Key pair method - RSA 2048



				6.1.1.1.4  Server certificate

- name ACS_LDAP_Server
( - issuer ACS_IssuingCAforLDAP)
- subject - 
CN=ACS_LDAP_Server,C=IL,ST=State,L=Natania,O=Cisco,OU=ACS
- SAN:
DNS::acsldap01.acs.com;IP::1.2.3.7
- Signature Algorithm: sha1WithRSAEncryption
- Key pair method - RSA 2048

Real LDAP address:
DNS::acs-issuing-ldap01.acs.com;IP::10.56.62.173

positive DNS FQDN:
DNS::cd-acs-ldap01.north.auto.acs.com;IP::10.56.62.1

negative DNS FQDN:
DNS::unknown-ldap01.north.auto.acs.com;IP::10.56.62.1

positive wildcard DNS FQDN:
DNS::*.north.auto.acs.com;IP::10.56.62.1

negative wildcard DNS FQDN:
DNS::*.hacker.com;IP::10.56.62.1
				6.1.1.1.5 Bundle certs for Michael's LDAP server

<URL:/cygdrive/c/work/KB/Network/sslKB#r=__bundle_certs__>

				6.1.1.1.6
			6.1.1.2

		6.1.2 CryptoLib

			6.1.2.1  Error translation in CryptoLib

Ex:
Crypto,18/03/2013,17:16:59:827,WARN ,3044952976,NIL-CONTEXT,Crypto::Result=1, Crypto.SSLConnection.pvClientInfoCB - Alert raised: code=0x230=560, where=0x4008=16392, source=local,SSLConnection.cpp:2724
Crypto,18/03/2013,17:16:59:827,WARN ,3044952976,NIL-CONTEXT,Crypto::Result=102, Crypto.SSLConnection.writeData - failed write the data,SSLConnection.cpp:934
Connection,18/03/2013,17:16:59:827,ERROR,3044952976,LdapSslConnectionContext::checkCryptoResult(id = 512): crypto result = 102,LdapSslConnectionContext.cpp:206
Connection,18/03/2013,17:16:59:827,ERROR,3044952976,LdapSslConnectionContext::checkCryptoResult(id = 512): error message = SSL alert: code=0x230=560 ; source=local ; type=fatal ; message="Unknown CA - Unable to get CRL",LdapSslConnectionContext.cpp:215

View report:
Cisco-AVPairs:
	
 
Other Attributes:
	
ACSVersion=acs-5.5.0.6-B.447 
ConfigVersionId=3 
Device Port=62928 
RadiusPacketType=AccessRequest 
Protocol=Radius 
Called-Station-ID=11 
DetailedInfo=SSL alert
code=0x230=560 ; source=local ; type=fatal ; message="Unknown CA - Unable to get CRL" 
Device IP Address=64.103.126.90
Steps
11001  Received RADIUS Access-Request
11017  RADIUS created a new session
Evaluating Service Selection Policy
15004  Matched rule
15012  Selected Access Service - Default Network Access
Evaluating Identity Policy
15006  Matched Default Rule
15013  Selected Identity Store - SecLdap
24031  Sending request to primary LDAP server
24015  Authenticating user against LDAP Server
24030  SSL connection error was encountered
22059  The advanced option that is configured for process failure is used.
22062  The 'Drop' advanced option is configured in case of a failed authentication request.

- code:
define alerts:
runtime/prebuilt/lnx26/include/openssl/x509_vfy.h

Trigger alert:
runtime/infrastructure/cryptoLib/src/SSL.cpp:CSSL::x509ExceptionCallback(INOUT int& nOK, IN X509_STORE_CTX* pX509StoreCtx) 

Parse alert:
runtime/infrastructure/cryptoLib/src/SSLConnection.cpp:SSLConnection::getLastSSLErrorMessage()
...
        if ( nAlertEvent==SSL_AD_UNKNOWN_CA )
        {
            if ( m_pSSL->verify_result==X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT)
                pAlertDesc= "Unknown CA - Unable to get Issuer Certificate" ;
            else if ( m_pSSL->verify_result==X509_V_ERR_UNABLE_TO_GET_CRL)
                pAlertDesc= "Unknown CA - Unable to get CRL" ;
            else if ( m_pSSL->verify_result==X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER)
                pAlertDesc= "Unknown CA - Unable to get CRL Issuer" ;
            else if ( m_pSSL->verify_result==X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT)
                pAlertDesc= "Unknown CA - error depth zero self-signed certificate" ;
            else if ( m_pSSL->verify_result==X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN)
                pAlertDesc= "Unknown CA - error self-signed certificate in chain" ;
            else if ( m_pSSL->verify_result==X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)
                pAlertDesc= "Unknown CA - error unable to get issuer certificate locally" ;
            else if ( m_pSSL->verify_result==X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE)
                pAlertDesc= "Unknown CA - error unable to verify leaf signature" ;
            else if ( m_pSSL->verify_result==X509_V_ERR_CERT_CHAIN_TOO_LONG)
                pAlertDesc= "Unknown CA - error certificate chain too long" ;
            else if ( m_pSSL->verify_result==X509_V_ERR_PATH_LENGTH_EXCEEDED)
                pAlertDesc= "Unknown CA - error path length exceeded" ;
            else if ( m_pSSL->verify_result==X509_V_ERR_INVALID_CA)
                pAlertDesc= "Unknown CA - error invalid CA" ;
        }
        else if ( nAlertEvent==SSL_AD_BAD_CERTIFICATE )
        {
            if ( m_pSSL->verify_result==X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE)
                pAlertDesc= "X509 bad certificate - error unable to decrypt certificate signature" ;
            else if ( m_pSSL->verify_result==X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE)
                pAlertDesc= "X509 bad certificate - error unable to decrypt_crl_ CRL signature" ;
            else if ( m_pSSL->verify_result==X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY)
                pAlertDesc= "X509 bad certificate - error unable to decode issuer public key" ;
            else if ( m_pSSL->verify_result==X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD)
                pAlertDesc= "X509 bad certificate - error in certificate not before field" ;
            else if ( m_pSSL->verify_result==X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD)
                pAlertDesc= "X509 bad certificate - error in certificate not after field" ;
            else if ( m_pSSL->verify_result==X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD)
                pAlertDesc= "X509 bad certificate - error in CRL last update field" ;
            else if ( m_pSSL->verify_result==X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD)
                pAlertDesc= "X509 bad certificate - error in CRL next update field" ;
            else if ( m_pSSL->verify_result==X509_V_ERR_CERT_NOT_YET_VALID)
                pAlertDesc= "X509 bad certificate - error certificate not yet valid" ;
            else if ( m_pSSL->verify_result==X509_V_ERR_CRL_NOT_YET_VALID)
                pAlertDesc= "X509 bad certificate - error CRL not yet valid" ;
            else if ( m_pSSL->verify_result==X509_V_ERR_CERT_UNTRUSTED)
                pAlertDesc= "X509 bad certificate - error certificate untrusted" ;
            else if ( m_pSSL->verify_result==X509_V_ERR_CERT_REJECTED)
                pAlertDesc= "X509 bad certificate - error certificate rejected" ;
        }
        else if ( nAlertEvent==SSL_AD_DECRYPT_ERROR )
        {
            if ( m_pSSL->verify_result==X509_V_ERR_CERT_SIGNATURE_FAILURE)
                pAlertDesc= "X509 decrypt error - certificate signature failure" ;
            else if ( m_pSSL->verify_result==X509_V_ERR_CRL_SIGNATURE_FAILURE)
                pAlertDesc= "X509 decrypt error - CRL signature failure" ;
        }
        else if ( nAlertEvent==SSL_AD_CERTIFICATE_EXPIRED )
        {
            if ( m_pSSL->verify_result==X509_V_ERR_CERT_HAS_EXPIRED)
                pAlertDesc= "X509 certificate expired" ;
            else if ( m_pSSL->verify_result==X509_V_ERR_CRL_HAS_EXPIRED)
                pAlertDesc= "X509 CRL expired" ;
        }
        else if (nAlertEvent == SSL_AD_CERTIFICATE_UNKNOWN)
        {
            if (m_pSSL->verify_result == X509_V_ERR_PERMITTED_VIOLATION)
                pAlertDesc = "X509 certificate unknown - name constraints permitted subtree violation";
            else if (m_pSSL->verify_result == X509_V_ERR_EXCLUDED_VIOLATION)
                pAlertDesc = "X509 certificate unknown - name constraints excluded subtree violation";
            else if (m_pSSL->verify_result == X509_V_ERR_SUBTREE_MINMAX)
                pAlertDesc = "X509 certificate unknown - min or max name constraints values present and matching type";
            else if (m_pSSL->verify_result == X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE)
                pAlertDesc = "X509 certificate unknown - unsupported constraint type";
            else if (m_pSSL->verify_result == X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX)
                pAlertDesc = "X509 certificate unknown - bad or unsupported constraint syntax";
            else if (m_pSSL->verify_result == X509_V_ERR_UNSUPPORTED_NAME_SYNTAX) 
                pAlertDesc = "X509 certificate unknown - bad or unsupported syntax of name";
        }

        snprintf(m_ErrorMessage, sizeof(m_ErrorMessage), 
                 "SSL alert: code=0x%X=%d ; source=%s ; type=%s ; message=\"%s\"",
                 m_AlertCode, m_AlertCode,
                 (m_AlertDirection==ALERT_DIR_NONE)?"unknown":((m_AlertDirection==ALERT_DIR_READ)?"remote":"local"), 
                 pAlertTypeDesc, 
                 pAlertDesc);
    }
    else
    {
        char opensslErrorMsg[MAX_ERROR_MESSAGE_LEN] ;

        (void)ERR_error_string(SSL_get_error(m_pSSL, m_AlertCode), opensslErrorMsg);

        snprintf(m_ErrorMessage, sizeof(m_ErrorMessage), 
                 "SSL alert: code=0x%X=%d ; source=%s ; message=\"%s\"",
                 m_AlertCode, m_AlertCode,
                 (m_AlertDirection==ALERT_DIR_NONE)?"unknown":((m_AlertDirection==ALERT_DIR_READ)?"remote":"local"), 
                 opensslErrorMsg);
    }


- Set alert
can use X509_STORE_CTX_set_error to set the SSL error in callback 12:40 PM 
example:  12:40 PM 
err = X509_V_ERR_CERT_CHAIN_TOO_LONG;
X509_STORE_CTX_set_error(ctx, err);
 

- add new alert:
requires change to SSL lib itself. For ACS it's not accepted practice

-
			6.1.2.2

		6.1.3
	6.2

7. Setups

	7.1 ActiveDirectory

		7.1.1 2012
c:\work\acs\setups\Cisco-2012-Env.xlsx 
Servername	Domain	Domain FQDN	Forest	IP Address	Site	Operatin system	Role
R1DC01	R1	R1.dom	R1.dom	10.56.53.76	Site1	Windows 2012	DC,Sub CA,NTP
C1DC01	C1	C1.R1.dom	R1.dom	10.56.53.77	Site1	Windows 2012	DC,Root CA
C2DC02	C2	C2.C1.R1.dom	R1.dom	10.56.53.78	Site1	Windows 2012	DC,Issuer CA, OCSP, SCEP
R2DC01	R2	R2.dom	R2.dom	10.56.53.79	Site1	Windows 2012	DC,DNS
R2DC02	R2	R2.dom	R2.dom	10.56.53.80	Site1	Windows 2012	DC,DNS
C3DC01	C3	C3.R2.dom	R2.dom	10.56.53.81	Site1	Windows 2012	DC
R3DC01	R3	R3.dom	R3.dom	10.56.53.82	Site1	Windows 2012	DC
C4DC01	C4	C4.R3.dom	R3.dom	10.56.53.83	Site1	Windows 2008 R2	DC
C5DC01	C5	C5.C4.R3.dom	R3.dom	10.56.53.84	Site1	Windows 2012	DC
C6DC01	C6	C6.C5.C4.R3.dom	R3.dom	10.56.53.85	Site1	Windows 2008 R2	DC
R4DC01	R4	R4.dom	R4.dom	10.56.53.86	Site1	Windows 2012	DC
R4DC02	R4	R4.dom	R4.dom	10.56.53.87	Site1	Windows 2012	DC
R4DC03	R4	R4.dom	R4.dom	10.56.53.88	Site1	Windows 2012	DC
R4DC04	R4	R4.dom	R4.dom	10.56.53.89	Site1	Windows 2012	DC
R4DC05	R4	R4.dom	R4.dom	10.56.63.100	Site2	Windows 2012	RODC
C7DC01	C7	C7.R4.dom	R4.dom	10.56.53.91	Site1	Windows 2012	DC
C7DC02	C7	C7.R4.dom	R4.dom	10.56.53.92	Site1	Windows 2012	DC
C7DC03	C7	C7.R4.dom	R4.dom	10.56.63.101	Site2	Windows 2008 R2	DC
C7DC04	C7	C7.R4.dom	R4.dom	10.56.63.102	Site2	Windows 2008 R2	DC
R5DC01	R5	R5.dom	R5.dom	10.56.53.95	Site1	Windows 2012	DC,Root CA, OCSP, SCEP
R5DC02	R5	R5.dom	R5.dom	10.56.53.96	Site1	Windows 2012	DC
R5DC03	R5	R5.dom	R5.dom	10.56.53.97	Site1	Windows 2012	DC
R5DC04	R5	R5.dom	R5.dom	10.56.53.98	Site1	Windows 2012	DC
R5DC05	R5	R5.dom	R5.dom	10.56.63.103	Site2	Windows 2012	RODC
							
							
		NTP Server for the environment : R1DC01 (10.56.53.76)					
		DNS Server for the environment: 10.56.53.79, 10.56.53.80					
		User name: ACSAdmin, Password:acS100%					

		7.1.2

	7.2

8. Build

	8.1 Hudson 


		8.1.1  Patches
https://acs-build1-lnx:9081/job/patch_test

			8.1.1.1  5.4 patch config

PROP_BUILD_NUMBER - 221
PATCH_VERSION - 3 
			8.1.1.2

		8.1.2

	8.2


9. Infrastructure

id=__ACS_RT_Thread_Model__
	9.1 Threading model
Another fundamental design pattern that governs the architecture of the server framework is the 'Worker Thread' or 'Unit-of-Work' threading model. Threads are one of the critical system resources that the server needs to manage in order to achieve high performance and scalability. There are several ways to try and achieve thread availability. One is to have a high number of threads - possibly creating and destroying them as needed - and to assign each request to a specific thread for the lifetime of the request. While this is a nice simple model, it has a high cost. First, creating threads is an expensive operation. Second, when the number of threads increases the cost of the OS switching between those threads becomes a significant percentage of the available CPU. The alternative chosen instead has a queue of 'work units' that are ready to be worked on and a queue of threads that are ready to do work. The next available thread grabs the next available work unit and processes it until the work unit is completed or until the thread would block waiting on some resource the work unit needs. The work unit is then parked while it waits for the resource to become available. The thread goes back to the queue waiting for the next work unit to be ready. When the resource becomes available, the parked work unit is put back on the queue until a thread is available.
Previous versions of ACS used a thread-per-request threading model. In a thread-per-request model, the content and state of the request are carried in the allocated thread. The request data may be in structures or in individual variables, but they are bound to references in the current thread. Usually when calls are made to functions to do work on behalf of the request, those calls only include those pieces of the request that are considered pertinent for the call. If a call is made that needs to wait for a response from an external resource, the current thread is blocked until the response comes back. The thread is blocked, unable to do anything else.
A unit-of-work threading model is different. All of the content and state associated with a request is in (or reachable from) a 'request context' (or just context for short). That context represents the request and is typically passed from component to component as the request is processed. Each component reads what it needs from the context and in turn updates the context with the outcome of its part of the processing. At the end of the processing, the context is used to create the response packet that is sent back to the client that initiated the request.
Since all of the content and state is carried by the context, and not the current thread, it allows for the request to be processed by different threads during the course of processing the request. That is, if it becomes necessary to hand off processing the request from one thread to another, this is easily done. This is very useful when the current thread would otherwise block (e.g., while waiting for I/O to finish, or for a response to come back from an external server). The current thread can go do useful work on another request rather than blocking. Note that it is absolutely required that only one thread at a time operates on a context. This requirement allows us to do no locking on a context when accessing or updating its contents. See Section 3.6 Management of State Between Requests for a discussion of the need to acquire locks for some objects before adding them to the Context, but once added accessing and updating those objects do not require additional locks while processing the request.
In the next section we will discuss Events, which are the unit-of-work and EventHandlers, the basic mechanism provided to support the unit-of-work threading model.

-	Events and Event handlers
Events are the 'unit-of-work', the object that is acted upon by the worker threads. Events contain a reference to the Context, the container for all of the data associated with the current request. While Events may be created at different points in the processing (there might first be a RawPacketEvent, followed by a RadiusRequestEvent, etc), the Context will remain the same for each Event. Events also keep track of which EventHandlers want to be called back when the EventHandlers they called are finished processing the Event. Because of this, when a new Event is created it should contain a reference to the originating Event. Thus the constructor for a RadiusRequestEvent will pass a reference to the RawPacketEvent. This is so that when the EventHandlers have finished processing the RadiusRequestEvent, the EventHandlers waiting for notification that the RawPacketEvent has been finished as well will be called back at the appropriate time. When the last EventHandler that indicated that it should be called back for the request indicates that it is finished with the Event (which will actually be the first EventHandler to register since this is a first-in last-out stack of callbacks), the Event (and the  Context it references) are deleted.
EventHandlers are designed to make it simple to develop components that implement the unit-of-work threading model. The implementor of a component based on the EventHandler base class doesn't need to be concerned with thread pools nor with allocating threads to work units. The designer of an EventHandler-based component can focus on the functionality it provides. In particular, the designer needs to define the types of Events that it is prepared to receive and the set of processing steps that it will perform for each of those Events. The caller of an EventHandler also has a similarly simple abstraction. The caller will invoke the EventHandler by sending an Event of an appropriate type to the EventHandler (the Event contains a pointer to the Context representing the unit-of-work). The caller typically doesn't know whether the Event will be processed on the current thread or not. It can't expect or depend on the processing of the Event being completed by the time the invocation returns. The Event may have been queued on a thread pool and the current thread may return immediately. Because of this, the caller can't touch the Event nor the Context referenced by the Event after the invocation returns. Typically the EventHandler will just return to its caller since it can't make any further progress on the task it was involved in. Either it needs to wait until the EventHandler it called has finished processing the Event that was just sent or it is done with its own task. When it returns to its caller, it returns an indication of whether it is finished processing the Event or not. If the caller is interested in getting notified when the called EventHandler is done processing the event, it passes in a pointer to the method that should be called to indicate that. That method will receive the original Event as its argument. It is assumed that the Context has been updated as a side effect of the EventHandler processing the Event.

-	Attribute Assertions
A negative consequence of having all of the data in the Context and passing it between EventHandlers in Events is the fact that we can't ask the compiler to help us detect whether the caller of a particular component has passed in all of the information that the component needs. So instead we will provide support for run-time validation that the incoming context contained all of the attributes required by a component. The validation rules will be defined in a table and the method can ask the context to validate itself against that table. The validation rules are defined in a table of structures like this:
ContextValidationTable myValidationTable[] =
{
    { Context::Request, Radius::UserName, ValidationTable::Exists, 0 },
    { Context::Request, Radius::UserName, ValidationTable::NotEqual, "" },
    { Context::Request, Radius::EAPMessage, ValidationTable::Exists, 0  }
};

size_t nmyValidationTable = sizeof( myValidationTable ) / sizeof( ValidationTable );
Each row of the table contains a tuple consisting of {attribute set, attribute, operator, value}. At the entrance to the method, the context can be validated:
pEvent->validateContext( myValidationTable, nmyValidationTable );
or
Context* pContext = pEvent->getContext();
pContext->validate( myValidationTable, nmyValidationTable );
When a condition fails to match, an InvalidArgumentException is thrown. If the validation is done in an event handler method, the exception is caught by the EventHandler base class and the message is logged to the debug log and the error code is placed on the context in Acs::LastError before the event is returned to the invoker.
-	Flow Branching Points
From the moment a request is received the application flow follows a number of branches, each depending on received protocol attributes and internal configuration. For instance, for a RADIUS request the first question we need to ask is whether it is a request or is it a response to a proxy request ACS previously forwarded. After this, we ask whether it is an accounting request or an authentication request. Essentially, a path along these branches is chosen until some sort of "leaf node" is reached. In order to support these decisions in a modular manner the EventHandler will support two methods:
static bool shouldInvoke( EventHandler::Key_t key, Event* pEvent );
static bool selectAndInvoke( EventHandler::Key_t ppEventHandlers[],
                             size_t nEventHandlers,
                             Event* pEvent,
                             EventHandler* pCaller = 0,
                             CallbackMethod pfMethod = 0);
The method shouldInvoke is passed the key of an EventHandler and the Event and returns true if the EventHandler determines that it should be invoked. The method selectAndInvoke receives an event and a list of keys of EventHandlers. The selectAndInvoke method iterates over this array, looks up the EventHandler by its key, and invokes each EventHandler's shouldInvoke method. Once one shouldInvoke returns true, that EventHandler is invoked and the selectAndInvoke method returns true. If no EventHandler returns true to shouldInvoke, then selectAndInvoke returns false.
The advantage of this is that it means that each component encapsulates not just its business logic but also the conditions under which it is executed. Without this the execution condition logic is either contained in the invoking component or in some global component. See email thread on this here: Branching analysis. It is important to note that this is meant as a solution for simple branching logic and is not recommended for more complicated flow constructs such as complex protocol state machines.
-	Management of State Between Requests
As mentioned in Section 4.1Contexts, AttributeSets and Dictionaries, some of the data accessed or processed during the course of handling a request is data that has a lifetime longer than the request itself. That data could be related to the authentication process (keeping state between challenge/responses until the final decision is made) or it could be related to the user's login session (keeping state between the Access-Accept until the user logs out). There may be other forms of state that exists outside of any given request, having to do with external authentication servers, posture and audit servers, or radius proxies. All of this state share similar characteristics. We need to be able to manage the creation, acquisition, release and destruction of the state. We need to be able to time out the state so that it will be released after a suitable time if it is not accessed. Some of these types of state may need to be replicated to the failover partner or may need to be persisted on disk so that it can be recovered if the process restarts. Because of these similarities, the architecture will provide a generic facility for managing state.
As mentioned in Section 4.1, state objects are AttributeSets. When they are acquired, they are put in the Context so that each component that needs to can access the attributes on the state object in a uniform way. When they are no longer needed, they can be removed from the Context and released or deleted as needed.
Each type of state will have its own Dictionary defining the legal attributes. There will be a component (the StateManager) that will be responsible for managing the lifecycle of all state AttributeSets. The StateManager will allow clients to create or acquire the state objects. There will also be the ability to do an atomic 'acquire or create' operation so that if the state object already exists it is acquired; otherwise a new object with the specified key is created. This avoids the window that would occur if the client had to try to acquire the object and if that failed had to create it instead.
Since acquiring an object may block (since the object in question may have been acquired by some other Context) and since releasing an object may block (since if updates were made to the object while acquired, the object may need to be replicated and/or persisted), the StateManager is an EventHandler. The StateManager will support at least the following Events: AcquireOrCreateState, AcquireState, ReleaseState and DeleteState. The Event will of course contain the Context. If AcquireOrCreateState or AcquireState are successful, the Context will contain a pointer to the state AttributeSet. When ReleaseState or DeleteState returns, the Context no longer has a pointer to the state AttributeSet.
As mentioned above, state objects may time out if they have not been acquired for a long enough period of time. Clients of the StateManager can register callbacks that will be called when a state object times out. This will allow the clients to release resources that may be referenced by the state object.
We anticipate that any replication of server state that needs to occur between the failover pairs will be handled transparently by the StateManager. That is, the rest of the runtime components will not need to deal with this issue. Initial implementations of the StateManager will likely ignore this feature, but later phases will support it without requiring a change to the interface provided to clients.
-	Configuration, Behavior, and State
One of the PRD requirements is that the runtime support 'hot config', that is, the ability to incorporate configuration changes without needing to restart the server. We will support that requirement by designing a component called the ConfigManager that will support versioned views of the configuration. When a request comes in and a Context is created to represent that request, the Context will acquire the current version id from the Service object. During the course of processing the request, any time that a component needs to access a configuration item, it will use the configuration version id to get the corresponding version of the item. When the Context is deleted the ConfigManager will be notified that the context doesn't need the version id any more. If that context was the last client of that version of the configuration, that version can be deleted.
Most components only need to access configuration elements while processing a given request. Some components however are intimately connected with configuration - the components implementing interfaces to external authentication databases for example. These components have behavior and state that are related to the configuration. For example, if the administrator configures an external authentication db as a specific LDAP directory server, there will be a component that knows how to take that configuration, create one or more connections to the directory server, binding to that server with the specified credentials. Those connections represent state that is associated with the configuration. If the configuration changes, the state would be invalid and would have to be recreated. For those components that have this intimate relationship between configuration, state and behavior, we will choose to implement those three elements in one component. That is, the component will contain all three. Note that this is in contrast to the design pattern where there would be three classes - one for the config, one for the state and one for the behavior. The choice made will make the invocation of the component easier. With separate config, state and behavior classes, a client would have to first look up the configuration for the component it wants to invoke. Then it would have to look in to that config object to find the type of the component it wants to invoke (that is, the type of behavior it requires, e.g. LDAP). It would then invoke the LDAP behavior client which would then be required to look up the state associated with the passed in configuration object. With the solution specified, the client could just invoke the component by identifier. The component would not have any extra steps to look up the state since it would already have the state it needs.
To support hot config of configuration that describes these stateful objects, when a configuration change is detected, a new instance of the stateful object will be created. New requests will find the new instance and will be processed by that instance. Existing requests will be handled by the instance that corresponds to the version that they know about. When the configuration version corresponding to the 'old' instance of the stateful object is no longer referenced by any active requests, those stateful objects can be deleted.
-	Error Handling
The runtime will be using a mixed model for handling errors. Within an EventHandler, we will be using C++ exceptions. Between EventHandlers we will be using an error code stored in the Request AttributeSet in the Context (Acs::LastError). Using error codes between EventHandlers is required by the asynchronous Event passing model used. There is no guarantee that the Event will be processed on the same thread that it was passed on, thus there is no guarantee that throwing an exception would be able to be caught by the invoking method. Instead, the base EventHandler class will catch any exceptions thrown by the derived class and will convert the exception to an error code on the Context. When the invoking EventHandler gets called back with the Event, it will need to check the Context to see if an error code was set. For components that are not based on EventHandler and that are called normally, exceptions will be thrown to the caller to indicate errors.
It is the responsibility of the catcher of the exception to generate a debug log message if appropriate. It is the responsibility of the code processing the error (of the error code if returned by an asynchronous call or by the catcher if thrown from a synchronous call) to decide whether a system log message is appropriate. Note that for errors caught within the flow of a request should be logged when the pass/fail attempt log message is generated (not separately in this case).
For other errors (like a lost connection to an external IDStore), the component responsible for handling the error is responsible for generating the appropriate system log message to record the error.

		9.1.1 EventDispatcher

			9.1.1.1 header
#ifndef EVENTDISPATCHER_H
#define EVENTDISPATCHER_H

/*
 * Copyright (c) 2007, 2008, 2009, 2012 Cisco Systems, Inc. This program contains
 * proprietary and confidential information. All rights reserved except * as may be permitted by prior written consent.
 *
 */

#include "ForwardPtrs.h"
#include "MethodCaller.h"
#include "EventHandler.h"
#include "AcsDebugLog.h"
#include "InvalidArgumentException.h"

#include <ace/Mutex.h>

#include <map>
#include <list>
#include <stdexcept>
#include <set>

class EventStack;
/**
 * Provides facilities for dispatching events to event handlers.
 * This class is a singleton
 */
class EventDispatcher
{
    public:
        /**
         * the EventHanlder key
         */
        typedef EventHandler::Key_t Key_t;
        /**
         * type for list of EventHandler keys
         */
        typedef std::list<Key_t> KeyList;

        /**
         * \return pointer to the single instance of this class
         */
        static EventDispatcher *instance ();

        /**
         * not designed for derivation
         */
        ~EventDispatcher ();

        /**
         * Register EventHandler
         * \throw InvalidArgumentException when !pEventHandler 
         * \throw EventHandlerException when registering with already registered key
         */
        void registerHandler (const EventHandlerPtr &pEventHandler);

        /**
         * Unreegister EventHandler
         * \throw InvalidArgumentException when !pEventHandler 
         */
        void unregisterHandler (const EventHandlerPtr &pEventHandler);


        /**
         * send event to EventHandler object registered with key
         * \throw InvalidArgumentException when !pEventHandler or !pEvent
         */ 
        void invoke (const Key_t &key, Event *pEvent);

        /**
         * send event to EventHandler object pHandler
         * \throw InvalidArgumentException when !pEventHandler or !pEvent
         */ 
        void invoke (const EventHandlerPtr &pHandler, Event *pEvent);

        /**
         * send event to EventHandler registered with key and specify a callback function
         * \param key - the key of the EventHandler
         * \param pEvent - the event to dispatch
         * \param pCaller - the handler that wants to receive callback
         * \param pfCallback - the callback function to call
         *
         * \throw InvalidArgumentException when any of arguments are NULL
         * \throw EventHandlerException when there is no registered handler with the specified key 
         *      or the registered handler doesn't have a method to handle this event
         */
        template <class Handler, class EventType> 
        void invoke ( 
                const Key_t &key, 
                EventType *pEvent, 
                Handler *pCaller,
                void (Handler::*pfCallback)(EventType *pEvent));

        /**
         * send event to EventHandler pointed to by pHandler and specify a callback function
         * \param pHandler - the pointer to the EventHandler
         * \param pEvent - the event to dispatch
         * \param pCaller - the handler that wants to receive callback
         * \param pfCallback - the callback function to call
         *
         * \throw InvalidArgumentException when any of arguments are NULL
         * \throw EventHandlerException when there is no registered handler with the specified key 
         *      or the registered handler doesn't have a method to handle this event
         */       
        template <class Handler, class EventType> 
        void invoke ( 
                const EventHandlerPtr &pHandler,
                EventType *pEvent, 
                Handler *pCaller,
                void (Handler::*pfCallback)(EventType *pEvent));

        /**
         * select a handler from the list keys and send pEvent to it
         * \param keys - list of keys to select from
         * \param pEvent - the event to send
         * \return true if handler was found for this event otherwise false
         * \throw InvalidArgumentException when pEvent == NULL
         */
        bool selectAndInvoke (const KeyList &keys, Event *pEvent);

        /**
         * select a handler from the list keys and send pEvent to it and specify a callback function
         * \param keys - list of keys to select from
         * \param pEvent - the event to dispatch
         * \param pCaller - the handler that wants to receive callback
         * \param pfCallback - the callback function to call
         *
         * \throw InvalidArgumentException when any of arguments are NULL
         */       
        template <class Handler, class EventType> 
        bool selectAndInvoke ( 
                const KeyList &keys, 
                EventType *pEvent, 
                Handler *pCaller,
                void (Handler::*pfCallback)(EventType *pEvent));

        /**
         * find handler by key
         */
        const EventHandlerPtr &findHandler (const Key_t &key);

        /**
         * check if event handler specified by key supports pEvent
         * \param key - event handler key
         * \param pEvent - event to check for
         * \return true if event supported otherwise false 
         */
        bool isEventSupported (const Key_t &eventHandlerKey, const Event::Key_t &eventKey );
        
        /**
         * get all eventKeys which are supported by the eventHandler
         * \param key - event handler key
         * \param eventKeysList - list of supported eventKeys
         * \return false if there is no such  eventHandler or exception occured, otherwise true
         */
        bool getSupportedEvents (const Key_t &eventHandlerKey, std::list<Event::Key_t> &eventKeysList);

        /**
         * suspend handling of the event chain represented by pEvent
         * \param pEvent - the event to suspend
         */
        void suspend (Event *pEvent);

        /**
         * resume handling of the chain represented by pEvent
         * \param pEvent - event to resume
         */
        void resume (Event *pEvent);



    private:
        EventDispatcher ();
        EventDispatcher (const EventDispatcher &other);
        EventDispatcher &operator = (const EventDispatcher &rhs);

        friend class EventCommand;

        static void sendToNextThreadPool (EventStack *pStack);
        static void deferredInvoke (EventStack *pStack, const WorkerThreadPoolPtr &pCurrentThreadPool);

        void invoke (const Key_t &key, const EventPtr &pEvent, const EventHandlerPtr &pCaller, const MethodCallerPtr &pCallback);
        void invoke (const EventHandlerPtr &pHandler, const EventPtr &pEvent, const EventHandlerPtr &pCaller, const MethodCallerPtr &pCallback);

        bool selectAndInvoke (const KeyList &keys, const EventPtr &pEvent, const EventHandlerPtr &pCaller, const MethodCallerPtr &pCallback);


        /**
         * \throw InvalidArgumentException when pHandler or pEvent equal zero
         * \throw EventHandlerException when there is no handling method 
         * registered for pEvent dynamic type
         */
        const MethodCallerPtr &findMethod (const EventHandlerPtr &pHandler, const EventPtr &pEvent);

        typedef std::map<Key_t, EventHandlerPtr> HandlerMap;
        HandlerMap m_handlers;
        ACE_RW_Thread_Mutex m_mutex;

        AcsDebugLog m_log;
};

template <class Handler, class EventType> 
void EventDispatcher::invoke ( 
        const Key_t &key, 
        EventType *pEvent, 
        Handler *pCaller,
        void (Handler::*pfCallback)(EventType *pEvent))
{
    if (pEvent == 0 || pCaller == 0 || pfCallback == 0)
    {
        throw InvalidArgumentException (std::string ("NULL pointer argument"));
    }
    MethodCallerPtr pCallback (new MethodCaller<Handler, EventType> (pfCallback), false);
    invoke (key, EventPtr (pEvent), EventHandlerPtr (pCaller), pCallback);
}

template <class Handler, class EventType> 
void EventDispatcher::invoke ( 
        const EventHandlerPtr &pHandler,
        EventType *pEvent, 
        Handler *pCaller,
        void (Handler::*pfCallback)(EventType *pEvent))
{
    if (!pHandler || pEvent == 0 || pCaller == 0 || pfCallback == 0)
    {
        throw InvalidArgumentException (std::string ("NULL pointer argument"));
    }
    MethodCallerPtr pCallback (new MethodCaller<Handler, EventType> (pfCallback), false);
    invoke (pHandler, EventPtr (pEvent), EventHandlerPtr (pCaller), pCallback);
}

template <class Handler, class EventType> 
bool EventDispatcher::selectAndInvoke ( 
        const KeyList &keys, 
        EventType *pEvent, 
        Handler *pCaller,
        void (Handler::*pfCallback)(EventType *pEvent))
{
    if (pEvent == 0 || pCaller == 0 || pfCallback == 0)
    {
        throw InvalidArgumentException (std::string ("NULL pointer argument"));
    }
    MethodCallerPtr pCallback (new MethodCaller<Handler, EventType> (pfCallback), false);
    return selectAndInvoke (keys, EventPtr (pEvent), pCaller, pCallback);
}

inline EventDispatcher *TheDispatcher ()
{
    return EventDispatcher::instance ();
}

template <class Handler> void create (const EventHandler::Key_t &key, const WorkerThreadPoolPtr &pThreadPool)
{
    EventHandlerPtr pEventHandler (new Handler (key, pThreadPool), false);
    TheDispatcher ()->registerHandler (pEventHandler);
}

template <class Handler, class ThreadPoolPtr> void create2 (const EventHandler::Key_t &key, const ThreadPoolPtr &pThreadPool)
{
    EventHandlerPtr pEventHandler (new Handler (key, pThreadPool), false);
    TheDispatcher ()->registerHandler (pEventHandler);
}

inline void destroy (const EventHandlerPtr &pEventHandler)
{
    TheDispatcher ()->unregisterHandler (pEventHandler);
} 


inline void destroy (const EventHandler::Key_t &key)
{
    EventHandlerPtr pEventHandler = TheDispatcher ()->findHandler (key);
    TheDispatcher ()->unregisterHandler (pEventHandler);
} 

// tepmorary place for thread pools
class ThreadPools
{
    public:
        void init ();
        static ThreadPools *instance ();

        WorkerThreadPoolPtr pMainThreadPool;
        WorkerThreadPoolPtr pIDStoreThreadPool;
        WorkerThreadPoolPtr pLoggingThreadPool;
        WorkerThreadPoolPtr pInternalIDStoreThreadPool;
        WorkerThreadPoolPtr pActiveDirectoryIDStoreThreadPool;
        ReactorThreadPtr pLdapThread;
        WorkerThreadPoolPtr pPostureServerThreadPool;
        ReactorThreadPtr pMessageBusThread;
        ReactorThreadPtr pConfigNotificationThread;
        ReactorThreadPtr pRSAAgentThread;
        WorkerThreadPoolPtr pEapTlsThreadPool;
        ReactorThreadPtr pTCPSyslogThread;

    private:
        ThreadPools ();
};

#endif // EVENTDISPATCHER_H

			9.1.1.2 ThreadPools


				9.1.1.2.1 class ThreadPools
{
    public:
        void init ();
        static ThreadPools *instance ();

        WorkerThreadPoolPtr pMainThreadPool;
        WorkerThreadPoolPtr pIDStoreThreadPool;
        WorkerThreadPoolPtr pLoggingThreadPool;
        WorkerThreadPoolPtr pInternalIDStoreThreadPool;
        WorkerThreadPoolPtr pActiveDirectoryIDStoreThreadPool;
        ReactorThreadPtr pLdapThread;
        WorkerThreadPoolPtr pPostureServerThreadPool;
        ReactorThreadPtr pMessageBusThread;
        ReactorThreadPtr pConfigNotificationThread;
        ReactorThreadPtr pRSAAgentThread;
        WorkerThreadPoolPtr pEapTlsThreadPool;
        ReactorThreadPtr pTCPSyslogThread;

    private:
        ThreadPools ();
};

----------------------------------------------------------------------------------------------------
// this code is intended for experimentation
// should be removed for production
ThreadPools::ThreadPools ()
{
    int numProcessors = ACE_OS::num_processors ();
    int numMainWorkerThreads = numProcessors; 
    char *pWorkerCountEnv = getenv ("MAIN_WORKER_THREADS_COUNT");
    if (pWorkerCountEnv)
    {
        numMainWorkerThreads = atoi (pWorkerCountEnv);
        if (numMainWorkerThreads == 0)
        {
            numMainWorkerThreads = numProcessors;
        }
        std::cout<<"MAIN_WORKER_THREADS_COUNT = "<<numMainWorkerThreads<<std::endl;
        std::cout<<"Number of processors = "<<numProcessors<<std::endl;
    }

    bool ldapInMainPool = false;
    char *pLdapInMainPoolEnv = getenv ("LDAP_IN_MAIN_POOL");
    if (pLdapInMainPoolEnv)
    {
        ldapInMainPool = atoi (pLdapInMainPoolEnv) == 1;
        std::cout<<"LDAP_IN_MAIN_POOL = "<<ldapInMainPool<<std::endl;
    }

    bool loggingInMainPool = false;
    char *pLoggingInMainPoolEnv = getenv ("LOGGING_IN_MAIN_POOL");
    if (pLoggingInMainPoolEnv)
    {
        loggingInMainPool = atoi (pLoggingInMainPoolEnv) == 1;
        std::cout<<"LOGGING_IN_MAIN_POOL = "<<loggingInMainPool<<std::endl;
    }

    pMainThreadPool = WorkerThreadPoolPtr (new WorkerThreadPool (numMainWorkerThreads), false);

    if (ldapInMainPool)
    {
        pIDStoreThreadPool = pMainThreadPool; 
    }
    else
    {
        pIDStoreThreadPool = WorkerThreadPoolPtr (new WorkerThreadPool (1), false);
    }

    if (loggingInMainPool)
    {
        pLoggingThreadPool = pMainThreadPool;
    }
    else
    {
        pLoggingThreadPool = WorkerThreadPoolPtr (new WorkerThreadPool (2), false);
    }

    int numInternalIDStoreThreads = 8;
    char *pInternalIDStoreCountEnv = getenv ("INTERNAL_ID_STORE_THREADS_COUNT");
    if (pInternalIDStoreCountEnv)
    {
        numInternalIDStoreThreads = atoi (pInternalIDStoreCountEnv);
        if (numInternalIDStoreThreads == 0)
        {
            numInternalIDStoreThreads = 8;
        }
        std::cout<<"INTERNAL_ID_STORE_THREADS_COUNT = "<<numInternalIDStoreThreads<<std::endl;
    }
        
    pInternalIDStoreThreadPool = WorkerThreadPoolPtr (new WorkerThreadPool (numInternalIDStoreThreads), false);
    
    int numActiveDirectoryIDStoreThreads = 15;
    char *pActiveDirectoryIDStoreCountEnv = getenv ("AD_ID_STORE_THREADS_COUNT");
    if (pActiveDirectoryIDStoreCountEnv)
    {
        numActiveDirectoryIDStoreThreads = atoi (pActiveDirectoryIDStoreCountEnv);
        if (numActiveDirectoryIDStoreThreads == 0)
        {
            numActiveDirectoryIDStoreThreads = 15;
        }
        std::cout<<"AD_ID_STORE_THREADS_COUNT = "<<numActiveDirectoryIDStoreThreads<<std::endl;
    }
    pActiveDirectoryIDStoreThreadPool = WorkerThreadPoolPtr (new WorkerThreadPool (numActiveDirectoryIDStoreThreads), false);
    
    int numEapTlsThreads = 4;
    char *pEapTlsCountEnv = getenv ("EAP_TLS_THREADS_COUNT");
    if (pEapTlsCountEnv)
    {
        numEapTlsThreads = atoi (pEapTlsCountEnv);
        if (numEapTlsThreads == 0)
        {
            numEapTlsThreads = 4;
        }
        std::cout<<"EAP_TLS_THREADS_COUNT = "<<numEapTlsThreads<<std::endl;
    }
    pEapTlsThreadPool = WorkerThreadPoolPtr (new WorkerThreadPool (numEapTlsThreads), false);    
    
    pLdapThread = ReactorThreadPtr (new ReactorThread);
   
    pPostureServerThreadPool = WorkerThreadPoolPtr (new WorkerThreadPool (10), false);

    // Message Bus
    pMessageBusThread = ReactorThreadPtr (new ReactorThread);

    // Config notification
    pConfigNotificationThread = ReactorThreadPtr (new ReactorThread);
    
    //RSAAgent
    pRSAAgentThread = ReactorThreadPtr (new ReactorThread);
    
    //  TCP & Secure TCP Syslog 
    pTCPSyslogThread = ReactorThreadPtr (new ReactorThread);
}

ThreadPools *ThreadPools::instance ()
{
    static ThreadPools instance_;
    return &instance_;
}

void ThreadPools::init ()
{
}

					9.1.1.2.1.1 ReactorThreadPtr
#ifndef REACTORTHREAD_H
#define REACTORTHREAD_H

/*
 * Copyright (C) 2007 by Cisco Systems, Inc. This program contains
 * proprietary and confidential information. All rights reserved except
 * as may be permitted by prior written consent.
 *
 */

#include "WorkerThreadPool.h"

/**
 * Objects of ReactorThread class combine functionality of ACS worker thread pool 
 * of dequeueing events and executing them with ACE reactor functionality of
 * demultiplexing IO and handling timeouts. 
 * It derives from WorkerThreadPool but ensures that there is only one thread in the pool
 * THIS CLASS IS NOT DESIGNED FOR DERIVATION. 
 *
 */
class ReactorThreadNotifier;
class ACE_Reactor_Impl;
class ReactorThread : public WorkerThreadPool
{
    public:
        ReactorThread ();
        virtual ~ReactorThread ();

        /**
         * \return ACE reactor implementation
         */
        ACE_Reactor_Impl *getReactor ();

    private:

        virtual int run ();

        virtual void beforeEnqueue ();
        virtual void afterEnqueue ();

        ACE_Reactor_Impl *m_pReactor;
        ReactorThreadNotifier *m_pNotifier;
        friend class ReactorThreadNotifier;
};


#endif // REACTORTHREAD_H

----------------------------------------------------------------------------------------------------
//**************************************************
// Copyright (c) 2008 Cisco Systems, Inc.
// All rights reserved.
//**************************************************
#include "ReactorThread.h"

#include "ReactiveEventHandler.h"
#include "WorkerThreadPool.h"

#include "ace/Dev_Poll_Reactor.h"

#include <iostream>

void intrusive_ptr_add_ref (ReactorThread *pReactorThread)
{
    pReactorThread->addRef ();
}

void intrusive_ptr_release (ReactorThread *pReactorThread)
{
    pReactorThread->release ();
}

/**
 * ReactorThreadNotifier is a helper class that receives notifications
 * from ACE reactor when there command is enqueued to owner thread
 * then it dequeues the command and executes it. If the notification
 * is about shutdown then shutdown flag is set
 */
class ReactorThreadNotifier : public ACE_Event_Handler
{
    public:
        ReactorThreadNotifier ()
            :   m_shutdown (false),
                m_pReactorThread (0)
        {
        }

        void setReactorThread (ReactorThread *pReactorThread)
        {
           m_pReactorThread = pReactorThread;
        } 

        bool isShutdown ()
        {
            return m_shutdown;
        }

    private:
        // this function will be called as result of call to m_pReactor->notify in the afterEnqueue function
        // dequeue and execute command
        virtual int handle_input (ACE_HANDLE fd)
        {
            //std::cout<<ACE_Thread::self ()<<" ReactorThreadNotifier::handle_input"<<std::endl;

            WorkerThreadPool::CommandPtr pCommand = m_pReactorThread->dequeue ();
            if (!pCommand)
            {
                if (m_pReactorThread->isShutdown ())
                {
                    //std::cout<<ACE_Thread::self ()<<" ReactorThreadNotifier::handle_input shutdown"<<std::endl;
                    m_shutdown = true;
                    return 0;
                }
                assert (0);
            }
            else
            {
                //std::cout<<ACE_Thread::self ()<<" ReactorThreadNotifier::handle_input execute command"<<std::endl;
                pCommand->execute ();
            }
            return 0;
        }
        
        bool m_shutdown;
        ReactorThread *m_pReactorThread;
};

ReactorThread::ReactorThread ()
    :   WorkerThreadPool (1, true),
        m_pReactor (new ACE_Dev_Poll_Reactor),
        m_pNotifier (new ReactorThreadNotifier)
{
    m_pReactor->register_handler (m_pNotifier, ACE_Event_Handler::READ_MASK);

    // resume execution of threads after all the initialization is done.
    // is a must if we want to avoid race condition between thread startup
    // in base class and initialization in the derived class
    WorkerThreadPool::resume ();
}

ReactorThread::~ReactorThread ()
{
    // send notification to thread so it can read the shutdown condition from the queue
    try 
    {
        // make SA happy
        closeQueue ();
        m_pReactor->notify (m_pNotifier, ACE_Event_Handler::READ_MASK);
        wait ();
        
        delete m_pReactor;
        m_pReactor = 0;
        
        delete m_pNotifier;
        m_pNotifier = 0;
    }
    catch (...)
    {
        // ignore
    }
}

int ReactorThread::run ()
{
    m_pNotifier->setReactorThread (this);
    while (true)
    {
        // int result = 
        m_pReactor->handle_events ();
        //std::cout<<"ReactorThread::run notified handlers: "<<result<<std::endl;
        if (isShutdown ())
        {
            return 0;
        }
    }
    return 0;
}

void ReactorThread::beforeEnqueue ()
{
    ////std::cout<<ACE_Thread::self ()<<" ReactorThread::beforeEnqueue"<<std::endl;
}

void ReactorThread::afterEnqueue ()
{
    // this notification will cause m_pNotifier->handle_input to be called
    // in the context of the reactor thread
    // each call to notify will cause exectly one call of handle_input
    m_pReactor->notify (m_pNotifier, ACE_Event_Handler::READ_MASK);
    //std::cout<<ACE_Thread::self ()<<" ReactorThread::afterEnqueue"<<std::endl;
}

ACE_Reactor_Impl *ReactorThread::getReactor ()
{
    return m_pReactor;
}


					9.1.1.2.1.2 WorkerThreadPoolPtr
#ifndef WORKERTHREADPOOL_H
#define WORKERTHREADPOOL_H

/*
 * Copyright (C) 2007 by Cisco Systems, Inc. This program contains
 * proprietary and confidential information. All rights reserved except
 * as may be permitted by prior written consent.
 *
 */

#include "AcsAssert.h"
#include "MessageQueue.h"

#include "ace/Task_T.h"
#include "ace/Lock_Adapter_T.h"
#include "ace/Time_Value.h"
#include "ace/Guard_T.h"
#include "ace/Mutex.h"
#include "ace/Condition_T.h"

#include <boost/shared_ptr.hpp>
#include <boost/intrusive_ptr.hpp>

#include <stdexcept>
#include <iostream>

#include "RefCountedObject.h"

// TODO implement try_enqueue
// TODO implement message queue limit
// TODO implement message priority
// 


struct Command : public LockedRefCountedObject
{
    virtual ~Command () 
    {
    }

    virtual void execute () = 0;
    virtual int priority () const
    {
        return 0;
    }
};

bool operator < (const Command &lhs, const Command &rhs);



extern void intrusive_ptr_release (Command *pCommand);
extern void intrusive_ptr_add_ref (Command *pCommand);

class ResumeThreadCondition
{
    public:
        ResumeThreadCondition ();

        void resume ();
        bool wait (int milliseconds);

    private:
        bool m_resume;
        ACE_Mutex m_mutex;
        ACE_Condition<ACE_Mutex> m_condition;
};

/** 
 * objects of class WorkerThreadPool provide functionality of 
 * thread pool and Command pattern. 
 * Commands can be enqueued to a pool and executed.
 * When deriving from this class and there is a need for intitialization
 * in the derived class thread should be created suspended and resumed in 
 * the derived class constructor. This is needed because of C++
 * initialization sequence
 */
class WorkerThreadPool : public LockedRefCountedObject 
{
    public:
        typedef boost::intrusive_ptr <Command> CommandPtr;

        /**
         * \param numberOfThreads - specifies number of thread for the thread pool
         * \param createSuspended - specify true when called from derived classes 
         *
         */ 
        WorkerThreadPool (size_t numberOfThreads = 1, bool createSuspended = false);
        virtual ~WorkerThreadPool ();


        void enqueue (const CommandPtr &pCommand, unsigned int priority = 0 /*lowest*/);

        static ACE_TSS<WorkerThreadPool> localThreadPool; 
        static WorkerThreadPool *getLocalThreadPool ();
        static void setLocalThreadPool (WorkerThreadPool *pThreadPool);

    protected:
        CommandPtr dequeue ();
        bool isShutdown () const;

        /**
         * resume execution of threads
         */
        void resume ();
        void wait ();
        void closeQueue ();

    private:
        void start ();
        void stop ();

        WorkerThreadPool (const WorkerThreadPool &other);
        WorkerThreadPool &operator = (const WorkerThreadPool &rhs);

        virtual int run ();

        virtual void beforeEnqueue ();
        virtual void afterEnqueue ();

        static ACE_THR_FUNC_RETURN srun (void *pArg);
                 
        size_t m_numberOfThreads;
        MessageQueue<CommandPtr> m_queue;

        typedef std::vector<ACE_thread_t> AceThreads;
        AceThreads m_threads;
        ResumeThreadCondition m_resumeThreadCondition;
};

extern void intrusive_ptr_release (WorkerThreadPool *pThreadPool);
extern void intrusive_ptr_add_ref (WorkerThreadPool *pThreadPool);

#endif // WORKERTHREADPOOL_H

					9.1.1.2.1.3
				9.1.1.2.2

			9.1.1.3
		9.1.2 EventHandler 

			9.1.2.1  header


#ifndef EVENTHANDLER_H
#define EVENTHANDLER_H

/*
 * Copyright (c) 2007, 2008, 2009 Cisco Systems, Inc. This program contains
 * proprietary and confidential information. All rights reserved except
 * as may be permitted by prior written consent.
 *
 */

#include "ForwardPtrs.h"
#include "RefCountedObject.h"

#include <string>
#include <sstream>
#include <memory>

class Event;
class Exception;
class EventDispatchTable;
class WorkerThreadPool;

/**
 * Provides a base class for event handlers and defines the Key type
 * Instances of this class are reference counted.
 */
class EventHandler : public LockedRefCountedObject
{
    public:

        /**
         * Provides key abstraction for event handler classes. 
         */
        class Key 
        {
            public:
                /**
                 * Default ctor
                 */
                Key();

                /**
                 * Construct a key from std::string
                 * \param name will serve as key
                 */
                Key (const std::string &name);

                /**
                 * Construct a key from std::string and number
                 * \param name base of the key 
                 * \param number sufix of the key
                 */
                Key (const std::string &name, int number);

                /**
                 * \return true when the key is empty
                 */
                bool isEmpty () const;

                /**
                 * Keys can be ordered
                 */
                friend bool operator < (const EventHandler::Key &lhs, const EventHandler::Key &rhs);

                /**
                 * Keys can be compared for equality
                 */
                friend bool operator == (const EventHandler::Key &lhs, const EventHandler::Key &rhs);

                /**
                 * Keys can be compared for inequality
                 */
                friend bool operator != (const EventHandler::Key &lhs, const EventHandler::Key &rhs);
                /**
                 * keys can be inserted in std streams
                 */
                friend std::ostream &operator << (std::ostream &os, const EventHandler::Key &key);

                /**
                 * \return reference to string representation of the key
                 */
                const std::string &asString () const;


            private:
                std::string m_key;
        };


        typedef Key Key_t;

        /**
         * Designed to be base class
         */
        virtual ~EventHandler ();

        /**
         * \return reference to the key of this handler
         */
        const Key_t &getKey () const;

        /**
         * for derived classes to override.
         * \return false by default
         */
        virtual bool shouldInvoke (Event *pEvent);

	virtual void onException (const Exception &e, Event *pEvent) const; 

        /**
         * \return the dispatch table of this handler
         */
        EventDispatchTable *getDispatchTable ();

        /**
         * \return thread pool assosiated with this handler
         */
        const WorkerThreadPoolPtr &getThreadPool ();

    protected:

        /**
         * For derived classes only.
         * \param key - the key with which this handler will be known
         * \param pThreadPool - thread pool assosiated with this handler
         */
        EventHandler (const Key_t &key, const WorkerThreadPoolPtr &pThreadPool);

    private:
        /**
         * No copy
         */
        EventHandler (const EventHandler &other);

        /**
         * No assignment
         */
        EventHandler &operator = (const EventHandler &rhs);

        typedef std::auto_ptr<EventDispatchTable> EventDispatchTablePtr;
        EventDispatchTablePtr m_pDispatchTable;
        Key_t m_key;

        WorkerThreadPoolPtr m_pThreadPool; 
};


inline bool operator < (const EventHandler::Key &lhs, const EventHandler::Key &rhs)
{
    return lhs.m_key < rhs.m_key;
}

inline bool operator == (const EventHandler::Key &lhs, const EventHandler::Key &rhs)
{
    return lhs.m_key == rhs.m_key;
}

inline bool operator != (const EventHandler::Key &lhs, const EventHandler::Key &rhs)
{
    return lhs.m_key != rhs.m_key;
}

inline std::ostream &operator << (std::ostream &os, const EventHandler::Key &key)
{
    os<<key.m_key;
    return os; 
}

#endif // EVENTHANDLER_H

		9.1.3 WorkerThreadPool

			9.1.3.1 header
#ifndef WORKERTHREADPOOL_H
#define WORKERTHREADPOOL_H

/*
 * Copyright (C) 2007 by Cisco Systems, Inc. This program contains
 * proprietary and confidential information. All rights reserved except
 * as may be permitted by prior written consent.
 *
 */

#include "AcsAssert.h"
#include "MessageQueue.h"

#include "ace/Task_T.h"
#include "ace/Lock_Adapter_T.h"
#include "ace/Time_Value.h"
#include "ace/Guard_T.h"
#include "ace/Mutex.h"
#include "ace/Condition_T.h"

#include <boost/shared_ptr.hpp>
#include <boost/intrusive_ptr.hpp>

#include <stdexcept>
#include <iostream>

#include "RefCountedObject.h"

// TODO implement try_enqueue
// TODO implement message queue limit
// TODO implement message priority
// 


struct Command : public LockedRefCountedObject
{
    virtual ~Command () 
    {
    }

    virtual void execute () = 0;
    virtual int priority () const
    {
        return 0;
    }
};

bool operator < (const Command &lhs, const Command &rhs);



extern void intrusive_ptr_release (Command *pCommand);
extern void intrusive_ptr_add_ref (Command *pCommand);

class ResumeThreadCondition
{
    public:
        ResumeThreadCondition ();

        void resume ();
        bool wait (int milliseconds);

    private:
        bool m_resume;
        ACE_Mutex m_mutex;
        ACE_Condition<ACE_Mutex> m_condition;
};

/** 
 * objects of class WorkerThreadPool provide functionality of 
 * thread pool and Command pattern. 
 * Commands can be enqueued to a pool and executed.
 * When deriving from this class and there is a need for intitialization
 * in the derived class thread should be created suspended and resumed in 
 * the derived class constructor. This is needed because of C++
 * initialization sequence
 */
class WorkerThreadPool : public LockedRefCountedObject 
{
    public:
        typedef boost::intrusive_ptr <Command> CommandPtr;

        /**
         * \param numberOfThreads - specifies number of thread for the thread pool
         * \param createSuspended - specify true when called from derived classes 
         *
         */ 
        WorkerThreadPool (size_t numberOfThreads = 1, bool createSuspended = false);
        virtual ~WorkerThreadPool ();


        void enqueue (const CommandPtr &pCommand, unsigned int priority = 0 /*lowest*/);

        static ACE_TSS<WorkerThreadPool> localThreadPool; 
        static WorkerThreadPool *getLocalThreadPool ();
        static void setLocalThreadPool (WorkerThreadPool *pThreadPool);

    protected:
        CommandPtr dequeue ();
        bool isShutdown () const;

        /**
         * resume execution of threads
         */
        void resume ();
        void wait ();
        void closeQueue ();

    private:
        void start ();
        void stop ();

        WorkerThreadPool (const WorkerThreadPool &other);
        WorkerThreadPool &operator = (const WorkerThreadPool &rhs);

        virtual int run ();

        virtual void beforeEnqueue ();
        virtual void afterEnqueue ();

        static ACE_THR_FUNC_RETURN srun (void *pArg);
                 
        size_t m_numberOfThreads;
        MessageQueue<CommandPtr> m_queue;

        typedef std::vector<ACE_thread_t> AceThreads;
        AceThreads m_threads;
        ResumeThreadCondition m_resumeThreadCondition;
};

extern void intrusive_ptr_release (WorkerThreadPool *pThreadPool);
extern void intrusive_ptr_add_ref (WorkerThreadPool *pThreadPool);

#endif // WORKERTHREADPOOL_H

			9.1.3.2 ACE_TSS

ACE_TSS< TYPE > Class Template Reference

Allows objects that are "physically" in thread specific storage (i.e., private to a thread) to be accessed as though they were "logically" global to a program. 
This class helps to maintain a separate copy of an object for each thread that needs access to it. All threads access a single instance of ACE_TSS to obtain a pointer to a thread-specific copy of a TYPE object. Using a pointer to TYPE in TSS instead of TYPE itself is useful because, in addition to avoiding copies on what may be a complex class, it allows assignment of objects to thread-specific data that have arbitrarily complex constructors.

When the ACE_TSS object is destroyed, all threads's instances of the data are deleted.

Modern compilers have no problem using a built-in type for TYPE. However, if you must use an older compiler that won't work with a built-in type, the ACE_TSS_Type_Adapter class template, below, can be used for adapting built-in types to work with ACE_TSS.

Note:
    Beware when creating static instances of this type (as with any other, btw). The unpredictable order of initialization across different platforms may cause a situation where one uses the instance before it is fully initialized. That's why typically instances of this type are dynamicaly allocated. On the stack it is typically allocated inside the ACE_Thread::svc() method which limits its lifetime appropriately. 

#include <TSS_T.h>
Collaboration diagram for ACE_TSS< TYPE >:
Collaboration graph
[legend]

List of all members.
Public Member Functions
 	ACE_TSS (TYPE *ts_obj=0)
virtual 	~ACE_TSS (void)
TYPE * 	ts_object (TYPE *new_ts_obj)
virtual TYPE * 	make_TSS_TYPE (void) const
 	Hook for construction parameters.
void 	dump (void) const
 	Dump the state of an object.
Accessors

All accessors return a pointer to the calling thread's copy of the TYPE data. The pointer may be 0 on error conditions or if the calling thread's copy of the data has not yet been set. See specific method descriptions for complete details.
TYPE * 	ts_object (void) const
TYPE * 	operator-> () const
 	operator TYPE * (void) const
Protected Member Functions
TYPE * 	ts_get (void) const
int 	ts_init (void)
void 	operator= (const ACE_TSS< TYPE > &)
 	ACE_TSS (const ACE_TSS< TYPE > &)
Protected Attributes
TYPE * 	type_
 	This implementation only works for non-threading systems...
Detailed Description
template<class TYPE>
class ACE_TSS< TYPE >

Allows objects that are "physically" in thread specific storage (i.e., private to a thread) to be accessed as though they were "logically" global to a program.

This class helps to maintain a separate copy of an object for each thread that needs access to it. All threads access a single instance of ACE_TSS to obtain a pointer to a thread-specific copy of a TYPE object. Using a pointer to TYPE in TSS instead of TYPE itself is useful because, in addition to avoiding copies on what may be a complex class, it allows assignment of objects to thread-specific data that have arbitrarily complex constructors.

When the ACE_TSS object is destroyed, all threads's instances of the data are deleted.

Modern compilers have no problem using a built-in type for TYPE. However, if you must use an older compiler that won't work with a built-in type, the ACE_TSS_Type_Adapter class template, below, can be used for adapting built-in types to work with ACE_TSS.

Note:
    Beware when creating static instances of this type (as with any other, btw). The unpredictable order of initialization across different platforms may cause a situation where one uses the instance before it is fully initialized. That's why typically instances of this type are dynamicaly allocated. On the stack it is typically allocated inside the ACE_Thread::svc() method which limits its lifetime appropriately. 

Constructor & Destructor Documentation
template<class TYPE>
ACE_TSS< TYPE >::ACE_TSS 	( 	TYPE *  	ts_obj = 0 	 )  	[inline]

Default constructor. Can also initialize this ACE_TSS instance, readying it for use by the calling thread as well as all other threads in the process. If the constructor does not initialize this object, the first access to it will perform the initialization, which could possibly (under odd error conditions) fail.

Parameters:
    	ts_obj 	If non-zero, this object is initialized for use by all threads and ts_obj is used to set the thread-specific value for the calling thread. Other threads use the ts_object (TYPE *) method to set a specific value.

template<class TYPE >
ACE_TSS< TYPE >::~ACE_TSS 	( 	void  		 )  	[inline, virtual]

Deregister this object from thread-specific storage administration. Will cause all threads' copies of TYPE to be destroyed.
template<class TYPE>
ACE_TSS< TYPE >::ACE_TSS 	( 	const ACE_TSS< TYPE > &  		 )  	[protected]
Member Function Documentation
template<class TYPE >
void ACE_TSS< TYPE >::dump 	( 	void  		 )  	const [inline]

Dump the state of an object.

Reimplemented in ACE_TSS_Connection.
template<class TYPE >
TYPE * ACE_TSS< TYPE >::make_TSS_TYPE 	( 	void  		 )  	const [inline, virtual]

Hook for construction parameters.

Reimplemented in ACE_TSS_Connection.
template<class TYPE >
ACE_TSS< TYPE >::operator TYPE * 	( 	void  		 )  	const [inline]

Obtain a pointer to the calling thread's TYPE object. If this ACE_TSS object hasn't been initialized, this method will initialize it as a side-affect. If the calling thread has not set a value, a default-constructed instance of TYPE is allocated and it becomes the thread's instance.

Returns:
    The calling thread's copy of the data. The returned pointer may be 0 under odd error conditions; check errno for further information. 

template<class TYPE >
TYPE * ACE_TSS< TYPE >::operator-> 	( 	void  		 )  	const [inline]

Use a "smart pointer" to get the thread-specific data associated with this object. If this ACE_TSS object hasn't been initialized, this method will initialize it as a side-affect. If the calling thread has not set a value, a default-constructed instance of TYPE is allocated and it becomes the thread's instance.

Returns:
    The calling thread's copy of the data. The returned pointer may be 0 under odd error conditions; check errno for further information. 

template<class TYPE>
void ACE_TSS< TYPE >::operator= 	( 	const ACE_TSS< TYPE > &  		 )  	[protected]
template<class TYPE >
TYPE * ACE_TSS< TYPE >::ts_get 	( 	void  		 )  	const [inline, protected]

Actually implements the code that retrieves the object from thread-specific storage.
template<class TYPE >
int ACE_TSS< TYPE >::ts_init 	( 	void  		 )  	[inline, protected]

Factors out common code for initializing TSS. This must NOT be called with the lock held...
template<class TYPE>
TYPE * ACE_TSS< TYPE >::ts_object 	( 	void  		 )  	const [inline]

Get the thread-specific object for this object.

Returns:
    0 if the object has never been initialized, otherwise returns the calling thread's copy of the data. The returned pointer may be 0 under odd error conditions; check errno for further information. 

template<class TYPE>
TYPE * ACE_TSS< TYPE >::ts_object 	( 	TYPE *  	new_ts_obj 	 )  	[inline]

Set the thread-specific object for the calling thread. If this object has not been initialized yet, this method performs the initialization.

Parameters:
    	new_ts_obj 	The new value for the calling thread's copy of this object.

Returns:
    The previous value of the calling thread's copy of this object; 0 if there was no previous value. This method also returns 0 on errors. To tell the difference between an error and a returned 0 pointer, it's recommended that one set errno to 0 prior to calling ts_object() and check for a new errno value if ts_object() returns 0. 

Member Data Documentation
template<class TYPE>
TYPE* ACE_TSS< TYPE >::type_ [protected]

This implementation only works for non-threading systems...
The documentation for this class was generated from the following files:

    TSS_T.h
    TSS_T.cpp
    TSS_T.inl


			9.1.3.3
		9.1.4 event
#ifndef EVENT_H
#define EVENT_H

/*
 * Copyright (c) 2007, 2008 Cisco Systems, Inc. This program contains
 * proprietary and confidential information. All rights reserved except
 * as may be permitted by prior written consent.
 *
 */

#include "ForwardPtrs.h"
#include "RefCountedObject.h"
#include "Exception.h"
#include "AcsDebugLog.h"

#include <string>

class Context;

/**
 * Provide base class for events passed to handlers
 */
class Event : public LockedRefCountedObject
{
    public:
        /**
         * Key type for the event
         */
        typedef std::string Key_t;

        /**
         * designed to server as base class
         */
        virtual ~Event ();

        /**
         * \return the key assosiated with this event
         */
        const Key_t &getKey () const;

        virtual Context *getContext ();



    protected:
        /**
         * for derivation only
         */
        Event (const Key_t &key, Event *pPreviousEvent = 0);

    protected:
//        AcsDebugLog m_log;

    private:
        // event serves as trasport for the stack
        // this can be changed by using TSS 
        // but that will be considered later
        friend class EventDispatcher;
        void setStack (EventStack *pStack);
        EventStack *getStack ();

        friend class EventStack;
        /**
         * should be overrided by base classes that contain Context
         * \throw e - the parameter exception
         */
        virtual void setUncaughtStdException (const std::exception &e);

        Event (const Event &other);
        Event &operator = (const Event &rhs);

        Key_t m_key;
        EventStack *m_pStack;
};


#endif // EVENT_H

		9.1.5 AcsEvent

			9.1.5.1 Header


/*
 * Copyright (c) 2006, 2008 Cisco Systems, Inc.  This program contains
 * proprietary and confidential information.  All rights reserved except
 * as may be permitted by prior written consent.
 *
 */

#ifndef ACSEVENT_H
#define ACSEVENT_H


/**
 * This file defines the AcsEvent base class.
 */

#include "Event.h"
#include "Context.h"
#include <string>


class ContextValidationTable;


/**
 * This class represents the base event class that is sent 
 * and received by the event handler
 *
 */

class AcsEvent : public Event
{
public:
    /**
     * The Key for the AcsEvent - the Name
     *
     */
    typedef const char* Key_t;
     
    /**
     * Get the Context
     *
     */
    virtual Context* getContext();
    Context* releaseContext();
    void replaceContext(Context *pContext );

protected:
    AcsEvent* m_pSourceEvent;
    Context* m_pContext;
    bool m_bDeleteContextInDestructor;

    /**
     * Construct an AcsEvent of a given Type, optionally basing it on an existing source AcsEvent
     *
     */
    AcsEvent (const Event::Key_t &key, AcsEvent* pSourceEvent = 0 );

    /**
     * Construct an AcsEvent of a given Type, basing it on an existing context (which will be cloned)
     *
     */
    //AcsEvent (const Event::Key_t &key, const Context* pContext );


public:     
    virtual ~AcsEvent();

private:

    virtual void setUncaughtStdException (const std::exception &e);
    virtual void setUncaughtAcsException (const Exception &e);

    // Don't allow the copy constructor or the assignment operator to be called
    // these are explicitly not implemented
    AcsEvent( AcsEvent& );
    AcsEvent& operator=( AcsEvent& );

};



#endif /* ACSEVENT_H */

			9.1.5.2 Suspend/Resume example

void RadiusClientListener::onRawBufferEvent (RadiusClientRawBufferEvent* pEvent)
{
    validateContext (pEvent);
    // Suspend Event
    TheDispatcher ()->suspend (pEvent); 
    // Allocate Request
    RadiusClient::Request* pRequest = new RadiusClient::Request (pEvent);
    // Round-Robin over Connections - According to Connection-ID defined on Context by RadiusClientHandler
    const size_t cid = determineConnectionId(pEvent->getContext());
    // Process Request
    m_pConnection [cid]-> processRequest (pRequest);
}


void RadiusClientListener::onResponseTo (RadiusClient::Request* pRequest)
{
    if (pRequest)
    {
        // Store Event
        RadiusClientRawBufferEvent* pEvent = pRequest->event;
        // Free Allocation
        delete pRequest;
        pRequest = NULL;
        // Resume Event
        AAA_LOG_DEBUG (RCLog,NULL) <<"onResponseTo: Request Deleted - Resume Event";
        TheDispatcher ()->resume (pEvent);
    }
    // ELSE - ERROR
}

			9.1.5.3
		9.1.6 RefCountedObject
#ifndef REFCOUNTEDOBJECT_H
#define REFCOUNTEDOBJECT_H

/*
 * Copyright (C) 2007 by Cisco Systems, Inc. This program contains
 * proprietary and confidential information. All rights reserved except
 * as may be permitted by prior written consent.
 *
 */

#include "ace/Lock_Adapter_T.h"
#include "ace/Atomic_Op.h"
#include "ace/Thread_Mutex.h"

template <class CounterType>
class RefCountedObject
{
    public:
        RefCountedObject ();
        virtual ~RefCountedObject ();
        long addRef ();
        long release ();

    private:
        RefCountedObject (const RefCountedObject &other);
        RefCountedObject &operator = (const RefCountedObject &rhs);
        CounterType m_refCount;
};

template <class CounterType>
RefCountedObject<CounterType>::RefCountedObject ()
    :   m_refCount (1)
{
}
        
template <class CounterType>
RefCountedObject<CounterType>::~RefCountedObject ()
{
}

// increment refference count of the object
// \return Current refference count.
template <class CounterType>
long RefCountedObject<CounterType>::addRef ()
{
    return ++m_refCount;
}

// decrement reffernce count of the object
// \return Current refference count.
template <class CounterType>
long RefCountedObject<CounterType>::release ()
{
    long refCount = --m_refCount;
    if (refCount == 0)
    {
        delete this;
        return 0;
    }
    return refCount;
}

typedef RefCountedObject<ACE_Atomic_Op<ACE_Thread_Mutex, long> > LockedRefCountedObject;
typedef RefCountedObject<long> UnlockedRefCountedObject;

#endif // REFCOUNTEDOBJECT_H

		9.1.7 Context

			9.1.7.1 Header
#ifndef CONTEXT_H
#define CONTEXT_H

/*
 * Copyright (c) 2007-2011 by Cisco Systems, Inc. This program contains
 * proprietary and confidential information. All rights reserved except
 * as may be permitted by prior written consent.
 *
 */

#include <map>

#include "DictionaryKey.h"
#include "ConfigManagerDefs.h"
#include "AttributeFactory.h"
#include "AttributeSet.h"
#include "DictionaryException.h"

class DictionaryManager;

class Context
{
    private:
        Context (const Context &other);
        Context &operator = (const Context &rhs);

    public:
        static const DictionaryKey Request;
        static const DictionaryKey Response;
        static const DictionaryKey Session;

        static const DictionaryKey Nested;

        Context (VersionID version, bool bIncCounter = true);
        Context (bool bIncCounter = true);
        ~Context ();

        Context *clone (VersionID version) const;


        VersionID getVersion () const;
        int64_t getId () const;

        AttributeSet *getAttributeSet (const DictionaryKey &key);
        AttributeSet *getAttributeSetNoFail (const DictionaryKey &key);
        const AttributeSet *getAttributeSet (const DictionaryKey &key) const;

        AttributeSet *releaseAttributeSet (const DictionaryKey &key);
        void removeAttributeSet (const DictionaryKey &key);
        void addAttributeSet (AttributeSet *pAttributeSet);

        // Cisco-AV-Pair
        bool getCiscoAVPair(const DictionaryKey& attributeSetKey, const std::string& name, std::string& value);
        int getCiscoAVPair(const DictionaryKey& attributeSetKey, const std::string& name, OctetBuffer& value);
        bool hasCiscoAVPair(const DictionaryKey& attributeSetKey, const std::string& name);

        // int32_t
        void setAsInt32 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, int32_t value);  
        void appendAsInt32 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, int32_t value);  
        int32_t getAsInt32 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey) const;  
        int32_t getAtAsInt32 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, size_t index) const;  

        // uint32_t
        void setAsUnsigned32 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, uint32_t value);  
        void appendAsUnsigned32 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, uint32_t value);  
        uint32_t getAsUnsigned32 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey) const;  
        uint32_t getAtAsUnsigned32 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, size_t index) const;  

        // int64_t
        void setAsInt64 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, int64_t value);  
        void appendAsInt64 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, int64_t value);  
        int64_t getAsInt64 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey) const;  
        int64_t getAtAsInt64 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, size_t index) const;  

        // uint64_t
        void setAsUnsigned64 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, uint64_t value);  
        void appendAsUnsigned64 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, uint64_t value);  
        uint64_t getAsUnsigned64 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey) const;  
        uint64_t getAtAsUnsigned64 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, size_t index) const;  

        // bool
        void setAsBoolean (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, bool value);  
        void appendAsBoolean (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, bool value);  
        bool getAsBoolean (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey) const;  
        bool getAtAsBoolean (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, size_t index) const;  

        // float32_t
        void setAsFloat32 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, float32_t value);  
        void appendAsFloat32 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, float32_t value);  
        float32_t getAsFloat32 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey) const;  
        float32_t getAtAsFloat32 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, size_t index) const;  
        /*
        // float64_t
        void setAsFloat64 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, float64_t value);  
        void appendAsFloat64 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, float64_t value);  
        float64_t getAsFloat64 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey) const;  
        float64_t getAtAsFloat64 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, size_t index) const;  

        // float128_t
        void setAsFloat128 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, float128_t value);  
        void appendAsFloat128 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, float128_t value);  
        float128_t getAsFloat128 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey) const;  
        float128_t getAtAsFloat128 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, size_t index) const;  
        */

        // std::string and const char*
        void setAsString (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, const std::string &value);  
        void appendAsString (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, const std::string &value);  
        void setAsString (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, const char* pszValue);  
        void appendAsString (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, const char* pszValue);  
        const std::string &getAsString (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey) const;  
        const std::string &getAtAsString (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, size_t index) const;  

        // OctetBuffer
        void setAsOctetString (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, const OctetBuffer &value);  
        void setAsOctetString (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, const byte_t *value, size_t length);  
        void appendAsOctetString (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, const OctetBuffer &value);  
        void appendAsOctetString (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, const byte_t *value, size_t length);  
        const OctetBuffer &getAsOctetString (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey) const;  
        const OctetBuffer &getAtAsOctetString (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, size_t index) const;  

        // in_addr
        void setAsIPv4 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, const in_addr &value);  
        void appendAsIPv4 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, const in_addr &value);  
        const in_addr &getAsIPv4 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey) const;  
        const in_addr &getAtAsIPv4 (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, size_t index) const;  

        // OpaqueObject
        void setAsOpaqueObject (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, OpaqueObject *value);  
        void appendAsOpaqueObject (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, OpaqueObject *value);  
        OpaqueObject *getAsOpaqueObject (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey) const;  
        OpaqueObject *getAtAsOpaqueObject (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, size_t index) const;  

        // AttributeSet
        void setAsAttributeSet (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, AttributeSet *value);  
        void appendAsAttributeSet (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, AttributeSet *value);  
        AttributeSet *getAsAttributeSet (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey) const;  
        AttributeSet *getAtAsAttributeSet (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, size_t index) const;  
  
        size_t count (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey) const;  

        bool containsKey (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey) const;

        void remove (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey);  
        
        void enumerate (AttributeEnumerator *pEnumerator) const;

        // validations
        void assertExists (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey);
        void assertNotExists (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey);
        void assertEmpty (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey);
        void assertNotEmpty (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey);
        
        void assertEqual (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, const std::string &value);
        void assertNotEqual (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, const std::string &value);

        void setTag(const DictionaryKey& attributeSetKey, const DictionaryKey& attributeKey, int32_t tag); 
        int32_t getTag(const DictionaryKey& attributeSetKey, const DictionaryKey& attributeKey)const;
    private:
        void privateAddAttributeSet (AttributeSet *pAttributeSet);
        void append (const DictionaryKey &attributeSetKey, AttributePtr pAttribute);  
        const DictionaryAttribute *getDictionaryAttribute (const DictionaryKey &key) const;
        void throwOutOfRange (const std::string& attributeSetName, const DictionaryKey& attributeKey, size_t index)const;
        void throwNoAttributeSet (const DictionaryKey& attributeSetKey)const;
        void throwNoAttribute (const std::string& attributeSetName, const DictionaryKey& attributeKey)const;
        
        VersionID m_version;
        bool m_bIncCounter;
        int64_t m_id;
        typedef std::map<DictionaryKey, AttributeSet *> AttributeSets;
        AttributeSets m_sets;
        DictionaryManager *m_pDictionaryManager;
};



#endif // CONTEXT_H
id=__ACS_EH_Usage__
			9.1.7.2 usage
- Events contain pointer to Context

- Event CTOR will generate new Context, unless new Event (pExistEvent) is called (in which case Context ptr is copied)

- Context contain AttributeSets (Dictionaries), accessible for R/W w/ (DictionaryKey, Attribute Key)
ex:
    isSent = ctx->containsKey(Context::Session, Acs::RawPacket) &&
             ctx->containsKey(Context::Request, Acs::SourcePort) &&
             ctx->containsKey(Context::Request, Acs::SourceIPAddress) &&
             ctx->containsKey(Context::Request, Acs::RadiusIdentifier) &&
             ctx->containsKey(Context::Request, Acs::SocketHandle);

    if (isSent)
    {
        const OctetBuffer& rawPacket = ctx->getAsOctetString(Context::Session, Acs::RawPacket);

        ipv4address_t NASIP = ctx->getAsInt32(Context::Request, Acs::SourceIPAddress);
        uint32_t iPort      = ctx->getAsUnsigned32(Context::Request, Acs::SourcePort);
        byte_t iId          = ctx->getAsUnsigned32(Context::Request, Acs::RadiusIdentifier);
        SOCKET sock         = ctx->getAsUnsigned32(Context::Request, Acs::SocketHandle);

- Can store OpaqueObject in AttributeSet (Request/Response/Session)
        // OpaqueObject
        void setAsOpaqueObject (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, OpaqueObject *value);  
        void appendAsOpaqueObject (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, OpaqueObject *value);  
        OpaqueObject *getAsOpaqueObject (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey) const;  
        OpaqueObject *getAtAsOpaqueObject (const DictionaryKey &attributeSetKey, const DictionaryKey &attributeKey, size_t index) const;  


			9.1.7.3
		9.1.8
	9.2

10. Code Reviews

	10.1 Management 

		10.1.1 Subject: Code review for bug Bug CSCuf74902 (Remotesyslog Directoryfiles in secondary not deleted during Register)
Hi Anatoly,

Looks good. C2D

Thanks,
Alon

From: Anatoly Dubrovsky (adubrovs) 
Sent: Tuesday, June 11, 2013 12:25 PM
To: Alon Barak (albarak)
Cc: Yosi Izaq (yizaq); acs5-codereview(mailer list)
Subject: Code review for bug Bug CSCuf74902 (Remotesyslog Directoryfiles in secondary not deleted during Register)

Hi Alon,
 
Please, review the next file:

/vob/nm_acs/acs/mgmt/replication/src/main/java/com/cisco/nm/acs/mgmt/replication/Registration.java

view: adubrovs6__adubrovs.int.acs5_0.lx
activity: Bug_CSCuf74902/vob/nmtgre_proj
 
Thanks,
Anatoly.


	10.2

11.


