.........................................Table Of Contents...............................................................
1. arithmetic <URL:#tn=1. arithmetic>
	1.1 expansion. <URL:#tn=	1.1 expansion.>
	1.2 floating point arithmetic bash <URL:#tn=	1.2 floating point arithmetic bash>
		1.2.1  via bc <URL:#tn=		1.2.1  via bc>
		1.2.2 <URL:#tn=		1.2.2>
	1.3 Floating Point Comparison in Shell Script <URL:#tn=	1.3 Floating Point Comparison in Shell Script>
		1.3.1 Can you please suggest to me the syntax for doing floating point comparison in a Bash script? <URL:#tn=		1.3.1 Can you please suggest to me the syntax for doing floating point comparison in a Bash script?>
		1.3.2 My example <URL:#tn=		1.3.2 My example>
		1.3.3 <URL:#tn=		1.3.3>
	1.4 Arithmetic Expansion <URL:#tn=	1.4 Arithmetic Expansion>
	1.5 <URL:#tn=	1.5>
2. command history. <URL:#tn=2. command history.>
	2.1. last command <URL:#tn=	2.1. last command>
	2.2 last prefix command <URL:#tn=	2.2 last prefix command>
	2.3 search history <URL:#tn=	2.3 search history>
	2.4 Argument of last command !$ <URL:#tn=	2.4 Argument of last command !$>
3. parameter of previous commands. <URL:#tn=3. parameter of previous commands.>
	3.1 last parameter of previous command !$ <URL:#tn=	3.1 last parameter of previous command !$>
	3.2 all paramters of previous command !* <URL:#tn=	3.2 all paramters of previous command !*>
	3.4 replace typos in previous command. the ^old^new... <URL:#tn=	3.4 replace typos in previous command. the ^old^new...>
	3.5 substitute cont. <URL:#tn=	3.5 substitute cont.>
		3.5.1  1 time substitute <URL:#tn=		3.5.1  1 time substitute>
		3.5.2 global substitute (of last command - !!) <URL:#tn=		3.5.2 global substitute (of last command - !!)>
	3.6 More bash prompt tips <URL:#tn=	3.6 More bash prompt tips>
	3.7 The Definitive Guide to Bash Command Line History <URL:#tn=	3.7 The Definitive Guide to Bash Command Line History>
	3.8 My examples <URL:#tn=	3.8 My examples>
	3.9 Bash History Cheat Sheet <URL:#tn=	3.9 Bash History Cheat Sheet>
	3.10 $ man  -P 'less -p ^HISTORY\ EXPANSION' bash <URL:#tn=	3.10 $ man  -P 'less -p ^HISTORY\ EXPANSION' bash>
4. Arrays <URL:#tn=4. Arrays>
		4.1 Iteration <URL:#tn=		4.1 Iteration>
		4.2 many commands for same argument <URL:#tn=		4.2 many commands for same argument>
		4.3 The Ultimate Bash Array Tutorial with 15 Examples <URL:#tn=		4.3 The Ultimate Bash Array Tutorial with 15 Examples>
			4.3.1 Declaring an Array and Assigning values <URL:#tn=			4.3.1 Declaring an Array and Assigning values>
			4.3.2 Initializing an array during declaration <URL:#tn=			4.3.2 Initializing an array during declaration>
			4.3.3 Print the Whole Bash Array <URL:#tn=			4.3.3 Print the Whole Bash Array>
			4.3.4 Length of the Bash Array <URL:#tn=			4.3.4 Length of the Bash Array>
			4.3.5 Length of the nth Element in an Array <URL:#tn=			4.3.5 Length of the nth Element in an Array>
			4.3.6 Extraction by offset and length for an array <URL:#tn=			4.3.6 Extraction by offset and length for an array>
			4.3.7 Extraction with offset and length, for a particular element of an array <URL:#tn=			4.3.7 Extraction with offset and length, for a particular element of an array>
			4.3.8 Search and Replace in an array elements <URL:#tn=			4.3.8 Search and Replace in an array elements>
			4.3.9  Add an element to an existing Bash Array <URL:#tn=			4.3.9  Add an element to an existing Bash Array>
			4.3.10 Remove an Element from an Array <URL:#tn=			4.3.10 Remove an Element from an Array>
			4.3.11 Remove Bash Array Elements using Patterns <URL:#tn=			4.3.11 Remove Bash Array Elements using Patterns>
			4.3.12 Copying an Array <URL:#tn=			4.3.12 Copying an Array>
			4.3.13 Concatenation of two Bash Arrays <URL:#tn=			4.3.13 Concatenation of two Bash Arrays>
			4.3.14 Deleting an Entire Array <URL:#tn=			4.3.14 Deleting an Entire Array>
			4.3.15  Load Content of a File into an Array <URL:#tn=			4.3.15  Load Content of a File into an Array>
		4.4 Merge two sorted array into third sorted <URL:#tn=		4.4 Merge two sorted array into third sorted>
			4.4.1 Snip: /vob/nm_acs/acs/mgmt/cli/cars/src/main/ctrlcmd/patch-wrapper.sh <URL:#tn=			4.4.1 Snip: /vob/nm_acs/acs/mgmt/cli/cars/src/main/ctrlcmd/patch-wrapper.sh>
		4.5 <URL:#tn=		4.5>
5. Strings <URL:#tn=5. Strings>
	5.1 string concatenation <URL:#tn=	5.1 string concatenation>
6. shell loops <URL:#tn=6. shell loops>
	6.1 do something on a list <URL:#tn=	6.1 do something on a list>
	6.2 C like loop <URL:#tn=	6.2 C like loop>
7. Keyboard shortcuts, command line options, shell prompt shortcuts <URL:#tn=7. Keyboard shortcuts, command line options, shell prompt shortcuts>
	7.1 Ctrl, alt combos <URL:#tn=	7.1 Ctrl, alt combos>
	7.2 History shortcuts <URL:#tn=	7.2 History shortcuts>
	7.3 <URL:#tn=	7.3>
8. Test operators <URL:#tn=8. Test operators>
9. Aliases <URL:#tn=9. Aliases>
10. prompt <URL:#tn=10. prompt>
11. Macros <URL:#tn=11. Macros>
12. Advanced Bash-Scripting Guide <URL:#tn=12. Advanced Bash-Scripting Guide>
	12.1 Basics (chapter 3) <URL:#tn=	12.1 Basics (chapter 3)>
		12.1.1 Special Characters <URL:#tn=		12.1.1 Special Characters>
		12.1.2 Introduction to Variables and Parameters (Chapter 4) <URL:#tn=		12.1.2 Introduction to Variables and Parameters (Chapter 4)>
			12.1.2.1  Variable Substitution <URL:#tn=			12.1.2.1  Variable Substitution>
			12.1.2.2 Variable assignment <URL:#tn=			12.1.2.2 Variable assignment>
			12.1.2.3 Bash Variables Are Untyped <URL:#tn=			12.1.2.3 Bash Variables Are Untyped>
			12.1.2.4 Special variable types <URL:#tn=			12.1.2.4 Special variable types>
	12.2 Chapter 5. Quoting <URL:#tn=	12.2 Chapter 5. Quoting>
		12.2.1 Quoting Variables <URL:#tn=		12.2.1 Quoting Variables>
		12.2.2 Escaping <URL:#tn=		12.2.2 Escaping>
	12.3 Chapter 6. Exit and Exit Status <URL:#tn=	12.3 Chapter 6. Exit and Exit Status>
	12.4 Chapter 7. Tests <URL:#tn=	12.4 Chapter 7. Tests>
		12.4.1. Test Constructs <URL:#tn=		12.4.1. Test Constructs>
		12.4.2. File test operators <URL:#tn=		12.4.2. File test operators>
		12.4.3. Other Comparison Operators <URL:#tn=		12.4.3. Other Comparison Operators>
			12.4.3.1 integer comparison <URL:#tn=			12.4.3.1 integer comparison>
			12.4.3.2 string comparison <URL:#tn=			12.4.3.2 string comparison>
		12.4.4. Nested if/then Condition Tests <URL:#tn=		12.4.4. Nested if/then Condition Tests>
	12.5 Chapter 8. Operations and Related Topics <URL:#tn=	12.5 Chapter 8. Operations and Related Topics>
		12.5.1 Operators <URL:#tn=		12.5.1 Operators>
			12.5.1.1 Assignment <URL:#tn=			12.5.1.1 Assignment>
			12.5.1.2 Arithmetic operators <URL:#tn=			12.5.1.2 Arithmetic operators>
			12.5.1.3 Bitwise operators. <URL:#tn=			12.5.1.3 Bitwise operators.>
			12.5.1.4 Logical operators <URL:#tn=			12.5.1.4 Logical operators>
		12.5.2 Numerical constants <URL:#tn=		12.5.2 Numerical constants>
	12.6 Part 3. Beyond the Basics. Chapter 9. Variables Revisited <URL:#tn=	12.6 Part 3. Beyond the Basics. Chapter 9. Variables Revisited>
		12.6.1 Internal Variables, builtin variables <URL:#tn=		12.6.1 Internal Variables, builtin variables>
			12.6.1.1 Bash internals <URL:#tn=			12.6.1.1 Bash internals>
			12.6.1.2 Bash internals, IFS <URL:#tn=			12.6.1.2 Bash internals, IFS>
				12.6.1.2.1 My example, arrays, elements, containing space <URL:#tn=				12.6.1.2.1 My example, arrays, elements, containing space>
				12.6.1.2.2 <URL:#tn=				12.6.1.2.2>
			12.6.1.3 more bash internals <URL:#tn=			12.6.1.3 more bash internals>
			12.6.1.4 Reading input <URL:#tn=			12.6.1.4 Reading input>
			12.6.1.5 Timing <URL:#tn=			12.6.1.5 Timing>
			12.6.1.6 IDs <URL:#tn=			12.6.1.6 IDs>
			12.6.1.7 Positional Parameters <URL:#tn=			12.6.1.7 Positional Parameters>
				12.6.1.7.1 Iterate over positional parameters <URL:#tn=				12.6.1.7.1 Iterate over positional parameters>
			12.6.1.8 Other Special Parameters <URL:#tn=			12.6.1.8 Other Special Parameters>
		12.6.2 Manipulating Strings <URL:#tn=		12.6.2 Manipulating Strings>
			12.6.2.1 String Length <URL:#tn=			12.6.2.1 String Length>
				12.6.2.2 Length of Matching Substring at Beginning of String <URL:#tn=				12.6.2.2 Length of Matching Substring at Beginning of String>
				12.6.2.3 Index <URL:#tn=				12.6.2.3 Index>
				12.6.2.4 Substring Extraction <URL:#tn=				12.6.2.4 Substring Extraction>
				12.6.2.5 substract from string <URL:#tn=				12.6.2.5 substract from string>
				12.6.2.6 string (pattern) match <URL:#tn=				12.6.2.6 string (pattern) match>
				12.6.2.8 Substring Removal <URL:#tn=				12.6.2.8 Substring Removal>
				12.6.2.9 Substring Replacement <URL:#tn=				12.6.2.9 Substring Replacement>
				12.6.2.10 Manipulating strings using awk <URL:#tn=				12.6.2.10 Manipulating strings using awk>
		12.6.3 Parameter Substitution <URL:#tn=		12.6.3 Parameter Substitution>
			12.6.3.1 Use Parameter/Variable <URL:#tn=			12.6.3.1 Use Parameter/Variable>
			12.6.3.2 If parameter not set, use default. <URL:#tn=			12.6.3.2 If parameter not set, use default.>
			12.6.3.3 If parameter not set, set it to default. <URL:#tn=			12.6.3.3 If parameter not set, set it to default.>
			12.6.3.4 If parameter set, use alt_value, else use null string. <URL:#tn=			12.6.3.4 If parameter set, use alt_value, else use null string.>
			12.6.3.5 If parameter set, use it, else print err_msg. <URL:#tn=			12.6.3.5 If parameter set, use it, else print err_msg.>
			12.6.3.6 Parameter substitution and/or expansion. <URL:#tn=			12.6.3.6 Parameter substitution and/or expansion.>
			12.6.3.7 Removal of part of string <URL:#tn=			12.6.3.7 Removal of part of string>
			12.6.3.8 Variable expansion / Substring replacement <URL:#tn=			12.6.3.8 Variable expansion / Substring replacement>
		12.6.4 Typing variables: declare or typeset <URL:#tn=		12.6.4 Typing variables: declare or typeset>
		12.6.5 Indirect References <URL:#tn=		12.6.5 Indirect References>
		12.6.6 $RANDOM: generate random integer <URL:#tn=		12.6.6 $RANDOM: generate random integer>
			12.6.6.1 Generating random numbers <URL:#tn=			12.6.6.1 Generating random numbers>
			12.6.6.2 Picking a random card from a deck <URL:#tn=			12.6.6.2 Picking a random card from a deck>
			12.6.6.3 Brownian Motion Simulation <URL:#tn=			12.6.6.3 Brownian Motion Simulation>
			12.6.6.4 Random between values <URL:#tn=			12.6.6.4 Random between values>
			12.6.6.5 Rolling a single die with RANDOM <URL:#tn=			12.6.6.5 Rolling a single die with RANDOM>
			12.6.6.6 Reseeding RANDOM <URL:#tn=			12.6.6.6 Reseeding RANDOM>
			12.6.6.7 Pseudorandom numbers, using awk <URL:#tn=			12.6.6.7 Pseudorandom numbers, using awk>
		12.6.7 The Double Parentheses Construct <URL:#tn=		12.6.7 The Double Parentheses Construct>
	12.7 Chapter 10. Loops and Branches <URL:#tn=	12.7 Chapter 10. Loops and Branches>
		12.7.1 Loops <URL:#tn=		12.7.1 Loops>
			12.7.1.1 For Loops <URL:#tn=			12.7.1.1 For Loops>
				12.7.1.1.1 Example 10-1. Simple for loops <URL:#tn=				12.7.1.1.1 Example 10-1. Simple for loops>
				12.7.1.1.2 Example 10-2. for loop with two parameters in each [list] element <URL:#tn=				12.7.1.1.2 Example 10-2. for loop with two parameters in each [list] element>
				12.7.1.1.3 Example 10-3. Fileinfo: operating on a file list contained in a variable <URL:#tn=				12.7.1.1.3 Example 10-3. Fileinfo: operating on a file list contained in a variable>
				12.7.1.1.4 Example 10-4. Operating on files with a for loop <URL:#tn=				12.7.1.1.4 Example 10-4. Operating on files with a for loop>
				12.7.1.1.5 Example 10-5. Missing in [list] in a for loop <URL:#tn=				12.7.1.1.5 Example 10-5. Missing in [list] in a for loop>
				12.7.1.1.6 Example 10-6. Generating the [list] in a for loop with command substitution <URL:#tn=				12.7.1.1.6 Example 10-6. Generating the [list] in a for loop with command substitution>
				12.7.1.1.7 Example 10-7. A grep replacement for binary files <URL:#tn=				12.7.1.1.7 Example 10-7. A grep replacement for binary files>
				12.7.1.1.8 Example 10-8. Listing all users on the system <URL:#tn=				12.7.1.1.8 Example 10-8. Listing all users on the system>
				12.7.1.1.9 Example 10-9. Checking all the binaries in a directory for authorship <URL:#tn=				12.7.1.1.9 Example 10-9. Checking all the binaries in a directory for authorship>
				12.7.1.1.10 Example 10-10. Listing the symbolic links in a directory <URL:#tn=				12.7.1.1.10 Example 10-10. Listing the symbolic links in a directory>
				12.7.1.1.11 Example 10-11. Symbolic links in a directory, saved to a file <URL:#tn=				12.7.1.1.11 Example 10-11. Symbolic links in a directory, saved to a file>
				12.7.1.1.12 Example 10-12. A C-style for loop <URL:#tn=				12.7.1.1.12 Example 10-12. A C-style for loop>
				12.7.1.1.13 Example 10-13. Using efax in batch mode <URL:#tn=				12.7.1.1.13 Example 10-13. Using efax in batch mode>
			12.7.1.2 While Loops <URL:#tn=			12.7.1.2 While Loops>
				12.7.1.2.1 Example 10-14. Simple while loop <URL:#tn=				12.7.1.2.1 Example 10-14. Simple while loop>
				12.7.1.2.2 Example 10-15. Another while loop <URL:#tn=				12.7.1.2.2 Example 10-15. Another while loop>
				12.7.1.2.3 Example 10-16. while loop with multiple conditions <URL:#tn=				12.7.1.2.3 Example 10-16. while loop with multiple conditions>
				12.7.1.2.4 Example 10-17. C-style syntax in a while loop <URL:#tn=				12.7.1.2.4 Example 10-17. C-style syntax in a while loop>
			12.7.1.3 Until Loops <URL:#tn=			12.7.1.3 Until Loops>
				12.7.1.3.1 Example 10-18. until loop <URL:#tn=				12.7.1.3.1 Example 10-18. until loop>
		12.7.2 Nested Loops <URL:#tn=		12.7.2 Nested Loops>
		12.7.3 Loop Control <URL:#tn=		12.7.3 Loop Control>
			12.7.3.1 Example 10-20. Effects of break and continue in a loop <URL:#tn=			12.7.3.1 Example 10-20. Effects of break and continue in a loop>
			12.7.3.2 Example 10-21. Breaking out of multiple loop levels <URL:#tn=			12.7.3.2 Example 10-21. Breaking out of multiple loop levels>
			12.7.3.3 Example 10-22. Continuing at a higher loop level <URL:#tn=			12.7.3.3 Example 10-22. Continuing at a higher loop level>
			12.7.3.4 Example 10-23. Using continue N in an actual task <URL:#tn=			12.7.3.4 Example 10-23. Using continue N in an actual task>
		12.7.4 Testing and Branching <URL:#tn=		12.7.4 Testing and Branching>
			12.7.4.1 case (in) / esac <URL:#tn=			12.7.4.1 case (in) / esac>
				12.7.4.1.1 Example 10-24. Using case <URL:#tn=				12.7.4.1.1 Example 10-24. Using case>
				12.7.4.1.2 Example 10-25. Creating menus using case <URL:#tn=				12.7.4.1.2 Example 10-25. Creating menus using case>
				12.7.4.1.3 Example 10-26. Using command substitution to generate the case variable <URL:#tn=				12.7.4.1.3 Example 10-26. Using command substitution to generate the case variable>
				12.7.4.1.4 Example 10-27. Simple string matching <URL:#tn=				12.7.4.1.4 Example 10-27. Simple string matching>
				12.7.4.1.5 Example 10-28. Checking for alphabetic input <URL:#tn=				12.7.4.1.5 Example 10-28. Checking for alphabetic input>
	12.8 Chapter 11. Command Substitution <URL:#tn=	12.8 Chapter 11. Command Substitution>
		12.8.1 Basic usages <URL:#tn=		12.8.1 Basic usages>
		12.8.2 Precaustions and limitations <URL:#tn=		12.8.2 Precaustions and limitations>
		12.8.3 Example 11-1. Stupid script tricks <URL:#tn=		12.8.3 Example 11-1. Stupid script tricks>
		12.8.4 Example 11-2. Generating a variable from a loop <URL:#tn=		12.8.4 Example 11-2. Generating a variable from a loop>
		12.8.5 Possibilities of using command substitution <URL:#tn=		12.8.5 Possibilities of using command substitution>
		12.8.6 Note, `` form replaced by $() <URL:#tn=		12.8.6 Note, `` form replaced by $()>
		12.8.7 $() form, Example 11-3. Finding anagrams <URL:#tn=		12.8.7 $() form, Example 11-3. Finding anagrams>
	12.9 Chapter 12. Arithmetic Expansion <URL:#tn=	12.9 Chapter 12. Arithmetic Expansion>
	12.11 Part 4. Linux Commands <URL:#tn=	12.11 Part 4. Linux Commands>
		12.11.1 Chapter 14. Internal Commands and Builtins <URL:#tn=		12.11.1 Chapter 14. Internal Commands and Builtins>
			12.11.1.1 Example 14-1. A script that forks off multiple instances of itself <URL:#tn=			12.11.1.1 Example 14-1. A script that forks off multiple instances of itself>
			12.11.1.2 I/O <URL:#tn=			12.11.1.2 I/O>
				12.11.1.2.1 echo <URL:#tn=				12.11.1.2.1 echo>
				12.11.1.2.2 printf, formatted print, formatting output <URL:#tn=				12.11.1.2.2 printf, formatted print, formatting output>
					12.11.1.2.2.1 The printf command <URL:#tn=					12.11.1.2.2.1 The printf command>
				12.11.1.2.3 read <URL:#tn=				12.11.1.2.3 read>
					12.11.1.2.3.1 Example 14-3. Variable assignment, using read <URL:#tn=					12.11.1.2.3.1 Example 14-3. Variable assignment, using read>
					12.11.1.2.3.2 Example 14-4. What happens when read has no variable <URL:#tn=					12.11.1.2.3.2 Example 14-4. What happens when read has no variable>
					12.11.1.2.3.3 Example 14-5. Multi-line input to read <URL:#tn=					12.11.1.2.3.3 Example 14-5. Multi-line input to read>
					12.11.1.2.3.4 #Read a keypress without hitting ENTER. <URL:#tn=					12.11.1.2.3.4 #Read a keypress without hitting ENTER.>
					12.11.1.2.3.5 Example 14-6. Detecting the arrow keys <URL:#tn=					12.11.1.2.3.5 Example 14-6. Detecting the arrow keys>
					12.11.1.2.3.6 Example 14-7. Using read with file redirection, read lines and seperate fields <URL:#tn=					12.11.1.2.3.6 Example 14-7. Using read with file redirection, read lines and seperate fields>
					12.11.1.2.3.7 Example 14-8. Problems reading from a pipe <URL:#tn=					12.11.1.2.3.7 Example 14-8. Problems reading from a pipe>
			12.11.1.3 Filesystem <URL:#tn=			12.11.1.3 Filesystem>
				12.11.1.3.1 cd <URL:#tn=				12.11.1.3.1 cd>
				12.11.1.3.2 pwd <URL:#tn=				12.11.1.3.2 pwd>
				12.11.1.3.3 Dir stack commands <URL:#tn=				12.11.1.3.3 Dir stack commands>
				12.11.1.3.4 Example 14-9. Changing the current working directory <URL:#tn=				12.11.1.3.4 Example 14-9. Changing the current working directory>
			12.11.1.4 Variables <URL:#tn=			12.11.1.4 Variables>
				12.11.1.4.1 let <URL:#tn=				12.11.1.4.1 let>
				12.11.1.4.2 Example 14-10. Letting let do arithmetic. <URL:#tn=				12.11.1.4.2 Example 14-10. Letting let do arithmetic.>
				12.11.1.4.3 eval <URL:#tn=				12.11.1.4.3 eval>
				12.11.1.4.4 Example 14-11. Showing the effect of eval <URL:#tn=				12.11.1.4.4 Example 14-11. Showing the effect of eval>
				12.11.1.4.5 Example 14-12. Echoing the command-line parameters <URL:#tn=				12.11.1.4.5 Example 14-12. Echoing the command-line parameters>
				12.11.1.4.6 Example 14-13. Forcing a log-off <URL:#tn=				12.11.1.4.6 Example 14-13. Forcing a log-off>
				12.11.1.4.7 Example 14-14. A version of rot13 <URL:#tn=				12.11.1.4.7 Example 14-14. A version of rot13>
				12.11.1.4.8 Example 14-15. Using eval to force variable substitution in a Perl script <URL:#tn=				12.11.1.4.8 Example 14-15. Using eval to force variable substitution in a Perl script>
				12.11.1.4.9 set <URL:#tn=				12.11.1.4.9 set>
				12.11.1.4.10 Example 14-16. Using set with positional parameters <URL:#tn=				12.11.1.4.10 Example 14-16. Using set with positional parameters>
				12.11.1.4.11 Example 14-17. Reversing the positional parameters <URL:#tn=				12.11.1.4.11 Example 14-17. Reversing the positional parameters>
				12.11.1.4.12 Example 14-18. Reassigning the positional parameters <URL:#tn=				12.11.1.4.12 Example 14-18. Reassigning the positional parameters>
				12.11.1.4.13 unset <URL:#tn=				12.11.1.4.13 unset>
				12.11.1.4.14 Example 14-19. "Unsetting" a variable <URL:#tn=				12.11.1.4.14 Example 14-19. "Unsetting" a variable>
				12.11.1.4.15 export <URL:#tn=				12.11.1.4.15 export>
				12.11.1.4.16 Example 14-20. Using export to pass a variable to an embedded awk script <URL:#tn=				12.11.1.4.16 Example 14-20. Using export to pass a variable to an embedded awk script>
				12.11.1.4.17 declare, typeset <URL:#tn=				12.11.1.4.17 declare, typeset>
				12.11.1.4.18 Example 14-21. Using getopts to read the options/arguments passed to a script <URL:#tn=				12.11.1.4.18 Example 14-21. Using getopts to read the options/arguments passed to a script>
				12.11.1.4.19 Script Behavior <URL:#tn=				12.11.1.4.19 Script Behavior>
					12.11.1.4.19.1 source, . (dot command) <URL:#tn=					12.11.1.4.19.1 source, . (dot command)>
					12.11.1.4.19.2 exec <URL:#tn=					12.11.1.4.19.2 exec>
					12.11.1.4.19.3 shopt -s cdspell <URL:#tn=					12.11.1.4.19.3 shopt -s cdspell>
					12.11.1.4.19.4 caller <URL:#tn=					12.11.1.4.19.4 caller>
					12.11.1.4.19.5 type [cmd] <URL:#tn=					12.11.1.4.19.5 type [cmd]>
					12.11.1.4.19.6 hash [cmds] <URL:#tn=					12.11.1.4.19.6 hash [cmds]>
					12.11.1.4.19.7 help <URL:#tn=					12.11.1.4.19.7 help>
			12.11.1.5 Job Control Commands <URL:#tn=			12.11.1.5 Job Control Commands>
				12.11.1.5.1 jobs <URL:#tn=				12.11.1.5.1 jobs>
				12.11.1.5.2 disown <URL:#tn=				12.11.1.5.2 disown>
				12.11.1.5.3 fg, bg <URL:#tn=				12.11.1.5.3 fg, bg>
				12.11.1.5.4 Example 14-26. Waiting for a process to finish before proceeding <URL:#tn=				12.11.1.5.4 Example 14-26. Waiting for a process to finish before proceeding>
				12.11.1.5.5 Exit <URL:#tn=				12.11.1.5.5 Exit>
				12.11.1.5.6 times <URL:#tn=				12.11.1.5.6 times>
				12.11.1.5.7 kill <URL:#tn=				12.11.1.5.7 kill>
				12.11.1.5.8 killall <URL:#tn=				12.11.1.5.8 killall>
				12.11.1.5.9 command <URL:#tn=				12.11.1.5.9 command>
				12.11.1.5.10 builtin <URL:#tn=				12.11.1.5.10 builtin>
				12.11.1.5.11 enable <URL:#tn=				12.11.1.5.11 enable>
				12.11.1.5.12 autoload <URL:#tn=				12.11.1.5.12 autoload>
		12.11.2 Chapter 15. External Filters, Programs and Commands <URL:#tn=		12.11.2 Chapter 15. External Filters, Programs and Commands>
			12.11.2.1 Basic Commands <URL:#tn=			12.11.2.1 Basic Commands>
				12.11.2.1.1 ls, tags, ls, list files directories <URL:#tn=				12.11.2.1.1 ls, tags, ls, list files directories>
				    12.11.2.1.1.1  list only hidden files <URL:#tn=				    12.11.2.1.1.1  list only hidden files>
				    12.11.2.1.1.2 <URL:#tn=				    12.11.2.1.1.2>
				12.11.2.1.2 cat, tac <URL:#tn=				12.11.2.1.2 cat, tac>
				12.11.2.1.3 rev <URL:#tn=				12.11.2.1.3 rev>
				12.11.2.1.4 cp <URL:#tn=				12.11.2.1.4 cp>
				12.11.2.1.5 mv <URL:#tn=				12.11.2.1.5 mv>
				12.11.2.1.6 rm <URL:#tn=				12.11.2.1.6 rm>
				12.11.2.1.7 rmdir <URL:#tn=				12.11.2.1.7 rmdir>
				12.11.2.1.8 mkdir <URL:#tn=				12.11.2.1.8 mkdir>
				12.11.2.1.9 chmod <URL:#tn=				12.11.2.1.9 chmod>
				12.11.2.1.10 chattr <URL:#tn=				12.11.2.1.10 chattr>
				12.11.2.1.11 ln <URL:#tn=				12.11.2.1.11 ln>
				12.11.2.1.12 man, info <URL:#tn=				12.11.2.1.12 man, info>
			12.11.2.2 Complex Commands <URL:#tn=			12.11.2.2 Complex Commands>
				12.11.2.2.1 find <URL:#tn=				12.11.2.2.1 find>
				12.11.2.2.2 Example 15-3. Badname, eliminate file names in current directory containing bad characters and whitespace. <URL:#tn=				12.11.2.2.2 Example 15-3. Badname, eliminate file names in current directory containing bad characters and whitespace.>
				12.11.2.2.3 Example 15-4. Deleting a file by its inode number <URL:#tn=				12.11.2.2.3 Example 15-4. Deleting a file by its inode number>
				12.11.2.2.4 xargs <URL:#tn=				12.11.2.2.4 xargs>
				    12.11.2.2.4.1 xargs examples, tags: xargs examples <URL:#tn=				    12.11.2.2.4.1 xargs examples, tags: xargs examples>
				12.11.2.2.5 Example 15-5. Logfile: Using xargs to monitor system log <URL:#tn=				12.11.2.2.5 Example 15-5. Logfile: Using xargs to monitor system log>
				12.11.2.2.6 Example 15-6. Copying files in current directory to another <URL:#tn=				12.11.2.2.6 Example 15-6. Copying files in current directory to another>
				12.11.2.2.7 Example 15-7. Killing processes by name <URL:#tn=				12.11.2.2.7 Example 15-7. Killing processes by name>
				12.11.2.2.8 Example 15-8. Word frequency analysis using xargs <URL:#tn=				12.11.2.2.8 Example 15-8. Word frequency analysis using xargs>
				12.11.2.2.9 expr <URL:#tn=				12.11.2.2.9 expr>
				12.11.2.2.10 Example 15-9. Using expr <URL:#tn=				12.11.2.2.10 Example 15-9. Using expr>
			12.11.2.3 Time / Date Commands <URL:#tn=			12.11.2.3 Time / Date Commands>
				12.11.2.3.1 date <URL:#tn=				12.11.2.3.1 date>
				12.11.2.3.2 Example 15-11. Date calculations <URL:#tn=				12.11.2.3.2 Example 15-11. Date calculations>
				12.11.2.3.3 zdump <URL:#tn=				12.11.2.3.3 zdump>
				12.11.2.3.4 time <URL:#tn=				12.11.2.3.4 time>
				12.11.2.3.5 touch <URL:#tn=				12.11.2.3.5 touch>
				12.11.2.3.6 at <URL:#tn=				12.11.2.3.6 at>
				12.11.2.3.7 batch <URL:#tn=				12.11.2.3.7 batch>
				12.11.2.3.8 cal <URL:#tn=				12.11.2.3.8 cal>
				12.11.2.3.9 sleep <URL:#tn=				12.11.2.3.9 sleep>
				12.11.2.3.10 usleep <URL:#tn=				12.11.2.3.10 usleep>
				12.11.2.3.11 hwclock, clock <URL:#tn=				12.11.2.3.11 hwclock, clock>
			12.11.2.4 Text Processing Commands <URL:#tn=			12.11.2.4 Text Processing Commands>
				12.11.2.4.1 sort <URL:#tn=				12.11.2.4.1 sort>
				12.11.2.4.2 tsort <URL:#tn=				12.11.2.4.2 tsort>
				12.11.2.4.3 uniq <URL:#tn=				12.11.2.4.3 uniq>
				12.11.2.4.4 Example 15-12. Word Frequency Analysis <URL:#tn=				12.11.2.4.4 Example 15-12. Word Frequency Analysis>
				12.11.2.4.5 expand, unexpand <URL:#tn=				12.11.2.4.5 expand, unexpand>
				12.11.2.4.6 cut <URL:#tn=				12.11.2.4.6 cut>
				12.11.2.4.7 paste <URL:#tn=				12.11.2.4.7 paste>
				12.11.2.4.8 join <URL:#tn=				12.11.2.4.8 join>
				12.11.2.4.9 head <URL:#tn=				12.11.2.4.9 head>
				12.11.2.4.10 Example 15-14. Generating 10-digit random numbers <URL:#tn=				12.11.2.4.10 Example 15-14. Generating 10-digit random numbers>
				12.11.2.4.11 tail <URL:#tn=				12.11.2.4.11 tail>
				12.11.2.4.12 grep <URL:#tn=				12.11.2.4.12 grep>
				12.11.2.4.13 Use grep for conditions <URL:#tn=				12.11.2.4.13 Use grep for conditions>
				12.11.2.4.14 Example 15-18. Crossword puzzle solver <URL:#tn=				12.11.2.4.14 Example 15-18. Crossword puzzle solver>
				12.11.2.4.15 egrep <URL:#tn=				12.11.2.4.15 egrep>
				12.11.2.4.16 fgrep <URL:#tn=				12.11.2.4.16 fgrep>
				12.11.2.4.17 agrep <URL:#tn=				12.11.2.4.17 agrep>
				12.11.2.4.18 look <URL:#tn=				12.11.2.4.18 look>
				12.11.2.4.19 sed, awk <URL:#tn=				12.11.2.4.19 sed, awk>
				12.11.2.4.20 wc <URL:#tn=				12.11.2.4.20 wc>
				12.11.2.4.21 tr <URL:#tn=				12.11.2.4.21 tr>
				12.11.2.4.22 Example 15-21. toupper: Transforms a file to all uppercase. <URL:#tn=				12.11.2.4.22 Example 15-21. toupper: Transforms a file to all uppercase.>
				12.11.2.4.23 Example 15-22. lowercase: Changes all filenames in working directory to lowercase. <URL:#tn=				12.11.2.4.23 Example 15-22. lowercase: Changes all filenames in working directory to lowercase.>
				12.11.2.4.24 Example 15-23. du: DOS to UNIX text file conversion. <URL:#tn=				12.11.2.4.24 Example 15-23. du: DOS to UNIX text file conversion.>
				12.11.2.4.25 Example 15-24. rot13: ultra-weak encryption. <URL:#tn=				12.11.2.4.25 Example 15-24. rot13: ultra-weak encryption.>
				12.11.2.4.26 Example 15-25. Generating "Crypto-Quote" Puzzles <URL:#tn=				12.11.2.4.26 Example 15-25. Generating "Crypto-Quote" Puzzles>
				12.11.2.4.27 fold <URL:#tn=				12.11.2.4.27 fold>
				12.11.2.4.28 fmt <URL:#tn=				12.11.2.4.28 fmt>
				12.11.2.4.29 col <URL:#tn=				12.11.2.4.29 col>
				12.11.2.4.30 colrm <URL:#tn=				12.11.2.4.30 colrm>
				12.11.2.4.31 nl <URL:#tn=				12.11.2.4.31 nl>
				12.11.2.4.32 pr <URL:#tn=				12.11.2.4.32 pr>
				12.11.2.4.33 gettext <URL:#tn=				12.11.2.4.33 gettext>
				12.11.2.4.34 msgfmt <URL:#tn=				12.11.2.4.34 msgfmt>
				12.11.2.4.35 iconv <URL:#tn=				12.11.2.4.35 iconv>
				12.11.2.4.36 recode <URL:#tn=				12.11.2.4.36 recode>
				12.11.2.4.37 TeX, gs <URL:#tn=				12.11.2.4.37 TeX, gs>
				12.11.2.4.38 texexec <URL:#tn=				12.11.2.4.38 texexec>
				12.11.2.4.39 enscript <URL:#tn=				12.11.2.4.39 enscript>
				12.11.2.4.40 groff, tbl, eqn <URL:#tn=				12.11.2.4.40 groff, tbl, eqn>
				12.11.2.4.41 lex, yacc <URL:#tn=				12.11.2.4.41 lex, yacc>
			12.11.2.5 File and Archiving Commands <URL:#tn=			12.11.2.5 File and Archiving Commands>
				12.11.2.5.1 tar <URL:#tn=				12.11.2.5.1 tar>
				12.11.2.5.2 shar <URL:#tn=				12.11.2.5.2 shar>
				12.11.2.5.3 ar <URL:#tn=				12.11.2.5.3 ar>
				12.11.2.5.4 rpm <URL:#tn=				12.11.2.5.4 rpm>
				12.11.2.5.5 cpio <URL:#tn=				12.11.2.5.5 cpio>
				12.11.2.5.6 Example 15-30. Using cpio to move a directory tree <URL:#tn=				12.11.2.5.6 Example 15-30. Using cpio to move a directory tree>
				12.11.2.5.7 rpm2cpio <URL:#tn=				12.11.2.5.7 rpm2cpio>
				12.11.2.5.8 gzip <URL:#tn=				12.11.2.5.8 gzip>
				12.11.2.5.9 bzip2 <URL:#tn=				12.11.2.5.9 bzip2>
				12.11.2.5.10 compress, uncompress <URL:#tn=				12.11.2.5.10 compress, uncompress>
				12.11.2.5.11 sq <URL:#tn=				12.11.2.5.11 sq>
				12.11.2.5.12 zip, unzip <URL:#tn=				12.11.2.5.12 zip, unzip>
				12.11.2.5.13 file <URL:#tn=				12.11.2.5.13 file>
				12.11.2.5.14 which <URL:#tn=				12.11.2.5.14 which>
				12.11.2.5.15 whereis <URL:#tn=				12.11.2.5.15 whereis>
				12.11.2.5.16 whatis <URL:#tn=				12.11.2.5.16 whatis>
				12.11.2.5.17 vdir <URL:#tn=				12.11.2.5.17 vdir>
				12.11.2.5.18 locate, slocate <URL:#tn=				12.11.2.5.18 locate, slocate>
				12.11.2.5.19 readlink <URL:#tn=				12.11.2.5.19 readlink>
				12.11.2.5.20 strings <URL:#tn=				12.11.2.5.20 strings>
				12.11.2.5.21 diff, patch <URL:#tn=				12.11.2.5.21 diff, patch>
				12.11.2.5.22 diff3, merge <URL:#tn=				12.11.2.5.22 diff3, merge>
				12.11.2.5.23 sdiff <URL:#tn=				12.11.2.5.23 sdiff>
				12.11.2.5.24 cmp <URL:#tn=				12.11.2.5.24 cmp>
				12.11.2.5.25 comm <URL:#tn=				12.11.2.5.25 comm>
				12.11.2.5.26 basename <URL:#tn=				12.11.2.5.26 basename>
				12.11.2.5.27 dirname <URL:#tn=				12.11.2.5.27 dirname>
				12.11.2.5.28 split, csplit <URL:#tn=				12.11.2.5.28 split, csplit>
				12.11.2.5.29 sum, cksum, md5sum, sha1sum <URL:#tn=				12.11.2.5.29 sum, cksum, md5sum, sha1sum>
				12.11.2.5.30 shred <URL:#tn=				12.11.2.5.30 shred>
				12.11.2.5.31 uuencode <URL:#tn=				12.11.2.5.31 uuencode>
				12.11.2.5.32 uudecode <URL:#tn=				12.11.2.5.32 uudecode>
				12.11.2.5.33 mimencode, mmencode <URL:#tn=				12.11.2.5.33 mimencode, mmencode>
				12.11.2.5.34 crypt <URL:#tn=				12.11.2.5.34 crypt>
				12.11.2.5.35 mktemp <URL:#tn=				12.11.2.5.35 mktemp>
				12.11.2.5.36 make <URL:#tn=				12.11.2.5.36 make>
				12.11.2.5.37 install <URL:#tn=				12.11.2.5.37 install>
				12.11.2.5.38 dos2unix <URL:#tn=				12.11.2.5.38 dos2unix>
				12.11.2.5.39 ptx <URL:#tn=				12.11.2.5.39 ptx>
				12.11.2.5.40 more, less <URL:#tn=				12.11.2.5.40 more, less>
			12.11.2.6 Communications Commands <URL:#tn=			12.11.2.6 Communications Commands>
				12.11.2.6.1 host <URL:#tn=				12.11.2.6.1 host>
				12.11.2.6.2 ipcalc <URL:#tn=				12.11.2.6.2 ipcalc>
				12.11.2.6.3 nslookup <URL:#tn=				12.11.2.6.3 nslookup>
				12.11.2.6.4 dig <URL:#tn=				12.11.2.6.4 dig>
				12.11.2.6.5 Example 15-40. Finding out where to report a spammer <URL:#tn=				12.11.2.6.5 Example 15-40. Finding out where to report a spammer>
				12.11.2.6.6 Example 15-41. Analyzing a spam domain <URL:#tn=				12.11.2.6.6 Example 15-41. Analyzing a spam domain>
				12.11.2.6.7 traceroute <URL:#tn=				12.11.2.6.7 traceroute>
				12.11.2.6.8 ping <URL:#tn=				12.11.2.6.8 ping>
				12.11.2.6.9 whois <URL:#tn=				12.11.2.6.9 whois>
				12.11.2.6.10 finger <URL:#tn=				12.11.2.6.10 finger>
				12.11.2.6.11 chfn <URL:#tn=				12.11.2.6.11 chfn>
				12.11.2.6.12 vrfy <URL:#tn=				12.11.2.6.12 vrfy>
				12.11.2.6.13 sx, rx <URL:#tn=				12.11.2.6.13 sx, rx>
				12.11.2.6.14 sz, rz <URL:#tn=				12.11.2.6.14 sz, rz>
				12.11.2.6.15 uucp, uux, cu <URL:#tn=				12.11.2.6.15 uucp, uux, cu>
				12.11.2.6.16 wget <URL:#tn=				12.11.2.6.16 wget>
				12.11.2.6.17 Example 15-42. Getting a stock quote <URL:#tn=				12.11.2.6.17 Example 15-42. Getting a stock quote>
				12.11.2.6.18 lynx <URL:#tn=				12.11.2.6.18 lynx>
				12.11.2.6.19 rlogin <URL:#tn=				12.11.2.6.19 rlogin>
				12.11.2.6.20 rsh <URL:#tn=				12.11.2.6.20 rsh>
				12.11.2.6.21 rcp <URL:#tn=				12.11.2.6.21 rcp>
				12.11.2.6.22 rsync <URL:#tn=				12.11.2.6.22 rsync>
				12.11.2.6.23 Example 15-43. Updating FC4 <URL:#tn=				12.11.2.6.23 Example 15-43. Updating FC4>
				12.11.2.6.24 ssh <URL:#tn=				12.11.2.6.24 ssh>
				12.11.2.6.25 scp <URL:#tn=				12.11.2.6.25 scp>
				12.11.2.6.26 write <URL:#tn=				12.11.2.6.26 write>
				12.11.2.6.27 netconfig <URL:#tn=				12.11.2.6.27 netconfig>
				12.11.2.6.28 mail <URL:#tn=				12.11.2.6.28 mail>
				12.11.2.6.29 Example 15-45. A script that mails itself <URL:#tn=				12.11.2.6.29 Example 15-45. A script that mails itself>
				12.11.2.6.30 mailto <URL:#tn=				12.11.2.6.30 mailto>
				12.11.2.6.31 mailstats <URL:#tn=				12.11.2.6.31 mailstats>
				12.11.2.6.32 vacation <URL:#tn=				12.11.2.6.32 vacation>
			12.11.2.7 Terminal Control Commands <URL:#tn=			12.11.2.7 Terminal Control Commands>
				12.11.2.7.1 tput <URL:#tn=				12.11.2.7.1 tput>
				12.11.2.7.2 infocmp <URL:#tn=				12.11.2.7.2 infocmp>
				12.11.2.7.3 reset <URL:#tn=				12.11.2.7.3 reset>
				12.11.2.7.4 clear <URL:#tn=				12.11.2.7.4 clear>
				12.11.2.7.5 resize <URL:#tn=				12.11.2.7.5 resize>
				12.11.2.7.6 script <URL:#tn=				12.11.2.7.6 script>
			12.11.2.8 Math Commands <URL:#tn=			12.11.2.8 Math Commands>
				12.11.2.8.1 factor <URL:#tn=				12.11.2.8.1 factor>
				12.11.2.8.2 Example 15-46. Generating prime numbers <URL:#tn=				12.11.2.8.2 Example 15-46. Generating prime numbers>
				12.11.2.8.3 bc <URL:#tn=				12.11.2.8.3 bc>
				12.11.2.8.4 Example 15-47. Monthly Payment on a Mortgage <URL:#tn=				12.11.2.8.4 Example 15-47. Monthly Payment on a Mortgage>
				12.11.2.8.5 Example 15-48. Base Conversion <URL:#tn=				12.11.2.8.5 Example 15-48. Base Conversion>
				12.11.2.8.6 Example 15-49. Invoking bc using a here document <URL:#tn=				12.11.2.8.6 Example 15-49. Invoking bc using a here document>
				12.11.2.8.7 Example 15-50. Calculating PI <URL:#tn=				12.11.2.8.7 Example 15-50. Calculating PI>
				12.11.2.8.8 dc <URL:#tn=				12.11.2.8.8 dc>
				12.11.2.8.9 Example 15-51. Converting a decimal number to hexadecimal <URL:#tn=				12.11.2.8.9 Example 15-51. Converting a decimal number to hexadecimal>
				12.11.2.8.10 Example 15-52. Factoring <URL:#tn=				12.11.2.8.10 Example 15-52. Factoring>
				12.11.2.8.11 awk <URL:#tn=				12.11.2.8.11 awk>
				12.11.2.8.12 Example 15-53. Calculating the hypotenuse of a triangle <URL:#tn=				12.11.2.8.12 Example 15-53. Calculating the hypotenuse of a triangle>
			12.11.2.9 Miscellaneous Commands <URL:#tn=			12.11.2.9 Miscellaneous Commands>
				12.11.2.9.1 jot, seq <URL:#tn=				12.11.2.9.1 jot, seq>
					12.11.2.9.1.1 Generate list with preceding zeros, ex: 001 - 099 <URL:#tn=					12.11.2.9.1.1 Generate list with preceding zeros, ex: 001 - 099>
					12.11.2.9.1.2 range for loop, like python for i in range <URL:#tn=					12.11.2.9.1.2 range for loop, like python for i in range>
					12.11.2.9.1.3 <URL:#tn=					12.11.2.9.1.3>
				12.11.2.9.2 Example 15-54. Using seq to generate loop arguments <URL:#tn=				12.11.2.9.2 Example 15-54. Using seq to generate loop arguments>
				12.11.2.9.3 Example 15-55. Letter Count" <URL:#tn=				12.11.2.9.3 Example 15-55. Letter Count">
				12.11.2.9.4 getopt <URL:#tn=				12.11.2.9.4 getopt>
				12.11.2.9.5 Example 15-56. Using getopt to parse command-line options <URL:#tn=				12.11.2.9.5 Example 15-56. Using getopt to parse command-line options>
				12.11.2.9.6 run-parts <URL:#tn=				12.11.2.9.6 run-parts>
				12.11.2.9.7 yes <URL:#tn=				12.11.2.9.7 yes>
				12.11.2.9.8 banner <URL:#tn=				12.11.2.9.8 banner>
				12.11.2.9.9 printenv <URL:#tn=				12.11.2.9.9 printenv>
				12.11.2.9.10 lp <URL:#tn=				12.11.2.9.10 lp>
				12.11.2.9.11 tee <URL:#tn=				12.11.2.9.11 tee>
				12.11.2.9.12 mkfifo <URL:#tn=				12.11.2.9.12 mkfifo>
				12.11.2.9.13 pathchk <URL:#tn=				12.11.2.9.13 pathchk>
				12.11.2.9.14 dd <URL:#tn=				12.11.2.9.14 dd>
				12.11.2.9.15 Example 15-57. A script that copies itself <URL:#tn=				12.11.2.9.15 Example 15-57. A script that copies itself>
				12.11.2.9.16 Example 15-58. Exercising dd <URL:#tn=				12.11.2.9.16 Example 15-58. Exercising dd>
				12.11.2.9.17 Example 15-59. Capturing Keystrokes <URL:#tn=				12.11.2.9.17 Example 15-59. Capturing Keystrokes>
				12.11.2.9.18 Example 15-60. Securely deleting a file <URL:#tn=				12.11.2.9.18 Example 15-60. Securely deleting a file>
				12.11.2.9.19 od <URL:#tn=				12.11.2.9.19 od>
				12.11.2.9.20 hexdump <URL:#tn=				12.11.2.9.20 hexdump>
				12.11.2.9.21 objdump <URL:#tn=				12.11.2.9.21 objdump>
				12.11.2.9.22 mcookie <URL:#tn=				12.11.2.9.22 mcookie>
				12.11.2.9.23 Example 15-61. Filename generator <URL:#tn=				12.11.2.9.23 Example 15-61. Filename generator>
				12.11.2.9.24 units <URL:#tn=				12.11.2.9.24 units>
				12.11.2.9.25 Example 15-62. Converting meters to miles <URL:#tn=				12.11.2.9.25 Example 15-62. Converting meters to miles>
				12.11.2.9.26 m4 <URL:#tn=				12.11.2.9.26 m4>
				12.11.2.9.27 Example 15-63. Using m4 <URL:#tn=				12.11.2.9.27 Example 15-63. Using m4>
				12.11.2.9.28 xmessage <URL:#tn=				12.11.2.9.28 xmessage>
				12.11.2.9.29 zenity <URL:#tn=				12.11.2.9.29 zenity>
				12.11.2.9.30 doexec <URL:#tn=				12.11.2.9.30 doexec>
				12.11.2.9.31 dialog <URL:#tn=				12.11.2.9.31 dialog>
				12.11.2.9.32 sox <URL:#tn=				12.11.2.9.32 sox>
		12.11.3 Chapter 16. System and Administrative Commands <URL:#tn=		12.11.3 Chapter 16. System and Administrative Commands>
			12.11.3.1 users <URL:#tn=			12.11.3.1 users>
			12.11.3.2 groups <URL:#tn=			12.11.3.2 groups>
			12.11.3.3 chown, chgrp <URL:#tn=			12.11.3.3 chown, chgrp>
			12.11.3.4 usermod <URL:#tn=			12.11.3.4 usermod>
			12.11.3.5 groupmod <URL:#tn=			12.11.3.5 groupmod>
			12.11.3.6 id <URL:#tn=			12.11.3.6 id>
			12.11.3.7 who <URL:#tn=			12.11.3.7 who>
			12.11.3.8 w <URL:#tn=			12.11.3.8 w>
			12.11.3.9 logname <URL:#tn=			12.11.3.9 logname>
			12.11.3.10 su <URL:#tn=			12.11.3.10 su>
			12.11.3.11 sudo <URL:#tn=			12.11.3.11 sudo>
			12.11.3.12 passwd <URL:#tn=			12.11.3.12 passwd>
			12.11.3.13 ac <URL:#tn=			12.11.3.13 ac>
			12.11.3.14 last <URL:#tn=			12.11.3.14 last>
			12.11.3.15 newgrp <URL:#tn=			12.11.3.15 newgrp>
			12.11.3.16 tty <URL:#tn=			12.11.3.16 tty>
			12.11.3.17 stty <URL:#tn=			12.11.3.17 stty>
			12.11.3.18 Example 16-2. Setting an erase character <URL:#tn=			12.11.3.18 Example 16-2. Setting an erase character>
			12.11.3.19 Example 16-3. secret password: Turning off terminal echoing <URL:#tn=			12.11.3.19 Example 16-3. secret password: Turning off terminal echoing>
			12.11.3.20 Example 16-4. Keypress detection <URL:#tn=			12.11.3.20 Example 16-4. Keypress detection>
			12.11.3.21 setterm <URL:#tn=			12.11.3.21 setterm>
			12.11.3.22 tset <URL:#tn=			12.11.3.22 tset>
			12.11.3.23 setserial <URL:#tn=			12.11.3.23 setserial>
			12.11.3.24 getty, agetty <URL:#tn=			12.11.3.24 getty, agetty>
			12.11.3.25 mesg <URL:#tn=			12.11.3.25 mesg>
			12.11.3.26 wall <URL:#tn=			12.11.3.26 wall>
			12.11.3.27 uname <URL:#tn=			12.11.3.27 uname>
			12.11.3.28 arch <URL:#tn=			12.11.3.28 arch>
			12.11.3.29 lastcomm <URL:#tn=			12.11.3.29 lastcomm>
			12.11.3.30 lastlog <URL:#tn=			12.11.3.30 lastlog>
			12.11.3.31 lsof <URL:#tn=			12.11.3.31 lsof>
			12.11.3.32 strace <URL:#tn=			12.11.3.32 strace>
			12.11.3.33 ltrace <URL:#tn=			12.11.3.33 ltrace>
			12.11.3.34 nmap <URL:#tn=			12.11.3.34 nmap>
			12.11.3.35 nc <URL:#tn=			12.11.3.35 nc>
			12.11.3.36 Example 16-5. Checking a remote server for identd <URL:#tn=			12.11.3.36 Example 16-5. Checking a remote server for identd>
				12.11.3.36.1 More netcat (nc) examples <URL:#tn=				12.11.3.36.1 More netcat (nc) examples>
					12.11.3.36.1.1 CLIENT/SERVER MODEL <URL:#tn=					12.11.3.36.1.1 CLIENT/SERVER MODEL>
					12.11.3.36.1.2 Port Scanning <URL:#tn=					12.11.3.36.1.2 Port Scanning>
					12.11.3.36.1.3 Various Examples <URL:#tn=					12.11.3.36.1.3 Various Examples>
			12.11.3.37 free <URL:#tn=			12.11.3.37 free>
			12.11.3.38 procinfo <URL:#tn=			12.11.3.38 procinfo>
			12.11.3.39 lsdev <URL:#tn=			12.11.3.39 lsdev>
			12.11.3.40 du <URL:#tn=			12.11.3.40 du>
			12.11.3.41 df <URL:#tn=			12.11.3.41 df>
			12.11.3.42 dmesg <URL:#tn=			12.11.3.42 dmesg>
			12.11.3.43 stat <URL:#tn=			12.11.3.43 stat>
			12.11.3.44 vmstat <URL:#tn=			12.11.3.44 vmstat>
			12.11.3.45 netstat <URL:#tn=			12.11.3.45 netstat>
			12.11.3.46 Show open sockets <URL:#tn=			12.11.3.46 Show open sockets>
			12.11.3.47 uptime <URL:#tn=			12.11.3.47 uptime>
			12.11.3.48 hostname <URL:#tn=			12.11.3.48 hostname>
			12.11.3.49 hostid <URL:#tn=			12.11.3.49 hostid>
			12.11.3.50 sar <URL:#tn=			12.11.3.50 sar>
			12.11.3.51 readelf <URL:#tn=			12.11.3.51 readelf>
			12.11.3.52 size <URL:#tn=			12.11.3.52 size>
			12.11.3.53 logger <URL:#tn=			12.11.3.53 logger>
			12.11.3.54 logrotate <URL:#tn=			12.11.3.54 logrotate>
			12.11.3.55 ps <URL:#tn=			12.11.3.55 ps>
			12.11.3.56 To display system processes in graphical "tree" format: ps afjx or ps ax --forest. <URL:#tn=			12.11.3.56 To display system processes in graphical "tree" format: ps afjx or ps ax --forest.>
			12.11.3.57 pgrep, pkill <URL:#tn=			12.11.3.57 pgrep, pkill>
			12.11.3.58 pstree <URL:#tn=			12.11.3.58 pstree>
			12.11.3.59 top <URL:#tn=			12.11.3.59 top>
			12.11.3.60 nice <URL:#tn=			12.11.3.60 nice>
			12.11.3.61 pidof <URL:#tn=			12.11.3.61 pidof>
			12.11.3.62 Example 16-6. pidof helps kill a process <URL:#tn=			12.11.3.62 Example 16-6. pidof helps kill a process>
			12.11.3.63 fuser <URL:#tn=			12.11.3.63 fuser>
			12.11.3.64 cron <URL:#tn=			12.11.3.64 cron>
			12.11.3.65 init <URL:#tn=			12.11.3.65 init>
			12.11.3.66 service <URL:#tn=			12.11.3.66 service>
			12.11.3.67 ifconfig <URL:#tn=			12.11.3.67 ifconfig>
			12.11.3.68 route <URL:#tn=			12.11.3.68 route>
			12.11.3.69 mount <URL:#tn=			12.11.3.69 mount>
			12.11.3.70 Example 16-7. Checking a CD image <URL:#tn=			12.11.3.70 Example 16-7. Checking a CD image>
			12.11.3.71 umount <URL:#tn=			12.11.3.71 umount>
			12.11.3.72 sync <URL:#tn=			12.11.3.72 sync>
			12.11.3.73 losetup <URL:#tn=			12.11.3.73 losetup>
			12.11.3.74 mkswap <URL:#tn=			12.11.3.74 mkswap>
			12.11.3.75 swapon, swapoff <URL:#tn=			12.11.3.75 swapon, swapoff>
			12.11.3.76 mke2fs <URL:#tn=			12.11.3.76 mke2fs>
			12.11.3.77 Example 16-9. Adding a new hard drive <URL:#tn=			12.11.3.77 Example 16-9. Adding a new hard drive>
			12.11.3.78 tune2fs <URL:#tn=			12.11.3.78 tune2fs>
			12.11.3.79 dumpe2fs <URL:#tn=			12.11.3.79 dumpe2fs>
			12.11.3.80 hdparm <URL:#tn=			12.11.3.80 hdparm>
			12.11.3.81 fdisk <URL:#tn=			12.11.3.81 fdisk>
			12.11.3.82 fsck, e2fsck, debugfs <URL:#tn=			12.11.3.82 fsck, e2fsck, debugfs>
			12.11.3.83 lsusb, usbmodules <URL:#tn=			12.11.3.83 lsusb, usbmodules>
			12.11.3.84 lspci <URL:#tn=			12.11.3.84 lspci>
			12.11.3.85 mkbootdisk <URL:#tn=			12.11.3.85 mkbootdisk>
			12.11.3.86 mkisofs <URL:#tn=			12.11.3.86 mkisofs>
			12.11.3.87 chroot <URL:#tn=			12.11.3.87 chroot>
			12.11.3.88 lockfile <URL:#tn=			12.11.3.88 lockfile>
			12.11.3.89 flock <URL:#tn=			12.11.3.89 flock>
			12.11.3.90 mknod <URL:#tn=			12.11.3.90 mknod>
			12.11.3.91 tmpwatch <URL:#tn=			12.11.3.91 tmpwatch>
			12.11.3.92 dump, restore <URL:#tn=			12.11.3.92 dump, restore>
			12.11.3.93 ulimit <URL:#tn=			12.11.3.93 ulimit>
			12.11.3.94 quota <URL:#tn=			12.11.3.94 quota>
			12.11.3.95 setquota <URL:#tn=			12.11.3.95 setquota>
			12.11.3.96 umask <URL:#tn=			12.11.3.96 umask>
			12.11.3.97 Example 16-10. Using umask to hide an output file from prying eyes <URL:#tn=			12.11.3.97 Example 16-10. Using umask to hide an output file from prying eyes>
			12.11.3.98 rdev <URL:#tn=			12.11.3.98 rdev>
			12.11.3.99 lsmod <URL:#tn=			12.11.3.99 lsmod>
			12.11.3.100 insmod <URL:#tn=			12.11.3.100 insmod>
			12.11.3.101 rmmod <URL:#tn=			12.11.3.101 rmmod>
			12.11.3.102 modprobe <URL:#tn=			12.11.3.102 modprobe>
			12.11.3.103 depmod <URL:#tn=			12.11.3.103 depmod>
			12.11.3.104 modinfo <URL:#tn=			12.11.3.104 modinfo>
			12.11.3.105 env <URL:#tn=			12.11.3.105 env>
			12.11.3.106 ldd <URL:#tn=			12.11.3.106 ldd>
			12.11.3.107 watch, iteration utility, replaces while true do cmd <URL:#tn=			12.11.3.107 watch, iteration utility, replaces while true do cmd>
			12.11.3.108 nm <URL:#tn=			12.11.3.108 nm>
			12.11.3.109 rdist <URL:#tn=			12.11.3.109 rdist>
		12.11.4 Analyzing a System Script <URL:#tn=		12.11.4 Analyzing a System Script>
	12.12 Part 5. Advanced Topics <URL:#tn=	12.12 Part 5. Advanced Topics>
		12.12.1 Chapter 17. Regular Expressions <URL:#tn=		12.12.1 Chapter 17. Regular Expressions>
			12.12.1.1 A Brief Introduction to Regular Expressions <URL:#tn=			12.12.1.1 A Brief Introduction to Regular Expressions>
			12.12.1.2 Globbing <URL:#tn=			12.12.1.2 Globbing>
		12.12.2 Chapter 18. Here Documents <URL:#tn=		12.12.2 Chapter 18. Here Documents>
			12.12.2.1 Example 18-2. dummyfile: Creates a 2-line dummy file <URL:#tn=			12.12.2.1 Example 18-2. dummyfile: Creates a 2-line dummy file>
			12.12.2.2 Examples of ex scripts that use here documents <URL:#tn=			12.12.2.2 Examples of ex scripts that use here documents>
			12.12.2.3 Analogous to "ex scripts" are cat scripts. <URL:#tn=			12.12.2.3 Analogous to "ex scripts" are cat scripts.>
			12.12.2.4 Example 18-4. Multi-line message, with tabs suppressed <URL:#tn=			12.12.2.4 Example 18-4. Multi-line message, with tabs suppressed>
			12.12.2.5 Example 18-5. Here document with parameter substitution <URL:#tn=			12.12.2.5 Example 18-5. Here document with parameter substitution>
			12.12.2.6 Example 18-6. Upload a file pair to Sunsite incoming directory <URL:#tn=			12.12.2.6 Example 18-6. Upload a file pair to Sunsite incoming directory>
			12.12.2.7 Example 18-7. Parameter substitution turned off <URL:#tn=			12.12.2.7 Example 18-7. Parameter substitution turned off>
			12.12.2.8 Example 18-8. A script that generates another script <URL:#tn=			12.12.2.8 Example 18-8. A script that generates another script>
			12.12.2.9 Example 18-9. Here documents and functions <URL:#tn=			12.12.2.9 Example 18-9. Here documents and functions>
			12.12.2.10 Example 18-10. "Anonymous" Here Document <URL:#tn=			12.12.2.10 Example 18-10. "Anonymous" Here Document>
			12.12.2.11 Example 18-11. Commenting out a block of code <URL:#tn=			12.12.2.11 Example 18-11. Commenting out a block of code>
			12.12.2.12 Example 18-12. A self-documenting script <URL:#tn=			12.12.2.12 Example 18-12. A self-documenting script>
			12.12.2.13 Here Strings <URL:#tn=			12.12.2.13 Here Strings>
				12.12.2.13.1 Example 18-13. Prepending a line to a file <URL:#tn=				12.12.2.13.1 Example 18-13. Prepending a line to a file>
				12.12.2.13.2 Example 18-14. Parsing a mailbox <URL:#tn=				12.12.2.13.2 Example 18-14. Parsing a mailbox>
		12.12.3 Chapter 19. I/O Redirection <URL:#tn=		12.12.3 Chapter 19. I/O Redirection>
			12.12.3.1 Using exec <URL:#tn=			12.12.3.1 Using exec>
				12.12.3.1.1 Example 19-1 Redirecting stdin using exec <URL:#tn=				12.12.3.1.1 Example 19-1 Redirecting stdin using exec>
				12.12.3.1.2 Example 19-2. Redirecting stdout using exec <URL:#tn=				12.12.3.1.2 Example 19-2. Redirecting stdout using exec>
				12.12.3.1.3 Example 19-3. Redirecting both stdin and stdout in the same script with exec <URL:#tn=				12.12.3.1.3 Example 19-3. Redirecting both stdin and stdout in the same script with exec>
				12.12.3.1.4 Example 19-4. Avoiding a subshell <URL:#tn=				12.12.3.1.4 Example 19-4. Avoiding a subshell>
			12.12.3.2 Redirecting Code Blocks <URL:#tn=			12.12.3.2 Redirecting Code Blocks>
				12.12.3.2.1 Example 19-5. Redirected while loop <URL:#tn=				12.12.3.2.1 Example 19-5. Redirected while loop>
				12.12.3.2.2 Example 19-6. Alternate form of redirected while loop <URL:#tn=				12.12.3.2.2 Example 19-6. Alternate form of redirected while loop>
				12.12.3.2.3 Example 19-7. Redirected until loop <URL:#tn=				12.12.3.2.3 Example 19-7. Redirected until loop>
				12.12.3.2.4 Example 19-8. Redirected for loop <URL:#tn=				12.12.3.2.4 Example 19-8. Redirected for loop>
				12.12.3.2.5 Example 19-9. Redirected for loop (both stdin and stdout redirected) <URL:#tn=				12.12.3.2.5 Example 19-9. Redirected for loop (both stdin and stdout redirected)>
				12.12.3.2.6 Example 19-10. Redirected if/then test <URL:#tn=				12.12.3.2.6 Example 19-10. Redirected if/then test>
				12.12.3.2.7 Here documents and IO redirection <URL:#tn=				12.12.3.2.7 Here documents and IO redirection>
			12.12.3.3 Applications <URL:#tn=			12.12.3.3 Applications>
		12.12.4 Chapter 20. Subshells <URL:#tn=		12.12.4 Chapter 20. Subshells>
			12.12.4.1 Example 20-1. Variable scope in a subshell <URL:#tn=			12.12.4.1 Example 20-1. Variable scope in a subshell>
			12.12.4.2 Example 20-2. List User Profiles <URL:#tn=			12.12.4.2 Example 20-2. List User Profiles>
			12.12.4.3 A subshell may be used to set up a "dedicated environment" for a command group. <URL:#tn=			12.12.4.3 A subshell may be used to set up a "dedicated environment" for a command group.>
			12.12.4.4 One application of such a "dedicated environment" is testing whether a variable is defined. <URL:#tn=			12.12.4.4 One application of such a "dedicated environment" is testing whether a variable is defined.>
			12.12.4.5 Another application is checking for a lock file: <URL:#tn=			12.12.4.5 Another application is checking for a lock file:>
			12.12.4.6 Example 20-3. Running parallel processes in subshells <URL:#tn=			12.12.4.6 Example 20-3. Running parallel processes in subshells>
		12.12.5 Chapter 21. Restricted Shells <URL:#tn=		12.12.5 Chapter 21. Restricted Shells>
			12.12.5.1 Example 21-1. Running a script in restricted mode <URL:#tn=			12.12.5.1 Example 21-1. Running a script in restricted mode>
		12.12.6 Chapter 22. Process Substitution <URL:#tn=		12.12.6 Chapter 22. Process Substitution>
		12.12.7 Chapter 23. Functions <URL:#tn=		12.12.7 Chapter 23. Functions>
			12.12.7.1 Example 23-1. Simple functions <URL:#tn=			12.12.7.1 Example 23-1. Simple functions>
			12.12.7.2 The function definition must precede the first call to it <URL:#tn=			12.12.7.2 The function definition must precede the first call to it>
			12.12.7.3 Function declarations can appear in unlikely places <URL:#tn=			12.12.7.3 Function declarations can appear in unlikely places>
			12.12.7.1. Complex Functions and Function Complexities <URL:#tn=			12.12.7.1. Complex Functions and Function Complexities>
				12.12.7.1..1 Example 23-2. Function Taking Parameters <URL:#tn=				12.12.7.1..1 Example 23-2. Function Taking Parameters>
				12.12.7.1.2 Example 23-3 Functions and command-line args passed to the script <URL:#tn=				12.12.7.1.2 Example 23-3 Functions and command-line args passed to the script>
				12.12.7.1.3 Example 23-4 Passing an indirect reference to a function <URL:#tn=				12.12.7.1.3 Example 23-4 Passing an indirect reference to a function>
				12.12.7.1.4 Example 23-5 Dereferencing a parameter passed to a function <URL:#tn=				12.12.7.1.4 Example 23-5 Dereferencing a parameter passed to a function>
				12.12.7.1.5 Example 23-6 Again, dereferencing a parameter passed to a function <URL:#tn=				12.12.7.1.5 Example 23-6 Again, dereferencing a parameter passed to a function>
				12.12.7.1.6 Exit and Return <URL:#tn=				12.12.7.1.6 Exit and Return>
					12.12.7.1.6.1 Example 23-7. Maximum of two numbers <URL:#tn=					12.12.7.1.6.1 Example 23-7. Maximum of two numbers>
					12.12.7.1.6.2 Example 23-8. Converting numbers to Roman numerals <URL:#tn=					12.12.7.1.6.2 Example 23-8. Converting numbers to Roman numerals>
					12.12.7.1.6.3 Example 23-9. Testing large return values in a function <URL:#tn=					12.12.7.1.6.3 Example 23-9. Testing large return values in a function>
					12.12.7.1.6.4 Example 23-10. Comparing two large integers <URL:#tn=					12.12.7.1.6.4 Example 23-10. Comparing two large integers>
					12.12.7.1.6.5 Example: Month length <URL:#tn=					12.12.7.1.6.5 Example: Month length>
				12.12.7.1.7 Redirection <URL:#tn=				12.12.7.1.7 Redirection>
					12.12.7.1.7.1 Example 23-11. Real name from username <URL:#tn=					12.12.7.1.7.1 Example 23-11. Real name from username>
			12.12.7.2 Local Variables <URL:#tn=			12.12.7.2 Local Variables>
				12.12.7.2.1 Example 23-12. Local variable visibility <URL:#tn=				12.12.7.2.1 Example 23-12. Local variable visibility>
				12.12.7.2.2 Local variables and recursion. <URL:#tn=				12.12.7.2.2 Local variables and recursion.>
					12.12.7.2.2.1 Example 23-13. Demonstration of a simple recursive function <URL:#tn=					12.12.7.2.2.1 Example 23-13. Demonstration of a simple recursive function>
					12.12.7.2.2.2 Example 23-14. Recursion, using a local variable <URL:#tn=					12.12.7.2.2.2 Example 23-14. Recursion, using a local variable>
					12.12.7.2.2.3 Example: Recursion limits <URL:#tn=					12.12.7.2.2.3 Example: Recursion limits>
			12.12.7.3 Recursion Without Local Variables <URL:#tn=			12.12.7.3 Recursion Without Local Variables>
				12.12.7.3.1 Example 23-15. The Fibonacci Sequence <URL:#tn=				12.12.7.3.1 Example 23-15. The Fibonacci Sequence>
				12.12.7.3.2 Example 23-16. The Towers of Hanoi <URL:#tn=				12.12.7.3.2 Example 23-16. The Towers of Hanoi>
		12.12.8 Chapter 24. Aliases <URL:#tn=		12.12.8 Chapter 24. Aliases>
			12.12.8.1 Example 24-1. Aliases within a script <URL:#tn=			12.12.8.1 Example 24-1. Aliases within a script>
			12.12.8.2 Example 24-2. unalias: Setting and unsetting an alias <URL:#tn=			12.12.8.2 Example 24-2. unalias: Setting and unsetting an alias>
		12.12.9 Chapter 25. List Constructs <URL:#tn=		12.12.9 Chapter 25. List Constructs>
			12.12.9.1 Example 25-1. Using an and list to test for command-line arguments <URL:#tn=			12.12.9.1 Example 25-1. Using an and list to test for command-line arguments>
			12.12.9.2 Example 25-2. Another command-line arg test using an and list <URL:#tn=			12.12.9.2 Example 25-2. Another command-line arg test using an and list>
			12.12.9.3 Example 25-3. Using or lists in combination with an and list <URL:#tn=			12.12.9.3 Example 25-3. Using or lists in combination with an and list>
		12.12.10 Chapter 26. Arrays <URL:#tn=		12.12.10 Chapter 26. Arrays>
			12.12.10.1 Example 26-1. Simple array usage <URL:#tn=			12.12.10.1 Example 26-1. Simple array usage>
			12.12.10.2 convenient way of initializing an entire array <URL:#tn=			12.12.10.2 convenient way of initializing an entire array>
			12.12.10.3 Example 26-2. Formatting a poem <URL:#tn=			12.12.10.3 Example 26-2. Formatting a poem>
			12.12.10.4 Example 26-3. Various array operations <URL:#tn=			12.12.10.4 Example 26-3. Various array operations>
			12.12.10.5 Example 26-4. String operations on arrays <URL:#tn=			12.12.10.5 Example 26-4. String operations on arrays>
			12.12.10.6 Example 26-6. Some special properties of arrays <URL:#tn=			12.12.10.6 Example 26-6. Some special properties of arrays>
			12.12.10.7 Example 26-7. Of empty arrays and empty elements <URL:#tn=			12.12.10.7 Example 26-7. Of empty arrays and empty elements>
			12.12.10.8 of ${array_name[@]} and ${array_name[*]} notations <URL:#tn=			12.12.10.8 of ${array_name[@]} and ${array_name[*]} notations>
			12.12.10.9 Example 26-8. Initializing arrays <URL:#tn=			12.12.10.9 Example 26-8. Initializing arrays>
			12.12.10.10 Example 26-9. Copying and concatenating arrays <URL:#tn=			12.12.10.10 Example 26-9. Copying and concatenating arrays>
			12.12.10.11 Example 26-10. More on concatenating arrays <URL:#tn=			12.12.10.11 Example 26-10. More on concatenating arrays>
			12.12.10.12 Example 26-11. The Bubble Sort <URL:#tn=			12.12.10.12 Example 26-11. The Bubble Sort>
			12.12.10.13 Is it possible to nest arrays within arrays? <URL:#tn=			12.12.10.13 Is it possible to nest arrays within arrays?>
			12.12.10.14 Example 26-12. Embedded arrays and indirect references <URL:#tn=			12.12.10.14 Example 26-12. Embedded arrays and indirect references>
			12.12.10.15 Example 26-13. The Sieve of Eratosthenes <URL:#tn=			12.12.10.15 Example 26-13. The Sieve of Eratosthenes>
			12.12.10.16 Example 26-15. Emulating a push-down stack <URL:#tn=			12.12.10.16 Example 26-15. Emulating a push-down stack>
			12.12.10.17 Example 26-16. Complex array application: Exploring a weird mathematical series <URL:#tn=			12.12.10.17 Example 26-16. Complex array application: Exploring a weird mathematical series>
			12.12.10.18 Example 26-17. Simulating a two-dimensional array, then tilting it <URL:#tn=			12.12.10.18 Example 26-17. Simulating a two-dimensional array, then tilting it>
		12.12.11 Chapter 27. /dev and /proc <URL:#tn=		12.12.11 Chapter 27. /dev and /proc>
			12.12.11.1  /dev <URL:#tn=			12.12.11.1  /dev>
				12.12.11.1.1  loopback devices <URL:#tn=				12.12.11.1.1  loopback devices>
				12.12.11.1.2 To mount a USB flash drive, <URL:#tn=				12.12.11.1.2 To mount a USB flash drive,>
				12.12.11.1.3  /dev/tcp/$host/$port <URL:#tn=				12.12.11.1.3  /dev/tcp/$host/$port>
				12.12.11.1.4 Example 27-1. Using /dev/tcp for troubleshooting <URL:#tn=				12.12.11.1.4 Example 27-1. Using /dev/tcp for troubleshooting>
				12.12.11.1.5 Example 27-2. Playing music <URL:#tn=				12.12.11.1.5 Example 27-2. Playing music>
			12.12.11.2 /proc <URL:#tn=			12.12.11.2 /proc>
				12.12.11.2.1  Devices <URL:#tn=				12.12.11.2.1  Devices>
				12.12.11.2.2 interrupts <URL:#tn=				12.12.11.2.2 interrupts>
				12.12.11.2.3 partitions <URL:#tn=				12.12.11.2.3 partitions>
				12.12.11.2.4 more /proc <URL:#tn=				12.12.11.2.4 more /proc>
				12.12.11.2.5 battery <URL:#tn=				12.12.11.2.5 battery>
				12.12.11.2.6 Memory <URL:#tn=				12.12.11.2.6 Memory>
				12.12.11.2.7 Extract info from /proc <URL:#tn=				12.12.11.2.7 Extract info from /proc>
		12.12.12 Chapter 28. Of Zeros and Nulls <URL:#tn=		12.12.12 Chapter 28. Of Zeros and Nulls>
			12.12.12.1 Uses of /dev/null <URL:#tn=			12.12.12.1 Uses of /dev/null>
				12.12.12.1.1  Suppressing stderr and stdout <URL:#tn=				12.12.12.1.1  Suppressing stderr and stdout>
				12.12.12.1.2 Deleting contents of a file, but preserving the file itself, with all attendant permissions <URL:#tn=				12.12.12.1.2 Deleting contents of a file, but preserving the file itself, with all attendant permissions>
				12.12.12.1.3 Example 28-1. Hiding the cookie jar <URL:#tn=				12.12.12.1.3 Example 28-1. Hiding the cookie jar>
			12.12.12.1 Uses of /dev/zero <URL:#tn=			12.12.12.1 Uses of /dev/zero>
				12.12.12.1.1 Example 28-2. Setting up a swapfile using /dev/zero <URL:#tn=				12.12.12.1.1 Example 28-2. Setting up a swapfile using /dev/zero>
				12.12.12.1.2 Example 28-3. Creating a ramdisk <URL:#tn=				12.12.12.1.2 Example 28-3. Creating a ramdisk>
		12.12.13 Chapter 29. Debugging <URL:#tn=		12.12.13 Chapter 29. Debugging>
			12.12.13.1 Example 29-1. A buggy script <URL:#tn=			12.12.13.1 Example 29-1. A buggy script>
			12.12.13.2 Example 29-2. Missing keyword <URL:#tn=			12.12.13.2 Example 29-2. Missing keyword>
			12.12.13.3 Example 29-3. test24: another buggy script <URL:#tn=			12.12.13.3 Example 29-3. test24: another buggy script>
			12.12.13.4 Tools for debugging non-working scripts include <URL:#tn=			12.12.13.4 Tools for debugging non-working scripts include>
				12.12.13.4.1 Inserting echo statements at critical points in the script to trace the variables, and otherwise give a snapshot of what is going on. <URL:#tn=				12.12.13.4.1 Inserting echo statements at critical points in the script to trace the variables, and otherwise give a snapshot of what is going on.>
				12.12.13.4.2 Using the tee filter to check processes or data flows at critical points. <URL:#tn=				12.12.13.4.2 Using the tee filter to check processes or data flows at critical points.>
				12.12.13.4.3 Setting option flags -n -v -x <URL:#tn=				12.12.13.4.3 Setting option flags -n -v -x>
				12.12.13.4.4 Assert <URL:#tn=				12.12.13.4.4 Assert>
				12.12.13.4.5 Using the $LINENO variable and the caller builtin. <URL:#tn=				12.12.13.4.5 Using the $LINENO variable and the caller builtin.>
				12.12.13.4.6 Trapping at exit. <URL:#tn=				12.12.13.4.6 Trapping at exit.>
					12.12.13.4.6.1 Example 29-5. Trapping at exit <URL:#tn=					12.12.13.4.6.1 Example 29-5. Trapping at exit>
					12.12.13.4.6.2 Example 29-6. Cleaning up after Control-C <URL:#tn=					12.12.13.4.6.2 Example 29-6. Cleaning up after Control-C>
					12.12.13.4.6.3 Example 29-7. Tracing a variable <URL:#tn=					12.12.13.4.6.3 Example 29-7. Tracing a variable>
					12.12.13.4.6.4 Example 29-8. Running multiple processes (on an SMP box) <URL:#tn=					12.12.13.4.6.4 Example 29-8. Running multiple processes (on an SMP box)>
	12.12.13.4.7 Version 3 of Bash adds the following internal variables for use by the debugger. <URL:#tn=	12.12.13.4.7 Version 3 of Bash adds the following internal variables for use by the debugger.>
		12.12.14 Chapter 30. Options <URL:#tn=		12.12.14 Chapter 30. Options>
		12.12.15 Chapter 31. Gotchas <URL:#tn=		12.12.15 Chapter 31. Gotchas>
		12.12.16 Chapter 32. Scripting With Style <URL:#tn=		12.12.16 Chapter 32. Scripting With Style>
		12.12.17 Chapter 33. Miscellany <URL:#tn=		12.12.17 Chapter 33. Miscellany>
			12.12.17.1 Interactive and non-interactive shells and scripts <URL:#tn=			12.12.17.1 Interactive and non-interactive shells and scripts>
			12.12.17.2 Operator Precedence <URL:#tn=			12.12.17.2 Operator Precedence>
			12.12.17.3 Shell Wrappers <URL:#tn=			12.12.17.3 Shell Wrappers>
				12.12.17.3.1 Example 33-1. shell wrapper <URL:#tn=				12.12.17.3.1 Example 33-1. shell wrapper>
				12.12.17.3.2 Example 33-2. A slightly more complex shell wrapper <URL:#tn=				12.12.17.3.2 Example 33-2. A slightly more complex shell wrapper>
				12.12.17.3.3 Example 33-3. A generic shell wrapper that writes to a logfile <URL:#tn=				12.12.17.3.3 Example 33-3. A generic shell wrapper that writes to a logfile>
				12.12.17.3.4 Example 33-4. A shell wrapper around an awk script <URL:#tn=				12.12.17.3.4 Example 33-4. A shell wrapper around an awk script>
				12.12.17.3.5 Example 33-5. A shell wrapper around another awk script <URL:#tn=				12.12.17.3.5 Example 33-5. A shell wrapper around another awk script>
				12.12.17.3.6 Example 33-6. Perl embedded in a Bash script <URL:#tn=				12.12.17.3.6 Example 33-6. Perl embedded in a Bash script>
				12.12.17.3.7 Example 33-7. Bash and Perl scripts combined <URL:#tn=				12.12.17.3.7 Example 33-7. Bash and Perl scripts combined>
			12.12.17.4 Tests and Comparisons: Alternatives <URL:#tn=			12.12.17.4 Tests and Comparisons: Alternatives>
			12.12.17.5 A script calling itself (recursion) <URL:#tn=			12.12.17.5 A script calling itself (recursion)>
			12.12.17.6 Example 33-9. A (useful) script that recursively calls itself <URL:#tn=			12.12.17.6 Example 33-9. A (useful) script that recursively calls itself>
			12.12.17.7 Example 33-10. Another (useful) script that recursively calls itself <URL:#tn=			12.12.17.7 Example 33-10. Another (useful) script that recursively calls itself>
			12.12.17.8 Notes <URL:#tn=			12.12.17.8 Notes>
			12.12.17.6 "Colorizing" Scripts <URL:#tn=			12.12.17.6 "Colorizing" Scripts>
				12.12.17.6.1 Example 33-11. A "colorized" address database <URL:#tn=				12.12.17.6.1 Example 33-11. A "colorized" address database>
				12.12.17.6.2 Example 33-12. Drawing a box <URL:#tn=				12.12.17.6.2 Example 33-12. Drawing a box>
				12.12.17.6.3 Table 33-2. Numbers representing colors in Escape Sequences <URL:#tn=				12.12.17.6.3 Table 33-2. Numbers representing colors in Escape Sequences>
				12.12.17.6.4 Example 33-13. Echoing colored text <URL:#tn=				12.12.17.6.4 Example 33-13. Echoing colored text>
				12.12.17.6.5 Example 33-14. A "horserace" game <URL:#tn=				12.12.17.6.5 Example 33-14. A "horserace" game>
			12.12.17.7 Optimizations <URL:#tn=			12.12.17.7 Optimizations>
			12.12.17.8 Assorted Tips <URL:#tn=			12.12.17.8 Assorted Tips>
			    12.12.17.8.1. Ideas for more powerful scripts <URL:#tn=			    12.12.17.8.1. Ideas for more powerful scripts>
				12.12.17.8.1.1 TOP DOWN approach <URL:#tn=				12.12.17.8.1.1 TOP DOWN approach>
				12.12.17.8.1.2 Keep track of scripts <URL:#tn=				12.12.17.8.1.2 Keep track of scripts>
				12.12.17.8.1.3 Create script library <URL:#tn=				12.12.17.8.1.3 Create script library>
				12.12.17.8.1.4  Use command substitution to set a variable to function output. <URL:#tn=				12.12.17.8.1.4  Use command substitution to set a variable to function output.>
				12.12.17.8.1.5 Use special-purpose comment headers to increase clarity and legibility in scripts. <URL:#tn=				12.12.17.8.1.5 Use special-purpose comment headers to increase clarity and legibility in scripts.>
				12.12.17.8.1.6 Example 33-15. A Progress Bar <URL:#tn=				12.12.17.8.1.6 Example 33-15. A Progress Bar>
				12.12.17.8.1.7 $? for using exit status to perform tests <URL:#tn=				12.12.17.8.1.7 $? for using exit status to perform tests>
				12.12.17.8.1.8 remember the 0-255 range for function return values <URL:#tn=				12.12.17.8.1.8 remember the 0-255 range for function return values>
					12.12.17.8.1.8.1 Example 33-16. Return value trickery <URL:#tn=					12.12.17.8.1.8.1 Example 33-16. Return value trickery>
					12.12.17.8.1.8.2 The same technique also works for alphanumeric strings. <URL:#tn=					12.12.17.8.1.8.2 The same technique also works for alphanumeric strings.>
					12.12.17.8.1.8.3 Example 33-17. Even more return value trickery <URL:#tn=					12.12.17.8.1.8.3 Example 33-17. Even more return value trickery>
				12.12.17.8.1.9 <URL:#tn=				12.12.17.8.1.9>
				12.12.17.8.1.10 Using the double-parentheses construct <URL:#tn=				12.12.17.8.1.10 Using the double-parentheses construct>
				12.12.17.8.1.11 Setting the path and umask at the beginning of a script <URL:#tn=				12.12.17.8.1.11 Setting the path and umask at the beginning of a script>
				12.12.17.8.1.12 Repeatdly feed the output of filter <URL:#tn=				12.12.17.8.1.12 Repeatdly feed the output of filter>
					12.12.17.8.1.12.1 Example 33-19. Fun with anagrams <URL:#tn=					12.12.17.8.1.12.1 Example 33-19. Fun with anagrams>
				12.12.17.8.1.13 annonymous here documents <URL:#tn=				12.12.17.8.1.13 annonymous here documents>
				12.12.17.8.1.14 use whatis to check commands availability <URL:#tn=				12.12.17.8.1.14 use whatis to check commands availability>
				12.12.17.8.1.15 Caution when using if-grep test <URL:#tn=				12.12.17.8.1.15 Caution when using if-grep test>
				12.12.17.8.1.16 If you absolutely must access a subshell variable outside the subshell, here's a way to do it. <URL:#tn=				12.12.17.8.1.16 If you absolutely must access a subshell variable outside the subshell, here's a way to do it.>
			    12.12.17.8.2. Widgets <URL:#tn=			    12.12.17.8.2. Widgets>
				12.12.17.8.2..1 Example 33-20. Widgets invoked from a shell script <URL:#tn=				12.12.17.8.2..1 Example 33-20. Widgets invoked from a shell script>
			12.12.17.9 Security Issues <URL:#tn=			12.12.17.9 Security Issues>
			    12.12.17.9.1 Infected Shell Scripts <URL:#tn=			    12.12.17.9.1 Infected Shell Scripts>
			    12.12.17.9.2 Hiding Shell Script Source <URL:#tn=			    12.12.17.9.2 Hiding Shell Script Source>
			    12.12.17.9.3 Writing Secure Shell Scripts <URL:#tn=			    12.12.17.9.3 Writing Secure Shell Scripts>
			12.12.17.10 Portability Issues <URL:#tn=			12.12.17.10 Portability Issues>
			12.12.17.11 Shell Scripting Under Windows <URL:#tn=			12.12.17.11 Shell Scripting Under Windows>
		12.12.18 Chapter 34. Bash, versions 2 and 3 <URL:#tn=		12.12.18 Chapter 34. Bash, versions 2 and 3>
			12.12.18.1 Bash, version 2 <URL:#tn=			12.12.18.1 Bash, version 2>
3.2.25(1)-release <URL:#tn=3.2.25(1)-release>
			12.12.18.2 Bash, version 3 <URL:#tn=			12.12.18.2 Bash, version 3>
			    12.12.18.2.1 Bash, version 3.1 <URL:#tn=			    12.12.18.2.1 Bash, version 3.1>
			    12.12.18.2.2 Bash, version 3.2 <URL:#tn=			    12.12.18.2.2 Bash, version 3.2>
13. Paralel, Cuncurency, LWPs, multiple threads <URL:#tn=13. Paralel, Cuncurency, LWPs, multiple threads>
	13.1 Wait for Background Process to complete <URL:#tn=	13.1 Wait for Background Process to complete>
		13.1.1 Run multiple processes and wait for them to complete <URL:#tn=		13.1.1 Run multiple processes and wait for them to complete>
		13.1.2 parallelism or multiple threads in BASH <URL:#tn=		13.1.2 parallelism or multiple threads in BASH>
		13.1.3 My example, <URL:#tn=		13.1.3 My example,>
		13.1.4 <URL:#tn=		13.1.4>
14. Cookbook solutions <URL:#tn=14. Cookbook solutions>
	14.1 Reverse bash array (reverse list) <URL:#tn=	14.1 Reverse bash array (reverse list)>
		14.1.1 Pure Bash solution <URL:#tn=		14.1.1 Pure Bash solution>
		14.1.2 Using AWK <URL:#tn=		14.1.2 Using AWK>
		14.1.3 As a function <URL:#tn=		14.1.3 As a function>
	14.2 Monitor file size doesn't exceed given quota <URL:#tn=	14.2 Monitor file size doesn't exceed given quota>
	14.3 Time <URL:#tn=	14.3 Time>
		14.3.1 Linux - bash script to calculate time elapsed <URL:#tn=		14.3.1 Linux - bash script to calculate time elapsed>
		14.3.2 <URL:#tn=		14.3.2>
	14.4 Locks <URL:#tn=	14.4 Locks>
		14.4.1 Lock your script (against parallel run) <URL:#tn=		14.4.1 Lock your script (against parallel run)>
			14.4.1.1  flock <URL:#tn=			14.4.1.1  flock>
				14.4.1.1.1  Elegant Locking of BASH Program <URL:#tn=				14.4.1.1.1  Elegant Locking of BASH Program>
			14.4.1.2 <URL:#tn=			14.4.1.2>
		14.4.2 <URL:#tn=		14.4.2>
	14.5 <URL:#tn=	14.5>
15.  odds and ends <URL:#tn=15.  odds and ends>
	15.1  Block signals <URL:#tn=	15.1  Block signals>
		15.1.1  SIGTERM, block ctrl+x <URL:#tn=		15.1.1  SIGTERM, block ctrl+x>
		15.1.2 Catching signals <URL:#tn=		15.1.2 Catching signals>
			15.1.2.1 Finding the signal man page <URL:#tn=			15.1.2.1 Finding the signal man page>
			15.1.2.2 Signals to your Bash shell <URL:#tn=			15.1.2.2 Signals to your Bash shell>
			15.1.2.3 Usage of signals with kill <URL:#tn=			15.1.2.3 Usage of signals with kill>
			15.1.2.4 Traps <URL:#tn=			15.1.2.4 Traps>
			15.1.2.5 How Bash interprets traps <URL:#tn=			15.1.2.5 How Bash interprets traps>
			15.1.2.6 More examples <URL:#tn=			15.1.2.6 More examples>
		15.1.3 <URL:#tn=		15.1.3>
	15.2 Tutorial: Conditions in bash scripting (if statements) <URL:#tn=	15.2 Tutorial: Conditions in bash scripting (if statements)>
		15.2.1 Introduction <URL:#tn=		15.2.1 Introduction>
		15.2.2 The syntax of an if statement (a short explanation) <URL:#tn=		15.2.2 The syntax of an if statement (a short explanation)>
		15.2.3 The basic rules of conditions <URL:#tn=		15.2.3 The basic rules of conditions>
		15.2.4 Different condition syntaxes <URL:#tn=		15.2.4 Different condition syntaxes>
			15.2.4.1 Single-bracket syntax <URL:#tn=			15.2.4.1 Single-bracket syntax>
			15.2.4.2 Double-bracket syntax <URL:#tn=			15.2.4.2 Double-bracket syntax>
			15.2.4.3 Double-parenthesis syntax <URL:#tn=			15.2.4.3 Double-parenthesis syntax>
		15.2.5 Table of conditions <URL:#tn=		15.2.5 Table of conditions>
			15.2.5.1 File-based conditions: <URL:#tn=			15.2.5.1 File-based conditions:>
			15.2.5.2 String-based conditions: <URL:#tn=			15.2.5.2 String-based conditions:>
			15.2.5.3 Arithmetic (number-based) conditions: <URL:#tn=			15.2.5.3 Arithmetic (number-based) conditions:>
			15.2.5.4 Miscellaneous conditions: <URL:#tn=			15.2.5.4 Miscellaneous conditions:>
			15.2.5.5 Double-parenthesis syntax conditions: <URL:#tn=			15.2.5.5 Double-parenthesis syntax conditions:>
		15.2.6 Diving a little deeper <URL:#tn=		15.2.6 Diving a little deeper>
		15.2.7 Conclusion <URL:#tn=		15.2.7 Conclusion>
	15.3 The case statement <URL:#tn=	15.3 The case statement>
1.1 Example <URL:#tn=1.1 Example>
1.2 Using Multiple Patterns <URL:#tn=1.2 Using Multiple Patterns>
1.3 Creating a backup script <URL:#tn=1.3 Creating a backup script>
	15.4 <URL:#tn=	15.4>
16. FAQ <URL:#tn=16. FAQ>
	16.1  How to trim whitespace from bash variable? <URL:#tn=	16.1  How to trim whitespace from bash variable?>
		16.1.1  I needed to trim whitespace from a script when the IFS variable was set to something else. Relying on perl did the trick: <URL:#tn=		16.1.1  I needed to trim whitespace from a script when the IFS variable was set to something else. Relying on perl did the trick:>
		16.1.2 assignments ignore leading and trailing whitespace and as such can be used to trim <URL:#tn=		16.1.2 assignments ignore leading and trailing whitespace and as such can be used to trim>
		16.1.3 You can use old-school tr. For example, this returns the number of modified files in a git repository, whitespaces stripped. <URL:#tn=		16.1.3 You can use old-school tr. For example, this returns the number of modified files in a git repository, whitespaces stripped.>
		16.1.4 This will remove all spaces ... <URL:#tn=		16.1.4 This will remove all spaces ...>
		16.1.5 # "Remove leading & trailing whitespace from a Bash variable", <URL:#tn=		16.1.5 # "Remove leading & trailing whitespace from a Bash variable",>
		16.1.6 how to read a file line by line <URL:#tn=		16.1.6 how to read a file line by line>
		16.1.7 <URL:#tn=		16.1.7>
	16.2 Match comment lines in file, regexp match example <URL:#tn=	16.2 Match comment lines in file, regexp match example>
	16.3 Edit file from bash script <URL:#tn=	16.3 Edit file from bash script>
		16.3.1 perl <URL:#tn=		16.3.1 perl>
		16.3.2 Sed <URL:#tn=		16.3.2 Sed>
		16.3.3 pure bash <URL:#tn=		16.3.3 pure bash>
		16.3.4 ex <URL:#tn=		16.3.4 ex>
		16.3.5 ed <URL:#tn=		16.3.5 ed>
		16.3.6 <URL:#tn=		16.3.6>
	16.4 Quoting <URL:#tn=	16.4 Quoting>
		16.4.1 execute commands bash script quoting problem <URL:#tn=		16.4.1 execute commands bash script quoting problem>
		16.4.2 <URL:#tn=		16.4.2>
	16.5 How to define hash tables in bash? <URL:#tn=	16.5 How to define hash tables in bash?>
	16.6 Tokenizing a string, split a string <URL:#tn=	16.6 Tokenizing a string, split a string>
		16.6.1 Bash: How to tokenize a string variable? <URL:#tn=		16.6.1 Bash: How to tokenize a string variable?>
		16.6.2 Split a string on newlines (bash) <URL:#tn=		16.6.2 Split a string on newlines (bash)>
		16.6.3 <URL:#tn=		16.6.3>
	16.7 How do I prompt a user for confirmation in bash script? <URL:#tn=	16.7 How do I prompt a user for confirmation in bash script?>
	16.8 redirect stderr to stdout <URL:#tn=	16.8 redirect stderr to stdout>
	16.9 Extract directory path from file name <URL:#tn=	16.9 Extract directory path from file name>
	16.10 <URL:#tn=	16.10>
17. Pro Bash Programming: Scripting the GNU/Linux Shell <URL:#tn=17. Pro Bash Programming: Scripting the GNU/Linux Shell>
	17.8. File Operations and Commands <URL:#tn=	17.8. File Operations and Commands>
		17.8.1 Section 8.1. Reading a File <URL:#tn=		17.8.1 Section 8.1. Reading a File>
		17.8.2 Section 8.2. External Commands <URL:#tn=		17.8.2 Section 8.2. External Commands>
		17.8.3 Section 8.3. Regular Expressions <URL:#tn=		17.8.3 Section 8.3. Regular Expressions>
		17.8.4 Section 8.4. File Name Expansion Options <URL:#tn=		17.8.4 Section 8.4. File Name Expansion Options>
		17.8.5 Section 8.5. Summary <URL:#tn=		17.8.5 Section 8.5. Summary>
		17.8.6 Section 8.6. Exercises <URL:#tn=		17.8.6 Section 8.6. Exercises>
18.  My examples <URL:#tn=18.  My examples>
	18.1  loop over words in string <URL:#tn=	18.1  loop over words in string>
	18.2 <URL:#tn=	18.2>
19. Pattern Matching & globes <URL:#tn=19. Pattern Matching & globes>
	19.1 http://mywiki.wooledge.org/BashGuide/Patterns <URL:#tn=	19.1 http://mywiki.wooledge.org/BashGuide/Patterns>
	19.2 BASH_REMATCH examples <URL:#tn=	19.2 BASH_REMATCH examples>
		19.2.1 Capture script <URL:#tn=		19.2.1 Capture script>
		19.2.2 <URL:#tn=		19.2.2>
	19.3 <URL:#tn=	19.3>
20. mac, tags: macos, mac, osx, bash <URL:#tn=20. mac, tags: macos, mac, osx, bash>
    20.1 upgrade bash version <URL:#tn=    20.1 upgrade bash version>
    20.2 <URL:#tn=    20.2>
21. bash versions features , tags: bash versions features <URL:#tn=21. bash versions features , tags: bash versions features>
    21.1 bash version 1 <URL:#tn=    21.1 bash version 1>
    21.2 bash version 2 <URL:#tn=    21.2 bash version 2>
        21.2.1  String expansion. <URL:#tn=        21.2.1  String expansion.>
        21.2.2  Indirect variable referencing. <URL:#tn=        21.2.2  Indirect variable referencing.>
        21.2.3 forEach in bash <URL:#tn=        21.2.3 forEach in bash>
        21.2.4 <URL:#tn=        21.2.4>
    21.3 bash version 3 <URL:#tn=    21.3 bash version 3>
        21.3.1 A new, more generalized {a..z} brace expansion operator. <URL:#tn=        21.3.1 A new, more generalized {a..z} brace expansion operator.>
            21.3.1.1 my examples <URL:#tn=            21.3.1.1 my examples>
            21.3.1.2 from source <URL:#tn=            21.3.1.2 from source>
        21.3.2 The ${!array[@]} operator, which expands to all the indices of a given array. iterate array <URL:#tn=        21.3.2 The ${!array[@]} operator, which expands to all the indices of a given array. iterate array>
        21.3.3 The =~ Regular Expression matching operator within a double brackets test expression. (Perl has a similar operator.) <URL:#tn=        21.3.3 The =~ Regular Expression matching operator within a double brackets test expression. (Perl has a similar operator.)>
    21.4 bash version 4 <URL:#tn=    21.4 bash version 4>
        21.4.1 Associative arrays. <URL:#tn=        21.4.1 Associative arrays.>
        21.4.2 Enhancements to the case construct: the ;;& and ;& terminators. <URL:#tn=        21.4.2 Enhancements to the case construct: the ;;& and ;& terminators.>
        21.4.3 The new coproc builtin enables two parallel processes to communicate and interact. <URL:#tn=        21.4.3 The new coproc builtin enables two parallel processes to communicate and interact.>
        21.4.4 Parameter substitution gets case-modification operators. <URL:#tn=        21.4.4 Parameter substitution gets case-modification operators.>
        21.4.5 The declare builtin now accepts the -l lowercase and -c capitalize options. <URL:#tn=        21.4.5 The declare builtin now accepts the -l lowercase and -c capitalize options.>
        21.4.6 Brace expansion has more options. <URL:#tn=        21.4.6 Brace expansion has more options.>
        21.4.7 Substring extraction on positional parameters now starts with $0 as the zero-index. <URL:#tn=        21.4.7 Substring extraction on positional parameters now starts with $0 as the zero-index.>
        21.4.8 The new ** globbing operator matches filenames and directories recursively. <URL:#tn=        21.4.8 The new ** globbing operator matches filenames and directories recursively.>
        21.4.9 command_not_found_handle <URL:#tn=        21.4.9 command_not_found_handle>
        21.4.10 Here documents embedded in $( ... ) command substitution constructs may terminate with a simple ). <URL:#tn=        21.4.10 Here documents embedded in $( ... ) command substitution constructs may terminate with a simple ).>
        21.4.11 Negative array indices permit counting backwards from the end of an array. <URL:#tn=        21.4.11 Negative array indices permit counting backwards from the end of an array.>
        21.4.12 Negative parameter in string-extraction construct <URL:#tn=        21.4.12 Negative parameter in string-extraction construct>
        21.4.13 <URL:#tn=        21.4.13>
    21.5 bash version 5 <URL:#tn=    21.5 bash version 5>
        21.5.1 <URL:#tn=        21.5.1>
    21.6 bash version 6 <URL:#tn=    21.6 bash version 6>
    21.7 <URL:#tn=    21.7>
22. command line scripts, tags:  command line scripts, CLI, arguments, parameters <URL:#tn=22. command line scripts, tags:  command line scripts, CLI, arguments, parameters>
    22.1 chatgpt <URL:#tn=    22.1 chatgpt>
        22.1.1 command line scripts, tags:  command line scripts, CLI, arguments, parameters <URL:#tn=        22.1.1 command line scripts, tags:  command line scripts, CLI, arguments, parameters>
        22.1.2 are there additional ways <URL:#tn=        22.1.2 are there additional ways>
        22.1.3 yet more ways <URL:#tn=        22.1.3 yet more ways>
        22.1.4 bash script to process a text file containing a list of names <URL:#tn=        22.1.4 bash script to process a text file containing a list of names>
        22.1.5 parse json file containing an array of names and print each name bash <URL:#tn=        22.1.5 parse json file containing an array of names and print each name bash>
        22.1.6 parse json file containing an array of names and load the names into an array then iterate over the array of names <URL:#tn=        22.1.6 parse json file containing an array of names and load the names into an array then iterate over the array of names>
        22.1.7 linux delete all files with specific pattern <URL:#tn=        22.1.7 linux delete all files with specific pattern>
        22.1.8 <URL:#tn=        22.1.8>
    22.2 <URL:#tn=    22.2>
23. <URL:#tn=23.>
.................................................END TOC..............................................

































































Description: 	Knoweledge of bash, related to both user and scripting.
Author:		Yosi Izaq.



1. arithmetic 

	1.1 expansion.
	$ echo $(( 2 + 3 * 5 ))
	returns 17.

	1.2 floating point arithmetic bash

		1.2.1  via bc
 If we want to add two floating point numbers say 2.5 and 3.75, then simply the string 2.5+3.75 should be feed into the input of bc and you are done. Check out the example below:

echo "2.5+3.75" | bc
| 6.25

Above the first line shows the input to bash, and the second line is the output.

As now you have understood the basic trick, that is so simply feed in any arithmetic expression into a programs input, who understands it, to get the answer from it, i will present some more examples.
Examples

Now lets say you want to get a square root of a number (floating point), say 641 . The function of bc which performs square root is sqrt. And as we are performing a math function we need to tell bc to turn on its standard math library. This can be done just by including the -l switch to bc. So the command will be as below:

echo "sqrt(641)" | bc -l
| 25.31797780234432546177

Till now you should have guessed that we can also use the shell variables in the echo with double quotes to enable variable value. For example check the command sequence below:

x=215
echo "sqrt($x)" | bc -l

And yes now the command performs the square root of the variable x , which can be assigned whatever.

The below nano shell script performs floating point addition operation using bc.

01	     
02	#!/bin/bash
03	echo "Enter a floating point number: "
04	read a
05	 
06	echo "Enter another floating point number: "
07	read b
08	 
09	echo "Addition: "
10	echo "$a+$b" | bc

Integer powers of a floating point could be calculated with the ^ operator. Below a is a floating point and b is integer.

echo "$a^$b" | bc -l

So it is simple. Now some trigonometric functions. In bc the s is the sine function, c is the cos function, and the a is the arctangent function (atan). And as normal the angles are to be passed as radians, but we can always do a degree to radian conversion. So we have the basic two. The below shell script demonstrates the calculation of different trigonometric vales.

01	#!/bin/bash
02	echo "Enter angle in degree: "
03	read deg
04	 
05	# Note: Pi calculation
06	# tan(pi/4) = 1
07	# atan(1) = pi/4 and
08	# pi = 4*atan(1)
09	 
10	pi=`echo "4*a(1)" | bc -l`
11	rad=`echo "$deg*($pi/180)" | bc -l`
12	 
13	echo "$deg Degree = $rad Radian"
14	 
15	echo "Sin($deg): "
16	echo "s($rad)" | bc -l
17	 
18	echo "Cos($deg): "
19	echo "c($rad)" | bc -l
20	 
21	echo "Tan($deg): "
22	echo "s($rad)/c($rad)" | bc -l

The natural logarithmic function in bc is l. So to calculate natural logarithm and ten base logarithm we would do the following:

1	#!/bin/bash
2	echo "Enter value: "
3	read x
4	 
5	echo "Natural Log: ln($x) :"
6	echo "l($x)" | bc -l
7	 
8	echo "Ten Base Log: log($x) :"
9	echo "l($x)/l(10)" | bc -l

And similarly the exponential function could be implemented by calling the e function in bc.

You can adjust the precision of the value which the math functions calculate be assigning the decimal point accuracy in the scale variable within bc. For an example if you want square root of a number up to 2 decimal places, you should do as below, where x is the variable.

echo "scale=2;sqrt($x)" | bc -l

Note that it simply truncates the decimal places, so the scaled value is not the approximation but only truncated. For example 6.74536878161602073277 in 2 decimal places would be simple truncated to 6.74, and not 6.75
More

And now you can write a function in bc syntax and also make it use. As presented below, a factorial function:

01	#!/bin/bash
02	 
03	echo "Enter an integer: "
04	read n
05	 
06	# Below we define the factorial function in bc syntax
07	fact="define f (x) {
08	i=x
09	fact=1
10	while (i > 1) {
11	fact=fact*i
12	i=i-1
13	}
14	return fact
15	}"
16	 
17	# Below we pass the function defined above, and call it with n as a parameter and pipe it to bc
18	factorial=`echo "$fact;f($n)" | bc -l`
19	 
20	echo "$n! = $factorial"

Clearly any other functions written in bc syntax could be used
Resources

Check out more functions and operators and all the details of bc by visiting the site here: http://www.gnu.org/software/bc/manual/html_mono/bc.html , and also check the man page and info pages by executing:

man bc
info bc

		1.2.2

	1.3 Floating Point Comparison in Shell Script

		1.3.1 Can you please suggest to me the syntax for doing floating point comparison in a Bash script? 
		I would ideally like to use it as part of an if statement. 
		Here is a small code snippet :

key1="12.3"
result="12.2"

if (( $result <= $key1 ))
then
    # some code here
fi


-> bash doesn't do floats, use awk

key1=12.3
result=12.5
var=$(awk 'BEGIN{ print "'$key1'"<"'$result'" }')    
# or var=$(awk -v key=$key1 -v result=$result 'BEGIN{print result<key?1:0}')
# or var=$(awk 'BEGIN{print "'$result'"<"'$key1'"?1:0}')
# or 
if [ "$var" -eq 1 ];then
  echo "do something"
else
  echo "result more than key"
fi

there are other shells that can do floats, like zsh or ksh, you might like to try using them as well

-> 
bc is your friend:

key1="12.3"
result="12.2"
if [ $(bc <<< "$result <= $key1") -eq 1 ]
    then
    # some code here
fi

Note the somewhat obscure here string (<<<) notation, as a nice alternative to echo "$result <= $key1" | bc.

Also, the un-bash-like bc prints 1 for true and 0 for false.

		1.3.2 My example
[root@cow3 ~]# if [ $( bc <<< " $(( $(df  /opt | sed -n '3p' | awk '{print $1}') * 1024 ))   > $( echo "$( du -s /opt/CSCOacs/patches/ | awk '{print $1}' )  * 1.1 " | bc ) " ) -eq 1 ]   ; then echo a ; else echo b; fi
a
[root@cow3 ~]# if [ $( bc <<< " $(( $(df  /opt | sed -n '3p' | awk '{print $1}') * 1024 ))   > $( echo "$( du -s /opt/CSCOacs/patches/ | awk '{print $1}' )  * 1000 " | bc ) " ) -eq 1 ]   ; then echo a ; else echo b; fi
a
[root@cow3 ~]# if [ $( bc <<< " $(( $(df  /opt | sed -n '3p' | awk '{print $1}') * 1024 ))   > $( echo "$( du -s /opt/CSCOacs/patches/ | awk '{print $1}' )  * 10000 " | bc ) " ) -eq 1 ]   ; then echo a ; else echo b; fi
a
[root@cow3 ~]# if [ $( bc <<< " $(( $(df  /opt | sed -n '3p' | awk '{print $1}') * 1024 ))   > $( echo "$( du -s /opt/CSCOacs/patches/ | awk '{print $1}' )  * 100000 " | bc ) " ) -eq 1 ]   ; then echo a ; else echo b; fi
b

		1.3.3

	1.4 Arithmetic Expansion
http://tldp.org/LDP/abs/html/arithexp.html
Arithmetic expansion provides a powerful tool for performing (integer) arithmetic operations in scripts. Translating a string into a numerical expression is relatively straightforward using backticks, double parentheses, or let.

Variations

Arithmetic expansion with backticks (often used in conjunction with expr)
z=`expr $z + 3`          # The 'expr' command performs the expansion.

Arithmetic expansion with double parentheses, and using let
The use of backticks (backquotes) in arithmetic expansion has been superseded by double parentheses -- ((...)) and $((...)) -- and also by the very convenient let construction.

z=$(($z+3))
z=$((z+3))                                  #  Also correct.
                                            #  Within double parentheses,
                                            #+ parameter dereferencing
                                            #+ is optional.

# $((EXPRESSION)) is arithmetic expansion.  #  Not to be confused with
                                            #+ command substitution.



# You may also use operations within double parentheses without assignment.

  n=0
  echo "n = $n"                             # n = 0

  (( n += 1 ))                              # Increment.
# (( $n += 1 )) is incorrect!
  echo "n = $n"                             # n = 1


let z=z+3
let "z += 3"  #  Quotes permit the use of spaces in variable assignment.
              #  The 'let' operator actually performs arithmetic evaluation,
              #+ rather than expansion.

	1.5
	id=__bash_prompt_history1
2. command history.
	2.1. last command
	$ !!

	2.2 last prefix command
	$ !pref

	example
	$ ping 1.2.3.4
	$ !pin
	repeats the ping command

	If you want to print the command instead of execute it do:
	$ !prefix:p

	2.3 search history

	ctrl+r (^r) 

	2.4 Argument of last command !$
	$ mkdir long/directory/name
	$ cd !$


	id=__bash_prompt_history2
3. parameter of previous commands.
	3.1 last parameter of previous command !$
	example:
	$ ls some_long_path
	$ vi !$ 
	vi will open the file with long path

	3.2 all paramters of previous command !*

	vi cd /stuff
	oops!
	[exit vi, twice]
	!*
	Which bash expands to: cd /stuff

	3.4 replace typos in previous command. the ^old^new...
 	example:
	vi /etc/X11/XF86config
	oops!
	^6c^6C
	Which bash turns into:
	vi /etc/X11/XF86Config

	3.5 substitute cont.

		3.5.1  1 time substitute


	!!:s/old/new/

	example:
	$ vi /etc/X11/XF86config
	$ !!:s/config/Config-4/

		3.5.2 global substitute (of last command - !!)
	$ mroe file1 ; mroe file2
	$ !!:gs/mroe/more

	3.6 More bash prompt tips

# BASH HISTORY SEARCH AND REPLACE
      ^string1^string2^ Quick substitution. Repeat the last command, replacing string1 with
      string2. Equivalent to ``!!:s/string1/string2/''

# MORE BASH COMMAND LINE TRICKERY (messing with the history)
make a directory then move into it:
mkdir cgi-bin; cd !#$ 
!#$ is shorthand for "the first word of this command". If I wanted to pick the third word
out of the previous command, that would be: !!:3 (don't forget there is a zeroth word).

# execute the most recent command the contains the following string: 
!?string

# globally search replace on the previous line:
!!:gs/old/new/

# HEADS AND TAILS
ever wanted to copy a few files in the same directory, all of which have same 
long prefix, like: cp /usr/local/etc/apache/file1.txt /usr/local/etc/apache/file2.txt
you can grap and reuse that prefix. It's named !#:1:h like:
cp /usr/local/etc/apache/file1.txt !#:1:h/file2.txt !#:1:h/file3.txt


# SAVING A COMMAND WITHOUT EXECUTING
While using bash, if you have typed a long command, and then realize you don't want to execute it yet, don't delete it. Simply
append a # to the beginning of the line, and then hit enter. Bash will not execute the command, but will store it in history so later
you can go back, remove the # from the front, and execute it. 

# GOING FORWARD A BACK A WORD
META-F goes forward a word
META-B goes backward a word

# COMPARE A FILE WITH IT'S VARIOUS VERSIONS IN THE SAME DIRECTORY
diff file.*

# EXAMPLE of a basic command line script
for f in `ls | grep -v "\.sh$"`; { mv ${f} ${f}.sh; }

# searching the history
Cntrl-R starts a reverse incremental search 

# Keyboard shortcuts: 
CTRL-k: delete ('kill') from cursor position to the end of the line
*	CTRL-u: delete from cursor position to the beginning of the line
*	ALT-d: delete from cursor position to the end of the current 'word'
*	CTRL-w: delete from cursor position to the beginning of the current 'word'
*	CTRL-a: move cursor to the first character of the line
*	CTRL-e: move cursor beyond the last character of the line
*	ALT-a: move cursor to the first character of the current 'word'
*	ALT-e: move cursor to the last character of the current 'word'
*	CTRL-y: insert latest deleted 'word'
*	ESC-_ or !$: repeats the last argument of the previous command.
Example: You created a directory with mkdir /usr/local/bin/peter/pan. Now you want to change into that directory with cd. Instead of typing the path again, you type cd ESC-_ or

# Diff 2 files with a common base:
diff {alpha,beta}site/config/Config.pl


	3.7 The Definitive Guide to Bash Command Line History
 
Let me teach you how to work efficiently with command line history in bash.

This tutorial comes with a downloadable cheat sheet that summarizes (and expands on) topics covered here (scroll to the end for a download link).

In case you are a first time reader, this is the 3rd part of the article series on working efficiently in bourne again shell. Previously I have written on how to work efficiently in vi and emacs command editing modes by using predefined keyboard shortcuts (both articles come with cheat sheets of predefined shortcuts).

First, lets review some basic keyboard shortcuts for navigating around previously typed commands.

As you remember, bash offers two modes for command editing - emacs mode and vi mode. In each of these editing modes the shortcuts for retrieving history are different.

Suppose you had executed the following commands:

$ echo foo bar baz
$ iptables -L -n -v -t nat
$ ... lots and lots more commands
$ echo foo foo foo
$ perl -wle 'print q/hello world/'
$ awk -F: '{print$1}' /etc/passwd
$
and you wanted to execute the last command (awk -F ...).

You could certainly hit the up arrow and live happily along, but do you really want to move your hand that far away?

If you are in emacs mode just try CTRL-p which fetches the previous command from history list (CTRL-n for the next command).

In vi mode try CTRL-[ (or ESC) (to switch to command mode) and 'h' ('j' for the next command).

There is another, equally quick, way to do that by using bash's history expansion mechanism - event designators. Typing '!!' will execute the previous command (more about event designators later).

Now, suppose that you wanted to execute 'iptables -L -n -v -t nat' command again without retyping it.

A naive user would, again, just keep hitting up-arrow key until he/she finds the command. But that's not the way hackers work. Hackers love to work quickly and efficiently. Forget about arrow keys and page-up, page-down, home and end keys. They are completely useless and, as I said, they are too far off from the main part of the keyboard anyway.

In emacs mode try CTRL-r and type a few first letters of 'iptables', like 'ipt'. That will display the last iptables command you executed. In case you had more than one iptables commands executed in between, hitting CTRL-r again will display older entries. In case you miss the right command and move too deep into history list, you can reverse the search direction by hitting CTRL-s (don't forget that by default CTRL-s stops the output to the terminal and you'll get an effect of "frozen" terminal (hit CTRL-q to "unfreeze"), see stty command to change this behavior).

In vi mode the same CTRL-r and CTRL-s still work but there is another way more specific to vi mode.
Switch to command mode by hitting CTRL-[ or ESC and hit '/', then type a first few characters of 'iptables' command, like 'ipt' and hit return. Bash will display the most recent match found in history. To navigate around use 'n' or just plain '/' to repeat the search in the same direction, and 'N' or '?' to repeat the search in opposite direction!

With event designators you may execute only the most recently executed command matching (or starting with) 'string'.

Try '!iptables' history expansion command which refers to the most recent command starting with 'iptables'.

Another way is to use bash's built in 'history' command then grep for a string of interest and finally use an event designator in form '!N', where N is an integer which refers to N-th command in command history list.

For example,

$ history | grep 'ipt'
  2    iptables -L -n -v -t nat
$ !2     # will execute the iptables command
I remembered another way to execute N-th command in history list in vi editing mode. Type 'N' (command number) and then 'G', in this example '2G'

Listing and Erasing Command History

Bash provides a built-in command 'history' for viewing and erasing command history.

Suppose that we are still working with the same example:

$ echo foo bar baz
$ iptables -L -n -v -t nat
$ ... lots and lots more commands
$ echo foo foo foo
$ perl -wle 'print q/hello world/'
$ awk -F: '{print$1}' /etc/passwd
$
Typing 'history' will display all the commands in bash history alongside with line numbers:

  1    echo foo bar baz
  2    iptables -L -n -v -t nat
  ...  lots and lots more commands
  568  echo foo foo foo
  569  perl -wle 'print q/hello world/'
  570  awk -F: '{print$1}' /etc/passwd
Typing 'history N', where N is an integer, will display the last N commands in the history.
For example, 'history 3' will display:

  568  echo foo foo foo
  569  perl -wle 'print q/hello world/'
  570  awk -F: '{print$1}' /etc/passwd
history -c will clear the history list and history -d N will delete a history entry N.

By default, the history list is kept in user's home directory in a file '.bash_history'.

History Expansion

History expansion is done via so-called event designators and word designators. Event designators can be used to recall previously executed commands (events) and word designators can be used to extract command line arguments from the events. Optionally, various modifiers can be applied to the extracted arguments.

Event designators are special commands that begin with a '!' (there is also one that begins with a '^'), they may follow a word designator and one or more modifiers. Event designators, word designators and modifiers are separated by a colon ':'.

Event Designators

Lets look at a couple of examples to see how the event designators work.

Event designator '!!' can be used to refer to the previous command, for example,

$ echo foo bar baz
foo bar baz
$ !!
foo bar baz
Here the '!!' executed the previous 'echo foo bar baz' command.

Event designator '!N' can be used to refer to the N-th command.
Suppose you listed the history and got the following output:

  1    echo foo foo foo
  2    iptables -L -n -v -t nat
  ...  lots and lots more commands
  568  echo bar bar bar
  569  perl -wle 'print q/hello world/'
  570  awk -F: '{print$1}' /etc/passwd
Then the event designator '!569' will execute 'perl ...' command, and '!1' will execute 'echo foo foo foo' command!

Event designator '!-N' refers to current command line minus N. For example,

$ echo foo bar baz
foo bar baz
$ echo a b c d e
a b c d e
$ !-2
foo bar baz
Here the event designator '!-2' executed a one before the previous command, or current command line minus 2.

Event designator '!string' refers to the most recent command starting with 'string'. For example,

$ awk --help
$ perl --help
Then the event designator '!p' or '!perl' or '!per' will execute the 'perl --help' command. Similarly, '!a' will execute the awk command.

An event designator '!?string?' refers to a command line containing (not necessarily starting with) 'string'.

Perhaps the most interesting event designator is the one in form '^string1^string2^' which takes the last command, replaces string1 with string2 and executes it. For example,

$ ehco foo bar baz
bash: ehco: command not found
$ ^ehco^echo^
foo bar baz
Here the '^ehco^echo^' designator replaced the incorrectly typed 'ehco' command with the correct 'echo' command and executed it.

Word Designators and Modifiers

Word designators follow event designators separated by a colon. They are used to refer to some or all of the parameters on the command referenced by event designator.

For example,

$ echo a b c d e
a b c d e
$ echo !!:2
b
This is the simplest form of a word designator. ':2' refers to the 2nd argument of the command (3rd word). In general ':N' refers to Nth argument of the command ((N+1)-th word).

Word designators also accept ranges, for example,

$ echo a b c d e
a b c d e
$ echo !!:3-4
c d
There are various shortcuts, such as, ':$' to refer to the last argument, ':^' to refer to the first argument, ':*' to refer to all the arguments (synonym to ':1-$'), and others. See the cheat sheet for a complete list.

Modifiers can be used to modify the behavior of a word designators. For example:

$ tar -xvzf software-1.0.tgz
software-1.0/file
...
$ cd !!:$:r
software-1.0$
Here the 'r' modifier was applied to a word designator which picked the last argument from the previous command line. The 'r' modifier removed the trailing suffix '.tgz'.

The 'h' modifier removes the trailing pathname component, leaving the head:

$ echo /usr/local/apache
/usr/local/apache
$ echo !!:$:h
/usr/local
The 'e' modifier removes all but the trailing suffix:

$ ls -la /usr/src/software-4.2.messy-Extension
...
$ echo /usr/src/*!!:$:e
/usr/src/*.messy-Extension    # ls could have been used instead of echo
Another interesting modifier is the substitute ':s/old/new/' modifier which substitutes new for old. It can be used in conjunction with 'g' modifier to do global substitution. For example,

$ ls /urs/local/software-4.2 /urs/local/software-4.3
/usr/bin/ls: /urs/local/software-4.2: No such file or directory
/usr/bin/ls: /urs/local/software-4.3: No such file or directory
$ !!:gs/urs/usr/
...
This example replaces all occurances of 'urs' to 'usr' and makes the command correct.

There are a few other modifiers, such as 'p' modifier which prints the resulting command after history expansion but does not execute it. See the cheat sheet for all of the modifiers.

Modifying History Behavior

Bash allows you to modify which commands get stored in the history list, the file where they get stored, the number of commands that get stored, and a few other options.

These options are controlled by setting HISTFILE, HISTFILESIZE, HISTIGNORE and HISTSIZE environment variables.

HISTFILE, as the name suggests, controls where the history file gets saved. 
For example,

$ export HISTFILE=/home/pkrumins/todays_history
will save the commands to a file /home/pkrumins/todays_history

Set it to /dev/null or unset it to avoid getting your history list saved.

HISTFILESIZE controls how many history commands to keep in HISTFILE.
For example,

$ export HISTFILESIZE=1000
will keep the last 1000 history commands.

HISTSIZE controls how many history commands to keep in the history list of current session.
For example,

$ export HISTSIZE=42
will keep 42 last commands in the history of current session.

If this number is less than HISTFILESIZE, only that many commands will get written to HISTFILE.

HISTIGNORE controls the items which get ignored and do not get saved. This variable takes a list of colon separated patterns. Pattern '&' (ampersand) is special in a sense that it matches the previous history command.

There is a trick to make history ignore the commands which begin with a space. The pattern for that is "[ ]*"

For example,

$ export HISTIGNORE="&:[ ]*:exit"
will make bash ignore duplicate commands, commands that begin with a space, and the 'exit' command.

There are several other options of interest controlled by the built-in 'shopt' command.

The options may be set by specifying '-s' parameter to the 'shopt' command, and may be unset by specifying '-u' parameter.

Option 'histappend' controls how the history list gets written to HISTFILE, setting the option will append history list of current session to HISTFILE, unsetting it (default) will make HISTFILE get overwritten each time.

For example, to set this option, type:

$ shopt -s histappend
And to unset it, type:

$ shopt -u histappend
Option 'histreedit' allows users to re-edit a failed history substitution.

For example, suppose you had typed:

$ echo foo bar baz
and wanted to substitute 'baz' for 'test' with the ^baz^test^ event designator , but you made a mistake and typed ^boo^test^. This would lead to a substitution failure because the previous command does not contain string 'boo'.

If you had this option turned on, bash would put the erroneous ^baz^test^ event designator back on the command line as if you had typed it again.

Finally, option 'histverify' allows users to verify a substituted history expansion.

Based on the previous example, suppose you wanted to execute that 'echo' command again by using the '!!' event designator. If you had this option on, bash would not execute the 'echo' command immediately but would first put it on command line so that you could see if it had made the correct substitution.

Tuning the Command Prompt

Here is how my command prompt looks:

Wed Jan 30@07:07:03
pkrumins@catonmat:1002:2:~$
The first line displays the date and time the command prompt was displayed so I could keep track of commands back in time.
The second line displays username, hostname, global history number and current command number.

The global history number allows me to quickly use event designators.

My PS1, primary prompt display variable looks like this:

PS1='\d@\t\n\u@\h:\!:\#:\w$ '


	3.8 My examples

- Use part of current command:
[yizaq@yizaq-lnx:Mon Oct 10:/view/yizaq__yizaq_5_4.int.acs5_0.lx/vob/nm_acs/acs]$ echo aaa/bbb/c.x !#
echo aaa/bbb/c.x echo aaa/bbb/c.x 
aaa/bbb/c.x echo aaa/bbb/c.x
[yizaq@yizaq-lnx:Mon Oct 10:/view/yizaq__yizaq_5_4.int.acs5_0.lx/vob/nm_acs/acs]$ echo aaa/bbb/c.x !#:0
echo aaa/bbb/c.x echo
aaa/bbb/c.x echo
[yizaq@yizaq-lnx:Mon Oct 10:/view/yizaq__yizaq_5_4.int.acs5_0.lx/vob/nm_acs/acs]$ echo aaa/bbb/c.x !#:1
echo aaa/bbb/c.x aaa/bbb/c.x


- And with more manipulations:
[yizaq@yizaq-lnx:Mon Oct 10:/view/yizaq__yizaq_5_4.int.acs5_0.lx/vob/nm_acs/acs]$ echo aaa/bbb/c.x !#:1:h
echo aaa/bbb/c.x aaa/bbb
aaa/bbb/c.x aaa/bbb
[yizaq@yizaq-lnx:Mon Oct 10:/view/yizaq__yizaq_5_4.int.acs5_0.lx/vob/nm_acs/acs]$ echo aaa/bbb/c.x !#:1:p
echo aaa/bbb/c.x aaa/bbb/c.x
[yizaq@yizaq-lnx:Mon Oct 10:/view/yizaq__yizaq_5_4.int.acs5_0.lx/vob/nm_acs/acs]$ echo aaa/bbb/c.x !#:t
echo aaa/bbb/c.x c.x 
aaa/bbb/c.x c.x
[yizaq@yizaq-lnx:Mon Oct 10:/view/yizaq__yizaq_5_4.int.acs5_0.lx/vob/nm_acs/acs]$ echo aaa/bbb/c.x !#:r
echo aaa/bbb/c.x echo aaa/bbb/c
aaa/bbb/c.x echo aaa/bbb/c
[yizaq@yizaq-lnx:Mon Oct 10:/view/yizaq__yizaq_5_4.int.acs5_0.lx/vob/nm_acs/acs]$ echo aaa/bbb/c.x !#:e
echo aaa/bbb/c.x .x 
aaa/bbb/c.x .x
[yizaq@yizaq-lnx:Mon Oct 10:/view/yizaq__yizaq_5_4.int.acs5_0.lx/vob/nm_acs/acs]$ echo aaa/bbb/c.x !#:1:q
echo aaa/bbb/c.x 'aaa/bbb/c.x'
aaa/bbb/c.x aaa/bbb/c.x


	3.9 Bash History Cheat Sheet                         
.---------------------------------------------------------------------------.
|                                                                           |
|                          Bash History Cheat Sheet                         |
|                                                                           |
'---------------------------------------------------------------------------'
| Peteris Krumins (peter@catonmat.net), 2008.02.15                          |
| http://www.catonmat.net  -  good coders code, great reuse                 |
|                                                                           |
| Released under the GNU Free Document License                              |
'---------------------------------------------------------------------------'

 ===================== Emacs Keyboard Shortcut Summary =====================

.--------------.------------------------------------------------------------.
|              |                                                            |
| Shortcut     | Description                                                |
|              |                                                            |
'--------------+------------------------------------------------------------'
| C-p          | Fetch the previous command from the history list.          |
'--------------+------------------------------------------------------------'
| C-n          | Fetch the next command from the history list.              |
'--------------+------------------------------------------------------------'
| M-<          | Move to the first line in the history.                     | 
'--------------+------------------------------------------------------------'
| M->          | Move to the end of the input history.                      |
'--------------+------------------------------------------------------------'
| C-r          | Search backward starting at the current line (incremental) |
'--------------+------------------------------------------------------------'
| C-s          | Search forward starting at the current line (incremental). |
'--------------+------------------------------------------------------------'
| M-p          | Search backward using non-incremental search.              |
'--------------+------------------------------------------------------------'
| M-n          | Search forward using non-incremental search                |
'--------------'------------------------------------------------------------'

 ======================= Vi Keyboard Shortcut Summary ======================

.--------------.------------------------------------------------------------.
|              |                                                            |
| Shortcut     | Description                                                |
|              |                                                            |
'--------------+------------------------------------------------------------'
| k            | Fetch the previous command from the history list.          |
'--------------+------------------------------------------------------------'
| j            | Fetch the next command from the history list.              |
'--------------+------------------------------------------------------------'
| /string or   | Search history backward for a command matching string.     |
| CTRL-r       |                                                            |
'--------------+------------------------------------------------------------'
| ?string or   | Search history forward for a command matching string.      |
| CTRL-s       | (Note that on most machines Ctrl-s STOPS the terminal      |
|              | output, change it with `stty' (Ctrl-q to resume)).         |
'--------------+------------------------------------------------------------'
| n            | Repeat search in the same direction as previous.           |
'--------------+------------------------------------------------------------'
| N            | Repeat search in the opposite direction as previous.       |
'--------------+------------------------------------------------------------'
| G            | Move to history line N (for example, 15G).                 |
'--------------'------------------------------------------------------------'

 ======================== History Expansion Summary ========================
 
 Event Designators:

.--------------.------------------------------------------------------------.
|              |                                                            |
| Designator   | Description                                                |
|              |                                                            |
'--------------+------------------------------------------------------------'
| !            | Start a history substitution.                              |
'--------------+------------------------------------------------------------'
| !!           | Refer to the last command.                                 |
'--------------+------------------------------------------------------------'
| !n           | Refer to the n-th command line (try `history' command).    |
'--------------+------------------------------------------------------------'
| !-n          | Refer to the current command line minus n.                 |
'--------------+------------------------------------------------------------'
| !string      | Refer to the most recent command starting with 'string'.   |
'--------------+------------------------------------------------------------'
| !?string?    | Refer to the most recent command containing 'string'.      |
'--------------+------------------------------------------------------------'
| ^str1^str2^  | Quick substitution. Repeat the last command, replacing     |
|              | 'str1' with 'str2'.                                        |
'--------------+------------------------------------------------------------'
| !#           | Refer to the entire command line typed so far.             |
'--------------'------------------------------------------------------------'

 Word Designators:
 (Word designators follow the event designators, separated by a collon ':')

.--------------.------------------------------------------------------------.
|              |                                                            |
| Designator   | Description                                                |
|              |                                                            |
'--------------+------------------------------------------------------------'
| 0            | The zeroth (first) word in a line (usually command name).  |
'--------------+------------------------------------------------------------'
| n            | The n-th word in a line.                                   |
'--------------+------------------------------------------------------------'
| ^            | The first argument (the second word) in a line.            |
'--------------+------------------------------------------------------------'
| $            | The last argument in a line.                               |
'--------------+------------------------------------------------------------'
| %            | The word matched by the most recent string search.         |
'--------------+------------------------------------------------------------'
| x-y          | A range of words from x to y (-y is synonymous with 0-y).  |
'--------------+------------------------------------------------------------'
| *            | All words but the zeroth (synonymous with 1-$).            |
'--------------+------------------------------------------------------------'
| x*           | Synonymous with x-$                                        |
'--------------+------------------------------------------------------------'
| x-           | The words from x to the second to last word.               |
'--------------'------------------------------------------------------------'

 Modifiers (modifiers follow word designators, separated by a colon):

.--------------.------------------------------------------------------------.
|              |                                                            |
| Modifier     | Description                                                |
|              |                                                            |
'--------------+------------------------------------------------------------'
| h            | Remove a trailing pathname component, leaving the head.    |
'--------------+------------------------------------------------------------'
| t            | Remove all leading pathname component, leaving the tail.   |
'--------------+------------------------------------------------------------'
| r            | Remove a trailing suffix of the form .xxx, leaving the     |
|              | basename.                                                  |
'--------------+------------------------------------------------------------'
| e            | Remove all but the trailing suffix.                        |
'--------------+------------------------------------------------------------'
| p            | Print the resulting command but do not execute it.         |
'--------------+------------------------------------------------------------'
| q            | Quotes the substituted words, escaping further             |
|              | substitutions.                                             |
'--------------+------------------------------------------------------------'
| x            | Quotes the substituted words, breaking them into words at  |
|              | blanks and newlines.                                       |
'--------------+------------------------------------------------------------'
| s/old/new/   | Substitutes 'new' for 'old'.                               |
'--------------+------------------------------------------------------------'
| &            | Repeats the previous substitution.                         |
'--------------+------------------------------------------------------------'
| g            | Causes s/old/new/ or & to be applied over the entire       |
|              | event line.                                                |
'--------------'------------------------------------------------------------'

 ============ History Behavior Modification via Shell Variables ============

.----------------.----------------------------------------------------------.
|                |                                                          |
| Shell Variable | Description                                              |
|                |                                                          |
'----------------+----------------------------------------------------------'
| HISTFILE       | Controls where the history file gets saved.              |
|                | Set to /dev/null not to save the history.                |
|                | Default: ~/.bash_history                                 |
'----------------+----------------------------------------------------------'
| HISTFILESIZE   | Controls how many history commands to keep in HISTFILE   |
|                | Default: 500                                             |
'----------------+----------------------------------------------------------'
| HISTSIZE       | Controls how many history commands to keep in the        |
|                | history list of current session.                         |
|                | Default: 500                                             |
'----------------+----------------------------------------------------------'
| HISTIGNORE     | Controls which commands to ignore and not save to the    |
|                | history list. The variable takes a list of               |
|                | colon separated values. Pattern & matches the previous   |
|                | history command.                                         |
'----------------'----------------------------------------------------------'

 ============ History Behavior Modification via `shopt' Command ============

.----------------.----------------------------------------------------------.
|                |                                                          |
| shopt Option   | Description                                              |
|                |                                                          |
'----------------+----------------------------------------------------------'
| histappend     | Setting the variable appends current session history to  |
|                | HISTFILE. Unsetting overwrites the file each time.       |
'----------------+----------------------------------------------------------'
| histreedit     | If set, puts a failed history substitution back on the   |
|                | command line for re-editing.                             |
'----------------+----------------------------------------------------------'
| histverify     | If set, puts the command to be executed after a          |
|                | substitution on command line as if you had typed it.     |
'----------------'----------------------------------------------------------'

 shopt options can be set by a `shopt -s option' and
 can be unset by             a `shopt -u option'.

 =============================== Examples ==================================

 $ echo a b c d e    (executes `echo ab c d e`)
 a b c d e

 $ echo !!:3-$       (executes `echo c d e`)
 c d e

 $ echo !-2:*:q      (executes `echo 'a b c d e'`)
 a b c d e

 $ echo !-3:1:2:4:x  (executes `echo 'a' 'b' 'd'`)
 a b d

 $ echo !-4:1-3:s/a/foo/:s/b/bar/:s/c/baz/ (executes `echo foo bar baz`)
 foo bar baz

 $ tar -xzf package-x.y.z.tgz
 ...
 $ cd !-1:$:r        (executes `cd package-x.y.z`)
 package-x.y.z $
 
 $ ls -a /tmp
 file1  file2  file3 ...

 $ ^-a^-l^           (executes `ls -l /tmp`)
 -rw-------  1  user  user  file1
 ...

 ===========================================================================

.---------------------------------------------------------------------------.
| Peteris Krumins (peter@catonmat.net), 2008.02.15                          |
| http://www.catonmat.net  -  good coders code, great reuse                 | 
|                                                                           |
| Released under the GNU Free Document License                              |
'---------------------------------------------------------------------------'

	3.10 $ man  -P 'less -p ^HISTORY\ EXPANSION' bash
<...>
Word Designators

Word designators are used to select desired words from the event.
A : separates the event specification from the word designator.
It may be omitted if the word designator begins with a ^, $, *, -,
or %.  Words are numbered from the beginning of the line, with the
first word being denoted by 0 (zero).  Words are inserted into the
current line separated by single spaces.

   0 (zero)
          The zeroth word.  For the shell, this is the command word.
   n      The nth word.
   ^      The first argument.  That is, word 1.
   $      The last argument.
   %      The word matched by the most recent ?string? search.
   x-y    A range of words; -y abbreviates 0-y.
   *      All of the words but the zeroth.
          This is a synonym for 1-$.  
          It is not an error to use * if there is just one word in
          the event; the empty string is returned in that case.
   x*     Abbreviates x-$.
   x-     Abbreviates x-$ like x*, but omits the last word.

   If a word designator is supplied without an event
   specification, the previous command is used as the event.
4. Arrays
		example:
			# -----------------------------------------------------------------
# # Another array, "area2".
# # Another way of assigning array variables...
# # array_name=( XXX YYY ZZZ ... )
#
# area2=( zero one two three four )
#
# echo -n "area2[0] = "
# echo ${area2[0]}
# # Aha, zero-based indexing (first element of array is [0], not [1]).
#
# echo -n "area2[1] = "
# echo ${area2[1]}    # [1] is second element of array.
# # -----------------------------------------------------------------

		4.1 Iteration
			example:
			for name in ${names[@]}
			do
			   echo $name
			      # other stuff on $name
			# done

			sometimes it is useful to loop through an array and know the numeric index of the array you are using (for example, so that you can reference another array with the same index). The same loop in the example above can be achieved this way, too: 
			for (( i = 0 ; i < ${#names[@]} ; i++ ))
			do
			  echo ${names[$i]}
			     # yadda yadda
			# done		

		4.2 many commands for same argument
			Also for many commands you can use a loop:
			for cmd in mkdir cd mkdir cd ls tar etc; do ${cmd}' /long/dir/name' ; done


		4.3 The Ultimate Bash Array Tutorial with 15 Examples
by SASIKALA on JUNE 3, 2010

An array is a variable containing multiple values may be of same type or of different type.  There is no maximum limit to the size of an array, nor any requirement that member variables be indexed or assigned contiguously. Array index starts with zero.

In this article, let us review 15 various array operations in bash.

This article is part of the on-going Bash Tutorial series. For those who are new to bash scripting, get a jump-start from the Bash Scripting Introduction tutorial.

			4.3.1 Declaring an Array and Assigning values

In bash, array is created automatically when a variable is used in the format like,

name[index]=value
name is any name for an array
index could be any number or expression that must evaluate to a number greater than or equal to zero.You can declare an explicit array using declare -a arrayname.
$ cat arraymanip.sh
#! /bin/bash
Unix[0]='Debian'
Unix[1]='Red hat'
Unix[2]='Ubuntu'
Unix[3]='Suse'

echo ${Unix[1]}

$./arraymanip.sh
Red hat
To access an element from an array use curly brackets like ${name[index]}.

			4.3.2 Initializing an array during declaration

Instead of initializing an each element of an array separately, you can declare and initialize an array by specifying the list of elements (separated by white space) with in a curly braces.

Syntax:
declare -a arrayname=(element1 element2 element3)
If the elements has the white space character, enclose it with in a quotes.

#! /bin/bash
$cat arraymanip.sh
declare -a Unix=('Debian' 'Red hat' 'Red hat' 'Suse' 'Fedora');
declare -a declares an array and all the elements in the parentheses are the elements of an array.


 
			4.3.3 Print the Whole Bash Array

There are different ways to print the whole elements of the array. If the index number is @ or *, all members of an array are referenced. You can traverse through the array elements and print it, using looping statements in bash.

echo ${Unix[@]}

# Add the above echo statement into the arraymanip.sh
#./t.sh
Debian Red hat Ubuntu Suse
Referring to the content of a member variable of an array without providing an index number is the same as referring to the content of the first element, the one referenced with index number zero.

			4.3.4 Length of the Bash Array

We can get the length of an array using the special parameter called $#.

${#arrayname[@]} gives you the length of the array.

$ cat arraymanip.sh
declare -a Unix=('Debian' 'Red hat' 'Suse' 'Fedora');
echo ${#Unix[@]} #Number of elements in the array
echo ${#Unix}  #Number of characters in the first element of the array.i.e Debian
$./arraymanip.sh
4
6

			4.3.5 Length of the nth Element in an Array

${#arrayname[n]} should give the length of the nth element in an array.

$cat arraymanip.sh
#! /bin/bash

Unix[0]='Debian'
Unix[1]='Red hat'
Unix[2]='Ubuntu'
Unix[3]='Suse'

echo ${#Unix[3]} # length of the element located at index 3 i.e Suse

$./arraymanip.sh
4

			4.3.6 Extraction by offset and length for an array

The following example shows the way to extract 2 elements starting from the position 3 from an array called Unix.

$cat arraymanip.sh
Unix=('Debian' 'Red hat' 'Ubuntu' 'Suse' 'Fedora' 'UTS' 'OpenLinux');
echo ${Unix[@]:3:2}

$./arraymanip.sh
Suse Fedora
The above example returns the elements in the 3rd index and fourth index. Index always starts with zero.

			4.3.7 Extraction with offset and length, for a particular element of an array

To extract only first four elements from an array element . For example, Ubuntu which is located at the second index of an array, you can use offset and length for a particular element of an array.

$cat arraymanip.sh
#! /bin/bash

Unix=('Debian' 'Red hat' 'Ubuntu' 'Suse' 'Fedora' 'UTS' 'OpenLinux');
echo ${Unix[2]:0:4}

./arraymanip.sh
Ubun
The above example extracts the first four characters from the 2nd indexed element of an array.

			4.3.8 Search and Replace in an array elements

The following example, searches for Ubuntu in an array elements, and replace the same with the word SCO Unix.

$cat arraymanip.sh
#!/bin/bash
Unix=('Debian' 'Red hat' 'Ubuntu' 'Suse' 'Fedora' 'UTS' 'OpenLinux');

echo ${Unix[@]/Ubuntu/SCO Unix}

$./arraymanip.sh
Debian Red hat SCO Unix Suse Fedora UTS OpenLinux
In this example, it replaces the element in the 2nd index Ubuntu with SCO Unix. But this example will not permanently replace the array content.

			4.3.9  Add an element to an existing Bash Array

The following example shows the way to add an element to the existing array.

$cat arraymanip.sh
Unix=('Debian' 'Red hat' 'Ubuntu' 'Suse' 'Fedora' 'UTS' 'OpenLinux');
Unix=("${Unix[@]}" "AIX" "HP-UX")
echo ${Unix[7]}

$./arraymanip.sh
AIX
In the array called Unix, the elements AIX and HP-UX are added in 7th and 8th index respectively.

			4.3.10 Remove an Element from an Array

unset is used to remove an element from an array.unset will have the same effect as assigning null to an element.

$cat arraymanip.sh
#!/bin/bash
Unix=('Debian' 'Red hat' 'Ubuntu' 'Suse' 'Fedora' 'UTS' 'OpenLinux');

unset Unix[3]
echo ${Unix[3]}
The above script will just print null which is the value available in the 3rd index. The following example shows one of the way to remove an element completely from an array.

$ cat arraymanip.sh
Unix=('Debian' 'Red hat' 'Ubuntu' 'Suse' 'Fedora' 'UTS' 'OpenLinux');
pos=3
Unix=(${Unix[@]:0:$pos} ${Unix[@]:$(($pos + 1))})
echo ${Unix[@]}

$./arraymanip.sh
Debian Red hat Ubuntu Fedora UTS OpenLinux
In this example, ${Unix[@]:0:$pos} will give you 3 elements starting from 0th index i.e 0,1,2 and ${Unix[@]:4} will give the elements from 4th index to the last index. And merge both the above output. This is one of the workaround to remove an element from an array.

			4.3.11 Remove Bash Array Elements using Patterns

In the search condition you can give the patterns, and stores the remaining element to an another array as shown below.

$ cat arraymanip.sh
#!/bin/bash
declare -a Unix=('Debian' 'Red hat' 'Ubuntu' 'Suse' 'Fedora');
declare -a patter=( ${Unix[@]/Red*/} )
echo ${patter[@]}

$ ./arraymanip.sh
Debian Ubuntu Suse Fedora
The above example removes the elements which has the patter Red*.

			4.3.12 Copying an Array

Expand the array elements and store that into a new array as shown below.

#!/bin/bash
Unix=('Debian' 'Red hat' 'Ubuntu' 'Suse' 'Fedora' 'UTS' 'OpenLinux');
Linux=("${Unix[@]}")
echo ${Linux[@]}

$ ./arraymanip.sh
Debian Red hat Ubuntu Fedora UTS OpenLinux

			4.3.13 Concatenation of two Bash Arrays

Expand the elements of the two arrays and assign it to the new array.

$cat arraymanip.sh
#!/bin/bash
Unix=('Debian' 'Red hat' 'Ubuntu' 'Suse' 'Fedora' 'UTS' 'OpenLinux');
Shell=('bash' 'csh' 'jsh' 'rsh' 'ksh' 'rc' 'tcsh');

UnixShell=("${Unix[@]}" "${Shell[@]}")
echo ${UnixShell[@]}
echo ${#UnixShell[@]}

$ ./arraymanip.sh
Debian Red hat Ubuntu Suse Fedora UTS OpenLinux bash csh jsh rsh ksh rc tcsh
14
It prints the array which has the elements of the both the array Unix and Shell, and number of elements of the new array is 14.

			4.3.14 Deleting an Entire Array

unset is used to delete an entire array.

$cat arraymanip.sh
#!/bin/bash
Unix=('Debian' 'Red hat' 'Ubuntu' 'Suse' 'Fedora' 'UTS' 'OpenLinux');
Shell=('bash' 'csh' 'jsh' 'rsh' 'ksh' 'rc' 'tcsh');

UnixShell=("${Unix[@]}" "${Shell[@]}")
unset UnixShell
echo ${#UnixShell[@]}

$ ./arraymanip.sh
0
After unset an array, its length would be zero as shown above.

			4.3.15  Load Content of a File into an Array

You can load the content of the file line by line into an array.

#Example file
$ cat logfile
Welcome
to
thegeekstuff
Linux
Unix

$ cat loadcontent.sh
#!/bin/bash
filecontent=( `cat "logfile" `)

for t in "${filecontent[@]}"
do
echo $t
done
echo "Read file content!"

$ ./loadcontent.sh
Welcome
to
thegeekstuff
Linux
Unix
Read file content!
In the above example, each index of an array element has printed through for loop.


		4.4 Merge two sorted array into third sorted

			4.4.1 Snip: /vob/nm_acs/acs/mgmt/cli/cars/src/main/ctrlcmd/patch-wrapper.sh
 mergesort()
 {
   #Assign arguments to array
   sArr1=("${!1}")
   sArr2=("${!2}")

   #Initialize index
   i=0
   j=0
   k=0

   #Calculate length
   m=${#sArr1[@]} #Array1 length
   n=${#sArr2[@]} #Array2 length

   #Merge sorted array
   while [[ "$i" -lt "$m" && "$j" -lt "$n" ]]
   do

     #Parse version
     sArr1Ver=`echo ${sArr1[i]} | awk -F'-' '{print $5}'`
     sArr2Ver=`echo ${sArr2[j]} | awk -F'-' '{print $7}'`

     if [ $sArr1Ver -lt $sArr2Ver ]; then
       out[k]=${sArr1[i]}
       let "i++"
       let "i++"
     elif [ $sArr1Ver -eq $sArr2Ver ]; then
       out[k]=${sArr1[i]}
       let "k++"
       out[k]=${sArr2[j]}
       let "i++"
       let "j++"
     else
       out[k]=${sArr2[j]}
       let "j++"
     fi
     let "k++"
    done

    if [ "$i" -ge "$m" ]; then
      while [ "$j" -lt "$n" ]
      do
        out[k]=${sArr2[j]}
        let "j++"
        let "k++"
      done
    fi

    if [ "$j" -ge "$n" ]; then
      while [ "$i" -lt "$m" ]
      do
        out[k]=${sArr1[i]}
        let "i++"
        let "k++"
      done
    fi

    echo "${out[@]}"
 }

---

     PATCHES=`ls --sort=version $DIR/installed/ | grep '^[0-9]' 2> /dev/null`
     POINTED_PATCHES=`ls --sort=version $DIR/installed | grep Pointed 2> /dev/null`

     if [[ ! -z "$POINTED_PATCHES" && ! -z "$PATCHES" ]]; then
       array1=( $PATCHES )
       array2=( $POINTED_PATCHES )
       PATCHLIST=`mergesort "array1[@]" "array2[@]"`
     else
       if [ ! -z "$POINTED_PATCHES" ]; then
         PATCHLIST="$POINTED_PATCHES"
       elif [ ! -z "$PATCHES" ]; then
         PATCHLIST="$PATCHES"
       else
         log 0 "$PATCHNAME is not installed"
         echo "$PATCHNAME No patch installed."
         return
       fi
     fi

     if [ ! -z "$PATCHLIST" ]; then
       LATEST_PATCH_NAME=`echo $PATCHLIST | awk '{ print $NF }' 2> /dev/null`
       if [ ! -z $LATEST_PATCH_NAME ]; then
         if [ "$PATCHNAME" != "$LATEST_PATCH_NAME" ]; then
           log 0 "$PATCHNAME is not the latest patch installed. Please remove the lastest patch $LATEST_PATCH_NAME and try again"
           echo "$PATCHNAME is not the latest patch installed. Please remove the lastest patch $LATEST_PATCH_NAME and try again"
           exit 1
         fi
       fi
     fi




		4.5
5. Strings
	5.1 string concatenation
		example
		_open_KB_files(){

			files=( knowledge_base_unix  clear_case_KB.txt bash/KB_bash  vi/KB_vi )
				path=" /cygdrive/d/work/KB/"
				cmd="vi "

				for file in ${files[@]};
			        do file=${path}${file};
				        cmd=${cmd}${file}
#echo $file;
#echo $cmd;
					done
						${cmd}
		}

6. shell loops
	6.1 do something on a list
	for file in KB_cpp kb_tools kb_cisco kb_acs; do tocify.pl $file; done

	6.2 C like loop
		output in one line
		LIMIT=31; for (i=1; i <= LIMIT ; i++); do echo -n "$i"; done

		output in multiple lines
		LIMIT=31; for ((i=1; i <= LIMIT ; i++)) ;  do echo  "$i"; done

7. Keyboard shortcuts, command line options, shell prompt shortcuts

	7.1 Ctrl, alt combos


#) Using Ctrl combination :
ctrl+a : jump to begning of line you are typing on ;
ctrl+b : moving back a character ;
ctrl+c : terminate the command;
ctrl+d:delete character at cursor;
ctrl+D : exit the current shell;
ctrl+h : delete character before cursor ;
ctrl+e : jump to end of line you are typing on ;
ctrl+f : move forward by one character ;
ctrl+l : clear the screen :
ctrl+K : clear the line after cursor ;
ctrl+H : works as backspace ;
ctrl+t : transpose 2 characters ;
ctrl+xx : move between end-of-line and current cursor position ;
ctrl+r : search the history backwords ;
ctrl+w : erase word before cursor ;
ctrl+x@ : shows possible hostname completions;
ctrl+y : recover previous deleation ;
ctrl+z : suspend/stop the command which is running ;

#) UsingAlt combination :
Alt + > - Move to the last line in the history ;
Alt + ? - Show current completion list ;
Alt + * - Insert all possible completions ;
Alt + / - Attempt to complete filename ;
Alt + . - Yank last argument to previous command ;
Alt + b - Move backward ;
Alt + c - Capitalize the word ;
Alt + d - Delete word ;
Alt + f - Move word forward ;
Alt + l - Make word lowercase ;
Alt + n - Search the history forwards non-incremental ;
Alt + p - Search the history backwards non-incremental ;
Alt + r - Recall command ;
Alt + t - Move words around ;
Alt + u - Make word uppercase ;
Alt + back-space - Delete backward from cursor ;

#) Using Esc combination :
esc+d : delete word ;
esc+f : move forward a word ;
esc+b : mmove backward a word ;
esc+t : transpose two adjacent words ;
#) Using Tab combination :
*)Press tab twice to see all available commands;
*)Press tab twice after a word to view all commands starting with that word ;
*)Pressing ~along with hitting tab 2 times will give you list of all user on system from /etc/passwd;
*)Pressing $along with hitting tab 2 times will show you all sys variables ;
*)Pressing / along with hitting tab 2 times will give you entire directory structure including hidden ;
*) To complete a command you can hit the tab key after typing one or more letters of a command.
*) you can use ! along with first few character of previous command to get previous command fired;
eg; if you have used ifconfig sometime back then you can use !if to fire that command once again. 

	7.2 History shortcuts

<URL:#r=__bash_prompt_history1>
<URL:#r=__bash_prompt_history2>

	7.3
8. Test operators

+-----------------------------------------------------------------------------------------------------------------------+
|Appendinx A, test operators quick reference.|
|Command	Description	Example|
|&	Run the previous command in the background	ls &|
|&&	Logical AND	if [ "$foo" -ge "0" ] && [ "$foo" -le "9"]|
|||	Logical OR	if [ "$foo" -lt "0" ] || [ "$foo" -gt "9" ]|
|^	Start of line	grep "^foo"|
|$	End of line	grep "foo$"|
|=	String equality (cf. -eq)	if [ "$foo" = "bar" ]|
|!	Logical NOT	if [ "$foo" != "bar" ]|
|$$	PID of current shell	echo "my PID = $$"|
|$!	PID of last background command	ls & echo "PID of ls = $!"|
|$?	exit status of last command	ls ; echo "ls returned code $?"|
|$0	Name of current command (as called)	echo "I am $0"|
|$1	Name of current command's first parameter	echo "My first argument is $1"|
|$9	Name of current command's ninth parameter	echo "My ninth argument is $9"|
|$@	All of current command's parameters (preserving whitespace and quoting)	echo "My arguments are $@"|
|$*	All of current command's parameters (not preserving whitespace and quoting)	echo "My arguments are $*"|
|-eq	Numeric Equality	if [ "$foo" -eq "9" ]|
|-ne	Numeric Inquality	if [ "$foo" -ne "9" ]|
|-lt	Less Than	if [ "$foo" -lt "9" ]|
|-le	Less Than or Equal	if [ "$foo" -le "9" ]|
|-gt	Greater Than	if [ "$foo" -gt "9" ]|
|-ge	Greater Than or Equal	if [ "$foo" -ge "9" ]|
|-z	String is zero length	if [ -z "$foo" ]|
|-n	String is not zero length	if [ -n "$foo" ]|
|-nt	Newer Than	if [ "$file1" -nt "$file2" ]|
|-d	Is a Directory	if [ -d /bin ]|
|-f	Is a File	if [ -f /bin/ls ]|
|-r	Is a readable file	if [ -r /bin/ls ]|
|-w	Is a writable file	if [ -w /bin/ls ]|
|-x	Is an executable file	if [ -x /bin/ls ]|
|brackets:|
|( ... )	Function definition	function myfunc() { echo hello }|
|braces:|
+-----------------------------------------------------------------------------------------------------------------------+

9. Aliases
	Create an alias, aliases allow a string to be substituted for a word when it is used as the first word of a simple command.

	SYNTAX
	      alias [-p] [name[=value] ...]
	      unalias [-a] [name ... ]      

	If arguments are supplied, an alias is defined for each name whose value is given.

	If no value is given, `alias' will print the current value of the alias.

	Without arguments or with the `-p' option, alias prints the list of aliases on the standard output in a form that allows them to be reused as input.

	`unalias' will remove each name from the list of aliases. If `-a' is supplied, all aliases are removed.

	`alias' and `unalias' are BASH built-ins.

	The first word of each simple command, if unquoted, is checked to see if it has an alias. If so, that word is replaced by the text of the alias. The alias name and the replacement text may contain any valid shell input, including shell metacharacters, with the exception that the alias name may not contain `='.

	The first word of the replacement text is tested for aliases, but a word that is identical to an alias being expanded is not expanded a second time. This means that one may alias ls to "ls -F", for instance, and Bash does not try to recursively expand the replacement text.

	If the last character of the alias value is a space or tab character, then the next command word following the alias is also checked for alias expansion.

	There is no mechanism for using arguments in the replacement text, as in csh. If arguments are needed, a shell function should be used . Aliases are not expanded when the shell is not interactive, unless the expand_aliases shell option is set using shopt .

	The rules concerning the definition and use of aliases are somewhat confusing. Bash always reads at least one complete line of input before executing any of the commands on that line. Aliases are expanded when a command is read, not when it is executed. Therefore, an alias definition appearing on the same line as another command does not take effect until the next line of input is read. The commands following the alias definition on that line are not affected by the new alias. This behavior is also an issue when functions are executed. Aliases are expanded when a function definition is read, not when the function is executed, because a function definition is itself a compound command. As a consequence, aliases defined in a function are not available until after that function is executed. To be safe, always put alias definitions on a separate line, and do not use alias in compound commands.

	For almost every purpose, shell functions are preferred over aliases.

	Examples

	alias ls='ls -F'

	Now issuing the command 'ls' will actually run 'ls -F'

	Making an alias permanent:
	Use your favorite text editor to create a .bash_aliases file, and type the alias commands into the file.
	.bash_aliases will run at login (or you can just execute it with ..bash_aliases )

	"The odds against there being a bomb on a plane are a million to one, and against two bombs a million times a million to one. Next time you fly, cut the odds and take a bomb." - Benny Hill

	Related Linux Bash commands:

	export - Set an environment variable
	env - Display, set, or remove environment variables
	echo - Display message on screen
	readonly - Mark variables/functions as readonly
	shift - Shift positional parameters

	Equivalent Windows XP commands:

	SET - Display, set, or remove Windows NT environment variables
	SETX - Set environment variables permanently
	SETLOCAL - Begin localisation of environment changes in a batch file

10. prompt
	add to .bashrc 
	PS1="[\u@\h:\d:\w]\$ "
	to get prompt, [yytzhak@yytzhak-wxp:Thu May 03:/cygdrive/c/work/scripts/games:]
	
	Bash provides an environment variable called PROMPT_COMMAND. The contents of this variable are executed as a regular Bash command just before Bash displays a prompt.

		[21:55:01][giles@nikola:~] PS1="[\u@\h:\w]\$ "
		[giles@nikola:~] PROMPT_COMMAND="date +%H%M"
		2155
		[giles@nikola:~] d
		bin   mail
		2156
		[giles@nikola:~] 

		What happened above was that I changed PS1 to no longer include the \t escape sequence (added in a previous section), so the time was no longer a part of the prompt. Then I used date +%H%M to display the time in a format I like better. But it appears on a different line than the prompt. Tidying this up using echo -n ... as shown below works with Bash 2.0+, but appears not to work with Bash 1.14.7: apparently the prompt is drawn in a different way, and the following method results in overlapping text.

		2156
		[giles@nikola:~] PROMPT_COMMAND="echo -n [$(date +%H%M)]"
		[2156][giles@nikola:~]$
		[2156][giles@nikola:~]$ d
		bin   mail
		[2157][giles@nikola:~]$ unset PROMPT_COMMAND
		[giles@nikola:~]

		echo -n ... controls the output of the date command and suppresses the trailing newline, allowing the prompt to appear all on one line. At the end, I used the unset command to remove the PROMPT_COMMAND environment variable.

11. Macros
start-kbd-macro (C-x ()
    Begin saving the characters typed into the current keyboard macro.

end-kbd-macro (C-x ))
    Stop saving the characters typed into the current keyboard macro and save the definition.

call-last-kbd-macro (C-x e)
    Re-execute the last keyboard macro defined, by making the characters in the macro appear as if typed at the keyboard.

12. Advanced Bash-Scripting Guide
An in-depth exploration of the art of shell scripting
Author: Mendel Cooper
http://tldp.org/LDP/abs/html/

	12.1 Basics (chapter 3)

		12.1.1 Special Characters
    Comments. Lines beginning with a #  (with the exception of #!) are comments and will not be executed.

    # This line is a comment.

    Comments may also occur following the end of a command.

    echo "A comment will follow." # Comment here.
    #                            ^ Note whitespace before #

    Comments may also follow whitespace at the beginning of a line.

    	# A tab precedes this comment.

    Caution: A command may not follow a comment on the same line. There is no method of terminating the comment, in order for "live code" to begin on the same line. Use a new line for the next command.

    Note	Of course, an escaped # in an echo statement does not begin a comment. Likewise, a # appears in certain parameter substitution constructs and in numerical constant expressions.

    echo "The # here does not begin a comment."
    echo 'The # here does not begin a comment.'
    echo The \# here does not begin a comment.
    echo The # here begins a comment.

    echo ${PATH#*:}       # Parameter substitution, not a comment.
    echo $(( 2#101011 ))  # Base conversion, not a comment.

    # Thanks, S.C.

    The standard quoting and escape characters (" ' \) escape the #.

    Certain pattern matching operations also use the #.
; Command separator [semicolon]. Permits putting two or more commands on the same line.

    echo hello; echo there


    if [ -x "$filename" ]; then    # Note that "if" and "then" need separation.
                                   # Why?
      echo "File $filename exists."; cp $filename $filename.bak
    else
      echo "File $filename not found."; touch $filename
    fi; echo "File test complete."

    Note that the ";" sometimes needs to be escaped.
;; Terminator in a case option [double semicolon].

    case "$variable" in
      abc)  echo "\$variable = abc" ;;
      xyz)  echo "\$variable = xyz" ;;
    esac

.  "dot" command [period]. Equivalent to source (see Example 14-22). This is a bash builtin.
.  "dot", as a component of a filename. When working with filenames, a dot is the prefix of a "hidden" file, a file that an ls will not normally show.

    bash$ touch .hidden-file
    bash$ ls -l	      
    total 10
     -rw-r--r--    1 bozo      4034 Jul 18 22:04 data1.addressbook
     -rw-r--r--    1 bozo      4602 May 25 13:58 data1.addressbook.bak
     -rw-r--r--    1 bozo       877 Dec 17  2000 employment.addressbook


    bash$ ls -al	      
    total 14
     drwxrwxr-x    2 bozo  bozo      1024 Aug 29 20:54 ./
     drwx------   52 bozo  bozo      3072 Aug 29 20:51 ../
     -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.addressbook
     -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.addressbook.bak
     -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.addressbook
     -rw-rw-r--    1 bozo  bozo         0 Aug 29 20:54 .hidden-file
    	        

    When considering directory names, a single dot represents the current working directory, and two dots denote the parent directory.

    bash$ pwd
    /home/bozo/projects

    bash$ cd .
    bash$ pwd
    /home/bozo/projects

    bash$ cd ..
    bash$ pwd
    /home/bozo/
    	        

    The dot often appears as the destination (directory) of a file movement command.

    bash$ cp /home/bozo/current_work/junk/* .
    	        

.  "dot" character match. When matching characters, as part of a regular expression, a "dot" matches a single character.
" partial quoting [double quote]. "STRING" preserves (from interpretation) most of the special characters within STRING. See also Chapter 5.
' full quoting [single quote]. 'STRING' preserves all special characters within STRING. This is a stronger form of quoting than using ". See also Chapter 5.
, comma operator. The comma operator [1] links together a series of arithmetic operations. All are evaluated, but only the last one is returned.

    let "t2 = ((a = 9, 15 / 3))"  # Set "a =
    	       9" and "t2 = 15 / 3"

\ escape [backslash]. A quoting mechanism for single characters.

\X "escapes" the character X. This has the effect of "quoting" X, equivalent to 'X'. The \ may be used to quote " and ', so they are expressed literally.

    See Chapter 5 for an in-depth explanation of escaped characters.
/ Filename path separator [forward slash]. Separates the components of a filename (as in /home/bozo/projects/Makefile).

    This is also the division arithmetic operator.
` command substitution. The `command` construct makes available the output of command for assignment to a variable. This is also known as backquotes or backticks.
: null command [colon]. This is the shell equivalent of a "NOP" (no op, a do-nothing operation). It may be considered a synonym for the shell builtin true. The ":" command is itself a Bash builtin, and its exit status is "true" (0).

    :
    echo $?   # 0

    Endless loop:

    while :
    do
       operation-1
       operation-2
       ...
       operation-n
    done

    # Same as:
    #    while true
    #    do
    #      ...
    #    done

    Placeholder in if/then test:

    if condition
    then :   # Do nothing and branch ahead
    else
       take-some-action
    fi

    Provide a placeholder where a binary operation is expected, see Example 8-2 and default parameters.

    : ${username=`whoami`}
    # ${username=`whoami`}   Gives an error without the leading :
    #                        unless "username" is a command or builtin...

    Provide a placeholder where a command is expected in a here document. See Example 18-10.

    Evaluate string of variables using parameter substitution (as in Example 9-16).

    : ${HOSTNAME?} ${USER?} ${MAIL?}
    #  Prints error message
    #+ if one or more of essential environmental variables not set.

    Variable expansion / substring replacement.

    In combination with the > redirection operator, truncates a file to zero length, without changing its permissions. If the file did not previously exist, creates it.

    : > data.xxx   # File "data.xxx" now empty.	      

    # Same effect as   cat /dev/null >data.xxx
    # However, this does not fork a new process, since ":" is a builtin.

    See also Example 15-14.

    In combination with the >> redirection operator, has no effect on a pre-existing target file (: >> target_file). If the file did not previously exist, creates it.

    Note	

    This applies to regular files, not pipes, symlinks, and certain special files.

    May be used to begin a comment line, although this is not recommended. Using # for a comment turns off error checking for the remainder of that line, so almost anything may appear in a comment. However, this is not the case with :.

    : This is a comment that generates an error, ( if [ $x -eq 3] ).

    The ":" also serves as a field separator, in /etc/passwd, and in the $PATH variable.

    bash$ echo $PATH
    /usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/sbin:/usr/sbin:/usr/games

!  reverse (or negate) the sense of a test or exit status [bang]. The ! operator inverts the exit status of the command to which it is applied (see Example 6-2). It also inverts the meaning of a test operator. This can, for example, change the sense of "equal" ( = ) to "not-equal" ( != ). The ! operator is a Bash keyword.

    In a different context, the ! also appears in indirect variable references.

    In yet another context, from the command line, the ! invokes the Bash history mechanism (see Appendix J). Note that within a script, the history mechanism is disabled.
* wild card [asterisk]. The * character serves as a "wild card" for filename expansion in globbing. By itself, it matches every filename in a given directory.

    bash$ echo *
    abs-book.sgml add-drive.sh agram.sh alias.sh
    	      

    The * also represents any number (or zero) characters in a regular expression.
* arithmetic operator. In the context of arithmetic operations, the * denotes multiplication.
A double asterisk, **, is the exponentiation operator.
?  test operator. Within certain expressions, the ? indicates a test for a condition.

    In a double parentheses construct, the ? can serve as an element of a C-style trinary operator, ?:.

    (( var0 = var1<98?9:21 ))
    #                ^ ^

    # if [ "$var1" -lt 98 ]
    # then
    #   var0=9
    # else
    #   var0=21
    # fi

    In a parameter substitution expression, the ? tests whether a variable has been set.
?  wild card. The ? character serves as a single-character "wild card" for filename expansion in globbing, as well as representing one character in an extended regular expression.
$ Variable substitution (contents of a variable).

    var1=5
    var2=23skidoo

    echo $var1     # 5
    echo $var2     # 23skidoo

    A $ prefixing a variable name indicates the value the variable holds.
$ end-of-line. In a regular expression, a "$" addresses the end of a line of text.
${} Parameter substitution. 
$*, $@ positional parameters. 
$?  exit status variable. The $? variable holds the exit status of a command, a function, or of the script itself.
$$ process ID variable. The $$ variable holds the process ID [2] of the script in which it appears.
() command group.

    (a=hello; echo $a)

    Important	A listing of commands within parentheses starts a subshell.

    Variables inside parentheses, within the subshell, are not visible to the rest of the script. The parent process, the script, cannot read variables created in the child process, the subshell.

    a=123
    ( a=321; )	      

    echo "a = $a"   # a = 123
    # "a" within parentheses acts like a local variable.

    array initialization.

    Array=(element1 element2 element3)

{xxx,yyy,zzz,...}

    Brace expansion.

    cat {file1,file2,file3} > combined_file
    # Concatenates the files file1, file2, and file3 into combined_file.


    cp file22.{txt,backup}
    # Copies "file22.txt" to "file22.backup"

    A command may act upon a comma-separated list of file specs within braces. [3] Filename expansion (globbing) applies to the file specs between the braces.

    Caution	No spaces allowed within the braces unless the spaces are quoted or escaped.

    echo {file1,file2}\ :{\ A," B",' C'}

    file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C
{a..z} Extended Brace expansion.

    echo {a..z} # a b c d e f g h i j k l m n o p q r s t u v w x y z
    # Echoes characters between a and z.

    echo {0..3} # 0 1 2 3
    # Echoes characters between 0 and 3.

    The {a..z} extended brace expansion construction is a feature introduced in version 3 of Bash.
{} Block of code [curly brackets]. Also referred to as an inline group, this construct, in effect, creates an anonymous function (a function without a name). However, unlike in a "standard" function, the variables inside a code block remain visible to the remainder of the script.

    bash$ { local a;
    	      a=123; }
    bash: local: can only be used in a
    function
    	      

    a=123
    { a=321; }
    echo "a = $a"   # a = 321   (value inside code block)

    # Thanks, S.C.

    The code block enclosed in braces may have I/O redirected to and from it.

    Example 3-1. Code blocks and I/O redirection

    #!/bin/bash
    # Reading lines in /etc/fstab.

    File=/etc/fstab

    {
    read line1
    read line2
    } < $File

    echo "First line in $File is:"
    echo "$line1"
    echo
    echo "Second line in $File is:"
    echo "$line2"

    exit 0

    # Now, how do you parse the separate fields of each line?
    # Hint: use awk, or . . .
    # . . . Hans-Joerg Diers suggests using the "set" Bash builtin.

    Example 3-2. Saving the output of a code block to a file

    #!/bin/bash
    # rpm-check.sh

    #  Queries an rpm file for description, listing,
    #+ and whether it can be installed.
    #  Saves output to a file.
    # 
    #  This script illustrates using a code block.

    SUCCESS=0
    E_NOARGS=65

    if [ -z "$1" ]
    then
      echo "Usage: `basename $0` rpm-file"
      exit $E_NOARGS
    fi  

    { # Begin code block.
      echo
      echo "Archive Description:"
      rpm -qpi $1       # Query description.
      echo
      echo "Archive Listing:"
      rpm -qpl $1       # Query listing.
      echo
      rpm -i --test $1  # Query whether rpm file can be installed.
      if [ "$?" -eq $SUCCESS ]
      then
        echo "$1 can be installed."
      else
        echo "$1 cannot be installed."
      fi  
      echo              # End code block.
    } > "$1.test"       # Redirects output of everything in block to file.

    echo "Results of rpm test in file $1.test"

    # See rpm man page for explanation of options.

    exit 0

    Note	

    Unlike a command group within (parentheses), as above, a code block enclosed by {braces} will not normally launch a subshell. [4] 
{} placeholder for text. Used after xargs -i (replace strings option). The {} double curly brackets are a placeholder for output text.

    ls . | xargs -i -t cp ./{} $1
    #            ^^         ^^

    # From "ex42.sh" (copydir.sh) example.

{} \; pathname. Mostly used in find constructs. This is not a shell builtin.

    Note	The ";" ends the -exec option of a find command sequence. It needs to be escaped to protect it from interpretation by the shell.
[ ] test.
Test expression between [ ]. Note that [ is part of the shell builtin test (and a synonym for it), not a link to the external command /usr/bin/test.
[[ ]] test.

    Test expression between [[ ]]. This is a shell keyword.

    See the discussion on the [[ ... ]] construct.
[ ] array element.

    In the context of an array, brackets set off the numbering of each element of that array.

    Array[1]=slot_1
    echo ${Array[1]}

[ ] range of characters.

    As part of a regular expression, brackets delineate a range of characters to match.
(( )) integer expansion.

    Expand and evaluate integer expression between (( )).

    See the discussion on the (( ... )) construct.
> &> >& >> < <> redirection.

    scriptname >filename redirects the output of scriptname to file filename. Overwrite filename if it already exists.

    command &>filename redirects both the stdout and the stderr of command to filename.

    command >&2 redirects stdout of command to stderr.

    scriptname >>filename appends the output of scriptname to file filename. If filename does not already exist, it is created.

    [i]<>filename opens file filename for reading and writing, and assigns file descriptor i to it. If filename does not exist, it is created.

    process substitution.

    (command)>

    <(command)

    In a different context, the "<" and ">" characters act as string comparison operators.

    In yet another context, the "<" and ">" characters act as integer comparison operators. See also Example 15-9.
<< redirection used in a here document. 
<<< redirection used in a here string. 
<, > ASCII comparison.

    veg1=carrots
    veg2=tomatoes

    if [[ "$veg1" < "$veg2" ]]
    then
      echo "Although $veg1 precede $veg2 in the dictionary,"
      echo -n "this does not necessarily imply anything "
      echo "about my culinary preferences."
    else
      echo "What kind of dictionary are you using, anyhow?"
    fi

\<, \> word boundary in a regular expression.

    bash$ grep '\<the\>' textfile
| pipe. Passes the output (stdout of a previous command to the input (stdin) of the next one, or to the shell. This is a method of chaining commands together.

    echo ls -l | sh
    #  Passes the output of "echo ls -l" to the shell,
    #+ with the same result as a simple "ls -l".


    cat *.lst | sort | uniq
    # Merges and sorts all ".lst" files, then deletes duplicate lines.

    A pipe, as a classic method of interprocess communication, sends the stdout of one process to the stdin of another. In a typical case, a command, such as cat or echo, pipes a stream of data to a filter (a command that transforms its input) for processing.

    cat $filename1 $filename2 | grep $search_word

    For an interesting note on the complexity of using UNIX pipes, see the UNIX FAQ, Part 3.

    The output of a command or commands may be piped to a script.

    #!/bin/bash
    # uppercase.sh : Changes input to uppercase.

    tr 'a-z' 'A-Z'
    #  Letter ranges must be quoted
    #+ to prevent filename generation from single-letter filenames.

    exit 0

    Now, let us pipe the output of ls -l to this script.

    bash$ ls -l | ./uppercase.sh
    -RW-RW-R--    1 BOZO  BOZO       109 APR  7 19:49 1.TXT
     -RW-RW-R--    1 BOZO  BOZO       109 APR 14 16:48 2.TXT
     -RW-R--R--    1 BOZO  BOZO       725 APR 20 20:56 DATA-FILE
    	      

    Note	

    The stdout of each process in a pipe must be read as the stdin of the next. If this is not the case, the data stream will block, and the pipe will not behave as expected.

    cat file1 file2 | ls -l | sort
    # The output from "cat file1 file2" disappears.

    A pipe runs as a child process, and therefore cannot alter script variables.

    variable="initial_value"
    echo "new_value" | read variable
    echo "variable = $variable"     # variable = initial_value

    If one of the commands in the pipe aborts, this prematurely terminates execution of the pipe. Called a broken pipe, this condition sends a SIGPIPE signal.
>| force redirection (even if the noclobber option is set). This will forcibly overwrite an existing file.
|| OR logical operator. In a test construct, the || operator causes a return of 0 (success) if either of the linked test conditions is true.
& Run job in background. A command followed by an & will run in the background.

    bash$ sleep 10 &
    [1] 850
    [1]+  Done                    sleep 10
    	      

    Within a script, commands and even loops may run in the background.

    Example 3-3. Running a loop in the background

    #!/bin/bash
    # background-loop.sh

    for i in 1 2 3 4 5 6 7 8 9 10            # First loop.
    do
      echo -n "$i "
    done & # Run this loop in background.
           # Will sometimes execute after second loop.

    echo   # This 'echo' sometimes will not display.

    for i in 11 12 13 14 15 16 17 18 19 20   # Second loop.
    do
      echo -n "$i "
    done  

    echo   # This 'echo' sometimes will not display.

    # ======================================================

    # The expected output from the script:
    # 1 2 3 4 5 6 7 8 9 10 
    # 11 12 13 14 15 16 17 18 19 20 

    # Sometimes, though, you get:
    # 11 12 13 14 15 16 17 18 19 20 
    # 1 2 3 4 5 6 7 8 9 10 bozo $
    # (The second 'echo' doesn't execute. Why?)

    # Occasionally also:
    # 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
    # (The first 'echo' doesn't execute. Why?)

    # Very rarely something like:
    # 11 12 13 1 2 3 4 5 6 7 8 9 10 14 15 16 17 18 19 20 
    # The foreground loop preempts the background one.

    exit 0

    #  Nasimuddin Ansari suggests adding    sleep 1
    #+ after the   echo -n "$i"   in lines 6 and 14,
    #+ for some real fun.

    Caution	

    A command run in the background within a script may cause the script to hang, waiting for a keystroke. Fortunately, there is a remedy for this.
&& AND logical operator. In a test construct, the && operator causes a return of 0 (success) only if both the linked test conditions are true.
- option, prefix. Option flag for a command or filter. Prefix for an operator. Prefix for a default parameter in parameter substitution.

    COMMAND -[Option1][Option2][...]

    ls -al

    sort -dfu $filename

    if [ $file1 -ot $file2 ]
    then #      ^
      echo "File $file1 is older than $file2."
    fi

    if [ "$a" -eq "$b" ]
    then      ^
      echo "$a is equal to $b."
    fi

    if [ "$c" -eq 24 -a "$d" -eq 47 ]
    then      ^              ^
      echo "$c equals 24 and $d equals 47."
    fi


    param2=${param1:-$DEFAULTVAL}
    #               ^

    --

    The double-dash -- prefixes long (verbatim) options to commands.

    sort --ignore-leading-blanks

    Used with a Bash builtin, it means the end of options to that particular command.

    It is also used in conjunction with set.

    set -- $variable (as in Example 14-18)
- redirection from/to stdin or stdout [dash].

    (cd /source/directory && tar cf - . ) | (cd /dest/directory && tar xpvf -)
    # Move entire file tree from one directory to another
    # [courtesy Alan Cox <a.cox@swansea.ac.uk>, with a minor change]

    # 1) cd /source/directory
    #    Source directory, where the files to be moved are.
    # 2) &&
    #   "And-list": if the 'cd' operation successful,
    #    then execute the next command.
    # 3) tar cf - .
    #    The 'c' option 'tar' archiving command creates a new archive,
    #    the 'f' (file) option, followed by '-' designates the target file
    #    as stdout, and do it in current directory tree ('.').
    # 4) |
    #    Piped to ...
    # 5) ( ... )
    #    a subshell
    # 6) cd /dest/directory
    #    Change to the destination directory.
    # 7) &&
    #   "And-list", as above
    # 8) tar xpvf -
    #    Unarchive ('x'), preserve ownership and file permissions ('p'),
    #    and send verbose messages to stdout ('v'),
    #    reading data from stdin ('f' followed by '-').
    #
    #    Note that 'x' is a command, and 'p', 'v', 'f' are options.
    #
    # Whew!



    # More elegant than, but equivalent to:
    #   cd source/directory
    #   tar cf - . | (cd ../dest/directory; tar xpvf -)
    #
    #     Also having same effect:
    # cp -a /source/directory/* /dest/directory */
    #     Or:
    # cp -a /source/directory/* /source/directory/.[^.]* /dest/directory */
    #     If there are hidden files in /source/directory.

    bunzip2 -c linux-2.6.16.tar.bz2 | tar xvf -
    #  --uncompress tar file--    | --then pass it to "tar"--
    #  If "tar" has not been patched to handle "bunzip2",
    #+ this needs to be done in two discrete steps, using a pipe.
    #  The purpose of the exercise is to unarchive "bzipped" kernel source.

    Note that in this context the "-" is not itself a Bash operator, but rather an option recognized by certain UNIX utilities that write to stdout, such as tar, cat, etc.

    bash$ echo "whatever" | cat -
    whatever 

    Where a filename is expected, - redirects output to stdout (sometimes seen with tar cf), or accepts input from stdin, rather than from a file. This is a method of using a file-oriented utility as a filter in a pipe.

    bash$ file
    Usage: file [-bciknvzL] [-f namefile] [-m magicfiles] file...
    	      

    By itself on the command line, file fails with an error message.

    Add a "-" for a more useful result. This causes the shell to await user input.

    bash$ file -
    abc
    standard input:              ASCII text



    bash$ file -
    #!/bin/bash
    standard input:              Bourne-Again shell script text executable
    	      

    Now the command accepts input from stdin and analyzes it.

    The "-" can be used to pipe stdout to other commands. This permits such stunts as prepending lines to a file.

    Using diff to compare a file with a section of another:

    grep Linux file1 | diff file2 -

    Finally, a real-world example using - with tar.

    Example 3-4. Backup of all files changed in last day

    #!/bin/bash

    #  Backs up all files in current directory modified within last 24 hours
    #+ in a "tarball" (tarred and gzipped file).

    BACKUPFILE=backup-$(date +%m-%d-%Y)
    #                 Embeds date in backup filename.
    #                 Thanks, Joshua Tschida, for the idea.
    archive=${1:-$BACKUPFILE}
    #  If no backup-archive filename specified on command line,
    #+ it will default to "backup-MM-DD-YYYY.tar.gz."

    tar cvf - `find . -mtime -1 -type f -print` > $archive.tar
    gzip $archive.tar
    echo "Directory $PWD backed up in archive file \"$archive.tar.gz\"."


    #  Stephane Chazelas points out that the above code will fail
    #+ if there are too many files found
    #+ or if any filenames contain blank characters.

    # He suggests the following alternatives:
    # -------------------------------------------------------------------
    #   find . -mtime -1 -type f -print0 | xargs -0 tar rvf "$archive.tar"
    #      using the GNU version of "find".


    #   find . -mtime -1 -type f -exec tar rvf "$archive.tar" '{}' \;
    #         portable to other UNIX flavors, but much slower.
    # -------------------------------------------------------------------


    exit 0

    Caution	

    Filenames beginning with "-" may cause problems when coupled with the "-" redirection operator. A script should check for this and add an appropriate prefix to such filenames, for example ./-FILENAME, $PWD/-FILENAME, or $PATHNAME/-FILENAME.

    If the value of a variable begins with a -, this may likewise create problems.

    var="-n"
    echo $var		
    # Has the effect of "echo -n", and outputs nothing.

- previous working directory. A cd - command changes to the previous working directory. This uses the $OLDPWD environmental variable.

    Caution	Do not confuse the "-" used in this sense with the "-" redirection operator just discussed. The interpretation of the "-" depends on the context in which it appears.
- Minus. Minus sign in an arithmetic operation.
= Equals. Assignment operator

    a=28
    echo $a   # 28

    In a different context, the "=" is a string comparison operator.
+ Plus. Addition arithmetic operator.

    In a different context, the + is a Regular Expression operator.
+ Option. Option flag for a command or filter.

    Certain commands and builtins use the + to enable certain options and the - to disable them. In parameter substitution, the + prefixes an alternate value that a variable expands to.
% modulo. Modulo (remainder of a division) arithmetic operation.

    In a different context, the % is a pattern matching operator.
~ home directory [tilde]. This corresponds to the $HOME internal variable. ~bozo is bozo's home directory, and ls ~bozo lists the contents of it. ~/ is the current user's home directory, and ls ~/ lists the contents of it.

    bash$ echo ~bozo
    /home/bozo

    bash$ echo ~
    /home/bozo

    bash$ echo ~/
    /home/bozo/

    bash$ echo ~:
    /home/bozo:

    bash$ echo ~nonexistent-user
    ~nonexistent-user
    	      

~+ current working directory. This corresponds to the $PWD internal variable.
~- previous working directory. This corresponds to the $OLDPWD internal variable.
=~ regular expression match. This operator was introduced with version 3 of Bash.
^ beginning-of-line. In a regular expression, a "^" addresses the beginning of a line of text.
Control Characters

    change the behavior of the terminal or text display. A control character is a CONTROL + key combination (pressed simultaneously). A control character may also be written in octal or hexadecimal notation, following an escape.

    Control characters are not normally useful inside a script.

        * Ctl-B Backspace (nondestructive).
        * Ctl-C Break. Terminate a foreground job.
        * Ctl-D Log out from a shell (similar to exit).

          "EOF" (end of file). This also terminates input from stdin.

          When typing text on the console or in an xterm window, Ctl-D erases the character under the cursor. When there are no characters present, Ctl-D logs out of the session, as expected. In an xterm window, this has the effect of closing the window.
        * Ctl-G "BEL" (beep). On some old-time teletype terminals, this would actually ring a bell.
        * Ctl-H "Rubout" (destructive backspace). Erases characters the cursor backs over while backspacing.

          #!/bin/bash
          # Embedding Ctl-H in a string.

          a="^H^H"                  # Two Ctl-H's -- backspaces
                                    # ctl-V ctl-H, using vi/vim
          echo "abcdef"             # abcdef
          echo
          echo -n "abcdef$a "       # abcd f
          #  Space at end  ^              ^  Backspaces twice.
          echo
          echo -n "abcdef$a"        # abcdef
          #  No space at end               ^ Doesn't backspace (why?).
                                    # Results may not be quite as expected.
          echo; echo

          # Constantin Hagemeier suggests trying:
          # a=$'\010\010'
          # a=$'\b\b'
          # a=$'\x08\x08'
          # But, this does not change the results.

        * Ctl-I Horizontal tab.
        * Ctl-J Newline (line feed). In a script, may also be expressed in octal notation -- '\012' or in hexadecimal -- '\x0a'.
        * Ctl-K Vertical tab.

          When typing text on the console or in an xterm window, Ctl-K erases from the character under the cursor to end of line. Within a script, Ctl-K may behave differently, as in Lee Lee Maschmeyer's example, below.
        * Ctl-L Formfeed (clear the terminal screen). In a terminal, this has the same effect as the clear command. When sent to a printer, a Ctl-L causes an advance to end of the paper sheet.
        * Ctl-M Carriage return.

          #!/bin/bash
          # Thank you, Lee Maschmeyer, for this example.

          read -n 1 -s -p \
          $'Control-M leaves cursor at beginning of this line. Press Enter. \x0d'
                     # Of course, '0d' is the hex equivalent of Control-M.
          echo >&2   #  The '-s' makes anything typed silent,
                     #+ so it is necessary to go to new line explicitly.

          read -n 1 -s -p $'Control-J leaves cursor on next line. \x0a'
                     #  '0a' is the hex equivalent of Control-J, linefeed.
          echo >&2

          ###

          read -n 1 -s -p $'And Control-K\x0bgoes straight down.'
          echo >&2   #  Control-K is vertical tab.

          # A better example of the effect of a vertical tab is:

          var=$'\x0aThis is the bottom line\x0bThis is the top line\x0a'
          echo "$var"
          #  This works the same way as the above example. However:
          echo "$var" | col
          #  This causes the right end of the line to be higher than the left end.
          #  It also explains why we started and ended with a line feed --
          #+ to avoid a garbled screen.

          # As Lee Maschmeyer explains:
          # --------------------------
          #  In the [first vertical tab example] . . . the vertical tab
          #+ makes the printing go straight down without a carriage return.
          #  This is true only on devices, such as the Linux console,
          #+ that can't go "backward."
          #  The real purpose of VT is to go straight UP, not down.
          #  It can be used to print superscripts on a printer.
          #  The col utility can be used to emulate the proper behavior of VT.

          exit 0

        * Ctl-Q Resume (XON).

          This resumes stdin in a terminal.
        * Ctl-S Suspend (XOFF).

          This freezes stdin in a terminal. (Use Ctl-Q to restore input.)
        * Ctl-U Erase a line of input, from the cursor backward to beginning of line. In some settings, Ctl-U erases the entire line of input, regardless of cursor position.
        * Ctl-V When inputting text, Ctl-V permits inserting control characters. For example, the following two are equivalent:

          echo -e '\x0a'
          echo <Ctl-V><Ctl-J>

          Ctl-V is primarily useful from within a text editor.
        * Ctl-W When typing text on the console or in an xterm window, Ctl-W erases from the character under the cursor backwards to the first instance of whitespace. In some settings, Ctl-W erases backwards to first non-alphanumeric character.
        * Ctl-Y Pastes back text previously erased (with Ctl-K or Ctl-U).
        * Ctl-Z Pause a foreground job.

Whitespace

    functions as a separator, separating commands or variables. Whitespace consists of either spaces, tabs, blank lines, or any combination thereof. [5] In some contexts, such as variable assignment, whitespace is not permitted, and results in a syntax error.

    Blank lines have no effect on the action of a script, and are therefore useful for visually separating functional sections.

    $IFS, the special variable separating fields of input to certain commands, defaults to whitespace.

    To preserve whitespace within a string or in a variable, use quoting.

		12.1.2 Introduction to Variables and Parameters (Chapter 4)
		
			12.1.2.1  Variable Substitution
			The name of a variable is a placeholder for its value, the data it holds. Referencing its value is called variable substitution.

$ Let us carefully distinguish between the name of a variable and its value. If variable1 is the name of a variable, then $variable1 is a reference to its value, the data item it contains. [1]

    bash$ variable=23


    bash$ echo variable
    variable

    bash$ echo $variable
    23

    The only time a variable appears "naked" -- without the $ prefix -- is when declared or assigned, when unset, when exported, or in the special case of a variable representing a signal (see Example 29-5). Assignment may be with an = (as in var1=27), in a read statement, and at the head of a loop (for var2 in 1 2 3).

    Enclosing a referenced value in double quotes (" ") does not interfere with variable substitution. This is called partial quoting, sometimes referred to as "weak quoting." Using single quotes (' ') causes the variable name to be used literally, and no substitution will take place. This is full quoting, sometimes referred to as "strong quoting." See Chapter 5 for a detailed discussion.
//'

    Note that $variable is actually a simplified alternate form of ${variable}. In contexts where the $variable syntax causes an error, the longer form may work.

    Example Variable assignment and substitution

    #!/bin/bash
    # ex9.sh

    # Variables: assignment and substitution

    a=375
    hello=$a

    #-------------------------------------------------------------------------
    # No space permitted on either side of = sign when initializing variables.
    # What happens if there is a space?

    #  "VARIABLE =value"
    #           ^
    #% Script tries to run "VARIABLE" command with one argument, "=value".

    #  "VARIABLE= value"
    #            ^
    #% Script tries to run "value" command with
    #+ the environmental variable "VARIABLE" set to "".
    #-------------------------------------------------------------------------


    echo hello    # hello
    # Not a variable reference, just the string "hello" . . .

    echo $hello   # 375
    #    ^          This *is* a variable reference.
    echo ${hello} # 375
    # Also a variable reference, as above.

    # Quoting . . .
    echo "$hello"    # 375
    echo "${hello}"  # 375

    echo

    hello="A B  C   D"
    echo $hello   # A B C D
    echo "$hello" # A B  C   D
    # As you see, echo $hello   and   echo "$hello"   give different results.
    # Why?
    # =======================================
    # Quoting a variable preserves whitespace.
    # =======================================

    echo

    echo '$hello'  # $hello
    #    ^      ^
    #  Variable referencing disabled (escaped) by single quotes,
    #+ which causes the "$" to be interpreted literally.

    # Notice the effect of different types of quoting.


    hello=    # Setting it to a null value.
    echo "\$hello (null value) = $hello"
    #  Note that setting a variable to a null value is not the same as
    #+ unsetting it, although the end result is the same (see below).

    # --------------------------------------------------------------

    #  It is permissible to set multiple variables on the same line,
    #+ if separated by white space.
    #  Caution, this may reduce legibility, and may not be portable.

    var1=21  var2=22  var3=$V3
    echo
    echo "var1=$var1   var2=$var2   var3=$var3"

    # May cause problems with older versions of "sh" . . .

    # --------------------------------------------------------------

    echo; echo

    numbers="one two three"
    #           ^   ^
    other_numbers="1 2 3"
    #               ^ ^
    #  If there is whitespace embedded within a variable,
    #+ then quotes are necessary.
    #  other_numbers=1 2 3                  # Gives an error message.
    echo "numbers = $numbers"
    echo "other_numbers = $other_numbers"   # other_numbers = 1 2 3
    #  Escaping the whitespace also works.
    mixed_bag=2\ ---\ Whatever
    #           ^    ^ Space after escape (\).

    echo "$mixed_bag"         # 2 --- Whatever

    echo; echo

    echo "uninitialized_variable = $uninitialized_variable"
    # Uninitialized variable has null value (no value at all!).
    uninitialized_variable=   #  Declaring, but not initializing it --
                              #+ same as setting it to a null value, as above.
    echo "uninitialized_variable = $uninitialized_variable"
                              # It still has a null value.

    uninitialized_variable=23       # Set it.
    unset uninitialized_variable    # Unset it.
    echo "uninitialized_variable = $uninitialized_variable"
                                    # It still has a null value.
    echo

    exit 0

    Caution	

    An uninitialized variable has a "null" value - no assigned value at all (not zero!). Using a variable before assigning a value to it will usually cause problems.

    It is nevertheless possible to perform arithmetic operations on an uninitialized variable.

    echo "$uninitialized"                                # (blank line)
    let "uninitialized += 5"                             # Add 5 to it.
    echo "$uninitialized"                                # 5

    #  Conclusion:
    #  An uninitialized variable has no value,
    #+ however it acts as if it were 0 in an arithmetic operation.
    #  This is undocumented (and probably non-portable) behavior.

			12.1.2.2 Variable assignment
= the assignment operator (no space before and after)

    Caution	Do not confuse this with = and -eq, which test, rather than assign!

    Note that = can be either an assignment or a test operator, depending on context.

    Example Plain Variable Assignment
    #!/bin/bash
    # Naked variables

    echo

    # When is a variable "naked", i.e., lacking the '$' in front?
    # When it is being assigned, rather than referenced.

    # Assignment
    a=879
    echo "The value of \"a\" is $a."

    # Assignment using 'let'
    let a=16+5
    echo "The value of \"a\" is now $a."

    echo

    # In a 'for' loop (really, a type of disguised assignment):
    echo -n "Values of \"a\" in the loop are: "
    for a in 7 8 9 11
    do
      echo -n "$a "
    done

    echo
    echo

    # In a 'read' statement (also a type of assignment):
    echo -n "Enter \"a\" "
    read a
    echo "The value of \"a\" is now $a."

    echo
    exit 0

    Example Variable Assignment, plain and fancy
    #!/bin/bash

    a=23              # Simple case
    echo $a
    b=$a
    echo $b

    # Now, getting a little bit fancier (command substitution).

    a=`echo Hello!`   # Assigns result of 'echo' command to 'a'
    echo $a
    #  Note that including an exclamation mark (!) within a
    #+ command substitution construct #+ will not work from the command line,
    #+ since this triggers the Bash "history mechanism."
    #  Inside a script, however, the history functions are disabled.

    a=`ls -l`         # Assigns result of 'ls -l' command to 'a'
    echo $a           # Unquoted, however, removes tabs and newlines.
    echo
    echo "$a"         # The quoted variable preserves whitespace.
                      # (See the chapter on "Quoting.")

    exit 0

    Variable assignment using the $(...) mechanism (a newer method than backquotes). This is actually a form of command substitution.

    # From /etc/rc.d/rc.local
    R=$(cat /etc/redhat-release)
    arch=$(uname -m)
    echo "$R"
    echo "$arch"


			12.1.2.3 Bash Variables Are Untyped

Unlike many other programming languages, Bash does not segregate its variables by "type". Essentially, Bash variables are character strings, but, depending on context, Bash permits integer operations and comparisons on variables. The determining factor is whether the value of a variable contains only digits.

Example Integer or string?

#!/bin/bash
# int-or-string.sh: Integer or string?

a=2334                   # Integer.
let "a += 1"
echo "a = $a "           # a = 2335
echo                     # Integer, still.


b=${a/23/BB}             # Substitute "BB" for "23".
                         # This transforms $b into a string.
echo "b = $b"            # b = BB35
declare -i b             # Declaring it an integer doesn't help.
echo "b = $b"            # b = BB35

let "b += 1"             # BB35 + 1 =
echo "b = $b"            # b = 1
echo

c=BB34
echo "c = $c"            # c = BB34
d=${c/BB/23}             # Substitute "23" for "BB".
                         # This makes $d an integer.
echo "d = $d"            # d = 2334
let "d += 1"             # 2334 + 1 =
echo "d = $d"            # d = 2335
echo

# What about null variables?
e=""
echo "e = $e"            # e =
let "e += 1"             # Arithmetic operations allowed on a null variable?
echo "e = $e"            # e = 1
echo                     # Null variable transformed into an integer.

# What about undeclared variables?
echo "f = $f"            # f =
let "f += 1"             # Arithmetic operations allowed?
echo "f = $f"            # f = 1
echo                     # Undeclared variable transformed into an integer.



# Variables in Bash are essentially untyped.

exit 0

Untyped variables are both a blessing and a curse. They permit more flexibility in scripting (enough rope to hang yourself!) and make it easier to grind out lines of code. However, they permit errors to creep in and encourage sloppy programming habits.

The burden is on the programmer to keep track of what type the script variables are. Bash will not do it for you.

			12.1.2.4 Special variable types
local variables: variables visible only within a code block or function (see also local variables in functions)
environmental variables: variables that affect the behavior of the shell and user interface

    Note	In a more general context, each process has an "environment", that is, a group of variables that hold information that the process may reference. In this sense, the shell behaves like any other process.

    Every time a shell starts, it creates shell variables that correspond to its own environmental variables. Updating or adding new environmental variables causes the shell to update its environment, and all the shell's child processes (the commands it executes) inherit this environment.

    Caution	The space allotted to the environment is limited. Creating too many environmental variables or ones that use up excessive space may cause problems.

    bash$ eval "`seq 10000 | sed -e 's/.*/export var&=ZZZZZZZZZZZZZZ/'`"
    bash$ du
    bash: /usr/bin/du: Argument list too long

    (Thank you, Stphane Chazelas for the clarification, and for providing the above example.)

    If a script sets environmental variables, they need to be "exported", that is, reported to the environment local to the script. This is the function of the export command.

    Note	A script can export variables only to child processes, that is, only to commands or processes which that particular script initiates. A script invoked from the command line cannot export variables back to the command line environment. Child processes cannot export variables back to the parent processes that spawned them.

    Definition: A child process is a subprocess launched by another process, its parent.

    ---
positional parameters

    arguments passed to the script from the command line: $0, $1, $2, $3 . . .

    $0 is the name of the script itself, $1 is the first argument, $2 the second, $3 the third, and so forth. [1] After $9, the arguments must be enclosed in brackets, for example, ${10}, ${11}, ${12}.

    The special variables $* and $@ denote all the positional parameters.

    Example Positional Parameters

    #!/bin/bash

    # Call this script with at least 10 parameters, for example
    # ./scriptname 1 2 3 4 5 6 7 8 9 10
    MINPARAMS=10

    echo

    echo "The name of this script is \"$0\"."
    # Adds ./ for current directory
    echo "The name of this script is \"`basename $0`\"."
    # Strips out path name info (see 'basename')

    echo

    if [ -n "$1" ]              # Tested variable is quoted.
    then
     echo "Parameter #1 is $1"  # Need quotes to escape #
    fi 

    if [ -n "$2" ]
    then
     echo "Parameter #2 is $2"
    fi 

    if [ -n "$3" ]
    then
     echo "Parameter #3 is $3"
    fi 

    # ...


    if [ -n "${10}" ]  # Parameters > $9 must be enclosed in {brackets}.
    then
     echo "Parameter #10 is ${10}"
    fi 

    echo "-----------------------------------"
    echo "All the command-line parameters are: "$*""

    if [ $# -lt "$MINPARAMS" ]
    then
      echo
      echo "This script needs at least $MINPARAMS command-line arguments!"
    fi  

    echo

    exit 0

    Bracket notation for positional parameters leads to a fairly simple way of referencing the last argument passed to a script on the command line. This also requires indirect referencing.

    args=$#           # Number of args passed.
    lastarg=${!args}
    # Or:       lastarg=${!#}
    #           (Thanks, Chris Monson.)
    # Note that lastarg=${!$#} doesn't work.

    Some scripts can perform different operations, depending on which name they are invoked with. For this to work, the script needs to check $0, the name it was invoked by. There must also exist symbolic links to all the alternate names of the script. See Example 15-2.

    Tip	If a script expects a command line parameter but is invoked without one, this may cause a null variable assignment, generally an undesirable result. One way to prevent this is to append an extra character to both sides of the assignment statement using the expected positional parameter.

    variable1_=$1_  # Rather than variable1=$1
    # This will prevent an error, even if positional parameter is absent.

    critical_argument01=$variable1_

    # The extra character can be stripped off later, like so.
    variable1=${variable1_/_/}
    # Side effects only if $variable1_ begins with an underscore.
    # This uses one of the parameter substitution templates discussed later.
    # (Leaving out the replacement pattern results in a deletion.)

    #  A more straightforward way of dealing with this is
    #+ to simply test whether expected positional parameters have been passed.
    if [ -z $1 ]
    then
      exit $E_MISSING_POS_PARAM
    fi


    #  However, as Fabian Kreutz points out,
    #+ the above method may have unexpected side-effects.
    #  A better method is parameter substitution:
    #         ${1:-$DefaultVal}
    #  See the "Parameter Substition" section
    #+ in the "Variables Revisited" chapter.

    ---

    Example wh, whois domain name lookup

    #!/bin/bash
    # ex18.sh

    # Does a 'whois domain-name' lookup on any of 3 alternate servers:
    #                    ripe.net, cw.net, radb.net

    # Place this script -- renamed 'wh' -- in /usr/local/bin

    # Requires symbolic links:
    # ln -s /usr/local/bin/wh /usr/local/bin/wh-ripe
    # ln -s /usr/local/bin/wh /usr/local/bin/wh-cw
    # ln -s /usr/local/bin/wh /usr/local/bin/wh-radb

    E_NOARGS=65


    if [ -z "$1" ]
    then
      echo "Usage: `basename $0` [domain-name]"
      exit $E_NOARGS
    fi

    # Check script name and call proper server.
    case `basename $0` in    # Or:    case ${0##*/} in
        "wh"     ) whois $1@whois.ripe.net;;
        "wh-ripe") whois $1@whois.ripe.net;;
        "wh-radb") whois $1@whois.radb.net;;
        "wh-cw"  ) whois $1@whois.cw.net;;
        *        ) echo "Usage: `basename $0` [domain-name]";;
    esac 

    exit $?

    ---

    The shift command reassigns the positional parameters, in effect shifting them to the left one notch.

    $1 <--- $2, $2 <--- $3, $3 <--- $4, etc.

    The old $1 disappears, but $0 (the script name) does not change. If you use a large number of positional parameters to a script, shift lets you access those past 10, although {bracket} notation also permits this.

    Example Using shift

    #!/bin/bash
    # shft.sh: Using 'shift' to step through all the positional parameters

    #  Name this script something like shft.sh,
    #+ and invoke it with some parameters.
    #+ For example:
    #             sh shft.sh a b c def 23 skidoo

    until [ -z "$1" ]  # Until all parameters used up . . .
    do
      echo -n "$1 "
      shift
    done

    echo               # Extra line feed.

    exit 0

    #  See also the echo-params.sh script for a "shiftless"
    #+ alternative method of stepping through the positional params.

    The shift command can take a numerical parameter indicating how many positions to shift.

    #!/bin/bash
    # shift-past.sh

    shift 3    # Shift 3 positions.
    #  n=3; shift $n
    #  Has the same effect.

    echo "$1"

    exit 0


    $ sh shift-past.sh 1 2 3 4 5
    4

    Note	

    The shift command works in a similar fashion on parameters passed to a function. 

	12.2 Chapter 5. Quoting
Quoting means just that, bracketing a string in quotes. This has the effect of protecting special characters in the string from reinterpretation or expansion by the shell or shell script. (A character is "special" if it has an interpretation other than its literal meaning, such as the wild card character -- *.)

bash$ ls -l [Vv]*
-rw-rw-r--    1 bozo  bozo       324 Apr  2 15:05 VIEWDATA.BAT
 -rw-rw-r--    1 bozo  bozo       507 May  4 14:25 vartrace.sh
 -rw-rw-r--    1 bozo  bozo       539 Apr 14 17:11 viewdata.sh

bash$ ls -l '[Vv]*'
ls: [Vv]*: No such file or directory

In everyday speech or writing, when we "quote" a phrase, we set it apart and give it special meaning. In a Bash script, when we quote a string, we set it apart and protect its literal meaning.

Certain programs and utilities reinterpret or expand special characters in a quoted string. An important use of quoting is protecting a command-line parameter from the shell, but still letting the calling program expand it.

bash$ grep '[Ff]irst' *.txt
file1.txt:This is the first line of file1.txt.
 file2.txt:This is the First line of file2.txt.

Note that the unquoted grep [Ff]irst *.txt works under the Bash shell. [1]

Quoting can also suppress echo's "appetite" for newlines.

bash$ echo $(ls -l)
total 8 -rw-rw-r-- 1 bo bo 13 Aug 21 12:57 t.sh -rw-rw-r-- 1 bo bo 78 Aug 21 12:57 u.sh


bash$ echo "$(ls -l)"
total 8
 -rw-rw-r--  1 bo bo  13 Aug 21 12:57 t.sh
 -rw-rw-r--  1 bo bo  78 Aug 21 12:57 u.sh

		12.2.1 Quoting Variables
When referencing a variable, it is generally advisable to enclose its name in double quotes. This prevents reinterpretation of all special characters within the quoted string -- the variable name [1]  -- except $, ` (backquote), and \ (escape). [2]  Keeping $ as a special character within double quotes permits referencing a quoted variable ("$variable"), that is, replacing the variable with its value (see Example 4-1, above).

Use double quotes to prevent word splitting. [3] An argument enclosed in double quotes presents itself as a single word, even if it contains whitespace separators.

variable1="a variable containing five words"
COMMAND This is $variable1    # Executes COMMAND with 7 arguments:
# "This" "is" "a" "variable" "containing" "five" "words"

COMMAND "This is $variable1"  # Executes COMMAND with 1 argument:
# "This is a variable containing five words"


variable2=""    # Empty.

COMMAND $variable2 $variable2 $variable2
                # Executes COMMAND with no arguments. 
COMMAND "$variable2" "$variable2" "$variable2"
                # Executes COMMAND with 3 empty arguments. 
COMMAND "$variable2 $variable2 $variable2"
                # Executes COMMAND with 1 argument (2 spaces). 

# Thanks, Stphane Chazelas.

Tip	

Enclosing the arguments to an echo statement in double quotes is necessary only when word splitting or preservation of whitespace is an issue.

Example Echoing Weird Variables

#!/bin/bash
# weirdvars.sh: Echoing weird variables.

var="'(]\\{}\$\""
echo $var        # '(]\{}$"
echo "$var"      # '(]\{}$"     Doesn't make a difference.

echo

IFS='\'
echo $var        # '(] {}$"     \ converted to space. Why?
echo "$var"      # '(]\{}$"

# Examples above supplied by Stephane Chazelas.

exit 0

Single quotes (' ') operate similarly to double quotes, but do not permit referencing variables, since the special meaning of $ is turned off. Within single quotes, every special character except ' gets interpreted literally. Consider single quotes ("full quoting") to be a stricter method of quoting than double quotes ("partial quoting").

Note	

Since even the escape character (\) gets a literal interpretation within single quotes, trying to enclose a single quote within single quotes will not yield the expected result.

echo "Why can't I write 's between single quotes"

echo

# The roundabout method.
echo 'Why can'\''t I write '"'"'s between single quotes'
#    |-------|  |----------|   |-----------------------|
# Three single-quoted strings, with escaped and quoted single quotes between.

# This example courtesy of Stphane Chazelas.

Notes
[1]	It also has side-effects on the value of the variable (see below)
[2]	Encapsulating "!" within double quotes gives an error when used from the command line. This is interpreted as a history command. Within a script, though, this problem does not occur, since the Bash history mechanism is disabled then.

Of more concern is the apparently inconsistent behavior of "\" within double quotes.

bash$ echo hello\!
hello!

bash$ echo "hello\!"
hello\!



bash$ echo -e x\ty
xty

bash$ echo -e "x\ty"
x       y
	      

What happens is that double quotes normally escape the "\" escape character, so that it echoes literally. However, the -e option to echo changes that. It causes the "\t" to be interpreted as a tab.
(Thank you, Wayne Pollock, for pointing this out, and Geoff Lee for explaining it.)

[3]	"Word splitting", in this context, means dividing a character string into a number of separate and discrete arguments.

		12.2.2 Escaping 
		Escaping is a method of quoting single characters. The escape  (\) preceding a character tells the shell to interpret that character literally.

Caution	With certain commands and utilities, such as echo and sed, escaping a character may have the opposite effect - it can toggle on a special meaning for that character.

Special meanings of certain escaped characters

used with echo and sed

\n means newline
\r means return
\t means tab
\v means vertical tab
\b means backspace
\a means "alert" (beep or flash)
\0xx translates to the octal ASCII equivalent of 0xx

    Example Escaped Characters

    #!/bin/bash
    # escaped.sh: escaped characters

    echo; echo

    # Escaping a newline.
    # ------------------

    echo ""

    echo "This will print
    as two lines."
    # This will print
    # as two lines.

    echo "This will print \
    as one line."
    # This will print as one line.

    echo; echo

    echo "============="


    echo "\v\v\v\v"      # Prints \v\v\v\v literally.
    # Use the -e option with 'echo' to print escaped characters.
    echo "============="
    echo "VERTICAL TABS"
    echo -e "\v\v\v\v"   # Prints 4 vertical tabs.
    echo "=============="

    echo "QUOTATION MARK"
    echo -e "\042"       # Prints " (quote, octal ASCII character 42).
    echo "=============="

    # The $'\X' construct makes the -e option unnecessary.
    echo; echo "NEWLINE AND BEEP"
    echo $'\n'           # Newline.
    echo $'\a'           # Alert (beep).

    echo "==============="
    echo "QUOTATION MARKS"
    # Version 2 and later of Bash permits using the $'\nnn' construct.
    # Note that in this case, '\nnn' is an octal value.
    echo $'\t \042 \t'   # Quote (") framed by tabs.

    # It also works with hexadecimal values, in an $'\xhhh' construct.
    echo $'\t \x22 \t'  # Quote (") framed by tabs.
    # Thank you, Greg Keraunen, for pointing this out.
    # Earlier Bash versions allowed '\x022'.
    echo "==============="
    echo





    # Assigning ASCII characters to a variable.
    # ----------------------------------------
    quote=$'\042'        # " assigned to a variable.
    echo "$quote This is a quoted string, $quote and this lies outside the quotes."

    echo

    # Concatenating ASCII chars in a variable.
    triple_underline=$'\137\137\137'  # 137 is octal ASCII code for '_'.
    echo "$triple_underline UNDERLINE $triple_underline"

    echo

    ABC=$'\101\102\103\010'           # 101, 102, 103 are octal A, B, C.
    echo $ABC

    echo; echo

    escape=$'\033'                    # 033 is octal for escape.
    echo "\"escape\" echoes as $escape"
    #                                   no visible output.

    echo; echo

    exit 0

\" gives the quote its literal meaning

    echo "Hello"                  # Hello
    echo "\"Hello\", he said."    # "Hello", he said.

\$ gives the dollar sign its literal meaning (variable name following \$ will not be referenced)

    echo "\$variable01"  # results in $variable01

\\ gives the backslash its literal meaning

    echo "\\"  # Results in \

    # Whereas . . .

    echo "\"   # Invokes secondary prompt from the command line.
               # In a script, gives an error message.

Note	The behavior of \ depends on whether it is itself escaped, quoted, or appearing within command substitution or a here document.

                      #  Simple escaping and quoting
echo \z               #  z
echo \\z              # \z
echo '\z'             # \z
echo '\\z'            # \\z
echo "\z"             # \z
echo "\\z"            # \z

                      #  Command substitution
echo `echo \z`        #  z
echo `echo \\z`       #  z
echo `echo \\\z`      # \z
echo `echo \\\\z`     # \z
echo `echo \\\\\\z`   # \z
echo `echo \\\\\\\z`  # \\z
echo `echo "\z"`      # \z
echo `echo "\\z"`     # \z

                      # Here document
cat <<EOF              
\z                      
EOF                   # \z

cat <<EOF              
\\z                     
EOF                   # \z

# These examples supplied by Stphane Chazelas.

Elements of a string assigned to a variable may be escaped, but the escape character alone may not be assigned to a variable.

variable=\
echo "$variable"
# Will not work - gives an error message:
# test.sh: : command not found
# A "naked" escape cannot safely be assigned to a variable.
#
#  What actually happens here is that the "\" escapes the newline and
#+ the effect is        variable=echo "$variable"
#+                      invalid variable assignment

variable=\
23skidoo
echo "$variable"        #  23skidoo
                        #  This works, since the second line
                        #+ is a valid variable assignment.

variable=\ 
#        \^    escape followed by space
echo "$variable"        # space

variable=\\
echo "$variable"        # \

variable=\\\
echo "$variable"
# Will not work - gives an error message:
# test.sh: \: command not found
#
#  First escape escapes second one, but the third one is left "naked",
#+ with same result as first instance, above.

variable=\\\\
echo "$variable"        # \\
                        # Second and fourth escapes escaped.
                        # This is o.k.

Escaping a space can prevent word splitting in a command's argument list.

file_list="/bin/cat /bin/gzip /bin/more /usr/bin/less /usr/bin/emacs-20.7"
# List of files as argument(s) to a command.

# Add two files to the list, and list all.
ls -l /usr/X11R6/bin/xsetroot /sbin/dump $file_list

echo "-------------------------------------------------------------------------"

# What happens if we escape a couple of spaces?
ls -l /usr/X11R6/bin/xsetroot\ /sbin/dump\ $file_list
# Error: the first three files concatenated into a single argument to 'ls -l'
#        because the two escaped spaces prevent argument (word) splitting.

The escape also provides a means of writing a multi-line command. Normally, each separate line constitutes a different command, but an escape at the end of a line escapes the newline character, and the command sequence continues on to the next line.

(cd /source/directory && tar cf - . ) | \
(cd /dest/directory && tar xpvf -)
# Repeating Alan Cox's directory tree copy command,
# but split into two lines for increased legibility.

# As an alternative:
tar cf - -C /source/directory . |
tar xpvf - -C /dest/directory
# See note below.
# (Thanks, Stphane Chazelas.)

Note	

If a script line ends with a |, a pipe character, then a \, an escape, is not strictly necessary. It is, however, good programming practice to always escape the end of a line of code that continues to the following line.

echo "foo
bar" 
#foo
#bar

echo

echo 'foo
bar'    # No difference yet.
#foo
#bar

echo

echo foo\
bar     # Newline escaped.
#foobar

echo

echo "foo\
bar"     # Same here, as \ still interpreted as escape within weak quotes.
#foobar

echo

echo 'foo\
bar'     # Escape character \ taken literally because of strong quoting.
#foo\
#bar

# Examples suggested by Stphane Chazelas.


	12.3 Chapter 6. Exit and Exit Status
The  exit  command may be used to terminate a script, just as in a C program. It can also return a value, which is available to the script's parent process.

Every command returns an exit status (sometimes referred to as a return status or exit code). A successful command returns a 0, while an unsuccessful one returns a non-zero value that usually may be interpreted as an error code. Well-behaved UNIX commands, programs, and utilities return a 0 exit code upon successful completion, though there are some exceptions.

Likewise, functions within a script and the script itself return an exit status. The last command executed in the function or script determines the exit status. Within a script, an exit nnn command may be used to deliver an nnn exit status to the shell (nnn must be a decimal number in the 0 - 255 range).

Note	When a script ends with an exit that has no parameter, the exit status of the script is the exit status of the last command executed in the script (previous to the exit).

#!/bin/bash

COMMAND_1

. . .

# Will exit with status of last command.
COMMAND_LAST

exit

The equivalent of a bare exit is exit $? or even just omitting the exit.

#!/bin/bash

COMMAND_1

. . .

# Will exit with status of last command.
COMMAND_LAST

exit $?

#!/bin/bash

COMMAND1

. . . 

# Will exit with status of last command.
COMMAND_LAST

$? reads the exit status of the last command executed. After a function returns, $? gives the exit status of the last command executed in the function. This is Bash's way of giving functions a "return value." After a script terminates, a $? from the command line gives the exit status of the script, that is, the last command executed in the script, which is, by convention, 0 on success or an integer in the range 1 - 255 on error.

Example exit / exit status

#!/bin/bash

echo hello
echo $?    # Exit status 0 returned because command executed successfully.

lskdf      # Unrecognized command.
echo $?    # Non-zero exit status returned because command failed to execute.

echo

exit 113   # Will return 113 to shell.
           # To verify this, type "echo $?" after script terminates.

#  By convention, an 'exit 0' indicates success,
#+ while a non-zero exit value means an error or anomalous condition.

$? is especially useful for testing the result of a command in a script (see Example 15-33 and Example 15-18).

Note	The !, the logical not qualifier, reverses the outcome of a test or command, and this affects its exit status.

Example Negating a condition using !

true    # The "true" builtin.
echo "exit status of \"true\" = $?"     # 0

! true
echo "exit status of \"! true\" = $?"   # 1
# Note that the "!" needs a space between it and the command.
#    !true   leads to a "command not found" error
#
# The '!' operator prefixing a command invokes the Bash history mechanism.

true
!true
# No error this time, but no negation either.
# It just repeats the previous command (true).

# Thanks, Stphane Chazelas and Kristopher Newsome.

Caution	

Certain exit status codes have reserved meanings and should not be user-specified in a script. 

	12.4 Chapter 7. Tests

		12.4.1. Test Constructs
    * An if/then construct tests whether the exit status of a list of commands is 0 (since 0 means "success" by UNIX convention), and if so, executes one or more commands.
    * There exists a dedicated command called [ (left bracket special character). It is a synonym for test, and a builtin for efficiency reasons. This command considers its arguments as comparison expressions or file tests and returns an exit status corresponding to the result of the comparison (0 for true, 1 for false).
    * With version 2.02, Bash introduced the [[ ... ]] extended test command, which performs comparisons in a manner more familiar to programmers from other languages. Note that [[ is a keyword, not a command.

      Bash sees [[ $a -lt $b ]] as a single element, which returns an exit status.

      The (( ... )) and let ... constructs also return an exit status of 0 if the arithmetic expressions they evaluate expand to a non-zero value. These arithmetic expansion constructs may therefore be used to perform arithmetic comparisons.

      let "1<2" returns 0 (as "1<2" expands to "1")
      (( 0 && 1 )) returns 1 (as "0 && 1" expands to "0")

    * An if can test any command, not just conditions enclosed within brackets.

      if cmp a b &> /dev/null  # Suppress output.
      then echo "Files a and b are identical."
      else echo "Files a and b differ."
      fi

      # The very useful "if-grep" construct:
      # ----------------------------------- 
      if grep -q Bash file
      then echo "File contains at least one occurrence of Bash."
      fi

      word=Linux
      letter_sequence=inu
      if echo "$word" | grep -q "$letter_sequence"
      # The "-q" option to grep suppresses output.
      then
        echo "$letter_sequence found in $word"
      else
        echo "$letter_sequence not found in $word"
      fi


      if COMMAND_WHOSE_EXIT_STATUS_IS_0_UNLESS_ERROR_OCCURRED
      then echo "Command succeeded."
      else echo "Command failed."
      fi

    *

      An if/then construct can contain nested comparisons and tests.

      if echo "Next *if* is part of the comparison for the first *if*."

        if [[ $comparison = "integer" ]]
          then (( a < b ))
        else
          [[ $a < $b ]]
        fi

      then
        echo '$a is less than $b'
      fi

      This detailed "if-test" explanation courtesy of Stphane Chazelas.

Example What is truth?

#!/bin/bash

#  Tip:
#  If you're unsure of how a certain condition would evaluate,
#+ test it in an if-test.

echo

echo "Testing \"0\""
if [ 0 ]      # zero
then
  echo "0 is true."
else
  echo "0 is false."
fi            # 0 is true.

echo

echo "Testing \"1\""
if [ 1 ]      # one
then
  echo "1 is true."
else
  echo "1 is false."
fi            # 1 is true.

echo

echo "Testing \"-1\""
if [ -1 ]     # minus one
then
  echo "-1 is true."
else
  echo "-1 is false."
fi            # -1 is true.

echo

echo "Testing \"NULL\""
if [ ]        # NULL (empty condition)
then
  echo "NULL is true."
else
  echo "NULL is false."
fi            # NULL is false.

echo

echo "Testing \"xyz\""
if [ xyz ]    # string
then
  echo "Random string is true."
else
  echo "Random string is false."
fi            # Random string is true.

echo

echo "Testing \"\$xyz\""
if [ $xyz ]   # Tests if $xyz is null, but...
              # it's only an uninitialized variable.
then
  echo "Uninitialized variable is true."
else
  echo "Uninitialized variable is false."
fi            # Uninitialized variable is false.

echo

echo "Testing \"-n \$xyz\""
if [ -n "$xyz" ]            # More pedantically correct.
then
  echo "Uninitialized variable is true."
else
  echo "Uninitialized variable is false."
fi            # Uninitialized variable is false.

echo


xyz=          # Initialized, but set to null value.

echo "Testing \"-n \$xyz\""
if [ -n "$xyz" ]
then
  echo "Null variable is true."
else
  echo "Null variable is false."
fi            # Null variable is false.


echo


# When is "false" true?

echo "Testing \"false\""
if [ "false" ]              #  It seems that "false" is just a string.
then
  echo "\"false\" is true." #+ and it tests true.
else
  echo "\"false\" is false."
fi            # "false" is true.

echo

echo "Testing \"\$false\""  # Again, uninitialized variable.
if [ "$false" ]
then
  echo "\"\$false\" is true."
else
  echo "\"\$false\" is false."
fi            # "$false" is false.
              # Now, we get the expected result.

#  What would happen if we tested the uninitialized variable "$true"?

echo

exit 0

Exercise. Explain the behavior of Example 7-1, above.

if [ condition-true ]
then
   command 1
   command 2
   ...
else
   # Optional (may be left out if not needed).
   # Adds default code block executing if original condition tests false.
   command 3
   command 4
   ...
fi

Note	

When if and then are on same line in a condition test, a semicolon must terminate the if statement. Both if and then are keywords. Keywords (or commands) begin statements, and before a new statement on the same line begins, the old one must terminate.

if [ -x "$filename" ]; then

Else if and elif

elif

    elif is a contraction for else if. The effect is to nest an inner if/then construct within an outer one.

    if [ condition1 ]
    then
       command1
       command2
       command3
    elif [ condition2 ]
    # Same as else if
    then
       command4
       command5
    else
       default-command
    fi

The if test condition-true construct is the exact equivalent of if [ condition-true ]. As it happens, the left bracket, [ , is a token which invokes the test command. The closing right bracket, ] , in an if/test should not therefore be strictly necessary, however newer versions of Bash require it.

Note	

The test command is a Bash builtin which tests file types and compares strings. Therefore, in a Bash script, test does not call the external /usr/bin/test binary, which is part of the sh-utils package. Likewise, [ does not call /usr/bin/[, which is linked to /usr/bin/test.

bash$ type test
test is a shell builtin
bash$ type '['
[ is a shell builtin
bash$ type '[['
[[ is a shell keyword
bash$ type ']]'
]] is a shell keyword
bash$ type ']'
bash: type: ]: not found
	      

If, for some reason, you wish to use /usr/bin/test in a Bash script, then specify it by full pathname.

Example Equivalence of test, /usr/bin/test, [ ], and /usr/bin/[

#!/bin/bash

echo

if test -z "$1"
then
  echo "No command-line arguments."
else
  echo "First command-line argument is $1."
fi

echo

if /usr/bin/test -z "$1"      # Equivalent to "test" builtin.
#  ^^^^^^^^^^^^^              # Specifying full pathname.
then
  echo "No command-line arguments."
else
  echo "First command-line argument is $1."
fi

echo

if [ -z "$1" ]                # Functionally identical to above code blocks.
#   if [ -z "$1"                should work, but...
#+  Bash responds to a missing close-bracket with an error message.
then
  echo "No command-line arguments."
else
  echo "First command-line argument is $1."
fi

echo


if /usr/bin/[ -z "$1" ]       # Again, functionally identical to above.
# if /usr/bin/[ -z "$1"       # Works, but gives an error message.
#                             # Note:
#                               This has been fixed in Bash, version 3.x.
then
  echo "No command-line arguments."
else
  echo "First command-line argument is $1."
fi

echo

exit 0

The [[ ]] construct is the more versatile Bash version of [ ]. This is the extended test command, adopted from ksh88.

Note	No filename expansion or word splitting takes place between [[ and ]], but there is parameter expansion and command substitution.

file=/etc/passwd

if [[ -e $file ]]
then
  echo "Password file exists."
fi

Tip	Using the [[ ... ]] test construct, rather than [ ... ] can prevent many logic errors in scripts. For example, the &&, ||, <, and > operators work within a [[ ]] test, despite giving an error within a [ ] construct.

Note	Following an if, neither the test command nor the test brackets ( [ ] or [[ ]] ) are strictly necessary.

dir=/home/bozo

if cd "$dir" 2>/dev/null; then   # "2>/dev/null" hides error message.
  echo "Now in $dir."
else
  echo "Can't change to $dir."
fi

The "if COMMAND" construct returns the exit status of COMMAND.

Similarly, a condition within test brackets may stand alone without an if, when used in combination with a list construct.

var1=20
var2=22
[ "$var1" -ne "$var2" ] && echo "$var1 is not equal to $var2"

home=/home/bozo
[ -d "$home" ] || echo "$home directory does not exist."

The (( )) construct expands and evaluates an arithmetic expression. If the expression evaluates as zero, it returns an exit status of 1, or "false". A non-zero expression returns an exit status of 0, or "true". This is in marked contrast to using the test and [ ] constructs previously discussed.

Example Arithmetic Tests using (( ))

#!/bin/bash
# Arithmetic tests.

# The (( ... )) construct evaluates and tests numerical expressions.
# Exit status opposite from [ ... ] construct!

(( 0 ))
echo "Exit status of \"(( 0 ))\" is $?."         # 1

(( 1 ))
echo "Exit status of \"(( 1 ))\" is $?."         # 0

(( 5 > 4 ))                                      # true
echo "Exit status of \"(( 5 > 4 ))\" is $?."     # 0

(( 5 > 9 ))                                      # false
echo "Exit status of \"(( 5 > 9 ))\" is $?."     # 1

(( 5 - 5 ))                                      # 0
echo "Exit status of \"(( 5 - 5 ))\" is $?."     # 1

(( 5 / 4 ))                                      # Division o.k.
echo "Exit status of \"(( 5 / 4 ))\" is $?."     # 0

(( 1 / 2 ))                                      # Division result < 1.
echo "Exit status of \"(( 1 / 2 ))\" is $?."     # Rounded off to 0.
                                                 # 1

(( 1 / 0 )) 2>/dev/null                          # Illegal division by 0.
#           ^^^^^^^^^^^
echo "Exit status of \"(( 1 / 0 ))\" is $?."     # 1

# What effect does the "2>/dev/null" have?
# What would happen if it were removed?
# Try removing it, then rerunning the script.

exit 0

		12.4.2. File test operators
Returns true if...

-e file exists
-a file exists This is identical in effect to -e. It has been "deprecated," [1] and its use is discouraged.
-f file is a regular file (not a directory or device file)
-s file is not zero size
-d file is a directory
-b file is a block device (floppy, cdrom, etc.) 
-c file is a character device (keyboard, modem, sound card, etc.)
-p file is a pipe
-h file is a symbolic link
-L file is a symbolic link
-S file is a socket
-t file (descriptor) is associated with a terminal device This test option may be used to check whether the stdin ([ -t 0 ]) or stdout ([ -t 1 ]) in a given script is a terminal.
-r file has read permission (for the user running the test)
-w file has write permission (for the user running the test)
-x file has execute permission (for the user running the test)
-g set-group-id (sgid) flag set on file or directory
If a directory has the sgid flag set, then a file created within that directory belongs to the group that owns the directory, not necessarily to the group of the user who created the file. This may be useful for a directory shared by a workgroup.
-u set-user-id (suid) flag set on file

    A binary owned by root with set-user-id flag set runs with root privileges, even when an ordinary user invokes it. [2] This is useful for executables (such as pppd and cdrecord) that need to access system hardware. Lacking the suid flag, these binaries could not be invoked by a non-root user.

    	      -rwsr-xr-t    1 root       178236 Oct  2  2000 /usr/sbin/pppd
    	      

    A file with the suid flag set shows an s in its permissions.

-k sticky bit set
Commonly known as the sticky bit, the save-text-mode flag is a special type of file permission. If a file has this flag set, that file will be kept in cache memory, for quicker access. [3] If set on a directory, it restricts write permission. Setting the sticky bit adds a t to the permissions on the file or directory listing.

    	      drwxrwxrwt    7 root         1024 May 19 21:26 tmp/
    	      

    If a user does not own a directory that has the sticky bit set, but has write permission in that directory, she can only delete those files that she owns in it. This keeps users from inadvertently overwriting or deleting each other's files in a publicly accessible directory, such as /tmp. (The owner of the directory or root can, of course, delete or rename files there.)
-O you are owner of file
-G group-id of file same as yours
-N file modified since it was last read
f1 -nt f2 file f1 is newer than f2
f1 -ot f2 file f1 is older than f2
f1 -ef f2 files f1 and f2 are hard links to the same file
!  "not" -- reverses the sense of the tests above (returns true if condition absent).

Example Testing for broken links

#!/bin/bash
# broken-link.sh
# Written by Lee bigelow <ligelowbee@yahoo.com>
# Used in ABS Guide with permission.

#  A pure shell script to find dead symlinks and output them quoted
#+ so they can be fed to xargs and dealt with :)
#+ eg. sh broken-link.sh /somedir /someotherdir|xargs rm
#
#  This, however, is a better method:
#
#  find "somedir" -type l -print0|\
#  xargs -r0 file|\
#  grep "broken symbolic"|
#  sed -e 's/^\|: *broken symbolic.*$/"/g'
#
#+ but that wouldn't be pure Bash, now would it.
#  Caution: beware the /proc file system and any circular links!
################################################################


#  If no args are passed to the script set directories-to-search 
#+ to current directory.  Otherwise set the directories-to-search 
#+ to the args passed.
######################

[ $# -eq 0 ] && directorys=`pwd` || directorys=$@


#  Setup the function linkchk to check the directory it is passed 
#+ for files that are links and don't exist, then print them quoted.
#  If one of the elements in the directory is a subdirectory then 
#+ send that subdirectory to the linkcheck function.
##########

linkchk () {
    for element in $1/*; do
#*/
      [ -h "$element" -a ! -e "$element" ] && echo \"$element\"
      [ -d "$element" ] && linkchk $element
    # Of course, '-h' tests for symbolic link, '-d' for directory.
    done
}

#  Send each arg that was passed to the script to the linkchk() function
#+ if it is a valid directoy.  If not, then print the error message
#+ and usage info.
##################
for directory in $directorys; do
    if [ -d $directory ]
	then linkchk $directory
	else 
	    echo "$directory is not a directory"
	    echo "Usage: $0 dir1 dir2 ..."
    fi
done

exit $?




		12.4.3. Other Comparison Operators
A binary comparison operator compares two variables or quantities. Note that integer and string comparison use a different set of operators.

			12.4.3.1 integer comparison

-eq is equal to
if [ "$a" -eq "$b" ]

-ne is not equal to
if [ "$a" -ne "$b" ]

-gt is greater than
if [ "$a" -gt "$b" ]

-ge is greater than or equal to
if [ "$a" -ge "$b" ]

-lt is less than
if [ "$a" -lt "$b" ]

-le is less than or equal to
if [ "$a" -le "$b" ]

< is less than (within double parentheses)
(("$a" < "$b"))

<= is less than or equal to (within double parentheses)
(("$a" <= "$b"))

> is greater than (within double parentheses)
(("$a" > "$b"))

>= is greater than or equal to (within double parentheses)
(("$a" >= "$b"))


			12.4.3.2 string comparison

= is equal to
if [ "$a" = "$b" ]

== is equal to
if [ "$a" == "$b" ]

This is a synonym for =.

    Note	
    The == comparison operator behaves differently within a double-brackets test than within single brackets.

    [[ $a == z* ]]    # True if $a starts with an "z" (pattern matching).
    [[ $a == "z*" ]]  # True if $a is equal to z* (literal matching).

    [ $a == z* ]      # File globbing and word splitting take place.
    [ "$a" == "z*" ]  # True if $a is equal to z* (literal matching).

    # Thanks, Stphane Chazelas

!= is not equal to
if [ "$a" != "$b" ]
This operator uses pattern matching within a [[ ... ]] construct.

< is less than, in ASCII alphabetical order
if [[ "$a" < "$b" ]]
if [ "$a" \< "$b" ]
Note that the "<" needs to be escaped within a [ ] construct.

> is greater than, in ASCII alphabetical order
if [[ "$a" > "$b" ]]
if [ "$a" \> "$b" ]
Note that the ">" needs to be escaped within a [ ] construct.

-n string is not "null."
Caution	The -n test absolutely requires that the string be quoted within the test brackets. Using an unquoted string with ! -z, or even just the unquoted string alone within test brackets  normally works, however, this is an unsafe practice. Always quote a tested string. [1] 

-z string is "null, " that is, has zero length

Example Arithmetic and string comparisons

#!/bin/bash

a=4
b=5

#  Here "a" and "b" can be treated either as integers or strings.
#  There is some blurring between the arithmetic and string comparisons,
#+ since Bash variables are not strongly typed.

#  Bash permits integer operations and comparisons on variables
#+ whose value consists of all-integer characters.
#  Caution advised, however.

echo

if [ "$a" -ne "$b" ]
then
  echo "$a is not equal to $b"
  echo "(arithmetic comparison)"
fi

echo

if [ "$a" != "$b" ]
then
  echo "$a is not equal to $b."
  echo "(string comparison)"
  #     "4"  != "5"
  # ASCII 52 != ASCII 53
fi

# In this particular instance, both "-ne" and "!=" work.

echo

exit 0

Example 7-6. Testing whether a string is null

#!/bin/bash
#  str-test.sh: Testing null strings and unquoted strings,
#+ but not strings and sealing wax, not to mention cabbages and kings . . .

# Using   if [ ... ]


# If a string has not been initialized, it has no defined value.
# This state is called "null" (not the same as zero).

if [ -n $string1 ]    # $string1 has not been declared or initialized.
then
  echo "String \"string1\" is not null."
else  
  echo "String \"string1\" is null."
fi  
# Wrong result.
# Shows $string1 as not null, although it was not initialized.


echo


# Lets try it again.

if [ -n "$string1" ]  # This time, $string1 is quoted.
then
  echo "String \"string1\" is not null."
else  
  echo "String \"string1\" is null."
fi                    # Quote strings within test brackets!


echo


if [ $string1 ]       # This time, $string1 stands naked.
then
  echo "String \"string1\" is not null."
else  
  echo "String \"string1\" is null."
fi  
# This works fine.
# The [ ] test operator alone detects whether the string is null.
# However it is good practice to quote it ("$string1").
#
# As Stephane Chazelas points out,
#    if [ $string1 ]    has one argument, "]"
#    if [ "$string1" ]  has two arguments, the empty "$string1" and "]" 



echo



string1=initialized

if [ $string1 ]       # Again, $string1 stands naked.
then
  echo "String \"string1\" is not null."
else  
  echo "String \"string1\" is null."
fi  
# Again, gives correct result.
# Still, it is better to quote it ("$string1"), because . . .


string1="a = b"

if [ $string1 ]       # Again, $string1 stands naked.
then
  echo "String \"string1\" is not null."
else  
  echo "String \"string1\" is null."
fi  
# Not quoting "$string1" now gives wrong result!

exit 0
# Thank you, also, Florian Wisser, for the "heads-up".

Example zmore

#!/bin/bash
# zmore

#View gzipped files with 'more'

NOARGS=65
NOTFOUND=66
NOTGZIP=67

if [ $# -eq 0 ] # same effect as:  if [ -z "$1" ]
# $1 can exist, but be empty:  zmore "" arg2 arg3
then
  echo "Usage: `basename $0` filename" >&2
  # Error message to stderr.
  exit $NOARGS
  # Returns 65 as exit status of script (error code).
fi  

filename=$1

if [ ! -f "$filename" ]   # Quoting $filename allows for possible spaces.
then
  echo "File $filename not found!" >&2
  # Error message to stderr.
  exit $NOTFOUND
fi  

if [ ${filename##*.} != "gz" ]
# Using bracket in variable substitution.
then
  echo "File $1 is not a gzipped file!"
  exit $NOTGZIP
fi  

zcat $1 | more

# Uses the filter 'more.'
# May substitute 'less', if desired.


exit $?   # Script returns exit status of pipe.
# Actually "exit $?" is unnecessary, as the script will, in any case,
# return the exit status of the last command executed.

compound comparison

-a logical and
exp1 -a exp2 returns true if both exp1 and exp2 are true.

-o logical or
exp1 -o exp2 returns true if either exp1 or exp2 are true.


These are similar to the Bash comparison operators && and ||, used within double brackets.

[[ condition1 && condition2 ]]

The -o and -a operators work with the test command or occur within single test brackets.

if [ "$exp1" -a "$exp2" ]

		12.4.4. Nested if/then Condition Tests
Condition tests using the if/then  construct may be nested. The net result is equivalent to using the && compound comparison operator above.

if [ condition1 ]
then
  then
    do-something  # But only if both "condition1" and "condition2" valid.
  fi  
fi


	12.5 Chapter 8. Operations and Related Topics

		12.5.1 Operators

			12.5.1.1 Assignment

variable assignment Initializing or changing the value of a variable
= All-purpose assignment operator, which works for both arithmetic and string assignments.

    var=27
    category=minerals  # No spaces allowed after the "=".

    Caution	Do not confuse the "=" assignment operator with the = test operator.

    #   =  as a test operator

    if [ "$string1" = "$string2" ]
    then
       command
    fi

    #  if [ "X$string1" = "X$string2" ] is safer,
    #+ to prevent an error message should one of the variables be empty.
    #  (The prepended "X" characters cancel out.)

			12.5.1.2 Arithmetic operators

+ plus
- minus
* multiplication
/ division
** exponentiation

    # Bash, version 2.02, introduced the "**" exponentiation operator.

    let "z=5**3"
    echo "z = $z"   # z = 125

% modulo, or mod (returns the remainder of an integer division operation)

    bash$ expr 5 % 3
    2
    	      
5/3 = 1 with remainder 2

    This operator finds use in, among other things, generating numbers within a specific range and formatting program output. It can even be used to generate prime numbers. Modulo turns up surprisingly often in various numerical recipes.

    Example Greatest common divisor

    #!/bin/bash
    # gcd.sh: greatest common divisor
    #         Uses Euclid's algorithm

    #  The "greatest common divisor" (gcd) of two integers
    #+ is the largest integer that will divide both, leaving no remainder.

    #  Euclid's algorithm uses successive division.
    #  In each pass,
    #+ dividend <---  divisor
    #+ divisor  <---  remainder
    #+ until remainder = 0.
    #+ The gcd = dividend, on the final pass.
    #
    #  For an excellent discussion of Euclid's algorithm, see
    #+ Jim Loy's site, http://www.jimloy.com/number/euclids.htm.


    # ------------------------------------------------------
    # Argument check
    ARGS=2
    E_BADARGS=65

    if [ $# -ne "$ARGS" ]
    then
      echo "Usage: `basename $0` first-number second-number"
      exit $E_BADARGS
    fi
    # ------------------------------------------------------


    gcd ()
    {

      dividend=$1             #  Arbitrary assignment.
      divisor=$2              #! It doesn't matter which of the two is larger.
                              #  Why not?

      remainder=1             #  If uninitialized variable used in loop,
                              #+ it results in an error message
                              #+ on the first pass through loop.

      until [ "$remainder" -eq 0 ]
      do
        let "remainder = $dividend % $divisor"
        dividend=$divisor     # Now repeat with 2 smallest numbers.
        divisor=$remainder
      done                    # Euclid's algorithm

    }                         # Last $dividend is the gcd.


    gcd $1 $2

    echo; echo "GCD of $1 and $2 = $dividend"; echo


    # Exercise :
    # --------
    #  Check command-line arguments to make sure they are integers,
    #+ and exit the script with an appropriate error message if not.

    exit 0

+= "plus-equal" (increment variable by a constant)
let "var += 5" results in var being incremented by 5.
-= "minus-equal" (decrement variable by a constant)
*= "times-equal" (multiply variable by a constant)
let "var *= 4" results in var being multiplied by 4.
/= "slash-equal" (divide variable by a constant)
%= "mod-equal" (remainder of dividing variable by a constant)

    Arithmetic operators often occur in an expr or let expression.

    Example Using Arithmetic Operations

    #!/bin/bash
    # Counting to 11 in 10 different ways.

    n=1; echo -n "$n "

    let "n = $n + 1"   # let "n = n + 1"  also works.
    echo -n "$n "


    : $((n = $n + 1))
    #  ":" necessary because otherwise Bash attempts
    #+ to interpret "$((n = $n + 1))" as a command.
    echo -n "$n "

    (( n = n + 1 ))
    #  A simpler alternative to the method above.
    #  Thanks, David Lombard, for pointing this out.
    echo -n "$n "

    n=$(($n + 1))
    echo -n "$n "

    : $[ n = $n + 1 ]
    #  ":" necessary because otherwise Bash attempts
    #+ to interpret "$[ n = $n + 1 ]" as a command.
    #  Works even if "n" was initialized as a string.
    echo -n "$n "

    n=$[ $n + 1 ]
    #  Works even if "n" was initialized as a string.
    #* Avoid this type of construct, since it is obsolete and nonportable.
    #  Thanks, Stephane Chazelas.
    echo -n "$n "

    # Now for C-style increment operators.
    # Thanks, Frank Wang, for pointing this out.

    let "n++"          # let "++n"  also works.
    echo -n "$n "

    (( n++ ))          # (( ++n )  also works.
    echo -n "$n "

    : $(( n++ ))       # : $(( ++n )) also works.
    echo -n "$n "

    : $[ n++ ]         # : $[ ++n ]] also works
    echo -n "$n "

    echo

    exit 0

Note	
Integer variables in Bash are actually signed long (32-bit) integers, in the range of -2147483648 to 2147483647. An operation that takes a variable outside these limits will give an erroneous result.

a=2147483646
echo "a = $a"      # a = 2147483646
let "a+=1"         # Increment "a".
echo "a = $a"      # a = 2147483647
let "a+=1"         # increment "a" again, past the limit.
echo "a = $a"      # a = -2147483648
                   #      ERROR (out of range)

As of version 2.05b, Bash supports 64-bit integers.

Caution	Bash does not understand floating point arithmetic. It treats numbers containing a decimal point as strings.

a=1.5

let "b = $a + 1.3"  # Error.
# t2.sh: let: b = 1.5 + 1.3: syntax error in expression
#                            (error token is ".5 + 1.3")

echo "b = $b"       # b=1

Use bc in scripts that that need floating point calculations or math library functions.

			12.5.1.3 Bitwise operators. 
			The bitwise operators seldom make an appearance in shell scripts. Their chief use seems to be manipulating and testing values read from ports or sockets. "Bit flipping" is more relevant to compiled languages, such as C and C++, which provide direct access to system hardware.

bitwise operators

<< bitwise left shift (multiplies by 2 for each shift position)
<<= "left-shift-equal"

    let "var <<= 2" results in var left-shifted 2 bits (multiplied by 4)
>> bitwise right shift (divides by 2 for each shift position)
>>= "right-shift-equal" (inverse of <<=)
& bitwise and
&= "bitwise and-equal"
| bitwise OR
|= "bitwise OR-equal"
~ bitwise negate
!  bitwise NOT
^ bitwise XOR
^= "bitwise XOR-equal"

			12.5.1.4 Logical operators

&& and (logical)

    if [ $condition1 ] && [ $condition2 ]
    # Same as:  if [ $condition1 -a $condition2 ]
    # Returns true if both condition1 and condition2 hold true...

    if [[ $condition1 && $condition2 ]]    # Also works.
    # Note that && operator not permitted within [ ... ] construct.

    Note	

    && may also, depending on context, be used in an and list to concatenate commands.
|| or (logical)

    if [ $condition1 ] || [ $condition2 ]
    # Same as:  if [ $condition1 -o $condition2 ]
    # Returns true if either condition1 or condition2 holds true...

    if [[ $condition1 || $condition2 ]]    # Also works.
    # Note that || operator not permitted within [ ... ] construct.

    Note	

    Bash tests the exit status of each statement linked with a logical operator.

    Example Compound Condition Tests Using && and ||

    #!/bin/bash

    a=24
    b=47

    if [ "$a" -eq 24 ] && [ "$b" -eq 47 ]
    then
      echo "Test #1 succeeds."
    else
      echo "Test #1 fails."
    fi

    # ERROR:   if [ "$a" -eq 24 && "$b" -eq 47 ]
    #+         attempts to execute  ' [ "$a" -eq 24 '
    #+         and fails to finding matching ']'.
    #
    #  Note:  if [[ $a -eq 24 && $b -eq 24 ]]  works.
    #  The double-bracket if-test is more flexible
    #+ than the single-bracket version.       
    #    (The "&&" has a different meaning in line 17 than in line 6.)
    #    Thanks, Stephane Chazelas, for pointing this out.


    if [ "$a" -eq 98 ] || [ "$b" -eq 47 ]
    then
      echo "Test #2 succeeds."
    else
      echo "Test #2 fails."
    fi


    #  The -a and -o options provide
    #+ an alternative compound condition test.
    #  Thanks to Patrick Callahan for pointing this out.


    if [ "$a" -eq 24 -a "$b" -eq 47 ]
    then
      echo "Test #3 succeeds."
    else
      echo "Test #3 fails."
    fi


    if [ "$a" -eq 98 -o "$b" -eq 47 ]
    then
      echo "Test #4 succeeds."
    else
      echo "Test #4 fails."
    fi


    a=rhino
    b=crocodile
    if [ "$a" = rhino ] && [ "$b" = crocodile ]
    then
      echo "Test #5 succeeds."
    else
      echo "Test #5 fails."
    fi

    exit 0

    The && and || operators also find use in an arithmetic context.

    bash$ echo $(( 1 && 2 )) $((3 && 0)) $((4 || 0)) $((0 || 0))
    1 0 1 0
    	      

miscellaneous operators

, comma operator

    The comma operator chains together two or more arithmetic operations. All the operations are evaluated (with possible side effects), but only the last operation is returned.

    let "t1 = ((5 + 3, 7 - 1, 15 - 4))"
    echo "t1 = $t1"               # t1 = 11

    let "t2 = ((a = 9, 15 / 3))"  # Set "a" and calculate "t2".
    echo "t2 = $t2    a = $a"     # t2 = 5    a = 9

    The comma operator finds use mainly in for loops. 

		12.5.2 Numerical constants
A shell script interprets a number as decimal (base 10), unless that number has a special prefix or notation. A number preceded by a 0 is octal  (base 8). A number preceded by 0x  is hexadecimal (base 16). A number with an embedded # evaluates as BASE#NUMBER (with range and notational restrictions).

Example Representation of numerical constants

#!/bin/bash
# numbers.sh: Representation of numbers in different bases.

# Decimal: the default
let "dec = 32"
echo "decimal number = $dec"             # 32
# Nothing out of the ordinary here.


# Octal: numbers preceded by '0' (zero)
let "oct = 032"
echo "octal number = $oct"               # 26
# Expresses result in decimal.
# --------- ------ -- -------


# Hexadecimal: numbers preceded by '0x' or '0X'
let "hex = 0x32"
echo "hexadecimal number = $hex"         # 50

echo $((0x9abc))                         # 39612
#     ^^      ^^   double-parentheses arithmetic expansion/evaluation
# Expresses result in decimal.



# Other bases: BASE#NUMBER
# BASE between 2 and 64.
# NUMBER must use symbols within the BASE range, see below.


let "bin = 2#111100111001101"
echo "binary number = $bin"              # 31181

let "b32 = 32#77"
echo "base-32 number = $b32"             # 231

let "b64 = 64#@_"
echo "base-64 number = $b64"             # 4031
# This notation only works for a limited range (2 - 64) of ASCII characters.
# 10 digits + 26 lowercase characters + 26 uppercase characters + @ + _


echo

echo $((36#zz)) $((2#10101010)) $((16#AF16)) $((53#1aA))
                                         # 1295 170 44822 3375


#  Important note:
#  --------------
#  Using a digit out of range of the specified base notation
#+ gives an error message.

let "bad_oct = 081"
# (Partial) error message output:
#  bad_oct = 081: value too great for base (error token is "081")
#              Octal numbers use only digits in the range 0 - 7.

exit 0       # Thanks, Rich Bartell and Stephane Chazelas, for clarification.

	12.6 Part 3. Beyond the Basics. Chapter 9. Variables Revisited 

		12.6.1 Internal Variables, builtin variables
		Those are variables defining bash behavior.

			12.6.1.1 Bash internals
$BASH the path to the Bash binary itself

    bash$ echo $BASH
    /bin/bash

$BASH_ENV an environmental variable pointing to a Bash startup file to be read when a script is invoked
$BASH_SUBSHELL a variable indicating the subshell level. This is a new addition to Bash, version 3.
$BASH_VERSINFO[n] a 6-element array containing version information about the installed release of Bash. This is similar to $BASH_VERSION, below, but a bit more detailed.

    # Bash version info:

    for n in 0 1 2 3 4 5
    do
      echo "BASH_VERSINFO[$n] = ${BASH_VERSINFO[$n]}"
    done  

    # BASH_VERSINFO[0] = 3                      # Major version no.
    # BASH_VERSINFO[1] = 00                     # Minor version no.
    # BASH_VERSINFO[2] = 14                     # Patch level.
    # BASH_VERSINFO[3] = 1                      # Build version.
    # BASH_VERSINFO[4] = release                # Release status.
    # BASH_VERSINFO[5] = i386-redhat-linux-gnu  # Architecture
                                                # (same as $MACHTYPE).

$BASH_VERSION the version of Bash installed on the system

    bash$ echo $BASH_VERSION
    |3.00.14(1)-release
    	      

    tcsh% echo $BASH_VERSION
    BASH_VERSION: Undefined variable.
    	      

    Note, Checking $BASH_VERSION is a good method of determining which shell is running. $SHELL does not necessarily give the correct answer.

$DIRSTACK the top value in the directory stack (affected by pushd and popd)

    This builtin variable corresponds to the dirs command, however dirs shows the entire contents of the directory stack.

$EDITOR the default editor invoked by a script, usually vi or emacs.
$EUID "effective" user ID number

    Identification number of whatever identity the current user has assumed, perhaps by means of su.

    Caution	The $EUID is not necessarily the same as the $UID.

$FUNCNAME name of the current function

    xyz23 ()
    {
      echo "$FUNCNAME now executing."  # xyz23 now executing.
    }

    xyz23

    echo "FUNCNAME = $FUNCNAME"        # FUNCNAME =
                                       # Null value outside a function.

$GLOBIGNORE A list of filename patterns to be excluded from matching in globbing.
$GROUPS groups current user belongs to

    This is a listing (array) of the group id numbers for current user, as recorded in /etc/passwd and /etc/group.

    root# echo $GROUPS
    0


    root# echo ${GROUPS[1]}
    1


    root# echo ${GROUPS[5]}
    6
    	      

$HOME home directory of the user, usually /home/username 

$HOSTNAME The hostname command assigns the system host name at bootup in an init script. However, the gethostname() function sets the Bash internal variable $HOSTNAME. 

$HOSTTYPE

    host type

    Like $MACHTYPE, identifies the system hardware.

    bash$ echo $HOSTTYPE
    i686

			12.6.1.2 Bash internals, IFS
$IFS

    internal field separator

    This variable determines how Bash recognizes fields, or word boundaries, when it interprets character strings.

    $IFS defaults to whitespace (space, tab, and newline), but may be changed, for example, to parse a comma-separated data file. Note that $* uses the first character held in $IFS. See Example 5-1.

    bash$ echo "$IFS"

    (With $IFS set to default, a blank line displays.)
    	      


    bash$ echo "$IFS" | cat -vte
     ^I$
     $
    (Show whitespace -- here space, ^I [horizontal tab],
      and newline -- and display "$" at end-of-line.)



    bash$ bash -c 'set w x y z; IFS=":-;"; echo "$*"'
    w:x:y:z
    (Read commands from string and assign any arguments to pos params.)
    	      

    Caution	

    $IFS does not handle whitespace the same as it does other characters.

    Example 9-1. $IFS and whitespace

    #!/bin/bash
    # $IFS treats whitespace differently than other characters.

    output_args_one_per_line()
    {
      for arg
      do echo "[$arg]"
      done
    }

    echo; echo "IFS=\" \""
    echo "-------"

    IFS=" "
    var=" a  b c   "
    output_args_one_per_line $var  # output_args_one_per_line `echo " a  b c   "`
    #
    # [a]
    # [b]
    # [c]


    echo; echo "IFS=:"
    echo "-----"

    IFS=:
    var=":a::b:c:::"               # Same as above, but substitute ":" for " ".
    output_args_one_per_line $var
    #
    # []
    # [a]
    # []
    # [b]
    # [c]
    # []
    # []
    # []

    # The same thing happens with the "FS" field separator in awk.

    # Thank you, Stephane Chazelas.

    echo

    exit 0

    (Many thanks, Stphane Chazelas, for clarification and examples.)

    See also Example 15-39, Example 10-7, and Example 18-14 for instructive examples of using $IFS.

				12.6.1.2.1 My example, arrays, elements, containing space
__log_selector()
{

# Set IFS to \n so that array elements containing space would not be considered as multiple elements
        IFS='
'
        LogFiles=( 
                        "/opt/CSCOacs/logs/acsRuntime.log"
                        "/opt/CSCOacs/logs/ACSADAgent.log"
                        "/opt/CSCOacs/logs/ACSManagement.log"   
                        "/opt/CSCOacs/logs/localStore/acsLocalStore.log"   
                        "/opt/CSCOacs/mgmt/apache-tomcat-6.0.18/logs/catalina.out"
                        )
        Operation=( 
                        "tail -f" 
                        "vi" 
                        "\\vi" 
                        "tail " 
                        )

        i=0
        j=0
        k=0
        echo "Choose operation+file"
        for file in ${LogFiles[@]} 
        do 
                for op in ${Operation[@]} 
                do
#printf "[%03d] %s%s\n" (($i+$j)) $op $view 
                        (( k = i + j ))
                        printf "[%03d] %s %s\n" $k $op $file 
                        (( j+=1 ))
                done
                (( i+=1 ))
        done
        echo -n "Please select operation and log file:"
        read

        echo $REPLY 
        let "i =  $REPLY / ${#LogFiles[@]} "
        echo $i
        let "j =  $REPLY % ${#LogFiles[@]} "
        echo $j
        printf "Operation: %s %s\n" ${Operation[$j]} ${LogFiles[$i]} 
        eval  "sudo  ${Operation[$j]} ${LogFiles[$i]} "
}


				12.6.1.2.2

			12.6.1.3 more bash internals
$IGNOREEOF ignore EOF: how many end-of-files (control-D) the shell will ignore before logging out.
$LC_COLLATE Often set in the .bashrc or /etc/profile files, this variable controls collation order in filename expansion and pattern matching. If mishandled, LC_COLLATE can cause unexpected results in filename globbing.

    Note	As of version 2.05 of Bash, filename globbing no longer distinguishes between lowercase and uppercase letters in a character range between brackets. For example, ls [A-M]* would match both File1.txt and file1.txt. To revert to the customary behavior of bracket matching, set LC_COLLATE to C by an export LC_COLLATE=C in /etc/profile and/or ~/.bashrc.
$LC_CTYPE This internal variable controls character interpretation in globbing and pattern matching.
$LINENO This variable is the line number of the shell script in which this variable appears. It has significance only within the script in which it appears, and is chiefly useful for debugging purposes.

    # *** BEGIN DEBUG BLOCK ***
    last_cmd_arg=$_  # Save it.

    echo "At line number $LINENO, variable \"v1\" = $v1"
    echo "Last command argument processed = $last_cmd_arg"
    # *** END DEBUG BLOCK ***

$MACHTYPE machine type

    Identifies the system hardware.

    bash$ echo $MACHTYPE
    i686

$OLDPWD old working directory ("OLD-print-working-directory", previous directory you were in)
$OSTYPE operating system type

    bash$ echo $OSTYPE
    linux

$PATH path to binaries, usually /usr/bin/, /usr/X11R6/bin/, /usr/local/bin, etc.

    When given a command, the shell automatically does a hash table search on the directories listed in the path for the executable. The path is stored in the environmental variable, $PATH, a list of directories, separated by colons. Normally, the system stores the $PATH definition in /etc/profile and/or ~/.bashrc (see Appendix G).

    bash$ echo $PATH
    /bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin:/sbin:/usr/sbin

    PATH=${PATH}:/opt/bin appends the /opt/bin directory to the current path. In a script, it may be expedient to temporarily add a directory to the path in this way. When the script exits, this restores the original $PATH (a child process, such as a script, may not change the environment of the parent process, the shell).

    Note	The current "working directory", ./, is usually omitted from the $PATH as a security measure.
$PIPESTATUS Array variable holding exit status(es) of last executed foreground pipe. Interestingly enough, this does not necessarily give the same result as the exit status of the last executed command.

    bash$ echo $PIPESTATUS
    0

    bash$ ls -al | bogus_command
    bash: bogus_command: command not found
    bash$ echo $PIPESTATUS
    141

    bash$ ls -al | bogus_command
    bash: bogus_command: command not found
    bash$ echo $?
    127
    	      

    The members of the $PIPESTATUS array hold the exit status of each respective command executed in a pipe. $PIPESTATUS[0] holds the exit status of the first command in the pipe, $PIPESTATUS[1] the exit status of the second command, and so on.

    Caution	The $PIPESTATUS variable may contain an erroneous 0 value in a login shell (in releases prior to 3.0 of Bash).

    tcsh% bash

    bash$ who | grep nobody | sort
    bash$ echo ${PIPESTATUS[*]}
    0
    	      

    The above lines contained in a script would produce the expected 0 1 0 output.

    Thank you, Wayne Pollock for pointing this out and supplying the above example.

    Note	

    The $PIPESTATUS variable gives unexpected results in some contexts.

    bash$ echo $BASH_VERSION
    |3.00.14(1)-release

    bash$ $ ls | bogus_command | wc
    bash: bogus_command: command not found
     0       0       0

    bash$ echo ${PIPESTATUS[@]}
    141 127 0
    	      

    Chet Ramey attributes the above output to the behavior of ls. If ls writes to a pipe whose output is not read, then SIGPIPE kills it, and its exit status is 141. Otherwise its exit status is 0, as expected. This likewise is the case for tr.

    Note	$PIPESTATUS is a "volatile" variable. It needs to be captured immediately after the pipe in question, before any other command intervenes.

    bash$ $ ls | bogus_command | wc
    bash: bogus_command: command not found
     0       0       0

    bash$ echo ${PIPESTATUS[@]}
    0 127 0

    bash$ echo ${PIPESTATUS[@]}
    0
    	      

    Note	The pipefail option may be useful in cases where $PIPESTATUS does not give the desired information.
$PPID The $PPID of a process is the process ID (pid) of its parent process. [1] 
    Compare this with the pidof command.
$PROMPT_COMMAND A variable holding a command to be executed just before the primary prompt, $PS1 is to be displayed.
$PS1 This is the main prompt, seen at the command line.
$PS2 The secondary prompt, seen when additional input is expected. It displays as ">".
$PS3 The tertiary prompt, displayed in a select loop (see Example 10-29).
$PS4 The quartenary prompt, shown at the beginning of each line of output when invoking a script with the -x option. It displays as "+".
$PWD working directory (directory you are in at the time)

    This is the analog to the pwd builtin command.

    #!/bin/bash

    E_WRONG_DIRECTORY=73

    clear # Clear screen.

    TargetDirectory=/home/bozo/projects/GreatAmericanNovel

    cd $TargetDirectory
    echo "Deleting stale files in $TargetDirectory."

    if [ "$PWD" != "$TargetDirectory" ]
    then    # Keep from wiping out wrong directory by accident.
      echo "Wrong directory!"
      echo "In $PWD, rather than $TargetDirectory!"
      echo "Bailing out!"
      exit $E_WRONG_DIRECTORY
    fi  

    rm -rf *
    rm .[A-Za-z0-9]*    # Delete dotfiles.
    # rm -f .[^.]* ..?*   to remove filenames beginning with multiple dots.
    # (shopt -s dotglob; rm -f *)   will also work.
    # Thanks, S.C. for pointing this out.

    # Filenames may contain all characters in the 0 - 255 range, except "/".
    # Deleting files beginning with weird characters is left as an exercise.

    # Various other operations here, as necessary.

    echo
    echo "Done."
    echo "Old files deleted in $TargetDirectory."
    echo


    exit 0

			12.6.1.4 Reading input
$REPLY The default value when a variable is not supplied to read. Also applicable to select menus, but only supplies the item number of the variable chosen, not the value of the variable itself.

    #!/bin/bash
    # reply.sh

    # REPLY is the default value for a 'read' command.

    echo
    echo -n "What is your favorite vegetable? "
    read

    echo "Your favorite vegetable is $REPLY."
    #  REPLY holds the value of last "read" if and only if
    #+ no variable supplied.

    echo
    echo -n "What is your favorite fruit? "
    read fruit
    echo "Your favorite fruit is $fruit."
    echo "but..."
    echo "Value of \$REPLY is still $REPLY."
    #  $REPLY is still set to its previous value because
    #+ the variable $fruit absorbed the new "read" value.

    echo

    exit 0

			12.6.1.5 Timing
$SECONDS The number of seconds the script has been running.

    #!/bin/bash

    TIME_LIMIT=10
    INTERVAL=1

    echo
    echo "Hit Control-C to exit before $TIME_LIMIT seconds."
    echo

    while [ "$SECONDS" -le "$TIME_LIMIT" ]
    do
      if [ "$SECONDS" -eq 1 ]
      then
        units=second
      else  
        units=seconds
      fi

      echo "This script has been running $SECONDS $units."
      #  On a slow or overburdened machine, the script may skip a count
      #+ every once in a while.
      sleep $INTERVAL
    done

    echo -e "\a"  # Beep!

    exit 0

$SHELLOPTS the list of enabled shell options, a readonly variable

    bash$ echo $SHELLOPTS
    braceexpand:hashall:histexpand:monitor:history:interactive-comments:emacs
    	      

$SHLVL Shell level, how deeply Bash is nested. [2] If, at the command line, $SHLVL is 1, then in a script it will increment to 2.

    Note	This variable is not affected by subshells. Use $BASH_SUBSHELL when you need an indication of subshell nesting.
$TMOUT If the $TMOUT environmental variable is set to a non-zero value time, then the shell prompt will time out after $time seconds. This will cause a logout.

    As of version 2.05b of Bash, it is now possible to use $TMOUT in a script in combination with read.

    # Works in scripts for Bash, versions 2.05b and later.

    TMOUT=3    # Prompt times out at three seconds.

    echo "What is your favorite song?"
    echo "Quickly now, you only have $TMOUT seconds to answer!"
    read song

    if [ -z "$song" ]
    then
      song="(no answer)"
      # Default response.
    fi

    echo "Your favorite song is $song."

    There are other, more complex, ways of implementing timed input in a script. One alternative is to set up a timing loop to signal the script when it times out. This also requires a signal handling routine to trap (see Example 29-5) the interrupt generated by the timing loop (whew!).

    Example 9-2. Timed Input

    #!/bin/bash
    # timed-input.sh

    # TMOUT=3    Also works, as of newer versions of Bash.


    TIMELIMIT=3  # Three seconds in this instance. May be set to different value.

    PrintAnswer()
    {
      if [ "$answer" = TIMEOUT ]
      then
        echo $answer
      else       # Don't want to mix up the two instances. 
        echo "Your favorite veggie is $answer"
        kill $!  # Kills no longer needed TimerOn function running in background.
                 # $! is PID of last job running in background.
      fi

    }  



    TimerOn()
    {
      sleep $TIMELIMIT && kill -s 14 $$ &
      # Waits 3 seconds, then sends sigalarm to script.
    }  

    Int14Vector()
    {
      answer="TIMEOUT"
      PrintAnswer
      exit 14
    }  

    trap Int14Vector 14   # Timer interrupt (14) subverted for our purposes.

    echo "What is your favorite vegetable "
    TimerOn
    read answer
    PrintAnswer


    #  Admittedly, this is a kludgy implementation of timed input,
    #+ however the "-t" option to "read" simplifies this task.
    #  See "t-out.sh", below.

    #  If you need something really elegant...
    #+ consider writing the application in C or C++,
    #+ using appropriate library functions, such as 'alarm' and 'setitimer'.

    exit 0

    An alternative is using stty.

    Example 9-3. Once more, timed input

    #!/bin/bash
    # timeout.sh

    #  Written by Stephane Chazelas,
    #+ and modified by the document author.

    INTERVAL=5                # timeout interval

    timedout_read() {
      timeout=$1
      varname=$2
      old_tty_settings=`stty -g`
      stty -icanon min 0 time ${timeout}0
      eval read $varname      # or just  read $varname
      stty "$old_tty_settings"
      # See man page for "stty".
    }

    echo; echo -n "What's your name? Quick! "
    timedout_read $INTERVAL your_name

    #  This may not work on every terminal type.
    #  The maximum timeout depends on the terminal.
    #+ (it is often 25.5 seconds).

    echo

    if [ ! -z "$your_name" ]  # If name input before timeout...
    then
      echo "Your name is $your_name."
    else
      echo "Timed out."
    fi

    echo

    # The behavior of this script differs somewhat from "timed-input.sh".
    # At each keystroke, the counter resets.

    exit 0

    Perhaps the simplest method is using the -t option to read.

    Example 9-4. Timed read

    #!/bin/bash
    # t-out.sh
    # Inspired by a suggestion from "syngin seven" (thanks).


    TIMELIMIT=4         # 4 seconds

    read -t $TIMELIMIT variable <&1
    #                           ^^^
    #  In this instance, "<&1" is needed for Bash 1.x and 2.x,
    #  but unnecessary for Bash 3.x.

    echo

    if [ -z "$variable" ]  # Is null?
    then
      echo "Timed out, variable still unset."
    else  
      echo "variable = $variable"
    fi  

    exit 0

			12.6.1.6 IDs
$UID user ID number

    current user's user identification number, as recorded in /etc/passwd

    This is the current user's real id, even if she has temporarily assumed another identity through su. $UID is a readonly variable, not subject to change from the command line or within a script, and is the counterpart to the id builtin.

    Example 9-5. Am I root?

    #!/bin/bash
    # am-i-root.sh:   Am I root or not?

    ROOT_UID=0   # Root has $UID 0.

    if [ "$UID" -eq "$ROOT_UID" ]  # Will the real "root" please stand up?
    then
      echo "You are root."
    else
      echo "You are just an ordinary user (but mom loves you just the same)."
    fi

    exit 0


    # ============================================================= #
    # Code below will not execute, because the script already exited.

    # An alternate method of getting to the root of matters:

    ROOTUSER_NAME=root

    username=`id -nu`              # Or...   username=`whoami`
    if [ "$username" = "$ROOTUSER_NAME" ]
    then
      echo "Rooty, toot, toot. You are root."
    else
      echo "You are just a regular fella."
    fi

    See also Example 2-3.

    Note	The variables $ENV, $LOGNAME, $MAIL, $TERM, $USER, and $USERNAME are not Bash builtins. These are, however, often set as environmental variables in one of the Bash startup files. $SHELL, the name of the user's login shell, may be set from /etc/passwd or in an "init" script, and it is likewise not a Bash builtin.

    tcsh% echo $LOGNAME
    bozo
    tcsh% echo $SHELL
    /bin/tcsh
    tcsh% echo $TERM
    rxvt

    bash$ echo $LOGNAME
    bozo
    bash$ echo $SHELL
    /bin/tcsh
    bash$ echo $TERM
    rxvt
    	      

			12.6.1.7 Positional Parameters

				12.6.1.7.1 Iterate over positional parameters
All forms below do same job with some nuiances to make a difference.

for arg; do
  echo "$arg"
done

while [ $# -gt 0 ]
do
        echo "extract_rpms(), extracting rpm $1 "
        shift
done

for rpm in "$@" 
do
        echo "extract_rpms(), extracting rpm ${rpm} "
done

args=$ARGS
while [ $args -gt 0 ]
do
        echo "extract_rpms(), extracting rpm ${args} "
        (( args-- ))
done

numargs=$#
for ((i=1 ; i <= numargs ; i++)); do
  echo "extract_rpms(), extracting rpm $1"
  shift
done



$0, $1, $2, etc.  positional parameters, passed from command line to script, passed to a function, or set to a variable (see Example 4-5 and Example 14-16)
$# number of command line arguments [3] or positional parameters (see Example 33-2)
$* All of the positional parameters, seen as a single word
Note	"$*" must be quoted.
$@ Same as $*, but each parameter is a quoted string, that is, the parameters are passed on intact, without interpretation or expansion. This means, among other things, that each parameter in the argument list is seen as a separate word.

    Note	Of course, "$@" should be quoted.

    Example 9-6. arglist: Listing arguments with $* and $@

    #!/bin/bash
    # arglist.sh
    # Invoke this script with several arguments, such as "one two three".

    E_BADARGS=65

    if[ ! -n "$1" ]
    then
      echo "Usage: `basename $0` argument1 argument2 etc."
      exit $E_BADARGS
    fi  

    echo

    index=1          # Initialize count.

    echo "Listing args with \"\$*\":"
    for arg in "$*"  # Doesn't work properly if "$*" isn't quoted.
    do
      echo "Arg #$index = $arg"
      let "index+=1"
    done             # $* sees all arguments as single word. 
    echo "Entire arg list seen as single word."

    echo

    index=1          # Reset count.
                     # What happens if you forget to do this?

    echo "Listing args with \"\$@\":"
    for arg in "$@"
    do
      echo "Arg #$index = $arg"
      let "index+=1"
    done             # $@ sees arguments as separate words. 
    echo "Arg list seen as separate words."

    echo

    index=1          # Reset count.

    echo "Listing args with \$* (unquoted):"
    for arg in $*
    do
      echo "Arg #$index = $arg"
      let "index+=1"
    done             # Unquoted $* sees arguments as separate words. 
    echo "Arg list seen as separate words."

    exit 0

    Following a shift, the $@ holds the remaining command-line parameters, lacking the previous $1, which was lost.

    #!/bin/bash
    # Invoke with ./scriptname 1 2 3 4 5

    echo "$@"    # 1 2 3 4 5
    shift
    echo "$@"    # 2 3 4 5
    shift
    echo "$@"    # 3 4 5

    # Each "shift" loses parameter $1.
    # "$@" then contains the remaining parameters.

    The $@ special parameter finds use as a tool for filtering input into shell scripts. The cat "$@" construction accepts input to a script either from stdin or from files given as parameters to the script. See Example 15-22 and Example 15-23.

    Caution	The $* and $@ parameters sometimes display inconsistent and puzzling behavior, depending on the setting of $IFS.

    Example 9-7. Inconsistent $* and $@ behavior

    #!/bin/bash

    #  Erratic behavior of the "$*" and "$@" internal Bash variables,
    #+ depending on whether they are quoted or not.
    #  Inconsistent handling of word splitting and linefeeds.


    set -- "First one" "second" "third:one" "" "Fifth: :one"
    # Setting the script arguments, $1, $2, etc.

    echo

    echo 'IFS unchanged, using "$*"'
    c=0
    for i in "$*"               # quoted
    do echo "$((c+=1)): [$i]"   # This line remains the same in every instance.
                                # Echo args.
    done
    echo ---

    echo 'IFS unchanged, using $*'
    c=0
    for i in $*                 # unquoted
    do echo "$((c+=1)): [$i]"
    done
    echo ---

    echo 'IFS unchanged, using "$@"'
    c=0
    for i in "$@"
    do echo "$((c+=1)): [$i]"
    done
    echo ---

    echo 'IFS unchanged, using $@'
    c=0
    for i in $@
    do echo "$((c+=1)): [$i]"
    done
    echo ---

    IFS=:
    echo 'IFS=":", using "$*"'
    c=0
    for i in "$*"
    do echo "$((c+=1)): [$i]"
    done
    echo ---

    echo 'IFS=":", using $*'
    c=0
    for i in $*
    do echo "$((c+=1)): [$i]"
    done
    echo ---

    var=$*
    echo 'IFS=":", using "$var" (var=$*)'
    c=0
    for i in "$var"
    do echo "$((c+=1)): [$i]"
    done
    echo ---

    echo 'IFS=":", using $var (var=$*)'
    c=0
    for i in $var
    do echo "$((c+=1)): [$i]"
    done
    echo ---

    var="$*"
    echo 'IFS=":", using $var (var="$*")'
    c=0
    for i in $var
    do echo "$((c+=1)): [$i]"
    done
    echo ---

    echo 'IFS=":", using "$var" (var="$*")'
    c=0
    for i in "$var"
    do echo "$((c+=1)): [$i]"
    done
    echo ---

    echo 'IFS=":", using "$@"'
    c=0
    for i in "$@"
    do echo "$((c+=1)): [$i]"
    done
    echo ---

    echo 'IFS=":", using $@'
    c=0
    for i in $@
    do echo "$((c+=1)): [$i]"
    done
    echo ---

    var=$@
    echo 'IFS=":", using $var (var=$@)'
    c=0
    for i in $var
    do echo "$((c+=1)): [$i]"
    done
    echo ---

    echo 'IFS=":", using "$var" (var=$@)'
    c=0
    for i in "$var"
    do echo "$((c+=1)): [$i]"
    done
    echo ---

    var="$@"
    echo 'IFS=":", using "$var" (var="$@")'
    c=0
    for i in "$var"
    do echo "$((c+=1)): [$i]"
    done
    echo ---

    echo 'IFS=":", using $var (var="$@")'
    c=0
    for i in $var
    do echo "$((c+=1)): [$i]"
    done

    echo

    # Try this script with ksh or zsh -y.

    exit 0

    # This example script by Stephane Chazelas,
    # and slightly modified by the document author.

    Note	The $@ and $* parameters differ only when between double quotes.

    Example 9-8. $* and $@ when $IFS is empty

    #!/bin/bash

    #  If $IFS set, but empty,
    #+ then "$*" and "$@" do not echo positional params as expected.

    mecho ()       # Echo positional parameters.
    {
    echo "$1,$2,$3";
    }


    IFS=""         # Set, but empty.
    set a b c      # Positional parameters.

    mecho "$*"     # abc,,
    mecho $*       # a,b,c

    mecho $@       # a,b,c
    mecho "$@"     # a,b,c

    #  The behavior of $* and $@ when $IFS is empty depends
    #+ on whatever Bash or sh version being run.
    #  It is therefore inadvisable to depend on this "feature" in a script.


    # Thanks, Stephane Chazelas.

    exit 0

			12.6.1.8 Other Special Parameters

$- Flags passed to script (using set). See Example 14-16.

    Caution	This was originally a ksh construct adopted into Bash, and unfortunately it does not seem to work reliably in Bash scripts. One possible use for it is to have a script self-test whether it is interactive.
$!  PID (process ID) of last job run in background

    LOG=$0.log

    COMMAND1="sleep 100"

    echo "Logging PIDs background commands for script: $0" >> "$LOG"
    # So they can be monitored, and killed as necessary.
    echo >> "$LOG"

    # Logging commands.

    echo -n "PID of \"$COMMAND1\":  " >> "$LOG"
    ${COMMAND1} &
    echo $! >> "$LOG"
    # PID of "sleep 100":  1506

    # Thank you, Jacques Lederer, for suggesting this.

    Important: Using $! for job control:
	$ possibly_hanging_job & { sleep ${TIMEOUT}; eval 'kill -9 $!' &> /dev/null; }
    # Forces completion of an ill-behaved program.
    # Useful, for example, in init scripts.

    # Thank you, Sylvain Fourmanoit, for this creative use of the "!" variable.

    Or, alternately:

    # This example by Matthew Sage.
    # Used with permission.

    TIMEOUT=30   # Timeout value in seconds
    count=0

    possibly_hanging_job & {
            while ((count < TIMEOUT )); do
                    eval '[ ! -d "/proc/$!" ] && ((count = TIMEOUT))'
                    # /proc is where information about running processes is found.
                    # "-d" tests whether it exists (whether directory exists).
                    # So, we're waiting for the job in question to show up.
                    ((count++))
                    sleep 1
            done
            eval '[ -d "/proc/$!" ] && kill -15 $!'
            # If the hanging job is running, kill it.
    }

$_ Special variable set to last argument of previous command executed.

    Example 9-9. Underscore variable

    #!/bin/bash

    echo $_              # /bin/bash
                         # Just called /bin/bash to run the script.

    du >/dev/null        # So no output from command.
    echo $_              # du

    ls -al >/dev/null    # So no output from command.
    echo $_              # -al  (last argument)

    :
    echo $_              # :

$?  Exit status of a command, function, or the script itself (see Example 23-7)
$$ Process ID of the script itself. The $$ variable often finds use in scripts to construct "unique" temp file names (see Example A-13, Example 29-6, Example 15-29, and Example 14-27). This is usually simpler than invoking mktemp.

		12.6.2 Manipulating Strings
Bash supports a surprising number of string manipulation operations. Unfortunately, these tools lack a unified focus. Some are a subset of parameter substitution, and others fall under the functionality of the UNIX expr command. This results in inconsistent command syntax and overlap of functionality, not to mention confusion.

			12.6.2.1 String Length

${#string}
Example: [yizaq@yytzhak-wxp:Tue Jul 08:/cygdrive/c/work/KB/bash/examples/basics:]$ a="yosi" && echo ${#a}
4

expr length $string
Example: [yizaq@yytzhak-wxp:Tue Jul 08:/cygdrive/c/work/KB/bash/examples/basics:]$ a="yosi" && expr length $a
4

    These are the equivalent of strlen() in C.
expr "$string" : '.*'

    stringZ=abcABC123ABCabc

    echo ${#stringZ}                 # 15
    echo `expr length $stringZ`      # 15
    echo `expr "$stringZ" : '.*'`    # 15

Example 9-10. Inserting a blank line between paragraphs in a text file

#!/bin/bash
# paragraph-space.sh

# Inserts a blank line between paragraphs of a single-spaced text file.
# Usage: $0 <FILENAME

MINLEN=45        # May need to change this value.
#  Assume lines shorter than $MINLEN characters
#+ terminate a paragraph.

while read line  # For as many lines as the input file has...
do
  echo "$line"   # Output the line itself.

  len=${#line}
  if [ "$len" -lt "$MINLEN" ]
    then echo    # Add a blank line after short line.
  fi  
done

exit 0

Usage Example:
[yizaq@yytzhak-wxp:Tue Jul 08:/cygdrive/c/work/KB/bash/examples/basics:]$ cat stam

|111
|222
|333
[yizaq@yytzhak-wxp:Tue Jul 08:/cygdrive/c/work/KB/bash/examples/basics:]$ . paragraph-space.bash < stam


|111

|222

|333


				12.6.2.2 Length of Matching Substring at Beginning of String

expr match "$string" '$substring'

    $substring is a regular expression.
expr "$string" : '$substring'

    $substring is a regular expression.

    stringZ=abcABC123ABCabc
    #       |------|

    echo `expr match "$stringZ" 'abc[A-Z]*.2'`   # 8
    echo `expr "$stringZ" : 'abc[A-Z]*.2'`       # 8

				12.6.2.3 Index

expr index $string $substring

    Numerical position in $string of first character in $substring that matches.

    stringZ=abcABC123ABCabc
    echo `expr index "$stringZ" C12`             # 6
                                                 # C position.

    echo `expr index "$stringZ" 1c`              # 3
    # 'c' (in #3 position) matches before '1'.

    This is the near equivalent of strchr() in C.

				12.6.2.4 Substring Extraction

${string:position}

    Extracts substring from $string at $position.

    If the $string parameter is "*" or "@", then this extracts the positional parameters, [1] starting at $position.
${string:position:length}

    Extracts $length characters of substring from $string at $position.

    stringZ=abcABC123ABCabc
    #       0123456789.....
    #       0-based indexing.

    echo ${stringZ:0}                            # abcABC123ABCabc
    echo ${stringZ:1}                            # bcABC123ABCabc
    echo ${stringZ:7}                            # 23ABCabc

    echo ${stringZ:7:3}                          # 23A
                                                 # Three characters of substring.



    # Is it possible to index from the right end of the string?
        
    echo ${stringZ:-4}                           # abcABC123ABCabc
    # Defaults to full string, as in ${parameter:-default}.
    # However . . .

    echo ${stringZ:(-4)}                         # Cabc 
    echo ${stringZ: -4}                          # Cabc
    # Now, it works.
    # Parentheses or added space "escape" the position parameter.

    # Thank you, Dan Jacobson, for pointing this out.

    The position and length arguments can be "parameterized," that is, represented as a variable, rather than as a numerical constant.

    Example 9-11. Generating an 8-character "random" string

    #!/bin/bash
    # rand-string.sh
    # Generating an 8-character "random" string.

    if [ "-n $1" ]  #  If command line argument present,
    then            #+ then set start-string to it.
      str0="$1"
    else            #  Else use PID of script as start-string.
      str0="$$"
    fi

    POS=2  # Starting from position 2 in the string.
    LEN=8  # Extract eight characters.

    str1=$( echo "$str0" | md5sum | md5sum )
    # Doubly scramble:     ^^^^^^   ^^^^^^

    randstring="${str1:$POS:$LEN}"
    # Can parameterize ^^^^ ^^^^

    echo "$randstring"

    exit $?

    # bozo$ ./rand-string.sh my-password
    # 1bdd88c4

    #  No, this is is not recommended
    #+ as a method of generating hack-proof passwords.

    If the $string parameter is "*" or "@", then this extracts a maximum of $length positional parameters, starting at $position.

    echo ${*:2}          # Echoes second and following positional parameters.
    echo ${@:2}          # Same as above.

    echo ${*:2:3}        # Echoes three positional parameters, starting at second.

				12.6.2.5 substract from string
expr substr $string $position $length Extracts $length characters from $string starting at $position.

    stringZ=abcABC123ABCabc
    #       123456789......
    #       1-based indexing.

    echo `expr substr $stringZ 1 2`              # ab
    echo `expr substr $stringZ 4 3`              # ABC

				12.6.2.6 string (pattern) match
expr match "$string" '\($substring\)' Extracts $substring at beginning of $string, where $substring is a regular expression.
expr "$string" : '\($substring\)' Extracts $substring at beginning of $string, where $substring is a regular expression.

    stringZ=abcABC123ABCabc
    #       =======	    

    echo `expr match "$stringZ" '\(.[b-c]*[A-Z]..[0-9]\)'`   # abcABC1
    echo `expr "$stringZ" : '\(.[b-c]*[A-Z]..[0-9]\)'`       # abcABC1
    echo `expr "$stringZ" : '\(.......\)'`                   # abcABC1
    # All of the above forms give an identical result.

expr match "$string" '.*\($substring\)' Extracts $substring at end of $string, where $substring is a regular expression.
expr "$string" : '.*\($substring\)' Extracts $substring at end of $string, where $substring is a regular expression.

    stringZ=abcABC123ABCabc
    #                ======

    echo `expr match "$stringZ" '.*\([A-C][A-C][A-C][a-c]*\)'`    # ABCabc
    echo `expr "$stringZ" : '.*\(......\)'`                       # ABCabc

				12.6.2.8 Substring Removal

${string#substring} Strips shortest match of $substring from front of $string.
${string##substring} Strips longest match of $substring from front of $string.

    stringZ=abcABC123ABCabc
    #       |----|
    #       |----------|

    echo ${stringZ#a*C}      # 123ABCabc
    # Strip out shortest match between 'a' and 'C'.

    echo ${stringZ##a*C}     # abc
    # Strip out longest match between 'a' and 'C'.

${string%substring} Strips shortest match of $substring from back of $string.

    For example:

    # Rename all filenames in $PWD with "TXT" suffix to a "txt" suffix.
    # For example, "file1.TXT" becomes "file1.txt" . . .

    SUFF=TXT
    suff=txt

    for i in $(ls *.$SUFF)
    do
      mv -f $i ${i%.$SUFF}.$suff
      #  Leave unchanged everything *except* the shortest pattern match
      #+ starting from the right-hand-side of the variable $i . . .
    done ### This could be condensed into a "one-liner" if desired.

    # Thank you, Rory Winston.

${string%%substring} Strips longest match of $substring from back of $string.

    stringZ=abcABC123ABCabc
    #                    ||
    #        |------------|

    echo ${stringZ%b*c}      # abcABC123ABCa
    # Strip out shortest match between 'b' and 'c', from back of $stringZ.

    echo ${stringZ%%b*c}     # a
    # Strip out longest match between 'b' and 'c', from back of $stringZ.

    This operator is useful for generating filenames.

    Example 9-12. Converting graphic file formats, with filename change

    #!/bin/bash
    #  cvt.sh:
    #  Converts all the MacPaint image files in a directory to "pbm" format.

    #  Uses the "macptopbm" binary from the "netpbm" package,
    #+ which is maintained by Brian Henderson (bryanh@giraffe-data.com).
    #  Netpbm is a standard part of most Linux distros.

    OPERATION=macptopbm
    SUFFIX=pbm          # New filename suffix. 

    if [ -n "$1" ]
    then
      directory=$1      # If directory name given as a script argument...
    else
      directory=$PWD    # Otherwise use current working directory.
    fi  
      
    #  Assumes all files in the target directory are MacPaint image files,
    #+ with a ".mac" filename suffix.

    for file in $directory/*    # Filename globbing. */
    do
      filename=${file%.*c}      #  Strip ".mac" suffix off filename
                                #+ ('.*c' matches everything
    			    #+ between '.' and 'c', inclusive).
      $OPERATION $file > "$filename.$SUFFIX"
                                # Redirect conversion to new filename.
      rm -f $file               # Delete original files after converting.   
      echo "$filename.$SUFFIX"  # Log what is happening to stdout.
    done

    exit 0

    # Exercise:
    # --------
    #  As it stands, this script converts *all* the files in the current
    #+ working directory.
    #  Modify it to work *only* on files with a ".mac" suffix.

    Example 9-13. Converting streaming audio files to ogg

    #!/bin/bash
    # ra2ogg.sh: Convert streaming audio files (*.ra) to ogg.

    # Uses the "mplayer" media player program:
    #      http://www.mplayerhq.hu/homepage
    #      Appropriate codecs may need to be installed for this script to work.
    # Uses the "ogg" library and "oggenc":
    #      http://www.xiph.org/


    OFILEPREF=${1%%ra}      # Strip off the "ra" suffix.
    OFILESUFF=wav           # Suffix for wav file.
    OUTFILE="$OFILEPREF""$OFILESUFF"
    E_NOARGS=65

    if [ -z "$1" ]          # Must specify a filename to convert.
    then
      echo "Usage: `basename $0` [filename]"
      exit $E_NOARGS
    fi


    ##########################################################################
    mplayer "$1" -ao pcm:file=$OUTFILE
    oggenc "$OUTFILE"  # Correct file extension automatically added by oggenc.
    ##########################################################################

    rm "$OUTFILE"      # Delete intermediate *.wav file.
                       # If you want to keep it, comment out above line.

    exit $?

    #  Note:
    #  ----
    #  On a Website, simply clicking on a *.ram streaming audio file
    #+ usually only downloads the URL of the actual audio file, the *.ra file.
    #  You can then use "wget" or something similar
    #+ to download the *.ra file itself.


    #  Exercises:
    #  ---------
    #  As is, this script converts only *.ra filenames.
    #  Add flexibility by permitting use of *.ram and other filenames.
    #
    #  If you're really ambitious, expand the script
    #+ to do automatic downloads and conversions of streaming audio files.
    #  Given a URL, batch download streaming audio files (using "wget")
    #+ and convert them.

    A simple emulation of getopt using substring extraction constructs.

    Example 9-14. Emulating getopt

    #!/bin/bash
    # getopt-simple.sh
    # Author: Chris Morgan
    # Used in the ABS Guide with permission.


    getopt_simple()
    {
        echo "getopt_simple()"
        echo "Parameters are '$*'"
        until [ -z "$1" ]
        do
          echo "Processing parameter of: '$1'"
          if [ ${1:0:1} = '/' ]
          then
              tmp=${1:1}               # Strip off leading '/' . . .
              parameter=${tmp%%=*}     # Extract name.
              value=${tmp##*=}         # Extract value.
              echo "Parameter: '$parameter', value: '$value'"
              eval $parameter=$value
          fi
          shift
        done
    }

    # Pass all options to getopt_simple().
    getopt_simple $*

    echo "test is '$test'"
    echo "test2 is '$test2'"

    exit 0

    ---

    sh getopt_example.sh /test=value1 /test2=value2

    Parameters are '/test=value1 /test2=value2'
    Processing parameter of: '/test=value1'
    Parameter: 'test', value: 'value1'
    Processing parameter of: '/test2=value2'
    Parameter: 'test2', value: 'value2'
    test is 'value1'
    test2 is 'value2'

				12.6.2.9 Substring Replacement

${string/substring/replacement} Replace first match of $substring with $replacement.
${string//substring/replacement} Replace all matches of $substring with $replacement.

    stringZ=abcABC123ABCabc

    echo ${stringZ/abc/xyz}           # xyzABC123ABCabc
                                      # Replaces first match of 'abc' with 'xyz'.

    echo ${stringZ//abc/xyz}          # xyzABC123ABCxyz
                                      # Replaces all matches of 'abc' with # 'xyz'.

${string/#substring/replacement} If $substring matches front end of $string, substitute $replacement for $substring.
${string/%substring/replacement} If $substring matches back end of $string, substitute $replacement for $substring.

    stringZ=abcABC123ABCabc

    echo ${stringZ/#abc/XYZ}          # XYZABC123ABCabc
                                      # Replaces front-end match of 'abc' with 'XYZ'.

    echo ${stringZ/%abc/XYZ}          # abcABC123ABCXYZ
                                      # Replaces back-end match of 'abc' with 'XYZ'.

				12.6.2.10 Manipulating strings using awk

A Bash script may invoke the string manipulation facilities of awk as an alternative to using its built-in operations.

Example 9-15. Alternate ways of extracting substrings

#!/bin/bash
# substring-extraction.sh

String=23skidoo1
#      012345678    Bash
#      123456789    awk
# Note different string indexing system:
# Bash numbers first character of string as '0'.
# Awk  numbers first character of string as '1'.

echo ${String:2:4} # position 3 (0-1-2), 4 characters long
                                         # skid

# The awk equivalent of ${string:pos:length} is substr(string,pos,length).
echo | awk '
{ print substr("'"${String}"'",3,4)      # skid
}
'
#  Piping an empty "echo" to awk gives it dummy input,
#+ and thus makes it unnecessary to supply a filename.

exit 0


		12.6.3 Parameter Substitution

Manipulating and/or expanding variables

			12.6.3.1 Use Parameter/Variable
${parameter} Same as $parameter, i.e., value of the variable parameter. In certain contexts, only the less ambiguous ${parameter} form works.

    May be used for concatenating variables with strings.

    your_id=${USER}-on-${HOSTNAME}
    echo "$your_id"
    #
    echo "Old \$PATH = $PATH"
    PATH=${PATH}:/opt/bin  #Add /opt/bin to $PATH for duration of script.
    echo "New \$PATH = $PATH"



			12.6.3.2 If parameter not set, use default.

${parameter-default}, ${parameter:-default}
    echo ${username-`whoami`}
    # Echoes the result of `whoami`, if variable $username is still unset.

    Note	${parameter-default} and ${parameter:-default} are almost equivalent. The extra : makes a difference only when parameter has been declared, but is null.

    #!/bin/bash
    # param-sub.sh

    #  Whether a variable has been declared
    #+ affects triggering of the default option
    #+ even if the variable is null.

    username0=
    echo "username0 has been declared, but is set to null."
    echo "username0 = ${username0-`whoami`}"
    # Will not echo.

    echo

    echo username1 has not been declared.
    echo "username1 = ${username1-`whoami`}"
    # Will echo.

    username2=
    echo "username2 has been declared, but is set to null."
    echo "username2 = ${username2:-`whoami`}"
    #                            ^
    # Will echo because of :- rather than just - in condition test.
    # Compare to first instance, above.


    #

    # Once again:

    variable=
    # variable has been declared, but is set to null.

    echo "${variable-0}"    # (no output)
    echo "${variable:-1}"   # 1
    #               ^

    unset variable

    echo "${variable-2}"    # 2
    echo "${variable:-3}"   # 3

    exit 0

    The default parameter construct finds use in providing "missing" command-line arguments in scripts.

    DEFAULT_FILENAME=generic.data
    filename=${1:-$DEFAULT_FILENAME}
    #  If not otherwise specified, the following command block operates
    #+ on the file "generic.data".
    #
    #  Commands follow.

    See also Example 3-4, Example 28-2, and Example A-6.

    Compare this method with using an and list to supply a default command-line argument.

			12.6.3.3 If parameter not set, set it to default.

${parameter=default}, ${parameter:=default}
    Both forms nearly equivalent. The : makes a difference only when $parameter has been declared and is null, [1] as above.

    echo ${username=`whoami`}
    # Variable "username" is now set to `whoami`.


			12.6.3.4 If parameter set, use alt_value, else use null string.

${parameter+alt_value}, ${parameter:+alt_value}
    Both forms nearly equivalent. The : makes a difference only when parameter has been declared and is null, see below.

    echo "###### \${parameter+alt_value} ########"
    echo

    a=${param1+xyz}
    echo "a = $a"      # a =

    param2=
    a=${param2+xyz}
    echo "a = $a"      # a = xyz

    param3=123
    a=${param3+xyz}
    echo "a = $a"      # a = xyz

    echo
    echo "###### \${parameter:+alt_value} ########"
    echo

    a=${param4:+xyz}
    echo "a = $a"      # a =

    param5=
    a=${param5:+xyz}
    echo "a = $a"      # a =
    # Different result from   a=${param5+xyz}

    param6=123
    a=${param6:+xyz}
    echo "a = $a"      # a = xyz


			12.6.3.5 If parameter set, use it, else print err_msg.

${parameter?err_msg}, ${parameter:?err_msg}
    Both forms nearly equivalent. The : makes a difference only when parameter has been declared and is null, as above.

Example 9-16. Using parameter substitution and error messages

#!/bin/bash

#  Check some of the system's environmental variables.
#  This is good preventative maintenance.
#  If, for example, $USER, the name of the person at the console, is not set,
#+ the machine will not recognize you.

: ${HOSTNAME?} ${USER?} ${HOME?} ${MAIL?}
  echo
  echo "Name of the machine is $HOSTNAME."
  echo "You are $USER."
  echo "Your home directory is $HOME."
  echo "Your mail INBOX is located in $MAIL."
  echo
  echo "If you are reading this message,"
  echo "critical environmental variables have been set."
  echo
  echo

# ------------------------------------------------------

#  The ${variablename?} construction can also check
#+ for variables set within the script.

ThisVariable=Value-of-ThisVariable
#  Note, by the way, that string variables may be set
#+ to characters disallowed in their names.
: ${ThisVariable?}
echo "Value of ThisVariable is $ThisVariable".
echo
echo


: ${ZZXy23AB?"ZZXy23AB has not been set."}
#  If ZZXy23AB has not been set,
#+ then the script terminates with an error message.

# You can specify the error message.
# : ${variablename?"ERROR MESSAGE"}


# Same result with:    dummy_variable=${ZZXy23AB?}
#                      dummy_variable=${ZZXy23AB?"ZXy23AB has not been set."}
#
#                      echo ${ZZXy23AB?} >/dev/null

#  Compare these methods of checking whether a variable has been set
#+ with "set -u" . . .



echo "You will not see this message, because script already terminated."

HERE=0
exit $HERE   # Will NOT exit here.

# In fact, this script will return an exit status (echo $?) of 1.

Example 9-17. Parameter substitution and "usage" messages

#!/bin/bash
# usage-message.sh

: ${1?"Usage: $0 ARGUMENT"}
#  Script exits here if command-line parameter absent,
#+ with following error message.
#    usage-message.sh: 1: Usage: usage-message.sh ARGUMENT

echo "These two lines echo only if command-line parameter given."
echo "command line parameter = \"$1\""

exit 0  # Will exit here only if command-line parameter present.

# Check the exit status, both with and without command-line parameter.
# If command-line parameter present, then "$?" is 0.
# If not, then "$?" is 1.

			12.6.3.6 Parameter substitution and/or expansion. 
			The following expressions are the complement to the match in expr string operations (see Example 15-9). These particular ones are used mostly in parsing file path names.

Variable length / Substring removal

${#var} String length (number of characters in $var). For an array, ${#array} is the length of the first element in the array.

    Note	Exceptions:

        * ${#*} and ${#@} give the number of positional parameters.
        * For an array, ${#array[*]} and ${#array[@]} give the number of elements in the array. 

    Example 9-18. Length of a variable

    #!/bin/bash
    # length.sh

    E_NO_ARGS=65

    if [ $# -eq 0 ]  # Must have command-line args to demo script.
    then
      echo "Please invoke this script with one or more command-line arguments."
      exit $E_NO_ARGS
    fi  

    var01=abcdEFGH28ij
    echo "var01 = ${var01}"
    echo "Length of var01 = ${#var01}"
    # Now, let's try embedding a space.
    var02="abcd EFGH28ij"
    echo "var02 = ${var02}"
    echo "Length of var02 = ${#var02}"

    echo "Number of command-line arguments passed to script = ${#@}"
    echo "Number of command-line arguments passed to script = ${#*}"

    exit 0

			12.6.3.7 Removal of part of string
${var#Pattern}, ${var##Pattern}

    ${var#Pattern} Remove from $var the shortest part of $Pattern that matches the front end of $var.

    ${var##Pattern} Remove from $var the longest part of $Pattern that matches the front end of $var.

    A usage illustration from Example A-7:

    # Function from "days-between.sh" example.  # Strips
    leading zero(s) from argument passed.

    strip_leading_zero () #  Strip possible leading zero(s)
    {                     #+ from argument passed.
      return=${1#0}       #  The "1" refers to "$1" -- passed arg.
    }                     #  The "0" is what to remove from "$1" -- strips zeros.

    Manfred Schwarb's more elaborate variation of the above:

    strip_leading_zero2 () # Strip possible leading zero(s), since otherwise
    {                      # Bash will interpret such numbers as octal values.
      shopt -s extglob     # Turn on extended globbing.
      local val=${1##+(0)} # Use local variable, longest matching series of 0's.
      shopt -u extglob     # Turn off extended globbing.
      _strip_leading_zero2=${val:-0}
                           # If input was 0, return 0 instead of "".
    }

    Another usage illustration:

    echo `basename $PWD`        # Basename of current working directory.
    echo "${PWD##*/}"           # Basename of current working directory.
    echo
    echo `basename $0`          # Name of script.
    echo $0                     # Name of script.
    echo "${0##*/}"             # Name of script.
    echo
    filename=test.data
    echo "${filename##*.}"      # data
                                # Extension of filename.

${var%Pattern}, ${var%%Pattern}

    {$var%Pattern} Remove from $var the shortest part of $Pattern that matches the back end of $var.

    {$var%%Pattern} Remove from $var the longest part of $Pattern that matches the back end of $var. 

Version 2 of Bash added additional options.

Example 9-19. Pattern matching in parameter substitution

#!/bin/bash
# patt-matching.sh

# Pattern matching  using the # ## % %% parameter substitution operators.

var1=abcd12345abc6789
pattern1=a*c  # * (wild card) matches everything between a - c.

echo
echo "var1 = $var1"           # abcd12345abc6789
echo "var1 = ${var1}"         # abcd12345abc6789
                              # (alternate form)
echo "Number of characters in ${var1} = ${#var1}"
echo

echo "pattern1 = $pattern1"   # a*c  (everything between 'a' and 'c')
echo "--------------"
echo '${var1#$pattern1}  =' "${var1#$pattern1}"    #         d12345abc6789
# Shortest possible match, strips out first 3 characters  abcd12345abc6789
#                                     ^^^^^               |-|
echo '${var1##$pattern1} =' "${var1##$pattern1}"   #                  6789      
# Longest possible match, strips out first 12 characters  abcd12345abc6789
#                                    ^^^^^                |----------|

echo; echo; echo

pattern2=b*9            # everything between 'b' and '9'
echo "var1 = $var1"     # Still  abcd12345abc6789
echo
echo "pattern2 = $pattern2"
echo "--------------"
echo '${var1%pattern2}  =' "${var1%$pattern2}"     #     abcd12345a
# Shortest possible match, strips out last 6 characters  abcd12345abc6789
#                                     ^^^^                         |----|
echo '${var1%%pattern2} =' "${var1%%$pattern2}"    #     a
# Longest possible match, strips out last 12 characters  abcd12345abc6789
#                                    ^^^^                 |-------------|

# Remember, # and ## work from the left end (beginning) of string,
#           % and %% work from the right end.

echo

exit 0

Example 9-20. Renaming file extensions:

#!/bin/bash
# rfe.sh: Renaming file extensions.
#
#         rfe old_extension new_extension
#
# Example:
# To rename all *.gif files in working directory to *.jpg,
#          rfe gif jpg


E_BADARGS=65

case $# in
  0|1)             # The vertical bar means "or" in this context.
  echo "Usage: `basename $0` old_file_suffix new_file_suffix"
  exit $E_BADARGS  # If 0 or 1 arg, then bail out.
  ;;
esac


for filename in *.$1
# Traverse list of files ending with 1st argument.
do
  mv $filename ${filename%$1}$2
  #  Strip off part of filename matching 1st argument,
  #+ then append 2nd argument.
done

exit 0

			12.6.3.8 Variable expansion / Substring replacement

    These constructs have been adopted from ksh.
${var:pos} Variable var expanded, starting from offset pos. 
${var:pos:len} Expansion to a max of len characters of variable var, from offset pos. See Example A-14 for an example of the creative use of this operator. 
${var/Pattern/Replacement} First match of Pattern, within var replaced with Replacement.
    If Replacement is omitted, then the first match of Pattern is replaced by nothing, that is, deleted.
${var//Pattern/Replacement} Global replacement. All matches of Pattern, within var replaced with Replacement.

    As above, if Replacement is omitted, then all occurrences of Pattern are replaced by nothing, that is, deleted.

    Example 9-21. Using pattern matching to parse arbitrary strings

    #!/bin/bash

    var1=abcd-1234-defg
    echo "var1 = $var1"

    t=${var1#*-*}
    echo "var1 (with everything, up to and including first - stripped out) = $t"
    #  t=${var1#*-}  works just the same,
    #+ since # matches the shortest string,
    #+ and * matches everything preceding, including an empty string.
    # (Thanks, Stephane Chazelas, for pointing this out.)

    t=${var1##*-*}
    echo "If var1 contains a \"-\", returns empty string...   var1 = $t"


    t=${var1%*-*}
    echo "var1 (with everything from the last - on stripped out) = $t"

    echo

    # -------------------------------------------
    path_name=/home/bozo/ideas/thoughts.for.today
    # -------------------------------------------
    echo "path_name = $path_name"
    t=${path_name##/*/}
    echo "path_name, stripped of prefixes = $t"
    # Same effect as   t=`basename $path_name` in this particular case.
    #  t=${path_name%/}; t=${t##*/}   is a more general solution,
    #+ but still fails sometimes.
    #  If $path_name ends with a newline, then `basename $path_name` will not work,
    #+ but the above expression will.
    # (Thanks, S.C.)

    t=${path_name%/*.*}
    # Same effect as   t=`dirname $path_name`
    echo "path_name, stripped of suffixes = $t"
    # These will fail in some cases, such as "../", "/foo////", # "foo/", "/".
    #  Removing suffixes, especially when the basename has no suffix,
    #+ but the dirname does, also complicates matters.
    # (Thanks, S.C.)

    echo

    t=${path_name:11}
    echo "$path_name, with first 11 chars stripped off = $t"
    t=${path_name:11:5}
    echo "$path_name, with first 11 chars stripped off, length 5 = $t"

    echo

    t=${path_name/bozo/clown}
    echo "$path_name with \"bozo\" replaced  by \"clown\" = $t"
    t=${path_name/today/}
    echo "$path_name with \"today\" deleted = $t"
    t=${path_name//o/O}
    echo "$path_name with all o's capitalized = $t"
    t=${path_name//o/}
    echo "$path_name with all o's deleted = $t"

    exit 0

${var/#Pattern/Replacement} If prefix of var matches Pattern, then substitute Replacement for Pattern.
${var/%Pattern/Replacement} If suffix of var matches Pattern, then substitute Replacement for Pattern.

    Example 9-22. Matching patterns at prefix or suffix of string

    #!/bin/bash
    # var-match.sh:
    # Demo of pattern replacement at prefix / suffix of string.

    v0=abc1234zip1234abc    # Original variable.
    echo "v0 = $v0"         # abc1234zip1234abc
    echo

    # Match at prefix (beginning) of string.
    v1=${v0/#abc/ABCDEF}    # abc1234zip1234abc
                            # |-|
    echo "v1 = $v1"         # ABCDEF1234zip1234abc
                            # |----|

    # Match at suffix (end) of string.
    v2=${v0/%abc/ABCDEF}    # abc1234zip123abc
                            #              |-|
    echo "v2 = $v2"         # abc1234zip1234ABCDEF
                            #               |----|

    echo

    #  ----------------------------------------------------
    #  Must match at beginning / end of string,
    #+ otherwise no replacement results.
    #  ----------------------------------------------------
    v3=${v0/#123/000}       # Matches, but not at beginning.
    echo "v3 = $v3"         # abc1234zip1234abc
                            # NO REPLACEMENT.
    v4=${v0/%123/000}       # Matches, but not at end.
    echo "v4 = $v4"         # abc1234zip1234abc
                            # NO REPLACEMENT.

    exit 0			

${!varprefix*}, ${!varprefix@} Matches names of all previously declared variables beginning with varprefix.

    xyz23=whatever
    xyz24=

    a=${!xyz*}      # Expands to *names* of declared variables beginning with "xyz".
    echo "a = $a"   # a = xyz23 xyz24
    a=${!xyz@}      # Same as above.
    echo "a = $a"   # a = xyz23 xyz24

    # Bash, version 2.04, adds this feature.



		12.6.4 Typing variables: declare or typeset
The declare or typeset builtins, which are exact synonyms, permit modifying the properties of variables. This is a very weak form of the typing  [1]  available in certain programming languages. The declare command is specific to version 2 or later of Bash. The typeset command also works in ksh scripts.

declare/typeset options

-r readonly declare -r var1

    (declare -r var1 works the same as readonly var1)

    This is the rough equivalent of the C const type qualifier. An attempt to change the value of a readonly variable fails with an error message.
-i integer

    declare -i number
    # The script will treat subsequent occurrences of "number" as an integer.		

    number=3
    echo "Number = $number"     # Number = 3

    number=three
    echo "Number = $number"     # Number = 0
    # Tries to evaluate the string "three" as an integer.

    Certain arithmetic operations are permitted for declared integer variables without the need for expr or let.

    n=6/3
    echo "n = $n"       # n = 6/3

    declare -i n
    n=6/3
    echo "n = $n"       # n = 2

-a array

    declare -a indices
The variable indices will be treated as an array.

-f function(s)

    declare -f

    A declare -f line with no arguments in a script causes a listing of all the functions previously defined in that script.

    declare -f function_name

    A declare -f function_name in a script lists just the function named.

-x export

    declare -x var3

    This declares a variable as available for exporting outside the environment of the script itself.
-x var=$value

    declare -x var3=373

    The declare command permits assigning a value to a variable in the same statement as setting its properties.

Example 9-23. Using declare to type variables

#!/bin/bash

func1 ()
{
echo This is a function.
}

declare -f        # Lists the function above.

echo

declare -i var1   # var1 is an integer.
var1=2367
echo "var1 declared as $var1"
var1=var1+1       # Integer declaration eliminates the need for 'let'.
echo "var1 incremented by 1 is $var1."
# Attempt to change variable declared as integer.
echo "Attempting to change var1 to floating point value, 2367.1."
var1=2367.1       # Results in error message, with no change to variable.
echo "var1 is still $var1"

echo

declare -r var2=13.36         # 'declare' permits setting a variable property
                              #+ and simultaneously assigning it a value.
echo "var2 declared as $var2" # Attempt to change readonly variable.
var2=13.37                    # Generates error message, and exit from script.

echo "var2 is still $var2"    # This line will not execute.

exit 0                        # Script will not exit here.

Caution	

Using the declare builtin restricts the scope of a variable.

foo ()
{
FOO="bar"
}

bar ()
{
foo
echo $FOO
}

bar   # Prints bar.

However . . .

foo (){
declare FOO="bar"
}

bar ()
{
foo
echo $FOO
}

bar  # Prints nothing.


# Thank you, Michael Iatrou, for pointing this out.


		12.6.5 Indirect References
Assume that the value of a variable is the name of a second variable. Is it somehow possible to retrieve the value of this second variable from the first one? For example, if a=letter_of_alphabet  and letter_of_alphabet=z, can a reference to a return z? This can indeed be done, and it is called an indirect reference. It uses the unusual eval var1=\$$var2  notation.

Example 9-24. Indirect Variable References

#!/bin/bash
# ind-ref.sh: Indirect variable referencing.
# Accessing the contents of the contents of a variable.

a=letter_of_alphabet   # Variable "a" holds the name of another variable.
letter_of_alphabet=z

echo

# Direct reference.
echo "a = $a"          # a = letter_of_alphabet

# Indirect reference.
eval a=\$$a
echo "Now a = $a"      # Now a = z

echo


# Now, let's try changing the second-order reference.

t=table_cell_3
table_cell_3=24
echo "\"table_cell_3\" = $table_cell_3"            # "table_cell_3" = 24
echo -n "dereferenced \"t\" = "; eval echo \$$t    # dereferenced "t" = 24
# In this simple case, the following also works (why?).
#         eval t=\$$t; echo "\"t\" = $t"

echo

t=table_cell_3
NEW_VAL=387
table_cell_3=$NEW_VAL
echo "Changing value of \"table_cell_3\" to $NEW_VAL."
echo "\"table_cell_3\" now $table_cell_3"
echo -n "dereferenced \"t\" now "; eval echo \$$t
# "eval" takes the two arguments "echo" and "\$$t" (set equal to $table_cell_3)

echo

# (Thanks, Stephane Chazelas, for clearing up the above behavior.)


# Another method is the ${!t} notation, discussed in "Bash, version 2" section.
# See also ex78.sh.

exit 0

Of what practical use is indirect referencing of variables? It gives Bash a little of the functionality of pointers in C, for instance, in table lookup. And, it also has some other very interesting applications. . . .

Nils Radtke shows how to build "dynamic" variable names and evaluate their contents. This can be useful when sourcing configuration files.

#!/bin/bash


# ---------------------------------------------
# This could be "sourced" from a separate file.
isdnMyProviderRemoteNet=172.16.0.100
isdnYourProviderRemoteNet=10.0.0.10
isdnOnlineService="MyProvider"
# ---------------------------------------------
      

remoteNet=$(eval "echo \$$(echo isdn${isdnOnlineService}RemoteNet)")
remoteNet=$(eval "echo \$$(echo isdnMyProviderRemoteNet)")
remoteNet=$(eval "echo \$isdnMyProviderRemoteNet")
remoteNet=$(eval "echo $isdnMyProviderRemoteNet")

echo "$remoteNet"    # 172.16.0.100

# ================================================================

#  And, it gets even better.

#  Consider the following snippet given a variable named getSparc,
#+ but no such variable getIa64:

chkMirrorArchs () { 
  arch="$1";
  if [ "$(eval "echo \${$(echo get$(echo -ne $arch |
       sed 's/^\(.\).*/\1/g' | tr 'a-z' 'A-Z'; echo $arch |
       sed 's/^.\(.*\)/\1/g')):-false}")" = true ]
  then
     return 0;
  else
     return 1;
  fi;
}

getSparc="true"
unset getIa64
chkMirrorArchs sparc
echo $?        # 0
               # True

chkMirrorArchs Ia64
echo $?        # 1
               # False

# Notes:
# -----
# Even the to-be-substituted variable name part is built explicitly.
# The parameters to the chkMirrorArchs calls are all lower case.
# The variable name is composed of two parts: "get" and "Sparc" . . .

Example 9-25. Passing an indirect reference to awk

#!/bin/bash

#  Another version of the "column totaler" script
#+ that adds up a specified column (of numbers) in the target file.
#  This one uses indirect references.

ARGS=2
E_WRONGARGS=65

if [ $# -ne "$ARGS" ] # Check for proper no. of command line args.
then
   echo "Usage: `basename $0` filename column-number"
   exit $E_WRONGARGS
fi

filename=$1
column_number=$2

#===== Same as original script, up to this point =====#


# A multi-line awk script is invoked by   awk ' ..... '


# Begin awk script.
# ------------------------------------------------
awk "

{ total += \$${column_number} # indirect reference
}
END {
     print total
     }

     " "$filename"
# ------------------------------------------------
# End awk script.

#  Indirect variable reference avoids the hassles
#+ of referencing a shell variable within the embedded awk script.
#  Thanks, Stephane Chazelas.


exit 0

Caution	

This method of indirect referencing is a bit tricky. If the second order variable changes its value, then the first order variable must be properly dereferenced (as in the above example). Fortunately, the ${!variable} notation introduced with version 2 of Bash (see Example 34-2 and Example A-24) makes indirect referencing more intuitive.

Bash does not support pointer arithmetic, and this severely limits the usefulness of indirect referencing. In fact, indirect referencing in a scripting language is, at best, an ugly kludge.



		12.6.6 $RANDOM: generate random integer
$RANDOM is an internal Bash function (not a constant) that returns a pseudorandom  [1]  integer in the range 0 - 32767. It should not be used to generate an encryption key.

			12.6.6.1 Generating random numbers

#!/bin/bash

# $RANDOM returns a different random integer at each invocation.
# Nominal range: 0 - 32767 (signed 16-bit integer).

MAXCOUNT=10
count=1

echo
echo "$MAXCOUNT random numbers:"
echo "-----------------"
while [ "$count" -le $MAXCOUNT ]      # Generate 10 ($MAXCOUNT) random integers.
do
  number=$RANDOM
  echo $number
  let "count += 1"  # Increment count.
done
echo "-----------------"

# If you need a random int within a certain range, use the 'modulo' operator.
# This returns the remainder of a division operation.

RANGE=500

echo

number=$RANDOM
let "number %= $RANGE"
#           ^^
echo "Random number less than $RANGE  ---  $number"

echo



#  If you need a random integer greater than a lower bound,
#+ then set up a test to discard all numbers below that.

FLOOR=200

number=0   #initialize
while [ "$number" -le $FLOOR ]
do
  number=$RANDOM
done
echo "Random number greater than $FLOOR ---  $number"
echo

   # Let's examine a simple alternative to the above loop, namely
   #       let "number = $RANDOM + $FLOOR"
   # That would eliminate the while-loop and run faster.
   # But, there might be a problem with that. What is it?



# Combine above two techniques to retrieve random number between two limits.
number=0   #initialize
while [ "$number" -le $FLOOR ]
do
  number=$RANDOM
  let "number %= $RANGE"  # Scales $number down within $RANGE.
done
echo "Random number between $FLOOR and $RANGE ---  $number"
echo



# Generate binary choice, that is, "true" or "false" value.
BINARY=2
T=1
number=$RANDOM

let "number %= $BINARY"
#  Note that    let "number >>= 14"    gives a better random distribution
#+ (right shifts out everything except last binary digit).
if [ "$number" -eq $T ]
then
  echo "TRUE"
else
  echo "FALSE"
fi  

echo


# Generate a toss of the dice.
SPOTS=6   # Modulo 6 gives range 0 - 5.
          # Incrementing by 1 gives desired range of 1 - 6.
          # Thanks, Paulo Marcel Coelho Aragao, for the simplification.
die1=0
die2=0
# Would it be better to just set SPOTS=7 and not add 1? Why or why not?

# Tosses each die separately, and so gives correct odds.

    let "die1 = $RANDOM % $SPOTS +1" # Roll first one.
    let "die2 = $RANDOM % $SPOTS +1" # Roll second one.
    #  Which arithmetic operation, above, has greater precedence --
    #+ modulo (%) or addition (+)?


let "throw = $die1 + $die2"
echo "Throw of the dice = $throw"
echo


exit 0

			12.6.6.2 Picking a random card from a deck

#!/bin/bash
# pick-card.sh

# This is an example of choosing random elements of an array.


# Pick a card, any card.

Suites="Clubs
Diamonds
Hearts
Spades"

Denominations="2
3
4
5
6
7
8
9
10
Jack
Queen
King
Ace"

# Note variables spread over multiple lines.


suite=($Suites)                # Read into array variable.
denomination=($Denominations)

num_suites=${#suite[*]}        # Count how many elements.
num_denominations=${#denomination[*]}

echo -n "${denomination[$((RANDOM%num_denominations))]} of "
echo ${suite[$((RANDOM%num_suites))]}


# $bozo sh pick-cards.sh
# Jack of Clubs


# Thank you, "jipe," for pointing out this use of $RANDOM.
exit 0

			12.6.6.3 Brownian Motion Simulation

#!/bin/bash
# brownian.sh
# Author: Mendel Cooper
# Reldate: 10/26/07
# License: GPL3

#  ----------------------------------------------------------------
#  This script models Brownian motion:
#+ the random wanderings of tiny particles in a fluid,
#+ as they are buffeted by random currents and collisions.
#+ This is colloquially known as the "Drunkard's Walk."

#  It can also be considered as a stripped-down simulation of a
#+ Galton Board, a slanted board with a pattern of pegs,
#+ down which rolls a succession of marbles, one at a time.
#+ At the bottom is a row of slots or catch basins in which
#+ the marbles come to rest at the end of their journey.
#  Think of it as a kind of bare-bones Pachinko game.
#  As you see by running the script,
#+ most of the marbles cluster around the center slot.
#+ This is consistent with the expected binomial distribution.
#  As a Galton Board simulation, the script
#+ disregards such parameters as
#+ board tilt-angle, rolling friction of the marbles,
#+ angles of impact, and elasticity of the pegs.
#  To what extent does this affect the accuracy of the simulation?
#  ----------------------------------------------------------------

PASSES=500            #  Number of particle interactions / marbles.
ROWS=10               #  Number of "collisions" (or horiz. peg rows).
RANGE=3               #  0 - 2 output range from $RANDOM.
POS=0                 #  Left/right position.
RANDOM=$$             #  Seeds the random number generator from PID
                      #+ of script.

declare -a Slots      # Array holding cumulative results of passes.
NUMSLOTS=21           # Number of slots at bottom of board.


Initialize_Slots () { # Zero out all elements of the array.
for i in $( seq $NUMSLOTS )
do
  Slots[$i]=0
done

echo                  # Blank line at beginning of run.
  }


Show_Slots () {
echo -n " "
for i in $( seq $NUMSLOTS )   # Pretty-print array elements.
do
  printf "%3d" ${Slots[$i]}   # Allot three spaces per result.
done

echo # Row of slots:
echo " |__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|"
echo "                                ^^"
echo #  Note that if the count within any particular slot exceeds 99,
     #+ it messes up the display.
     #  Running only(!) 500 passes usually avoids this.
  }


Move () {              # Move one unit right / left, or stay put.
  Move=$RANDOM         # How random is $RANDOM? Well, let's see ...
  let "Move %= RANGE"  # Normalize into range of 0 - 2.
  case "$Move" in
    0 ) ;;                   # Do nothing, i.e., stay in place.
    1 ) ((POS--));;          # Left.
    2 ) ((POS++));;          # Right.
    * ) echo -n "Error ";;   # Anomaly! (Should never occur.)
  esac
  }


Play () {                    # Single pass (inner loop).
i=0
while [ "$i" -lt "$ROWS" ]       # One event per row.
do
  Move
  ((i++));
done

SHIFT=11                     # Why 11, and not 10?
let "POS += $SHIFT"          # Shift "zero position" to center.
(( Slots[$POS]++ ))          # DEBUG: echo $POS
  }


Run () {                     # Outer loop.
p=0
while [ "$p" -lt "$PASSES" ]
do
  Play
  (( p++ ))
  POS=0                      # Reset to zero. Why?
done
  }


# --------------
# main ()
Initialize_Slots
Run
Show_Slots
# --------------

exit $?

#  Exercises:
#  ---------
#  1) Show the results in a vertical bar graph, or as an alternative,
#+    a scattergram.
#  2) Alter the script to use /dev/urandom instead of $RANDOM.
#     Will this make the results more random?

Jipe points out a set of techniques for generating random numbers within a range.

#  Generate random number between 6 and 30.
   rnumber=$((RANDOM%25+6))	

#  Generate random number in the same 6 - 30 range,
#+ but the number must be evenly divisible by 3.
   rnumber=$(((RANDOM%30/3+1)*3))

#  Note that this will not work all the time.
#  It fails if $RANDOM%30 returns 0.

#  Frank Wang suggests the following alternative:
   rnumber=$(( RANDOM%27/3*3+6 ))

Bill Gradwohl came up with an improved formula that works for positive numbers.

rnumber=$(((RANDOM%(max-min+divisibleBy))/divisibleBy*divisibleBy+min))

Here Bill presents a versatile function that returns a random number between two specified values.

			12.6.6.4 Random between values

#!/bin/bash
# random-between.sh
# Random number between two specified values. 
# Script by Bill Gradwohl, with minor modifications by the document author.
# Used with permission.


randomBetween() {
   #  Generates a positive or negative random number
   #+ between $min and $max
   #+ and divisible by $divisibleBy.
   #  Gives a "reasonably random" distribution of return values.
   #
   #  Bill Gradwohl - Oct 1, 2003

   syntax() {
   # Function embedded within function.
      echo
      echo    "Syntax: randomBetween [min] [max] [multiple]"
      echo
      echo -n "Expects up to 3 passed parameters, "
      echo    "but all are completely optional."
      echo    "min is the minimum value"
      echo    "max is the maximum value"
      echo -n "multiple specifies that the answer must be "
      echo     "a multiple of this value."
      echo    "    i.e. answer must be evenly divisible by this number."
      echo    
      echo    "If any value is missing, defaults area supplied as: 0 32767 1"
      echo -n "Successful completion returns 0, "
      echo     "unsuccessful completion returns"
      echo    "function syntax and 1."
      echo -n "The answer is returned in the global variable "
      echo    "randomBetweenAnswer"
      echo -n "Negative values for any passed parameter are "
      echo    "handled correctly."
   }

   local min=${1:-0}
   local max=${2:-32767}
   local divisibleBy=${3:-1}
   # Default values assigned, in case parameters not passed to function.

   local x
   local spread

   # Let's make sure the divisibleBy value is positive.
   [ ${divisibleBy} -lt 0 ] && divisibleBy=$((0-divisibleBy))

   # Sanity check.
   if [ $# -gt 3 -o ${divisibleBy} -eq 0 -o  ${min} -eq ${max} ]; then 
      syntax
      return 1
   fi

   # See if the min and max are reversed.
   if [ ${min} -gt ${max} ]; then
      # Swap them.
      x=${min}
      min=${max}
      max=${x}
   fi

   #  If min is itself not evenly divisible by $divisibleBy,
   #+ then fix the min to be within range.
   if [ $((min/divisibleBy*divisibleBy)) -ne ${min} ]; then 
      if [ ${min} -lt 0 ]; then
         min=$((min/divisibleBy*divisibleBy))
      else
         min=$((((min/divisibleBy)+1)*divisibleBy))
      fi
   fi

   #  If max is itself not evenly divisible by $divisibleBy,
   #+ then fix the max to be within range.
   if [ $((max/divisibleBy*divisibleBy)) -ne ${max} ]; then 
      if [ ${max} -lt 0 ]; then
         max=$((((max/divisibleBy)-1)*divisibleBy))
      else
         max=$((max/divisibleBy*divisibleBy))
      fi
   fi

   #  ---------------------------------------------------------------------
   #  Now, to do the real work.

   #  Note that to get a proper distribution for the end points,
   #+ the range of random values has to be allowed to go between
   #+ 0 and abs(max-min)+divisibleBy, not just abs(max-min)+1.

   #  The slight increase will produce the proper distribution for the
   #+ end points.

   #  Changing the formula to use abs(max-min)+1 will still produce
   #+ correct answers, but the randomness of those answers is faulty in
   #+ that the number of times the end points ($min and $max) are returned
   #+ is considerably lower than when the correct formula is used.
   #  ---------------------------------------------------------------------

   spread=$((max-min))
   #  Omair Eshkenazi points out that this test is unnecessary,
   #+ since max and min have already been switched around.
   [ ${spread} -lt 0 ] && spread=$((0-spread))
   let spread+=divisibleBy
   randomBetweenAnswer=$(((RANDOM%spread)/divisibleBy*divisibleBy+min))   

   return 0

   #  However, Paulo Marcel Coelho Aragao points out that
   #+ when $max and $min are not divisible by $divisibleBy,
   #+ the formula fails.
   #
   #  He suggests instead the following formula:
   #    rnumber = $(((RANDOM%(max-min+1)+min)/divisibleBy*divisibleBy))

}

# Let's test the function.
min=-14
max=20
divisibleBy=3


#  Generate an array of expected answers and check to make sure we get
#+ at least one of each answer if we loop long enough.

declare -a answer
minimum=${min}
maximum=${max}
   if [ $((minimum/divisibleBy*divisibleBy)) -ne ${minimum} ]; then 
      if [ ${minimum} -lt 0 ]; then
         minimum=$((minimum/divisibleBy*divisibleBy))
      else
         minimum=$((((minimum/divisibleBy)+1)*divisibleBy))
      fi
   fi


   #  If max is itself not evenly divisible by $divisibleBy,
   #+ then fix the max to be within range.

   if [ $((maximum/divisibleBy*divisibleBy)) -ne ${maximum} ]; then 
      if [ ${maximum} -lt 0 ]; then
         maximum=$((((maximum/divisibleBy)-1)*divisibleBy))
      else
         maximum=$((maximum/divisibleBy*divisibleBy))
      fi
   fi


#  We need to generate only positive array subscripts,
#+ so we need a displacement that that will guarantee
#+ positive results.

disp=$((0-minimum))
for ((i=${minimum}; i<=${maximum}; i+=divisibleBy)); do
   answer[i+disp]=0
done


# Now loop a large number of times to see what we get.
loopIt=1000   #  The script author suggests 100000,
              #+ but that takes a good long while.

for ((i=0; i<${loopIt}; ++i)); do

   #  Note that we are specifying min and max in reversed order here to
   #+ make the function correct for this case.

   randomBetween ${max} ${min} ${divisibleBy}

   # Report an error if an answer is unexpected.
   [ ${randomBetweenAnswer} -lt ${min} -o ${randomBetweenAnswer} -gt ${max} ] \
   && echo MIN or MAX error - ${randomBetweenAnswer}!
   [ $((randomBetweenAnswer%${divisibleBy})) -ne 0 ] \
   && echo DIVISIBLE BY error - ${randomBetweenAnswer}!

   # Store the answer away statistically.
   answer[randomBetweenAnswer+disp]=$((answer[randomBetweenAnswer+disp]+1))
done



# Let's check the results

for ((i=${minimum}; i<=${maximum}; i+=divisibleBy)); do
   [ ${answer[i+displacement]} -eq 0 ] \
   && echo "We never got an answer of $i." \
   || echo "${i} occurred ${answer[i+displacement]} times."
done


exit 0

Just how random is $RANDOM? The best way to test this is to write a script that tracks the distribution of "random" numbers generated by $RANDOM. Let's roll a $RANDOM die a few times . . .

			12.6.6.5 Rolling a single die with RANDOM

#!/bin/bash
# How random is RANDOM?

RANDOM=$$       # Reseed the random number generator using script process ID.

PIPS=6          # A die has 6 pips.
MAXTHROWS=600   # Increase this if you have nothing better to do with your time.
throw=0         # Throw count.

ones=0          #  Must initialize counts to zero,
twos=0          #+ since an uninitialized variable is null, not zero.
threes=0
fours=0
fives=0
sixes=0

print_result ()
{
echo
echo "ones =   $ones"
echo "twos =   $twos"
echo "threes = $threes"
echo "fours =  $fours"
echo "fives =  $fives"
echo "sixes =  $sixes"
echo
}

update_count()
{
case "$1" in
  0) let "ones += 1";;   # Since die has no "zero", this corresponds to 1.
  1) let "twos += 1";;   # And this to 2, etc.
  2) let "threes += 1";;
  3) let "fours += 1";;
  4) let "fives += 1";;
  5) let "sixes += 1";;
esac
}

echo


while [ "$throw" -lt "$MAXTHROWS" ]
do
  let "die1 = RANDOM % $PIPS"
  update_count $die1
  let "throw += 1"
done  

print_result

exit 0

#  The scores should distribute fairly evenly, assuming RANDOM is fairly random.
#  With $MAXTHROWS at 600, all should cluster around 100, plus-or-minus 20 or so.
#
#  Keep in mind that RANDOM is a pseudorandom generator,
#+ and not a spectacularly good one at that.

#  Randomness is a deep and complex subject.
#  Sufficiently long "random" sequences may exhibit
#+ chaotic and other "non-random" behavior.

# Exercise (easy):
# ---------------
# Rewrite this script to flip a coin 1000 times.
# Choices are "HEADS" and "TAILS".

As we have seen in the last example, it is best to reseed the RANDOM generator each time it is invoked. Using the same seed for RANDOM repeats the same series of numbers. [2] (This mirrors the behavior of the random() function in C.)

			12.6.6.6 Reseeding RANDOM

#!/bin/bash
# seeding-random.sh: Seeding the RANDOM variable.

MAXCOUNT=25       # How many numbers to generate.

random_numbers ()
{
count=0
while [ "$count" -lt "$MAXCOUNT" ]
do
  number=$RANDOM
  echo -n "$number "
  let "count += 1"
done  
}

echo; echo

RANDOM=1          # Setting RANDOM seeds the random number generator.
random_numbers

echo; echo

RANDOM=1          # Same seed for RANDOM...
random_numbers    # ...reproduces the exact same number series.
                  #
                  # When is it useful to duplicate a "random" number series?

echo; echo

RANDOM=2          # Trying again, but with a different seed...
random_numbers    # gives a different number series.

echo; echo

# RANDOM=$$  seeds RANDOM from process id of script.
# It is also possible to seed RANDOM from 'time' or 'date' commands.

# Getting fancy...
SEED=$(head -1 /dev/urandom | od -N 1 | awk '{ print $2 }')
#  Pseudo-random output fetched
#+ from /dev/urandom (system pseudo-random device-file),
#+ then converted to line of printable (octal) numbers by "od",
#+ finally "awk" retrieves just one number for SEED.
RANDOM=$SEED
random_numbers

echo; echo

exit 0

Note	
The /dev/urandom pseudo-device file provides a method of generating much more "random" pseudorandom numbers than the $RANDOM variable. dd if=/dev/urandom of=targetfile bs=1 count=XX creates a file of well-scattered pseudorandom numbers. However, assigning these numbers to a variable in a script requires a workaround, such as filtering through od (as in above example, Example 15-14, and Example A-38), or using dd (see Example 15-59), or even piping to md5sum (see Example 33-14).

There are also other ways to generate pseudorandom numbers in a script. Awk provides a convenient means of doing this.

			12.6.6.7 Pseudorandom numbers, using awk

#!/bin/bash
# random2.sh: Returns a pseudorandom number in the range 0 - 1.
# Uses the awk rand() function.

AWKSCRIPT=' { srand(); print rand() } '
#            Command(s) / parameters passed to awk
# Note that srand() reseeds awk's random number generator.


echo -n "Random number between 0 and 1 = "

echo | awk "$AWKSCRIPT"
# What happens if you leave out the 'echo'?

exit 0


# Exercises:
# ---------

# 1) Using a loop construct, print out 10 different random numbers.
#      (Hint: you must reseed the "srand()" function with a different seed
#+     in each pass through the loop. What happens if you fail to do this?)

# 2) Using an integer multiplier as a scaling factor, generate random numbers 
#+   in the range between 10 and 100.

# 3) Same as exercise #2, above, but generate random integers this time.

The date command also lends itself to generating pseudorandom integer sequences.
Notes
[1]	

True "randomness," insofar as it exists at all, can only be found in certain incompletely understood natural phenomena, such as radioactive decay. Computers only simulate randomness, and computer-generated sequences of "random" numbers are therefore referred to as pseudorandom.
[2]	

The seed of a computer-generated pseudorandom number series can be considered an identification label. For example, think of the pseudorandom series with a seed of 23 as series #23.

A property of a pseurandom number series is the length of the cycle before it starts repeating itself. A good pseurandom generator will produce series with very long cycles.


		12.6.7 The Double Parentheses Construct
Similar to the let command, the (( ... )) construct permits arithmetic expansion and evaluation. In its simplest form, a=$(( 5 + 3 )) would set a to 5 + 3, or 8. However, this double parentheses construct is also a mechanism for allowing C-style manipulation of variables in Bash, for example, (( var++ )).

Example 9-33. C-style manipulation of variables

#!/bin/bash
# Manipulating a variable, C-style, using the ((...)) construct.


echo

(( a = 23 ))  #  Setting a value, C-style,
              #+ with spaces on both sides of the "=".
echo "a (initial value) = $a"

(( a++ ))     #  Post-increment 'a', C-style.
echo "a (after a++) = $a"

(( a-- ))     #  Post-decrement 'a', C-style.
echo "a (after a--) = $a"


(( ++a ))     #  Pre-increment 'a', C-style.
echo "a (after ++a) = $a"

(( --a ))     #  Pre-decrement 'a', C-style.
echo "a (after --a) = $a"

echo

########################################################
#  Note that, as in C, pre- and post-decrement operators
#+ have slightly different side-effects.

n=1; let --n && echo "True" || echo "False"  # False
n=1; let n-- && echo "True" || echo "False"  # True

#  Thanks, Jeroen Domburg.
########################################################

echo

(( t = a<45?7:11 ))   # C-style trinary operator.
#       ^  ^ ^
echo "If a < 45, then t = 7, else t = 11."
echo "t = $t "        # Yes!

echo


# -----------------
# Easter Egg alert!
# -----------------
#  Chet Ramey seems to have snuck a bunch of undocumented C-style
#+ constructs into Bash (actually adapted from ksh, pretty much).
#  In the Bash docs, Ramey calls ((...)) shell arithmetic,
#+ but it goes far beyond that.
#  Sorry, Chet, the secret is now out.

# See also "for" and "while" loops using the ((...)) construct.

# These work only with Bash, version 2.04 or later.

exit 0

	12.7 Chapter 10. Loops and Branches

		12.7.1 Loops
			
			12.7.1.1 For Loops
for arg in [list]

    This is the basic looping construct. It differs significantly from its C counterpart.

    for arg in [list]
    do
     command(s)...
    done

    Note	During each pass through the loop, arg takes on the value of each successive variable in the list.

    for arg in "$var1" "$var2" "$var3" ... "$varN"  
    # In pass 1 of the loop, arg = $var1	    
    # In pass 2 of the loop, arg = $var2	    
    # In pass 3 of the loop, arg = $var3	    
    # ...
    # In pass N of the loop, arg = $varN

    # Arguments in [list] quoted to prevent possible word splitting.

    The argument list may contain wild cards.

    If do is on same line as for, there needs to be a semicolon after list.

    for arg in [list] ; do

    Note, use seq to generate a list of numbers from a range for the loop, like:
[yizaq@yytzhak-wxp:Wed Jul 23:~:]$ for n in $( seq 10 ) ; do echo $n; done
1
2
3
4
5
6
7
8
9
10
[yizaq@yytzhak-wxp:Wed Jul 23:~:]$ for n in $( seq 10 ) ; do echo -n $n; done
12345678910[yizaq@yytzhak-wxp:Wed Jul 23:~:]$ 

[yizaq@yytzhak-wxp:Wed Jul 23:~:]$ for n in $( seq 10 5 30 ) ; do echo  $n; done
10
15
20
25
30


				12.7.1.1.1 Example 10-1. Simple for loops

    #!/bin/bash
    # Listing the planets.

    for planet in Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto
    do
      echo $planet  # Each planet on a separate line.
    done

    echo

    for planet in "Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto"
        # All planets on same line.
        # Entire 'list' enclosed in quotes creates a single variable.
        # Why? Whitespace incorporated into the variable.
    do
      echo $planet
    done

    exit 0

    Each [list] element may contain multiple parameters. This is useful when processing parameters in groups. In such cases, use the set command (see Example 14-16) to force parsing of each [list] element and assignment of each component to the positional parameters.

				12.7.1.1.2 Example 10-2. for loop with two parameters in each [list] element

    #!/bin/bash
    # Planets revisited.

    # Associate the name of each planet with its distance from the sun.

    for planet in "Mercury 36" "Venus 67" "Earth 93"  "Mars 142" "Jupiter 483"
    do
      set -- $planet  #  Parses variable "planet"
                      #+ and sets positional parameters.
      #  The "--" prevents nasty surprises if $planet is null or
      #+ begins with a dash.

      #  May need to save original positional parameters,
      #+ since they get overwritten.
      #  One way of doing this is to use an array,
      #         original_params=("$@")

      echo "$1		$2,000,000 miles from the sun"
      #-------two  tabs---concatenate zeroes onto parameter $2
    done

    # (Thanks, S.C., for additional clarification.)

    exit 0

    A variable may supply the [list] in a for loop.

				12.7.1.1.3 Example 10-3. Fileinfo: operating on a file list contained in a variable

    #!/bin/bash
    # fileinfo.sh

    FILES="/usr/sbin/accept
    /usr/sbin/pwck
    /usr/sbin/chroot
    /usr/bin/fakefile
    /sbin/badblocks
    /sbin/ypbind"     # List of files you are curious about.
                      # Threw in a dummy file, /usr/bin/fakefile.

    echo

    for file in $FILES
    do

      if [ ! -e "$file" ]       # Check if file exists.
      then
        echo "$file does not exist."; echo
        continue                # On to next.
       fi

      ls -l $file | awk '{ print $9 "         file size: " $5 }'  # Print 2 fields.
      whatis `basename $file`   # File info.
      # Note that the whatis database needs to have been set up for this to work.
      # To do this, as root run /usr/bin/makewhatis.
      echo
    done  

    exit 0

    If the [list] in a for loop contains wild cards (* and ?) used in filename expansion, then globbing takes place.

				12.7.1.1.4 Example 10-4. Operating on files with a for loop

    #!/bin/bash
    # list-glob.sh: Generating [list] in a for-loop, using "globbing"

    echo

    for file in *
    #           ^  Bash performs filename expansion
    #+             on expressions that globbing recognizes.
    do
      ls -l "$file"  # Lists all files in $PWD (current directory).
      #  Recall that the wild card character "*" matches every filename,
      #+ however, in "globbing," it doesn't match dot-files.

      #  If the pattern matches no file, it is expanded to itself.
      #  To prevent this, set the nullglob option
      #+   (shopt -s nullglob).
      #  Thanks, S.C.
    done

    echo; echo

    for file in [jx]*
    do
      rm -f $file    # Removes only files beginning with "j" or "x" in $PWD.
      echo "Removed file \"$file\"".
    done

    echo

    exit 0

    Omitting the in [list] part of a for loop causes the loop to operate on $@ -- the positional parameters. A particularly clever illustration of this is Example A-16. See also Example 14-17.

				12.7.1.1.5 Example 10-5. Missing in [list] in a for loop

    #!/bin/bash

    #  Invoke this script both with and without arguments,
    #+ and see what happens.

    for a
    do
     echo -n "$a "
    done

    #  The 'in list' missing, therefore the loop operates on '$@'
    #+ (command-line argument list, including whitespace).

    echo

    exit 0

    It is possible to use command substitution to generate the [list] in a for loop. See also Example 15-53, Example 10-10 and Example 15-47.

				12.7.1.1.6 Example 10-6. Generating the [list] in a for loop with command substitution

    #!/bin/bash
    #  for-loopcmd.sh: for-loop with [list]
    #+ generated by command substitution.

    NUMBERS="9 7 3 8 37.53"

    for number in `echo $NUMBERS`  # for number in 9 7 3 8 37.53
    do
      echo -n "$number "
    done

    echo 
    exit 0

    Here is a somewhat more complex example of using command substitution to create the [list].

				12.7.1.1.7 Example 10-7. A grep replacement for binary files

    #!/bin/bash
    # bin-grep.sh: Locates matching strings in a binary file.

    # A "grep" replacement for binary files.
    # Similar effect to "grep -a"

    E_BADARGS=65
    E_NOFILE=66

    if [ $# -ne 2 ]
    then
      echo "Usage: `basename $0` search_string filename"
      exit $E_BADARGS
    fi

    if [ ! -f "$2" ]
    then
      echo "File \"$2\" does not exist."
      exit $E_NOFILE
    fi  


    IFS=$'\012'       # Per suggestion of Anton Filippov.
                      # was:  IFS="\n"
    for word in $( strings "$2" | grep "$1" )
    # The "strings" command lists strings in binary files.
    # Output then piped to "grep", which tests for desired string.
    do
      echo $word
    done

    # As S.C. points out, lines 23 - 30 could be replaced with the simpler
    #    strings "$2" | grep "$1" | tr -s "$IFS" '[\n*]'


    #  Try something like  "./bin-grep.sh mem /bin/ls"
    #+ to exercise this script.

    exit 0

    More of the same.

				12.7.1.1.8 Example 10-8. Listing all users on the system

    #!/bin/bash
    # userlist.sh

    PASSWORD_FILE=/etc/passwd
    n=1           # User number

    for name in $(awk 'BEGIN{FS=":"}{print $1}' < "$PASSWORD_FILE" )
    # Field separator = :    ^^^^^^
    # Print first field              ^^^^^^^^
    # Get input from password file               ^^^^^^^^^^^^^^^^^
    do
      echo "USER #$n = $name"
      let "n += 1"
    done  


    # USER #1 = root
    # USER #2 = bin
    # USER #3 = daemon
    # ...
    # USER #30 = bozo

    exit 0

    #  Exercise:
    #  --------
    #  How is it that an ordinary user (or a script run by same)
    #+ can read /etc/passwd?
    #  Isn't this a security hole? Why or why not?

    A final example of the [list] resulting from command substitution.

				12.7.1.1.9 Example 10-9. Checking all the binaries in a directory for authorship

    #!/bin/bash
    # findstring.sh:
    # Find a particular string in the binaries in a specified directory.

    directory=/usr/bin/
    fstring="Free Software Foundation"  # See which files come from the FSF.

    for file in $( find $directory -type f -name '*' | sort )
    do
      strings -f $file | grep "$fstring" | sed -e "s%$directory%%"
      #  In the "sed" expression,
      #+ it is necessary to substitute for the normal "/" delimiter
      #+ because "/" happens to be one of the characters filtered out.
      #  Failure to do so gives an error message (try it).
    done  

    exit 0

    #  Exercise (easy):
    #  ---------------
    #  Convert this script to take command-line parameters
    #+ for $directory and $fstring.

    The output of a for loop may be piped to a command or commands.

				12.7.1.1.10 Example 10-10. Listing the symbolic links in a directory

    #!/bin/bash
    # symlinks.sh: Lists symbolic links in a directory.


    directory=${1-`pwd`}
    #  Defaults to current working directory,
    #+ if not otherwise specified.
    #  Equivalent to code block below.
    # ----------------------------------------------------------
    # ARGS=1                 # Expect one command-line argument.
    #
    # if [ $# -ne "$ARGS" ]  # If not 1 arg...
    # then
    #   directory=`pwd`      # current working directory
    # else
    #   directory=$1
    # fi
    # ----------------------------------------------------------

    echo "symbolic links in directory \"$directory\""

    for file in "$( find $directory -type l )"   # -type l = symbolic links
    do
      echo "$file"
    done | sort                                  # Otherwise file list is unsorted.
    #  Strictly speaking, a loop isn't really necessary here,
    #+ since the output of the "find" command is expanded into a single word.
    #  However, it's easy to understand and illustrative this way.

    #  As Dominik 'Aeneas' Schnitzer points out,
    #+ failing to quote  $( find $directory -type l )
    #+ will choke on filenames with embedded whitespace.
    #  Even this will only pick up the first field of each argument.

    exit 0


    # --------------------------------------------------------
    # Jean Helou proposes the following alternative:

    echo "symbolic links in directory \"$directory\""
    # Backup of the current IFS. One can never be too cautious.
    OLDIFS=$IFS
    IFS=:

    for file in $(find $directory -type l -printf "%p$IFS")
    do     #                              ^^^^^^^^^^^^^^^^
           echo "$file"
           done|sort

    # And, James "Mike" Conley suggests modifying Helou's code thusly:

    OLDIFS=$IFS
    IFS='' # Null IFS means no word breaks
    for file in $( find $directory -type l )
    do
      echo $file
      done | sort

    #  This works in the "pathological" case of a directory name having
    #+ an embedded colon.
    #  "This also fixes the pathological case of the directory name having
    #+  a colon (or space in earlier example) as well."

    The stdout of a loop may be redirected to a file, as this slight modification to the previous example shows.

				12.7.1.1.11 Example 10-11. Symbolic links in a directory, saved to a file

    #!/bin/bash
    # symlinks.sh: Lists symbolic links in a directory.

    OUTFILE=symlinks.list                         # save file

    directory=${1-`pwd`}
    #  Defaults to current working directory,
    #+ if not otherwise specified.


    echo "symbolic links in directory \"$directory\"" > "$OUTFILE"
    echo "---------------------------" >> "$OUTFILE"

    for file in "$( find $directory -type l )"    # -type l = symbolic links
    do
      echo "$file"
    done | sort >> "$OUTFILE"                     # stdout of loop
    #           ^^^^^^^^^^^^^                       redirected to save file.

    exit 0

    There is an alternative syntax to a for loop that will look very familiar to C programmers. This requires double parentheses.

				12.7.1.1.12 Example 10-12. A C-style for loop

    #!/bin/bash
    # Two ways to count up to 10.

    echo

    # Standard syntax.
    for a in 1 2 3 4 5 6 7 8 9 10
    do
      echo -n "$a "
    done  

    echo; echo

    # +==========================================+

    # Now, let's do the same, using C-like syntax.

    LIMIT=10

    for ((a=1; a <= LIMIT ; a++))  # Double parentheses, and "LIMIT" with no "$".
    do
      echo -n "$a "
    done                           # A construct borrowed from 'ksh93'.

    echo; echo

    # +=========================================================================+

    # Let's use the C "comma operator" to increment two variables simultaneously.

    for ((a=1, b=1; a <= LIMIT ; a++, b++))  # The comma chains together operations.
    do
      echo -n "$a-$b "
    done

    echo; echo

    exit 0

    See also Example 26-16, Example 26-17, and Example A-6.

    ---

    Now, a for loop used in a "real-life" context.

				12.7.1.1.13 Example 10-13. Using efax in batch mode

    #!/bin/bash
    # Faxing (must have 'efax' package installed).

    EXPECTED_ARGS=2
    E_BADARGS=65
    MODEM_PORT="/dev/ttyS2"   # May be different on your machine.
    #                ^^^^^      PCMCIA modem card default port.

    if [ $# -ne $EXPECTED_ARGS ]
    # Check for proper number of command line args.
    then
       echo "Usage: `basename $0` phone# text-file"
       exit $E_BADARGS
    fi


    if [ ! -f "$2" ]
    then
      echo "File $2 is not a text file."
      #     File is not a regular file, or does not exist.
      exit $E_BADARGS
    fi
      

    fax make $2              #  Create fax-formatted files from text files.

    for file in $(ls $2.0*)  #  Concatenate the converted files.
                             #  Uses wild card (filename "globbing")
    			 #+ in variable list.
    do
      fil="$fil $file"
    done  

    efax -d "$MODEM_PORT"  -t "T$1" $fil   # Finally, do the work.
    # Trying adding  -o1  if above line fails.


    #  As S.C. points out, the for-loop can be eliminated with
    #     efax -d /dev/ttyS2 -o1 -t "T$1" $2.0*
    #+ but it's not quite as instructive [grin].

    exit $?   # Also, efax sends diagnostic messages to stdout.


			12.7.1.2 While Loops
This construct tests for a condition at the top of a loop, and keeps looping as long as that condition is true (returns a 0 exit status). In contrast to a for loop, a while loop finds use in situations where the number of loop repetitions is not known beforehand.

while [ condition ]
do
 command(s)...
done

The bracket construct in a while loop is nothing more than our old friend, the test brackets used in an if/then test. In fact, a while loop can legally use the more versatile double brackets construct (while [[ condition ]]).

As is the case with for loops, placing the do on the same line as the condition test requires a semicolon.

while [ condition ] ; do

Note that the test brackets are not mandatory in a while loop. See, for example, the getopts construct.

				12.7.1.2.1 Example 10-14. Simple while loop

#!/bin/bash

var0=0
LIMIT=10

while [ "$var0" -lt "$LIMIT" ]
#      ^                    ^
# Spaces, because these are "test-brackets" . . .
do
  echo -n "$var0 "        # -n suppresses newline.
  #             ^           Space, to separate printed out numbers.

  var0=`expr $var0 + 1`   # var0=$(($var0+1))  also works.
                          # var0=$((var0 + 1)) also works.
                          # let "var0 += 1"    also works.
done                      # Various other methods also work.

echo

exit 0

				12.7.1.2.2 Example 10-15. Another while loop

#!/bin/bash

echo
                               # Equivalent to:
while [ "$var1" != "end" ]     # while test "$var1" != "end"
do
  echo "Input variable #1 (end to exit) "
  read var1                    # Not 'read $var1' (why?).
  echo "variable #1 = $var1"   # Need quotes because of "#" . . .
  # If input is 'end', echoes it here.
  # Does not test for termination condition until top of loop.
  echo
done  

exit 0

A while loop may have multiple conditions. Only the final condition determines when the loop terminates. This necessitates a slightly different loop syntax, however.

				12.7.1.2.3 Example 10-16. while loop with multiple conditions

#!/bin/bash

var1=unset
previous=$var1

while echo "previous-variable = $previous"
      echo
      previous=$var1
      [ "$var1" != end ] # Keeps track of what $var1 was previously.
      # Four conditions on "while", but only last one controls loop.
      # The *last* exit status is the one that counts.
do
echo "Input variable #1 (end to exit) "
  read var1
  echo "variable #1 = $var1"
done  

# Try to figure out how this all works.
# It's a wee bit tricky.

exit 0

As with a for loop, a while loop may employ C-style syntax by using the double parentheses construct (see also Example 9-33).

				12.7.1.2.4 Example 10-17. C-style syntax in a while loop

#!/bin/bash
# wh-loopc.sh: Count to 10 in a "while" loop.

LIMIT=10
a=1

while [ "$a" -le $LIMIT ]
do
  echo -n "$a "
  let "a+=1"
done           # No surprises, so far.

echo; echo

# +=================================================================+

# Now, repeat with C-like syntax.

((a = 1))      # a=1
# Double parentheses permit space when setting a variable, as in C.

while (( a <= LIMIT ))   # Double parentheses, and no "$" preceding variables.
do
  echo -n "$a "
  ((a += 1))   # let "a+=1"
  # Yes, indeed.
  # Double parentheses permit incrementing a variable with C-like syntax.
done

echo

# C programmers can feel right at home in Bash.

exit 0

Inside its test brackets, a while loop can call a function.

t=0

condition ()
{
  ((t++))

  if [ $t -lt 5 ]
  then
    return 0  # true
  else
    return 1  # false
  fi
}

while condition
#     ^^^^^^^^^
#     Function call -- four loop iterations.
do
  echo "Still going: t = $t"
done

# Still going: t = 1
# Still going: t = 2
# Still going: t = 3
# Still going: t = 4

Similar to the if-test construct, a while loop can omit the test brackets.

while condition
do
   ...
done

By coupling the power of the read command with a while loop, we get the handy while read construct, useful for reading and parsing files.

cat $filename |   # Supply input from a file.
while read line   # As long as there is another line to read ...
do
  ...
done

Note	

A while loop may have its stdin redirected to a file by a < at its end.

A while loop may have its stdin supplied by a pipe.

			12.7.1.3 Until Loops
    This construct tests for a condition at the top of a loop, and keeps looping as long as that condition is false (opposite of while loop).

    until [ condition-is-true ]
    do
     command(s)...
    done

    Note that an until loop tests for the terminating condition at the top of the loop, differing from a similar construct in some programming languages.

    As is the case with for loops, placing the do on the same line as the condition test requires a semicolon.

    until [ condition-is-true ] ; do

				12.7.1.3.1 Example 10-18. until loop

    #!/bin/bash

    END_CONDITION=end

    until [ "$var1" = "$END_CONDITION" ]
    # Tests condition here, at top of loop.
    do
      echo "Input variable #1 "
      echo "($END_CONDITION to exit)"
      read var1
      echo "variable #1 = $var1"
      echo
    done  

    exit 0

How to choose between a for loop or a while loop or until loop? In C, you would typically use a for loop when the number of loop iterations is known beforehand. With Bash, however, the situation is fuzzier. The Bash for loop is more loosely structured and more flexible than its equivalent in other languages. Therefore, feel free to use whatever type of loop gets the job done in the simplest way.

		12.7.2 Nested Loops
A nested loop is a loop within a loop, an inner loop within the body of an outer one. How this works is that the first pass of the outer loop triggers the inner loop, which executes to completion. Then the second pass of the outer loop triggers the inner loop again. This repeats until the outer loop finishes. Of course, a break within either the inner or outer loop would interrupt this process.

Example 10-19. Nested Loop

#!/bin/bash
# nested-loop.sh: Nested "for" loops.

outer=1             # Set outer loop counter.

# Beginning of outer loop.
for a in 1 2 3 4 5
do
  echo "Pass $outer in outer loop."
  echo "---------------------"
  inner=1           # Reset inner loop counter.

  # ===============================================
  # Beginning of inner loop.
  for b in 1 2 3 4 5
  do
    echo "Pass $inner in inner loop."
    let "inner+=1"  # Increment inner loop counter.
  done
  # End of inner loop.
  # ===============================================

  let "outer+=1"    # Increment outer loop counter. 
  echo              # Space between output blocks in pass of outer loop.
done               
# End of outer loop.

exit 0

		12.7.3 Loop Control
Commands Affecting Loop Behavior

break, continue 
    The break and continue loop control commands [1] correspond exactly to their counterparts in other programming languages. The break command terminates the loop (breaks out of it), while continue causes a jump to the next iteration (repetition) of the loop, skipping all the remaining commands in that particular loop cycle.

			12.7.3.1 Example 10-20. Effects of break and continue in a loop

    #!/bin/bash

    LIMIT=19  # Upper limit

    echo
    echo "Printing Numbers 1 through 20 (but not 3 and 11)."

    a=0

    while [ $a -le "$LIMIT" ]
    do
     a=$(($a+1))

     if [ "$a" -eq 3 ] || [ "$a" -eq 11 ]  # Excludes 3 and 11.
     then
       continue      # Skip rest of this particular loop iteration.
     fi

     echo -n "$a "   # This will not execute for 3 and 11.
    done 

    # Exercise:
    # Why does loop print up to 20?

    echo; echo

    echo Printing Numbers 1 through 20, but something happens after 2.

    ##################################################################

    # Same loop, but substituting 'break' for 'continue'.

    a=0

    while [ "$a" -le "$LIMIT" ]
    do
     a=$(($a+1))

     if [ "$a" -gt 2 ]
     then
       break  # Skip entire rest of loop.
     fi

     echo -n "$a "
    done

    echo; echo; echo

    exit 0

    The break command may optionally take a parameter. A plain break terminates only the innermost loop in which it is embedded, but a break N breaks out of N levels of loop.

			12.7.3.2 Example 10-21. Breaking out of multiple loop levels

    #!/bin/bash
    # break-levels.sh: Breaking out of loops.

    # "break N" breaks out of N level loops.

    for outerloop in 1 2 3 4 5
    do
      echo -n "Group $outerloop:   "

      # --------------------------------------------------------
      for innerloop in 1 2 3 4 5
      do
        echo -n "$innerloop "

        if [ "$innerloop" -eq 3 ]
        then
          break  # Try   break 2   to see what happens.
                 # ("Breaks" out of both inner and outer loops.)
        fi
      done
      # --------------------------------------------------------

      echo
    done  

    echo

    exit 0

    The continue command, similar to break, optionally takes a parameter. A plain continue cuts short the current iteration within its loop and begins the next. A continue N terminates all remaining iterations at its loop level and continues with the next iteration at the loop, N levels above.

			12.7.3.3 Example 10-22. Continuing at a higher loop level

    #!/bin/bash
    # The "continue N" command, continuing at the Nth level loop.

    for outer in I II III IV V           # outer loop
    do
      echo; echo -n "Group $outer: "

      # --------------------------------------------------------------------
      for inner in 1 2 3 4 5 6 7 8 9 10  # inner loop
      do

        if [ "$inner" -eq 7 ]
        then
          continue 2  # Continue at loop on 2nd level, that is "outer loop".
                      # Replace above line with a simple "continue"
                      # to see normal loop behavior.
        fi  

        echo -n "$inner "  # 7 8 9 10 will never echo.
      done  
      # --------------------------------------------------------------------

    done

    echo; echo

    # Exercise:
    # Come up with a meaningful use for "continue N" in a script.

    exit 0

			12.7.3.4 Example 10-23. Using continue N in an actual task

    # Albert Reiner gives an example of how to use "continue N":
    # ---------------------------------------------------------

    #  Suppose I have a large number of jobs that need to be run, with
    #+ any data that is to be treated in files of a given name pattern in a
    #+ directory. There are several machines that access this directory, and
    #+ I want to distribute the work over these different boxen. Then I
    #+ usually nohup something like the following on every box:

    while true
    do
      for n in .iso.*
      do
        [ "$n" = ".iso.opts" ] && continue
        beta=${n#.iso.}
        [ -r .Iso.$beta ] && continue
        [ -r .lock.$beta ] && sleep 10 && continue
        lockfile -r0 .lock.$beta || continue
        echo -n "$beta: " `date`
        run-isotherm $beta
        date
        ls -alF .Iso.$beta
        [ -r .Iso.$beta ] && rm -f .lock.$beta
        continue 2
      done
      break
    done

    #  The details, in particular the sleep N, are particular to my
    #+ application, but the general pattern is:

    while true
    do
      for job in {pattern}
      do
        {job already done or running} && continue
        {mark job as running, do job, mark job as done}
        continue 2
      done
      break        # Or something like `sleep 600' to avoid termination.
    done

    #  This way the script will stop only when there are no more jobs to do
    #+ (including jobs that were added during runtime). Through the use
    #+ of appropriate lockfiles it can be run on several machines
    #+ concurrently without duplication of calculations [which run a couple
    #+ of hours in my case, so I really want to avoid this]. Also, as search
    #+ always starts again from the beginning, one can encode priorities in
    #+ the file names. Of course, one could also do this without `continue 2',
    #+ but then one would have to actually check whether or not some job
    #+ was done (so that we should immediately look for the next job) or not
    #+ (in which case we terminate or sleep for a long time before checking
    #+ for a new job).

    Caution	

    The continue N construct is difficult to understand and tricky to use in any meaningful context. It is probably best avoided.


		12.7.4 Testing and Branching
The case and select  constructs are technically not loops, since they do not iterate the execution of a code block. Like loops, however, they direct program flow according to conditions at the top or bottom of the block.

Controlling program flow in a code block


			12.7.4.1 case (in) / esac

    The case construct is the shell scripting analog to switch in C/C++. It permits branching to one of a number of code blocks, depending on condition tests. It serves as a kind of shorthand for multiple if/then/else statements and is an appropriate tool for creating menus.

    case "$variable" in

     "$condition1" )
     command...
     ;;

     "$condition2" )
     command...
     ;;

    esac

    Note	

        * Quoting the variables is not mandatory, since word splitting does not take place.
        * Each test line ends with a right paren ).
        * Each condition block ends with a double semicolon ;;.
        * The entire case block terminates with an esac (case spelled backwards).

				12.7.4.1.1 Example 10-24. Using case

    #!/bin/bash
    # Testing ranges of characters.

    echo; echo "Hit a key, then hit return."
    read Keypress

    case "$Keypress" in
      [[:lower:]]   ) echo "Lowercase letter";;
      [[:upper:]]   ) echo "Uppercase letter";;
      [[:digit:]]         ) echo "Digit";;
#      [0-9]         ) echo "Digit";;
      *             ) echo "Punctuation, whitespace, or other";;
    esac      #  Allows ranges of characters in [square brackets],
              #+ or POSIX ranges in [[double square brackets.

    #  In the first version of this example,
    #+ the tests for lowercase and uppercase characters were
    #+ [a-z] and [A-Z].
    #  This no longer works in certain locales and/or Linux distros.
    #  POSIX is more portable.
    #  Thanks to Frank Wang for pointing this out.

    #  Exercise:
    #  --------
    #  As the script stands, it accepts a single keystroke, then terminates.
    #  Change the script so it accepts repeated input,
    #+ reports on each keystroke, and terminates only when "X" is hit.
    #  Hint: enclose everything in a "while" loop.

    exit 0

				12.7.4.1.2 Example 10-25. Creating menus using case

    #!/bin/bash

    # Crude address database

    clear # Clear the screen.

    echo "          Contact List"
    echo "          ------- ----"
    echo "Choose one of the following persons:" 
    echo
    echo "[E]vans, Roland"
    echo "[J]ones, Mildred"
    echo "[S]mith, Julie"
    echo "[Z]ane, Morris"
    echo

    read person

    case "$person" in
    # Note variable is quoted.

      "E" | "e" )
      # Accept upper or lowercase input.
      echo
      echo "Roland Evans"
      echo "4321 Floppy Dr."
      echo "Hardscrabble, CO 80753"
      echo "(303) 734-9874"
      echo "(303) 734-9892 fax"
      echo "revans@zzy.net"
      echo "Business partner & old friend"
      ;;
    # Note double semicolon to terminate each option.

      "J" | "j" )
      echo
      echo "Mildred Jones"
      echo "249 E. 7th St., Apt. 19"
      echo "New York, NY 10009"
      echo "(212) 533-2814"
      echo "(212) 533-9972 fax"
      echo "milliej@loisaida.com"
      echo "Ex-girlfriend"
      echo "Birthday: Feb. 11"
      ;;

    # Add info for Smith & Zane later.

              * )
       # Default option.	  
       # Empty input (hitting RETURN) fits here, too.
       echo
       echo "Not yet in database."
      ;;

    esac

    echo

    #  Exercise:
    #  --------
    #  Change the script so it accepts multiple inputs,
    #+ instead of terminating after displaying just one address.

    exit 0

    An exceptionally clever use of case involves testing for command-line parameters.

    #! /bin/bash

    case "$1" in
      "") echo "Usage: ${0##*/} <filename>"; exit $E_PARAM;;
                          # No command-line parameters,
                          # or first parameter empty.
    # Note that ${0##*/} is ${var##pattern} param substitution.
                          # Net result is $0.

      -*) FILENAME=./$1;;   #  If filename passed as argument ($1)
                          #+ starts with a dash,
                          #+ replace it with ./$1
                          #+ so further commands don't interpret it
                          #+ as an option.

      * ) FILENAME=$1;;     # Otherwise, $1.
    esac

    Here is an more straightforward example of command-line parameter handling:

    #! /bin/bash


    while [ $# -gt 0 ]; do    # Until you run out of parameters . . .
      case "$1" in
        -d|--debug)
                  # "-d" or "--debug" parameter?
                  DEBUG=1
                  ;;
        -c|--conf)
                  CONFFILE="$2"
                  shift
                  if [ ! -f $CONFFILE ]; then
                    echo "Error: Supplied file doesn't exist!"
                    exit $E_CONFFILE     # File not found error.
                  fi
                  ;;
      esac
      shift       # Check next set of parameters.
    done

    #  From Stefano Falsetto's "Log2Rot" script,
    #+ part of his "rottlog" package.
    #  Used with permission.

				12.7.4.1.3 Example 10-26. Using command substitution to generate the case variable

    #!/bin/bash
    # case-cmd.sh: Using command substitution to generate a "case" variable.

    case $( arch ) in   # "arch" returns machine architecture.
                        # Equivalent to 'uname -m' ...
      i386 ) echo "80386-based machine";;
      i486 ) echo "80486-based machine";;
      i586 ) echo "Pentium-based machine";;
      i686 ) echo "Pentium2+-based machine";;
      *    ) echo "Other type of machine";;
    esac

    exit 0

    A case construct can filter strings for globbing patterns.

				12.7.4.1.4 Example 10-27. Simple string matching

    #!/bin/bash
    # match-string.sh: simple string matching

    match_string ()
    {
      MATCH=0
      NOMATCH=90
      PARAMS=2     # Function requires 2 arguments.
      BAD_PARAMS=91

      [ $# -eq $PARAMS ] || return $BAD_PARAMS

      case "$1" in
      "$2") return $MATCH;;
      *   ) return $NOMATCH;;
      esac

    }  


    a=one
    b=two
    c=three
    d=two


    match_string $a     # wrong number of parameters
    echo $?             # 91

    match_string $a $b  # no match
    echo $?             # 90

    match_string $b $d  # match
    echo $?             # 0


    exit 0		    

				12.7.4.1.5 Example 10-28. Checking for alphabetic input

    #!/bin/bash
    # isalpha.sh: Using a "case" structure to filter a string.

    SUCCESS=0
    FAILURE=-1

    isalpha ()  # Tests whether *first character* of input string is alphabetic.
    {
    if [ -z "$1" ]                # No argument passed?
    then
      return $FAILURE
    fi

    case "$1" in
      [a-zA-Z]*) return $SUCCESS;;  # Begins with a letter?
      *        ) return $FAILURE;;
    esac
    }             # Compare this with "isalpha ()" function in C.


    isalpha2 ()   # Tests whether *entire string* is alphabetic.
    {
      [ $# -eq 1 ] || return $FAILURE

      case $1 in
      *[!a-zA-Z]*|"") return $FAILURE;;
                   *) return $SUCCESS;;
      esac
    }

    isdigit ()    # Tests whether *entire string* is numerical.
    {             # In other words, tests for integer variable.
      [ $# -eq 1 ] || return $FAILURE

      case $1 in
        *[!0-9]*|"") return $FAILURE;;
                  *) return $SUCCESS;;
      esac
    }



    check_var ()  # Front-end to isalpha ().
    {
    if isalpha "$@"
    then
      echo "\"$*\" begins with an alpha character."
      if isalpha2 "$@"
      then        # No point in testing if first char is non-alpha.
        echo "\"$*\" contains only alpha characters."
      else
        echo "\"$*\" contains at least one non-alpha character."
      fi  
    else
      echo "\"$*\" begins with a non-alpha character."
                  # Also "non-alpha" if no argument passed.
    fi

    echo

    }

    digit_check ()  # Front-end to isdigit ().
    {
    if isdigit "$@"
    then
      echo "\"$*\" contains only digits [0 - 9]."
    else
      echo "\"$*\" has at least one non-digit character."
    fi

    echo

    }

    a=23skidoo
    b=H3llo
    c=-What?
    d=What?
    e=`echo $b`   # Command substitution.
    f=AbcDef
    g=27234
    h=27a34
    i=27.34

    check_var $a
    check_var $b
    check_var $c
    check_var $d
    check_var $e
    check_var $f
    check_var     # No argument passed, so what happens?
    #
    digit_check $g
    digit_check $h
    digit_check $i


    exit 0        # Script improved by S.C.

    # Exercise:
    # --------
    #  Write an 'isfloat ()' function that tests for floating point numbers.
    #  Hint: The function duplicates 'isdigit ()',
    #+ but adds a test for a mandatory decimal point.

select

    The select construct, adopted from the Korn Shell, is yet another tool for building menus.

    select variable [in list]
    do
     command...
     break
    done

    This prompts the user to enter one of the choices presented in the variable list. Note that select uses the PS3 prompt (#? ) by default, but that this may be changed.

    Example 10-29. Creating menus using select

    #!/bin/bash

    PS3='Choose your favorite vegetable: ' # Sets the prompt string.

    echo

    select vegetable in "beans" "carrots" "potatoes" "onions" "rutabagas"
    do
      echo
      echo "Your favorite veggie is $vegetable."
      echo "Yuck!"
      echo
      break  # What happens if there is no 'break' here?
    done

    exit 0

    If in list is omitted, then select uses the list of command line arguments ($@) passed to the script or to the function in which the select construct is embedded.

    Compare this to the behavior of a

    for variable [in list]
    construct with the in list omitted.

    Example 10-30. Creating menus using select in a function

    #!/bin/bash

    PS3='Choose your favorite vegetable: '

    echo

    choice_of()
    {
    select vegetable
    # [in list] omitted, so 'select' uses arguments passed to function.
    do
      echo
      echo "Your favorite veggie is $vegetable."
      echo "Yuck!"
      echo
      break
    done
    }

    choice_of beans rice carrots radishes tomatoes spinach
    #         $1    $2   $3      $4       $5       $6
    #         passed to choice_of() function

    exit 0

	12.8 Chapter 11. Command Substitution
Command substitution reassigns the output of a command [1]  or even multiple commands; it literally plugs the command output into another context. [2]

The classic form of command substitution uses backquotes (`...`). Commands within backquotes (backticks) generate command line text.

		12.8.1 Basic usages


script_name=`basename $0`
echo "The name of this script is $script_name."

The output of commands can be used as arguments to another command, to set a variable, and even for generating the argument list in a for loop.

rm `cat filename`   # "filename" contains a list of files to delete.
#
# S. C. points out that "arg list too long" error might result.
# Better is              xargs rm -- < filename 
# ( -- covers those cases where "filename" begins with a "-" )

textfile_listing=`ls *.txt`
# Variable contains names of all *.txt files in current working directory.
echo $textfile_listing

textfile_listing2=$(ls *.txt)   # The alternative form of command substitution.
echo $textfile_listing2
# Same result.

# A possible problem with putting a list of files into a single string
# is that a newline may creep in.
#
# A safer way to assign a list of files to a parameter is with an array.
#      shopt -s nullglob    # If no match, filename expands to nothing.
#      textfile_listing=( *.txt )
#
# Thanks, S.C.

		12.8.2 Precaustions and limitations
Note	

Command substitution invokes a subshell.

Caution	

Command substitution may result in word splitting.

COMMAND `echo a b`     # 2 args: a and b

COMMAND "`echo a b`"   # 1 arg: "a b"

COMMAND `echo`         # no arg

COMMAND "`echo`"       # one empty arg


# Thanks, S.C.

Even when there is no word splitting, command substitution can remove trailing newlines.

# cd "`pwd`"  # This should always work.
# However...

mkdir 'dir with trailing newline
'

cd 'dir with trailing newline
'

cd "`pwd`"  # Error message:
# bash: cd: /tmp/file with trailing newline: No such file or directory

cd "$PWD"   # Works fine.





old_tty_setting=$(stty -g)   # Save old terminal setting.
echo "Hit a key "
stty -icanon -echo           # Disable "canonical" mode for terminal.
                             # Also, disable *local* echo.
key=$(dd bs=1 count=1 2> /dev/null)   # Using 'dd' to get a keypress.
stty "$old_tty_setting"      # Restore old setting. 
echo "You hit ${#key} key."  # ${#variable} = number of characters in $variable
#
# Hit any key except RETURN, and the output is "You hit 1 key."
# Hit RETURN, and it's "You hit 0 key."
# The newline gets eaten in the command substitution.

Thanks, S.C.

Caution	Using echo to output an unquoted variable set with command substitution removes trailing newlines characters from the output of the reassigned command(s). This can cause unpleasant surprises.

dir_listing=`ls -l`
echo $dir_listing     # unquoted

# Expecting a nicely ordered directory listing.

# However, what you get is:
# total 3 -rw-rw-r-- 1 bozo bozo 30 May 13 17:15 1.txt -rw-rw-r-- 1 bozo
# bozo 51 May 15 20:57 t2.sh -rwxr-xr-x 1 bozo bozo 217 Mar 5 21:13 wi.sh

# The newlines disappeared.


echo "$dir_listing"   # quoted
# -rw-rw-r--    1 bozo       30 May 13 17:15 1.txt
# -rw-rw-r--    1 bozo       51 May 15 20:57 t2.sh
# -rwxr-xr-x    1 bozo      217 Mar  5 21:13 wi.sh

Command substitution even permits setting a variable to the contents of a file, using either redirection or the cat command.

variable1=`<file1`      #  Set "variable1" to contents of "file1".
variable2=`cat file2`   #  Set "variable2" to contents of "file2".
                        #  This, however, forks a new process,
                        #+ so the line of code executes slower than the above version.

#  Note:
#  The variables may contain embedded whitespace,
#+ or even (horrors), control characters.

#  Excerpts from system file, /etc/rc.d/rc.sysinit
#+ (on a Red Hat Linux installation)


if [ -f /fsckoptions ]; then
        fsckoptions=`cat /fsckoptions`
...
fi
#
#
if [ -e "/proc/ide/${disk[$device]}/media" ] ; then
             hdmedia=`cat /proc/ide/${disk[$device]}/media`
...
fi
#
#
if [ ! -n "`uname -r | grep -- "-"`" ]; then
       ktag="`cat /proc/version`"
...
fi
#
#
if [ $usb = "1" ]; then
    sleep 5
    mouseoutput=`cat /proc/bus/usb/devices 2>/dev/null|grep -E "^I.*Cls=03.*Prot=02"`
    kbdoutput=`cat /proc/bus/usb/devices 2>/dev/null|grep -E "^I.*Cls=03.*Prot=01"`
...
fi

Caution	Do not set a variable to the contents of a long text file unless you have a very good reason for doing so. Do not set a variable to the contents of a binary file, even as a joke.

		12.8.3 Example 11-1. Stupid script tricks

#!/bin/bash
# stupid-script-tricks.sh: Don't try this at home, folks.
# From "Stupid Script Tricks," Volume I.


dangerous_variable=`cat /boot/vmlinuz`   # The compressed Linux kernel itself.

echo "string-length of \$dangerous_variable = ${#dangerous_variable}"
# string-length of $dangerous_variable = 794151
# (Does not give same count as 'wc -c /boot/vmlinuz'.)

# echo "$dangerous_variable"
# Don't try this! It would hang the script.


#  The document author is aware of no useful applications for
#+ setting a variable to the contents of a binary file.

exit 0

Notice that a buffer overrun does not occur. This is one instance where an interpreted language, such as Bash, provides more protection from programmer mistakes than a compiled language.

Command substitution permits setting a variable to the output of a loop. The key to this is grabbing the output of an echo command within the loop.

		12.8.4 Example 11-2. Generating a variable from a loop

#!/bin/bash
# csubloop.sh: Setting a variable to the output of a loop.

variable1=`for i in 1 2 3 4 5
do
  echo -n "$i"                 #  The 'echo' command is critical
done`                          #+ to command substitution here.

echo "variable1 = $variable1"  # variable1 = 12345


i=0
variable2=`while [ "$i" -lt 10 ]
do
  echo -n "$i"                 # Again, the necessary 'echo'.
  let "i += 1"                 # Increment.
done`

echo "variable2 = $variable2"  # variable2 = 0123456789

#  Demonstrates that it's possible to embed a loop
#+ within a variable declaration.

exit 0

		12.8.5 Possibilities of using command substitution
Command substitution makes it possible to extend the toolset available to Bash. It is simply a matter of writing a program or script that outputs to stdout (like a well-behaved UNIX tool should) and assigning that output to a variable.

#include <stdio.h>

/*  "Hello, world." C program  */		

int main()
{
  printf( "Hello, world." );
  return (0);
}

bash$ gcc -o hello hello.c
	      

#!/bin/bash
# hello.sh		

greeting=`./hello`
echo $greeting

bash$ sh hello.sh
Hello, world.
	        

		12.8.6 Note, `` form replaced by $()	

The $(...) form has superseded backticks for command substitution.

output=$(sed -n /"$1"/p $file)   # From "grp.sh"	example.
	      
# Setting a variable to the contents of a text file.
File_contents1=$(cat $file1)      
File_contents2=$(<$file2)        # Bash permits this also.

The $(...) form of command substitution treats a double backslash in a different way than `...`.

bash$ echo `echo \\`


bash$ echo $(echo \\)
\
	      

The $(...) form of command substitution permits nesting. [3]

word_count=$( wc -w $(ls -l | awk '{print $9}') )

Or, for something a bit more elaborate . . .

		12.8.7 $() form, Example 11-3. Finding anagrams

#!/bin/bash
# agram2.sh
# Example of nested command substitution.

#  Uses "anagram" utility
#+ that is part of the author's "yawl" word list package.
#  http://ibiblio.org/pub/Linux/libs/yawl-0.3.2.tar.gz
#  http://personal.riverusers.com/~thegrendel/yawl-0.3.2.tar.gz

E_NOARGS=66
E_BADARG=67
MINLEN=7

if [ -z "$1" ]
then
  echo "Usage $0 LETTERSET"
  exit $E_NOARGS         # Script needs a command-line argument.
elif [ ${#1} -lt $MINLEN ]
then
  echo "Argument must have at least $MINLEN letters."
  exit $E_BADARG
fi



FILTER='.......'         # Must have at least 7 letters.
#       1234567
Anagrams=( $(echo $(anagram $1 | grep $FILTER) ) )
#          $(     $(  nested command sub.    ) )
#        (              array assignment         )

echo
echo "${#Anagrams[*]}  7+ letter anagrams found"
echo
echo ${Anagrams[0]}      # First anagram.
echo ${Anagrams[1]}      # Second anagram.
                         # Etc.

# echo "${Anagrams[*]}"  # To list all the anagrams in a single line . . .

#  Look ahead to the "Arrays" chapter for enlightenment on
#+ what's going on here.

# See also the agram.sh script for an example of anagram finding.

exit $?

[1]	For purposes of command substitution, a command may be an external system command, an internal scripting builtin, or even a script function.
[2]	In a more technically correct sense, command substitution extracts the stdout of a command, then assigns it to a variable using the = operator.
[3]	In fact, nesting with backticks is also possible, but only by escaping the inner backticks, as John Default points out.

word_count=` wc -w \`ls -l | awk '{print $9}'\` `



	12.9 Chapter 12. Arithmetic Expansion
Arithmetic expansion provides a powerful tool for performing (integer) arithmetic operations in scripts. Translating a string into a numerical expression is relatively straightforward using backticks, double parentheses, or let.

Variations

Arithmetic expansion with backticks (often used in conjunction with expr)

    z=`expr $z + 3`          # The 'expr' command performs the expansion.

Arithmetic expansion with double parentheses, and using let

    The use of backticks (backquotes) in arithmetic expansion has been superseded by double parentheses -- ((...)) and $((...)) -- and also by the very convenient let construction.

    z=$(($z+3))
    z=$((z+3))                                  #  Also correct.
                                                #  Within double parentheses,
                                                #+ parameter dereferencing
                                                #+ is optional.

    # $((EXPRESSION)) is arithmetic expansion.  #  Not to be confused with
                                                #+ command substitution.



    # You may also use operations within double parentheses without assignment.

      n=0
      echo "n = $n"                             # n = 0

      (( n += 1 ))                              # Increment.
    # (( $n += 1 )) is incorrect!
      echo "n = $n"                             # n = 1


    let z=z+3
    let "z += 3"  #  Quotes permit the use of spaces in variable assignment.
                  #  The 'let' operator actually performs arithmetic evaluation,
                  #+ rather than expansion.



	12.11 Part 4. Linux Commands
Mastering the commands on your Linux machine is an indispensable prelude to writing effective shell scripts.

This section covers the following commands:

    * . (See also source), execute a text file is if all its lines were bash instructions

    * ac Show users' logged in time, as read from /var/log/wtmp. This is one of the GNU accounting utilities.
bash$ ac
        total       68.08

    * adduser
useradd, userdel

    The useradd administrative command adds a user account to the system and creates a home directory for that particular user, if so specified. The corresponding userdel command removes a user account from the system [2] and deletes associated files.

    Note	The adduser command is a synonym for useradd and is usually a symbolic link to it.

    * agetty
    getty, agetty 
    The initialization process for a terminal uses getty or agetty to set it up for login by a user. These commands are not used within user shell scripts. Their scripting counterpart is stty.

    * agrep
agrep (approximate grep) extends the capabilities of grep to approximate matching. The search string may differ by a specified number of characters from the resulting matches. This utility is not part of the core Linux distribution.

Tip	

To search compressed files, use zgrep, zegrep, or zfgrep. These also work on non-compressed files, though slower than plain grep, egrep, fgrep. They are handy for searching through a mixed set of files, some compressed, some not.

To search bzipped files, use bzgrep.

    * ar
    Creation and manipulation utility for archives, mainly used for binary object file libraries.

    * arch
Show system architecture. Equivalent to uname -m. See Example 10-26.

bash$ arch
i686

bash$ uname -m
i686

    * at
The at job control command executes a given set of commands at a specified time. Superficially, it resembles cron, however, at is chiefly useful for one-time execution of a command set.

at 2pm January 15 prompts for a set of commands to execute at that time. These commands should be shell-script compatible, since, for all practical purposes, the user is typing in an executable shell script a line at a time. Input terminates with a Ctl-D.

Using either the -f option or input redirection (<), at reads a command list from a file. This file is an executable shell script, though it should, of course, be non-interactive. Particularly clever is including the run-parts command in the file to execute a different set of scripts.

bash$ at 2:30 am Friday < at-jobs.list
job 2 at 2000-10-27 02:30
	      
[yizaq@yizaq-lnx:Tue Jul 22:~]$ at 19:37
at> echo "hi Yosi"
at> <EOT>
job 1 at 2008-07-22 19:37

    * autoload
This is a port to Bash of the ksh autoloader. With autoload in place, a function with an autoload declaration will load from an external file at its first invocation.

    * awk (See also Using awk for math operations)
Awk is a full-featured text processing language with a syntax reminiscent of C. While it possesses an extensive set of operators and capabilities, we will cover only a few of these here - the ones most useful in shell scripts.
see kb_awk for full details

    * badblocks
    Checks for bad blocks (physical media flaws) on a storage device. This command finds use when formatting a newly installed hard drive or testing the integrity of backup media. [4]  As an example, badblocks /dev/fd0  tests a floppy disk.

    The badblocks command may be invoked destructively (overwrite all data) or in non-destructive read-only mode. If root user owns the device to be tested, as is generally the case, then root must invoke this command.

    * banner
    Prints arguments as a large vertical banner to stdout, using an ASCII character (default '#'). This may be redirected to a printer for hardcopy.

    Note that banner has been dropped from many Linux distros.

    * basename
Strips the path information from a file name, printing only the file name. The construction basename $0 lets the script know its name, that is, the name it was invoked by. This can be used for "usage" messages if, for example a script is called with missing arguments:

echo "Usage: `basename $0` arg1 arg2 ... argn"

    * batch
    The batch job control command is similar to at, but it runs a command list when the system load drops below .8. Like at, it can read commands from a file with the -f option.

    * bc
    Bash can't handle floating point calculations, and it lacks operators for certain important mathematical functions. Fortunately, bc comes to the rescue.

Not just a versatile, arbitrary precision calculation utility, bc offers many of the facilities of a programming language.

bc has a syntax vaguely resembling C.

Example, as calculator:
[yizaq@yytzhak-wxp:Wed Jul 23:~:]$ bc
bc 1.06
Copyright 1991-1994, 1997, 1998, 2000 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty'. 
time = 20
users = 20000
tps = users/time
print tps
1000

Example, as piped calculator:
[yizaq@yytzhak-wxp:Wed Jul 23:~:]$ echo "50+20" | bc
70


    * bg
    The fg command switches a job running in the background into the foreground. The bg command restarts a suspended job, and runs it in the background. If no job number is specified, then the fg or bg  command acts upon the currently running job.

    * bind

    The bind builtin displays or modifies readline key bindings.
Example:
[yizaq@yytzhak-wxp:Wed Jul 23:~:]$ bind -v
set bind-tty-special-chars on

    * bison
    The lex lexical analyzer produces programs for pattern matching. This has been replaced by the nonproprietary flex on Linux systems.

The yacc utility creates a parser based on a set of specifications. This has been replaced by the nonproprietary bison on Linux systems.


    * builtin
    Invoking builtin BUILTIN_COMMAND runs the command BUILTIN_COMMAND as a shell builtin, temporarily disabling both functions and external system commands with the same name.

    * bzgrep
    To search bzipped  files, use bzgrep.

    * bzip2
    An alternate compression utility, usually more efficient (but slower) than gzip, especially on large files. The corresponding decompression command is bunzip2.

Note	Newer versions of tar have been patched with bzip2 support.

    * cal
Prints a neatly formatted monthly calendar to stdout. Will do current year or a large range of past and future years.

    * caller
    Putting a caller command inside a function  echoes to stdout information about the caller of that function.

    #!/bin/bash

    function1 ()
    {
      # Inside function1 ().
      caller 0   # Tell me about it.
    }

    function1    # Line 9 of script.

    # 9 main test.sh
    # ^                 Line number that the function was called from.
    #   ^^^^            Invoked from "main" part of script.
    #        ^^^^^^^    Name of calling script.

    caller 0     # Has no effect because it's not inside a function.

    A caller command can also return caller information from a script sourced within another script. Analogous to a function, this is a "subroutine call."

    You may find this command useful in debugging.


    * cat
cat, tac

    cat, an acronym for concatenate, lists a file to stdout. When combined with redirection (> or >>), it is commonly used to concatenate files.

    # Uses of 'cat'
    cat filename                          # Lists the file.

    cat file.1 file.2 file.3 > file.123   # Combines three files into one.

    The -n option to cat inserts consecutive numbers before all lines of the target file(s). The -b option numbers only the non-blank lines. The -v option echoes nonprintable characters, using ^ notation. The -s option squeezes multiple consecutive blank lines into a single blank line.

    See also Example 15-28 and Example 15-24.

    Note	

    In a pipe, it may be more efficient to redirect the stdin to a file, rather than to cat the file.

    cat filename | tr a-z A-Z

    tr a-z A-Z < filename   #  Same effect, but starts one less process,
                            #+ and also dispenses with the pipe.

    tac, is the inverse of cat, listing a file backwards from its end.


    * cd
The familiar cd change directory command finds use in scripts where execution of a command requires being in a specified directory.

(cd /source/directory && tar cf - . ) | (cd /dest/directory && tar xpvf -)

[from the previously cited example by Alan Cox]

The -P (physical) option to cd causes it to ignore symbolic links.

cd - changes to $OLDPWD, the previous working directory.

Caution	

The cd command does not function as expected when presented with two forward slashes.

bash$ cd //
bash$ pwd
//
	      

The output should, of course, be /. This is a problem both from the command line and in a script.


    * chattr
Change file attributes. This is analogous to chmod above, but with different options and a different invocation syntax, and it works only on ext2/ext3 filesystems.

One particularly interesting chattr option is i. A chattr +i filename marks the file as immutable. The file cannot be modified, linked to, or deleted, not even by root. This file attribute can be set or removed only by root. In a similar fashion, the a option marks the file as append only.

root# chattr +i file1.txt


root# rm file1.txt

rm: remove write-protected regular file `file1.txt'? y
 rm: cannot remove `file1.txt': Operation not permitted
	      

If a file has the s (secure) attribute set, then when it is deleted its block is zeroed out on the disk.

If a file has the u (undelete) attribute set, then when it is deleted, its contents can still be retrieved (undeleted).

If a file has the c (compress) attribute set, then it will automatically be compressed on writes to disk, and uncompressed on reads.

Note	The file attributes set with chattr do not show in a file listing (ls -l).

    * chfn
Change information disclosed by the finger command.

id=__chgrp
    * chgrp
The chown command changes the ownership of a file or files. This command is a useful method that root can use to shift file ownership from one user to another. An ordinary user may not change the ownership of files, not even her own files. [1]

root# chown bozo *.txt

	      

The chgrp command changes the group ownership of a file or files. You must be owner of the file(s) as well as a member of the destination group (or root) to use this operation.

chgrp --recursive dunderheads *.data
#  The "dunderheads" group will now own all the "*.data" files
#+ all the way down the $PWD directory tree (that's what "recursive" means).

    * chkconfig
Check network and system configuration. This command lists and manages the network and system services started at bootup in the /etc/rc?.d  directory.

Originally a port from IRIX to Red Hat Linux, chkconfig may not be part of the core installation of some Linux flavors.

bash$ chkconfig --list
atd             0:off   1:off   2:off   3:on    4:on    5:on    6:off
 rwhod           0:off   1:off   2:off   3:off   4:off   5:off   6:off
 ...
	      

    * chmod
Changes the attributes of an existing file or directory (see Example 14-13).

chmod +x filename
# Makes "filename" executable for all users.

chmod u+s filename
# Sets "suid" bit on "filename" permissions.
# An ordinary user may execute "filename" with same privileges as the file's owner.
# (This does not apply to shell scripts.)

chmod 644 filename
# Makes "filename" readable/writable to owner, readable to others
# (octal mode).

chmod 444 filename
#  Makes "filename" read-only for all.
#  Modifying the file (for example, with a text editor)
#+ not allowed for a user who does not own the file (except for root),
#+ and even the file owner must force a file-save
#+ if she modifies the file.
#  Same restrictions apply for deleting the file.

chmod 1777 directory-name
#  Gives everyone read, write, and execute permission in directory,
#+ however also sets the "sticky bit".
#  This means that only the owner of the directory,
#+ owner of the file, and, of course, root
#+  can delete any particular file in that directory.

chmod 111 directory-name
#  Gives everyone execute-only permission in a directory.
#  This means that you can execute and READ the files in that directory
#+ (execute permission necessarily includes read permission
#+ because you can't execute a file without being able to read it).
#  But you can't list the files or search for them with the "find" command.
#  These restrictions do not apply to root.

chmod 000 directory-name
#  No permissions at all for that directory.
#  Can't read, write, or execute files in it.
#  Can't even list files in it or "cd" to it.
#  But, you can rename (mv) the directory
#+ or delete it (rmdir) if it is empty.
#  You can even symlink to files in the directory,
#+ but you can't read, write, or execute the symlinks.
#  These restrictions do not apply to root.

    * chown

<URL:#r=__chgrp>

    * chroot
CHange ROOT directory. Normally commands are fetched from $PATH, relative to /, the default root directory. This changes the root directory to a different one (and also changes the working directory to there). This is useful for security purposes, for instance when the system administrator wishes to restrict certain users, such as those telnetting in, to a secured portion of the filesystem (this is sometimes referred to as confining a guest user to a "chroot jail"). Note that after a chroot, the execution path for system binaries is no longer valid.

A chroot /opt would cause references to /usr/bin to be translated to /opt/usr/bin. Likewise, chroot /aaa/bbb /bin/ls would redirect future instances of ls to /aaa/bbb as the base directory, rather than / as is normally the case. An alias XX 'chroot /aaa/bbb ls' in a user's ~/.bashrc effectively restricts which portion of the filesystem she may run command "XX" on.

The chroot command is also handy when running from an emergency boot floppy (chroot to /dev/fd0), or as an option to lilo when recovering from a system crash. Other uses include installation from a different filesystem (an rpm option) or running a readonly filesystem from a CD ROM. Invoke only as root, and use with care.

Caution	

It might be necessary to copy certain system files to a chrooted directory, since the normal $PATH can no longer be relied upon.


    * cksum
These are utilities for generating checksums. A checksum is a number mathematically calculated from the contents of a file, for the purpose of checking its integrity. A script might refer to a list of checksums for security purposes, such as ensuring that the contents of key system files have not been altered or corrupted. For security applications, use the md5sum (message digest 5  checksum) command, or better yet, the newer sha1sum (Secure Hash Algorithm).

bash$ cksum /boot/vmlinuz
1670054224 804083 /boot/vmlinuz

bash$ echo -n "Top Secret" | cksum
3391003827 10



bash$ md5sum /boot/vmlinuz
0f43eccea8f09e0a0b2b5cf1dcf333ba  /boot/vmlinuz

bash$ echo -n "Top Secret" | md5sum
8babc97a6f62a4649716f4df8d61728f  -
	      

Note	

The cksum command shows the size, in bytes, of its target, whether file or stdout.

The md5sum and sha1sum commands display a dash when they receive their input from stdout.

    * clear
The clear command simply clears the text screen at the console or in an xterm. The prompt and cursor reappear at the upper lefthand corner of the screen or xterm window. This command may be used either at the command line or in a script.

    * clock
    The hwclock command accesses or adjusts the machine's hardware clock. Some options require root privileges. The /etc/rc.d/rc.sysinit startup file uses hwclock to set the system time from the hardware clock at bootup.

    The clock command is a synonym for hwclock.

    * cmp
The cmp command is a simpler version of diff, above. Whereas diff  reports the differences between two files, cmp merely shows at what point they differ.

Note	Like diff, cmp returns an exit status of 0 if the compared files are identical, and 1 if they differ. This permits use in a test construct within a shell script.

Use zcmp on gzipped files.

    * col
    This deceptively named filter removes reverse line feeds from an input stream. It also attempts to replace whitespace with equivalent tabs. The chief use of col is in filtering the output from certain text processing utilities, such as groff and tbl.

    * colrm
Column removal filter. This removes columns (characters) from a file and writes the file, lacking the range of specified columns, back to stdout. colrm 2 4 <filename removes the second through fourth characters from each line of the text file filename.

Caution	

If the file contains tabs or nonprintable characters, this may cause unpredictable behavior. In such cases, consider using expand and unexpand in a pipe preceding colrm.

    * column
    Column formatter. This filter transforms list-type text output into a "pretty-printed" table by inserting tabs at appropriate places.

Example 15-27. Using column to format a directory listing

#!/bin/bash
# colms.sh
# A minor modification of the example file in the "column" man page.


(printf "PERMISSIONS LINKS OWNER GROUP SIZE MONTH DAY HH:MM PROG-NAME\n" \
; ls -l | sed 1d) | column -t
#         ^^^^^^           ^^

#  The "sed 1d" in the pipe deletes the first line of output,
#+ which would be "total        N",
#+ where "N" is the total number of files found by "ls -l".

# The -t option to "column" pretty-prints a table.

exit 0

    * comm
        Versatile file comparison utility. The files must be sorted for this to be useful.

    comm -options first-file second-file

    comm file-1 file-2 outputs three columns:

        *

          column 1 = lines unique to file-1
        *

          column 2 = lines unique to file-2
        *

          column 3 = lines common to both.

    The options allow suppressing output of one or more columns.

        *

          -1 suppresses column 1
        *

          -2 suppresses column 2
        *

          -3 suppresses column 3
        *

          -12 suppresses both columns 1 and 2, etc.

    This command is useful for comparing "dictionaries" or word lists -- sorted text files with one word per line.

    
    * command
    The command directive disables aliases and functions for the command immediately following it.

bash$ command ls
              

Note	This is one of three shell directives that effect script command processing. The others are builtin and enable.

    * compress
    This is an older, proprietary compression utility found in commercial UNIX distributions. The more efficient gzip has largely replaced it. Linux distributions generally include a compress workalike for compatibility, although gunzip can unarchive files treated with compress.

Tip	

The znew command transforms compressed files into gzipped ones.

    * cp
    This is the file copy command. cp file1 file2 copies file1  to file2, overwriting file2 if it already exists (see Example 15-6).

Tip	

Particularly useful are the -a archive flag (for copying an entire directory tree), the -u update flag (which prevents overwriting identically-named newer files), and the -r and -R recursive flags.

cp -u source_dir/* dest_dir
#  "Synchronize" dest_dir to source_dir
#+  by copying over all newer and not previously existing files.

    * cpio
    This specialized archiving copy command (copy input and output) is rarely seen any more, having been supplanted by tar/gzip. It still has its uses, such as moving a directory tree. With an appropriate block size (for copying) specified, it can be appreciably faster than tar.

Example 15-30. Using cpio to move a directory tree

#!/bin/bash

# Copying a directory tree using cpio.

# Advantages of using 'cpio':
#   Speed of copying. It's faster than 'tar' with pipes.
#   Well suited for copying special files (named pipes, etc.)
#+  that 'cp' may choke on.

ARGS=2
E_BADARGS=65

if [ $# -ne "$ARGS" ]
then
  echo "Usage: `basename $0` source destination"
  exit $E_BADARGS
fi  

source="$1"
destination="$2"

###################################################################
find "$source" -depth | cpio -admvp "$destination"
#               ^^^^^         ^^^^^
#  Read the 'find' and 'cpio' info pages to decipher these options.
#  The above works only relative to $PWD (current directory) . . .
#+ full pathnames are specified.
###################################################################


# Exercise:
# --------

#  Add code to check the exit status ($?) of the 'find | cpio' pipe
#+ and output appropriate error messages if anything went wrong.

exit $?


    * cron
    Administrative program scheduler, performing such duties as cleaning up and deleting system log files and updating the slocate database. This is the superuser version of at (although each user may have their own crontab file which can be changed with the crontab command). It runs as a daemon  and executes scheduled entries from /etc/crontab.

Note	

Some flavors of Linux run crond, Matthew Dillon's version of cron.

    * crypt
    At one time, this was the standard UNIX file encryption utility. [3]  Politically motivated government regulations prohibiting the export of encryption software resulted in the disappearance of crypt  from much of the UNIX world, and it is still missing from most Linux distributions. Fortunately, programmers have come up with a number of decent alternatives to it, among them the author's very own cruft

    * csplit
    These are utilities for splitting a file into smaller chunks. Their usual use is for splitting up large files in order to back them up on floppies or preparatory to e-mailing or uploading them.

The csplit command splits a file according to context, the split occuring where patterns are matched.

Example 15-37. A script that copies itself in sections

#!/bin/bash
# splitcopy.sh

#  A script that splits itself into chunks,
#+ then reassembles the chunks into an exact copy
#+ of the original script.

CHUNKSIZE=4    #  Size of first chunk of split files.
OUTPREFIX=xx   #  csplit prefixes, by default,
               #+ files with "xx" ...

csplit "$0" "$CHUNKSIZE"

# Some comment lines for padding . . .
# Line 15
# Line 16
# Line 17
# Line 18
# Line 19
# Line 20

cat "$OUTPREFIX"* > "$0.copy"  # Concatenate the chunks.
rm "$OUTPREFIX"*               # Get rid of the chunks.

exit $?

    * cu
    uucp: UNIX to UNIX copy. This is a communications package for transferring files between UNIX servers. A shell script is an effective way to handle a uucp  command sequence.

    Since the advent of the Internet and e-mail, uucp seems to have faded into obscurity, but it still exists and remains perfectly workable in situations where an Internet connection is not available or appropriate. The advantage of uucp is that it is fault-tolerant, so even if there is a service interruption the copy operation will resume where it left off when the connection is restored.

    ---

    uux: UNIX to UNIX execute. Execute a command on a remote system. This command is part of the uucp package.

    ---

    cu: Call Up a remote system and connect as a simple terminal. It is a sort of dumbed-down version of telnet. This command is part of the uucp package.

    * cut
    A tool for extracting fields from files. It is similar to the print $N command set in awk, but more limited. It may be simpler to use cut in a script than awk. Particularly important are the -d (delimiter) and -f  (field specifier) options.

Using cut to obtain a listing of the mounted filesystems:

cut -d ' ' -f1,2 /etc/mtab

Using cut to list the OS and kernel version:

uname -a | cut -d" " -f1,3,11,12

Using cut to extract message headers from an e-mail folder:

bash$ grep '^Subject:' read-messages | cut -c10-80
Re: Linux suitable for mission-critical apps?
 MAKE MILLIONS WORKING AT HOME!!!
 Spam complaint
 Re: Spam complaint

Using cut to parse a file:

# List all the users in /etc/passwd.

FILENAME=/etc/passwd

for user in $(cut -d: -f1 $FILENAME)
do
  echo $user
done

# Thanks, Oleg Philon for suggesting this.

cut -d ' ' -f2,3 filename is equivalent to awk -F'[ ]' '{ print $2, $3 }' filename

Note	

It is even possible to specify a linefeed as a delimiter. The trick is to actually embed a linefeed (RETURN) in the command sequence.

bash$ cut -d'
 ' -f3,7,19 testfile
This is line 3 of testfile.
 This is line 7 of testfile.
 This is line 19 of testfile.
	      

Thank you, Jaka Kranjc, for pointing this out.

    * date
    Simply invoked, date prints the date and time to stdout. Where this command gets interesting is in its formatting and parsing options.

    * dc
    The dc (desk calculator) utility is stack-oriented and uses RPN ("Reverse Polish Notation"). Like bc, it has much of the power of a programming language.

    * dd
    This is the somewhat obscure and much feared data duplicator command. Originally a utility for exchanging data on magnetic tapes between UNIX minicomputers and IBM mainframes, this command still has its uses. The dd command simply copies a file (or stdin/stdout), but with conversions. Possible conversions are ASCII/EBCDIC, [4]  upper/lower case, swapping of byte pairs between input and output, and skipping and/or truncating the head or tail of the input file.

    * debugfs
    Filesystem check, repair, and debug command set.

fsck: a front end for checking a UNIX filesystem (may invoke other utilities). The actual filesystem type generally defaults to ext2.

e2fsck: ext2 filesystem checker.

debugfs: ext2 filesystem debugger. One of the uses of this versatile, but dangerous command is to (attempt to) recover deleted files. For advanced users only!

Caution	

All of these should be invoked as root, and they can damage or destroy a filesystem if misused.

    * declare
    The declare or typeset builtins, which are exact synonyms, permit modifying the properties of variables.

    * depmod
    Creates module dependency file. Usually invoked from a startup script.

    * df
    Shows filesystem usage in tabular form.

bash$ df
Filesystem           1k-blocks      Used Available Use% Mounted on
 /dev/hda5               273262     92607    166547  36% /
 /dev/hda8               222525    123951     87085  59% /home
 /dev/hda7              1408796   1075744    261488  80% /usr

    * dialog
    The dialog family of tools offers a method of calling "dialog" widgets from a shell script. The original dialog utility works in a text console, but its successors, gdialog, Xdialog, and kdialog  use X-Windows-based widget sets.

    * diff
    diff: flexible file comparison utility. It compares the target files line-by-line sequentially. In some applications, such as comparing word dictionaries, it may be helpful to filter the files through sort  and uniq before piping them to diff. diff file-1 file-2 outputs the lines in the files that differ, with carets showing which file each particular line belongs to.

The --side-by-side option to diff outputs each compared file, line by line, in separate columns, with non-matching lines marked. The -c and -u options likewise make the output of the command easier to interpret.

There are available various fancy frontends for diff, such as sdiff, wdiff, xdiff, and mgdiff.

Tip	

The diff command returns an exit status of 0 if the compared files are identical, and 1 if they differ. This permits use of diff in a test construct within a shell script (see below).

A common use for diff is generating difference files to be used with patch The -e option outputs files suitable for ed or ex scripts.

    * diff3
        An extended version of diff that compares three files at a time. This command returns an exit value of 0 upon successful execution, but unfortunately this gives no information about the results of the comparison.

    bash$ diff3 file-1 file-2 file-3
    ====
     1:1c
       This is line 1 of "file-1".
     2:1c
       This is line 1 of "file-2".
     3:1c
       This is line 1 of "file-3"
    	      

    The merge (3-way file merge) command is an interesting adjunct to diff3. Its syntax is merge Mergefile file1 file2. The result is to output to Mergefile the changes that lead from file1 to file2. Consider this command a stripped-down version of patch.

    * diffstat
    Use diffstat to create a histogram (point-distribution graph) of output from diff.

    * dig
    Domain Information Groper. Similar to nslookup, dig does an Internet name server lookup on a host. May be run from the command line or from within a script.

Some interesting options to dig are +time=N for setting a query timeout to N seconds, +nofail for continuing to query servers until a reply is received, and -x for doing a reverse address lookup.

    * dirname
    Strips the basename from a filename, printing only the path information.

Note	

basename and dirname can operate on any arbitrary string. The argument does not need to refer to an existing file, or even be a filename for that matter

    * dirs
    This command set is a mechanism for bookmarking working directories, a means of moving back and forth through directories in an orderly manner. A pushdown stack is used to keep track of directory names. Options allow various manipulations of the directory stack.

pushd dir-name pushes the path dir-name onto the directory stack and simultaneously changes the current working directory to dir-name

popd removes (pops) the top directory path name off the directory stack and simultaneously changes the current working directory to that directory popped from the stack.

dirs lists the contents of the directory stack (compare this with the $DIRSTACK variable). A successful pushd or popd will automatically invoke dirs.

    * disown
    Remove job(s) from the shell's table of active jobs.

    * dmesg
    Lists all system bootup messages to stdout. Handy for debugging and ascertaining which device drivers were installed and which system interrupts in use. The output of dmesg may, of course, be parsed with grep, sed, or awk from within a script.

bash$ dmesg | grep hda
Kernel command line: ro root=/dev/hda2
 hda: IBM-DLGA-23080, ATA DISK drive
 hda: 6015744 sectors (3080 MB) w/96KiB Cache, CHS=746/128/63
 hda: hda1 hda2 hda3 < hda5 hda6 hda7 > hda4

    * doexec
    The doexec command enables passing an arbitrary list of arguments to a binary executable. In particular, passing argv[0] (which corresponds to $0 in a script) lets the executable be invoked by various names, and it can then carry out different sets of actions, according to the name by which it was called. What this amounts to is roundabout way of passing options to an executable.

For example, the /usr/local/bin directory might contain a binary called "aaa". Invoking doexec /usr/local/bin/aaa list would list all those files in the current working directory beginning with an "a", while invoking (the same executable with) doexec /usr/local/bin/aaa delete would delete those files.

Note	

The various behaviors of the executable must be defined within the code of the executable itself, analogous to something like the following in a shell script:

case `basename $0` in
"name1" ) do_something;;
"name2" ) do_something_else;;
"name3" ) do_yet_another_thing;;
*       ) bail_out;;
esac

    * dos2unix
    This utility, written by Benjamin Lin and collaborators, converts DOS-formatted text files (lines terminated by CR-LF) to UNIX format (lines terminated by LF only), and vice-versa.

    * du
    * dump
    * dumpe2fs
    * e2fsck
    * echo
    * egrep
    * enable
    * enscript
    * env
    * eqn
    * eval
    * exec
    * exit (Related topic: exit status)
    * expand
    * export
    * expr
    * factor
    * false
    * fdformat
    * fdisk
    * fg
    * fgrep
    * file
    * find
    * finger
    * flex
    * flock
    * fmt
    * fold
    * free
    * fsck
    * ftp
    * fuser
    * getopt
    * getopts
    * gettext
    * getty
    * gnome-mount
    * grep
    * groff
    * groupmod
    * groups (Related topic: the $GROUPS variable)
    * gs
    * gzip
    * halt
    * hash
    * hdparm
    * head
    * help
    * hexdump
    * host
    * hostid
    * hostname (Related topic: the $HOSTNAME variable)
    * hwclock
    * iconv
    * id (Related topic: the $UID variable)
    * ifconfig
    * info
    * infocmp
    * init
    * insmod
    * install
    * ip
    * ipcalc
    * iwconfig
    * jobs
    * join
    * jot
    * kill
    * killall
    * last
    * lastcomm
    * lastlog
    * ldd
    * less
    * let
    * lex
    * ln
    * locate
    * lockfile
    * logger
    * logname
    * logout
    * logrotate
    * look
    * losetup
    * lp
    * ls
    * lsdev
    * lsmod
    * lsof
    * lspci
    * lsusb
    * ltrace
    * lynx
    * lzcat
    * lzma
    * m4
    * mail
    * mailstats
    * mailto
    * make
    * MAKEDEV
    * man
    * mcookie
    * md5sum
    * merge
    * mesg
    * mimencode
    * mkbootdisk
    * mkdir
    * mke2fs
    * mkfifo
    * mkisofs
    * mknod
    * mkswap
    * mktemp
    * mmencode
    * modinfo
    * modprobe
    * more
    * mount
    * msgfmt
    * mv
    * nc
    * netconfig
    * netstat
    * newgrp
    * nice
    * nl
    * nm
    * nmap
    * nohup
    * nslookup
    * objdump
    * od
    * passwd
    * paste
    * patch (Related topic: diff)
    * pathchk
    * perl
    * pgrep
    * pidof
    return the process ID of list of process names. pidof process1 process2 ...
    * ping
    * pkill
    * popd
    * pr
    * printenv
    * printf
    * procinfo
    * ps
    * pstree
    * ptx
    * pushd
    * pwd (Related topic: the $PWD variable)
    * python
    * quota
    * rcp
    * rdev
    * rdist
    * read
    * readelf
    * readlink
    * readonly
    * reboot
    * recode
    * renice
    * reset
    * resize
    * restore
    * rev
    * rlogin
    * rm
    * rmdir
    * rmmod
    * route
    * rpm
    * rpm2cpio
    * rsh
    * rsync
    * runlevel
    * run-parts
    * rx
    * rz
    * sar
    * scp
    * script
    * sdiff
    * sed
    * seq
    * service
    * set
    * setquota
    * setserial
    * setterm
    * sha1sum
    * shar
    * shopt
    * shred
    * shutdown
    * size
    * skill
    * sleep
    * slocate
    * snice
    * sort
    * source
    * sox
    * split
    * sq
    * ssh
    * stat
    * strace
    * strings
    * strip
    * stty
    * su
    * sudo
    * sum
    * suspend
    * swapoff
    * swapon
    * sx
    * sync
    * sz
    * tac
    * tail
    * tar
    * tbl
    * tcpdump
    * tee
    * telinit
    * telnet
    * Tex
    * texexec
    * time
    * times
    * tmpwatch
    * top
    * touch
    * tput
    * tr
    * traceroute
    * true
    * tset
    * tsort
    * tty
    * tune2fs
    * type
    * typeset
    * ulimit
    * umask
    * umount
    * uname
    * unarc
    * unarj
    * uncompress
    * unexpand
    * uniq
    * units
    * unlzma
    * unrar
    * unset
    * unsq
    * unzip
    * uptime
    * usbmodules
    * useradd
    * userdel
    * usermod
    * users
    * usleep
    * uucp
    * uudecode
    * uuencode
    * uux
    * vacation
    * vdir
    * vmstat
    * vrfy
    * w
    * wait
    * wall
    * watch
    * wc
    * wget
    * whatis
    * whereis
    * which
    * who
    * whoami
    * whois
    * write
    * xargs
    * yacc
    * yes
    * zcat
    * zdiff
    * zdump
    * zegrep
    * zfgrep
    * zgrep
    * zip



		12.11.1 Chapter 14. Internal Commands and Builtins

A builtin is a command contained within the Bash tool set, literally built in. This is either for performance reasons -- builtins execute faster than external commands, which usually require forking off a separate process -- or because a particular builtin needs direct access to the shell internals.

When a command or the shell itself initiates (or spawns) a new subprocess to carry out a task, this is called forking. This new process is the child, and the process that forked it off is the parent. While the child process is doing its work, the parent process is still executing.

Note that while a parent process gets the process ID of the child process, and can thus pass arguments to it, the reverse is not true. This can create problems that are subtle and hard to track down.

			12.11.1.1 Example 14-1. A script that forks off multiple instances of itself

#!/bin/bash
# spawn.sh


PIDS=$(pidof sh $0)  # Process IDs of the various instances of this script. 
P_array=( $PIDS )    # Put them in an array (why?).
echo $PIDS           # Show process IDs of parent and child processes.
let "instances = ${#P_array[*]} - 1"  # Count elements, less 1.
                                      # Why subtract 1?
echo "$instances instance(s) of this script running."
echo "[Hit Ctl-C to exit.]"; echo


sleep 1              # Wait.
sh $0                # Play it again, Sam.

exit 0               # Not necessary; script will never get to here.
                     # Why not?

#  After exiting with a Ctl-C,
#+ do all the spawned instances of the script die?
#  If so, why?

# Note:
# ----
# Be careful not to run this script too long.
# It will eventually eat up too many system resources.

#  Is having a script spawn multiple instances of itself
#+ an advisable scripting technique.
#  Why or why not?

Generally, a Bash builtin does not fork a subprocess when it executes within a script. An external system command or filter in a script usually will fork a subprocess.

A builtin may be a synonym to a system command of the same name, but Bash reimplements it internally. For example, the Bash echo command is not the same as /bin/echo, although their behavior is almost identical.

#!/bin/bash

echo "This line uses the \"echo\" builtin."
/bin/echo "This line uses the /bin/echo system command."

A keyword is a reserved word, token or operator. Keywords have a special meaning to the shell, and indeed are the building blocks of the shell's syntax. As examples, for, while, do, and ! are keywords. Similar to a builtin, a keyword is hard-coded into Bash, but unlike a builtin, a keyword is not in itself a command, but a subunit of a command construct. [1]

			12.11.1.2 I/O

				12.11.1.2.1 echo

    prints (to stdout) an expression or variable (see Example 4-1).

    echo Hello
    echo $a

    An echo requires the -e option to print escaped characters. See Example 5-2.

    Normally, each echo command prints a terminal newline, but the -n option suppresses this.

    Note	An echo can be used to feed a sequence of commands down a pipe.

    if echo "$VAR" | grep -q txt   # if [[ $VAR = *txt* ]]
    then
      echo "$VAR contains the substring sequence \"txt\""
    fi

    Note	An echo, in combination with command substitution can set a variable.

    a=`echo "HELLO" | tr A-Z a-z`


    Be aware that echo `command` deletes any linefeeds that the output of command generates.

    The $IFS (internal field separator) variable normally contains \n (linefeed) as one of its set of whitespace characters. Bash therefore splits the output of command at linefeeds into arguments to echo. Then echo outputs these arguments, separated by spaces.

    bash$ ls -l /usr/share/apps/kjezz/sounds
    -rw-r--r--    1 root     root         1407 Nov  7  2000 reflect.au
     -rw-r--r--    1 root     root          362 Nov  7  2000 seconds.au




    bash$ echo `ls -l /usr/share/apps/kjezz/sounds`
    total 40 -rw-r--r-- 1 root root 716 Nov 7 2000 reflect.au -rw-r--r-- 1 root root ...
    	      

    So, how can we embed a linefeed within an echoed character string?

    # Embedding a linefeed?
    echo "Why doesn't this string \n split on two lines?"
    # Doesn't split.

    # Let's try something else.

    echo
    	     
    echo $"A line of text containing
    a linefeed."
    # Prints as two distinct lines (embedded linefeed).
    # But, is the "$" variable prefix really necessary?

    echo

    echo "This string splits
    on two lines."
    # No, the "$" is not needed.

    echo
    echo "---------------"
    echo

    echo -n $"Another line of text containing
    a linefeed."
    # Prints as two distinct lines (embedded linefeed).
    # Even the -n option fails to suppress the linefeed here.

    echo
    echo
    echo "---------------"
    echo
    echo

    # However, the following doesn't work as expected.
    # Why not? Hint: Assignment to a variable.
    string1=$"Yet another line of text containing
    a linefeed (maybe)."

    echo $string1
    # Yet another line of text containing a linefeed (maybe).
    #                                    ^
    # Linefeed becomes a space.

    # Thanks, Steve Parker, for pointing this out.

    Note	This command is a shell builtin, and not the same as /bin/echo, although its behavior is similar.

    bash$ type -a echo
    echo is a shell builtin
     echo is /bin/echo
    	      

				12.11.1.2.2 printf, formatted print, formatting output

    The printf, formatted print, command is an enhanced echo. It is a limited variant of the C language printf() library function, and its syntax is somewhat different.

    printf format-string... parameter...

    This is the Bash builtin version of the /bin/printf or /usr/bin/printf command. See the printf manpage (of the system command) for in-depth coverage.

    Caution	Older versions of Bash may not support printf.

    Example 14-2. printf in action

    #!/bin/bash
    # printf demo

    PI=3.14159265358979
    DecimalConstant=31373
    Message1="Greetings,"
    Message2="Earthling."

    echo

    printf "Pi to 2 decimal places = %1.2f" $PI
    echo
    printf "Pi to 9 decimal places = %1.9f" $PI  # It even rounds off correctly.

    printf "\n"                                  # Prints a line feed,
                                                 # Equivalent to 'echo' . . .

    printf "Constant = \t%d\n" $DecimalConstant  # Inserts tab (\t).

    printf "%s %s \n" $Message1 $Message2

    echo

    # ==========================================#
    # Simulation of C function, sprintf().
    # Loading a variable with a formatted string.

    echo 

    Pi12=$(printf "%1.12f" $PI)
    echo "Pi to 12 decimal places = $Pi12"      # Roundoff error!

    Msg=`printf "%s %s \n" $Message1 $Message2`
    echo $Msg; echo $Msg

    #  As it happens, the 'sprintf' function can now be accessed
    #+ as a loadable module to Bash,
    #+ but this is not portable.

    exit 0

    Formatting error messages is a useful application of printf

    E_BADDIR=65

    var=nonexistent_directory

    error()
    {
      printf "$@" >&2
      # Formats positional params passed, and sends them to stderr.
      echo
      exit $E_BADDIR
    }

    cd $var || error $"Can't cd to %s." "$var"

    # Thanks, S.C.


					12.11.1.2.2.1 The printf command

Unlike other documentations, I don't want to redirect you to the manual page for the printf() C function family. However, if you're more experienced, that should be the most detailed description for the format strings and modifiers.

Due to mutual exclusive historical implementations of the echo command, POSIX recommends to use printf rather than echo.
General

The printf command provides a method to print preformatted text similar to the printf() system interface (C function). It's meant as successor for echo and has far more features and possibilities.

Beside other reasons, POSIX has a very good argument to recommend it: Both historical main flavours of the echo command are mutual exclusive, they collide. A "new" command had to be invented to solve the issue.
Syntax

printf <FORMAT> <ARGUMENTS...>

The text format is given in <FORMAT>, while all arguments the formatstring may point to are given after that, here, indicated by <ARGUMENTS...>.

Thus, a typical printf-call looks like:

printf "Surname: %s\nName: %s\n" "$SURNAME" "$LASTNAME"

where "Surname: %s\nName: %s\n" is the format specification, and the two variables are passed as arguments, the %s in the formatstring points to (for every format specifier you give, printf awaits one argument!).
Options
-v VAR	If given, the output is assigned to the variable VAR instead of printed to stdout (comparable to sprintf() in some way)

The -v Option can't assign directly to array indexes in Bash versions older than Bash 4.1
Arguments

Of course in shell-meaning the arguments are just strings, however, the common C-notations plus some additions for number-constants are recognized to give a number-argument to printf:
Number-Format	Description
N	A normal decimal number
0N	An octal number
0xN	A hexadecimal number
0XN	A hexadecimal number
"X	(a literal double-quote infront of a character): interpreted as number (underlying codeset) don't forget escaping
'X	(a literal single-quote infront of a character): interpreted as number (underlying codeset) don't forget escaping

If more arguments than format specifiers are present, then the format string is re-used until the last argument is interpreted. If less format specifiers than arguments are present, then number-formats are set to zero, while string-formats are set to null (empty).

Also, to minimize surprises, when printf expects an argument, give it one, not more. I'm talking about shell word splitting, please read this article if you don't know what I mean.

Again, attention: When a numerical format expects a number, the internal printf-command will use the common Bash arithmetic rules regarding the base. A command like the following example will throw an error, since 08 is not a valid octal number (00 to 07!):

printf "%d\n" 08

Format strings

FIXME incomplete

The format string interpretion is derived from the C printf() function family. Only format specifiers that end in one of the letters diouxXfeEgGcs are recognized.

To print a literal % (percent-sign), use %% in the format string.

Again: Every format specifier expects an associated argument provided!
Format	Description
%b	Print the associated argument while interpreting backslash escapes in there
%q	Print the associated argument shell-quoted, reusable as input
%d	Print the associated argument as signed decimal number
%i	Same as %d
%o	Print the associated argument as unsigned octal number
%u	Print the associated argument as unsigned decimal number
%x	Print the associated argument as unsigned hexadecimal number with lower-case hex-digits (a-f)
%X	Same as %x, but with upper-case hex-digits (A-F)
%f	Interpret and print the associated argument as floating point number
%e	Interpret the associated argument as double, and print it in <N>e<N> format
%E	Same as %e, but with an upper-case E in the printed format
%g	Interprets the associated argument as double, but prints it like %f or %e
%G	Same as %g, but print it like %E
%c	Interprets the associated argument as character: only the first character of a given argument is printed
%s	Interprets the associated argument literally as string
%b	Interprets the associated argument as a string and interpreting escape sequences in it
%q	Prints the associated argument in a format, that it can be re-used as shell-input (escaped spaces etc..)
%n	No conversion or printing is done. Assigns the number of so far printed characters to the variable named in the corresponding argument (similat to C's printf)
%%	No conversion is done. Produces a % (percent sign)

Some of the mentioned format specifiers can modify their behaviour by getting a format modifier:
Modifiers

To be more flexible in the output of numbers and strings, the printf command allows format modifiers. These are specified between the introducting % and the character that specifies the format:

printf "%50s\n" "This field is 50 characters wide..."

Field and printing modifiers
Field output format
<N>	Any number: Specifies a minimum field width, if the text to print is smaller, it's padded with spaces, if the text is bigger, the field is expanded
.	The dot: Together with a field width, the field is not expanded when the text is bigger, the text is cutted instead. "%.s" is an undocumented equivalent for "%.0s", which will force a field width of zero, effectively hiding the field from output
*	The asterisk: the width is given as argument before the string or number. Usage (the "*" corresponds to the "20"): printf "%*s\n" 20 "test string"
#	"Alternative format" for numbers: see table below
-	Left-bound text printing in the field (standard is right-bound)
0	Pads numbers with zeros, not spaces
<space>	Pad a positive number with a space, where a minus (-) is for negative numbers
+	Prints all numbers signed (+ for positive, - for negative)

The "alternative format" modifier #:
Alternative Format
%#o	The octal number is printed with a leading zero, unless it's zero itself
%#x, %#X	The hex number is printed with a leading "0x"/"0X", unless it's zero
%#g, %#G	The float number is printed with trailing zeros until the number of digits for the current precision is reached (usually trailing zeros are not printed)
all number formats except %d, %o, %x, %X	Always print a decimal point in the output, even if no digits follow it
Precision

The precision for a floating- or double-number can be specified by using .<DIGITS>, where <DIGITS> is the number of digits for precision. If <DIGITS> is an asterisk (*), the precision is read from the argument that precedes the number to print, like (prints 4,3000000000):

printf "%.*f\n" 10 4,3

The format .*N to specify the N'th argument for precision does not work in Bash.

For strings, the precision specifies the maximum number of characters to print (i.e. the maximum field width). For integers, it specifies the number of digits to print (zero-padding!).
Escape codes
Code	Description
\\	Prints the character \ (backslash)
\a	Prints the alert character (ASCII code 7 decimal)
\b	Prints a backspace
\f	Prints a form-feed
\n	Prints a newline
\r	Prints a carriage-return
\t	Prints a horizontal tabulator
\v	Prints a vertical tabulator
\"	Prints a '
\?	Prints a ?
\<NNN>	Interprets <NNN> as octal number and prints the corresponding character from the character set
\0<NNN>	same as \<NNN>
\x<NNN>	Interprets <NNN> as hexadecimal number and prints the corresponding character from the character set (3 digits)
\u<NNNN>	same as \x<NNN>, but 4 digits
\U<NNNNNNNN>	same as \x<NNN>, but 8 digits
Examples
Snipplets

    *
      print the decimal representation of a hexadecimal number (preserve the sign)
          o
            printf "%d\n" 0x41
          o
            printf "%d\n" -0x41
          o
            printf "%+d\n" 0x41
    *
      print the octal representation of a decimal number
          o
            printf "%o\n" 65
          o
            printf "%05o\n" 65 (5 characters width, padded with zeros)
    *
      this prints a 0, since no argument is specified
          o
            printf "%d\n"
    *
      print the code number of the character A
          o
            printf "%d\n" \'A
          o
            printf "%d\n" "'A"
    *
      Generate a greeting banner and assign it to the variable GREETER
          o
            printf -v GREETER "Hello %s" "$LOGNAME"
    *
      Print a text at the end of the line, using tput to get the current line width
          o
            printf "%*s\n" $(tput cols) "Hello world!"

Small code table

This small loop prints all numbers from 0 to 127 in

    *
      decimal
    *
      octal
    *
      hex

for ((x=0; x <= 127; x++)); do
  printf '%3d | %04o | 0x%02x\n' "$x" "$x" "$x"
done

Ensure well-formatted MAC address

This code here will take a common MAC address and rewrite it into a well-known format (regarding leading zeros or upper/lowercase of the hex digits, ...):

the_mac="0:13:ce:7:7a:ad"

# lowercase hex digits
the_mac="$(printf "%02x:%02x:%02x:%02x:%02x:%02x" 0x${the_mac//:/ 0x})"

# or the uppercase-digits variant
the_mac="$(printf "%02X:%02X:%02X:%02X:%02X:%02X" 0x${the_mac//:/ 0x})"

Replacement echo

This code was found in Solaris manpage for echo(1).

Solaris version of /usr/bin/echo is equivalent to:

printf "%b\n" "$*"

Solaris /usr/ucb/echo is equivalent to:

if [ "X$1" = "X-n" ]
then
     shift
     printf "%s" "$*"
else
     printf "%s\n" "$*"
fi

prargs Implementation

Working off the replacement echo, here is a terse implementation of prargs:

printf '"%b"\n' "$0" "$@" | nl -v0 -s": "

repeating a character (for example to print a line)

A small trick: Combining printf and parameter expansion to draw a line

length=40
printf -v line '%*s' "$length"
echo ${line// /-}

or:

length=40
eval printf -v line '%.0s-' {1..$length}

See also

    *
      Internal: Code snip: Print a horizontal line uses some printf examples
    *
      External: Greg's BashFAQ 18: How can I use numbers with leading zeros in a loop, e.g. 01, 02?



				12.11.1.2.3 read

    "Reads" the value of a variable from stdin, that is, interactively fetches input from the keyboard. The -a option lets read get array variables .

					12.11.1.2.3.1 Example 14-3. Variable assignment, using read

    #!/bin/bash
    # "Reading" variables.

    echo -n "Enter the value of variable 'var1': "
    # The -n option to echo suppresses newline.

    read var1
    # Note no '$' in front of var1, since it is being set.

    echo "var1 = $var1"


    echo

    # A single 'read' statement can set multiple variables.
    echo -n "Enter the values of variables 'var2' and 'var3' "
    echo =n "(separated by a space or tab): "
    read var2 var3
    echo "var2 = $var2      var3 = $var3"
    #  If you input only one value,
    #+ the other variable(s) will remain unset (null).

    exit 0

    A read without an associated variable assigns its input to the dedicated variable $REPLY.

					12.11.1.2.3.2 Example 14-4. What happens when read has no variable

    #!/bin/bash
    # read-novar.sh

    echo

    # -------------------------- #
    echo -n "Enter a value: "
    read var
    echo "\"var\" = "$var""
    # Everything as expected here.
    # -------------------------- #

    echo

    # ------------------------------------------------------------------- #
    echo -n "Enter another value: "
    read           #  No variable supplied for 'read', therefore...
                   #+ Input to 'read' assigned to default variable, $REPLY.
    var="$REPLY"
    echo "\"var\" = "$var""
    # This is equivalent to the first code block.
    # ------------------------------------------------------------------- #

    echo
    echo "========================="
    echo


    #  This example is similar to the "reply.sh" script.
    #  However, this one shows that $REPLY is available
    #+ even after a 'read' to a variable in the conventional way.


    # ================================================================= #

    #  In some instances, you might wish to discard the first value read.
    #  In such cases, simply ignore the $REPLY variable.

    { # Code block.
    read            # Line 1, to be discarded.
    read line2      # Line 2, saved in variable.
      } <$0
    echo "Line 2 of this script is:"
    echo "$line2"   #   # read-novar.sh
    echo            #   #!/bin/bash  line discarded.

    # See also the soundcard-on.sh script.

    exit 0

    Normally, inputting a \ suppresses a newline during input to a read. The -r option causes an inputted \ to be interpreted literally.

					12.11.1.2.3.3 Example 14-5. Multi-line input to read

    #!/bin/bash

    echo

    echo "Enter a string terminated by a \\, then press <ENTER>."
    echo "Then, enter a second string (no \\ this time), and again press <ENTER>."

    read var1     # The "\" suppresses the newline, when reading $var1.
                  #     first line \
                  #     second line

    echo "var1 = $var1"
    #     var1 = first line second line

    #  For each line terminated by a "\"
    #+ you get a prompt on the next line to continue feeding characters into var1.

    echo; echo

    echo "Enter another string terminated by a \\ , then press <ENTER>."
    read -r var2  # The -r option causes the "\" to be read literally.
                  #     first line \

    echo "var2 = $var2"
    #     var2 = first line \

    # Data entry terminates with the first <ENTER>.

    echo 

    exit 0

    The read command has some interesting options that permit echoing a prompt and even reading keystrokes without hitting ENTER.

					12.11.1.2.3.4 #Read a keypress without hitting ENTER.

    read -s -n1 -p "Hit a key " keypress
    echo; echo "Keypress was "\"$keypress\""."

    # -s option means do not echo input.
    # -n N option means accept only N characters of input.
    # -p option means echo the following prompt before reading input.

    # Using these options is tricky, since they need to be in the correct order.

    The -n option to read also allows detection of the arrow keys and certain of the other unusual keys.

					12.11.1.2.3.5 Example 14-6. Detecting the arrow keys

    #!/bin/bash
    # arrow-detect.sh: Detects the arrow keys, and a few more.
    # Thank you, Sandro Magi, for showing me how.

    # --------------------------------------------
    # Character codes generated by the keypresses.
    arrowup='\[A'
    arrowdown='\[B'
    arrowrt='\[C'
    arrowleft='\[D'
    insert='\[2'
    delete='\[3'
    # --------------------------------------------

    SUCCESS=0
    OTHER=65

    echo -n "Press a key...  "
    # May need to also press ENTER if a key not listed above pressed.
    read -n3 key                      # Read 3 characters.

    echo -n "$key" | grep "$arrowup"  #Check if character code detected.
    if [ "$?" -eq $SUCCESS ]
    then
      echo "Up-arrow key pressed."
      exit $SUCCESS
    fi

    echo -n "$key" | grep "$arrowdown"
    if [ "$?" -eq $SUCCESS ]
    then
      echo "Down-arrow key pressed."
      exit $SUCCESS
    fi

    echo -n "$key" | grep "$arrowrt"
    if [ "$?" -eq $SUCCESS ]
    then
      echo "Right-arrow key pressed."
      exit $SUCCESS
    fi

    echo -n "$key" | grep "$arrowleft"
    if [ "$?" -eq $SUCCESS ]
    then
      echo "Left-arrow key pressed."
      exit $SUCCESS
    fi

    echo -n "$key" | grep "$insert"
    if [ "$?" -eq $SUCCESS ]
    then
      echo "\"Insert\" key pressed."
      exit $SUCCESS
    fi

    echo -n "$key" | grep "$delete"
    if [ "$?" -eq $SUCCESS ]
    then
      echo "\"Delete\" key pressed."
      exit $SUCCESS
    fi


    echo " Some other key pressed."

    exit $OTHER

    # ========================================= #

    #  Mark Alexander came up with a simplified
    #+ version of the above script (Thank you!).
    #  It eliminates the need for grep.

    #!/bin/bash

      uparrow=$'\x1b[A'
      downarrow=$'\x1b[B'
      leftarrow=$'\x1b[D'
      rightarrow=$'\x1b[C'

      read -s -n3 -p "Hit an arrow key: " x

      case "$x" in
      $uparrow)
         echo "You pressed up-arrow"
         ;;
      $downarrow)
         echo "You pressed down-arrow"
         ;;
      $leftarrow)
         echo "You pressed left-arrow"
         ;;
      $rightarrow)
         echo "You pressed right-arrow"
         ;;
      esac

    exit $?

    # ========================================= #

    # Antonio Macchi has a simpler alternative.

    #!/bin/bash

    while true
    do
      read -sn1 a
      test "$a" == `echo -en "\e"` || continue
      read -sn1 a
      test "$a" == "[" || continue
      read -sn1 a
      case "$a" in
        A)  echo "up";;
        B)  echo "down";;
        C)  echo "right";;
        D)  echo "left";;
      esac
    done

    # ========================================= #

    #  Exercise:
    #  --------
    #  1) Add detection of the "Home," "End," "PgUp," and "PgDn" keys.

    Note	

    The -n option to read will not detect the ENTER (newline) key.

    The -t option to read permits timed input (see Example 9-4 and Example A-43).

    The read command may also "read" its variable value from a file redirected to stdin. If the file contains more than one line, only the first line is assigned to the variable. If read has more than one parameter, then each of these variables gets assigned a successive whitespace-delineated string. Caution!

					12.11.1.2.3.6 Example 14-7. Using read with file redirection, read lines and seperate fields
(bash simple way to read lines of N fields file)

    #!/bin/bash

    read var1 <data-file
    echo "var1 = $var1"
    # var1 set to the entire first line of the input file "data-file"

    read var2 var3 <data-file
    echo "var2 = $var2   var3 = $var3"
    # Note non-intuitive behavior of "read" here.
    # 1) Rewinds back to the beginning of input file.
    # 2) Each variable is now set to a corresponding string,
    #    separated by whitespace, rather than to an entire line of text.
    # 3) The final variable gets the remainder of the line.
    # 4) If there are more variables to be set than whitespace-terminated strings
    #    on the first line of the file, then the excess variables remain empty.

    echo "------------------------------------------------"

    # How to resolve the above problem with a loop:
    while read line
    do
      echo "$line"
    done <data-file
    # Thanks, Heiner Steven for pointing this out.

    echo "------------------------------------------------"

    # Use $IFS (Internal Field Separator variable) to split a line of input to
    # "read", if you do not want the default to be whitespace.

    echo "List of all users:"
    OIFS=$IFS; IFS=:       # /etc/passwd uses ":" for field separator.
    while read name passwd uid gid fullname ignore
    do
      echo "$name ($fullname)"
    done </etc/passwd   # I/O redirection.
    IFS=$OIFS              # Restore original $IFS.
    # This code snippet also by Heiner Steven.



    #  Setting the $IFS variable within the loop itself
    #+ eliminates the need for storing the original $IFS
    #+ in a temporary variable.
    #  Thanks, Dim Segebart, for pointing this out.
    echo "------------------------------------------------"
    echo "List of all users:"

    while IFS=: read name passwd uid gid fullname ignore
    do
      echo "$name ($fullname)"
    done </etc/passwd   # I/O redirection.

    echo
    echo "\$IFS still $IFS"

    exit 0

    Note	

    Piping output to a read, using echo to set variables will fail.

    Yet, piping the output of cat seems to work.

    cat file1 file2 |
    while read line
    do
    echo $line
    done

    However, as Bjn Eriksson shows:

					12.11.1.2.3.7 Example 14-8. Problems reading from a pipe

    #!/bin/sh
    # readpipe.sh
    # This example contributed by Bjon Eriksson.

    last="(null)"
    cat $0 |
    while read line
    do
        echo "{$line}"
        last=$line
    done
    printf "\nAll done, last:$last\n"

    exit 0  # End of code.
            # (Partial) output of script follows.
            # The 'echo' supplies extra brackets.

    #############################################

    ./readpipe.sh 

    {#!/bin/sh}
    {last="(null)"}
    {cat $0 |}
    {while read line}
    {do}
    {echo "{$line}"}
    {last=$line}
    {done}
    {printf "nAll done, last:$lastn"}


    All done, last:(null)

    The variable (last) is set within the subshell but unset outside.

    The gendiff script, usually found in /usr/bin on many Linux distros, pipes the output of find to a while read construct.

    find $1 \( -name "*$2" -o -name ".*$2" \) -print |
    while read f; do
    . . .

    Tip	

    It is possible to paste text into the input field of a read (but not multiple lines!). See Example A-40.

			12.11.1.3 Filesystem

				12.11.1.3.1 cd

    The familiar cd change directory command finds use in scripts where execution of a command requires being in a specified directory.

    (cd /source/directory && tar cf - . ) | (cd /dest/directory && tar xpvf -)

    [from the previously cited example by Alan Cox]

    The -P (physical) option to cd causes it to ignore symbolic links.

    cd - changes to $OLDPWD, the previous working directory.

    Caution	The cd command does not function as expected when presented with two forward slashes.

    bash$ cd //
    bash$ pwd
    //
    	      

    The output should, of course, be /. This is a problem both from the command line and in a script.

				12.11.1.3.2 pwd
				Print Working Directory. This gives the user's (or script's) current directory (see Example 14-9). The effect is identical to reading the value of the builtin variable $PWD.
pushd, popd, dirs

    This command set is a mechanism for bookmarking working directories, a means of moving back and forth through directories in an orderly manner. A pushdown stack is used to keep track of directory names. Options allow various manipulations of the directory stack.

				12.11.1.3.3 Dir stack commands
    pushd dir-name pushes the path dir-name onto the directory stack and simultaneously changes the current working directory to dir-name

    popd removes (pops) the top directory path name off the directory stack and simultaneously changes the current working directory to that directory popped from the stack.

    dirs lists the contents of the directory stack (compare this with the $DIRSTACK variable). A successful pushd or popd will automatically invoke dirs.

    Scripts that require various changes to the current working directory without hard-coding the directory name changes can make good use of these commands. Note that the implicit $DIRSTACK array variable, accessible from within a script, holds the contents of the directory stack.

				12.11.1.3.4 Example 14-9. Changing the current working directory

    #!/bin/bash

    dir1=/usr/local
    dir2=/var/spool

    pushd $dir1
    # Will do an automatic 'dirs' (list directory stack to stdout).
    echo "Now in directory `pwd`." # Uses back-quoted 'pwd'.

    # Now, do some stuff in directory 'dir1'.
    pushd $dir2
    echo "Now in directory `pwd`."

    # Now, do some stuff in directory 'dir2'.
    echo "The top entry in the DIRSTACK array is $DIRSTACK."
    popd
    echo "Now back in directory `pwd`."

    # Now, do some more stuff in directory 'dir1'.
    popd
    echo "Now back in original working directory `pwd`."

    exit 0

    # What happens if you don't 'popd' -- then exit the script?
    # Which directory do you end up in? Why?

			12.11.1.4 Variables

				12.11.1.4.1 let

    The let command carries out arithmetic operations on variables. In many cases, it functions as a less complex version of expr.

				12.11.1.4.2 Example 14-10. Letting let do arithmetic.

    #!/bin/bash

    echo

    let a=11            # Same as 'a=11'
    let a=a+5           # Equivalent to  let "a = a + 5"
                        # (Double quotes and spaces make it more readable.)
    echo "11 + 5 = $a"  # 16

    let "a <<= 3"       # Equivalent to  let "a = a << 3"
    echo "\"\$a\" (=16) left-shifted 3 places = $a"
                        # 128

    let "a /= 4"        # Equivalent to  let "a = a / 4"
    echo "128 / 4 = $a" # 32

    let "a -= 5"        # Equivalent to  let "a = a - 5"
    echo "32 - 5 = $a"  # 27

    let "a *=  10"      # Equivalent to  let "a = a * 10"
    echo "27 * 10 = $a" # 270

    let "a %= 8"        # Equivalent to  let "a = a % 8"
    echo "270 modulo 8 = $a  (270 / 8 = 33, remainder $a)"
                        # 6


    # Does "let" permit C-style operators?
    # Yes, just as the (( ... )) double-parentheses construct does.

    let a++             # C-style (post) increment.
    echo "6++ = $a"     # 6++ = 7
    let a--             # C-style decrement.
    echo "7-- = $a"     # 7-- = 6
    # Of course, ++a, etc., also allowed . . .
    echo


    # Trinary operator.

    # Note that $a is 6, see above.
    let "t = a<7?7:11"   # True
    echo $t  # 7

    let a++
    let "t = a<7?7:11"   # False
    echo $t  #     11

    exit

    "

				12.11.1.4.3 eval

    eval arg1 [arg2] ... [argN]

    Combines the arguments in an expression or list of expressions and evaluates them. Any variables contained within the expression are expanded. The result translates into a command. This can be useful for code generation from the command line or within a script.

    bash$ process=xterm
    bash$ show_process="eval ps ax | grep $process"
    bash$ $show_process
    1867 tty1     S      0:02 xterm
     2779 tty1     S      0:00 xterm
     2886 pts/1    S      0:00 grep xterm
    	      

    Each invocation of eval forces a re-evaluation of its arguments.

    a='$b'
    b='$c'
    c=d

    echo $a             # $b
                        # First level.
    eval echo $a        # $c
                        # Second level.
    eval eval echo $a   # d
                        # Third level.

    # Thank you, E. Choroba.

				12.11.1.4.4 Example 14-11. Showing the effect of eval

    #!/bin/bash
    # Exercising "eval" ...

    y=`eval ls -l`  #  Similar to y=`ls -l`
    echo $y         #+ but linefeeds removed because "echoed" variable is unquoted.
    echo
    echo "$y"       #  Linefeeds preserved when variable is quoted.

    echo; echo

    y=`eval df`     #  Similar to y=`df`
    echo $y         #+ but linefeeds removed.

    #  When LF's not preserved, it may make it easier to parse output,
    #+ using utilities such as "awk".

    echo
    echo "==========================================================="
    echo


    # Now, showing how to do something useful with "eval" . . .
    # (Thank you, E. Choroba!)

    version=3.4     #  Can we split the version into major and minor
                    #+ part in one command?
    echo "version = $version"
    eval major=${version/./;minor=}     #  Replaces '.' in version by ';minor='
                                        #  The substitution yields '3; minor=4'
                                        #+ so eval does minor=4, major=3
    echo Major: $major, minor: $minor   #  Major: 3, minor: 4

				12.11.1.4.5 Example 14-12. Echoing the command-line parameters

    #!/bin/bash
    # echo-params.sh

    # Call this script with a few command line parameters.
    # For example:
    #     sh echo-params.sh first second third fourth fifth

    params=$#              # Number of command-line parameters.
    param=1                # Start at first command-line param.

    while [ "$param" -le "$params" ]
    do
      echo -n "Command line parameter "
      echo -n \$$param     #  Gives only the *name* of variable.
    #         ^^^          #  $1, $2, $3, etc.
                           #  Why?
                           #  \$ escapes the first "$"
                           #+ so it echoes literally,
                           #+ and $param dereferences "$param" . . .
                           #+ . . . as expected.
      echo -n " = "
      eval echo \$$param   #  Gives the *value* of variable.
    # ^^^^      ^^^        #  The "eval" forces the *evaluation*
                           #+ of \$$
                           #+ as an indirect variable reference.

    (( param ++ ))         # On to the next.
    done

    exit $?

    # =================================================

    $ sh echo-params.sh first second third fourth fifth
    Command line parameter $1 = first
    Command line parameter $2 = second
    Command line parameter $3 = third
    Command line parameter $4 = fourth
    Command line parameter $5 = fifth

				12.11.1.4.6 Example 14-13. Forcing a log-off

    #!/bin/bash
    # Killing ppp to force a log-off.

    # Script should be run as root user.

    killppp="eval kill -9 `ps ax | awk '/ppp/ { print $1 }'`"
    #                     -------- process ID of ppp -------  

    $killppp                  # This variable is now a command.


    # The following operations must be done as root user.

    chmod 666 /dev/ttyS3      # Restore read+write permissions, or else what?
    #  Since doing a SIGKILL on ppp changed the permissions on the serial port,
    #+ we restore permissions to previous state.

    rm /var/lock/LCK..ttyS3   # Remove the serial port lock file. Why?

    #  Note:
    #  Depending on the hardware and even the kernel version,
    #+ the modem port on your machine may be different --
    #+ /dev/ttyS1 or /dev/ttyS2.

    exit 0

    # Exercises:
    # ---------
    # 1) Have script check whether root user is invoking it.
    # 2) Do a check on whether the process to be killed
    #+   is actually running before attempting to kill it.   
    # 3) Write an alternate version of this script based on 'fuser':
    #+      if [ fuser -s /dev/modem ]; then . . .

				12.11.1.4.7 Example 14-14. A version of rot13

    #!/bin/bash
    # A version of "rot13" using 'eval'.
    # Compare to "rot13.sh" example.

    setvar_rot_13()              # "rot13" scrambling
    {
      local varname=$1 varvalue=$2
      eval $varname='$(echo "$varvalue" | tr a-z n-za-m)'
    }


    setvar_rot_13 var "foobar"   # Run "foobar" through rot13.
    echo $var                    # sbbone

    setvar_rot_13 var "$var"     # Run "sbbone" through rot13.
                                 # Back to original variable.
    echo $var                    # foobar

    # This example by Stephane Chazelas.
    # Modified by document author.

    exit 0

    Rory Winston contributed the following instance of how useful eval can be.

				12.11.1.4.8 Example 14-15. Using eval to force variable substitution in a Perl script

    In the Perl script "test.pl":
            ...		
            my $WEBROOT = <WEBROOT_PATH>;
            ...

    To force variable substitution try:
            $export WEBROOT_PATH=/usr/local/webroot
            $sed 's/<WEBROOT_PATH>/$WEBROOT_PATH/' < test.pl > out

    But this just gives:
            my $WEBROOT = $WEBROOT_PATH;

    However:
            $export WEBROOT_PATH=/usr/local/webroot
            $eval sed 's%\<WEBROOT_PATH\>%$WEBROOT_PATH%' < test.pl > out
    #        ====

    That works fine, and gives the expected substitution:
            my $WEBROOT = /usr/local/webroot;


    ### Correction applied to original example by Paulo Marcel Coelho Aragao.

    The eval command occurs in the older version of indirect referencing.

    eval var=\$$var

    Caution	The eval command can be risky, and normally should be avoided when there exists a reasonable alternative. An eval $COMMANDS executes the contents of COMMANDS, which may contain such unpleasant surprises as rm -rf *. Running an eval on unfamiliar code written by persons unknown is living dangerously.


				12.11.1.4.9 set 

    The set command changes the value of internal script variables/options. One use for this is to toggle option flags which help determine the behavior of the script. Another application for it is to reset the positional parameters that a script sees as the result of a command (set `command`). The script can then parse the fields of the command output.

				12.11.1.4.10 Example 14-16. Using set with positional parameters

    #!/bin/bash

    # script "set-test"

    # Invoke this script with three command line parameters,
    # for example, "./set-test one two three".

    echo
    echo "Positional parameters before  set \`uname -a\` :"
    echo "Command-line argument #1 = $1"
    echo "Command-line argument #2 = $2"
    echo "Command-line argument #3 = $3"


    set `uname -a` # Sets the positional parameters to the output
                   # of the command `uname -a`

    echo $_        # unknown
    # Flags set in script.

    echo "Positional parameters after  set \`uname -a\` :"
    # $1, $2, $3, etc. reinitialized to result of `uname -a`
    echo "Field #1 of 'uname -a' = $1"
    echo "Field #2 of 'uname -a' = $2"
    echo "Field #3 of 'uname -a' = $3"
    echo ---
    echo $_        # ---
    echo

    exit 0

    More fun with positional parameters.

				12.11.1.4.11 Example 14-17. Reversing the positional parameters

    #!/bin/bash
    # revposparams.sh: Reverse positional parameters.
    # Script by Dan Jacobson, with stylistic revisions by document author.


    set a\ b c d\ e;
    #     ^      ^     Spaces escaped 
    #       ^ ^        Spaces not escaped
    OIFS=$IFS; IFS=:;
    #              ^   Saving old IFS and setting new one.

    echo

    until [ $# -eq 0 ]
    do          #      Step through positional parameters.
      echo "### k0 = "$k""     # Before
      k=$1:$k;  #      Append each pos param to loop variable.
    #     ^
      echo "### k = "$k""      # After
      echo
      shift;
    done

    set $k  #  Set new positional parameters.
    echo -
    echo $# #  Count of positional parameters.
    echo -
    echo

    for i   #  Omitting the "in list" sets the variable -- i --
            #+ to the positional parameters.
    do
      echo $i  # Display new positional parameters.
    done

    IFS=$OIFS  # Restore IFS.

    #  Question:
    #  Is it necessary to set an new IFS, internal field separator,
    #+ in order for this script to work properly?
    #  What happens if you don't? Try it.
    #  And, why use the new IFS -- a colon -- in line 17,
    #+ to append to the loop variable?
    #  What is the purpose of this?

    exit 0

    $ ./revposparams.sh

    ### k0 = 
    ### k = a b

    ### k0 = a b
    ### k = c a b

    ### k0 = c a b
    ### k = d e c a b

    -
    3
    -

    d e
    c
    a b

    Invoking set without any options or arguments simply lists all the environmental and other variables that have been initialized.

    bash$ set
    AUTHORCOPY=/home/bozo/posts
     BASH=/bin/bash
     BASH_VERSION=$'2.05.8(1)-release'
     ...
     XAUTHORITY=/home/bozo/.Xauthority
     _=/etc/bashrc
     variable22=abc
     variable23=xzy
    	      

    Using set with the -- option explicitly assigns the contents of a variable to the positional parameters. If no variable follows the -- it unsets the positional parameters.

				12.11.1.4.12 Example 14-18. Reassigning the positional parameters

    #!/bin/bash

    variable="one two three four five"

    set -- $variable
    # Sets positional parameters to the contents of "$variable".

    first_param=$1
    second_param=$2
    shift; shift        # Shift past first two positional params.
    # shift 2             also works.
    remaining_params="$*"

    echo
    echo "first parameter = $first_param"             # one
    echo "second parameter = $second_param"           # two
    echo "remaining parameters = $remaining_params"   # three four five

    echo; echo

    # Again.
    set -- $variable
    first_param=$1
    second_param=$2
    echo "first parameter = $first_param"             # one
    echo "second parameter = $second_param"           # two

    # ======================================================

    set --
    # Unsets positional parameters if no variable specified.

    first_param=$1
    second_param=$2
    echo "first parameter = $first_param"             # (null value)
    echo "second parameter = $second_param"           # (null value)

    exit 0

    See also Example 10-2 and Example 15-56.

				12.11.1.4.13 unset

    The unset command deletes a shell variable, effectively setting it to null. Note that this command does not affect positional parameters.

    bash$ unset PATH

    bash$ echo $PATH


    bash$ 

				12.11.1.4.14 Example 14-19. "Unsetting" a variable

    #!/bin/bash
    # unset.sh: Unsetting a variable.

    variable=hello                       # Initialized.
    echo "variable = $variable"

    unset variable                       # Unset.
                                         # Same effect as:  variable=
    echo "(unset) variable = $variable"  # $variable is null.

    if [ -z "$variable" ]                # Try a string-length test.
    then
      echo "\$variable has zero length."
    fi

    exit 0

				12.11.1.4.15 export

    The export [2] command makes available variables to all child processes of the running script or shell. One important use of the export command is in startup files, to initialize and make accessible environmental variables to subsequent user processes.

    Caution	Unfortunately, there is no way to export variables back to the parent process, to the process that called or invoked the script or shell.

				12.11.1.4.16 Example 14-20. Using export to pass a variable to an embedded awk script

    #!/bin/bash

    #  Yet another version of the "column totaler" script (col-totaler.sh)
    #+ that adds up a specified column (of numbers) in the target file.
    #  This uses the environment to pass a script variable to 'awk' . . .
    #+ and places the awk script in a variable.


    ARGS=2
    E_WRONGARGS=65

    if [ $# -ne "$ARGS" ] # Check for proper no. of command line args.
    then
       echo "Usage: `basename $0` filename column-number"
       exit $E_WRONGARGS
    fi

    filename=$1
    column_number=$2

    #===== Same as original script, up to this point =====#

    export column_number
    # Export column number to environment, so it's available for retrieval.


    # -----------------------------------------------
    awkscript='{ total += $ENVIRON["column_number"] }
    END { print total }'
    # Yes, a variable can hold an awk script.
    # -----------------------------------------------

    # Now, run the awk script.
    awk "$awkscript" "$filename"

    # Thanks, Stephane Chazelas.

    exit 0

    Tip	It is possible to initialize and export variables in the same operation, as in export var1=xxx.

    However, as Greg Keraunen points out, in certain situations this may have a different effect than setting a variable, then exporting it.

    bash$ export var=(a b); echo ${var[0]}
    (a b)



    bash$ var=(a b); export var; echo ${var[0]}
    a
    	      

				12.11.1.4.17 declare, typeset

    The declare and typeset commands specify and/or restrict properties of variables.
readonly

    Same as declare -r, sets a variable as read-only, or, in effect, as a constant. Attempts to change the variable fail with an error message. This is the shell analog of the C language const type qualifier.
getopts

    This powerful tool parses command-line arguments passed to the script. This is the Bash analog of the getopt external command and the getopt library function familiar to C programmers. It permits passing and concatenating multiple options [3] and associated arguments to a script (for example scriptname -abc -e /usr/local).

    The getopts construct uses two implicit variables. $OPTIND is the argument pointer (OPTion INDex) and $OPTARG (OPTion ARGument) the (optional) argument attached to an option. A colon following the option name in the declaration tags that option as having an associated argument.

    A getopts construct usually comes packaged in a while loop, which processes the options and arguments one at a time, then increments the implicit $OPTIND variable to step to the next.

    Note	

       a.

          The arguments passed from the command line to the script must be preceded by a minus (-). It is the prefixed - that lets getopts recognize command-line arguments as options. In fact, getopts will not process arguments without the prefixed -, and will terminate option processing at the first argument encountered lacking them.
       b.

          The getopts template differs slightly from the standard while loop, in that it lacks condition brackets.
       c.

          The getopts construct is a highly functional replacement for the traditional getopt external command.

    while getopts ":abcde:fg" Option
    # Initial declaration.
    # a, b, c, d, e, f, and g are the options (flags) expected.
    # The : after option 'e' shows it will have an argument passed with it.
    do
      case $Option in
        a ) # Do something with variable 'a'.
        b ) # Do something with variable 'b'.
        ...
        e)  # Do something with 'e', and also with $OPTARG,
            # which is the associated argument passed with option 'e'.
        ...
        g ) # Do something with variable 'g'.
      esac
    done
    shift $(($OPTIND - 1))
    # Move argument pointer to next.

    # All this is not nearly as complicated as it looks <grin>.

				12.11.1.4.18 Example 14-21. Using getopts to read the options/arguments passed to a script

    #!/bin/bash
    # Exercising getopts and OPTIND
    # Script modified 10/09/03 at the suggestion of Bill Gradwohl.


    # Here we observe how 'getopts' processes command line arguments to script.
    # The arguments are parsed as "options" (flags) and associated arguments.

    # Try invoking this script with
    # 'scriptname -mn'
    # 'scriptname -oq qOption' (qOption can be some arbitrary string.)
    # 'scriptname -qXXX -r'
    #
    # 'scriptname -qr'    - Unexpected result, takes "r" as the argument to option "q"
    # 'scriptname -q -r'  - Unexpected result, same as above
    # 'scriptname -mnop -mnop'  - Unexpected result
    # (OPTIND is unreliable at stating where an option came from).
    #
    #  If an option expects an argument ("flag:"), then it will grab
    #+ whatever is next on the command line.

    NO_ARGS=0 
    E_OPTERROR=65

    if [ $# -eq "$NO_ARGS" ]  # Script invoked with no command-line args?
    then
      echo "Usage: `basename $0` options (-mnopqrs)"
      exit $E_OPTERROR        # Exit and explain usage, if no argument(s) given.
    fi  
    # Usage: scriptname -options
    # Note: dash (-) necessary


    while getopts ":mnopq:rs" Option
    do
      case $Option in
        m     ) echo "Scenario #1: option -m-   [OPTIND=${OPTIND}]";;
        n | o ) echo "Scenario #2: option -$Option-   [OPTIND=${OPTIND}]";;
        p     ) echo "Scenario #3: option -p-   [OPTIND=${OPTIND}]";;
        q     ) echo "Scenario #4: option -q-\
     with argument \"$OPTARG\"   [OPTIND=${OPTIND}]";;
        #  Note that option 'q' must have an associated argument,
        #+ otherwise it falls through to the default.
        r | s ) echo "Scenario #5: option -$Option-";;
        *     ) echo "Unimplemented option chosen.";;   # DEFAULT
      esac
    done

    shift $(($OPTIND - 1))
    #  Decrements the argument pointer so it points to next argument.
    #  $1 now references the first non option item supplied on the command line
    #+ if one exists.

    exit 0

    #   As Bill Gradwohl states,
    #  "The getopts mechanism allows one to specify:  scriptname -mnop -mnop
    #+  but there is no reliable way to differentiate what came from where
    #+  by using OPTIND."

				12.11.1.4.19 Script Behavior

					12.11.1.4.19.1 source, . (dot command)

    This command, when invoked from the command line, executes a script. Within a script, a source file-name loads the file file-name. Sourcing a file (dot-command) imports code into the script, appending to the script (same effect as the #include directive in a C program). The net result is the same as if the "sourced" lines of code were physically present in the body of the script. This is useful in situations when multiple scripts use a common data file or function library.

    Example 14-22. "Including" a data file

    #!/bin/bash

    . data-file    # Load a data file.
    # Same effect as "source data-file", but more portable.

    #  The file "data-file" must be present in current working directory,
    #+ since it is referred to by its 'basename'.

    # Now, reference some data from that file.

    echo "variable1 (from data-file) = $variable1"
    echo "variable3 (from data-file) = $variable3"

    let "sum = $variable2 + $variable4"
    echo "Sum of variable2 + variable4 (from data-file) = $sum"
    echo "message1 (from data-file) is \"$message1\""
    # Note:                            escaped quotes

    print_message This is the message-print function in the data-file.


    exit 0

    File data-file for Example 14-22, above. Must be present in same directory.

    # This is a data file loaded by a script.
    # Files of this type may contain variables, functions, etc.
    # It may be loaded with a 'source' or '.' command by a shell script.

    # Let's initialize some variables.

    variable1=22
    variable2=474
    variable3=5
    variable4=97

    message1="Hello, how are you?"
    message2="Enough for now. Goodbye."

    print_message ()
    {
    # Echoes any message passed to it.

      if [ -z "$1" ]
      then
        return 1
        # Error, if argument missing.
      fi

      echo

      until [ -z "$1" ]
      do
        # Step through arguments passed to function.
        echo -n "$1"
        # Echo args one at a time, suppressing line feeds.
        echo -n " "
        # Insert spaces between words.
        shift
        # Next one.
      done  

      echo

      return 0
    }  

    If the sourced file is itself an executable script, then it will run, then return control to the script that called it. A sourced executable script may use a return for this purpose.

    Arguments may be (optionally) passed to the sourced file as positional parameters.

    source $filename $arg1 arg2

    It is even possible for a script to source itself, though this does not seem to have any practical applications.

    Example 14-23. A (useless) script that sources itself

    #!/bin/bash
    # self-source.sh: a script sourcing itself "recursively."
    # From "Stupid Script Tricks," Volume II.

    MAXPASSCNT=100    # Maximum number of execution passes.

    echo -n  "$pass_count  "
    #  At first execution pass, this just echoes two blank spaces,
    #+ since $pass_count still uninitialized.

    let "pass_count += 1"
    #  Assumes the uninitialized variable $pass_count
    #+ can be incremented the first time around.
    #  This works with Bash and pdksh, but
    #+ it relies on non-portable (and possibly dangerous) behavior.
    #  Better would be to initialize $pass_count to 0 before incrementing.

    while [ "$pass_count" -le $MAXPASSCNT ]
    do
      . $0   # Script "sources" itself, rather than calling itself.
             # ./$0 (which would be true recursion) doesn't work here. Why?
    done  

    #  What occurs here is not actually recursion,
    #+ since the script effectively "expands" itself, i.e.,
    #+ generates a new section of code
    #+ with each pass through the 'while' loop',
    #  with each 'source' in line 20.
    #
    #  Of course, the script interprets each newly 'sourced' "#!" line
    #+ as a comment, and not as the start of a new script.

    echo

    exit 0   # The net effect is counting from 1 to 100.
             # Very impressive.

    # Exercise:
    # --------
    # Write a script that uses this trick to actually do something useful.

exit

    Unconditionally terminates a script. [4] The exit command may optionally take an integer argument, which is returned to the shell as the exit status of the script. It is good practice to end all but the simplest scripts with an exit 0, indicating a successful run.

    Note	If a script terminates with an exit lacking an argument, the exit status of the script is the exit status of the last command executed in the script, not counting the exit. This is equivalent to an exit $?.

    Note	An exit command may also be used to terminate a subshell.

					12.11.1.4.19.2 exec

    This shell builtin replaces the current process with a specified command. Normally, when the shell encounters a command, it forks off a child process to actually execute the command. Using the exec builtin, the shell does not fork, and the command exec'ed replaces the shell. When used in a script, therefore, it forces an exit from the script when the exec'ed command terminates. [5]

    Example 14-24. Effects of exec

    #!/bin/bash

    exec echo "Exiting \"$0\"."   # Exit from script here.

    # ----------------------------------
    # The following lines never execute.

    echo "This echo will never echo."

    exit 99                       #  This script will not exit here.
                                  #  Check exit value after script terminates
                                  #+ with an 'echo $?'.
                                  #  It will *not* be 99.

    Example 14-25. A script that exec's itself

    #!/bin/bash
    # self-exec.sh

    echo

    echo "This line appears ONCE in the script, yet it keeps echoing."
    echo "The PID of this instance of the script is still $$."
    #     Demonstrates that a subshell is not forked off.

    echo "==================== Hit Ctl-C to exit ===================="

    sleep 1

    exec $0   #  Spawns another instance of this same script
              #+ that replaces the previous one.

    echo "This line will never echo!"  # Why not?

    exit 99                            # Will not exit here!
                                       # Exit code will not be 99!

    An exec also serves to reassign file descriptors. For example, exec <zzz-file replaces stdin with the file zzz-file.

    Note	

    The -exec option to find is not the same as the exec shell builtin.
shopt

    This command permits changing shell options on the fly (see Example 24-1 and Example 24-2). It often appears in the Bash startup files, but also has its uses in scripts. Needs version 2 or later of Bash.

					12.11.1.4.19.3 shopt -s cdspell
    # Allows minor misspelling of directory names with 'cd'

    cd /hpme  # Oops! Mistyped '/home'.
    pwd       # /home
              # The shell corrected the misspelling.

					12.11.1.4.19.4 caller

    Putting a caller command inside a function echoes to stdout information about the caller of that function.

    #!/bin/bash

    function1 ()
    {
      # Inside function1 ().
      caller 0   # Tell me about it.
    }

    function1    # Line 9 of script.

    # 9 main test.sh
    # ^                 Line number that the function was called from.
    #   ^^^^            Invoked from "main" part of script.
    #        ^^^^^^^    Name of calling script.

    caller 0     # Has no effect because it's not inside a function.

    A caller command can also return caller information from a script sourced within another script. Analogous to a function, this is a "subroutine call."

    You may find this command useful in debugging.

Commands

true

    A command that returns a successful (zero) exit status, but does nothing else.

    bash$ true
    bash$ echo $?
    0
    	      

    # Endless loop
    while true   # alias for ":"
    do
       operation-1
       operation-2
       ...
       operation-n
       # Need a way to break out of loop or script will hang.
    done

false

    A command that returns an unsuccessful exit status, but does nothing else.

    bash$ false
    bash$ echo $?
    1
    	      

    # Testing "false" 
    if false
    then
      echo "false evaluates \"true\""
    else
      echo "false evaluates \"false\""
    fi
    # false evaluates "false"


    # Looping while "false" (null loop)
    while false
    do
       # The following code will not execute.
       operation-1
       operation-2
       ...
       operation-n
       # Nothing happens!
    done   

					12.11.1.4.19.5 type [cmd]

    Similar to the which external command, type cmd identifies "cmd." Unlike which, type is a Bash builtin. The useful -a option to type identifies keywords and builtins, and also locates system commands with identical names.

    bash$ type '['
    [ is a shell builtin
    bash$ type -a '['
    [ is a shell builtin
     [ is /usr/bin/[


    bash$ type type
    type is a shell builtin
    	      

					12.11.1.4.19.6 hash [cmds]

    Record the path name of specified commands -- in the shell hash table [6] -- so the shell or script will not need to search the $PATH on subsequent calls to those commands. When hash is called with no arguments, it simply lists the commands that have been hashed. The -r option resets the hash table.
bind

    The bind builtin displays or modifies readline [7] key bindings.


					12.11.1.4.19.7 help

    Gets a short usage summary of a shell builtin. This is the counterpart to whatis, but for builtins.

    bash$ help exit
    exit: exit [n]
        Exit the shell with a status of N.  If N is omitted, the exit status
        is that of the last command executed.
    	      

			12.11.1.5 Job Control Commands
Certain of the following job control commands take a job identifier as an argument. See the table at end of the chapter.

				12.11.1.5.1 jobs

    Lists the jobs running in the background, giving the job number. Not as useful as ps.

    Note	It is all too easy to confuse jobs and processes. Certain builtins, such as kill, disown, and wait accept either a job number or a process number as an argument. The fg, bg and jobs commands accept only a job number.

    bash$ sleep 100 &
    [1] 1384

    bash $ jobs
    [1]+  Running                 sleep 100 &

    "1" is the job number (jobs are maintained by the current shell). "1384" is the PID or process ID number (processes are maintained by the system). To kill this job/process, either a kill %1 or a kill 1384 works.

    Thanks, S.C.

				12.11.1.5.2 disown

    Remove job(s) from the shell's table of active jobs.

				12.11.1.5.3 fg, bg

    The fg command switches a job running in the background into the foreground. The bg command restarts a suspended job, and runs it in the background. If no job number is specified, then the fg or bg command acts upon the currently running job.
wait

    Suspend script execution until all jobs running in background have terminated, or until the job number or process ID specified as an option terminates. Returns the exit status of waited-for command.

    You may use the wait command to prevent a script from exiting before a background job finishes executing (this would create a dreaded orphan process).

				12.11.1.5.4 Example 14-26. Waiting for a process to finish before proceeding

    #!/bin/bash

    ROOT_UID=0   # Only users with $UID 0 have root privileges.
    E_NOTROOT=65
    E_NOPARAMS=66

    if [ "$UID" -ne "$ROOT_UID" ]
    then
      echo "Must be root to run this script."
      # "Run along kid, it's past your bedtime."
      exit $E_NOTROOT
    fi  

    if [ -z "$1" ]
    then
      echo "Usage: `basename $0` find-string"
      exit $E_NOPARAMS
    fi


    echo "Updating 'locate' database..."
    echo "This may take a while."
    updatedb /usr &     # Must be run as root.

    wait
    # Don't run the rest of the script until 'updatedb' finished.
    # You want the the database updated before looking up the file name.

    locate $1

    #  Without the 'wait' command, in the worse case scenario,
    #+ the script would exit while 'updatedb' was still running,
    #+ leaving it as an orphan process.

    exit 0

    Optionally, wait can take a job identifier as an argument, for example, wait%1 or wait $PPID. See the job id table.

    Tip	Within a script, running a command in the background with an ampersand (&) may cause the script to hang until ENTER is hit. This seems to occur with commands that write to stdout. It can be a major annoyance.

    #!/bin/bash
    # test.sh		  

    ls -l &
    echo "Done."

    bash$ ./test.sh
    Done.
     [bozo@localhost test-scripts]$ total 1
     -rwxr-xr-x    1 bozo     bozo           34 Oct 11 15:09 test.sh
     _
                   

            As Walter Brameld IV explains it:

            As far as I can tell, such scripts don't actually hang. It just
            seems that they do because the background command writes text to
            the console after the prompt. The user gets the impression that
            the prompt was never displayed. Here's the sequence of events:

|            1. Script launches background command.
|            2. Script exits.
|            3. Shell displays the prompt.
|            4. Background command continues running and writing text to the
|               console.
|            5. Background command finishes.
|            6. User doesn't see a prompt at the bottom of the output, thinks script
               is hanging.

    Placing a wait after the background command seems to remedy this.

    #!/bin/bash
    # test.sh		  

    ls -l &
    echo "Done."
    wait

    bash$ ./test.sh
    Done.
     [bozo@localhost test-scripts]$ total 1
     -rwxr-xr-x    1 bozo     bozo           34 Oct 11 15:09 test.sh
                   

    Redirecting the output of the command to a file or even to /dev/null also takes care of this problem. 
suspend

    This has a similar effect to Control-Z, but it suspends the shell (the shell's parent process should resume it at an appropriate time).
logout

				12.11.1.5.5 Exit 
				a login shell, optionally specifying an exit status.


				12.11.1.5.6 times

    Gives statistics on the system time elapsed when executing commands, in the following form:

    0m0.020s 0m0.020s

    This capability is of relatively limited value, since it is not common to profile and benchmark shell scripts.


				12.11.1.5.7 kill

    Forcibly terminate a process by sending it an appropriate terminate signal (see Example 16-6).

    Example 14-27. A script that kills itself

    #!/bin/bash
    # self-destruct.sh

    kill $$  # Script kills its own process here.
             # Recall that "$$" is the script's PID.

    echo "This line will not echo."
    # Instead, the shell sends a "Terminated" message to stdout.

    exit 0   # Normal exit? No!

    #  After this script terminates prematurely,
    #+ what exit status does it return?
    #
    # sh self-destruct.sh
    # echo $?
    # 143
    #
    # 143 = 128 + 15
    #             TERM signal

    Note	kill -l lists all the signals (as does the file /usr/include/asm/signal.h). A kill -9 is a sure kill, which will usually terminate a process that stubbornly refuses to die with a plain kill. Sometimes, a kill -15 works. A zombie process, that is, a child process that has terminated, but that the parent process has not (yet) killed, cannot be killed by a logged-on user -- you can't kill something that is already dead -- but init will generally clean it up sooner or later.


				12.11.1.5.8 killall

    The killall command kills a running process by name, rather than by process ID. If there are multiple instances of a particular command running, then doing a killall on that command will terminate them all.

    Note	This refers to the killall command in /usr/bin, not the killall script in /etc/rc.d/init.d.

				12.11.1.5.9 command

    The command directive disables aliases and functions for the command immediately following it.

    bash$ command ls
                  

    Note	This is one of three shell directives that effect script command processing. The others are builtin and enable.

				12.11.1.5.10 builtin

    Invoking builtin BUILTIN_COMMAND runs the command BUILTIN_COMMAND as a shell builtin, temporarily disabling both functions and external system commands with the same name.


				12.11.1.5.11 enable

    This either enables or disables a shell builtin command. As an example, enable -n kill disables the shell builtin kill, so that when Bash subsequently encounters kill, it invokes the external command /bin/kill.

    The -a option to enable lists all the shell builtins, indicating whether or not they are enabled. The -f filename option lets enable load a builtin as a shared library (DLL) module from a properly compiled object file. [1]. 


				12.11.1.5.12 autoload

    This is a port to Bash of the ksh autoloader. With autoload in place, a function with an autoload declaration will load from an external file at its first invocation. [2] This saves system resources.

    Note that autoload is not a part of the core Bash installation. It needs to be loaded in with enable -f (see above).

Table 14-1. Job identifiers
Notation	Meaning
%N	Job number [N]
%S	Invocation (command line) of job begins with string S
%?S	Invocation (command line) of job contains within it string S
%%	"current" job (last job stopped in foreground or started in background)
%+	"current" job (last job stopped in foreground or started in background)
%-	Last job
$!	Last background process


		12.11.2 Chapter 15. External Filters, Programs and Commands
			12.11.2.1 Basic Commands
The first commands a novice learns

				12.11.2.1.1 ls, tags, ls, list files directories

    The basic file "list" command. It is all too easy to underestimate the power of this humble command. For example, using the -R, recursive option, ls provides a tree-like listing of a directory structure. Other useful options are -S, sort listing by file size, -t, sort by file modification time, -b, show escape characters, and -i, show file inodes (see Example 15-4).

    Tip	The ls command returns a non-zero exit status when attempting to list a non-existent file.

    bash$ ls abc
    ls: abc: No such file or directory


    bash$ echo $?
    2

    Example 15-1. Using ls to create a table of contents for burning a CDR disk

    #!/bin/bash
    # ex40.sh (burn-cd.sh)
    # Script to automate burning a CDR.


    SPEED=2          # May use higher speed if your hardware supports it.
    IMAGEFILE=cdimage.iso
    CONTENTSFILE=contents
    DEVICE=cdrom
    # DEVICE="0,0"     For older versions of cdrecord
    DEFAULTDIR=/opt  # This is the directory containing the data to be burned.
                     # Make sure it exists.
                     # Exercise: Add a test for this.

    # Uses Joerg Schilling's "cdrecord" package:
    # http://www.fokus.fhg.de/usr/schilling/cdrecord.html

    #  If this script invoked as an ordinary user, may need to suid cdrecord
    #+ chmod u+s /usr/bin/cdrecord, as root.
    #  Of course, this creates a security hole, though a relatively minor one.

    if [ -z "$1" ]
    then
      IMAGE_DIRECTORY=$DEFAULTDIR
      # Default directory, if not specified on command line.
    else
        IMAGE_DIRECTORY=$1
    fi

    # Create a "table of contents" file.
    ls -lRF $IMAGE_DIRECTORY > $IMAGE_DIRECTORY/$CONTENTSFILE
    # The "l" option gives a "long" file listing.
    # The "R" option makes the listing recursive.
    # The "F" option marks the file types (directories get a trailing /).
    echo "Creating table of contents."

    # Create an image file preparatory to burning it onto the CDR.
    mkisofs -r -o $IMAGEFILE $IMAGE_DIRECTORY
    echo "Creating ISO9660 file system image ($IMAGEFILE)."

    # Burn the CDR.
    echo "Burning the disk."
    echo "Please be patient, this will take a while."
    cdrecord -v -isosize speed=$SPEED dev=$DEVICE $IMAGEFILE

    exit $?

				    12.11.2.1.1.1  list only hidden files
$ ls -ad .*

explanation: -a list all (also hidden), -d list directories w/o recursing into their contents, .* pattern (starts w/ .)
				    12.11.2.1.1.2

				12.11.2.1.2 cat, tac

    cat, an acronym for concatenate, lists a file to stdout. When combined with redirection (> or >>), it is commonly used to concatenate files.

    # Uses of 'cat'
    cat filename                          # Lists the file.

    cat file.1 file.2 file.3 > file.123   # Combines three files into one.

    The -n option to cat inserts consecutive numbers before all lines of the target file(s). The -b option numbers only the non-blank lines. The -v option echoes nonprintable characters, using ^ notation. The -s option squeezes multiple consecutive blank lines into a single blank line.

    See also Example 15-28 and Example 15-24.

    Note	In a pipe, it may be more efficient to redirect the stdin to a file, rather than to cat the file.

    cat filename | tr a-z A-Z

    tr a-z A-Z < filename   #  Same effect, but starts one less process,
                            #+ and also dispenses with the pipe.

    tac, is the inverse of cat, listing a file backwards from its end.

				12.11.2.1.3 rev

    reverses each line of a file, and outputs to stdout. This does not have the same effect as tac, as it preserves the order of the lines, but flips each one around (mirror image).

    bash$ cat file1.txt
    This is line 1.
     This is line 2.


    bash$ tac file1.txt
    This is line 2.
     This is line 1.


    bash$ rev file1.txt
    .1 enil si sihT
     .2 enil si sihT
    	      

				12.11.2.1.4 cp

    This is the file copy command. cp file1 file2 copies file1 to file2, overwriting file2 if it already exists (see Example 15-6).

    Tip	Particularly useful are the -a archive flag (for copying an entire directory tree), the -u update flag (which prevents overwriting identically-named newer files), and the -r and -R recursive flags.

    cp -u source_dir/* dest_dir
    #  "Synchronize" dest_dir to source_dir
    #+  by copying over all newer and not previously existing files.

				12.11.2.1.5 mv

    This is the file move command. It is equivalent to a combination of cp and rm. It may be used to move multiple files to a directory, or even to rename a directory. For some examples of using mv in a script, see Example 9-20 and Example A-2.

    Note	When used in a non-interactive script, mv takes the -f (force) option to bypass user input.

    When a directory is moved to a preexisting directory, it becomes a subdirectory of the destination directory.

    bash$ mv source_directory target_directory

    bash$ ls -lF target_directory
    total 1
     drwxrwxr-x    2 bozo  bozo      1024 May 28 19:20 source_directory/
    	      

				12.11.2.1.6 rm

    Delete (remove) a file or files. The -f option forces removal of even readonly files, and is useful for bypassing user input in a script.

    Note	The rm command will, by itself, fail to remove filenames beginning with a dash. Why? Because rm sees a dash-prefixed filename as an option.

    bash$ rm -badname
    rm: invalid option -- b
     Try `rm --help' for more information.

    One clever workaround is to precede the filename with a " -- " (the end-of-options flag).

    bash$ rm -- -badname

    Another method to is to preface the filename to be removed with a dot-slash .

    bash$ rm ./-badname

    Warning	When used with the recursive flag -r, this command removes files all the way down the directory tree from the current directory. A careless rm -rf * can wipe out a big chunk of a directory structure.

				12.11.2.1.7 rmdir

    Remove directory. The directory must be empty of all files -- including "invisible" dotfiles [1] -- for this command to succeed.

				12.11.2.1.8 mkdir

    Make directory, creates a new directory. For example, mkdir -p project/programs/December creates the named directory. The -p option automatically creates any necessary parent directories.

				12.11.2.1.9 chmod

    Changes the attributes of an existing file or directory (see Example 14-13).

    chmod +x filename
    # Makes "filename" executable for all users.

    chmod u+s filename
    # Sets "suid" bit on "filename" permissions.
    # An ordinary user may execute "filename" with same privileges as the file's owner.
    # (This does not apply to shell scripts.)

    chmod 644 filename
    # Makes "filename" readable/writable to owner, readable to others
    # (octal mode).

    chmod 444 filename
    #  Makes "filename" read-only for all.
    #  Modifying the file (for example, with a text editor)
    #+ not allowed for a user who does not own the file (except for root),
    #+ and even the file owner must force a file-save
    #+ if she modifies the file.
    #  Same restrictions apply for deleting the file.

    chmod 1777 directory-name
    #  Gives everyone read, write, and execute permission in directory,
    #+ however also sets the "sticky bit".
    #  This means that only the owner of the directory,
    #+ owner of the file, and, of course, root
    #+  can delete any particular file in that directory.

    chmod 111 directory-name
    #  Gives everyone execute-only permission in a directory.
    #  This means that you can execute and READ the files in that directory
    #+ (execute permission necessarily includes read permission
    #+ because you can't execute a file without being able to read it).
    #  But you can't list the files or search for them with the "find" command.
    #  These restrictions do not apply to root.

    chmod 000 directory-name
    #  No permissions at all for that directory.
    #  Can't read, write, or execute files in it.
    #  Can't even list files in it or "cd" to it.
    #  But, you can rename (mv) the directory
    #+ or delete it (rmdir) if it is empty.
    #  You can even symlink to files in the directory,
    #+ but you can't read, write, or execute the symlinks.
    #  These restrictions do not apply to root.

				12.11.2.1.10 chattr

    Change file attributes. This is analogous to chmod above, but with different options and a different invocation syntax, and it works only on ext2/ext3 filesystems.

    One particularly interesting chattr option is i. A chattr +i filename marks the file as immutable. The file cannot be modified, linked to, or deleted, not even by root. This file attribute can be set or removed only by root. In a similar fashion, the a option marks the file as append only.

    root# chattr +i file1.txt


    root# rm file1.txt

    rm: remove write-protected regular file `file1.txt'? y
     rm: cannot remove `file1.txt': Operation not permitted
    	      

    If a file has the s (secure) attribute set, then when it is deleted its block is zeroed out on the disk.

    If a file has the u (undelete) attribute set, then when it is deleted, its contents can still be retrieved (undeleted).

    If a file has the c (compress) attribute set, then it will automatically be compressed on writes to disk, and uncompressed on reads.

    Note	The file attributes set with chattr do not show in a file listing (ls -l).

				12.11.2.1.11 ln

    Creates links to pre-existings files. A "link" is a reference to a file, an alternate name for it. The ln command permits referencing the linked file by more than one name and is a superior alternative to aliasing (see Example 4-6).

    The ln creates only a reference, a pointer to the file only a few bytes in size.

    The ln command is most often used with the -s, symbolic or "soft" link flag. Advantages of using the -s flag are that it permits linking across file systems or to directories.

    The syntax of the command is a bit tricky. For example: ln -s oldfile newfile links the previously existing oldfile to the newly created link, newfile.

    Caution	If a file named newfile has previously existed, an error message will result.

    Which type of link to use?

    As John Macdonald explains it:

    Both of these [types of links] provide a certain measure of dual reference -- if you edit the contents of the file using any name, your changes will affect both the original name and either a hard or soft new name. The differences between them occurs when you work at a higher level. The advantage of a hard link is that the new name is totally independent of the old name -- if you remove or rename the old name, that does not affect the hard link, which continues to point to the data while it would leave a soft link hanging pointing to the old name which is no longer there. The advantage of a soft link is that it can refer to a different file system (since it is just a reference to a file name, not to actual data). And, unlike a hard link, a symbolic link can refer to a directory.

    Links give the ability to invoke a script (or any other type of executable) with multiple names, and having that script behave according to how it was invoked.

    Example 15-2. Hello or Good-bye

    #!/bin/bash
    # hello.sh: Saying "hello" or "goodbye"
    #+          depending on how script is invoked.

    # Make a link in current working directory ($PWD) to this script:
    #    ln -s hello.sh goodbye
    # Now, try invoking this script both ways:
    # ./hello.sh
    # ./goodbye


    HELLO_CALL=65
    GOODBYE_CALL=66

    if [ $0 = "./goodbye" ]
    then
      echo "Good-bye!"
      # Some other goodbye-type commands, as appropriate.
      exit $GOODBYE_CALL
    fi

    echo "Hello!"
    # Some other hello-type commands, as appropriate.
    exit $HELLO_CALL

				12.11.2.1.12 man, info

    These commands access the manual and information pages on system commands and installed utilities. When available, the info pages usually contain more detailed descriptions than do the man pages.

    There have been various attempts at "automating" the writing of man pages. For a script that makes a tentative first step in that direction, 

			12.11.2.2 Complex Commands
Commands for more advanced users

				12.11.2.2.1 find

    -exec COMMAND \;

    Carries out COMMAND on each file that find matches. The command sequence terminates with ; (the ";" is escaped to make certain the shell passes it to find literally, without interpreting it as a special character).

    bash$ find ~/ -name '*.txt'
    /home/bozo/.kde/share/apps/karm/karmdata.txt
     /home/bozo/misc/irmeyc.txt
     /home/bozo/test-scripts/1.txt
    	      

    If COMMAND contains {}, then find substitutes the full path name of the selected file for "{}".

    find ~/ -name 'core*' -exec rm {} \;
    # Removes all core dump files from user's home directory.

    find /home/bozo/projects -mtime 1
    #  Lists all files in /home/bozo/projects directory tree
    #+ that were modified within the last day.
    #
    #  mtime = last modification time of the target file
    #  ctime = last status change time (via 'chmod' or otherwise)
    #  atime = last access time

    DIR=/home/bozo/junk_files
    find "$DIR" -type f -atime +5 -exec rm {} \;
    #                                      ^^
    #  Curly brackets are placeholder for the path name output by "find."
    #
    #  Deletes all files in "/home/bozo/junk_files"
    #+ that have not been accessed in at least 5 days.
    #
    #  "-type filetype", where
    #  f = regular file
    #  d = directory
    #  l = symbolic link, etc.
    #  (The 'find' manpage and info page have complete listings.)

    find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \;

    # Finds all IP addresses (xxx.xxx.xxx.xxx) in /etc directory files.
    # There a few extraneous hits. Can they be filtered out?

    # Possibly by:

    find /etc -type f -exec cat '{}' \; | tr -c '.[:digit:]' '\n' \
    | grep '^[^.][^.]*\.[^.][^.]*\.[^.][^.]*\.[^.][^.]*$'
    #
    #  [:digit:] is one of the character classes
    #+ introduced with the POSIX 1003.2 standard. 

    # Thanks, Stphane Chazelas. 

    Note	The -exec option to find should not be confused with the exec shell builtin.

				12.11.2.2.2 Example 15-3. Badname, eliminate file names in current directory containing bad characters and whitespace.

    #!/bin/bash
    # badname.sh
    # Delete filenames in current directory containing bad characters.

    for filename in *
    do
      badname=`echo "$filename" | sed -n /[\+\{\;\"\\\=\?~\(\)\<\>\&\*\|\$]/p`
    # badname=`echo "$filename" | sed -n '/[+{;"\=?~()<>&*|$]/p'`  also works.
    # Deletes files containing these nasties:     + { ; " \ = ? ~ ( ) < > & * | $
    #
      rm $badname 2>/dev/null
    #             ^^^^^^^^^^^ Error messages deep-sixed.
    done

    # Now, take care of files containing all manner of whitespace.
    find . -name "* *" -exec rm -f {} \;
    # The path name of the file that _find_ finds replaces the "{}".
    # The '\' ensures that the ';' is interpreted literally, as end of command.

    exit 0

    #---------------------------------------------------------------------
    # Commands below this line will not execute because of _exit_ command.

    # An alternative to the above script:
    find . -name '*[+{;"\\=?~()<>&*|$ ]*' -maxdepth 0 \
    -exec rm -f '{}' \;
    #  The "-maxdepth 0" option ensures that _find_ will not search
    #+ subdirectories below $PWD.

    # (Thanks, S.C.)

				12.11.2.2.3 Example 15-4. Deleting a file by its inode number

    #!/bin/bash
    # idelete.sh: Deleting a file by its inode number.

    #  This is useful when a filename starts with an illegal character,
    #+ such as ? or -.

    ARGCOUNT=1                      # Filename arg must be passed to script.
    E_WRONGARGS=70
    E_FILE_NOT_EXIST=71
    E_CHANGED_MIND=72

    if [ $# -ne "$ARGCOUNT" ]
    then
      echo "Usage: `basename $0` filename"
      exit $E_WRONGARGS
    fi  

    if [ ! -e "$1" ]
    then
      echo "File \""$1"\" does not exist."
      exit $E_FILE_NOT_EXIST
    fi  

    inum=`ls -i | grep "$1" | awk '{print $1}'`
    # inum = inode (index node) number of file
    # -----------------------------------------------------------------------
    # Every file has an inode, a record that holds its physical address info.
    # -----------------------------------------------------------------------

    echo; echo -n "Are you absolutely sure you want to delete \"$1\" (y/n)? "
    # The '-v' option to 'rm' also asks this.
    read answer
    case "$answer" in
    [nN]) echo "Changed your mind, huh?"
          exit $E_CHANGED_MIND
          ;;
    *)    echo "Deleting file \"$1\".";;
    esac

    find . -inum $inum -exec rm {} \;
    #                           ^^
    #        Curly brackets are placeholder
    #+       for text output by "find."
    echo "File "\"$1"\" deleted!"

    exit 0

    The find command also works without the -exec option.

    #!/bin/bash
    #  Find suid root files.
    #  A strange suid file might indicate a security hole,
    #+ or even a system intrusion.

    directory="/usr/sbin"
    # Might also try /sbin, /bin, /usr/bin, /usr/local/bin, etc.
    permissions="+4000"  # suid root (dangerous!)


    for file in $( find "$directory" -perm "$permissions" )
    do
      ls -ltF --author "$file"
    done

				12.11.2.2.4 xargs

				    12.11.2.2.4.1 xargs examples, tags: xargs examples 


    A filter for feeding arguments to a command, and also a tool for assembling the commands themselves. It breaks a data stream into small enough chunks for filters and commands to process. Consider it as a powerful replacement for backquotes. In situations where command substitution fails with a too many arguments error, substituting xargs often works. [1] Normally, xargs reads from stdin or from a pipe, but it can also be given the output of a file.

    The default command for xargs is echo. This means that input piped to xargs may have linefeeds and other whitespace characters stripped out.

    bash$ ls -l
    total 0
     -rw-rw-r--    1 bozo  bozo         0 Jan 29 23:58 file1
     -rw-rw-r--    1 bozo  bozo         0 Jan 29 23:58 file2



    bash$ ls -l | xargs
    total 0 -rw-rw-r-- 1 bozo bozo 0 Jan 29 23:58 file1 -rw-rw-r-- 1 bozo bozo 0 Jan...



    bash$ find ~/mail -type f | xargs grep "Linux"
    ./misc:User-Agent: slrn/0.9.8.1 (Linux)
     ./sent-mail-jul-2005: hosted by the Linux Documentation Project.
     ./sent-mail-jul-2005: (Linux Documentation Project Site, rtf version)
     ./sent-mail-jul-2005: Subject: Criticism of Bozo's Windows/Linux article
     ./sent-mail-jul-2005: while mentioning that the Linux ext2/ext3 filesystem
     . . .
    	      

    ls | xargs -p -l gzip gzips every file in current directory, one at a time, prompting before each operation.


    Note that xargs processes the arguments passed to it sequentially, one at a time.

    bash$ find /usr/bin | xargs file
    /usr/bin:          directory
     /usr/bin/foomatic-ppd-options:          perl script text executable
     . . .
    	      

    Tip	An interesting xargs option is -n NN, which limits to NN the number of arguments passed.

    ls | xargs -n 8 echo lists the files in the current directory in 8 columns.

    Tip	Another useful option is -0, in combination with find -print0 or grep -lZ. This allows handling arguments containing whitespace or quotes.

    find / -type f -print0 | xargs -0 grep -liwZ GUI | xargs -0 rm -f

    grep -rliwZ GUI / | xargs -0 rm -f

    Either of the above will remove any file containing "GUI". (Thanks, S.C.)

    Or:

    cat /proc/"$pid"/"$OPTION" | xargs -0 echo
    #  Formats output:         ^^^^^^^^^^^^^^^
    #  From Han Holl's fixup of "get-commandline.sh"
    #+ script in "/dev and /proc" chapter.

				12.11.2.2.5 Example 15-5. Logfile: Using xargs to monitor system log

    #!/bin/bash

    # Generates a log file in current directory
    # from the tail end of /var/log/messages.

    # Note: /var/log/messages must be world readable
    # if this script invoked by an ordinary user.
    #         #root chmod 644 /var/log/messages

    LINES=5

    ( date; uname -a ) >>logfile
    # Time and machine name
    echo ---------------------------------------------------------- >>logfile
    tail -n $LINES /var/log/messages | xargs | fmt -s >>logfile
    echo >>logfile
    echo >>logfile

    exit 0

    #  Note:
    #  ----
    #  As Frank Wang points out,
    #+ unmatched quotes (either single or double quotes) in the source file
    #+ may give xargs indigestion.
    #
    #  He suggests the following substitution for line 15:
    #  tail -n $LINES /var/log/messages | tr -d "\"'" | xargs | fmt -s >>logfile



    #  Exercise:
    #  --------
    #  Modify this script to track changes in /var/log/messages at intervals
    #+ of 20 minutes.
    #  Hint: Use the "watch" command. 

    As in find, a curly bracket pair serves as a placeholder for replacement text.

				12.11.2.2.6 Example 15-6. Copying files in current directory to another

    #!/bin/bash
    # copydir.sh

    #  Copy (verbose) all files in current directory ($PWD)
    #+ to directory specified on command line.

    E_NOARGS=65

    if [ -z "$1" ]   # Exit if no argument given.
    then
      echo "Usage: `basename $0` directory-to-copy-to"
      exit $E_NOARGS
    fi  

    ls . | xargs -i -t cp ./{} $1
    #            ^^ ^^      ^^
    #  -t is "verbose" (output command line to stderr) option.
    #  -i is "replace strings" option.
    #  {} is a placeholder for output text.
    #  This is similar to the use of a curly bracket pair in "find."
    #
    #  List the files in current directory (ls .),
    #+ pass the output of "ls" as arguments to "xargs" (-i -t options),
    #+ then copy (cp) these arguments ({}) to new directory ($1).  
    #
    #  The net result is the exact equivalent of
    #+   cp * $1
    #+ unless any of the filenames has embedded "whitespace" characters.

    exit 0

				12.11.2.2.7 Example 15-7. Killing processes by name

    #!/bin/bash
    # kill-byname.sh: Killing processes by name.
    # Compare this script with kill-process.sh.

    #  For instance,
    #+ try "./kill-byname.sh xterm" --
    #+ and watch all the xterms on your desktop disappear.

    #  Warning:
    #  -------
    #  This is a fairly dangerous script.
    #  Running it carelessly (especially as root)
    #+ can cause data loss and other undesirable effects.

    E_BADARGS=66

    if test -z "$1"  # No command line arg supplied?
    then
      echo "Usage: `basename $0` Process(es)_to_kill"
      exit $E_BADARGS
    fi


    PROCESS_NAME="$1"
    ps ax | grep "$PROCESS_NAME" | awk '{print $1}' | xargs -i kill {} 2&>/dev/null
    #                                                       ^^      ^^

    # ---------------------------------------------------------------
    # Notes:
    # -i is the "replace strings" option to xargs.
    # The curly brackets are the placeholder for the replacement.
    # 2&>/dev/null suppresses unwanted error messages.
    #
    # Can  grep "$PROCESS_NAME" be replaced by pidof "$PROCESS_NAME"?
    # ---------------------------------------------------------------

    exit $?

    #  The "killall" command has the same effect as this script,
    #+ but using it is not quite as educational.

				12.11.2.2.8 Example 15-8. Word frequency analysis using xargs

    #!/bin/bash
    # wf2.sh: Crude word frequency analysis on a text file.

    # Uses 'xargs' to decompose lines of text into single words.
    # Compare this example to the "wf.sh" script later on.


    # Check for input file on command line.
    ARGS=1
    E_BADARGS=65
    E_NOFILE=66

    if [ $# -ne "$ARGS" ]
    # Correct number of arguments passed to script?
    then
      echo "Usage: `basename $0` filename"
      exit $E_BADARGS
    fi

    if [ ! -f "$1" ]       # Check if file exists.
    then
      echo "File \"$1\" does not exist."
      exit $E_NOFILE
    fi



    ########################################################
    cat "$1" | xargs -n1 | \
    #  List the file, one word per line. 
    tr A-Z a-z | \
    #  Shift characters to lowercase.
    sed -e 's/\.//g'  -e 's/\,//g' -e 's/ /\
    /g' | \
    #  Filter out periods and commas, and
    #+ change space between words to linefeed,
    sort | uniq -c | sort -nr
    #  Finally prefix occurrence count and sort numerically.
    ########################################################

    #  This does the same job as the "wf.sh" example,
    #+ but a bit more ponderously, and it runs more slowly (why?).

    exit 0

				12.11.2.2.9 expr

    All-purpose expression evaluator: Concatenates and evaluates the arguments according to the operation given (arguments must be separated by spaces). Operations may be arithmetic, comparison, string, or logical.

    expr 3 + 5

        returns 8
    expr 5 % 3

        returns 2
    expr 1 / 0

        returns the error message, expr: division by zero

        Illegal arithmetic operations not allowed.
    expr 5 \* 3

        returns 15

        The multiplication operator must be escaped when used in an arithmetic expression with expr.
    y=`expr $y + 1`

        Increment a variable, with the same effect as let y=y+1 and y=$(($y+1)). This is an example of arithmetic expansion.
    z=`expr substr $string $position $length`

        Extract substring of $length characters, starting at $position.

				12.11.2.2.10 Example 15-9. Using expr

    #!/bin/bash

    # Demonstrating some of the uses of 'expr'
    # =======================================

    echo

    # Arithmetic Operators
    # ---------- ---------

    echo "Arithmetic Operators"
    echo
    a=`expr 5 + 3`
    echo "5 + 3 = $a"

    a=`expr $a + 1`
    echo
    echo "a + 1 = $a"
    echo "(incrementing a variable)"

    a=`expr 5 % 3`
    # modulo
    echo
    echo "5 mod 3 = $a"

    echo
    echo

    # Logical Operators
    # ------- ---------

    #  Returns 1 if true, 0 if false,
    #+ opposite of normal Bash convention.

    echo "Logical Operators"
    echo

    x=24
    y=25
    b=`expr $x = $y`         # Test equality.
    echo "b = $b"            # 0  ( $x -ne $y )
    echo

    a=3
    b=`expr $a \> 10`
    echo 'b=`expr $a \> 10`, therefore...'
    echo "If a > 10, b = 0 (false)"
    echo "b = $b"            # 0  ( 3 ! -gt 10 )
    echo

    b=`expr $a \< 10`
    echo "If a < 10, b = 1 (true)"
    echo "b = $b"            # 1  ( 3 -lt 10 )
    echo
    # Note escaping of operators.

    b=`expr $a \<= 3`
    echo "If a <= 3, b = 1 (true)"
    echo "b = $b"            # 1  ( 3 -le 3 )
    # There is also a "\>=" operator (greater than or equal to).


    echo
    echo



    # String Operators
    # ------ ---------

    echo "String Operators"
    echo

    a=1234zipper43231
    echo "The string being operated upon is \"$a\"."

    # length: length of string
    b=`expr length $a`
    echo "Length of \"$a\" is $b."

    # index: position of first character in substring
    #        that matches a character in string
    b=`expr index $a 23`
    echo "Numerical position of first \"2\" in \"$a\" is \"$b\"."

    # substr: extract substring, starting position & length specified
    b=`expr substr $a 2 6`
    echo "Substring of \"$a\", starting at position 2,\
    and 6 chars long is \"$b\"."


    #  The default behavior of the 'match' operations is to
    #+ search for the specified match at the ***beginning*** of the string.
    #
    #        uses Regular Expressions
    b=`expr match "$a" '[0-9]*'`               #  Numerical count.
    echo Number of digits at the beginning of \"$a\" is $b.
    b=`expr match "$a" '\([0-9]*\)'`           #  Note that escaped parentheses
    #                   ==      ==              + trigger substring match.
    echo "The digits at the beginning of \"$a\" are \"$b\"."

    echo

    exit 0

    Important	

    The : operator can substitute for match. For example, b=`expr $a : [0-9]*` is the exact equivalent of b=`expr match $a [0-9]*` in the above listing.

    #!/bin/bash

    echo
    echo "String operations using \"expr \$string : \" construct"
    echo "==================================================="
    echo

    a=1234zipper5FLIPPER43231

    echo "The string being operated upon is \"`expr "$a" : '\(.*\)'`\"."
    #     Escaped parentheses grouping operator.            ==  ==

    #       ***************************
    #+          Escaped parentheses
    #+           match a substring
    #       ***************************


    #  If no escaped parentheses...
    #+ then 'expr' converts the string operand to an integer.

    echo "Length of \"$a\" is `expr "$a" : '.*'`."   # Length of string

    echo "Number of digits at the beginning of \"$a\" is `expr "$a" : '[0-9]*'`."

    # ------------------------------------------------------------------------- #

    echo

    echo "The digits at the beginning of \"$a\" are `expr "$a" : '\([0-9]*\)'`."
    #                                                             ==      ==
    echo "The first 7 characters of \"$a\" are `expr "$a" : '\(.......\)'`."
    #         =====                                          ==       ==
    # Again, escaped parentheses force a substring match.
    #
    echo "The last 7 characters of \"$a\" are `expr "$a" : '.*\(.......\)'`."
    #         ====                  end of string operator  ^^
    #  (actually means skip over one or more of any characters until specified
    #+  substring)

    echo

    exit 0

The above script illustrates how expr uses the escaped parentheses -- \( ... \) -- grouping operator in tandem with regular expression parsing to match a substring. Here is a another example, this time from "real life."

# Strip the whitespace from the beginning and end.
LRFDATE=`expr "$LRFDATE" : '[[:space:]]*\(.*\)[[:space:]]*$'`

#  From Peter Knowles' "booklistgen.sh" script
#+ for converting files to Sony Librie/PRS-50X format.
#  (http://booklistgensh.peterknowles.com)

Perl, sed, and awk have far superior string parsing facilities. A short sed or awk "subroutine" within a script (see Section 33.3) is an attractive alternative to expr.

			12.11.2.3 Time / Date Commands
Time/date and timing

				12.11.2.3.1 date

    Simply invoked, date prints the date and time to stdout. Where this command gets interesting is in its formatting and parsing options.

    Example 15-10. Using date

    #!/bin/bash
    # Exercising the 'date' command

    echo "The number of days since the year's beginning is `date +%j`."
    # Needs a leading '+' to invoke formatting.
    # %j gives day of year.

    echo "The number of seconds elapsed since 01/01/1970 is `date +%s`."
    #  %s yields number of seconds since "UNIX epoch" began,
    #+ but how is this useful?

    prefix=temp
    suffix=$(date +%s)  # The "+%s" option to 'date' is GNU-specific.
    filename=$prefix.$suffix
    echo $filename
    #  It's great for creating "unique" temp filenames,
    #+ even better than using $$.

    # Read the 'date' man page for more formatting options.

    exit 0

    The -u option gives the UTC (Universal Coordinated Time).

    bash$ date
    Fri Mar 29 21:07:39 MST 2002



    bash$ date -u
    Sat Mar 30 04:07:42 UTC 2002
    	      

    This option facilitates calculating the time between different dates.

				12.11.2.3.2 Example 15-11. Date calculations

    #!/bin/bash
    # date-calc.sh
    # Author: Nathan Coulter
    # Used in ABS Guide with permission (thanks!).

    MPHR=60    # Minutes per hour.
    HPD=24     # Hours per day.

    diff () {
            printf '%s' $(( $(date -u -d"$TARGET" +%s) -
                            $(date -u -d"$CURRENT" +%s)))
    #                       %d = day of month.
    }


    CURRENT=$(date -u -d '2007-09-01 17:30:24' '+%F %T.%N %Z')
    TARGET=$(date -u -d'2007-12-25 12:30:00' '+%F %T.%N %Z')
    # %F = full date, %T = %H:%M:%S, %N = nanoseconds, %Z = time zone.

    printf '\nIn 2007, %s ' \
           "$(date -d"$CURRENT +
            $(( $(diff) /$MPHR /$MPHR /$HPD / 2 )) days" '+%d %B')" 
    #       %B = name of month                ^ halfway
    printf 'was halfway between %s ' "$(date -d"$CURRENT" '+%d %B')"
    printf 'and %s\n' "$(date -d"$TARGET" '+%d %B')"

    printf '\nOn %s at %s, there were\n' \
            $(date -u -d"$CURRENT" +%F) $(date -u -d"$CURRENT" +%T)
    DAYS=$(( $(diff) / $MPHR / $MPHR / $HPD ))
    CURRENT=$(date -d"$CURRENT +$DAYS days" '+%F %T.%N %Z')
    HOURS=$(( $(diff) / $MPHR / $MPHR ))
    CURRENT=$(date -d"$CURRENT +$HOURS hours" '+%F %T.%N %Z')
    MINUTES=$(( $(diff) / $MPHR ))
    CURRENT=$(date -d"$CURRENT +$MINUTES minutes" '+%F %T.%N %Z')
    printf '%s days, %s hours, ' "$DAYS" "$HOURS"
    printf '%s minutes, and %s seconds ' "$MINUTES" "$(diff)"
    printf 'until Christmas Dinner!\n\n'

    #  Exercise:
    #  --------
    #  Rewrite the diff () function to accept passed parameters,
    #+ rather than using global variables.

    The date command has quite a number of output options. For example %N gives the nanosecond portion of the current time. One interesting use for this is to generate random integers.

    date +%N | sed -e 's/000$//' -e 's/^0//'
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    #  Strip off leading and trailing zeroes, if present.
    #  Length of generated integer depends on
    #+ how many zeroes stripped off.

    # 115281032
    # 63408725
    # 394504284

    There are many more options (try man date).

    date +%j
    # Echoes day of the year (days elapsed since January 1).

    date +%k%M
    # Echoes hour and minute in 24-hour format, as a single digit string.



    # The 'TZ' parameter permits overriding the default time zone.
    date                 # Mon Mar 28 21:42:16 MST 2005
    TZ=EST date          # Mon Mar 28 23:42:16 EST 2005
    # Thanks, Frank Kannemann and Pete Sjoberg, for the tip.


    SixDaysAgo=$(date --date='6 days ago')
    OneMonthAgo=$(date --date='1 month ago')  # Four weeks back (not a month).
    OneYearAgo=$(date --date='1 year ago')

				12.11.2.3.3 zdump

    Time zone dump: echoes the time in a specified time zone.

    bash$ zdump EST
    EST  Tue Sep 18 22:09:22 2001 EST
    	      

				12.11.2.3.4 time

    Outputs very verbose timing statistics for executing a command.

    time ls -l / gives something like this:

    |0.00user 0.01system 0:00.05elapsed 16%CPU (0avgtext+0avgdata 0maxresident)k
     |0inputs+0outputs (149major+27minor)pagefaults 0swaps

    See also the very similar times command in the previous section.

    Note	As of version 2.0 of Bash, time became a shell reserved word, with slightly altered behavior in a pipeline.

				12.11.2.3.5 touch

    Utility for updating access/modification times of a file to current system time or other specified time, but also useful for creating a new file. The command touch zzz will create a new file of zero length, named zzz, assuming that zzz did not previously exist. Time-stamping empty files in this way is useful for storing date information, for example in keeping track of modification times on a project.

    Note	The touch command is equivalent to : >> newfile or >> newfile (for ordinary files).

    Tip	Before doing a cp -u (copy/update), use touch to update the time stamp of files you don't wish overwritten.

    As an example, if the directory /home/bozo/tax_audit contains the files spreadsheet-051606.data, spreadsheet-051706.data, and spreadsheet-051806.data, then doing a touch spreadsheet*.data will protect these files from being overwritten by files with the same names during a cp -u /home/bozo/financial_info/spreadsheet*data /home/bozo/tax_audit.

				12.11.2.3.6 at

    The at job control command executes a given set of commands at a specified time. Superficially, it resembles cron, however, at is chiefly useful for one-time execution of a command set.

    at 2pm January 15 prompts for a set of commands to execute at that time. These commands should be shell-script compatible, since, for all practical purposes, the user is typing in an executable shell script a line at a time. Input terminates with a Ctl-D.

    Using either the -f option or input redirection (<), at reads a command list from a file. This file is an executable shell script, though it should, of course, be non-interactive. Particularly clever is including the run-parts command in the file to execute a different set of scripts.

    bash$ at 2:30 am Friday < at-jobs.list
    job 2 at 2000-10-27 02:30
    	      

				12.11.2.3.7 batch

    The batch job control command is similar to at, but it runs a command list when the system load drops below .8. Like at, it can read commands from a file with the -f option.

    The concept of batch processing dates back to the era of mainframe computers. It means running a set of commands without user intervention.

				12.11.2.3.8 cal

    Prints a neatly formatted monthly calendar to stdout. Will do current year or a large range of past and future years.

				12.11.2.3.9 sleep

    This is the shell equivalent of a wait loop. It pauses for a specified number of seconds, doing nothing. It can be useful for timing or in processes running in the background, checking for a specific event every so often (polling), as in Example 29-6.

    sleep 3     # Pauses 3 seconds.

    Note	The sleep command defaults to seconds, but minute, hours, or days may also be specified.

    sleep 3 h   # Pauses 3 hours!

    Note	The watch command may be a better choice than sleep for running commands at timed intervals.

				12.11.2.3.10 usleep

    Microsleep (the u may be read as the Greek mu, or micro- prefix). This is the same as sleep, above, but "sleeps" in microsecond intervals. It can be used for fine-grained timing, or for polling an ongoing process at very frequent intervals.

    usleep 30     # Pauses 30 microseconds.

    This command is part of the Red Hat initscripts / rc-scripts package.

    Caution	The usleep command does not provide particularly accurate timing, and is therefore unsuitable for critical timing loops.

				12.11.2.3.11 hwclock, clock

    The hwclock command accesses or adjusts the machine's hardware clock. Some options require root privileges. The /etc/rc.d/rc.sysinit startup file uses hwclock to set the system time from the hardware clock at bootup.

    The clock command is a synonym for hwclock.


			12.11.2.4 Text Processing Commands
Commands affecting text and text files

				12.11.2.4.1 sort

    File sort utility, often used as a filter in a pipe. This command sorts a text stream or file forwards or backwards, or according to various keys or character positions. Using the -m option, it merges presorted input files. The info page lists its many capabilities and options. See Example 10-9, Example 10-10, and Example A-8.

				12.11.2.4.2 tsort

    Topological sort, reading in pairs of whitespace-separated strings and sorting according to input patterns. The original purpose of tsort was to sort a list of dependencies for an obsolete version of the ld linker in an "ancient" version of UNIX.

    The results of a tsort will usually differ markedly from those of the standard sort command, above.

				12.11.2.4.3 uniq

    This filter removes duplicate lines from a sorted file. It is often seen in a pipe coupled with sort.

    cat list-1 list-2 list-3 | sort | uniq > final.list
    # Concatenates the list files,
    # sorts them,
    # removes duplicate lines,
    # and finally writes the result to an output file.

    The useful -c option prefixes each line of the input file with its number of occurrences.

    bash$ cat testfile
    This line occurs only once.
     This line occurs twice.
     This line occurs twice.
     This line occurs three times.
     This line occurs three times.
     This line occurs three times.


    bash$ uniq -c testfile
          1 This line occurs only once.
           2 This line occurs twice.
           3 This line occurs three times.


    bash$ sort testfile | uniq -c | sort -nr
          3 This line occurs three times.
           2 This line occurs twice.
           1 This line occurs only once.
    	      

    The sort INPUTFILE | uniq -c | sort -nr command string produces a frequency of occurrence listing on the INPUTFILE file (the -nr options to sort cause a reverse numerical sort). This template finds use in analysis of log files and dictionary lists, and wherever the lexical structure of a document needs to be examined.

				12.11.2.4.4 Example 15-12. Word Frequency Analysis

    #!/bin/bash
    # wf.sh: Crude word frequency analysis on a text file.
    # This is a more efficient version of the "wf2.sh" script.


    # Check for input file on command line.
    ARGS=1
    E_BADARGS=65
    E_NOFILE=66

    if [ $# -ne "$ARGS" ]  # Correct number of arguments passed to script?
    then
      echo "Usage: `basename $0` filename"
      exit $E_BADARGS
    fi

    if [ ! -f "$1" ]       # Check if file exists.
    then
      echo "File \"$1\" does not exist."
      exit $E_NOFILE
    fi



    ########################################################
    # main ()
    sed -e 's/\.//g'  -e 's/\,//g' -e 's/ /\
    /g' "$1" | tr 'A-Z' 'a-z' | sort | uniq -c | sort -nr
    #                           =========================
    #                            Frequency of occurrence

    #  Filter out periods and commas, and
    #+ change space between words to linefeed,
    #+ then shift characters to lowercase, and
    #+ finally prefix occurrence count and sort numerically.

    #  Arun Giridhar suggests modifying the above to:
    #  . . . | sort | uniq -c | sort +1 [-f] | sort +0 -nr
    #  This adds a secondary sort key, so instances of
    #+ equal occurrence are sorted alphabetically.
    #  As he explains it:
    #  "This is effectively a radix sort, first on the
    #+ least significant column
    #+ (word or string, optionally case-insensitive)
    #+ and last on the most significant column (frequency)."
    #
    #  As Frank Wang explains, the above is equivalent to
    #+       . . . | sort | uniq -c | sort +0 -nr
    #+ and the following also works:
    #+       . . . | sort | uniq -c | sort -k1nr -k
    ########################################################

    exit 0

    # Exercises:
    # ---------
    # 1) Add 'sed' commands to filter out other punctuation,
    #+   such as semicolons.
    # 2) Modify the script to also filter out multiple spaces and
    #+   other whitespace.

    bash$ cat testfile
    This line occurs only once.
     This line occurs twice.
     This line occurs twice.
     This line occurs three times.
     This line occurs three times.
     This line occurs three times.


    bash$ ./wf.sh testfile
          6 this
           6 occurs
           6 line
           3 times
           3 three
           2 twice
           1 only
           1 once
    	       

				12.11.2.4.5 expand, unexpand

    The expand filter converts tabs to spaces. It is often used in a pipe.

    The unexpand filter converts spaces to tabs. This reverses the effect of expand.

				12.11.2.4.6 cut

    A tool for extracting fields from files. It is similar to the print $N command set in awk, but more limited. It may be simpler to use cut in a script than awk. Particularly important are the -d (delimiter) and -f (field specifier) options.

    Using cut to obtain a listing of the mounted filesystems:

    cut -d ' ' -f1,2 /etc/mtab

    Using cut to list the OS and kernel version:

    uname -a | cut -d" " -f1,3,11,12

    Using cut to extract message headers from an e-mail folder:

    bash$ grep '^Subject:' read-messages | cut -c10-80
    Re: Linux suitable for mission-critical apps?
     MAKE MILLIONS WORKING AT HOME!!!
     Spam complaint
     Re: Spam complaint

    Using cut to parse a file:

    # List all the users in /etc/passwd.

    FILENAME=/etc/passwd

    for user in $(cut -d: -f1 $FILENAME)
    do
      echo $user
    done

    # Thanks, Oleg Philon for suggesting this.

    cut -d ' ' -f2,3 filename is equivalent to awk -F'[ ]' '{ print $2, $3 }' filename

    Note	It is even possible to specify a linefeed as a delimiter. The trick is to actually embed a linefeed (RETURN) in the command sequence.

    bash$ cut -d'
     ' -f3,7,19 testfile
    This is line 3 of testfile.
     This is line 7 of testfile.
     This is line 19 of testfile.
    	      

    Thank you, Jaka Kranjc, for pointing this out.

				12.11.2.4.7 paste

    Tool for merging together different files into a single, multi-column file. In combination with cut, useful for creating system log files. 

				12.11.2.4.8 join

    Consider this a special-purpose cousin of paste. This powerful utility allows merging two files in a meaningful fashion, which essentially creates a simple version of a relational database.

    The join command operates on exactly two files, but pastes together only those lines with a common tagged field (usually a numerical label), and writes the result to stdout. The files to be joined should be sorted according to the tagged field for the matchups to work properly.

    File: 1.data

    100 Shoes
    200 Laces
    300 Socks

    File: 2.data

    100 $40.00
    200 $1.00
    300 $2.00

    bash$ join 1.data 2.data
    File: 1.data 2.data

     100 Shoes $40.00
     200 Laces $1.00
     300 Socks $2.00
    	      

    Note	The tagged field appears only once in the output.

				12.11.2.4.9 head

    lists the beginning of a file to stdout. The default is 10 lines, but a different number can be specified. The command has a number of interesting options.

    Example 15-13. Which files are scripts?

    #!/bin/bash
    # script-detector.sh: Detects scripts within a directory.

    TESTCHARS=2    # Test first 2 characters.
    SHABANG='#!'   # Scripts begin with a "sha-bang."

    for file in *  # Traverse all the files in current directory.
    do
      if [[ `head -c$TESTCHARS "$file"` = "$SHABANG" ]]
      #      head -c2                      #!
      #  The '-c' option to "head" outputs a specified
      #+ number of characters, rather than lines (the default).
      then
        echo "File \"$file\" is a script."
      else
        echo "File \"$file\" is *not* a script."
      fi
    done
      
    exit 0

    #  Exercises:
    #  ---------
    #  1) Modify this script to take as an optional argument
    #+    the directory to scan for scripts
    #+    (rather than just the current working directory).
    #
    #  2) As it stands, this script gives "false positives" for
    #+    Perl, awk, and other scripting language scripts.
    #     Correct this.

				12.11.2.4.10 Example 15-14. Generating 10-digit random numbers

    #!/bin/bash
    # rnd.sh: Outputs a 10-digit random number

    # Script by Stephane Chazelas.

    head -c4 /dev/urandom | od -N4 -tu4 | sed -ne '1s/.* //p'


    # =================================================================== #

    # Analysis
    # --------

    # head:
    # -c4 option takes first 4 bytes.

    # od:
    # -N4 option limits output to 4 bytes.
    # -tu4 option selects unsigned decimal format for output.

    # sed: 
    # -n option, in combination with "p" flag to the "s" command,
    # outputs only matched lines.



    # The author of this script explains the action of 'sed', as follows.

    # head -c4 /dev/urandom | od -N4 -tu4 | sed -ne '1s/.* //p'
    # ----------------------------------> |

    # Assume output up to "sed" --------> |
    # is 0000000 1198195154\n

    #  sed begins reading characters: 0000000 1198195154\n.
    #  Here it finds a newline character,
    #+ so it is ready to process the first line (0000000 1198195154).
    #  It looks at its <range><action>s. The first and only one is

    #   range     action
    #   1         s/.* //p

    #  The line number is in the range, so it executes the action:
    #+ tries to substitute the longest string ending with a space in the line
    #  ("0000000 ") with nothing (//), and if it succeeds, prints the result
    #  ("p" is a flag to the "s" command here, this is different
    #+ from the "p" command).

    #  sed is now ready to continue reading its input. (Note that before
    #+ continuing, if -n option had not been passed, sed would have printed
    #+ the line once again).

    #  Now, sed reads the remainder of the characters, and finds the
    #+ end of the file.
    #  It is now ready to process its 2nd line (which is also numbered '$' as
    #+ it's the last one).
    #  It sees it is not matched by any <range>, so its job is done.

    #  In few word this sed commmand means:
    #  "On the first line only, remove any character up to the right-most space,
    #+ then print it."

    # A better way to do this would have been:
    #           sed -e 's/.* //;q'

    # Here, two <range><action>s (could have been written
    #           sed -e 's/.* //' -e q):

    #   range                    action
    #   nothing (matches line)   s/.* //
    #   nothing (matches line)   q (quit)

    #  Here, sed only reads its first line of input.
    #  It performs both actions, and prints the line (substituted) before
    #+ quitting (because of the "q" action) since the "-n" option is not passed.

    # =================================================================== #

    # An even simpler altenative to the above one-line script would be:
    #           head -c4 /dev/urandom| od -An -tu4

    exit 0

    See also Example 15-39.

				12.11.2.4.11 tail

    lists the (tail) end of a file to stdout. The default is 10 lines, but this can be changed with the -n option. Commonly used to keep track of changes to a system logfile, using the -f option, which outputs lines appended to the file.

    Example 15-15. Using tail to monitor the system log

    #!/bin/bash

    filename=sys.log

    cat /dev/null > $filename; echo "Creating / cleaning out file."
    #  Creates file if it does not already exist,
    #+ and truncates it to zero length if it does.
    #  : > filename   and   > filename also work.

    tail /var/log/messages > $filename  
    # /var/log/messages must have world read permission for this to work.

    echo "$filename contains tail end of system log."

    exit 0

    Tip	To list a specific line of a text file, pipe the output of head to tail -n 1. For example head -n 8 database.txt | tail -n 1 lists the 8th line of the file database.txt.

    To set a variable to a given block of a text file:

    var=$(head -n $m $filename | tail -n $n)

    # filename = name of file
    # m = from beginning of file, number of lines to end of block
    # n = number of lines to set variable to (trim from end of block)

    Note	Newer implementations of tail deprecate the older tail -$LINES filename usage. The standard tail -n $LINES filename is correct.

				12.11.2.4.12 grep

    A multi-purpose file search tool that uses Regular Expressions. It was originally a command/filter in the venerable ed line editor: g/re/p -- global - regular expression - print.

    grep pattern [file...]
    Search the target file(s) for occurrences of pattern, where pattern may be literal text or a Regular Expression.

    bash$ grep '[rst]ystem.$' osinfo.txt
    The GPL governs the distribution of the Linux operating system.
    	      

    If no target file(s) specified, grep works as a filter on stdout, as in a pipe.

    bash$ ps ax | grep clock
    765 tty1     S      0:00 xclock
     901 pts/1    S      0:00 grep clock
    	      

    The -i option causes a case-insensitive search.

    The -w option matches only whole words.

    The -l option lists only the files in which matches were found, but not the matching lines.

    The -r (recursive) option searches files in the current working directory and all subdirectories below it.

    The -n option lists the matching lines, together with line numbers.

    bash$ grep -n Linux osinfo.txt
    2:This is a file containing information about Linux.
     6:The GPL governs the distribution of the Linux operating system.
    	      

    The -v (or --invert-match) option filters out matches.

    grep pattern1 *.txt | grep -v pattern2

    # Matches all lines in "*.txt" files containing "pattern1",
    # but ***not*** "pattern2".	      

    The -c (--count) option gives a numerical count of matches, rather than actually listing the matches.

    grep -c txt *.sgml   # (number of occurrences of "txt" in "*.sgml" files)


    #   grep -cz .
    #            ^ dot
    # means count (-c) zero-separated (-z) items matching "."
    # that is, non-empty ones (containing at least 1 character).
    # 
    printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -cz .     # 3
    printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -cz '$'   # 5
    printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -cz '^'   # 5
    #
    printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -c '$'    # 9
    # By default, newline chars (\n) separate items to match. 

    # Note that the -z option is GNU "grep" specific.


    # Thanks, S.C.

    The --color (or --colour) option marks the matching string in color (on the console or in an xterm window). Since grep prints out each entire line containing the matching pattern, this lets you see exactly what is being matched. See also the -o option, which shows only the matching portion of the line(s).

    Example 15-16. Printing out the From lines in stored e-mail messages

    #!/bin/bash
    # from.sh

    #  Emulates the useful "from" utility in Solaris, BSD, etc.
    #  Echoes the "From" header line in all messages
    #+ in your e-mail directory.


    MAILDIR=~/mail/*               #  No quoting of variable. Why?
    GREP_OPTS="-H -A 5 --color"    #  Show file, plus extra context lines
                                   #+ and display "From" in color.
    TARGETSTR="^From"              # "From" at beginning of line.

    for file in $MAILDIR           #  No quoting of variable.
    do
      grep $GREP_OPTS "$TARGETSTR" "$file"
      #    ^^^^^^^^^^              #  Again, do not quote this variable.
      echo
    done

    exit $?

    #  Might wish to pipe the output of this script to 'more' or
    #+ redirect it to a file . . .

    When invoked with more than one target file given, grep specifies which file contains matches.

    bash$ grep Linux osinfo.txt misc.txt
    osinfo.txt:This is a file containing information about Linux.
     osinfo.txt:The GPL governs the distribution of the Linux operating system.
     misc.txt:The Linux operating system is steadily gaining in popularity.
    	      

    Tip	To force grep to show the filename when searching only one target file, simply give /dev/null as the second file.

    bash$ grep Linux osinfo.txt /dev/null
    osinfo.txt:This is a file containing information about Linux.
     osinfo.txt:The GPL governs the distribution of the Linux operating system.
    	      

				12.11.2.4.13 Use grep for conditions

    If there is a successful match, grep returns an exit status of 0, which makes it useful in a condition test in a script, especially in combination with the -q option to suppress output.

    SUCCESS=0                      # if grep lookup succeeds
    word=Linux
    filename=data.file

    grep -q "$word" "$filename"    #  The "-q" option
                                   #+ causes nothing to echo to stdout.
    if [ $? -eq $SUCCESS ]
    # if grep -q "$word" "$filename"   can replace lines 5 - 7.
    then
      echo "$word found in $filename"
    else
      echo "$word not found in $filename"
    fi

    Example 29-6 demonstrates how to use grep to search for a word pattern in a system logfile.

    Example 15-17. Emulating grep in a script

    #!/bin/bash
    # grp.sh: Rudimentary reimplementation of grep.

    E_BADARGS=85

    if [ -z "$1" ]    # Check for argument to script.
    then
      echo "Usage: `basename $0` pattern"
      exit $E_BADARGS
    fi  

    echo

    for file in *     # Traverse all files in $PWD.
    do
      output=$(sed -n /"$1"/p $file)  # Command substitution.

      if [ ! -z "$output" ]           # What happens if "$output" is not quoted?
      then
        echo -n "$file: "
        echo "$output"
      fi              #  sed -ne "/$1/s|^|${file}: |p"  is equivalent to above.

      echo
    done  

    echo

    exit 0

    # Exercises:
    # ---------
    # 1) Add newlines to output, if more than one match in any given file.
    # 2) Add features.

    How can grep search for two (or more) separate patterns? What if you want grep to display all lines in a file or files that contain both "pattern1" and "pattern2"?

    One method is to pipe the result of grep pattern1 to grep pattern2.

    For example, given the following file:

    # Filename: tstfile

    This is a sample file.
    This is an ordinary text file.
    This file does not contain any unusual text.
    This file is not unusual.
    Here is some text.

    Now, let's search this file for lines containing both "file" and "text" . . .

    bash$ grep file tstfile
    # Filename: tstfile
     This is a sample file.
     This is an ordinary text file.
     This file does not contain any unusual text.
     This file is not unusual.

    bash$ grep file tstfile | grep text
    This is an ordinary text file.
     This file does not contain any unusual text.

    Now, for an interesting recreational use of grep . . .

				12.11.2.4.14 Example 15-18. Crossword puzzle solver

    #!/bin/bash
    # cw-solver.sh
    # This is actually a wrapper around a one-liner (line 46).

    #  Crossword puzzle and anagramming word game solver.
    #  You know *some* of the letters in the word you're looking for,
    #+ so you need a list of all valid words
    #+ with the known letters in given positions.
    #  For example: w...i....n
    #               1???5????10
    # w in position 1, 3 unknowns, i in the 5th, 4 unknowns, n at the end.
    # (See comments at end of script.)


    E_NOPATT=71
    DICT=/usr/share/dict/word.lst
    #                    ^^^^^^^^   Looks for word list here.
    #  ASCII word list, one word per line.
    #  If you happen to need an appropriate list,
    #+ download the author's "yawl" word list package.
    #  http://ibiblio.org/pub/Linux/libs/yawl-0.3.2.tar.gz
    #  or
    #  http://personal.riverusers.com/~thegrendel/yawl-0.3.2.tar.gz


    if [ -z "$1" ]   #  If no word pattern specified
    then             #+ as a command-line argument . . .
      echo           #+ . . . then . . .
      echo "Usage:"  #+ Usage message.
      echo
      echo ""$0" \"pattern,\""
      echo "where \"pattern\" is in the form"
      echo "xxx..x.x..."
      echo
      echo "The x's represent known letters,"
      echo "and the periods are unknown letters (blanks)."
      echo "Letters and periods can be in any position."
      echo "For example, try:   sh cw-solver.sh w...i....n"
      echo
      exit $E_NOPATT
    fi

    echo
    # ===============================================
    # This is where all the work gets done.
    grep ^"$1"$ "$DICT"   # Yes, only one line!
    #    |    |
    # ^ is start-of-word regex anchor.
    # $ is end-of-word regex anchor.

    #  From _Stupid Grep Tricks_, vol. 1,
    #+ a book the ABS Guide author may yet get around
    #+ to writing . . . one of these days . . .
    # ===============================================
    echo


    exit $?  # Script terminates here.
    #  If there are too many words generated,
    #+ redirect the output to a file.

    $ sh cw-solver.sh w...i....n

    wellington
    workingman
    workingmen

				12.11.2.4.15 egrep
				-- extended grep -- is the same as grep -E. This uses a somewhat different, extended set of Regular Expressions, which can make the search a bit more flexible. It also allows the boolean | (or) operator.

    bash $ egrep 'matches|Matches' file.txt
    Line 1 matches.
     Line 3 Matches.
     Line 4 contains matches, but also Matches
                  

				12.11.2.4.16 fgrep
				-- fast grep -- is the same as grep -F. It does a literal string search (no Regular Expressions), which generally speeds things up a bit.

    Note	On some Linux distros, egrep and fgrep are symbolic links to, or aliases for grep, but invoked with the -E and -F options, respectively.

    Example 15-19. Looking up definitions in Webster's 1913 Dictionary

    #!/bin/bash
    # dict-lookup.sh

    #  This script looks up definitions in the 1913 Webster's Dictionary.
    #  This Public Domain dictionary is available for download
    #+ from various sites, including
    #+ Project Gutenberg (http://www.gutenberg.org/etext/247).
    #
    #  Convert it from DOS to UNIX format (only LF at end of line)
    #+ before using it with this script.
    #  Store the file in plain, uncompressed ASCII.
    #  Set DEFAULT_DICTFILE variable below to path/filename.


    E_BADARGS=65
    MAXCONTEXTLINES=50                        # Maximum number of lines to show.
    DEFAULT_DICTFILE="/usr/share/dict/webster1913-dict.txt"
                                              # Default dictionary file pathname.
                                              # Change this as necessary.
    #  Note:
    #  ----
    #  This particular edition of the 1913 Webster's
    #+ begins each entry with an uppercase letter
    #+ (lowercase for the remaining characters).
    #  Only the *very first line* of an entry begins this way,
    #+ and that's why the search algorithm below works.



    if [[ -z $(echo "$1" | sed -n '/^[A-Z]/p') ]]
    #  Must at least specify word to look up, and
    #+ it must start with an uppercase letter.
    then
      echo "Usage: `basename $0` Word-to-define [dictionary-file]"
      echo
      echo "Note: Word to look up must start with capital letter,"
      echo "with the rest of the word in lowercase."
      echo "--------------------------------------------"
      echo "Examples: Abandon, Dictionary, Marking, etc."
      exit $E_BADARGS
    fi


    if [ -z "$2" ]                            #  May specify different dictionary
                                              #+ as an argument to this script.
    then
      dictfile=$DEFAULT_DICTFILE
    else
      dictfile="$2"
    fi

    # ---------------------------------------------------------
    Definition=$(fgrep -A $MAXCONTEXTLINES "$1 \\" "$dictfile")
    #                  Definitions in form "Word \..."
    #
    #  And, yes, "fgrep" is fast enough
    #+ to search even a very large text file.


    # Now, snip out just the definition block.

    echo "$Definition" |
    sed -n '1,/^[A-Z]/p' |
    #  Print from first line of output
    #+ to the first line of the next entry.
    sed '$d' | sed '$d'
    #  Delete last two lines of output
    #+ (blank line and first line of next entry).
    # ---------------------------------------------------------

    exit 0

    # Exercises:
    # ---------
    # 1)  Modify the script to accept any type of alphabetic input
    #   + (uppercase, lowercase, mixed case), and convert it
    #   + to an acceptable format for processing.
    #
    # 2)  Convert the script to a GUI application,
    #   + using something like 'gdialog' or 'zenity' . . .
    #     The script will then no longer take its argument(s)
    #   + from the command line.
    #
    # 3)  Modify the script to parse one of the other available
    #   + Public Domain Dictionaries, such as the U.S. Census Bureau Gazetteer.

    Note	See also Example A-43 for an example of speedy fgrep lookup on a large text file.

				12.11.2.4.17 agrep
				(approximate grep) extends the capabilities of grep to approximate matching. The search string may differ by a specified number of characters from the resulting matches. This utility is not part of the core Linux distribution.

    Tip	To search compressed files, use zgrep, zegrep, or zfgrep. These also work on non-compressed files, though slower than plain grep, egrep, fgrep. They are handy for searching through a mixed set of files, some compressed, some not.

    To search bzipped files, use bzgrep.

				12.11.2.4.18 look

    The command look works like grep, but does a lookup on a "dictionary," a sorted word list. By default, look searches for a match in /usr/dict/words, but a different dictionary file may be specified.

    Example 15-20. Checking words in a list for validity

    #!/bin/bash
    # lookup: Does a dictionary lookup on each word in a data file.

    file=words.data  # Data file from which to read words to test.

    echo

    while [ "$word" != end ]  # Last word in data file.
    do               # ^^^
      read word      # From data file, because of redirection at end of loop.
      look $word > /dev/null  # Don't want to display lines in dictionary file.
      lookup=$?      # Exit status of 'look' command.

      if [ "$lookup" -eq 0 ]
      then
        echo "\"$word\" is valid."
      else
        echo "\"$word\" is invalid."
      fi  

    done <"$file"    # Redirects stdin to $file, so "reads" come from there.

    echo

    exit 0

    # ----------------------------------------------------------------
    # Code below line will not execute because of "exit" command above.


    # Stephane Chazelas proposes the following, more concise alternative:

    while read word && [[ $word != end ]]
    do if look "$word" > /dev/null
       then echo "\"$word\" is valid."
       else echo "\"$word\" is invalid."
       fi
    done <"$file"

    exit 0

				12.11.2.4.19 sed, awk

    Scripting languages especially suited for parsing text files and command output. May be embedded singly or in combination in pipes and shell scripts.
sed Non-interactive "stream editor", permits using many ex commands in batch mode. It finds many uses in shell scripts.
awk Programmable file extractor and formatter, good for manipulating and/or extracting fields (columns) in structured text files. Its syntax is similar to C.

				12.11.2.4.20 wc

    wc gives a "word count" on a file or I/O stream:

    bash $ wc /usr/share/doc/sed-4.1.2/README
    13  70  447 README
    [13 lines  70 words  447 characters]

    wc -w gives only the word count.

    wc -l gives only the line count.

    wc -c gives only the byte count.

    wc -m gives only the character count.

    wc -L gives only the length of the longest line.

    Using wc to count how many .txt files are in current working directory:

    $ ls *.txt | wc -l
    #  Will work as long as none of the "*.txt" files
    #+ have a linefeed embedded in their name.

    #  Alternative ways of doing this are:
    #      find . -maxdepth 1 -name \*.txt -print0 | grep -cz .
    #      (shopt -s nullglob; set -- *.txt; echo $#)

    #  Thanks, S.C.

    Using wc to total up the size of all the files whose names begin with letters in the range d - h

    bash$ wc [d-h]* | grep total | awk '{print $3}'
    71832
    	      

    Using wc to count the instances of the word "Linux" in the main source file for this book.

    bash$ grep Linux abs-book.sgml | wc -l
    50
    	      


    Certain commands include some of the functionality of wc as options.

    ... | grep foo | wc -l
    # This frequently used construct can be more concisely rendered.

    ... | grep -c foo
    # Just use the "-c" (or "--count") option of grep.

    # Thanks, S.C.

				12.11.2.4.21 tr

    character translation filter.

    Caution	Must use quoting and/or brackets, as appropriate. Quotes prevent the shell from reinterpreting the special characters in tr command sequences. Brackets should be quoted to prevent expansion by the shell.

    Either tr "A-Z" "*" <filename or tr A-Z \* <filename changes all the uppercase letters in filename to asterisks (writes to stdout). On some systems this may not work, but tr A-Z '[**]' will.

    The -d option deletes a range of characters.

    echo "abcdef"                 # abcdef
    echo "abcdef" | tr -d b-d     # aef


    tr -d 0-9 <filename
    # Deletes all digits from the file "filename".

    The --squeeze-repeats (or -s) option deletes all but the first instance of a string of consecutive characters. This option is useful for removing excess whitespace.

    bash$ echo "XXXXX" | tr --squeeze-repeats 'X'
    X

    The -c "complement" option inverts the character set to match. With this option, tr acts only upon those characters not matching the specified set.

    bash$ echo "acfdeb123" | tr -c b-d +
    +c+d+b++++

    Note that tr recognizes POSIX character classes. [1]

    bash$ echo "abcd2ef1" | tr '[:alpha:]' -
    ----2--1
    	      

				12.11.2.4.22 Example 15-21. toupper: Transforms a file to all uppercase.

    #!/bin/bash
    # Changes a file to all uppercase.

    E_BADARGS=65

    if [ -z "$1" ]  # Standard check for command line arg.
    then
      echo "Usage: `basename $0` filename"
      exit $E_BADARGS
    fi  

    tr a-z A-Z <"$1"

    # Same effect as above, but using POSIX character set notation:
    #        tr '[:lower:]' '[:upper:]' <"$1"
    # Thanks, S.C.

    exit 0

    #  Exercise:
    #  Rewrite this script to give the option of changing a file
    #+ to *either* upper or lowercase.

				12.11.2.4.23 Example 15-22. lowercase: Changes all filenames in working directory to lowercase.

    #!/bin/bash
    #
    #  Changes every filename in working directory to all lowercase.
    #
    #  Inspired by a script of John Dubois,
    #+ which was translated into Bash by Chet Ramey,
    #+ and considerably simplified by the author of the ABS Guide.


    for filename in *                # Traverse all files in directory.
    do
       fname=`basename $filename`
       n=`echo $fname | tr A-Z a-z`  # Change name to lowercase.
       if [ "$fname" != "$n" ]       # Rename only files not already lowercase.
       then
         mv $fname $n
       fi  
    done   

    exit $?


    # Code below this line will not execute because of "exit".
    #--------------------------------------------------------#
    # To run it, delete script above line.

    # The above script will not work on filenames containing blanks or newlines.
    # Stephane Chazelas therefore suggests the following alternative:


    for filename in *    # Not necessary to use basename,
                         # since "*" won't return any file containing "/".
    do n=`echo "$filename/" | tr '[:upper:]' '[:lower:]'`
    #                             POSIX char set notation.
    #                    Slash added so that trailing newlines are not
    #                    removed by command substitution.
       # Variable substitution:
       n=${n%/}          # Removes trailing slash, added above, from filename.
       [[ $filename == $n ]] || mv "$filename" "$n"
                         # Checks if filename already lowercase.
    done

    exit $?

				12.11.2.4.24 Example 15-23. du: DOS to UNIX text file conversion.

    #!/bin/bash
    # Du.sh: DOS to UNIX text file converter.

    E_WRONGARGS=65

    if [ -z "$1" ]
    then
      echo "Usage: `basename $0` filename-to-convert"
      exit $E_WRONGARGS
    fi

    NEWFILENAME=$1.unx

    CR='\015'  # Carriage return.
               # 015 is octal ASCII code for CR.
               # Lines in a DOS text file end in CR-LF.
               # Lines in a UNIX text file end in LF only.

    tr -d $CR < $1 > $NEWFILENAME
    # Delete CR's and write to new file.

    echo "Original DOS text file is \"$1\"."
    echo "Converted UNIX text file is \"$NEWFILENAME\"."

    exit 0

    # Exercise:
    # --------
    # Change the above script to convert from UNIX to DOS.

				12.11.2.4.25 Example 15-24. rot13: ultra-weak encryption.

    #!/bin/bash
    # rot13.sh: Classic rot13 algorithm,
    #           encryption that might fool a 3-year old.

    # Usage: ./rot13.sh filename
    # or     ./rot13.sh <filename
    # or     ./rot13.sh and supply keyboard input (stdin)

    cat "$@" | tr 'a-zA-Z' 'n-za-mN-ZA-M'   # "a" goes to "n", "b" to "o", etc.
    #  The 'cat "$@"' construction
    #+ permits getting input either from stdin or from files.

    exit 0

				12.11.2.4.26 Example 15-25. Generating "Crypto-Quote" Puzzles

    #!/bin/bash
    # crypto-quote.sh: Encrypt quotes

    #  Will encrypt famous quotes in a simple monoalphabetic substitution.
    #  The result is similar to the "Crypto Quote" puzzles
    #+ seen in the Op Ed pages of the Sunday paper.


    key=ETAOINSHRDLUBCFGJMQPVWZYXK
    # The "key" is nothing more than a scrambled alphabet.
    # Changing the "key" changes the encryption.

    # The 'cat "$@"' construction gets input either from stdin or from files.
    # If using stdin, terminate input with a Control-D.
    # Otherwise, specify filename as command-line parameter.

    cat "$@" | tr "a-z" "A-Z" | tr "A-Z" "$key"
    #        |  to uppercase  |     encrypt       
    # Will work on lowercase, uppercase, or mixed-case quotes.
    # Passes non-alphabetic characters through unchanged.


    # Try this script with something like:
    # "Nothing so needs reforming as other people's habits."
    # --Mark Twain
    #
    # Output is:
    # "CFPHRCS QF CIIOQ MINFMBRCS EQ FPHIM GIFGUI'Q HETRPQ."
    # --BEML PZERC

    # To reverse the encryption:
    # cat "$@" | tr "$key" "A-Z"


    #  This simple-minded cipher can be broken by an average 12-year old
    #+ using only pencil and paper.

    exit 0

    #  Exercise:
    #  --------
    #  Modify the script so that it will either encrypt or decrypt,
    #+ depending on command-line argument(s).

    tr variants

    The tr utility has two historic variants. The BSD version does not use brackets (tr a-z A-Z), but the SysV one does (tr '[a-z]' '[A-Z]'). The GNU version of tr resembles the BSD one. 

				12.11.2.4.27 fold

    A filter that wraps lines of input to a specified width. This is especially useful with the -s option, which breaks lines at word spaces.

				12.11.2.4.28 fmt

    Simple-minded file formatter, used as a filter in a pipe to "wrap" long lines of text output.

    Example 15-26. Formatted file listing.

    #!/bin/bash

    WIDTH=40                    # 40 columns wide.

    b=`ls /usr/local/bin`       # Get a file listing...

    echo $b | fmt -w $WIDTH

    # Could also have been done by
    #    echo $b | fold - -s -w $WIDTH
     
    exit 0

    See also Example 15-5.

    Tip	A powerful alternative to fmt is Kamil Toman's par utility, available from http://www.cs.berkeley.edu/~amc/Par/. 

				12.11.2.4.29 col

    This deceptively named filter removes reverse line feeds from an input stream. It also attempts to replace whitespace with equivalent tabs. The chief use of col is in filtering the output from certain text processing utilities, such as groff and tbl.
column

    Column formatter. This filter transforms list-type text output into a "pretty-printed" table by inserting tabs at appropriate places.

    Example 15-27. Using column to format a directory listing

    #!/bin/bash
    # colms.sh
    # A minor modification of the example file in the "column" man page.


    (printf "PERMISSIONS LINKS OWNER GROUP SIZE MONTH DAY HH:MM PROG-NAME\n" \
    ; ls -l | sed 1d) | column -t
    #         ^^^^^^           ^^

    #  The "sed 1d" in the pipe deletes the first line of output,
    #+ which would be "total        N",
    #+ where "N" is the total number of files found by "ls -l".

    # The -t option to "column" pretty-prints a table.

    exit 0

				12.11.2.4.30 colrm

    Column removal filter. This removes columns (characters) from a file and writes the file, lacking the range of specified columns, back to stdout. colrm 2 4 <filename removes the second through fourth characters from each line of the text file filename.

    Caution	If the file contains tabs or nonprintable characters, this may cause unpredictable behavior. In such cases, consider using expand and unexpand in a pipe preceding colrm.


				12.11.2.4.31 nl

    Line numbering filter: nl filename lists filename to stdout, but inserts consecutive numbers at the beginning of each non-blank line. If filename omitted, operates on stdin.

    The output of nl is very similar to cat -b, since, by default nl does not list blank lines.

    Example 15-28. nl: A self-numbering script.

    #!/bin/bash
    # line-number.sh

    # This script echoes itself twice to stdout with its lines numbered.

    # 'nl' sees this as line 4 since it does not number blank lines.
    # 'cat -n' sees the above line as number 6.

    nl `basename $0`

    echo; echo  # Now, let's try it with 'cat -n'

    cat -n `basename $0`
    # The difference is that 'cat -n' numbers the blank lines.
    # Note that 'nl -ba' will also do so.

    exit 0
    # -----------------------------------------------------------------

				12.11.2.4.32 pr

    Print formatting filter. This will paginate files (or stdout) into sections suitable for hard copy printing or viewing on screen. Various options permit row and column manipulation, joining lines, setting margins, numbering lines, adding page headers, and merging files, among other things. The pr command combines much of the functionality of nl, paste, fold, column, and expand.

    pr -o 5 --width=65 fileZZZ | more gives a nice paginated listing to screen of fileZZZ with margins set at 5 and 65.

    A particularly useful option is -d, forcing double-spacing (same effect as sed -G).

				12.11.2.4.33 gettext

    The GNU gettext package is a set of utilities for localizing and translating the text output of programs into foreign languages. While originally intended for C programs, it now supports quite a number of programming and scripting languages.

    The gettext program works on shell scripts. See the info page.

				12.11.2.4.34 msgfmt

    A program for generating binary message catalogs. It is used for localization.

				12.11.2.4.35 iconv

    A utility for converting file(s) to a different encoding (character set). Its chief use is for localization.

    # Convert a string from UTF-8 to UTF-16 and print to the BookList
    function write_utf8_string {
        STRING=$1
        BOOKLIST=$2
        echo -n "$STRING" | iconv -f UTF8 -t UTF16 | \
        cut -b 3- | tr -d \\n >> "$BOOKLIST"
    }

    #  From Peter Knowles' "booklistgen.sh" script
    #+ for converting files to Sony Librie/PRS-50X format.
    #  (http://booklistgensh.peterknowles.com)

				12.11.2.4.36 recode

    Consider this a fancier version of iconv, above. This very versatile utility for converting a file to a different encoding scheme. Note that recode is not part of the standard Linux installation.


				12.11.2.4.37 TeX, gs

    TeX and Postscript are text markup languages used for preparing copy for printing or formatted video display.

    TeX is Donald Knuth's elaborate typsetting system. It is often convenient to write a shell script encapsulating all the options and arguments passed to one of these markup languages.

    Ghostscript (gs) is a GPL-ed Postscript interpreter.

				12.11.2.4.38 texexec

    Utility for processing TeX and pdf files. Found in /usr/bin on many Linux distros, it is actually a shell wrapper that calls Perl to invoke Tex.

    texexec --pdfarrange --result=Concatenated.pdf *pdf

    #  Concatenates all the pdf files in the current working directory
    #+ into the merged file, Concatenated.pdf . . .
    #  (The --pdfarrange option repaginates a pdf file. See also --pdfcombine.)
    #  The above command line could be parameterized and put into a shell script.

				12.11.2.4.39 enscript

    Utility for converting plain text file to PostScript

    For example, enscript filename.txt -p filename.ps produces the PostScript output file filename.ps.

				12.11.2.4.40 groff, tbl, eqn

    Yet another text markup and display formatting language is groff. This is the enhanced GNU version of the venerable UNIX roff/troff display and typesetting package. Manpages use groff.

    The tbl table processing utility is considered part of groff, as its function is to convert table markup into groff commands.

    The eqn equation processing utility is likewise part of groff, and its function is to convert equation markup into groff commands.

    Example 15-29. manview: Viewing formatted manpages

    #!/bin/bash
    # manview.sh: Formats the source of a man page for viewing.

    #  This script is useful when writing man page source.
    #  It lets you look at the intermediate results on the fly
    #+ while working on it.

    E_WRONGARGS=85

    if [ -z "$1" ]
    then
      echo "Usage: `basename $0` filename"
      exit $E_WRONGARGS
    fi

    # ---------------------------
    groff -Tascii -man $1 | less
    # From the man page for groff.
    # ---------------------------

    #  If the man page includes tables and/or equations,
    #+ then the above code will barf.
    #  The following line can handle such cases.
    #
    #   gtbl < "$1" | geqn -Tlatin1 | groff -Tlatin1 -mtty-char -man
    #
    #   Thanks, S.C.

    exit 0

    See also Example A-41.

				12.11.2.4.41 lex, yacc

    The lex lexical analyzer produces programs for pattern matching. This has been replaced by the nonproprietary flex on Linux systems.

    The yacc utility creates a parser based on a set of specifications. This has been replaced by the nonproprietary bison on Linux systems.



			12.11.2.5 File and Archiving Commands
Archiving

				12.11.2.5.1 tar

    The standard UNIX archiving utility. [1] Originally a Tape ARchiving program, it has developed into a general purpose package that can handle all manner of archiving with all types of destination devices, ranging from tape drives to regular files to even stdout (see Example 3-4). GNU tar has been patched to accept various compression filters, for example: tar czvf archive_name.tar.gz *, which recursively archives and gzips all files in a directory tree except dotfiles in the current working directory ($PWD). [2]

    Some useful tar options:

|       1.  -c create (a new archive)
|       2.  -x extract (files from existing archive)
|       3.  --delete delete (files from existing archive)
|
|          Caution	This option will not work on magnetic tape devices.
|       4.  -r append (files to existing archive)
|       5.  -A append (tar files to existing archive)
|       6.  -t list (contents of existing archive)
|       7.  -u update archive
|       8.  -d compare archive with specified filesystem
|       9.  --after-date only process files with a date stamp after specified date
|      10.  -z gzip the archive
|(compress or uncompress, depending on whether combined with the -c or -x) option
|      11.  -j bzip2 the archive

    Caution	It may be difficult to recover data from a corrupted gzipped tar archive. When archiving important files, make multiple backups.

				12.11.2.5.2 shar

    Shell archiving utility. The files in a shell archive are concatenated without compression, and the resultant archive is essentially a shell script, complete with #!/bin/sh header, and containing all the necessary unarchiving commands. Shar archives still show up in Usenet newsgroups, but otherwise shar has been pretty well replaced by tar/gzip. The unshar command unpacks shar archives.

				12.11.2.5.3 ar

    Creation and manipulation utility for archives, mainly used for binary object file libraries.

				12.11.2.5.4 rpm

    The Red Hat Package Manager, or rpm utility provides a wrapper for source or binary archives. It includes commands for installing and checking the integrity of packages, among other things.

    A simple rpm -i package_name.rpm usually suffices to install a package, though there are many more options available.

    Tip	rpm -qf identifies which package a file originates from.

    bash$ rpm -qf /bin/ls
    coreutils-5.2.1-31
    	      

    Tip	rpm -qa gives a complete list of all installed rpm packages on a given system. An rpm -qa package_name lists only the package(s) corresponding to package_name.

    bash$ rpm -qa
    redhat-logos-1.1.3-1
     glibc-2.2.4-13
     cracklib-2.7-12
     dosfstools-2.7-1
     gdbm-1.8.0-10
     ksymoops-2.4.1-1
     mktemp-1.5-11
     perl-5.6.0-17
     reiserfs-utils-3.x.0j-2
     ...


    bash$ rpm -qa docbook-utils
    docbook-utils-0.6.9-2


    bash$ rpm -qa docbook | grep docbook
    docbook-dtd31-sgml-1.0-10
     docbook-style-dsssl-1.64-3
     docbook-dtd30-sgml-1.0-10
     docbook-dtd40-sgml-1.0-11
     docbook-utils-pdf-0.6.9-2
     docbook-dtd41-sgml-1.0-10
     docbook-utils-0.6.9-2
    	      

				12.11.2.5.5 cpio

    This specialized archiving copy command (copy input and output) is rarely seen any more, having been supplanted by tar/gzip. It still has its uses, such as moving a directory tree. With an appropriate block size (for copying) specified, it can be appreciably faster than tar.

				12.11.2.5.6 Example 15-30. Using cpio to move a directory tree

    #!/bin/bash

    # Copying a directory tree using cpio.

    # Advantages of using 'cpio':
    #   Speed of copying. It's faster than 'tar' with pipes.
    #   Well suited for copying special files (named pipes, etc.)
    #+  that 'cp' may choke on.

    ARGS=2
    E_BADARGS=65

    if [ $# -ne "$ARGS" ]
    then
      echo "Usage: `basename $0` source destination"
      exit $E_BADARGS
    fi  

    source="$1"
    destination="$2"

    ###################################################################
    find "$source" -depth | cpio -admvp "$destination"
    #               ^^^^^         ^^^^^
    #  Read the 'find' and 'cpio' info pages to decipher these options.
    #  The above works only relative to $PWD (current directory) . . .
    #+ full pathnames are specified.
    ###################################################################


    # Exercise:
    # --------

    #  Add code to check the exit status ($?) of the 'find | cpio' pipe
    #+ and output appropriate error messages if anything went wrong.

    exit $?

				12.11.2.5.7 rpm2cpio

    This command extracts a cpio archive from an rpm one.

    Example 15-31. Unpacking an rpm archive

    #!/bin/bash
    # de-rpm.sh: Unpack an 'rpm' archive

    : ${1?"Usage: `basename $0` target-file"}
    # Must specify 'rpm' archive name as an argument.


    TEMPFILE=$$.cpio                         #  Tempfile with "unique" name.
                                             #  $$ is process ID of script.

    rpm2cpio < $1 > $TEMPFILE                #  Converts rpm archive into
                                             #+ cpio archive.
    cpio --make-directories -F $TEMPFILE -i  #  Unpacks cpio archive.
    rm -f $TEMPFILE                          #  Deletes cpio archive.

    exit 0

    #  Exercise:
    #  Add check for whether 1) "target-file" exists and
    #+                       2) it is an rpm archive.
    #  Hint:                    Parse output of 'file' command.

Compression

				12.11.2.5.8 gzip

    The standard GNU/UNIX compression utility, replacing the inferior and proprietary compress. The corresponding decompression command is gunzip, which is the equivalent of gzip -d.

    Note	The -c option sends the output of gzip to stdout. This is useful when piping to other commands.

    The zcat filter decompresses a gzipped file to stdout, as possible input to a pipe or redirection. This is, in effect, a cat command that works on compressed files (including files processed with the older compress utility). The zcat command is equivalent to gzip -dc.

    Caution	On some commercial UNIX systems, zcat is a synonym for uncompress -c, and will not work on gzipped files.

				12.11.2.5.9 bzip2

    An alternate compression utility, usually more efficient (but slower) than gzip, especially on large files. The corresponding decompression command is bunzip2.

    Note	Newer versions of tar have been patched with bzip2 support.

				12.11.2.5.10 compress, uncompress

    This is an older, proprietary compression utility found in commercial UNIX distributions. The more efficient gzip has largely replaced it. Linux distributions generally include a compress workalike for compatibility, although gunzip can unarchive files treated with compress.

    Tip	The znew command transforms compressed files into gzipped ones.

				12.11.2.5.11 sq

    Yet another compression (squeeze) utility, a filter that works only on sorted ASCII word lists. It uses the standard invocation syntax for a filter, sq < input-file > output-file. Fast, but not nearly as efficient as gzip. The corresponding uncompression filter is unsq, invoked like sq.

    Tip	The output of sq may be piped to gzip for further compression.

				12.11.2.5.12 zip, unzip

    Cross-platform file archiving and compression utility compatible with DOS pkzip.exe. "Zipped" archives seem to be a more common medium of file exchange on the Internet than "tarballs."
unarc, unarj, unrar

    These Linux utilities permit unpacking archives compressed with the DOS arc.exe, arj.exe, and rar.exe programs.
lzma, unlzma, lzcat

    Highly efficient Lempel-Ziv-Markov compression. The syntax of lzma is similar to that of gzip. The 7-zip Website has more information.

File Information

				12.11.2.5.13 file

    A utility for identifying file types. The command file file-name will return a file specification for file-name, such as ascii text or data. It references the magic numbers found in /usr/share/magic, /etc/magic, or /usr/lib/magic, depending on the Linux/UNIX distribution.

    The -f option causes file to run in batch mode, to read from a designated file a list of filenames to analyze. The -z option, when used on a compressed target file, forces an attempt to analyze the uncompressed file type.

    bash$ file test.tar.gz
    test.tar.gz: gzip compressed data, deflated,
     last modified: Sun Sep 16 13:34:51 2001, os: Unix

    bash file -z test.tar.gz
    test.tar.gz: GNU tar archive (gzip compressed data, deflated,
     last modified: Sun Sep 16 13:34:51 2001, os: Unix)
    	      

    # Find sh and Bash scripts in a given directory:

    DIRECTORY=/usr/local/bin
    KEYWORD=Bourne
    # Bourne and Bourne-Again shell scripts

    file $DIRECTORY/* | fgrep $KEYWORD

    # Output:

    # /usr/local/bin/burn-cd:          Bourne-Again shell script text executable
    # /usr/local/bin/burnit:           Bourne-Again shell script text executable
    # /usr/local/bin/cassette.sh:      Bourne shell script text executable
    # /usr/local/bin/copy-cd:          Bourne-Again shell script text executable
    # . . .

    Example 15-32. Stripping comments from C program files

    #!/bin/bash
    # strip-comment.sh: Strips out the comments (/* COMMENT */) in a C program.

    E_NOARGS=0
    E_ARGERROR=66
    E_WRONG_FILE_TYPE=67

    if [ $# -eq "$E_NOARGS" ]
    then
      echo "Usage: `basename $0` C-program-file" >&2 # Error message to stderr.
      exit $E_ARGERROR
    fi  

    # Test for correct file type.
    type=`file $1 | awk '{ print $2, $3, $4, $5 }'`
    # "file $1" echoes file type . . .
    # Then awk removes the first field, the filename . . .
    # Then the result is fed into the variable "type."
    correct_type="ASCII C program text"

    if [ "$type" != "$correct_type" ]
    then
      echo
      echo "This script works on C program files only."
      echo
      exit $E_WRONG_FILE_TYPE
    fi  


    # Rather cryptic sed script:
    #--------
    sed '
    /^\/\*/d
    /.*\*\//d
    ' $1
    #--------
    # Easy to understand if you take several hours to learn sed fundamentals.


    #  Need to add one more line to the sed script to deal with
    #+ case where line of code has a comment following it on same line.
    #  This is left as a non-trivial exercise.

    #  Also, the above code deletes non-comment lines with a "*/" . . .
    #+ not a desirable result.

    exit 0


    # ----------------------------------------------------------------
    # Code below this line will not execute because of 'exit 0' above.

    # Stephane Chazelas suggests the following alternative:

    usage() {
      echo "Usage: `basename $0` C-program-file" >&2
      exit 1
    }

    WEIRD=`echo -n -e '\377'`   # or WEIRD=$'\377'
    [[ $# -eq 1 ]] || usage
    case `file "$1"` in
      *"C program text"*) sed -e "s%/\*%${WEIRD}%g;s%\*/%${WEIRD}%g" "$1" \
         | tr '\377\n' '\n\377' \
         | sed -ne 'p;n' \
         | tr -d '\n' | tr '\377' '\n';;
      *) usage;;
    esac

    #  This is still fooled by things like:
    #  printf("/*");
    #  or
    #  /*  /* buggy embedded comment */
    #
    #  To handle all special cases (comments in strings, comments in string
    #+ where there is a \", \\" ...),
    #+ the only way is to write a C parser (using lex or yacc perhaps?).

    exit 0

				12.11.2.5.14 which

    which command gives the full path to "command." This is useful for finding out whether a particular command or utility is installed on the system.

    $bash which rm

    /usr/bin/rm

				12.11.2.5.15 whereis

    Similar to which, above, whereis command gives the full path to "command," but also to its manpage.

    $bash whereis rm

    rm: /bin/rm /usr/share/man/man1/rm.1.bz2

				12.11.2.5.16 whatis

    whatis command looks up "command" in the whatis database. This is useful for identifying system commands and important configuration files. Consider it a simplified man command.

    $bash whatis whatis

    whatis               (1)  - search the whatis database for complete words

    Example 15-33. Exploring /usr/X11R6/bin

    #!/bin/bash

    # What are all those mysterious binaries in /usr/X11R6/bin?

    DIRECTORY="/usr/X11R6/bin"
    # Try also "/bin", "/usr/bin", "/usr/local/bin", etc.

    for file in $DIRECTORY/*
    do
      whatis `basename $file`   # Echoes info about the binary.
    done

    exit 0

    # You may wish to redirect output of this script, like so:
    # ./what.sh >>whatis.db
    # or view it a page at a time on stdout,
    # ./what.sh | less

    See also Example 10-3.

				12.11.2.5.17 vdir

    Show a detailed directory listing. The effect is similar to ls -lb.

    This is one of the GNU fileutils.

    bash$ vdir
    total 10
     -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
     -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
     -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo

    bash ls -l
    total 10
     -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
     -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
     -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo
    	      

				12.11.2.5.18 locate, slocate

    The locate command searches for files using a database stored for just that purpose. The slocate command is the secure version of locate (which may be aliased to slocate).

    $bash locate hickson

    /usr/lib/xephem/catalogs/hickson.edb

				12.11.2.5.19 readlink

    Disclose the file that a symbolic link points to.

    bash$ readlink /usr/bin/awk
    ../../bin/gawk
    	      

				12.11.2.5.20 strings

    Use the strings command to find printable strings in a binary or data file. It will list sequences of printable characters found in the target file. This might be handy for a quick 'n dirty examination of a core dump or for looking at an unknown graphic image file (strings image-file | more might show something like JFIF, which would identify the file as a jpeg graphic). In a script, you would probably parse the output of strings with grep or sed. See Example 10-7 and Example 10-9.

    Example 15-34. An "improved" strings command

    #!/bin/bash
    # wstrings.sh: "word-strings" (enhanced "strings" command)
    #
    #  This script filters the output of "strings" by checking it
    #+ against a standard word list file.
    #  This effectively eliminates gibberish and noise,
    #+ and outputs only recognized words.

    # ===========================================================
    #                 Standard Check for Script Argument(s)
    ARGS=1
    E_BADARGS=65
    E_NOFILE=66

    if [ $# -ne $ARGS ]
    then
      echo "Usage: `basename $0` filename"
      exit $E_BADARGS
    fi

    if [ ! -f "$1" ]                      # Check if file exists.
    then
        echo "File \"$1\" does not exist."
        exit $E_NOFILE
    fi
    # ===========================================================


    MINSTRLEN=3                           #  Minimum string length.
    WORDFILE=/usr/share/dict/linux.words  #  Dictionary file.
    #  May specify a different word list file
    #+ of one-word-per-line format.
    #  For example, the "yawl" word-list package,
    #  http://personal.riverusers.com/~thegrendel/yawl-0.3.2.tar.gz


    wlist=`strings "$1" | tr A-Z a-z | tr '[:space:]' Z | \
    tr -cs '[:alpha:]' Z | tr -s '\173-\377' Z | tr Z ' '`

    # Translate output of 'strings' command with multiple passes of 'tr'.
    #  "tr A-Z a-z"  converts to lowercase.
    #  "tr '[:space:]'"  converts whitespace characters to Z's.
    #  "tr -cs '[:alpha:]' Z"  converts non-alphabetic characters to Z's,
    #+ and squeezes multiple consecutive Z's.
    #  "tr -s '\173-\377' Z"  converts all characters past 'z' to Z's
    #+ and squeezes multiple consecutive Z's,
    #+ which gets rid of all the weird characters that the previous
    #+ translation failed to deal with.
    #  Finally, "tr Z ' '" converts all those Z's to whitespace,
    #+ which will be seen as word separators in the loop below.

    #  ****************************************************************
    #  Note the technique of feeding the output of 'tr' back to itself,
    #+ but with different arguments and/or options on each pass.
    #  ****************************************************************


    for word in $wlist                    # Important:
                                          # $wlist must not be quoted here.
                                          # "$wlist" does not work.
                                          # Why not?
    do

      strlen=${#word}                     # String length.
      if [ "$strlen" -lt "$MINSTRLEN" ]   # Skip over short strings.
      then
        continue
      fi

      grep -Fw $word "$WORDFILE"          #  Match whole words only.
    #      ^^^                            #  "Fixed strings" and
                                          #+ "whole words" options. 

    done  


    exit $?

Comparison

				12.11.2.5.21 diff, patch

    diff: flexible file comparison utility. It compares the target files line-by-line sequentially. In some applications, such as comparing word dictionaries, it may be helpful to filter the files through sort and uniq before piping them to diff. diff file-1 file-2 outputs the lines in the files that differ, with carets showing which file each particular line belongs to.

    The --side-by-side option to diff outputs each compared file, line by line, in separate columns, with non-matching lines marked. The -c and -u options likewise make the output of the command easier to interpret.

    There are available various fancy frontends for diff, such as sdiff, wdiff, xdiff, and mgdiff.

    Tip	The diff command returns an exit status of 0 if the compared files are identical, and 1 if they differ. This permits use of diff in a test construct within a shell script (see below).

    A common use for diff is generating difference files to be used with patch The -e option outputs files suitable for ed or ex scripts.

    patch: flexible versioning utility. Given a difference file generated by diff, patch can upgrade a previous version of a package to a newer version. It is much more convenient to distribute a relatively small "diff" file than the entire body of a newly revised package. Kernel "patches" have become the preferred method of distributing the frequent releases of the Linux kernel.

    patch -p1 <patch-file
    # Takes all the changes listed in 'patch-file'
    # and applies them to the files referenced therein.
    # This upgrades to a newer version of the package.

    Patching the kernel:

    cd /usr/src
    gzip -cd patchXX.gz | patch -p0
    # Upgrading kernel source using 'patch'.
    # From the Linux kernel docs "README",
    # by anonymous author (Alan Cox?).

    Note	The diff command can also recursively compare directories (for the filenames present).

    bash$ diff -r ~/notes1 ~/notes2
    Only in /home/bozo/notes1: file02
     Only in /home/bozo/notes1: file03
     Only in /home/bozo/notes2: file04
    	      

    Tip	Use zdiff to compare gzipped files.

    Tip	Use diffstat to create a histogram (point-distribution graph) of output from diff.

				12.11.2.5.22 diff3, merge

    An extended version of diff that compares three files at a time. This command returns an exit value of 0 upon successful execution, but unfortunately this gives no information about the results of the comparison.

    bash$ diff3 file-1 file-2 file-3
    ====
     1:1c
       This is line 1 of "file-1".
     2:1c
       This is line 1 of "file-2".
     3:1c
       This is line 1 of "file-3"
    	      

    The merge (3-way file merge) command is an interesting adjunct to diff3. Its syntax is merge Mergefile file1 file2. The result is to output to Mergefile the changes that lead from file1 to file2. Consider this command a stripped-down version of patch.

				12.11.2.5.23 sdiff

    Compare and/or edit two files in order to merge them into an output file. Because of its interactive nature, this command would find little use in a script.

				12.11.2.5.24 cmp

    The cmp command is a simpler version of diff, above. Whereas diff reports the differences between two files, cmp merely shows at what point they differ.

    Note	Like diff, cmp returns an exit status of 0 if the compared files are identical, and 1 if they differ. This permits use in a test construct within a shell script.

    Example 15-35. Using cmp to compare two files within a script.

    #!/bin/bash

    ARGS=2  # Two args to script expected.
    E_BADARGS=65
    E_UNREADABLE=66

    if [ $# -ne "$ARGS" ]
    then
      echo "Usage: `basename $0` file1 file2"
      exit $E_BADARGS
    fi

    if [[ ! -r "$1" || ! -r "$2" ]]
    then
      echo "Both files to be compared must exist and be readable."
      exit $E_UNREADABLE
    fi

    cmp $1 $2 &> /dev/null  # /dev/null buries the output of the "cmp" command.
    #   cmp -s $1 $2  has same result ("-s" silent flag to "cmp")
    #   Thank you  Anders Gustavsson for pointing this out.
    #
    # Also works with 'diff', i.e.,   diff $1 $2 &> /dev/null

    if [ $? -eq 0 ]         # Test exit status of "cmp" command.
    then
      echo "File \"$1\" is identical to file \"$2\"."
    else  
      echo "File \"$1\" differs from file \"$2\"."
    fi

    exit 0

    Tip	Use zcmp on gzipped files.

				12.11.2.5.25 comm

    Versatile file comparison utility. The files must be sorted for this to be useful.

    comm -options first-file second-file

    comm file-1 file-2 outputs three columns:

        * column 1 = lines unique to file-1
        * column 2 = lines unique to file-2
        * column 3 = lines common to both.

    The options allow suppressing output of one or more columns.

        * -1 suppresses column 1
        * -2 suppresses column 2
        * -3 suppresses column 3
        * -12 suppresses both columns 1 and 2, etc.

    This command is useful for comparing "dictionaries" or word lists -- sorted text files with one word per line.

Utilities

				12.11.2.5.26 basename

    Strips the path information from a file name, printing only the file name. The construction basename $0 lets the script know its name, that is, the name it was invoked by. This can be used for "usage" messages if, for example a script is called with missing arguments:

    echo "Usage: `basename $0` arg1 arg2 ... argn"

				12.11.2.5.27 dirname

    Strips the basename from a filename, printing only the path information.

    Note	basename and dirname can operate on any arbitrary string. The argument does not need to refer to an existing file, or even be a filename for that matter (see Example A-7).

    Example 15-36. basename and dirname

    #!/bin/bash

    a=/home/bozo/daily-journal.txt

    echo "Basename of /home/bozo/daily-journal.txt = `basename $a`"
    echo "Dirname of /home/bozo/daily-journal.txt = `dirname $a`"
    echo
    echo "My own home is `basename ~/`."         # `basename ~` also works.
    echo "The home of my home is `dirname ~/`."  # `dirname ~`  also works.

    exit 0

				12.11.2.5.28 split, csplit

    These are utilities for splitting a file into smaller chunks. Their usual use is for splitting up large files in order to back them up on floppies or preparatory to e-mailing or uploading them.

    The csplit command splits a file according to context, the split occuring where patterns are matched.

    Example 15-37. A script that copies itself in sections

    #!/bin/bash
    # splitcopy.sh

    #  A script that splits itself into chunks,
    #+ then reassembles the chunks into an exact copy
    #+ of the original script.

    CHUNKSIZE=4    #  Size of first chunk of split files.
    OUTPREFIX=xx   #  csplit prefixes, by default,
                   #+ files with "xx" ...

    csplit "$0" "$CHUNKSIZE"

    # Some comment lines for padding . . .
    # Line 15
    # Line 16
    # Line 17
    # Line 18
    # Line 19
    # Line 20

    cat "$OUTPREFIX"* > "$0.copy"  # Concatenate the chunks.
    rm "$OUTPREFIX"*               # Get rid of the chunks.

    exit $?

Encoding and Encryption

				12.11.2.5.29 sum, cksum, md5sum, sha1sum

    These are utilities for generating checksums. A checksum is a number mathematically calculated from the contents of a file, for the purpose of checking its integrity. A script might refer to a list of checksums for security purposes, such as ensuring that the contents of key system files have not been altered or corrupted. For security applications, use the md5sum (message digest 5 checksum) command, or better yet, the newer sha1sum (Secure Hash Algorithm).

    bash$ cksum /boot/vmlinuz
    1670054224 804083 /boot/vmlinuz

    bash$ echo -n "Top Secret" | cksum
    3391003827 10



    bash$ md5sum /boot/vmlinuz
    0f43eccea8f09e0a0b2b5cf1dcf333ba  /boot/vmlinuz

    bash$ echo -n "Top Secret" | md5sum
    8babc97a6f62a4649716f4df8d61728f  -
    	      

    Note	The cksum command shows the size, in bytes, of its target, whether file or stdout.

    The md5sum and sha1sum commands display a dash when they receive their input from stdout.

    Example 15-38. Checking file integrity

    #!/bin/bash
    # file-integrity.sh: Checking whether files in a given directory
    #                    have been tampered with.

    E_DIR_NOMATCH=70
    E_BAD_DBFILE=71

    dbfile=File_record.md5
    # Filename for storing records (database file).


    set_up_database ()
    {
      echo ""$directory"" > "$dbfile"
      # Write directory name to first line of file.
      md5sum "$directory"/* >> "$dbfile"
      # Append md5 checksums and filenames.
    }

    check_database ()
    {
      local n=0
      local filename
      local checksum

      # ------------------------------------------- #
      #  This file check should be unnecessary,
      #+ but better safe than sorry.

      if [ ! -r "$dbfile" ]
      then
        echo "Unable to read checksum database file!"
        exit $E_BAD_DBFILE
      fi
      # ------------------------------------------- #

      while read record[n]
      do

        directory_checked="${record[0]}"
        if [ "$directory_checked" != "$directory" ]
        then
          echo "Directories do not match up!"
          # Tried to use file for a different directory.
          exit $E_DIR_NOMATCH
        fi

        if [ "$n" -gt 0 ]   # Not directory name.
        then
          filename[n]=$( echo ${record[$n]} | awk '{ print $2 }' )
          #  md5sum writes records backwards,
          #+ checksum first, then filename.
          checksum[n]=$( md5sum "${filename[n]}" )


          if [ "${record[n]}" = "${checksum[n]}" ]
          then
            echo "${filename[n]} unchanged."

          elif [ "`basename ${filename[n]}`" != "$dbfile" ]
                 #  Skip over checksum database file,
                 #+ as it will change with each invocation of script.
    	     #  ---
    	     #  This unfortunately means that when running
    	     #+ this script on $PWD, tampering with the
    	     #+ checksum database file will not be detected.
    	     #  Exercise: Fix this.
    	then
              echo "${filename[n]} : CHECKSUM ERROR!"
            # File has been changed since last checked.
          fi

          fi



        let "n+=1"
      done <"$dbfile"       # Read from checksum database file. 

    }  

    # =================================================== #
    # main ()

    if [ -z  "$1" ]
    then
      directory="$PWD"      #  If not specified,
    else                    #+ use current working directory.
      directory="$1"
    fi  

    clear                   # Clear screen.
    echo " Running file integrity check on $directory"
    echo

    # ------------------------------------------------------------------ #
      if [ ! -r "$dbfile" ] # Need to create database file?
      then
        echo "Setting up database file, \""$directory"/"$dbfile"\"."; echo
        set_up_database
      fi  
    # ------------------------------------------------------------------ #

    check_database          # Do the actual work.

    echo 

    #  You may wish to redirect the stdout of this script to a file,
    #+ especially if the directory checked has many files in it.

    exit 0

    #  For a much more thorough file integrity check,
    #+ consider the "Tripwire" package,
    #+ http://sourceforge.net/projects/tripwire/.

    Also see Example A-20, Example 33-14, and Example 9-11 for creative uses of the md5sum command.

    Note	There have been reports that the 128-bit md5sum can be cracked, so the more secure 160-bit sha1sum is a welcome new addition to the checksum toolkit.

    bash$ md5sum testfile
    e181e2c8720c60522c4c4c981108e367  testfile


    bash$ sha1sum testfile
    5d7425a9c08a66c3177f1e31286fa40986ffc996  testfile
    	      

    Security consultants have demonstrated that even sha1sum can be compromised. Fortunately, newer Linux distros include longer bit-length sha224sum, sha256sum, sha384sum, and sha512sum commands.

				12.11.2.5.30 shred

    Securely erase a file by overwriting it multiple times with random bit patterns before deleting it. This command has the same effect as Example 15-60, but does it in a more thorough and elegant manner.

    This is one of the GNU fileutils.

    Caution	Advanced forensic technology may still be able to recover the contents of a file, even after application of shred.

				12.11.2.5.31 uuencode

    This utility encodes binary files (images, sound files, compressed files, etc.) into ASCII characters, making them suitable for transmission in the body of an e-mail message or in a newsgroup posting. This is especially useful where MIME (multimedia) encoding is not available.

				12.11.2.5.32 uudecode

    This reverses the encoding, decoding uuencoded files back into the original binaries.

    Example 15-39. Uudecoding encoded files

    #!/bin/bash
    # Uudecodes all uuencoded files in current working directory.

    lines=35        # Allow 35 lines for the header (very generous).

    for File in *   # Test all the files in $PWD.
    do
      search1=`head -n $lines $File | grep begin | wc -w`
      search2=`tail -n $lines $File | grep end | wc -w`
      #  Uuencoded files have a "begin" near the beginning,
      #+ and an "end" near the end.
      if [ "$search1" -gt 0 ]
      then
        if [ "$search2" -gt 0 ]
        then
          echo "uudecoding - $File -"
          uudecode $File
        fi  
      fi
    done  

    #  Note that running this script upon itself fools it
    #+ into thinking it is a uuencoded file,
    #+ because it contains both "begin" and "end".

    #  Exercise:
    #  --------
    #  Modify this script to check each file for a newsgroup header,
    #+ and skip to next if not found.

    exit 0

    Tip	The fold -s command may be useful (possibly in a pipe) to process long uudecoded text messages downloaded from Usenet newsgroups.

				12.11.2.5.33 mimencode, mmencode

    The mimencode and mmencode commands process multimedia-encoded e-mail attachments. Although mail user agents (such as pine or kmail) normally handle this automatically, these particular utilities permit manipulating such attachments manually from the command line or in batch processing mode by means of a shell script.

				12.11.2.5.34 crypt

    At one time, this was the standard UNIX file encryption utility. [3] Politically motivated government regulations prohibiting the export of encryption software resulted in the disappearance of crypt from much of the UNIX world, and it is still missing from most Linux distributions. Fortunately, programmers have come up with a number of decent alternatives to it, among them the author's very own cruft (see Example A-4). 

    ccrypt is also a great utility available under cygwin.

Miscellaneous

				12.11.2.5.35 mktemp

    Create a temporary file [4] with a "unique" filename. When invoked from the command line without additional arguments, it creates a zero-length file in the /tmp directory.

    bash$ mktemp
    /tmp/tmp.zzsvql3154
    	      

    PREFIX=filename
    tempfile=`mktemp $PREFIX.XXXXXX`
    #                        ^^^^^^ Need at least 6 placeholders
    #+                              in the filename template.
    #   If no filename template supplied,
    #+ "tmp.XXXXXXXXXX" is the default.

    echo "tempfile name = $tempfile"
    # tempfile name = filename.QA2ZpY
    #                 or something similar...

    #  Creates a file of that name in the current working directory
    #+ with 600 file permissions.
    #  A "umask 177" is therefore unnecessary,
    #+ but it's good programming practice anyhow.

				12.11.2.5.36 make

    Utility for building and compiling binary packages. This can also be used for any set of operations that is triggered by incremental changes in source files.

    The make command checks a Makefile, a list of file dependencies and operations to be carried out.

    The make utility is, in effect, a powerful scripting language similar in many ways to Bash, but with the capability of recognizing dependencies. For in-depth coverage of this useful tool set, see the GNU software documentation site.

				12.11.2.5.37 install

    Special purpose file copying command, similar to cp, but capable of setting permissions and attributes of the copied files. This command seems tailormade for installing software packages, and as such it shows up frequently in Makefiles (in the make install : section). It could likewise find use in installation scripts.

				12.11.2.5.38 dos2unix

    This utility, written by Benjamin Lin and collaborators, converts DOS-formatted text files (lines terminated by CR-LF) to UNIX format (lines terminated by LF only), and vice-versa.

				12.11.2.5.39 ptx

    The ptx [targetfile] command outputs a permuted index (cross-reference list) of the targetfile. This may be further filtered and formatted in a pipe, if necessary.
    
				12.11.2.5.40 more, less

    Pagers that display a text file or stream to stdout, one screenful at a time. These may be used to filter the output of stdout . . . or of a script.

    An interesting application of more is to "test drive" a command sequence, to forestall potentially unpleasant consequences.

    ls /home/bozo | awk '{print "rm -rf " $1}' | more
    #                                            ^^^^
    		 
    # Testing the effect of the following (disastrous) command line:
    #      ls /home/bozo | awk '{print "rm -rf " $1}' | sh
    #      Hand off to the shell to execute . . .       ^^

    The less pager has the interesting property of doing a formatted display of man page source. See Example A-41.

			12.11.2.6 Communications Commands
Certain of the following commands find use in network data transfer and analysis, as well as in chasing spammers.

Information and Statistics

				12.11.2.6.1 host

    Searches for information about an Internet host by name or IP address, using DNS.

    bash$ host surfacemail.com
    surfacemail.com. has address 202.92.42.236
    	      

				12.11.2.6.2 ipcalc

    Displays IP information for a host. With the -h option, ipcalc does a reverse DNS lookup, finding the name of the host (server) from the IP address.

    bash$ ipcalc -h 202.92.42.236
    HOSTNAME=surfacemail.com
    	      

				12.11.2.6.3 nslookup

    Do an Internet "name server lookup" on a host by IP address. This is essentially equivalent to ipcalc -h or dig -x . The command may be run either interactively or noninteractively, i.e., from within a script.

    The nslookup command has allegedly been "deprecated," but it is still useful.

    bash$ nslookup -sil 66.97.104.180
    nslookup kuhleersparnis.ch
     Server:         135.116.137.2
     Address:        135.116.137.2#53

     Non-authoritative answer:
     Name:   kuhleersparnis.ch
    	      

				12.11.2.6.4 dig

    Domain Information Groper. Similar to nslookup, dig does an Internet name server lookup on a host. May be run from the command line or from within a script.

    Some interesting options to dig are +time=N for setting a query timeout to N seconds, +nofail for continuing to query servers until a reply is received, and -x for doing a reverse address lookup.

    Compare the output of dig -x with ipcalc -h and nslookup.

    bash$ dig -x 81.9.6.2
    ;; Got answer:
     ;; ->>HEADER<<- opcode: QUERY, status: NXDOMAIN, id: 11649
     ;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 0

     ;; QUESTION SECTION:
     ;2.6.9.81.in-addr.arpa.         IN      PTR

     ;; AUTHORITY SECTION:
     |     6.9.81.in-addr.arpa.    3600    IN      SOA     ns.eltel.net. noc.eltel.net.
     |     2002031705 900 600 86400 3600

     ;; Query time: 537 msec
     ;; SERVER: 135.116.137.2#53(135.116.137.2)
     ;; WHEN: Wed Jun 26 08:35:24 2002
     ;; MSG SIZE  rcvd: 91
    	      

				12.11.2.6.5 Example 15-40. Finding out where to report a spammer

    #!/bin/bash
    # spam-lookup.sh: Look up abuse contact to report a spammer.
    # Thanks, Michael Zick.

    # Check for command-line arg.
    ARGCOUNT=1
    E_WRONGARGS=65
    if [ $# -ne "$ARGCOUNT" ]
    then
      echo "Usage: `basename $0` domain-name"
      exit $E_WRONGARGS
    fi


    dig +short $1.contacts.abuse.net -c in -t txt
    # Also try:
    #     dig +nssearch $1
    #     Tries to find "authoritative name servers" and display SOA records.

    # The following also works:
    #     whois -h whois.abuse.net $1
    #           ^^ ^^^^^^^^^^^^^^^  Specify host.  
    #     Can even lookup multiple spammers with this, i.e."
    #     whois -h whois.abuse.net $spamdomain1 $spamdomain2 . . .


    #  Exercise:
    #  --------
    #  Expand the functionality of this script
    #+ so that it automatically e-mails a notification
    #+ to the responsible ISP's contact address(es).
    #  Hint: use the "mail" command.

    exit $?

    # spam-lookup.sh chinatietong.com
    #                A known spam domain.

    # "crnet_mgr@chinatietong.com"
    # "crnet_tec@chinatietong.com"
    # "postmaster@chinatietong.com"


    #  For a more elaborate version of this script,
    #+ see the SpamViz home page, http://www.spamviz.net/index.html.

				12.11.2.6.6 Example 15-41. Analyzing a spam domain

    #! /bin/bash
    # is-spammer.sh: Identifying spam domains

    # $Id: is-spammer, v 1.4 2004/09/01 19:37:52 mszick Exp $
    # Above line is RCS ID info.
    #
    #  This is a simplified version of the "is_spammer.bash
    #+ script in the Contributed Scripts appendix.

    # is-spammer <domain.name>

    # Uses an external program: 'dig'
    # Tested with version: 9.2.4rc5

    # Uses functions.
    # Uses IFS to parse strings by assignment into arrays.
    # And even does something useful: checks e-mail blacklists.

    # Use the domain.name(s) from the text body:
    # http://www.good_stuff.spammer.biz/just_ignore_everything_else
    #                       ^^^^^^^^^^^
    # Or the domain.name(s) from any e-mail address:
    # Really_Good_Offer@spammer.biz
    #
    # as the only argument to this script.
    #(PS: have your Inet connection running)
    #
    # So, to invoke this script in the above two instances:
    #       is-spammer.sh spammer.biz


    # Whitespace == :Space:Tab:Line Feed:Carriage Return:
    WSP_IFS=$'\x20'$'\x09'$'\x0A'$'\x0D'

    # No Whitespace == Line Feed:Carriage Return
    No_WSP=$'\x0A'$'\x0D'

    # Field separator for dotted decimal ip addresses
    ADR_IFS=${No_WSP}'.'

    # Get the dns text resource record.
    # get_txt <error_code> <list_query>
    get_txt() {

        # Parse $1 by assignment at the dots.
        local -a dns
        IFS=$ADR_IFS
        dns=( $1 )
        IFS=$WSP_IFS
        if [ "${dns[0]}" == '127' ]
        then
            # See if there is a reason.
            echo $(dig +short $2 -t txt)
        fi
    }

    # Get the dns address resource record.
    # chk_adr <rev_dns> <list_server>
    chk_adr() {
        local reply
        local server
        local reason

        server=${1}${2}
        reply=$( dig +short ${server} )

        # If reply might be an error code . . .
        if [ ${#reply} -gt 6 ]
        then
            reason=$(get_txt ${reply} ${server} )
            reason=${reason:-${reply}}
        fi
        echo ${reason:-' not blacklisted.'}
    }

    # Need to get the IP address from the name.
    echo 'Get address of: '$1
    ip_adr=$(dig +short $1)
    dns_reply=${ip_adr:-' no answer '}
    echo ' Found address: '${dns_reply}

    # A valid reply is at least 4 digits plus 3 dots.
    if [ ${#ip_adr} -gt 6 ]
    then
        echo
        declare query

        # Parse by assignment at the dots.
        declare -a dns
        IFS=$ADR_IFS
        dns=( ${ip_adr} )
        IFS=$WSP_IFS

        # Reorder octets into dns query order.
        rev_dns="${dns[3]}"'.'"${dns[2]}"'.'"${dns[1]}"'.'"${dns[0]}"'.'

    # See: http://www.spamhaus.org (Conservative, well maintained)
        echo -n 'spamhaus.org says: '
        echo $(chk_adr ${rev_dns} 'sbl-xbl.spamhaus.org')

    # See: http://ordb.org (Open mail relays)
        echo -n '   ordb.org  says: '
        echo $(chk_adr ${rev_dns} 'relays.ordb.org')

    # See: http://www.spamcop.net/ (You can report spammers here)
        echo -n ' spamcop.net says: '
        echo $(chk_adr ${rev_dns} 'bl.spamcop.net')

    # # # other blacklist operations # # #

    # See: http://cbl.abuseat.org.
        echo -n ' abuseat.org says: '
        echo $(chk_adr ${rev_dns} 'cbl.abuseat.org')

    # See: http://dsbl.org/usage (Various mail relays)
        echo
        echo 'Distributed Server Listings'
        echo -n '       list.dsbl.org says: '
        echo $(chk_adr ${rev_dns} 'list.dsbl.org')

        echo -n '   multihop.dsbl.org says: '
        echo $(chk_adr ${rev_dns} 'multihop.dsbl.org')

        echo -n 'unconfirmed.dsbl.org says: '
        echo $(chk_adr ${rev_dns} 'unconfirmed.dsbl.org')

    else
        echo
        echo 'Could not use that address.'
    fi

    exit 0

    # Exercises:
    # --------

    # 1) Check arguments to script,
    #    and exit with appropriate error message if necessary.

    # 2) Check if on-line at invocation of script,
    #    and exit with appropriate error message if necessary.

    # 3) Substitute generic variables for "hard-coded" BHL domains.

    # 4) Set a time-out for the script using the "+time=" option
         to the 'dig' command.

    For a much more elaborate version of the above script, see Example A-30.

				12.11.2.6.7 traceroute

    Trace the route taken by packets sent to a remote host. This command works within a LAN, WAN, or over the Internet. The remote host may be specified by an IP address. The output of this command may be filtered by grep or sed in a pipe.

    bash$ traceroute 81.9.6.2
    traceroute to 81.9.6.2 (81.9.6.2), 30 hops max, 38 byte packets
     1  tc43.xjbnnbrb.com (136.30.178.8)  191.303 ms  179.400 ms  179.767 ms
     2  or0.xjbnnbrb.com (136.30.178.1)  179.536 ms  179.534 ms  169.685 ms
     3  192.168.11.101 (192.168.11.101)  189.471 ms  189.556 ms *
     ...
    	      

				12.11.2.6.8 ping

    Broadcast an ICMP ECHO_REQUEST packet to another machine, either on a local or remote network. This is a diagnostic tool for testing network connections, and it should be used with caution.

    bash$ ping localhost
    PING localhost.localdomain (127.0.0.1) from 127.0.0.1 : 56(84) bytes of data.
     64 bytes from localhost.localdomain (127.0.0.1): icmp_seq=0 ttl=255 time=709 usec
     64 bytes from localhost.localdomain (127.0.0.1): icmp_seq=1 ttl=255 time=286 usec

     --- localhost.localdomain ping statistics ---
     2 packets transmitted, 2 packets received, 0% packet loss
     round-trip min/avg/max/mdev = 0.286/0.497/0.709/0.212 ms
    	      

    A successful ping returns an exit status of 0. This can be tested for in a script.

      HNAME=nastyspammer.com
    # HNAME=$HOST     # Debug: test for localhost.
      count=2  # Send only two pings.

    if [[ `ping -c $count "$HNAME"` ]]
    then
      echo ""$HNAME" still up and broadcasting spam your way."
    else
      echo ""$HNAME" seems to be down. Pity."
    fi

				12.11.2.6.9 whois

    Perform a DNS (Domain Name System) lookup. The -h option permits specifying which particular whois server to query. 
				12.11.2.6.10 finger

    Retrieve information about users on a network. Optionally, this command can display a user's ~/.plan, ~/.project, and ~/.forward files, if present.

    bash$ finger
    Login  Name           Tty      Idle  Login Time   Office     Office Phone
     bozo   Bozo Bozeman   tty1        8  Jun 25 16:59                (:0)
     bozo   Bozo Bozeman   ttyp0          Jun 25 16:59                (:0.0)
     bozo   Bozo Bozeman   ttyp1          Jun 25 17:07                (:0.0)



    bash$ finger bozo
    Login: bozo                             Name: Bozo Bozeman
     Directory: /home/bozo                   Shell: /bin/bash
     Office: 2355 Clown St., 543-1234
     On since Fri Aug 31 20:13 (MST) on tty1    1 hour 38 minutes idle
     On since Fri Aug 31 20:13 (MST) on pts/0   12 seconds idle
     On since Fri Aug 31 20:13 (MST) on pts/1
     On since Fri Aug 31 20:31 (MST) on pts/2   1 hour 16 minutes idle
     Mail last read Tue Jul  3 10:08 2007 (MST) 
     No Plan.
    	      

    Out of security considerations, many networks disable finger and its associated daemon. [1] 
				12.11.2.6.11 chfn

    Change information disclosed by the finger command.
				12.11.2.6.12 vrfy

    Verify an Internet e-mail address.

    This command seems to be missing from newer Linux distros.

Remote Host Access

				12.11.2.6.13 sx, rx

    The sx and rx command set serves to transfer files to and from a remote host using the xmodem protocol. These are generally part of a communications package, such as minicom.
				12.11.2.6.14 sz, rz

    The sz and rz command set serves to transfer files to and from a remote host using the zmodem protocol. Zmodem has certain advantages over xmodem, such as faster transmission rate and resumption of interrupted file transfers. Like sx and rx, these are generally part of a communications package.
ftp

    Utility and protocol for uploading / downloading files to or from a remote host. An ftp session can be automated in a script (see Example 18-6, Example A-4, and Example A-13).
				12.11.2.6.15 uucp, uux, cu

    uucp: UNIX to UNIX copy. This is a communications package for transferring files between UNIX servers. A shell script is an effective way to handle a uucp command sequence.

    Since the advent of the Internet and e-mail, uucp seems to have faded into obscurity, but it still exists and remains perfectly workable in situations where an Internet connection is not available or appropriate. The advantage of uucp is that it is fault-tolerant, so even if there is a service interruption the copy operation will resume where it left off when the connection is restored.

    ---

    uux: UNIX to UNIX execute. Execute a command on a remote system. This command is part of the uucp package.

    ---

    cu: Call Up a remote system and connect as a simple terminal. It is a sort of dumbed-down version of telnet. This command is part of the uucp package.
telnet

    Utility and protocol for connecting to a remote host.

    Caution	The telnet protocol contains security holes and should therefore probably be avoided. Its use within a shell script is not recommended.
				12.11.2.6.16 wget

    The wget utility noninteractively retrieves or downloads files from a Web or ftp site. It works well in a script.

    wget -p http://www.xyz23.com/file01.html
    #  The -p or --page-requisite option causes wget to fetch all files
    #+ required to display the specified page.

    wget -r ftp://ftp.xyz24.net/~bozo/project_files/ -O $SAVEFILE
    #  The -r option recursively follows and retrieves all links
    #+ on the specified site.

    wget -c ftp://ftp.xyz25.net/bozofiles/filename.tar.bz2
    #  The -c option lets wget resume an interrupted download.
    #  This works with ftp servers and many HTTP sites.

				12.11.2.6.17 Example 15-42. Getting a stock quote

    #!/bin/bash
    # quote-fetch.sh: Download a stock quote.


    E_NOPARAMS=66

    if [ -z "$1" ]  # Must specify a stock (symbol) to fetch.
      then echo "Usage: `basename $0` stock-symbol"
      exit $E_NOPARAMS
    fi

    stock_symbol=$1

    file_suffix=.html
    # Fetches an HTML file, so name it appropriately.
    URL='http://finance.yahoo.com/q?s='
    # Yahoo finance board, with stock query suffix.

    # -----------------------------------------------------------
    wget -O ${stock_symbol}${file_suffix} "${URL}${stock_symbol}"
    # -----------------------------------------------------------


    # To look up stuff on http://search.yahoo.com:
    # -----------------------------------------------------------
    # URL="http://search.yahoo.com/search?fr=ush-news&p=${query}"
    # wget -O "$savefilename" "${URL}"
    # -----------------------------------------------------------
    # Saves a list of relevant URLs.

    exit $?

    # Exercises:
    # ---------
    #
    # 1) Add a test to ensure the user running the script is on-line.
    #    (Hint: parse the output of 'ps -ax' for "ppp" or "connect."
    #
    # 2) Modify this script to fetch the local weather report,
    #+   taking the user's zip code as an argument.

    See also Example A-32 and Example A-33.
				12.11.2.6.18 lynx

    The lynx Web and file browser can be used inside a script (with the -dump option) to retrieve a file from a Web or ftp site noninteractively.

    lynx -dump http://www.xyz23.com/file01.html >$SAVEFILE

    With the -traversal option, lynx starts at the HTTP URL specified as an argument, then "crawls" through all links located on that particular server. Used together with the -crawl option, outputs page text to a log file.
				12.11.2.6.19 rlogin

    Remote login, initates a session on a remote host. This command has security issues, so use ssh instead.
				12.11.2.6.20 rsh

    Remote shell, executes command(s) on a remote host. This has security issues, so use ssh instead.
				12.11.2.6.21 rcp

    Remote copy, copies files between two different networked machines.
				12.11.2.6.22 rsync

    Remote synchronize, updates (synchronizes) files between two different networked machines.

    bash$ rsync -a ~/sourcedir/*txt /node1/subdirectory/
    	      

				12.11.2.6.23 Example 15-43. Updating FC4

    #!/bin/bash
    # fc4upd.sh

    # Script author: Frank Wang.
    # Slight stylistic modifications by ABS Guide author.
    # Used in ABS Guide with permission.


    #  Download Fedora Core 4 update from mirror site using rsync. 
    #  Should also work for newer Fedora Cores -- 5, 6, . . .
    #  Only download latest package if multiple versions exist,
    #+ to save space.

    URL=rsync://distro.ibiblio.org/fedora-linux-core/updates/
    # URL=rsync://ftp.kddilabs.jp/fedora/core/updates/
    # URL=rsync://rsync.planetmirror.com/fedora-linux-core/updates/

    DEST=${1:-/var/www/html/fedora/updates/}
    LOG=/tmp/repo-update-$(/bin/date +%Y-%m-%d).txt
    PID_FILE=/var/run/${0##*/}.pid

    E_RETURN=65        # Something unexpected happened.


    # General rsync options
    # -r: recursive download
    # -t: reserve time
    # -v: verbose

    OPTS="-rtv --delete-excluded --delete-after --partial"

    # rsync include pattern
    # Leading slash causes absolute path name match.
    INCLUDE=(
        "/4/i386/kde-i18n-Chinese*" 
    #   ^                         ^
    # Quoting is necessary to prevent globbing.
    ) 


    # rsync exclude pattern
    # Temporarily comment out unwanted pkgs using "#" . . .
    EXCLUDE=(
        /1
        /2
        /3
        /testing
        /4/SRPMS
        /4/ppc
        /4/x86_64
        /4/i386/debug
       "/4/i386/kde-i18n-*"
       "/4/i386/openoffice.org-langpack-*"
       "/4/i386/*i586.rpm"
       "/4/i386/GFS-*"
       "/4/i386/cman-*"
       "/4/i386/dlm-*"
       "/4/i386/gnbd-*"
       "/4/i386/kernel-smp*"
    #  "/4/i386/kernel-xen*" 
    #  "/4/i386/xen-*" 
    )


    init () {
        # Let pipe command return possible rsync error, e.g., stalled network.
        set -o pipefail                  # Newly introduced in Bash, version 3.

        TMP=${TMPDIR:-/tmp}/${0##*/}.$$  # Store refined download list.
        trap "{
            rm -f $TMP 2>/dev/null
        }" EXIT                          # Clear temporary file on exit.
    }


    check_pid () {
    # Check if process exists.
        if [ -s "$PID_FILE" ]; then
            echo "PID file exists. Checking ..."
            PID=$(/bin/egrep -o "^[[:digit:]]+" $PID_FILE)
            if /bin/ps --pid $PID &>/dev/null; then
                echo "Process $PID found. ${0##*/} seems to be running!"
               /usr/bin/logger -t ${0##*/} \
                     "Process $PID found. ${0##*/} seems to be running!"
                exit $E_RETURN
            fi
            echo "Process $PID not found. Start new process . . ."
        fi
    }


    #  Set overall file update range starting from root or $URL,
    #+ according to above patterns.
    set_range () {
        include=
        exclude=
        for p in "${INCLUDE[@]}"; do
            include="$include --include \"$p\""
        done

        for p in "${EXCLUDE[@]}"; do
            exclude="$exclude --exclude \"$p\""
        done
    }


    # Retrieve and refine rsync update list.
    get_list () {
        echo $$ > $PID_FILE || {
            echo "Can't write to pid file $PID_FILE"
            exit $E_RETURN
        }

        echo -n "Retrieving and refining update list . . ."

        # Retrieve list -- 'eval' is needed to run rsync as a single command.
        # $3 and $4 is the date and time of file creation.
        # $5 is the full package name.
        previous=
        pre_file=
        pre_date=0
        eval /bin/nice /usr/bin/rsync \
            -r $include $exclude $URL | \
            egrep '^dr.x|^-r' | \
            awk '{print $3, $4, $5}' | \
            sort -k3 | \
            { while read line; do
                # Get seconds since epoch, to filter out obsolete pkgs.
                cur_date=$(date -d "$(echo $line | awk '{print $1, $2}')" +%s)
                #  echo $cur_date

                # Get file name.
                cur_file=$(echo $line | awk '{print $3}')
                #  echo $cur_file

                # Get rpm pkg name from file name, if possible.
                if [[ $cur_file == *rpm ]]; then
                    pkg_name=$(echo $cur_file | sed -r -e \
                        's/(^([^_-]+[_-])+)[[:digit:]]+\..*[_-].*$/\1/')
                else
                    pkg_name=
                fi
                # echo $pkg_name

                if [ -z "$pkg_name" ]; then   #  If not a rpm file,
                    echo $cur_file >> $TMP    #+ then append to download list.
                elif [ "$pkg_name" != "$previous" ]; then   # A new pkg found.
                    echo $pre_file >> $TMP                  # Output latest file.
                    previous=$pkg_name                      # Save current.
                    pre_date=$cur_date
                    pre_file=$cur_file
                elif [ "$cur_date" -gt "$pre_date" ]; then
                                                    #  If same pkg, but newer,
                    pre_date=$cur_date              #+ then update latest pointer.
                    pre_file=$cur_file
                fi
                done
                echo $pre_file >> $TMP              #  TMP contains ALL
                                                    #+ of refined list now.
                # echo "subshell=$BASH_SUBSHELL"

        }       # Bracket required here to let final "echo $pre_file >> $TMP" 
                # Remained in the same subshell ( 1 ) with the entire loop.

        RET=$?  # Get return code of the pipe command.

        [ "$RET" -ne 0 ] && {
            echo "List retrieving failed with code $RET"
            exit $E_RETURN
        }

        echo "done"; echo
    }

    # Real rsync download part.
    get_file () {

        echo "Downloading..."
        /bin/nice /usr/bin/rsync \
            $OPTS \
            --filter "merge,+/ $TMP" \
            --exclude '*'  \
            $URL $DEST     \
            | /usr/bin/tee $LOG

        RET=$?

       #  --filter merge,+/ is crucial for the intention. 
       #  + modifier means include and / means absolute path.
       #  Then sorted list in $TMP will contain ascending dir name and 
       #+ prevent the following --exclude '*' from "shortcutting the circuit." 

        echo "Done"

        rm -f $PID_FILE 2>/dev/null

        return $RET
    }

    # -------
    # Main
    init
    check_pid
    set_range
    get_list
    get_file
    RET=$?
    # -------

    if [ "$RET" -eq 0 ]; then
        /usr/bin/logger -t ${0##*/} "Fedora update mirrored successfully."
    else
        /usr/bin/logger -t ${0##*/} \
        "Fedora update mirrored with failure code: $RET"
    fi

    exit $RET


    Note	Using rcp, rsync, and similar utilities with security implications in a shell script may not be advisable. Consider, instead, using ssh, scp, or an expect script.
				12.11.2.6.24 ssh

    Secure shell, logs onto a remote host and executes commands there. This secure replacement for telnet, rlogin, rcp, and rsh uses identity authentication and encryption. See its manpage for details.

    Example 15-44. Using ssh

    #!/bin/bash
    # remote.bash: Using ssh.

    # This example by Michael Zick.
    # Used with permission.


    #   Presumptions:
    #   ------------
    #   fd-2 isn't being captured ( '2>/dev/null' ).
    #   ssh/sshd presumes stderr ('2') will display to user.
    #
    #   sshd is running on your machine.
    #   For any 'standard' distribution, it probably is,
    #+  and without any funky ssh-keygen having been done.

    # Try ssh to your machine from the command line:
    #
    # $ ssh $HOSTNAME
    # Without extra set-up you'll be asked for your password.
    #   enter password
    #   when done,  $ exit
    #
    # Did that work? If so, you're ready for more fun.

    # Try ssh to your machine as 'root':
    #
    #   $  ssh -l root $HOSTNAME
    #   When asked for password, enter root's, not yours.
    #          Last login: Tue Aug 10 20:25:49 2004 from localhost.localdomain
    #   Enter 'exit' when done.

    #  The above gives you an interactive shell.
    #  It is possible for sshd to be set up in a 'single command' mode,
    #+ but that is beyond the scope of this example.
    #  The only thing to note is that the following will work in
    #+ 'single command' mode.


    # A basic, write stdout (local) command.

    ls -l

    # Now the same basic command on a remote machine.
    # Pass a different 'USERNAME' 'HOSTNAME' if desired:
    USER=${USERNAME:-$(whoami)}
    HOST=${HOSTNAME:-$(hostname)}

    #  Now excute the above command line on the remote host,
    #+ with all transmissions encrypted.

    ssh -l ${USER} ${HOST} " ls -l "

    #  The expected result is a listing of your username's home
    #+ directory on the remote machine.
    #  To see any difference, run this script from somewhere
    #+ other than your home directory.

    #  In other words, the Bash command is passed as a quoted line
    #+ to the remote shell, which executes it on the remote machine.
    #  In this case, sshd does  ' bash -c "ls -l" '   on your behalf.

    #  For information on topics such as not having to enter a
    #+ password/passphrase for every command line, see
    #+    man ssh
    #+    man ssh-keygen
    #+    man sshd_config.

    exit 0

    Caution	

    Within a loop, ssh may cause unexpected behavior. According to a Usenet post in the comp.unix shell archives, ssh inherits the loop's stdin. To remedy this, pass ssh either the -n or -f option.

    Thanks, Jason Bechtel, for pointing this out.
				12.11.2.6.25 scp

    Secure copy, similar in function to rcp, copies files between two different networked machines, but does so using authentication, and with a security level similar to ssh.

Local Network

				12.11.2.6.26 write

    This is a utility for terminal-to-terminal communication. It allows sending lines from your terminal (console or xterm) to that of another user. The mesg command may, of course, be used to disable write access to a terminal

    Since write is interactive, it would not normally find use in a script.
				12.11.2.6.27 netconfig

    A command-line utility for configuring a network adapter (using DHCP). This command is native to Red Hat centric Linux distros.

Mail

				12.11.2.6.28 mail

    Send or read e-mail messages.

    This stripped-down command-line mail client works fine as a command embedded in a script.

				12.11.2.6.29 Example 15-45. A script that mails itself

    #!/bin/sh
    # self-mailer.sh: Self-mailing script

    adr=${1:-`whoami`}     # Default to current user, if not specified.
    #  Typing 'self-mailer.sh wiseguy@superdupergenius.com'
    #+ sends this script to that addressee.
    #  Just 'self-mailer.sh' (no argument) sends the script
    #+ to the person invoking it, for example, bozo@localhost.localdomain.
    #
    #  For more on the ${parameter:-default} construct,
    #+ see the "Parameter Substitution" section
    #+ of the "Variables Revisited" chapter.

    # ============================================================================
      cat $0 | mail -s "Script \"`basename $0`\" has mailed itself to you." "$adr"
    # ============================================================================

    # --------------------------------------------
    #  Greetings from the self-mailing script.
    #  A mischievous person has run this script,
    #+ which has caused it to mail itself to you.
    #  Apparently, some people have nothing better
    #+ to do with their time.
    # --------------------------------------------

    echo "At `date`, script \"`basename $0`\" mailed to "$adr"."

    exit 0

    #  Note that the "mailx" command (in "send" mode) may be substituted
    #+ for "mail" ... but with somewhat different options.

				12.11.2.6.30 mailto

    Similar to the mail command, mailto sends e-mail messages from the command line or in a script. However, mailto also permits sending MIME (multimedia) messages.
				12.11.2.6.31 mailstats

    Show mail statistics. This command may be invoked only by root.

    root# mailstats
    Statistics from Tue Jan  1 20:32:08 2008
      M   msgsfr  bytes_from   msgsto    bytes_to  msgsrej msgsdis msgsqur  Mailer
      |4     1682      24118K        0          0K        0       0       0  esmtp
      |9      212        640K     1894      25131K        0       0       0  local
     =====================================================================
      T     1894      24758K     1894      25131K        0       0       0
      C      414                    0
    	      

				12.11.2.6.32 vacation

    This utility automatically replies to e-mails that the intended recipient is on vacation and temporarily unavailable. It runs on a network, in conjunction with sendmail, and is not applicable to a dial-up POPmail account.


			12.11.2.7 Terminal Control Commands
Command affecting the console or terminal

				12.11.2.7.1 tput

    Initialize terminal and/or fetch information about it from terminfo data. Various options permit certain terminal operations: tput clear is the equivalent of clear; tput reset is the equivalent of reset.

    bash$ tput longname
    xterm terminal emulator (X Window System)
    	      

    Issuing a tput cup X Y moves the cursor to the (X,Y) coordinates in the current terminal. A clear to erase the terminal screen would normally precede this.

    Some interesting options to tput are:

        * bold, for high-intensity text
        * smul, to underline text in the terminal
        * smso, to render text in reverse
        * sgr0, to reset the terminal parameters (to normal), without clearing the screen

    Note that stty offers a more powerful command set for controlling a terminal.
				12.11.2.7.2 infocmp

    This command prints out extensive information about the current terminal. It references the terminfo database.

    bash$ infocmp
    #       Reconstructed via infocmp from file:
     /usr/share/terminfo/r/rxvt
     rxvt|rxvt terminal emulator (X Window System), 
             am, bce, eo, km, mir, msgr, xenl, xon, 
             colors#8, cols#80, it#8, lines#24, pairs#64, 
             acsc=``aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~, 
             bel=^G, blink=\E[5m, bold=\E[1m,
             civis=\E[?25l, 
             clear=\E[H\E[2J, cnorm=\E[?25h, cr=^M, 
             ...
    	      

				12.11.2.7.3 reset

    Reset terminal parameters and clear text screen. As with clear, the cursor and prompt reappear in the upper lefthand corner of the terminal.
				12.11.2.7.4 clear

    The clear command simply clears the text screen at the console or in an xterm. The prompt and cursor reappear at the upper lefthand corner of the screen or xterm window. This command may be used either at the command line or in a script. See Example 10-25.
				12.11.2.7.5 resize

    Echoes commands necessary to set $TERM and $TERMCAP to duplicate the size (dimensions) of the current terminal.

    bash$ resize
    set noglob;
     setenv COLUMNS '80';
     setenv LINES '24';
     unset noglob;
    	        

				12.11.2.7.6 script

    This utility records (saves to a file) all the user keystrokes at the command line in a console or an xterm window. This, in effect, creates a record of a session.

			12.11.2.8 Math Commands
"Doing the numbers"

				12.11.2.8.1 factor

    Decompose an integer into prime factors.

    bash$ factor 27417
    27417: 3 13 19 37
    	      

				12.11.2.8.2 Example 15-46. Generating prime numbers

    #!/bin/bash
    # primes2.sh

    #  Generating prime numbers the quick-and-easy way,
    #+ without resorting to fancy algorithms.

    CEILING=10000   # 1 to 10000
    PRIME=0
    E_NOTPRIME=

    is_prime ()
    {
      local factors
      factors=( $(factor $1) )  # Load output of `factor` into array.

    if [ -z "${factors[2]}" ]
    #  Third element of "factors" array:
    #+ ${factors[2]} is 2nd factor of argument.
    #  If it is blank, then there is no 2nd factor,
    #+ and the argument is therefore prime.
    then
      return $PRIME             # 0
    else
      return $E_NOTPRIME        # null
    fi
    }

    echo
    for n in $(seq $CEILING)
    do
      if is_prime $n
      then
        printf %5d $n
      fi   #    ^  Five positions per number suffices.
    done   #       For a higher $CEILING, adjust upward, as necessary.

    echo

    exit

				12.11.2.8.3 bc

    Bash can't handle floating point calculations, and it lacks operators for certain important mathematical functions. Fortunately, bc comes to the rescue.

    Not just a versatile, arbitrary precision calculation utility, bc offers many of the facilities of a programming language.

    bc has a syntax vaguely resembling C.

    Since it is a fairly well-behaved UNIX utility, and may therefore be used in a pipe, bc comes in handy in scripts.

    Here is a simple template for using bc to calculate a script variable. This uses command substitution.

    	      variable=$(echo "OPTIONS; OPERATIONS" | bc)
    	      

				12.11.2.8.4 Example 15-47. Monthly Payment on a Mortgage

    #!/bin/bash
    # monthlypmt.sh: Calculates monthly payment on a mortgage.


    #  This is a modification of code in the
    #+ "mcalc" (mortgage calculator) package,
    #+ by Jeff Schmidt
    #+ and
    #+ Mendel Cooper (yours truly, the author of the ABS Guide).
    #   http://www.ibiblio.org/pub/Linux/apps/financial/mcalc-1.6.tar.gz  [15k]

    echo
    echo "Given the principal, interest rate, and term of a mortgage,"
    echo "calculate the monthly payment."

    bottom=1.0

    echo
    echo -n "Enter principal (no commas) "
    read principal
    echo -n "Enter interest rate (percent) "  # If 12%, enter "12", not ".12".
    read interest_r
    echo -n "Enter term (months) "
    read term


     interest_r=$(echo "scale=9; $interest_r/100.0" | bc) # Convert to decimal.
                     #           ^^^^^^^^^^^^^^^^^  Divide by 100. 
                     # "scale" determines how many decimal places.

     interest_rate=$(echo "scale=9; $interest_r/12 + 1.0" | bc)
     

     top=$(echo "scale=9; $principal*$interest_rate^$term" | bc)
              #           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
              #           Standard formula for figuring interest.

     echo; echo "Please be patient. This may take a while."

     let "months = $term - 1"
    # ==================================================================== 
     for ((x=$months; x > 0; x--))
     do
       bot=$(echo "scale=9; $interest_rate^$x" | bc)
       bottom=$(echo "scale=9; $bottom+$bot" | bc)
    #  bottom = $(($bottom + $bot"))
     done
    # ==================================================================== 

    # -------------------------------------------------------------------- 
    #  Rick Boivie pointed out a more efficient implementation
    #+ of the above loop, which decreases computation time by 2/3.

    # for ((x=1; x <= $months; x++))
    # do
    #   bottom=$(echo "scale=9; $bottom * $interest_rate + 1" | bc)
    # done


    #  And then he came up with an even more efficient alternative,
    #+ one that cuts down the run time by about 95%!

    # bottom=`{
    #     echo "scale=9; bottom=$bottom; interest_rate=$interest_rate"
    #     for ((x=1; x <= $months; x++))
    #     do
    #          echo 'bottom = bottom * interest_rate + 1'
    #     done
    #     echo 'bottom'
    #     } | bc`       # Embeds a 'for loop' within command substitution.
    # --------------------------------------------------------------------------
    #  On the other hand, Frank Wang suggests:
    #  bottom=$(echo "scale=9; ($interest_rate^$term-1)/($interest_rate-1)" | bc)

    #  Because . . .
    #  The algorithm behind the loop
    #+ is actually a sum of geometric proportion series.
    #  The sum formula is e0(1-q^n)/(1-q),
    #+ where e0 is the first element and q=e(n+1)/e(n)
    #+ and n is the number of elements.
    # --------------------------------------------------------------------------


     # let "payment = $top/$bottom"
     payment=$(echo "scale=2; $top/$bottom" | bc)
     # Use two decimal places for dollars and cents.
     
     echo
     echo "monthly payment = \$$payment"  # Echo a dollar sign in front of amount.
     echo


     exit 0


     # Exercises:
     #   1) Filter input to permit commas in principal amount.
     #   2) Filter input to permit interest to be entered as percent or decimal.
     #   3) If you are really ambitious,
     #+     expand this script to print complete amortization tables.

				12.11.2.8.5 Example 15-48. Base Conversion

    #!/bin/bash
    ###########################################################################
    # Shellscript:	base.sh - print number to different bases (Bourne Shell)
    # Author     :	Heiner Steven (heiner.steven@odn.de)
    # Date       :	07-03-95
    # Category   :	Desktop
    # $Id: base.sh,v 1.2 2000/02/06 19:55:35 heiner Exp $
    # ==> Above line is RCS ID info.
    ###########################################################################
    # Description
    #
    # Changes
    # 21-03-95 stv	fixed error occuring with 0xb as input (0.2)
    ###########################################################################

    # ==> Used in ABS Guide with the script author's permission.
    # ==> Comments added by ABS Guide author.

    NOARGS=65
    PN=`basename "$0"`			       # Program name
    VER=`echo '$Revision: 1.2 $' | cut -d' ' -f2`  # ==> VER=1.2

    Usage () {
        echo "$PN - print number to different bases, $VER (stv '95)
    usage: $PN [number ...]

    If no number is given, the numbers are read from standard input.
    A number may be
        binary (base 2)		starting with 0b (i.e. 0b1100)
        octal (base 8)		starting with 0  (i.e. 014)
        hexadecimal (base 16)	starting with 0x (i.e. 0xc)
        decimal			otherwise (i.e. 12)" >&2
        exit $NOARGS 
    }   # ==> Function to print usage message.

    Msg () {
        for i   # ==> in [list] missing.
        do echo "$PN: $i" >&2
        done
    }

    Fatal () { Msg "$@"; exit 66; }

    PrintBases () {
        # Determine base of the number
        for i      # ==> in [list] missing...
        do         # ==> so operates on command line arg(s).
    	case "$i" in
    	    0b*)		ibase=2;;	# binary
    	    0x*|[a-f]*|[A-F]*)	ibase=16;;	# hexadecimal
    	    0*)			ibase=8;;	# octal
    	    [1-9]*)		ibase=10;;	# decimal
    	    *)
    		Msg "illegal number $i - ignored"
    		continue;;
    	esac

    	# Remove prefix, convert hex digits to uppercase (bc needs this)
    	number=`echo "$i" | sed -e 's:^0[bBxX]::' | tr '[a-f]' '[A-F]'`
    	# ==> Uses ":" as sed separator, rather than "/".

    	# Convert number to decimal
    	dec=`echo "ibase=$ibase; $number" | bc`  # ==> 'bc' is calculator utility.
    	case "$dec" in
    	    [0-9]*)	;;			 # number ok
    	    *)		continue;;		 # error: ignore
    	esac

    	# Print all conversions in one line.
    	# ==> 'here document' feeds command list to 'bc'.
    	echo `bc <<!
    	    obase=16; "hex="; $dec
    	    obase=10; "dec="; $dec
    	    obase=8;  "oct="; $dec
    	    obase=2;  "bin="; $dec
    !
        ` | sed -e 's: :	:g'

        done
    }

    while [ $# -gt 0 ]
    # ==>  Is a "while loop" really necessary here,
    # ==>+ since all the cases either break out of the loop
    # ==>+ or terminate the script.
    # ==> (Above comment by Paulo Marcel Coelho Aragao.)
    do
        case "$1" in
    	--)     shift; break;;
    	-h)     Usage;;                 # ==> Help message.
    	-*)     Usage;;
             *)     break;;                 # first number
        esac   # ==> More error checking for illegal input might be useful.
        shift
    done

    if [ $# -gt 0 ]
    then
        PrintBases "$@"
    else					# read from stdin
        while read line
        do
    	PrintBases $line
        done
    fi


    exit 0

    An alternate method of invoking bc involves using a here document embedded within a command substitution block. This is especially appropriate when a script needs to pass a list of options and commands to bc.

    variable=`bc << LIMIT_STRING
    options
    statements
    operations
    LIMIT_STRING
    `

    ...or...


    variable=$(bc << LIMIT_STRING
    options
    statements
    operations
    LIMIT_STRING
    )

				12.11.2.8.6 Example 15-49. Invoking bc using a here document

    #!/bin/bash
    # Invoking 'bc' using command substitution
    # in combination with a 'here document'.


    var1=`bc << EOF
    |18.33 * 19.78
    EOF
    `
    echo $var1       # 362.56


    #  $( ... ) notation also works.
    v1=23.53
    v2=17.881
    v3=83.501
    v4=171.63

    var2=$(bc << EOF
    scale = 4
    a = ( $v1 + $v2 )
    b = ( $v3 * $v4 )
    a * b + 15.35
    EOF
    )
    echo $var2       # 593487.8452


    var3=$(bc -l << EOF
    scale = 9
    s ( 1.7 )
    EOF
    )
    # Returns the sine of 1.7 radians.
    # The "-l" option calls the 'bc' math library.
    echo $var3       # .991664810


    # Now, try it in a function...
    hypotenuse ()    # Calculate hypotenuse of a right triangle.
    {                # c = sqrt( a^2 + b^2 )
    hyp=$(bc -l << EOF
    scale = 9
    sqrt ( $1 * $1 + $2 * $2 )
    EOF
    )
    # Can't directly return floating point values from a Bash function.
    # But, can echo-and-capture:
    echo "$hyp"
    }

    hyp=$(hypotenuse 3.68 7.31)
    echo "hypotenuse = $hyp"    # 8.184039344


    exit 0

				12.11.2.8.7 Example 15-50. Calculating PI

    #!/bin/bash
    # cannon.sh: Approximating PI by firing cannonballs.

    # This is a very simple instance of a "Monte Carlo" simulation:
    #+ a mathematical model of a real-life event,
    #+ using pseudorandom numbers to emulate random chance.

    #  Consider a perfectly square plot of land, 10000 units on a side.
    #  This land has a perfectly circular lake in its center,
    #+ with a diameter of 10000 units.
    #  The plot is actually mostly water, except for land in the four corners.
    #  (Think of it as a square with an inscribed circle.)
    #
    #  We will fire iron cannonballs from an old-style cannon
    #+ at the square.
    #  All the shots impact somewhere on the square,
    #+ either in the lake or on the dry corners.
    #  Since the lake takes up most of the area,
    #+ most of the shots will SPLASH! into the water.
    #  Just a few shots will THUD! into solid ground
    #+ in the four corners of the square.
    #
    #  If we take enough random, unaimed shots at the square,
    #+ Then the ratio of SPLASHES to total shots will approximate
    #+ the value of PI/4.
    #
    #  The reason for this is that the cannon is actually shooting
    #+ only at the upper right-hand quadrant of the square,
    #+ i.e., Quadrant I of the Cartesian coordinate plane.
    #  (The previous explanation was a simplification.)
    #
    #  Theoretically, the more shots taken, the better the fit.
    #  However, a shell script, as opposed to a compiled language
    #+ with floating-point math built in, requires a few compromises.
    #  This tends to lower the accuracy of the simulation.


    DIMENSION=10000  # Length of each side of the plot.
                     # Also sets ceiling for random integers generated.

    MAXSHOTS=1000    # Fire this many shots.
                     # 10000 or more would be better, but would take too long.
    PMULTIPLIER=4.0  # Scaling factor to approximate PI.

    M_PI=3.141592654 # Actual value of PI, for comparison purposes.

    get_random ()
    {
    SEED=$(head -n 1 /dev/urandom | od -N 1 | awk '{ print $2 }')
    RANDOM=$SEED                                  #  From "seeding-random.sh"
                                                  #+ example script.
    let "rnum = $RANDOM % $DIMENSION"             #  Range less than 10000.
    echo $rnum
    }

    distance=        # Declare global variable.
    hypotenuse ()    # Calculate hypotenuse of a right triangle.
    {                # From "alt-bc.sh" example.
    distance=$(bc -l << EOF
    scale = 0
    sqrt ( $1 * $1 + $2 * $2 )
    EOF
    )
    #  Setting "scale" to zero rounds down result to integer value,
    #+ a necessary compromise in this script.
    #  This diminshes the accuracy of the simulation.
    }


    # main() {

    # Initialize variables.
    shots=0
    splashes=0
    thuds=0
    Pi=0
    error=0

    while [ "$shots" -lt  "$MAXSHOTS" ]           # Main loop.
    do

      xCoord=$(get_random)                        # Get random X and Y coords.
      yCoord=$(get_random)
      hypotenuse $xCoord $yCoord                  #  Hypotenuse of right-triangle =
                                                  #+ distance.
      ((shots++))

      printf "#%4d   " $shots
      printf "Xc = %4d  " $xCoord
      printf "Yc = %4d  " $yCoord
      printf "Distance = %5d  " $distance         #  Distance from 
                                                  #+ center of lake --
                                                  #  the "origin" --
                                                  #+ coordinate (0,0).

      if [ "$distance" -le "$DIMENSION" ]
      then
        echo -n "SPLASH!  "
        ((splashes++))
      else
        echo -n "THUD!    "
        ((thuds++))
      fi

      Pi=$(echo "scale=9; $PMULTIPLIER*$splashes/$shots" | bc)
      # Multiply ratio by 4.0.
      echo -n "PI ~ $Pi"
      echo

    done

    echo
    echo "After $shots shots, PI looks like approximately $Pi"
    # Tends to run a bit high . . . 
    # Probably due to round-off error and imperfect randomness of $RANDOM.
    error=$(echo "scale=9; $Pi - $M_PI" | bc)
    echo "Deviation from mathematical value of PI =      $error"
    echo

    # }

    exit 0

    #  One might well wonder whether a shell script is appropriate for
    #+ an application as complex and computation-intensive as a simulation.
    #
    #  There are at least two justifications.
    #  1) As a proof of concept: to show it can be done.
    #  2) To prototype and test the algorithms before rewriting
    #+    it in a compiled high-level language.

				12.11.2.8.8 dc

    The dc (desk calculator) utility is stack-oriented and uses RPN ("Reverse Polish Notation"). Like bc, it has much of the power of a programming language.

    Most persons avoid dc, since it requires non-intuitive input. Yet, it has its uses.

				12.11.2.8.9 Example 15-51. Converting a decimal number to hexadecimal

    #!/bin/bash
    # hexconvert.sh: Convert a decimal number to hexadecimal.

    E_NOARGS=85 # Command-line arg missing.
    BASE=16     # Hexadecimal.

    if [ -z "$1" ]
    then        # Need a command line argument.
      echo "Usage: $0 number"
      exit $E_NOARGS
    fi          # Exercise: add argument validity checking.


    hexcvt ()
    {
    if [ -z "$1" ]
    then
      echo 0
      return    # "Return" 0 if no arg passed to function.
    fi

    echo ""$1" "$BASE" o p" | dc
    #                  o    sets radix (numerical base) of output.
    #                    p  prints the top of stack.
    # For other options: 'man dc' ...
    return
    }

    hexcvt "$1"

    exit

    Studying the info page for dc is a painful path to understanding its intricacies. There seems to be a small, select group of dc wizards who delight in showing off their mastery of this powerful, but arcane utility.

    bash$ echo "16i[q]sa[ln0=aln100%Pln100/snlbx]sbA0D68736142snlbxq" | dc"
    Bash
    	      

				12.11.2.8.10 Example 15-52. Factoring

    #!/bin/bash
    # factr.sh: Factor a number

    MIN=2       # Will not work for number smaller than this.
    E_NOARGS=65
    E_TOOSMALL=66

    if [ -z $1 ]
    then
      echo "Usage: $0 number"
      exit $E_NOARGS
    fi

    if [ "$1" -lt "$MIN" ]
    then
      echo "Number to factor must be $MIN or greater."
      exit $E_TOOSMALL
    fi  

    # Exercise: Add type checking (to reject non-integer arg).

    echo "Factors of $1:"
    # -------------------------------------------------------------------------------
    echo "$1[p]s2[lip/dli%0=1dvsr]s12sid2%0=13sidvsr[dli%0=1lrli2+dsi!>.]ds.xd1<2"|dc
    # -------------------------------------------------------------------------------
    # Above line of code written by Michel Charpentier <charpov@cs.unh.edu>.
    # Used in ABS Guide with permission (thanks!).

     exit 0

				12.11.2.8.11 awk

    Yet another way of doing floating point math in a script is using awk's built-in math functions in a shell wrapper.

				12.11.2.8.12 Example 15-53. Calculating the hypotenuse of a triangle

    #!/bin/bash
    # hypotenuse.sh: Returns the "hypotenuse" of a right triangle.
    #                (square root of sum of squares of the "legs")

    ARGS=2                # Script needs sides of triangle passed.
    E_BADARGS=65          # Wrong number of arguments.

    if [ $# -ne "$ARGS" ] # Test number of arguments to script.
    then
      echo "Usage: `basename $0` side_1 side_2"
      exit $E_BADARGS
    fi


    AWKSCRIPT=' { printf( "%3.7f\n", sqrt($1*$1 + $2*$2) ) } '
    #             command(s) / parameters passed to awk


    # Now, pipe the parameters to awk.
        echo -n "Hypotenuse of $1 and $2 = "
        echo $1 $2 | awk "$AWKSCRIPT"
    #   ^^^^^^^^^^^^
    # An echo-and-pipe is an easy way of passing shell parameters to awk.

    exit 0

    # Exercise: Rewrite this script using 'bc' rather than awk.
    #           Which method is more intuitive?


			12.11.2.9 Miscellaneous Commands
Command that fit in no special category

				12.11.2.9.1 jot, seq

    These utilities emit a sequence of integers, with a user-selectable increment.

    The default separator character between each integer is a newline, but this can be changed with the -s option.

    bash$ seq 5
    1
     2
     3
     4
     5



    bash$ seq -s : 5
    1:2:3:4:5
    	      

    Both jot and seq come in handy in a for loop.

					12.11.2.9.1.1 Generate list with preceding zeros, ex: 001 - 099
seq -f "%03g" 99
					12.11.2.9.1.2 range for loop, like python for i in range
[i500695@C02X632CJGH6:2019-01-08 15:56:26:~/Desktop/work/SAP/CF_LocAL/portal-cf-site-semantic-service:]1149$ for i in $(seq 5); do echo $i; done
1
2
3
4
5

					12.11.2.9.1.3


				12.11.2.9.2 Example 15-54. Using seq to generate loop arguments

    #!/bin/bash
    # Using "seq"

    echo

    for a in `seq 80`  # or   for a in $( seq 80 )
    # Same as   for a in 1 2 3 4 5 ... 80   (saves much typing!).
    # May also use 'jot' (if present on system).
    do
      echo -n "$a "
    done      # 1 2 3 4 5 ... 80
    # Example of using the output of a command to generate 
    # the [list] in a "for" loop.

    echo; echo


    COUNT=80  # Yes, 'seq' also accepts a replaceable parameter.

    for a in `seq $COUNT`  # or   for a in $( seq $COUNT )
    do
      echo -n "$a "
    done      # 1 2 3 4 5 ... 80

    echo; echo

    BEGIN=75
    END=80

    for a in `seq $BEGIN $END`
    #  Giving "seq" two arguments starts the count at the first one,
    #+ and continues until it reaches the second.
    do
      echo -n "$a "
    done      # 75 76 77 78 79 80

    echo; echo

    BEGIN=45
    INTERVAL=5
    END=80

    for a in `seq $BEGIN $INTERVAL $END`
    #  Giving "seq" three arguments starts the count at the first one,
    #+ uses the second for a step interval,
    #+ and continues until it reaches the third.
    do
      echo -n "$a "
    done      # 45 50 55 60 65 70 75 80

    echo; echo

    exit 0

    A simpler example:

    #  Create a set of 10 files,
    #+ named file.1, file.2 . . . file.10.
    COUNT=10
    PREFIX=file

    for filename in `seq $COUNT`
    do
      touch $PREFIX.$filename
      #  Or, can do other operations,
      #+ such as rm, grep, etc.
    done

				12.11.2.9.3 Example 15-55. Letter Count"

    #!/bin/bash
    # letter-count.sh: Counting letter occurrences in a text file.
    # Written by Stefano Palmeri.
    # Used in ABS Guide with permission.
    # Slightly modified by document author.

    MINARGS=2          # Script requires at least two arguments.
    E_BADARGS=65
    FILE=$1

    let LETTERS=$#-1   # How many letters specified (as command-line args).
                       # (Subtract 1 from number of command line args.)


    show_help(){
    	   echo
               echo Usage: `basename $0` file letters  
               echo Note: `basename $0` arguments are case sensitive.
               echo Example: `basename $0` foobar.txt G n U L i N U x.
    	   echo
    }

    # Checks number of arguments.
    if [ $# -lt $MINARGS ]; then
       echo
       echo "Not enough arguments."
       echo
       show_help
       exit $E_BADARGS
    fi  


    # Checks if file exists.
    if [ ! -f $FILE ]; then
        echo "File \"$FILE\" does not exist."
        exit $E_BADARGS
    fi



    # Counts letter occurrences .
    for n in `seq $LETTERS`; do
          shift
          if [[ `echo -n "$1" | wc -c` -eq 1 ]]; then             #  Checks arg.
                 echo "$1" -\> `cat $FILE | tr -cd  "$1" | wc -c` #  Counting.
          else
                 echo "$1 is not a  single char."
          fi  
    done

    exit $?

    #  This script has exactly the same functionality as letter-count2.sh,
    #+ but executes faster.
    #  Why?

    Note	Somewhat more capable than seq, jot is a classic UNIX utility that is not normally included in a standard Linux distro. However, the source rpm is available for download from the MIT repository.

    Unlike seq, jot can generate a sequence of random numbers, using the -r option.

    bash$ jot -r 3 999
    1069
     1272
     1428

				12.11.2.9.4 getopt

    The getopt command parses command-line options preceded by a dash. This external command corresponds to the getopts Bash builtin. Using getopt permits handling long options by means of the -l flag, and this also allows parameter reshuffling.

				12.11.2.9.5 Example 15-56. Using getopt to parse command-line options

    #!/bin/bash
    # Using getopt

    # Try the following when invoking this script:
    #   sh ex33a.sh -a
    #   sh ex33a.sh -abc
    #   sh ex33a.sh -a -b -c
    #   sh ex33a.sh -d
    #   sh ex33a.sh -dXYZ
    #   sh ex33a.sh -d XYZ
    #   sh ex33a.sh -abcd
    #   sh ex33a.sh -abcdZ
    #   sh ex33a.sh -z
    #   sh ex33a.sh a
    # Explain the results of each of the above.

    E_OPTERR=65

    if [ "$#" -eq 0 ]
    then   # Script needs at least one command-line argument.
      echo "Usage $0 -[options a,b,c]"
      exit $E_OPTERR
    fi  

    set -- `getopt "abcd:" "$@"`
    # Sets positional parameters to command-line arguments.
    # What happens if you use "$*" instead of "$@"?

    while [ ! -z "$1" ]
    do
      case "$1" in
        -a) echo "Option \"a\"";;
        -b) echo "Option \"b\"";;
        -c) echo "Option \"c\"";;
        -d) echo "Option \"d\" $2";;
         *) break;;
      esac

      shift
    done

    #  It is usually better to use the 'getopts' builtin in a script.
    #  See "ex33.sh."

    exit 0

    Note	

    As Peggy Russell points out:

    It is often necessary to include an eval to correctly process whitespace and quotes.

    args=$(getopt -o a:bc:d -- "$@")
    eval set -- "$args"

				12.11.2.9.6 run-parts

    The run-parts command [1] executes all the scripts in a target directory, sequentially in ASCII-sorted filename order. Of course, the scripts need to have execute permission.

    The cron daemon invokes run-parts to run the scripts in the /etc/cron.* directories.
				12.11.2.9.7 yes

    In its default behavior the yes command feeds a continuous string of the character y followed by a line feed to stdout. A control-C terminates the run. A different output string may be specified, as in yes different string, which would continually output different string to stdout.

    One might well ask the purpose of this. From the command line or in a script, the output of yes can be redirected or piped into a program expecting user input. In effect, this becomes a sort of poor man's version of expect.

    yes | fsck /dev/hda1 runs fsck non-interactively (careful!).

    yes | rm -r dirname has same effect as rm -rf dirname (careful!).

    Warning	Caution advised when piping yes to a potentially dangerous system command, such as fsck or fdisk. It might have unintended consequences.

    Note	The yes command parses variables, or more accurately, it echoes parsed variables. For example:

    bash$ yes $BASH_VERSION
|    3.1.17(1)-release
|     3.1.17(1)-release
|     3.1.17(1)-release
|     3.1.17(1)-release
|     3.1.17(1)-release
     . . .
    	      

    This particular "feature" may be used to create a very large ASCII file on the fly:

    bash$ yes $PATH > huge_file.txt
    Ctl-C	      
    	      

    Hit Ctl-C very quickly, or you just might get more than you bargained for. . . .

    Example, use for cleartool uncheckout to answer yes to creating keep file:
    yes | ct unco *
    "
Save private copy of "ldap_utf8.h"?  [yes] Private version of "ldap_utf8.h" saved in "ldap_utf8.h.keep".
Checkout cancelled for "ldap_utf8.h".
"
    The yes command may be emulated in a very simple script function.

    yes ()
    { # Trivial emulation of "yes" ...
      local DEFAULT_TEXT="yes"
      while [ true ]   # Endless loop.
      do
        if [ -z "$1" ]
        then
          echo "$DEFAULT_TEXT"
        else           # If argument ...
          echo "$1"    # ... expand and echo it.
        fi
      done             #  The only things missing are the
    }                  #+ --help and --version options.

				12.11.2.9.8 banner

    Prints arguments as a large vertical banner to stdout, using an ASCII character (default '#'). This may be redirected to a printer for hardcopy.

    Note that banner has been dropped from many Linux distros.
				12.11.2.9.9 printenv

    Show all the environmental variables set for a particular user.

    bash$ printenv | grep HOME
    HOME=/home/bozo
    	      

				12.11.2.9.10 lp

    The lp and lpr commands send file(s) to the print queue, to be printed as hard copy. [2] These commands trace the origin of their names to the line printers of another era.

    bash$ lp file1.txt or bash lp <file1.txt

    It is often useful to pipe the formatted output from pr to lp.

    bash$ pr -options file1.txt | lp

    Formatting packages, such as groff and Ghostscript may send their output directly to lp.

    bash$ groff -Tascii file.tr | lp

    bash$ gs -options | lp file.ps

    Related commands are lpq, for viewing the print queue, and lprm, for removing jobs from the print queue.
				12.11.2.9.11 tee

    [UNIX borrows an idea from the plumbing trade.]

    This is a redirection operator, but with a difference. Like the plumber's tee, it permits "siphoning off" to a file the output of a command or commands within a pipe, but without affecting the result. This is useful for printing an ongoing process to a file or paper, perhaps to keep track of it for debugging purposes.

                                 (redirection)
                                |----> to file
                                |
      ==========================|====================
      command ---> command ---> |tee ---> command ---> ---> output of pipe
      ===============================================
    	      

    cat listfile* | sort | tee check.file | uniq > result.file
    #                      ^^^^^^^^^^^^^^   ^^^^    

    #  The file "check.file" contains the concatenated sorted "listfiles,"
    #+ before the duplicate lines are removed by 'uniq.'

				12.11.2.9.12 mkfifo

    This obscure command creates a named pipe, a temporary first-in-first-out buffer for transferring data between processes. [3] Typically, one process writes to the FIFO, and the other reads from it. See Example A-15.

    #!/bin/bash
    # This short script by Omair Eshkenazi.
    # Used in ABS Guide with permission (thanks!).

    mkfifo pipe1   # Yes, pipes can be given names.
    mkfifo pipe2   # Hence the designation "named pipe."

    (cut -d' ' -f1 | tr "a-z" "A-Z") >pipe2 <pipe1 &
    ls -l | tr -s ' ' | cut -d' ' -f3,9- | tee pipe1 |
    cut -d' ' -f2 | paste - pipe2

    rm -f pipe1
    rm -f pipe2

    # No need to kill background processes when script terminates (why not?).

    exit $?

    Now, invoke the script and explain the output:
    sh mkfifo-example.sh

    |4830.tar.gz          BOZO
    pipe1   BOZO
    pipe2   BOZO
    mkfifo-example.sh    BOZO
    Mixed.msg BOZO

				12.11.2.9.13 pathchk

    This command checks the validity of a filename. If the filename exceeds the maximum allowable length (255 characters) or one or more of the directories in its path is not searchable, then an error message results.

    Unfortunately, pathchk does not return a recognizable error code, and it is therefore pretty much useless in a script. Consider instead the file test operators.
				12.11.2.9.14 dd

    This is the somewhat obscure and much feared data duplicator command. Originally a utility for exchanging data on magnetic tapes between UNIX minicomputers and IBM mainframes, this command still has its uses. The dd command simply copies a file (or stdin/stdout), but with conversions. Possible conversions are ASCII/EBCDIC, [4] upper/lower case, swapping of byte pairs between input and output, and skipping and/or truncating the head or tail of the input file.

    # Converting a file to all uppercase:

    dd if=$filename conv=ucase > $filename.uppercase
    #                    lcase   # For lower case conversion

    Some basic options to dd are:

        * if=INFILE

          INFILE is the source file.
        * of=OUTFILE

          OUTFILE is the target file, the file that will have the data written to it.
        * bs=BLOCKSIZE

          This is the size of each block of data being read and written, usually a power of 2.
        * skip=BLOCKS

          How many blocks of data to skip in INFILE before starting to copy. This is useful when the INFILE has "garbage" or garbled data in its header or when it is desirable to copy only a portion of the INFILE.
        * seek=BLOCKS

          How many blocks of data to skip in OUTFILE before starting to copy, leaving blank data at beginning of OUTFILE.
        * count=BLOCKS

          Copy only this many blocks of data, rather than the entire INFILE.
        * conv=CONVERSION

          Type of conversion to be applied to INFILE data before copying operation.

    A dd --help lists all the options this powerful utility takes.

				12.11.2.9.15 Example 15-57. A script that copies itself

    #!/bin/bash
    # self-copy.sh

    # This script copies itself.

    file_subscript=copy

    dd if=$0 of=$0.$file_subscript 2>/dev/null
    # Suppress messages from dd:   ^^^^^^^^^^^

    exit $?

    #  A program whose only output is its own source code
    #+ is called a "quine" per Willard Quine.
    #  Does this script qualify as a quine?

				12.11.2.9.16 Example 15-58. Exercising dd

    #!/bin/bash
    # exercising-dd.sh

    # Script by Stephane Chazelas.
    # Somewhat modified by ABS Guide author.

    infile=$0       # This script.
    outfile=log.txt # This output file left behind.
    n=3
    p=5

    dd if=$infile of=$outfile bs=1 skip=$((n-1)) count=$((p-n+1)) 2> /dev/null
    # Extracts characters n to p (3 to 5) from this script.

    # --------------------------------------------------------

    echo -n "hello world" | dd cbs=1 conv=unblock 2> /dev/null
    # Echoes "hello world" vertically.
    # Why? Newline after each character dd emits.

    exit 0

    To demonstrate just how versatile dd is, let's use it to capture keystrokes.

				12.11.2.9.17 Example 15-59. Capturing Keystrokes

    #!/bin/bash
    # dd-keypress.sh: Capture keystrokes without needing to press ENTER.


    keypresses=4                      # Number of keypresses to capture.


    old_tty_setting=$(stty -g)        # Save old terminal settings.

    echo "Press $keypresses keys."
    stty -icanon -echo                # Disable canonical mode.
                                      # Disable local echo.
    keys=$(dd bs=1 count=$keypresses 2> /dev/null)
    # 'dd' uses stdin, if "if" (input file) not specified.

    stty "$old_tty_setting"           # Restore old terminal settings.

    echo "You pressed the \"$keys\" keys."

    # Thanks, Stephane Chazelas, for showing the way.
    exit 0

    The dd command can do random access on a data stream.

    echo -n . | dd bs=1 seek=4 of=file conv=notrunc
    #  The "conv=notrunc" option means that the output file
    #+ will not be truncated.

    # Thanks, S.C.

    The dd command can copy raw data and disk images to and from devices, such as floppies and tape drives (Example A-5). A common use is creating boot floppies.

    dd if=kernel-image of=/dev/fd0H1440

    Similarly, dd can copy the entire contents of a floppy, even one formatted with a "foreign" OS, to the hard drive as an image file.

    dd if=/dev/fd0 of=/home/bozo/projects/floppy.img

    Other applications of dd include initializing temporary swap files (Example 28-2) and ramdisks (Example 28-3). It can even do a low-level copy of an entire hard drive partition, although this is not necessarily recommended.

    People (with presumably nothing better to do with their time) are constantly thinking of interesting applications of dd.

				12.11.2.9.18 Example 15-60. Securely deleting a file

    #!/bin/bash
    # blot-out.sh: Erase "all" traces of a file.

    #  This script overwrites a target file alternately
    #+ with random bytes, then zeros before finally deleting it.
    #  After that, even examining the raw disk sectors by conventional methods
    #+ will not reveal the original file data.

    PASSES=7         #  Number of file-shredding passes.
                     #  Increasing this slows script execution,
                     #+ especially on large target files.
    BLOCKSIZE=1      #  I/O with /dev/urandom requires unit block size,
                     #+ otherwise you get weird results.
    E_BADARGS=70     #  Various error exit codes.
    E_NOT_FOUND=71
    E_CHANGED_MIND=72

    if [ -z "$1" ]   # No filename specified.
    then
      echo "Usage: `basename $0` filename"
      exit $E_BADARGS
    fi

    file=$1

    if [ ! -e "$file" ]
    then
      echo "File \"$file\" not found."
      exit $E_NOT_FOUND
    fi  

    echo; echo -n "Are you absolutely sure you want to blot out \"$file\" (y/n)? "
    read answer
    case "$answer" in
    [nN]) echo "Changed your mind, huh?"
          exit $E_CHANGED_MIND
          ;;
    *)    echo "Blotting out file \"$file\".";;
    esac


    flength=$(ls -l "$file" | awk '{print $5}')  # Field 5 is file length.
    pass_count=1

    chmod u+w "$file"   # Allow overwriting/deleting the file.

    echo

    while [ "$pass_count" -le "$PASSES" ]
    do
      echo "Pass #$pass_count"
      sync         # Flush buffers.
      dd if=/dev/urandom of=$file bs=$BLOCKSIZE count=$flength
                   # Fill with random bytes.
      sync         # Flush buffers again.
      dd if=/dev/zero of=$file bs=$BLOCKSIZE count=$flength
                   # Fill with zeros.
      sync         # Flush buffers yet again.
      let "pass_count += 1"
      echo
    done  


    rm -f $file    # Finally, delete scrambled and shredded file.
    sync           # Flush buffers a final time.

    echo "File \"$file\" blotted out and deleted."; echo


    exit 0

    #  This is a fairly secure, if inefficient and slow method
    #+ of thoroughly "shredding" a file.
    #  The "shred" command, part of the GNU "fileutils" package,
    #+ does the same thing, although more efficiently.

    #  The file cannot not be "undeleted" or retrieved by normal methods.
    #  However . . .
    #+ this simple method would *not* likely withstand
    #+ sophisticated forensic analysis.

    #  This script may not play well with a journaled file system.
    #  Exercise (difficult): Fix it so it does.



    #  Tom Vier's "wipe" file-deletion package does a much more thorough job
    #+ of file shredding than this simple script.
    #     http://www.ibiblio.org/pub/Linux/utils/file/wipe-2.0.0.tar.bz2

    #  For an in-depth analysis on the topic of file deletion and security,
    #+ see Peter Gutmann's paper,
    #+     "Secure Deletion of Data From Magnetic and Solid-State Memory".
    #       http://www.cs.auckland.ac.nz/~pgut001/pubs/secure_del.html

    See also the dd thread entry in the bibliography.
				12.11.2.9.19 od

    The od, or octal dump filter converts input (or files) to octal (base-8) or other bases. This is useful for viewing or processing binary data files or otherwise unreadable system device files, such as /dev/urandom, and as a filter for binary data.

    head -c4 /dev/urandom | od -N4 -tu4 | sed -ne '1s/.* //p'
    # Sample output: 1324725719, 3918166450, 2989231420, etc.

    # From rnd.sh example script, by Stphane Chazelas

    See also Example 9-31 and Example A-38.
				12.11.2.9.20 hexdump

    Performs a hexadecimal, octal, decimal, or ASCII dump of a binary file. This command is the rough equivalent of od, above, but not nearly as useful. May be used to view the contents of a binary file, in combination with dd and less.

    dd if=/bin/ls | hexdump -C | less
    # The -C option nicely formats the output in tabular form.

				12.11.2.9.21 objdump

    Displays information about an object file or binary executable in either hexadecimal form or as a disassembled listing (with the -d option).

    bash$ objdump -d /bin/ls
    /bin/ls:     file format elf32-i386

     Disassembly of section .init:

     080490bc <.init>:
      80490bc:       55                      push   %ebp
      80490bd:       89 e5                   mov    %esp,%ebp
      . . .
    	      

				12.11.2.9.22 mcookie

    This command generates a "magic cookie," a 128-bit (32-character) pseudorandom hexadecimal number, normally used as an authorization "signature" by the X server. This also available for use in a script as a "quick 'n dirty" random number.

    random000=$(mcookie)

    Of course, a script could use md5sum for the same purpose.

    # Generate md5 checksum on the script itself.
    random001=`md5sum $0 | awk '{print $1}'`
    # Uses 'awk' to strip off the filename.

    The mcookie command gives yet another way to generate a "unique" filename.

				12.11.2.9.23 Example 15-61. Filename generator

    #!/bin/bash
    # tempfile-name.sh:  temp filename generator

    BASE_STR=`mcookie`   # 32-character magic cookie.
    POS=11               # Arbitrary position in magic cookie string.
    LEN=5                # Get $LEN consecutive characters.

    prefix=temp          #  This is, after all, a "temp" file.
                         #  For more "uniqueness," generate the
                         #+ filename prefix using the same method
                         #+ as the suffix, below.

    suffix=${BASE_STR:POS:LEN}
                         #  Extract a 5-character string,
                         #+ starting at position 11.

    temp_filename=$prefix.$suffix
                         # Construct the filename.

    echo "Temp filename = "$temp_filename""

    # sh tempfile-name.sh
    # Temp filename = temp.e19ea

    #  Compare this method of generating "unique" filenames
    #+ with the 'date' method in ex51.sh.

    exit 0

				12.11.2.9.24 units

    This utility converts between different units of measure. While normally invoked in interactive mode, units may find use in a script.

				12.11.2.9.25 Example 15-62. Converting meters to miles

    #!/bin/bash
    # unit-conversion.sh


    convert_units ()  # Takes as arguments the units to convert.
    {
      cf=$(units "$1" "$2" | sed --silent -e '1p' | awk '{print $2}')
      # Strip off everything except the actual conversion factor.
      echo "$cf"
    }  

    Unit1=miles
    Unit2=meters
    cfactor=`convert_units $Unit1 $Unit2`
    quantity=3.73

    result=$(echo $quantity*$cfactor | bc)

    echo "There are $result $Unit2 in $quantity $Unit1."

    #  What happens if you pass incompatible units,
    #+ such as "acres" and "miles" to the function?

    exit 0

				12.11.2.9.26 m4

    A hidden treasure, m4 is a powerful macro [5] processing filter, virtually a complete language. Although originally written as a pre-processor for RatFor, m4 turned out to be useful as a stand-alone utility. In fact, m4 combines some of the functionality of eval, tr, and awk, in addition to its extensive macro expansion facilities.

    The April, 2002 issue of Linux Journal has a very nice article on m4 and its uses.

				12.11.2.9.27 Example 15-63. Using m4

    #!/bin/bash
    # m4.sh: Using the m4 macro processor

    # Strings
    string=abcdA01
    echo "len($string)" | m4                            #   7
    echo "substr($string,4)" | m4                       # A01
    echo "regexp($string,[0-1][0-1],\&Z)" | m4          # 01Z

    # Arithmetic
    echo "incr(22)" | m4                                #  23
    echo "eval(99 / 3)" | m4                            #  33

    exit 0

				12.11.2.9.28 xmessage

    This X-based variant of echo pops up a message/query window on the desktop.

    xmessage Left click to continue -button okay

				12.11.2.9.29 zenity

    The zenity utility is adept at displaying GTK+ dialog widgets and very suitable for scripting purposes.
				12.11.2.9.30 doexec

    The doexec command enables passing an arbitrary list of arguments to a binary executable. In particular, passing argv[0] (which corresponds to $0 in a script) lets the executable be invoked by various names, and it can then carry out different sets of actions, according to the name by which it was called. What this amounts to is roundabout way of passing options to an executable.

    For example, the /usr/local/bin directory might contain a binary called "aaa". Invoking doexec /usr/local/bin/aaa list would list all those files in the current working directory beginning with an "a", while invoking (the same executable with) doexec /usr/local/bin/aaa delete would delete those files.

    Note	The various behaviors of the executable must be defined within the code of the executable itself, analogous to something like the following in a shell script:

    case `basename $0` in
    "name1" ) do_something;;
    "name2" ) do_something_else;;
    "name3" ) do_yet_another_thing;;
    *       ) bail_out;;
    esac

				12.11.2.9.31 dialog

    The dialog family of tools provide a method of calling interactive "dialog" boxes from a script. The more elaborate variations of dialog -- gdialog, Xdialog, and kdialog -- actually invoke X-Windows widgets.
				12.11.2.9.32 sox

    The sox, or "sound exchange" command plays and performs transformations on sound files. In fact, the /usr/bin/play executable (now deprecated) is nothing but a shell wrapper for sox.

    For example, sox soundfile.wav soundfile.au changes a WAV sound file into a (Sun audio format) AU sound file.

    Shell scripts are ideally suited for batch-processing sox operations on sound files. For examples, see the Linux Radio Timeshift HOWTO and the MP3do Project.


		12.11.3 Chapter 16. System and Administrative Commands
The startup and shutdown scripts in /etc/rc.d illustrate the uses (and usefulness) of many of these comands. These are usually invoked by root and used for system maintenance or emergency filesystem repairs. Use with caution, as some of these commands may damage your system if misused.

Users and Groups
			12.11.3.1 users

    Show all logged on users. This is the approximate equivalent of who -q.

			12.11.3.2 groups

    Lists the current user and the groups she belongs to. This corresponds to the $GROUPS internal variable, but gives the group names, rather than the numbers.

    bash$ groups
    bozita cdrom cdwriter audio xgrp

    bash$ echo $GROUPS
    501

			12.11.3.3 chown, chgrp

    The chown command changes the ownership of a file or files. This command is a useful method that root can use to shift file ownership from one user to another. An ordinary user may not change the ownership of files, not even her own files. [1]

    root# chown bozo *.txt

    	      

    The chgrp command changes the group ownership of a file or files. You must be owner of the file(s) as well as a member of the destination group (or root) to use this operation.

    chgrp --recursive dunderheads *.data
    #  The "dunderheads" group will now own all the "*.data" files
    #+ all the way down the $PWD directory tree (that's what "recursive" means).

useradd, userdel

    The useradd administrative command adds a user account to the system and creates a home directory for that particular user, if so specified. The corresponding userdel command removes a user account from the system [2] and deletes associated files.

    Note	The adduser command is a synonym for useradd and is usually a symbolic link to it.
			12.11.3.4 usermod

    Modify a user account. Changes may be made to the password, group membership, expiration date, and other attributes of a given user's account. With this command, a user's password may be locked, which has the effect of disabling the account.
			12.11.3.5 groupmod

    Modify a given group. The group name and/or ID number may be changed using this command.
			12.11.3.6 id

    The id command lists the real and effective user IDs and the group IDs of the user associated with the current process. This is the counterpart to the $UID, $EUID, and $GROUPS internal Bash variables.

    bash$ id
    uid=501(bozo) gid=501(bozo) groups=501(bozo),22(cdrom),80(cdwriter),81(audio)

    bash$ echo $UID
    501

    Note	The id command shows the effective IDs only when they differ from the real ones.

			12.11.3.7 who

    Show all users logged on to the system.

    bash$ who
    bozo  tty1     Apr 27 17:45
     bozo  pts/0    Apr 27 17:46
     bozo  pts/1    Apr 27 17:47
     bozo  pts/2    Apr 27 17:49
    	      

    The -m gives detailed information about only the current user. Passing any two arguments to who is the equivalent of who -m, as in who am i or who The Man.

    bash$ who -m
    localhost.localdomain!bozo  pts/2    Apr 27 17:49
    	      

    whoami is similar to who -m, but only lists the user name.

    bash$ whoami
    bozo
    	      

			12.11.3.8 w

    Show all logged on users and the processes belonging to them. This is an extended version of who. The output of w may be piped to grep to find a specific user and/or process.

    bash$ w | grep startx
    bozo  tty1     -                 4:22pm  6:41   4.47s  0.45s  startx

			12.11.3.9 logname

    Show current user's login name (as found in /var/run/utmp). This is a near-equivalent to whoami, above.

    bash$ logname
    bozo

    bash$ whoami
    bozo

    However . . .

    bash$ su
    Password: ......

    bash# whoami
    root
    bash# logname
    bozo

    Note	While logname prints the name of the logged in user, whoami gives the name of the user attached to the current process. As we have just seen, sometimes these are not the same.
			12.11.3.10 su

    Runs a program or script as a substitute user. su rjones starts a shell as user rjones. A naked su defaults to root. 
			12.11.3.11 sudo

    Runs a command as root (or another user). This may be used in a script, thus permitting a regular user to run the script.

    #!/bin/bash

    # Some commands.
    sudo cp /root/secretfile /home/bozo/secret
    # Some more commands.

    The file /etc/sudoers holds the names of users permitted to invoke sudo.
			12.11.3.12 passwd

    Sets, changes, or manages a user's password.

    The passwd command can be used in a script, but probably should not be.

    Example 16-1. Setting a new password

    #!/bin/bash
    #  setnew-password.sh: For demonstration purposes only.
    #                      Not a good idea to actually run this script.
    #  This script must be run as root.

    ROOT_UID=0         # Root has $UID 0.
    E_WRONG_USER=65    # Not root?

    E_NOSUCHUSER=70
    SUCCESS=0


    if [ "$UID" -ne "$ROOT_UID" ]
    then
      echo; echo "Only root can run this script."; echo
      exit $E_WRONG_USER
    else
      echo
      echo "You should know better than to run this script, root."
      echo "Even root users get the blues... "
      echo
    fi  


    username=bozo
    NEWPASSWORD=security_violation

    # Check if bozo lives here.
    grep -q "$username" /etc/passwd
    if [ $? -ne $SUCCESS ]
    then
      echo "User $username does not exist."
      echo "No password changed."
      exit $E_NOSUCHUSER
    fi  

    echo "$NEWPASSWORD" | passwd --stdin "$username"
    #  The '--stdin' option to 'passwd' permits
    #+ getting a new password from stdin (or a pipe).

    echo; echo "User $username's password changed!"

    # Using the 'passwd' command in a script is dangerous.

    exit 0

    The passwd command's -l, -u, and -d options permit locking, unlocking, and deleting a user's password. Only root may use these options.
			12.11.3.13 ac

    Show users' logged in time, as read from /var/log/wtmp. This is one of the GNU accounting utilities.

    bash$ ac
            total       68.08

			12.11.3.14 last

    List last logged in users, as read from /var/log/wtmp. This command can also show remote logins.

    For example, to show the last few times the system rebooted:

    bash$ last reboot
    reboot   system boot  2.6.9-1.667      Fri Feb  4 18:18          (00:02)    
     reboot   system boot  2.6.9-1.667      Fri Feb  4 15:20          (01:27)    
     reboot   system boot  2.6.9-1.667      Fri Feb  4 12:56          (00:49)    
     reboot   system boot  2.6.9-1.667      Thu Feb  3 21:08          (02:17)    
     . . .

     wtmp begins Tue Feb  1 12:50:09 2005

			12.11.3.15 newgrp

    Change user's group ID without logging out. This permits access to the new group's files. Since users may be members of multiple groups simultaneously, this command finds only limited use.

    Note	Kurt Glaesemann points out that the newgrp command could prove helpful in setting the default group permissions for files a user writes. However, the chgrp command might be more convenient for this purpose.

Terminals

			12.11.3.16 tty

    Echoes the name (filename) of the current user's terminal. Note that each separate xterm window counts as a different terminal.

    bash$ tty
    /dev/pts/1

			12.11.3.17 stty

    Shows and/or changes terminal settings. This complex command, used in a script, can control terminal behavior and the way output displays. See the info page, and study it carefully.

			12.11.3.18 Example 16-2. Setting an erase character

    #!/bin/bash
    # erase.sh: Using "stty" to set an erase character when reading input.

    echo -n "What is your name? "
    read name                      #  Try to backspace
                                   #+ to erase characters of input.
                                   #  Problems?
    echo "Your name is $name."

    stty erase '#'                 #  Set "hashmark" (#) as erase character.
    echo -n "What is your name? "
    read name                      #  Use # to erase last character typed.
    echo "Your name is $name."

    exit 0

    # Even after the script exits, the new key value remains set.
    # Exercise: How would you reset the erase character to the default value?

			12.11.3.19 Example 16-3. secret password: Turning off terminal echoing

    #!/bin/bash
    # secret-pw.sh: secret password

    echo
    echo -n "Enter password "
    read passwd
    echo "password is $passwd"
    echo -n "If someone had been looking over your shoulder, "
    echo "your password would have been compromised."

    echo && echo  # Two line-feeds in an "and list."


    stty -echo    # Turns off screen echo.

    echo -n "Enter password again "
    read passwd
    echo
    echo "password is $passwd"
    echo

    stty echo     # Restores screen echo.

    exit 0

    # Do an 'info stty' for more on this useful-but-tricky command.

    A creative use of stty is detecting a user keypress (without hitting ENTER).

			12.11.3.20 Example 16-4. Keypress detection

    #!/bin/bash
    # keypress.sh: Detect a user keypress ("hot keys").

    echo

    old_tty_settings=$(stty -g)   # Save old settings (why?).
    stty -icanon
    Keypress=$(head -c1)          # or $(dd bs=1 count=1 2> /dev/null)
                                  # on non-GNU systems

    echo
    echo "Key pressed was \""$Keypress"\"."
    echo

    stty "$old_tty_settings"      # Restore old settings.

    # Thanks, Stephane Chazelas.

    exit 0


    terminals and modes

    Normally, a terminal works in the canonical mode. When a user hits a key, the resulting character does not immediately go to the program actually running in this terminal. A buffer local to the terminal stores keystrokes. When the user hits the ENTER key, this sends all the stored keystrokes to the program running. There is even a basic line editor inside the terminal.

    bash$ stty -a
    speed 9600 baud; rows 36; columns 96; line = 0;
     intr = ^C; quit = ^\; erase = ^H; kill = ^U; eof = ^D; eol = <undef>; eol2 = <undef>;
     start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O;
     ...
     isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt
                    

    Using canonical mode, it is possible to redefine the special keys for the local terminal line editor.

    bash$ cat > filexxx
    wha<ctl-W>I<ctl-H>foo bar<ctl-U>hello world<ENTER>
    <ctl-D>
    bash$ cat filexxx
    hello world		
    bash$ wc -c < filexxx
    12		
                    

    The process controlling the terminal receives only 12 characters (11 alphabetic ones, plus a newline), although the user hit 26 keys.

    In non-canonical ("raw") mode, every key hit (including special editing keys such as ctl-H) sends a character immediately to the controlling process.

    The Bash prompt disables both icanon and echo, since it replaces the basic terminal line editor with its own more elaborate one. For example, when you hit ctl-A at the Bash prompt, there's no ^A echoed by the terminal, but Bash gets a \1 character, interprets it, and moves the cursor to the begining of the line.

    Stphane Chazelas
			12.11.3.21 setterm

    Set certain terminal attributes. This command writes to its terminal's stdout a string that changes the behavior of that terminal.

    bash$ setterm -cursor off
    bash$
    	      

    The setterm command can be used within a script to change the appearance of text written to stdout, although there are certainly better tools available for this purpose.

    setterm -bold on
    echo bold hello

    setterm -bold off
    echo normal hello

			12.11.3.22 tset

    Show or initialize terminal settings. This is a less capable version of stty.

    bash$ tset -r
    Terminal type is xterm-xfree86.
     Kill is control-U (^U).
     Interrupt is control-C (^C).
    	      

			12.11.3.23 setserial

    Set or display serial port parameters. This command must be run by root and is usually found in a system setup script.

    # From /etc/pcmcia/serial script:

    IRQ=`setserial /dev/$DEVICE | sed -e 's/.*IRQ: //'`
    setserial /dev/$DEVICE irq 0 ; setserial /dev/$DEVICE irq $IRQ

			12.11.3.24 getty, agetty

    The initialization process for a terminal uses getty or agetty to set it up for login by a user. These commands are not used within user shell scripts. Their scripting counterpart is stty.
			12.11.3.25 mesg

    Enables or disables write access to the current user's terminal. Disabling access would prevent another user on the network to write to the terminal.

    Tip	It can be quite annoying to have a message about ordering pizza suddenly appear in the middle of the text file you are editing. On a multi-user network, you might therefore wish to disable write access to your terminal when you need to avoid interruptions.
			12.11.3.26 wall

    This is an acronym for "write all," i.e., sending a message to all users at every terminal logged into the network. It is primarily a system administrator's tool, useful, for example, when warning everyone that the system will shortly go down due to a problem (see Example 18-1).

    bash$ wall System going down for maintenance in 5 minutes!
    Broadcast message from bozo (pts/1) Sun Jul  8 13:53:27 2001...

     System going down for maintenance in 5 minutes!
    	      

    Note	If write access to a particular terminal has been disabled with mesg, then wall cannot send a message to that terminal.

Information and Statistics

			12.11.3.27 uname

    Output system specifications (OS, kernel version, etc.) to stdout. Invoked with the -a option, gives verbose system info (see Example 15-5). The -s option shows only the OS type.

    bash$ uname
    Linux

    bash$ uname -s
    Linux


    bash$ uname -a
    Linux iron.bozo 2.6.15-1.2054_FC5 #1 Tue Mar 14 15:48:33 EST 2006
     i686 i686 i386 GNU/Linux

			12.11.3.28 arch

    Show system architecture. Equivalent to uname -m. 

    bash$ arch
    i686

    bash$ uname -m
    i686

			12.11.3.29 lastcomm

    Gives information about previous commands, as stored in the /var/account/pacct file. Command name and user name can be specified by options. This is one of the GNU accounting utilities.
			12.11.3.30 lastlog

    List the last login time of all system users. This references the /var/log/lastlog file.

    bash$ lastlog
    root          tty1                      Fri Dec  7 18:43:21 -0700 2001
     bin                                     **Never logged in**
     daemon                                  **Never logged in**
     ...
     bozo          tty1                      Sat Dec  8 21:14:29 -0700 2001



    bash$ lastlog | grep root
    root          tty1                      Fri Dec  7 18:43:21 -0700 2001
    	      

    Caution	This command will fail if the user invoking it does not have read permission for the /var/log/lastlog file.
			12.11.3.31 lsof

    List open files. This command outputs a detailed table of all currently open files and gives information about their owner, size, the processes associated with them, and more. Of course, lsof may be piped to grep and/or awk to parse and analyze its results.

    bash$ lsof
    COMMAND    PID    USER   FD   TYPE     DEVICE    SIZE     NODE NAME
     init         1    root  mem    REG        3,5   30748    30303 /sbin/init
     init         1    root  mem    REG        3,5   73120     8069 /lib/ld-2.1.3.so
     init         1    root  mem    REG        3,5  931668     8075 /lib/libc-2.1.3.so
     cardmgr    213    root  mem    REG        3,5   36956    30357 /sbin/cardmgr
     ...
    	      

    The lsof command is a useful, if complex administrative tool. If you are unable to dismount a filesystem and get an error message that it is still in use, then running lsof helps determine which files are still open on that filesystem. The -i option lists open network socket files, and this can help trace intrusion or hack attempts.

    bash$ lsof -an -i tcp
    COMMAND  PID USER  FD  TYPE DEVICE SIZE NODE NAME
     firefox 2330 bozo  32u IPv4   9956       TCP 66.0.118.137:57596->67.112.7.104:http ...
     firefox 2330 bozo  38u IPv4  10535       TCP 66.0.118.137:57708->216.79.48.24:http ...
    	      

			12.11.3.32 strace

    System trace: diagnostic and debugging tool for tracing system calls and signals. This command and ltrace, following, are useful for diagnosing why a given program or package fails to run . . . perhaps due to missing libraries or related causes.

    bash$ strace df
    execve("/bin/df", ["df"], [/* 45 vars */]) = 0
     uname({sys="Linux", node="bozo.localdomain", ...}) = 0
     brk(0)                                  = 0x804f5e4

     ...
    	    

    This is the Linux equivalent of the Solaris truss command.
			12.11.3.33 ltrace

    Library trace: diagnostic and debugging tool that traces library calls invoked by a given command.

    bash$ ltrace df
    __libc_start_main(0x804a910, 1, 0xbfb589a4, 0x804fb70, 0x804fb68 <unfinished ...>:
     setlocale(6, "")                                 = "en_US.UTF-8"
    bindtextdomain("coreutils", "/usr/share/locale") = "/usr/share/locale"
    textdomain("coreutils")                          = "coreutils"
    __cxa_atexit(0x804b650, 0, 0, 0x8052bf0, 0xbfb58908) = 0
    getenv("DF_BLOCK_SIZE")                          = NULL

     ...
    	    

			12.11.3.34 nmap

    Network mapper and port scanner. This command scans a server to locate open ports and the services associated with those ports. It can also report information about packet filters and firewalls. This is an important security tool for locking down a network against hacking attempts.

    #!/bin/bash

    SERVER=$HOST                           # localhost.localdomain (127.0.0.1).
    PORT_NUMBER=25                         # SMTP port.

    nmap $SERVER | grep -w "$PORT_NUMBER"  # Is that particular port open?
    #              grep -w matches whole words only,
    #+             so this wouldn't match port 1025, for example.

    exit 0

    # 25/tcp     open        smtp

			12.11.3.35 nc

    The nc (netcat) utility is a complete toolkit for connecting to and listening to TCP and UDP ports. It is useful as a diagnostic and testing tool and as a component in simple script-based HTTP clients and servers.

    bash$ nc localhost.localdomain 25
    220 localhost.localdomain ESMTP Sendmail 8.13.1/8.13.1;
     Thu, 31 Mar 2005 15:41:35 -0700

			12.11.3.36 Example 16-5. Checking a remote server for identd

    #! /bin/sh
    ## Duplicate DaveG's ident-scan thingie using netcat. Oooh, he'll be p*ssed.
    ## Args: target port [port port port ...]
    ## Hose stdout _and_ stderr together.
    ##
    ##  Advantages: runs slower than ident-scan, giving remote inetd less cause
    ##+ for alarm, and only hits the few known daemon ports you specify.
    ##  Disadvantages: requires numeric-only port args, the output sleazitude,
    ##+ and won't work for r-services when coming from high source ports.
    # Script author: Hobbit <hobbit@avian.org>
    # Used in ABS Guide with permission.

    # ---------------------------------------------------
    E_BADARGS=65       # Need at least two args.
    TWO_WINKS=2        # How long to sleep.
    THREE_WINKS=3
    IDPORT=113         # Authentication "tap ident" port.
    RAND1=999
    RAND2=31337
    TIMEOUT0=9
    TIMEOUT1=8
    TIMEOUT2=4
    # ---------------------------------------------------

    case "${2}" in
      "" ) echo "Need HOST and at least one PORT." ; exit $E_BADARGS ;;
    esac

    # Ping 'em once and see if they *are* running identd.
    nc -z -w $TIMEOUT0 "$1" $IDPORT || \
    { echo "Oops, $1 isn't running identd." ; exit 0 ; }
    #  -z scans for listening daemons.
    #     -w $TIMEOUT = How long to try to connect.

    # Generate a randomish base port.
    RP=`expr $$ % $RAND1 + $RAND2`

    TRG="$1"
    shift

    while test "$1" ; do
      nc -v -w $TIMEOUT1 -p ${RP} "$TRG" ${1} < /dev/null > /dev/null &
      PROC=$!
      sleep $THREE_WINKS
      echo "${1},${RP}" | nc -w $TIMEOUT2 -r "$TRG" $IDPORT 2>&1
      sleep $TWO_WINKS

    # Does this look like a lamer script or what . . . ?
    # ABS Guide author comments: "Ain't really all that bad . . .
    #+                            kinda clever, actually."

      kill -HUP $PROC
      RP=`expr ${RP} + 1`
      shift
    done

    exit $?

    #  Notes:
    #  -----

    #  Try commenting out line 30 and running this script
    #+ with "localhost.localdomain 25" as arguments.

    #  For more of Hobbit's 'nc' example scripts,
    #+ look in the documentation:
    #+ the /usr/share/doc/nc-X.XX/scripts directory.

    And, of course, there's Dr. Andrew Tridgell's notorious one-line script in the BitKeeper Affair:

    echo clone | nc thunk.org 5000 > e2fsprogs.dat

				12.11.3.36.1 More netcat (nc) examples

					12.11.3.36.1.1 CLIENT/SERVER MODEL 

It is quite simple to build a very basic client/server model using nc. On one console, start nc listening on a specific port for a connection. For example:

$ nc -l 1234

nc is now listening on port 1234 for a connection. On a second console (or a second machine), connect to the machine and port being listened on:

$ nc 127.0.0.1 1234

There should now be a connection between the ports. Anything typed at the second console will be concatenated to the first, and vice-versa. After the connection has been set up, nc does not really care which side is being used as a 'server' and which side is being used as a 'client'. The connection may be terminated using an EOF ('^D').
Data Transfer

The example in the previous section can be expanded to build a basic data transfer model. Any information input into one end of the connection will be output to the other end, and input and output can be easily captured in order to emulate file transfer.

Start by using nc to listen on a specific port, with output captured into a file:

$ nc -l 1234 > filename.out

Using a second machine, connect to the listening nc process, feeding it the file which is to be transferred:

$ nc host.example.com 1234 < filename.in

After the file has been transferred, the connection will close automatically.
Talking To Servers

It is sometimes useful to talk to servers ''by hand'' rather than through a user interface. It can aid in troubleshooting, when it might be necessary to verify what data a server is sending in response to commands issued by the client. For example, to retrieve the home page of a web site:

$ echo -n "GET / HTTP/1.0\r\n\r\n" | nc host.example.com 80

Note that this also displays the headers sent by the web server. They can be filtered, using a tool such as sed(1), if necessary.

More complicated examples can be built up when the user knows the format of requests required by the server. As another example, an email may be submitted to an SMTP server using:

$ nc localhost 25 << EOF
HELO host.example.com
MAIL FROM: <user@host.example.com>
RCPT TO: <user2@host.example.com>
DATA
Body of email.
.
QUIT
EOF

					12.11.3.36.1.2 Port Scanning 
It may be useful to know which ports are open and running services on a target machine. The -z flag can be used to tell nc to report open ports, rather than initiate a connection. For example:

$ nc -z host.example.com 20-30
Connection to host.example.com 22 port [tcp/ssh] succeeded!
Connection to host.example.com 25 port [tcp/smtp] succeeded!

The port range was specified to limit the search to ports 20 - 30.

Alternatively, it might be useful to know which server software is running, and which versions. This information is often contained within the greeting banners. In order to retrieve these, it is necessary to first make a connection, and then break the connection when the banner has been retrieved. This can be accomplished by specifying a small timeout with the -w flag, or perhaps by issuing a "QUIT" command to the server:

$ echo "QUIT" | nc host.example.com 20-30
SSH-1.99-OpenSSH_3.6.1p2
Protocol mismatch.
220 host.example.com IMS SMTP Receiver Version 0.84 Ready

					12.11.3.36.1.3 Various Examples

Open a TCP connection to port 42 of host.example.com, using port 31337 as the source port, with a timeout of 5 seconds:

$ nc -p 31337 -w 5 host.example.com 42

Open a UDP connection to port 53 of host.example.com:

$ nc -u host.example.com 53

Open a TCP connection to port 42 of host.example.com using 10.1.2.3 as the IP for the local end of the connection:

$ nc -s 10.1.2.3 host.example.com 42

Create and listen on a Unix Domain Socket:

$ nc -lU /var/tmp/dsocket

Connect to port 42 of host.example.com via an HTTP proxy at 10.2.3.4, port 8080. This example could also be used by ssh(1); see the ProxyCommand directive in ssh_config(5) for more information.

$ nc -x10.2.3.4:8080 -Xconnect host.example.com 42 


			12.11.3.37 free

    Shows memory and cache usage in tabular form. The output of this command lends itself to parsing, using grep, awk or Perl. The procinfo command shows all the information that free does, and much more.

    bash$ free
                    total       used       free     shared    buffers     cached
       Mem:         30504      28624       1880      15820       1608       16376
       -/+ buffers/cache:      10640      19864
       Swap:        68540       3128      65412

    To show unused RAM memory:

    bash$ free | grep Mem | awk '{ print $4 }'
    1880

			
			12.11.3.38 procinfo

    Extract and list information and statistics from the /proc pseudo-filesystem. This gives a very extensive and detailed listing.

    bash$ procinfo | grep Bootup
    Bootup: Wed Mar 21 15:15:50 2001    Load average: 0.04 0.21 0.34 3/47 6829

			12.11.3.39 lsdev

    List devices, that is, show installed hardware.

    bash$ lsdev
    Device            DMA   IRQ  I/O Ports
     ------------------------------------------------
     cascade             4     2 
     dma                          0080-008f
     dma1                         0000-001f
     dma2                         00c0-00df
     fpu                          00f0-00ff
     ide0                     14  01f0-01f7 03f6-03f6
     ...
    	      

			12.11.3.40 du

    Show (disk) file usage, recursively. Defaults to current working directory, unless otherwise specified.

    bash$ du -ach
|    1.0k    ./wi.sh
|     1.0k    ./tst.sh
|     1.0k    ./random.file
|     6.0k    .
|     6.0k    total

			12.11.3.41 df

    Shows filesystem usage in tabular form.

    bash$ df
    Filesystem           1k-blocks      Used Available Use% Mounted on
     /dev/hda5               273262     92607    166547  36% /
     /dev/hda8               222525    123951     87085  59% /home
     /dev/hda7              1408796   1075744    261488  80% /usr

			12.11.3.42 dmesg

    Lists all system bootup messages to stdout. Handy for debugging and ascertaining which device drivers were installed and which system interrupts in use. The output of dmesg may, of course, be parsed with grep, sed, or awk from within a script.

    bash$ dmesg | grep hda
    Kernel command line: ro root=/dev/hda2
     hda: IBM-DLGA-23080, ATA DISK drive
     hda: 6015744 sectors (3080 MB) w/96KiB Cache, CHS=746/128/63
     hda: hda1 hda2 hda3 < hda5 hda6 hda7 > hda4
    	      

			12.11.3.43 stat

    Gives detailed and verbose statistics on a given file (even a directory or device file) or set of files.

    bash$ stat test.cru
      File: "test.cru"
       Size: 49970        Allocated Blocks: 100          Filetype: Regular File
       Mode: (0664/-rw-rw-r--)         Uid: (  501/ bozo)  Gid: (  501/ bozo)
     Device:  3,8   Inode: 18185     Links: 1    
     Access: Sat Jun  2 16:40:24 2001
     Modify: Sat Jun  2 16:40:24 2001
     Change: Sat Jun  2 16:40:24 2001
    	      

    If the target file does not exist, stat returns an error message.

    bash$ stat nonexistent-file
    nonexistent-file: No such file or directory
    	      

    In a script, you can use stat to extract information about files (and filesystems) and set variables accordingly.

    #!/bin/bash
    # fileinfo2.sh

    # Per suggestion of Jol Bourquard and . . .
    # http://www.linuxquestions.org/questions/showthread.php?t=410766


    FILENAME=testfile.txt
    file_name=$(stat -c%n "$FILENAME")   # Same as "$FILENAME" of course.
    file_owner=$(stat -c%U "$FILENAME")
    file_size=$(stat -c%s "$FILENAME")
    #  Certainly easier than using "ls -l $FILENAME"
    #+ and then parsing with sed.
    file_inode=$(stat -c%i "$FILENAME")
    file_type=$(stat -c%F "$FILENAME")
    file_access_rights=$(stat -c%A "$FILENAME")

    echo "File name:          $file_name"
    echo "File owner:         $file_owner"
    echo "File size:          $file_size"
    echo "File inode:         $file_inode"
    echo "File type:          $file_type"
    echo "File access rights: $file_access_rights"

    exit 0

    sh fileinfo2.sh

    File name:          testfile.txt
    File owner:         bozo
    File size:          418
    File inode:         1730378
    File type:          regular file
    File access rights: -rw-rw-r--

			12.11.3.44 vmstat

    Display virtual memory statistics.

    bash$ vmstat
       procs                      memory    swap          io system         cpu
     r  b  w   swpd   free   buff  cache  si  so    bi    bo   in    cs  us  sy id
     0  0  0      0  11040   2636  38952   0   0    33     7  271    88   8   3 89
    	    

			12.11.3.45 netstat

    Show current network statistics and information, such as routing tables and active connections. This utility accesses information in /proc/net (Chapter 27). See Example 27-4.

    netstat -r is equivalent to route.

    bash$ netstat
    Active Internet connections (w/o servers)
     Proto Recv-Q Send-Q Local Address           Foreign Address         State      
     Active UNIX domain sockets (w/o servers)
     Proto RefCnt Flags       Type       State         I-Node Path
     unix  11     [ ]         DGRAM                    906    /dev/log
     unix  3      [ ]         STREAM     CONNECTED     4514   /tmp/.X11-unix/X0
     unix  3      [ ]         STREAM     CONNECTED     4513
     . . .

			12.11.3.46 Show open sockets
    Note	A netstat -lptu shows sockets that are listening to ports, and the associated processes. This can be useful for determining whether a computer has been hacked or compromised.
			12.11.3.47 uptime

    Shows how long the system has been running, along with associated statistics.

    bash$ uptime
    10:28pm  up  1:57,  3 users,  load average: 0.17, 0.34, 0.27

    Note	A load average of 1 or less indicates that the system handles processes immediately. A load average greater than 1 means that processes are being queued. When the load average gets above 3, then system performance is significantly degraded.
			12.11.3.48 hostname

    Lists the system's host name. This command sets the host name in an /etc/rc.d setup script (/etc/rc.d/rc.sysinit or similar). It is equivalent to uname -n, and a counterpart to the $HOSTNAME internal variable.

    bash$ hostname
    localhost.localdomain

    bash$ echo $HOSTNAME
    localhost.localdomain

    Similar to the hostname command are the domainname, dnsdomainname, nisdomainname, and ypdomainname commands. Use these to display or set the system DNS or NIS/YP domain name. Various options to hostname also perform these functions.
			12.11.3.49 hostid

    Echo a 32-bit hexadecimal numerical identifier for the host machine.

    bash$ hostid
    |7f0100

    Note	This command allegedly fetches a "unique" serial number for a particular system. Certain product registration procedures use this number to brand a particular user license. Unfortunately, hostid only returns the machine network address in hexadecimal, with pairs of bytes transposed.

    The network address of a typical non-networked Linux machine, is found in /etc/hosts.

    bash$ cat /etc/hosts
    |127.0.0.1               localhost.localdomain localhost

    As it happens, transposing the bytes of 127.0.0.1, we get 0.127.1.0, which translates in hex to 007f0100, the exact equivalent of what hostid returns, above. There exist only a few million other Linux machines with this identical hostid.
			12.11.3.50 sar

    Invoking sar (System Activity Reporter) gives a very detailed rundown on system statistics. The Santa Cruz Operation ("Old" SCO) released sar as Open Source in June, 1999.

    This command is not part of the base Linux distribution, but may be obtained as part of the sysstat utilities package, written by Sebastien Godard.

    bash$ sar
    Linux 2.4.9 (brooks.seringas.fr) 	09/26/03

    10:30:00          CPU     %user     %nice   %system   %iowait     %idle
    10:40:00          all      2.21     10.90     65.48      0.00     21.41
    10:50:00          all      3.36      0.00     72.36      0.00     24.28
    11:00:00          all      1.12      0.00     80.77      0.00     18.11
    Average:          all      2.23      3.63     72.87      0.00     21.27

    14:32:30          LINUX RESTART

    15:00:00          CPU     %user     %nice   %system   %iowait     %idle
    15:10:00          all      8.59      2.40     17.47      0.00     71.54
    15:20:00          all      4.07      1.00     11.95      0.00     82.98
    15:30:00          all      0.79      2.94      7.56      0.00     88.71
    Average:          all      6.33      1.70     14.71      0.00     77.26
               

			12.11.3.51 readelf

    Show information and statistics about a designated elf binary. This is part of the binutils package.

    bash$ readelf -h /bin/bash
    ELF Header:
       Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
       Class:                             ELF32
       Data:                              2's complement, little endian
       Version:                           1 (current)
       OS/ABI:                            UNIX - System V
       ABI Version:                       0
       Type:                              EXEC (Executable file)
       . . .

			12.11.3.52 size

    The size [/path/to/binary] command gives the segment sizes of a binary executable or archive file. This is mainly of use to programmers.

    bash$ size /bin/bash
       text    data     bss     dec     hex filename
      495971   22496   17392  535859   82d33 /bin/bash
    	      

System Logs

			12.11.3.53 logger

    Appends a user-generated message to the system log (/var/log/messages). You do not have to be root to invoke logger.

    logger Experiencing instability in network connection at 23:10, 05/21.
    # Now, do a 'tail /var/log/messages'.

    By embedding a logger command in a script, it is possible to write debugging information to /var/log/messages.

    logger -t $0 -i Logging at line "$LINENO".
    # The "-t" option specifies the tag for the logger entry.
    # The "-i" option records the process ID.

    # tail /var/log/message
    # ...
    # Jul  7 20:48:58 localhost ./test.sh[1712]: Logging at line 3.

    Example: logger -p user.debug  -t yosi_msg "test aaa"
			12.11.3.54 logrotate

    This utility manages the system log files, rotating, compressing, deleting, and/or e-mailing them, as appropriate. This keeps the /var/log from getting cluttered with old log files. Usually cron runs logrotate on a daily basis.

    Adding an appropriate entry to /etc/logrotate.conf makes it possible to manage personal log files, as well as system-wide ones.

    Note	Stefano Falsetto has created rottlog, which he considers to be an improved version of logrotate.

Job Control

			12.11.3.55 ps

    Process Statistics: lists currently executing processes by owner and PID (process ID). This is usually invoked with ax or aux options, and may be piped to grep or sed to search for a specific process (see Example 14-13 and Example 27-3).

    bash$  ps ax | grep sendmail
    |295 ?	   S	  0:00 sendmail: accepting connections on port 25

			12.11.3.56 To display system processes in graphical "tree" format: ps afjx or ps ax --forest.
			12.11.3.57 pgrep, pkill

    Combining the ps command with grep or kill.

    bash$ ps a | grep mingetty
    2212 tty2     Ss+    0:00 /sbin/mingetty tty2
     2213 tty3     Ss+    0:00 /sbin/mingetty tty3
     2214 tty4     Ss+    0:00 /sbin/mingetty tty4
     2215 tty5     Ss+    0:00 /sbin/mingetty tty5
     2216 tty6     Ss+    0:00 /sbin/mingetty tty6
     4849 pts/2    S+     0:00 grep mingetty


    bash$ pgrep mingetty
    2212 mingetty
     2213 mingetty
     2214 mingetty
     2215 mingetty
     2216 mingetty
    	      

    Compare the action of pkill with killall.
			12.11.3.58 pstree

    Lists currently executing processes in "tree" format. The -p option shows the PIDs, as well as the process names.
			12.11.3.59 top

    Continuously updated display of most cpu-intensive processes. The -b option displays in text mode, so that the output may be parsed or accessed from a script.

    bash$ top -b
      8:30pm  up 3 min,  3 users,  load average: 0.49, 0.32, 0.13
     45 processes: 44 sleeping, 1 running, 0 zombie, 0 stopped
     CPU states: 13.6% user,  7.3% system,  0.0% nice, 78.9% idle
     Mem:    78396K av,   65468K used,   12928K free,       0K shrd,    2352K buff
     Swap:  157208K av,       0K used,  157208K free                   37244K cached

       PID USER     PRI  NI  SIZE  RSS SHARE STAT %CPU %MEM   TIME COMMAND
       848 bozo      17   0   996  996   800 R     5.6  1.2   0:00 top
         1 root       8   0   512  512   444 S     0.0  0.6   0:04 init
         2 root       9   0     0    0     0 SW    0.0  0.0   0:00 keventd
       ...  
    	      

			12.11.3.60 nice

    Run a background job with an altered priority. Priorities run from 19 (lowest) to -20 (highest). Only root may set the negative (higher) priorities. Related commands are renice and snice, which change the priority of a running process or processes, and skill, which sends a kill signal to a process or processes.
nohup

    Keeps a command running even after user logs off. The command will run as a foreground process unless followed by &. If you use nohup within a script, consider coupling it with a wait to avoid creating an orphan or zombie process.
			12.11.3.61 pidof

    Identifies process ID (PID) of a running job. Since job control commands, such as kill and renice act on the PID of a process (not its name), it is sometimes necessary to identify that PID. The pidof command is the approximate counterpart to the $PPID internal variable.

    bash$ pidof xclock
    880
    	      

			12.11.3.62 Example 16-6. pidof helps kill a process

    #!/bin/bash
    # kill-process.sh

    NOPROCESS=2

    process=xxxyyyzzz  # Use nonexistent process.
    # For demo purposes only...
    # ... don't want to actually kill any actual process with this script.
    #
    # If, for example, you wanted to use this script to logoff the Internet,
    #     process=pppd

    t=`pidof $process`       # Find pid (process id) of $process.
    # The pid is needed by 'kill' (can't 'kill' by program name).

    if [ -z "$t" ]           # If process not present, 'pidof' returns null.
    then
      echo "Process $process was not running."
      echo "Nothing killed."
      exit $NOPROCESS
    fi  

    kill $t                  # May need 'kill -9' for stubborn process.

    # Need a check here to see if process allowed itself to be killed.
    # Perhaps another " t=`pidof $process` " or ...


    # This entire script could be replaced by
    #        kill $(pidof -x process_name)
    # or
    #        killall process_name
    # but it would not be as instructive.

    exit 0

			12.11.3.63 fuser

    Identifies the processes (by PID) that are accessing a given file, set of files, or directory. May also be invoked with the -k option, which kills those processes. This has interesting implications for system security, especially in scripts preventing unauthorized users from accessing system services.

    bash$ fuser -u /usr/bin/vim
    /usr/bin/vim:         3207e(bozo)



    bash$ fuser -u /dev/null
    /dev/null:            3009(bozo)  3010(bozo)  3197(bozo)  3199(bozo)
    	      

    One important application for fuser is when physically inserting or removing storage media, such as CD ROM disks or USB flash drives. Sometimes trying a umount fails with a device is busy error message. This means that some user(s) and/or process(es) are accessing the device. An fuser -um /dev/device_name will clear up the mystery, so you can kill any relevant processes.

    bash$ umount /mnt/usbdrive
    umount: /mnt/usbdrive: device is busy



    bash$ fuser -um /dev/usbdrive
    /mnt/usbdrive:        1772c(bozo)

    bash$ kill -9 1772
    bash$ umount /mnt/usbdrive
    	      

    The fuser command, invoked with the -n option identifies the processes accessing a port. This is especially useful in combination with nmap.

    root# nmap localhost.localdomain
    PORT     STATE SERVICE
     25/tcp   open  smtp



    root# fuser -un tcp 25
    25/tcp:               2095(root)

    root# ps ax | grep 2095 | grep -v grep
    2095 ?        Ss     0:00 sendmail: accepting connections
    	      

			12.11.3.64 cron

    Administrative program scheduler, performing such duties as cleaning up and deleting system log files and updating the slocate database. This is the superuser version of at (although each user may have their own crontab file which can be changed with the crontab command). It runs as a daemon and executes scheduled entries from /etc/crontab.

    Note	Some flavors of Linux run crond, Matthew Dillon's version of cron.

Process Control and Booting

			12.11.3.65 init

    The init command is the parent of all processes. Called in the final step of a bootup, init determines the runlevel of the system from /etc/inittab. Invoked by its alias telinit, and by root only.
telinit

    Symlinked to init, this is a means of changing the system runlevel, usually done for system maintenance or emergency filesystem repairs. Invoked only by root. This command can be dangerous -- be certain you understand it well before using!
runlevel

    Shows the current and last runlevel, that is, whether the system is halted (runlevel 0), in single-user mode (1), in multi-user mode (2 or 3), in X Windows (5), or rebooting (6). This command accesses the /var/run/utmp file.
halt, shutdown, reboot

    Command set to shut the system down, usually just prior to a power down.
			12.11.3.66 service

    Starts or stops a system service. The startup scripts in /etc/init.d and /etc/rc.d use this command to start services at bootup.

    root# /sbin/service iptables stop
    Flushing firewall rules:                                   [  OK  ]
     Setting chains to policy ACCEPT: filter                    [  OK  ]
     Unloading iptables modules:                                [  OK  ]
    	      

Network

			12.11.3.67 ifconfig

    Network interface configuration and tuning utility.

    bash$ ifconfig -a
    lo        Link encap:Local Loopback
               inet addr:127.0.0.1  Mask:255.0.0.0
               UP LOOPBACK RUNNING  MTU:16436  Metric:1
               RX packets:10 errors:0 dropped:0 overruns:0 frame:0
               TX packets:10 errors:0 dropped:0 overruns:0 carrier:0
               collisions:0 txqueuelen:0 
               RX bytes:700 (700.0 b)  TX bytes:700 (700.0 b)

    The ifconfig command is most often used at bootup to set up the interfaces, or to shut them down when rebooting.

    # Code snippets from /etc/rc.d/init.d/network

    # ...

    # Check that networking is up.
    [ ${NETWORKING} = "no" ] && exit 0

    [ -x /sbin/ifconfig ] || exit 0

    # ...

    for i in $interfaces ; do
      if ifconfig $i 2>/dev/null | grep -q "UP" >/dev/null 2>&1 ; then
        action "Shutting down interface $i: " ./ifdown $i boot
      fi
    #  The GNU-specific "-q" option to "grep" means "quiet", i.e.,
    #+ producing no output.
    #  Redirecting output to /dev/null is therefore not strictly necessary.
           
    # ...

    echo "Currently active devices:"
    echo `/sbin/ifconfig | grep ^[a-z] | awk '{print $1}'`
    #                            ^^^^^  should be quoted to prevent globbing.
    #  The following also work.
    #    echo $(/sbin/ifconfig | awk '/^[a-z]/ { print $1 })'
    #    echo $(/sbin/ifconfig | sed -e 's/ .*//')
    #  Thanks, S.C., for additional comments.

    See also Example 29-6.
			|12.11.3.68 iwconfig

    This is the command set for configuring a wireless network. It is the wireless equivalent of ifconfig, above.
			|12.11.3.69 ip

    General purpose utility for setting up, changing, and analyzing IP (Internet Protocol) networks and attached devices. This command is part of the iproute2 package.

    bash$ ip link show
    |1: lo: <LOOPBACK,UP> mtu 16436 qdisc noqueue 
         link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
     |2: eth0: <BROADCAST,MULTICAST> mtu 1500 qdisc pfifo_fast qlen 1000
         link/ether 00:d0:59:ce:af:da brd ff:ff:ff:ff:ff:ff
     |3: sit0: <NOARP> mtu 1480 qdisc noop 
         link/sit 0.0.0.0 brd 0.0.0.0


    bash$ ip route list
    |169.254.0.0/16 dev lo  scope link
    	      

    Or, in a script:

    #!/bin/bash
    # Script by Juan Nicolas Ruiz
    # Used with his kind permission.

    # Setting up (and stopping) a GRE tunnel.


    # --- start-tunnel.sh ---

    LOCAL_IP="192.168.1.17"
    REMOTE_IP="10.0.5.33"
    OTHER_IFACE="192.168.0.100"
    REMOTE_NET="192.168.3.0/24"

    /sbin/ip tunnel add netb mode gre remote $REMOTE_IP \
      local $LOCAL_IP ttl 255
    /sbin/ip addr add $OTHER_IFACE dev netb
    /sbin/ip link set netb up
    /sbin/ip route add $REMOTE_NET dev netb

    exit 0  #############################################

    # --- stop-tunnel.sh ---

    REMOTE_NET="192.168.3.0/24"

    /sbin/ip route del $REMOTE_NET dev netb
    /sbin/ip link set netb down
    /sbin/ip tunnel del netb

    exit 0

			12.11.3.68 route

    Show info about or make changes to the kernel routing table.

    bash$ route
    Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
     pm3-67.bozosisp *               255.255.255.255 UH       40 0          0 ppp0
     |127.0.0.0       *               255.0.0.0       U        40 0          0 lo
     default         pm3-67.bozosisp 0.0.0.0         UG       40 0          0 ppp0
    	      

     |127.0.0.1 chkconfig

    Check network and system configuration. This command lists and manages the network and system services started at bootup in the /etc/rc?.d directory.

    Originally a port from IRIX to Red Hat Linux, chkconfig may not be part of the core installation of some Linux flavors.

    bash$ chkconfig --list
    atd             0:off   1:off   2:off   3:on    4:on    5:on    6:off
     rwhod           0:off   1:off   2:off   3:off   4:off   5:off   6:off
     ...
    	      

     |127.0.0.2 tcpdump

    Network packet "sniffer." This is a tool for analyzing and troubleshooting traffic on a network by dumping packet headers that match specified criteria.

    Dump ip packet traffic between hosts bozoville and caduceus:

    bash$ tcpdump ip host bozoville and caduceus
    	      

    Of course, the output of tcpdump can be parsed with certain of the previously discussed text processing utilities.

Filesystem

			12.11.3.69 mount

    Mount a filesystem, usually on an external device, such as a floppy or CDROM. The file /etc/fstab provides a handy listing of available filesystems, partitions, and devices, including options, that may be automatically or manually mounted. The file /etc/mtab shows the currently mounted filesystems and partitions (including the virtual ones, such as /proc).

    mount -a mounts all filesystems and partitions listed in /etc/fstab, except those with a noauto option. At bootup, a startup script in /etc/rc.d (rc.sysinit or something similar) invokes this to get everything mounted.

    mount -t iso9660 /dev/cdrom /mnt/cdrom
    # Mounts CD ROM. ISO 9660 is a standard CD ROM filesystem.
    mount /mnt/cdrom
    # Shortcut, if /mnt/cdrom listed in /etc/fstab

    The versatile mount command can even mount an ordinary file on a block device, and the file will act as if it were a filesystem. Mount accomplishes that by associating the file with a loopback device. One application of this is to mount and examine an ISO9660 filesystem image before burning it onto a CDR. [3]

			12.11.3.70 Example 16-7. Checking a CD image

    # As root...

    mkdir /mnt/cdtest  # Prepare a mount point, if not already there.

    mount -r -t iso9660 -o loop cd-image.iso /mnt/cdtest   # Mount the image.
    #                  "-o loop" option equivalent to "losetup /dev/loop0"
    cd /mnt/cdtest     # Now, check the image.
    ls -alR            # List the files in the directory tree there.
                       # And so forth.

			12.11.3.71 umount

    Unmount a currently mounted filesystem. Before physically removing a previously mounted floppy or CDROM disk, the device must be umounted, else filesystem corruption may result.

    umount /mnt/cdrom
    # You may now press the eject button and safely remove the disk.

    Note	The automount utility, if properly installed, can mount and unmount floppies or CDROM disks as they are accessed or removed. On "multispindle" laptops with swappable floppy and optical drives, this can cause problems, however.
gnome-mount

    The newer Linux distros have deprecated mount and umount. The successor, for command-line mounting of removable storage devices, is gnome-mount. It can take the -d option to mount a device file by its listing in /dev.

    For example, to mount a USB flash drive:

    bash$ gnome-mount -d /dev/sda1
    gnome-mount 0.4


    bash$ df
    . . .
     /dev/sda1                63584     12034     51550  19% /media/disk
     

			12.11.3.72 sync

    Forces an immediate write of all updated data from buffers to hard drive (synchronize drive with buffers). While not strictly necessary, a sync assures the sys admin or user that the data just changed will survive a sudden power failure. In the olden days, a sync; sync (twice, just to make absolutely sure) was a useful precautionary measure before a system reboot.

    At times, you may wish to force an immediate buffer flush, as when securely deleting a file (see Example 15-60) or when the lights begin to flicker.
			12.11.3.73 losetup

    Sets up and configures loopback devices.

    Example 16-8. Creating a filesystem in a file

    SIZE=1000000  # 1 meg

    head -c $SIZE < /dev/zero > file  # Set up file of designated size.
    losetup /dev/loop0 file           # Set it up as loopback device.
    mke2fs /dev/loop0                 # Create filesystem.
    mount -o loop /dev/loop0 /mnt     # Mount it.

    # Thanks, S.C.

			12.11.3.74 mkswap

    Creates a swap partition or file. The swap area must subsequently be enabled with swapon.
			12.11.3.75 swapon, swapoff

    Enable / disable swap partitition or file. These commands usually take effect at bootup and shutdown.
			12.11.3.76 mke2fs

    Create a Linux ext2 filesystem. This command must be invoked as root.

			12.11.3.77 Example 16-9. Adding a new hard drive

    #!/bin/bash

    # Adding a second hard drive to system.
    # Software configuration. Assumes hardware already mounted.
    # From an article by the author of this document.
    # In issue #38 of "Linux Gazette", http://www.linuxgazette.com.

    ROOT_UID=0     # This script must be run as root.
    E_NOTROOT=67   # Non-root exit error.

    if [ "$UID" -ne "$ROOT_UID" ]
    then
      echo "Must be root to run this script."
      exit $E_NOTROOT
    fi  

    # Use with extreme caution!
    # If something goes wrong, you may wipe out your current filesystem.


    NEWDISK=/dev/hdb         # Assumes /dev/hdb vacant. Check!
    MOUNTPOINT=/mnt/newdisk  # Or choose another mount point.


    fdisk $NEWDISK
    mke2fs -cv $NEWDISK1   # Check for bad blocks & verbose output.
    #  Note:    /dev/hdb1, *not* /dev/hdb!
    mkdir $MOUNTPOINT
    chmod 777 $MOUNTPOINT  # Makes new drive accessible to all users.


    # Now, test...
    # mount -t ext2 /dev/hdb1 /mnt/newdisk
    # Try creating a directory.
    # If it works, umount it, and proceed.

    # Final step:
    # Add the following line to /etc/fstab.
    # /dev/hdb1  /mnt/newdisk  ext2  defaults  1 1

    exit

    See also Example 16-8 and Example 28-3.
			12.11.3.78 tune2fs

    Tune ext2 filesystem. May be used to change filesystem parameters, such as maximum mount count. This must be invoked as root.

    Warning	This is an extremely dangerous command. Use it at your own risk, as you may inadvertently destroy your filesystem. 
			12.11.3.79 dumpe2fs

    Dump (list to stdout) very verbose filesystem info. This must be invoked as root.

    root# dumpe2fs /dev/hda7 | grep 'ount count'
    dumpe2fs 1.19, 13-Jul-2000 for EXT2 FS 0.5b, 95/08/09
     Mount count:              6
     Maximum mount count:      20

			12.11.3.80 hdparm

    List or change hard disk parameters. This command must be invoked as root, and it may be dangerous if misused.
			12.11.3.81 fdisk

    Create or change a partition table on a storage device, usually a hard drive. This command must be invoked as root.

    Warning	Use this command with extreme caution. If something goes wrong, you may destroy an existing filesystem.
			12.11.3.82 fsck, e2fsck, debugfs

    Filesystem check, repair, and debug command set.

    fsck: a front end for checking a UNIX filesystem (may invoke other utilities). The actual filesystem type generally defaults to ext2.

    e2fsck: ext2 filesystem checker.

    debugfs: ext2 filesystem debugger. One of the uses of this versatile, but dangerous command is to (attempt to) recover deleted files. For advanced users only!

    Caution	All of these should be invoked as root, and they can damage or destroy a filesystem if misused.
badblocks

    Checks for bad blocks (physical media flaws) on a storage device. This command finds use when formatting a newly installed hard drive or testing the integrity of backup media. [4] As an example, badblocks /dev/fd0 tests a floppy disk.

    The badblocks command may be invoked destructively (overwrite all data) or in non-destructive read-only mode. If root user owns the device to be tested, as is generally the case, then root must invoke this command.
			12.11.3.83 lsusb, usbmodules

    The lsusb command lists all USB (Universal Serial Bus) buses and the devices hooked up to them.

    The usbmodules command outputs information about the driver modules for connected USB devices.

    bash$ lsusb
    Bus 001 Device 001: ID 0000:0000  
     Device Descriptor:
       bLength                18
       bDescriptorType         1
       bcdUSB               1.00
       bDeviceClass            9 Hub
       bDeviceSubClass         0 
       bDeviceProtocol         0 
       bMaxPacketSize0         8
       idVendor           0x0000 
       idProduct          0x0000

       . . .
    	      

			12.11.3.84 lspci

    Lists pci busses present.

    bash$ lspci
    00:00.0 Host bridge: Intel Corporation 82845 845
     (Brookdale) Chipset Host Bridge (rev 04)
     00:01.0 PCI bridge: Intel Corporation 82845 845
     (Brookdale) Chipset AGP Bridge (rev 04)
     00:1d.0 USB Controller: Intel Corporation 82801CA/CAM USB (Hub #1) (rev 02)
     00:1d.1 USB Controller: Intel Corporation 82801CA/CAM USB (Hub #2) (rev 02)
     00:1d.2 USB Controller: Intel Corporation 82801CA/CAM USB (Hub #3) (rev 02)
     00:1e.0 PCI bridge: Intel Corporation 82801 Mobile PCI Bridge (rev 42)

       . . .
    	      

			12.11.3.85 mkbootdisk

    Creates a boot floppy which can be used to bring up the system if, for example, the MBR (master boot record) becomes corrupted. Of special interest is the --iso option, which uses mkisofs to create a bootable ISO9660 filesystem image suitable for burning a bootable CDR.

    The mkbootdisk command is actually a Bash script, written by Erik Troan, in the /sbin directory.
			12.11.3.86 mkisofs

    Creates an ISO9660 filesystem suitable for a CDR image.
			12.11.3.87 chroot

    CHange ROOT directory. Normally commands are fetched from $PATH, relative to /, the default root directory. This changes the root directory to a different one (and also changes the working directory to there). This is useful for security purposes, for instance when the system administrator wishes to restrict certain users, such as those telnetting in, to a secured portion of the filesystem (this is sometimes referred to as confining a guest user to a "chroot jail"). Note that after a chroot, the execution path for system binaries is no longer valid.

    A chroot /opt would cause references to /usr/bin to be translated to /opt/usr/bin. Likewise, chroot /aaa/bbb /bin/ls would redirect future instances of ls to /aaa/bbb as the base directory, rather than / as is normally the case. An alias XX 'chroot /aaa/bbb ls' in a user's ~/.bashrc effectively restricts which portion of the filesystem she may run command "XX" on.

    The chroot command is also handy when running from an emergency boot floppy (chroot to /dev/fd0), or as an option to lilo when recovering from a system crash. Other uses include installation from a different filesystem (an rpm option) or running a readonly filesystem from a CD ROM. Invoke only as root, and use with care.

    Caution	It might be necessary to copy certain system files to a chrooted directory, since the normal $PATH can no longer be relied upon.
			12.11.3.88 lockfile

    This utility is part of the procmail package (www.procmail.org). It creates a lock file, a semaphore [5] file that controls access to a file, device, or resource. The lock file serves as a flag that this particular file, device, or resource is in use by a process (it is "busy"), and this permits only restricted access (or no access) to other processes.

    lockfile /home/bozo/lockfiles/$0.lock
    # Creates a write-protected lockfile prefixed with the name of the script.

    lockfile /home/bozo/lockfiles/${0##*/}.lock
    # A safer version of the above, as pointed out by E. Choroba.

    Lock files are used in such applications as protecting system mail folders from simultaneously being changed by multiple users, indicating that a modem port is being accessed, and showing that an instance of Netscape is using its cache. Scripts may check for the existence of a lock file created by a certain process to check if that process is running. Note that if a script attempts to create a lock file that already exists, the script will likely hang.

    Normally, applications create and check for lock files in the /var/lock directory. [6] A script can test for the presence of a lock file by something like the following.

    appname=xyzip
    # Application "xyzip" created lock file "/var/lock/xyzip.lock".

    if [ -e "/var/lock/$appname.lock" ]
    then   #+ Prevent other programs & scripts
           #  from accessing files/resources used by xyzip.
      ...

			12.11.3.89 flock

    Much less useful than the lockfile command is flock. It sets an "advisory" lock on a file and then executes a command while the lock is on. This is to prevent any other process from setting a lock on that file until completion of the specified command.

    flock $0 cat $0 > lockfile__$0
    #  Set a lock on the script the above line appears in,
    #+ while listing the script to stdout.

    Note	

    Unlike lockfile, flock does not automatically create a lock file.
			12.11.3.90 mknod

    Creates block or character device files (may be necessary when installing new hardware on the system). The MAKEDEV utility has virtually all of the functionality of mknod, and is easier to use.
MAKEDEV

    Utility for creating device files. It must be run as root, and in the /dev directory. It is a sort of advanced version of mknod.
			12.11.3.91 tmpwatch

    Automatically deletes files which have not been accessed within a specified period of time. Usually invoked by cron to remove stale log files.

Backup

			12.11.3.92 dump, restore

    The dump command is an elaborate filesystem backup utility, generally used on larger installations and networks. [7] It reads raw disk partitions and writes a backup file in a binary format. Files to be backed up may be saved to a variety of storage media, including disks and tape drives. The restore command restores backups made with dump.
fdformat

    Perform a low-level format on a floppy disk (/dev/fd0*).

System Resources

			12.11.3.93 ulimit

    Sets an upper limit on use of system resources. Usually invoked with the -f option, which sets a limit on file size (ulimit -f 1000 limits files to 1 meg maximum). The -t option limits the coredump size (ulimit -c 0 eliminates coredumps). Normally, the value of ulimit would be set in /etc/profile and/or ~/.bash_profile (see Appendix G).

    Important	Judicious use of ulimit can protect a system against the dreaded fork bomb.

    #!/bin/bash
    # This script is for illustrative purposes only.
    # Run it at your own peril -- it WILL freeze your system.

    while true  #  Endless loop.
    do
      $0 &      #  This script invokes itself . . .
                #+ forks an infinite number of times . . .
                #+ until the system freezes up because all resources exhausted.
    done        #  This is the notorious "sorcerer's appentice" scenario.

    exit 0      #  Will not exit here, because this script will never terminate.

    A ulimit -Hu XX (where XX is the user process limit) in /etc/profile would abort this script when it exceeded the preset limit. 
			12.11.3.94 quota

    Display user or group disk quotas.
			12.11.3.95 setquota

    Set user or group disk quotas from the command line.
			12.11.3.96 umask

    User file creation permissions mask. Limit the default file attributes for a particular user. All files created by that user take on the attributes specified by umask. The (octal) value passed to umask defines the file permissions disabled. For example, umask 022 ensures that new files will have at most 755 permissions (777 NAND 022). [8] Of course, the user may later change the attributes of particular files with chmod. The usual practice is to set the value of umask in /etc/profile and/or ~/.bash_profile (see Appendix G).

			12.11.3.97 Example 16-10. Using umask to hide an output file from prying eyes

    #!/bin/bash
    # rot13a.sh: Same as "rot13.sh" script, but writes output to "secure" file.

    # Usage: ./rot13a.sh filename
    # or     ./rot13a.sh <filename
    # or     ./rot13a.sh and supply keyboard input (stdin)

    umask 177               #  File creation mask.
                            #  Files created by this script
                            #+ will have 600 permissions.

    OUTFILE=decrypted.txt   #  Results output to file "decrypted.txt"
                            #+ which can only be read/written
                            #  by invoker of script (or root).

    cat "$@" | tr 'a-zA-Z' 'n-za-mN-ZA-M' > $OUTFILE 
    #    ^^ Input from stdin or a file.   ^^^^^^^^^^ Output redirected to file. 

    exit 0

			12.11.3.98 rdev

    Get info about or make changes to root device, swap space, or video mode. The functionality of rdev has generally been taken over by lilo, but rdev remains useful for setting up a ram disk. This is a dangerous command, if misused. 

Modules

			12.11.3.99 lsmod

    List installed kernel modules.

    bash$ lsmod
    Module                  Size  Used by
     autofs                  9456   2 (autoclean)
     opl3                   11376   0
     serial_cs               5456   0 (unused)
     sb                     34752   0
     uart401                 6384   0 [sb]
     sound                  58368   0 [opl3 sb uart401]
     soundlow                 464   0 [sound]
     soundcore               2800   6 [sb sound]
     ds                      6448   2 [serial_cs]
     i82365                 22928   2
     pcmcia_core            45984   0 [serial_cs ds i82365]
    	      

    Note	

    Doing a cat /proc/modules gives the same information.
			12.11.3.100 insmod

    Force installation of a kernel module (use modprobe instead, when possible). Must be invoked as root.
			12.11.3.101 rmmod

    Force unloading of a kernel module. Must be invoked as root.
			12.11.3.102 modprobe

    Module loader that is normally invoked automatically in a startup script. Must be invoked as root.
			12.11.3.103 depmod

    Creates module dependency file. Usually invoked from a startup script.
			12.11.3.104 modinfo

    Output information about a loadable module.

    bash$ modinfo hid
    filename:    /lib/modules/2.4.20-6/kernel/drivers/usb/hid.o
     description: "USB HID support drivers"
     author:      "Andreas Gal, Vojtech Pavlik <vojtech@suse.cz>"
     license:     "GPL"
    	      

Miscellaneous

			12.11.3.105 env

    Runs a program or script with certain environmental variables set or changed (without changing the overall system environment). The [varname=xxx] permits changing the environmental variable varname for the duration of the script. With no options specified, this command lists all the environmental variable settings. [9]

    Note	The first line of a script (the "sha-bang" line) may use env when the path to the shell or interpreter is unknown.

    #! /usr/bin/env perl

    print "This Perl script will run,\n";
    print "even when I don't know where to find Perl.\n";

    # Good for portable cross-platform scripts,
    # where the Perl binaries may not be in the expected place.
    # Thanks, S.C.

    Or even ...

    #!/bin/env bash
    # Queries the $PATH enviromental variable for the location of bash.
    # Therefore ...
    # This script will run where Bash is not in its usual place, in /bin.
    ...

			12.11.3.106 ldd

    Show shared lib dependencies for an executable file.

    bash$ ldd /bin/ls
    libc.so.6 => /lib/libc.so.6 (0x4000c000)
    /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x80000000)

			12.11.3.107 watch, iteration utility, replaces while true do cmd

    Run a command repeatedly, at specified time intervals.

    The default is two-second intervals, but this may be changed with the -n option.

    watch -n 5 tail /var/log/messages
    # Shows tail end of system log, /var/log/messages, every five seconds.

    Note	Unfortunately, piping the output of watch command to grep does not work.
			|12.11.3.108 strip

    Remove the debugging symbolic references from an executable binary. This decreases its size, but makes debugging it impossible.

    This command often occurs in a Makefile, but rarely in a shell script.
			12.11.3.108 nm

    List symbols in an unstripped compiled binary.
			12.11.3.109 rdist

    Remote distribution client: synchronizes, clones, or backs up a file system on a remote server.

		12.11.4 Analyzing a System Script

Using our knowledge of administrative commands, let us examine a system script. One of the shortest and simplest to understand scripts is "killall," [1] used to suspend running processes at system shutdown.

Example 16-11. killall, from /etc/rc.d/init.d

#!/bin/sh

# --> Comments added by the author of this document marked by "# -->".

# --> This is part of the 'rc' script package
# --> by Miquel van Smoorenburg, <miquels@drinkel.nl.mugnet.org>.

# --> This particular script seems to be Red Hat / FC specific
# --> (may not be present in other distributions).

#  Bring down all unneeded services that are still running
#+ (there shouldn't be any, so this is just a sanity check)

for i in /var/lock/subsys/*; do
        # --> Standard for/in loop, but since "do" is on same line,
        # --> it is necessary to add ";".
        # Check if the script is there.
        [ ! -f $i ] && continue
        # --> This is a clever use of an "and list", equivalent to:
        # --> if [ ! -f "$i" ]; then continue

        # Get the subsystem name.
        subsys=${i#/var/lock/subsys/}
        # --> Match variable name, which, in this case, is the file name.
        # --> This is the exact equivalent of subsys=`basename $i`.
	
        # -->  It gets it from the lock file name
        # -->+ (if there is a lock file,
        # -->+ that's proof the process has been running).
        # -->  See the "lockfile" entry, above.


        # Bring the subsystem down.
        if [ -f /etc/rc.d/init.d/$subsys.init ]; then
           /etc/rc.d/init.d/$subsys.init stop
        else
           /etc/rc.d/init.d/$subsys stop
        # -->  Suspend running jobs and daemons.
        # -->  Note that "stop" is a positional parameter,
        # -->+ not a shell builtin.
        fi
done

That wasn't so bad. Aside from a little fancy footwork with variable matching, there is no new material there.

"
	12.12 Part 5. Advanced Topics

		12.12.1 Chapter 17. Regular Expressions

			12.12.1.1 A Brief Introduction to Regular Expressions

An expression is a string of characters. Those characters having an interpretation above and beyond their literal meaning are called metacharacters. A quote symbol, for example, may denote speech by a person, ditto, or a meta-meaning [1] for the symbols that follow. Regular Expressions are sets of characters and/or metacharacters that match (or specify) patterns.

A Regular Expression contains one or more of the following:

    * A character set. These are the characters retaining their literal meaning. The simplest type of Regular Expression consists only of a character set, with no metacharacters.
    * An anchor. These designate (anchor) the position in the line of text that the RE is to match. For example, ^, and $ are anchors.
    * Modifiers. These expand or narrow (modify) the range of text the RE is to match. Modifiers include the asterisk, brackets, and the backslash.

The main uses for Regular Expressions (REs) are text searches and string manipulation. An RE matches a single character or a set of characters -- a string or a part of a string.

    * The asterisk -- * -- matches any number of repeats of the character string or RE preceding it, including zero instances.

      "1133*" matches 11 + one or more 3's: 113, 1133, 1133333, and so forth.
    * The dot -- . -- matches any one character, except a newline. [2]

      "13." matches 13 + at least one of any character (including a space): 1133, 11333, but not 13 (additional character missing).

    * The caret -- ^ -- matches the beginning of a line, but sometimes, depending on context, negates the meaning of a set of characters in an RE.
    * The dollar sign -- $ -- at the end of an RE matches the end of a line.

      "XXX$" matches XXX at the end of a line.

      "^$" matches blank lines.
    * Brackets -- [...] -- enclose a set of characters to match in a single RE.

      "[xyz]" matches the characters x, y, or z.

      "[c-n]" matches any of the characters in the range c to n.

      "[B-Pk-y]" matches any of the characters in the ranges B to P and k to y.

      "[a-z0-9]" matches any lowercase letter or any digit.

      "[^b-d]" matches all characters except those in the range b to d. This is an instance of ^ negating or inverting the meaning of the following RE (taking on a role similar to ! in a different context).

      Combined sequences of bracketed characters match common word patterns. "[Yy][Ee][Ss]" matches yes, Yes, YES, yEs, and so forth. "[0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]" matches any Social Security number.
    * The backslash -- \ -- escapes a special character, which means that character gets interpreted literally.

      A "\$" reverts back to its literal meaning of "$", rather than its RE meaning of end-of-line. Likewise a "\\" has the literal meaning of "\".
    * Escaped "angle brackets" -- \<...\> -- mark word boundaries.

      The angle brackets must be escaped, since otherwise they have only their literal character meaning.

      "\<the\>" matches the word "the," but not the words "them," "there," "other," etc.

      bash$ cat textfile
      This is line 1, of which there is only one instance.
       This is the only instance of line 2.
       This is line 3, another line.
       This is line 4.


      bash$ grep 'the' textfile
      This is line 1, of which there is only one instance.
       This is the only instance of line 2.
       This is line 3, another line.


      bash$ grep '\<the\>' textfile
      This is the only instance of line 2.
      	      

The only way to be certain that a particular RE works is to test it.

TEST FILE: tstfile                          # No match.
                                            # No match.
Run   grep "1133*"  on this file.           # Match.
                                            # No match.
                                            # No match.
This line contains the number 113.          # Match.
This line contains the number 13.           # No match.
This line contains the number 133.          # No match.
This line contains the number 1133.         # Match.
This line contains the number 113312.       # Match.
This line contains the number 1112.         # No match.
This line contains the number 113312312.    # Match.
This line contains no numbers at all.       # No match.

bash$ grep "1133*" tstfile
Run   grep "1133*"  on this file.           # Match.
 This line contains the number 113.          # Match.
 This line contains the number 1133.         # Match.
 This line contains the number 113312.       # Match.
 This line contains the number 113312312.    # Match.
	      

    * Extended REs. Additional metacharacters added to the basic set. Used in egrep, awk, and Perl.
    * The question mark -- ? -- matches zero or one of the previous RE. It is generally used for matching single characters.
    * The plus -- + -- matches one or more of the previous RE. It serves a role similar to the *, but does not match zero occurrences.

      # GNU versions of sed and awk can use "+",
      # but it needs to be escaped.

      echo a111b | sed -ne '/a1\+b/p'
      echo a111b | grep 'a1\+b'
      echo a111b | gawk '/a1+b/'
      # All of above are equivalent.

      # Thanks, S.C.

    * Escaped "curly brackets" -- \{ \} -- indicate the number of occurrences of a preceding RE to match.

      It is necessary to escape the curly brackets since they have only their literal character meaning otherwise. This usage is technically not part of the basic RE set.

      "[0-9]\{5\}" matches exactly five digits (characters in the range of 0 to 9).

      Note	

      Curly brackets are not available as an RE in the "classic" (non-POSIX compliant) version of awk. However, gawk has the --re-interval option that permits them (without being escaped).

      bash$ echo 2222 | gawk --re-interval '/2{3}/'
      |2222
      	      

      Perl and some egrep versions do not require escaping the curly brackets.
    * Parentheses -- ( ) -- enclose a group of REs. They are useful with the following "|" operator and in substring extraction using expr.
    * The -- | -- "or" RE operator matches any of a set of alternate characters.

      bash$ egrep 're(a|e)d' misc.txt
      People who read seem to be better informed than those who do not.
       The clarinet produces sound by the vibration of its reed.
      	      

Note	Some versions of sed, ed, and ex support escaped versions of the extended Regular Expressions described above, as do the GNU utilities.

    * POSIX Character Classes. [:class:]

      This is an alternate method of specifying a range of characters to match.
    * [:alnum:] matches alphabetic or numeric characters. This is equivalent to A-Za-z0-9.
    * [:alpha:] matches alphabetic characters. This is equivalent to A-Za-z.
    * [:blank:] matches a space or a tab.
    * [:cntrl:] matches control characters.
    * [:digit:] matches (decimal) digits. This is equivalent to 0-9.
    * [:graph:] (graphic printable characters). Matches characters in the range of ASCII 33 - 126. This is the same as [:print:], below, but excluding the space character.
    * [:lower:] matches lowercase alphabetic characters. This is equivalent to a-z.
    * [:print:] (printable characters). Matches characters in the range of ASCII 32 - 126. This is the same as [:graph:], above, but adding the space character.
    * [:space:] matches whitespace characters (space and horizontal tab).
    * [:upper:] matches uppercase alphabetic characters. This is equivalent to A-Z.
    * [:xdigit:] matches hexadecimal digits. This is equivalent to 0-9A-Fa-f.

      Important	

      POSIX character classes generally require quoting or double brackets ([[ ]]).

      bash$ grep [[:digit:]] test.file
      abc=723
      	      

      These character classes may even be used with globbing, to a limited extent.

      bash$ ls -l ?[[:digit:]][[:digit:]]?
      -rw-rw-r--    1 bozo  bozo         0 Aug 21 14:47 a33b
      	      

Sed, awk, and Perl, used as filters in scripts, take REs as arguments when "sifting" or transforming files or I/O streams. 

The standard reference on this complex topic is Friedl's Mastering Regular Expressions. Sed & Awk, by Dougherty and Robbins, also gives a very lucid treatment of REs. See the Bibliography for more information on these books.


			12.12.1.2 Globbing

Bash itself cannot recognize Regular Expressions. Inside scripts, it is commands and utilities -- such as sed and awk -- that interpret RE's.

Bash does carry out filename expansion [1] -- a process known as globbing -- but this does not use the standard RE set. Instead, globbing recognizes and expands wild cards. Globbing interprets the standard wild card characters, * and ?, character lists in square brackets, and certain other special characters (such as ^ for negating the sense of a match). There are important limitations on wild card characters in globbing, however. Strings containing * will not match filenames that start with a dot, as, for example, .bashrc. [2] Likewise, the ? has a different meaning in globbing than as part of an RE.

bash$ ls -l
total 2
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 a.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1
 -rw-rw-r--    1 bozo  bozo       466 Aug  6 17:48 t2.sh
 -rw-rw-r--    1 bozo  bozo       758 Jul 30 09:02 test1.txt

bash$ ls -l t?.sh
-rw-rw-r--    1 bozo  bozo       466 Aug  6 17:48 t2.sh

bash$ ls -l [ab]*
-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 a.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1

bash$ ls -l [a-c]*
-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 a.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1

bash$ ls -l [^ab]*
-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1
 -rw-rw-r--    1 bozo  bozo       466 Aug  6 17:48 t2.sh
 -rw-rw-r--    1 bozo  bozo       758 Jul 30 09:02 test1.txt

bash$ ls -l {b*,c*,*est*}
-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1
 -rw-rw-r--    1 bozo  bozo       758 Jul 30 09:02 test1.txt
	      

Bash performs filename expansion on unquoted command-line arguments. The echo command demonstrates this.

bash$ echo *
a.1 b.1 c.1 t2.sh test1.txt

bash$ echo t*
t2.sh test1.txt
	      

Note	It is possible to modify the way Bash interprets special characters in globbing. A set -f command disables globbing, and the nocaseglob and nullglob options to shopt change globbing behavior.


		12.12.2 Chapter 18. Here Documents
Here and now, boys.

--Aldous Huxley, Island

A here document is a special-purpose code block. It uses a form of I/O redirection to feed a command list to an interactive program or a command, such as ftp, cat, or the ex text editor.

COMMAND <<InputComesFromHERE
...
InputComesFromHERE

A limit string delineates (frames) the command list. The special symbol << designates the limit string. This has the effect of redirecting the output of a file into the stdin of the program or command. It is similar to interactive-program < command-file, where command-file contains

command #1
command #2
...

The here document alternative looks like this:

#!/bin/bash
interactive-program <<LimitString
command #1
command #2
...
LimitString

Choose a limit string sufficiently unusual that it will not occur anywhere in the command list and confuse matters.

Note that here documents may sometimes be used to good effect with non-interactive utilities and commands, such as, for example, wall.

Example 18-1. broadcast: Sends message to everyone logged in

#!/bin/bash

wall <<zzz23EndOfMessagezzz23
E-mail your noontime orders for pizza to the system administrator.
    (Add an extra dollar for anchovy or mushroom topping.)
# Additional message text goes here.
# Note: 'wall' prints comment lines.
zzz23EndOfMessagezzz23

# Could have been done more efficiently by
#         wall <message-file
#  However, embedding the message template in a script
#+ is a quick-and-dirty one-off solution.

exit 0

Even such unlikely candidates as the vi text editor lend themselves to here documents.

			12.12.2.1 Example 18-2. dummyfile: Creates a 2-line dummy file

#!/bin/bash

# Non-interactive use of 'vi' to edit a file.
# Emulates 'sed'.

E_BADARGS=65

if [ -z "$1" ]
then
  echo "Usage: `basename $0` filename"
  exit $E_BADARGS
fi

TARGETFILE=$1

# Insert 2 lines in file, then save.
#--------Begin here document-----------#
vi $TARGETFILE <<x23LimitStringx23
i
This is line 1 of the example file.
This is line 2 of the example file.
^[
ZZ
x23LimitStringx23
#----------End here document-----------#

#  Note that ^[ above is a literal escape
#+ typed by Control-V <Esc>.

#  Bram Moolenaar points out that this may not work with 'vim',
#+ because of possible problems with terminal interaction.

exit 0

Note, my tests confirm it doesn't work with VIM

[Yosi note, see some more examples with cat and ed:
[yizaq@yizaq-lnx:Thu Aug 28:~]$ cat<<aaa
> sdkalskd
> ksldkslk
> aaaa
> bbb
> aaa
sdkalskd
ksldkslk
aaaa
bbb
[yizaq@yizaq-lnx:Thu Aug 28:~]$ ed<<aaa
> a
> jjjj
> wwww
> aaaaaa
> .
> w stam
> q
> aaa
|17
[yizaq@yizaq-lnx:Thu Aug 28:~]$ cat stam
jjjj
wwww
aaaaaa
]

The above script could just as effectively have been implemented with ex, rather than vi. Here documents containing a list of ex commands are common enough to form their own category, known as ex scripts.

			12.12.2.2 Examples of ex scripts that use here documents
#!/bin/bash
#  Replace all instances of "Smith" with "Jones"
#+ in files with a ".txt" filename suffix. 

ORIGINAL=Smith
REPLACEMENT=Jones

for word in $(fgrep -l $ORIGINAL *.txt)
do
  # -------------------------------------
  ex $word <<EOF
  :%s/$ORIGINAL/$REPLACEMENT/g
  :wq
EOF
  # :%s is the "ex" substitution command.
  # :wq is write-and-quit.
  # -------------------------------------
done

			12.12.2.3 Analogous to "ex scripts" are cat scripts.

Example 18-3. Multi-line message using cat

#!/bin/bash

#  'echo' is fine for printing single line messages,
#+  but somewhat problematic for for message blocks.
#   A 'cat' here document overcomes this limitation.

cat <<End-of-message
-------------------------------------
This is line 1 of the message.
This is line 2 of the message.
This is line 3 of the message.
This is line 4 of the message.
This is the last line of the message.
-------------------------------------
End-of-message

#  Replacing line 7, above, with
#+   cat > $Newfile <<End-of-message
#+       ^^^^^^^^^^
#+ writes the output to the file $Newfile, rather than to stdout.

exit 0


#--------------------------------------------
# Code below disabled, due to "exit 0" above.

# S.C. points out that the following also works.
echo "-------------------------------------
This is line 1 of the message.
This is line 2 of the message.
This is line 3 of the message.
This is line 4 of the message.
This is the last line of the message.
-------------------------------------"
# However, text may not include double quotes unless they are escaped.

The - option to mark a here document limit string (<<-LimitString) suppresses leading tabs (but not spaces) in the output. This may be useful in making a script more readable.

			12.12.2.4 Example 18-4. Multi-line message, with tabs suppressed

#!/bin/bash
# Same as previous example, but...

#  The - option to a here document <<-
#+ suppresses leading tabs in the body of the document,
#+ but *not* spaces.

cat <<-ENDOFMESSAGE
	This is line 1 of the message.
	This is line 2 of the message.
	This is line 3 of the message.
	This is line 4 of the message.
	This is the last line of the message.
ENDOFMESSAGE
# The output of the script will be flush left.
# Leading tab in each line will not show.

# Above 5 lines of "message" prefaced by a tab, not spaces.
# Spaces not affected by   <<-  .

# Note that this option has no effect on *embedded* tabs.

exit 0

A here document supports parameter and command substitution. It is therefore possible to pass different parameters to the body of the here document, changing its output accordingly.

			12.12.2.5 Example 18-5. Here document with parameter substitution

#!/bin/bash
# Another 'cat' here document, using parameter substitution.

# Try it with no command line parameters,   ./scriptname
# Try it with one command line parameter,   ./scriptname Mortimer
# Try it with one two-word quoted command line parameter,
#                           ./scriptname "Mortimer Jones"

CMDLINEPARAM=1     #  Expect at least command line parameter.

if [ $# -ge $CMDLINEPARAM ]
then
  NAME=$1          #  If more than one command line param,
                   #+ then just take the first.
else
  NAME="John Doe"  #  Default, if no command line parameter.
fi  

RESPONDENT="the author of this fine script"  
  

cat <<Endofmessage

Hello, there, $NAME.
Greetings to you, $NAME, from $RESPONDENT.

# This comment shows up in the output (why?).

Endofmessage

# Note that the blank lines show up in the output.
# So does the "comment".

exit 0

This is a useful script containing a here document with parameter substitution.

			12.12.2.6 Example 18-6. Upload a file pair to Sunsite incoming directory

#!/bin/bash
# upload.sh

#  Upload file pair (Filename.lsm, Filename.tar.gz)
#+ to incoming directory at Sunsite/UNC (ibiblio.org).
#  Filename.tar.gz is the tarball itself.
#  Filename.lsm is the descriptor file.
#  Sunsite requires "lsm" file, otherwise will bounce contributions.


E_ARGERROR=65

if [ -z "$1" ]
then
  echo "Usage: `basename $0` Filename-to-upload"
  exit $E_ARGERROR
fi  


Filename=`basename $1`           # Strips pathname out of file name.

Server="ibiblio.org"
Directory="/incoming/Linux"
#  These need not be hard-coded into script,
#+ but may instead be changed to command line argument.

Password="your.e-mail.address"   # Change above to suit.

ftp -n $Server <<End-Of-Session
# -n option disables auto-logon

user anonymous "$Password"
binary
bell                             # Ring 'bell' after each file transfer.
cd $Directory
put "$Filename.lsm"
put "$Filename.tar.gz"
bye
End-Of-Session

exit 0

Quoting or escaping the "limit string" at the head of a here document disables parameter substitution within its body.

			12.12.2.7 Example 18-7. Parameter substitution turned off

#!/bin/bash
#  A 'cat' here-document, but with parameter substitution disabled.

NAME="John Doe"
RESPONDENT="the author of this fine script"  

cat <<'Endofmessage'

Hello, there, $NAME.
Greetings to you, $NAME, from $RESPONDENT.

Endofmessage

#   No parameter substitution when the "limit string" is quoted or escaped.
#   Either of the following at the head of the here document would have
#+  the same effect.
#   cat <<"Endofmessage"
#   cat <<\Endofmessage

exit 0

Disabling parameter substitution permits outputting literal text. Generating scripts or even program code is one use for this.

			12.12.2.8 Example 18-8. A script that generates another script

#!/bin/bash
# generate-script.sh
# Based on an idea by Albert Reiner.

OUTFILE=generated.sh         # Name of the file to generate.


# -----------------------------------------------------------
# 'Here document containing the body of the generated script.
(
cat <<'EOF'
#!/bin/bash

echo "This is a generated shell script."
#  Note that since we are inside a subshell,
#+ we can't access variables in the "outside" script.

echo "Generated file will be named: $OUTFILE"
#  Above line will not work as normally expected
#+ because parameter expansion has been disabled.
#  Instead, the result is literal output.

a=7
b=3

let "c = $a * $b"
echo "c = $c"

exit 0
EOF
) > $OUTFILE
# -----------------------------------------------------------

#  Quoting the 'limit string' prevents variable expansion
#+ within the body of the above 'here document.'
#  This permits outputting literal strings in the output file.

if [ -f "$OUTFILE" ]
then
  chmod 755 $OUTFILE
  # Make the generated file executable.
else
  echo "Problem in creating file: \"$OUTFILE\""
fi

#  This method can also be used for generating
#+ C programs, Perl programs, Python programs, Makefiles,
#+ and the like.

exit 0

It is possible to set a variable from the output of a here document. This is actually a devious form of command substitution.

variable=$(cat <<SETVAR
This variable
runs over multiple lines.
SETVAR)

echo "$variable"

A here document can supply input to a function in the same script.

			12.12.2.9 Example 18-9. Here documents and functions

#!/bin/bash
# here-function.sh

GetPersonalData ()
{
  read firstname
  read lastname
  read address
  read city 
  read state 
  read zipcode
} # This certainly looks like an interactive function, but...


# Supply input to the above function.
GetPersonalData <<RECORD001
Bozo
Bozeman
|2726 Nondescript Dr.
Baltimore
MD
|21226
RECORD001


echo
echo "$firstname $lastname"
echo "$address"
echo "$city, $state $zipcode"
echo

exit 0

It is possible to use : as a dummy command accepting output from a here document. This, in effect, creates an "anonymous" here document.

			12.12.2.10 Example 18-10. "Anonymous" Here Document

#!/bin/bash

: <<TESTVARIABLES
${HOSTNAME?}${USER?}${MAIL?}  # Print error message if one of the variables not set.
TESTVARIABLES

exit 0

Tip	A variation of the above technique permits "commenting out" blocks of code.

			12.12.2.11 Example 18-11. Commenting out a block of code

#!/bin/bash
# commentblock.sh

: <<COMMENTBLOCK
echo "This line will not echo."
This is a comment line missing the "#" prefix.
This is another comment line missing the "#" prefix.

&*@!!++=
The above line will cause no error message,
because the Bash interpreter will ignore it.
COMMENTBLOCK

echo "Exit value of above \"COMMENTBLOCK\" is $?."   # 0
# No error shown.
echo


#  The above technique also comes in useful for commenting out
#+ a block of working code for debugging purposes.
#  This saves having to put a "#" at the beginning of each line,
#+ then having to go back and delete each "#" later.

echo "Just before commented-out code block."
#  The lines of code between the double-dashed lines will not execute.
#  ===================================================================
: <<DEBUGXXX
for file in *
do
 cat "$file"
done
DEBUGXXX
#  ===================================================================
echo "Just after commented-out code block."

exit 0



######################################################################
#  Note, however, that if a bracketed variable is contained within
#+ the commented-out code block,
#+ then this could cause problems.
#  for example:


#/!/bin/bash

  : <<COMMENTBLOCK
  echo "This line will not echo."
  &*@!!++=
  ${foo_bar_bazz?}
  $(rm -rf /tmp/foobar/)
  $(touch my_build_directory/cups/Makefile)
COMMENTBLOCK


$ sh commented-bad.sh
commented-bad.sh: line 3: foo_bar_bazz: parameter null or not set

# The remedy for this is to strong-quote the 'COMMENTBLOCK' in line 49, above.

  : <<'COMMENTBLOCK'

# Thank you, Kurt Pfeifle, for pointing this out.

Tip	Yet another twist of this nifty trick makes "self-documenting" scripts possible.

			12.12.2.12 Example 18-12. A self-documenting script

#!/bin/bash
# self-document.sh: self-documenting script
# Modification of "colm.sh".

DOC_REQUEST=70

if [ "$1" = "-h"  -o "$1" = "--help" ]     # Request help.
then
  echo; echo "Usage: $0 [directory-name]"; echo
  sed --silent -e '/DOCUMENTATIONXX$/,/^DOCUMENTATIONXX$/p' "$0" |
  sed -e '/DOCUMENTATIONXX$/d'; exit $DOC_REQUEST; fi


: <<DOCUMENTATIONXX
List the statistics of a specified directory in tabular format.
---------------------------------------------------------------
The command line parameter gives the directory to be listed.
If no directory specified or directory specified cannot be read,
then list the current working directory.

DOCUMENTATIONXX

if [ -z "$1" -o ! -r "$1" ]
then
  directory=.
else
  directory="$1"
fi  

echo "Listing of "$directory":"; echo
(printf "PERMISSIONS LINKS OWNER GROUP SIZE MONTH DAY HH:MM PROG-NAME\n" \
; ls -l "$directory" | sed 1d) | column -t

exit 0

Using a cat script is an alternate way of accomplishing this.

DOC_REQUEST=70

if [ "$1" = "-h"  -o "$1" = "--help" ]     # Request help.
then                                       # Use a "cat script" . . .
  cat <<DOCUMENTATIONXX
List the statistics of a specified directory in tabular format.
---------------------------------------------------------------
The command line parameter gives the directory to be listed.
If no directory specified or directory specified cannot be read,
then list the current working directory.

DOCUMENTATIONXX
exit $DOC_REQUEST
fi


Note	Here documents create temporary files, but these files are deleted after opening and are not accessible to any other process.

bash$ bash -c 'lsof -a -p $$ -d0' << EOF
> EOF
lsof    1213 bozo    0r   REG    3,5    0 30386 /tmp/t1213-0-sh (deleted)
	      

Caution	Some utilities will not work inside a here document.

Warning	The closing limit string, on the final line of a here document, must start in the first character position. There can be no leading whitespace. Trailing whitespace after the limit string likewise causes unexpected behavior. The whitespace prevents the limit string from being recognized.

#!/bin/bash

echo "----------------------------------------------------------------------"

cat <<LimitString
echo "This is line 1 of the message inside the here document."
echo "This is line 2 of the message inside the here document."
echo "This is the final line of the message inside the here document."
     LimitString
#^^^^Indented limit string. Error! This script will not behave as expected.

echo "----------------------------------------------------------------------"

#  These comments are outside the 'here document',
#+ and should not echo.

echo "Outside the here document."

exit 0

echo "This line had better not echo."  # Follows an 'exit' command.

For those tasks too complex for a "here document", consider using the expect scripting language, which was specifically designed for feeding input into interactive programs.


			12.12.2.13 Here Strings

A here string can be considered as a stripped-down form of a here document. It consists of nothing more than COMMAND <<<$WORD, where $WORD is expanded and fed to the stdin of COMMAND.

As a simple example, consider this alternative to the echo-grep construction.

# Instead of:
if echo "$VAR" | grep -q txt   # if [[ $VAR = *txt* ]]
# etc.

# Try:
if grep -q "txt" <<< "$VAR"
then   #         ^^^
   echo "$VAR contains the substring sequence \"txt\""
fi
# Thank you, Sebastian Kaminski, for the suggestion.

Or, in combination with read:

String="This is a string of words."

read -r -a Words <<< "$String"
#  The -a option to "read"
#+ assigns the resulting values to successive members of an array.

echo "First word in String is:    ${Words[0]}"   # This
echo "Second word in String is:   ${Words[1]}"   # is
echo "Third word in String is:    ${Words[2]}"   # a
echo "Fourth word in String is:   ${Words[3]}"   # string
echo "Fifth word in String is:    ${Words[4]}"   # of
echo "Sixth word in String is:    ${Words[5]}"   # words.
echo "Seventh word in String is:  ${Words[6]}"   # (null)
                                                 # Past end of $String.

# Thank you, Francisco Lobo, for the suggestion.

				12.12.2.13.1 Example 18-13. Prepending a line to a file

#!/bin/bash
# prepend.sh: Add text at beginning of file.
#
#  Example contributed by Kenny Stauffer,
#+ and slightly modified by document author.


E_NOSUCHFILE=65

read -p "File: " file   # -p arg to 'read' displays prompt.
if [ ! -e "$file" ]
then   # Bail out if no such file.
  echo "File $file not found."
  exit $E_NOSUCHFILE
fi

read -p "Title: " title
cat - $file <<<$title > $file.new

echo "Modified file is $file.new"

exit 0

# from 'man bash':
# Here Strings
# 	A variant of here documents, the format is:
# 
# 		<<<word
# 
# 	The word is expanded and supplied to the command on its standard input.

				12.12.2.13.2 Example 18-14. Parsing a mailbox

#!/bin/bash
#  Script by Francisco Lobo,
#+ and slightly modified and commented by ABS Guide author.
#  Used in ABS Guide with permission. (Thank you!)

# This script will not run under Bash versions < 3.0.


E_MISSING_ARG=67
if [ -z "$1" ]
then
  echo "Usage: $0 mailbox-file"
  exit $E_MISSING_ARG
fi

mbox_grep()  # Parse mailbox file.
{
    declare -i body=0 match=0
    declare -a date sender
    declare mail header value


    while IFS= read -r mail
#         ^^^^                 Reset $IFS.
#  Otherwise "read" will strip leading & trailing space from its input.

   do
       if [[ $mail =~ "^From " ]]   # Match "From" field in message.
       then
          (( body  = 0 ))           # "Zero out" variables.
          (( match = 0 ))
          unset date

       elif (( body ))
       then
            (( match ))
            # echo "$mail"
            # Uncomment above line if you want entire body of message to display.

       elif [[ $mail ]]; then
          IFS=: read -r header value <<< "$mail"
          #                          ^^^  "here string"

          case "$header" in
          [Ff][Rr][Oo][Mm] ) [[ $value =~ "$2" ]] && (( match++ )) ;;
          # Match "From" line.
          [Dd][Aa][Tt][Ee] ) read -r -a date <<< "$value" ;;
          #                                  ^^^
          # Match "Date" line.
          [Rr][Ee][Cc][Ee][Ii][Vv][Ee][Dd] ) read -r -a sender <<< "$value" ;;
          #                                                    ^^^
          # Match IP Address (may be spoofed).
          esac

       else
          (( body++ ))
          (( match  )) &&
          echo "MESSAGE ${date:+of: ${date[*]} }"
       #    Entire $date array             ^
          echo "IP address of sender: ${sender[1]}"
       #    Second field of "Received" line    ^

       fi


    done < "$1" # Redirect stdout of file into loop.
}


mbox_grep "$1"  # Send mailbox file to function.

exit $?

# Exercises:
# ---------
# 1) Break the single function, above, into multiple functions,
#+   for the sake of readability.
# 2) Add additional parsing to the script, checking for various keywords.



$ mailbox_grep.sh scam_mail
  MESSAGE of Thu, 5 Jan 2006 08:00:56 -0500 (EST) 
  IP address of sender: 196.3.62.4



		12.12.3 Chapter 19. I/O Redirection
There are always three default "files"  open, stdin (the keyboard), stdout (the screen), and stderr (error messages output to the screen). These, and any other open files, can be redirected. Redirection simply means capturing output from a file, command, program, script, or even code block within a script and sending it as input to another file, command, program, or script.

Each open file gets assigned a file descriptor. [1] The file descriptors for stdin, stdout, and stderr are 0, 1, and 2, respectively. For opening additional files, there remain descriptors 3 to 9. It is sometimes useful to assign one of these additional file descriptors to stdin, stdout, or stderr as a temporary duplicate link. [2] This simplifies restoration to normal after complex redirection and reshuffling (see Example 19-1).

   COMMAND_OUTPUT >
      # Redirect stdout to a file.
      # Creates the file if not present, otherwise overwrites it.

      ls -lR > dir-tree.list
      # Creates a file containing a listing of the directory tree.

   : > filename
      # The > truncates file "filename" to zero length.
      # If file not present, creates zero-length file (same effect as 'touch').
      # The : serves as a dummy placeholder, producing no output.

   > filename    
      # The > truncates file "filename" to zero length.
      # If file not present, creates zero-length file (same effect as 'touch').
      # (Same result as ": >", above, but this does not work with some shells.)

   COMMAND_OUTPUT >>
      # Redirect stdout to a file.
      # Creates the file if not present, otherwise appends to it.


      # Single-line redirection commands (affect only the line they are on):
      # --------------------------------------------------------------------

|   1>filename
      # Redirect stdout to file "filename."
Example:
[yizaq@yytzhak-wxp:Tue Sep 02:/cygdrive/c/work/KB/bash/examples/advanced:]$ 1>stam  echo aaa bbb
[yizaq@yytzhak-wxp:Tue Sep 02:/cygdrive/c/work/KB/bash/examples/advanced:]$ cat stam
aaa bbb
[yizaq@yytzhak-wxp:Tue Sep 02:/cygdrive/c/work/KB/bash/examples/advanced:]$

|   1>>filename
      # Redirect and append stdout to file "filename."
|   2>filename
      # Redirect stderr to file "filename."
|   2>>filename
      # Redirect and append stderr to file "filename."
   &>filename
      # Redirect both stdout and stderr to file "filename."
      #
      #  Note that   &>>filename
      #+ -- attempting to redirect and *append*
      #+ stdout and stderr to file "filename" --
      #+ fails with the error message,
      #+ syntax error near unexpected token `>'.
#Note that for this to work (append both stdout and stderr to file you'll need:
#  COMMAND > stam 2>&1

   M>N
     # "M" is a file descriptor, which defaults to 1, if not explicitly set.
     # "N" is a filename.
     # File descriptor "M" is redirect to file "N."
   M>&N
     # "M" is a file descriptor, which defaults to 1, if not set.
     # "N" is another file descriptor.

      #==============================================================================

      # Redirecting stdout, one line at a time.
      LOGFILE=script.log

      echo "This statement is sent to the log file, \"$LOGFILE\"." 1>$LOGFILE
      echo "This statement is appended to \"$LOGFILE\"." 1>>$LOGFILE
      echo "This statement is also appended to \"$LOGFILE\"." 1>>$LOGFILE
      echo "This statement is echoed to stdout, and will not appear in \"$LOGFILE\"."
      # These redirection commands automatically "reset" after each line.



      # Redirecting stderr, one line at a time.
      ERRORFILE=script.errors

      bad_command1 2>$ERRORFILE       #  Error message sent to $ERRORFILE.
      bad_command2 2>>$ERRORFILE      #  Error message appended to $ERRORFILE.
      bad_command3                    #  Error message echoed to stderr,
                                      #+ and does not appear in $ERRORFILE.
      # These redirection commands also automatically "reset" after each line.
      #=======================================================================

|   2>&1
      # Redirects stderr to stdout.
      # Error messages get sent to same place as standard output.

   i>&j
      # Redirects file descriptor i to j.
      # All output of file pointed to by i gets sent to file pointed to by j.

   >&j
      # Redirects, by default, file descriptor 1 (stdout) to j.
      # All stdout gets sent to file pointed to by j.

|   0< FILENAME
    < FILENAME
      # Accept input from a file.
      # Companion command to ">", and often used in combination with it.
      #
      # grep search-word <filename


   [j]<>filename
      #  Open file "filename" for reading and writing,
      #+ and assign file descriptor "j" to it.
      #  If "filename" does not exist, create it.
      #  If file descriptor "j" is not specified, default to fd 0, stdin.
      #
      #  An application of this is writing at a specified place in a file. 
      echo 1234567890 > File    # Write string to "File".
      exec 3<> File             # Open "File" and assign fd 3 to it.
      read -n 4 <&3             # Read only 4 characters.
      echo -n . >&3             # Write a decimal point there.
      exec 3>&-                 # Close fd 3.
      cat File                  # ==> 1234.67890
      #  Random access, by golly.



   |
      # Pipe.
      # General purpose process and command chaining tool.
      # Similar to ">", but more general in effect.
      # Useful for chaining commands, scripts, files, and programs together.
      cat *.txt | sort | uniq > result-file
      # Sorts the output of all the .txt files and deletes duplicate lines,
      # finally saves results to "result-file".

Multiple instances of input and output redirection and/or pipes can be combined in a single command line.

command < input-file > output-file

command1 | command2 | command3 > output-file


Multiple output streams may be redirected to one file.

ls -yz >> command.log 2>&1
#  Capture result of illegal options "yz" in file "command.log."
#  Because stderr is redirected to the file,
#+ any error messages will also be there.

#  Note, however, that the following does *not* give the same result.
ls -yz 2>&1 >> command.log
#  Outputs an error message and does not write to file.

#  If redirecting both stdout and stderr,
#+ the order of the commands makes a difference.

Closing File Descriptors n<&-

    Close input file descriptor n.  0<&-, <&-

    Close stdin.  n>&-

    Close output file descriptor n.  1>&-, >&-

    Close stdout.

Child processes inherit open file descriptors. This is why pipes work. To prevent an fd from being inherited, close it.

# Redirecting only stderr to a pipe.

exec 3>&1                              # Save current "value" of stdout.
ls -l 2>&1 >&3 3>&- | grep bad 3>&-    # Close fd 3 for 'grep' (but not 'ls').
#              ^^^^   ^^^^
exec 3>&-                              # Now close it for the remainder of the script.

# Thanks, S.C.

			12.12.3.1 Using exec
An exec <filename command redirects stdin to a file. From that point on, all stdin comes from that file, rather than its normal source (usually keyboard input). This provides a method of reading a file line by line and possibly parsing each line of input using sed  and/or awk.

				12.12.3.1.1 Example 19-1 Redirecting stdin using exec

#!/bin/bash
# Redirecting stdin using 'exec'.


exec 6<&0          # Link file descriptor #6 with stdin.
                   # Saves stdin.

exec < data-file   # stdin replaced by file "data-file"

read a1            # Reads first line of file "data-file".
read a2            # Reads second line of file "data-file."

echo
echo "Following lines read from file."
echo "-------------------------------"
echo $a1
echo $a2

echo; echo; echo

exec 0<&6 6<&-
#  Now restore stdin from fd #6, where it had been saved,
#+ and close fd #6 ( 6<&- ) to free it for other processes to use.
#
# <&6 6<&-    also works.

echo -n "Enter data  "
read b1  # Now "read" functions as expected, reading from normal stdin.
echo "Input read from stdin."
echo "----------------------"
echo "b1 = $b1"

echo

exit 0

Similarly, an exec >filename command redirects stdout to a designated file. This sends all command output that would normally go to stdout to that file.

Important	

exec N > filename affects the entire script or current shell. Redirection in the PID of the script or shell from that point on has changed. However . . .

N > filename affects only the newly-forked process, not the entire script or shell.

Thank you, Ahmed Darwish, for pointing this out.

				12.12.3.1.2 Example 19-2. Redirecting stdout using exec

#!/bin/bash
# reassign-stdout.sh

LOGFILE=logfile.txt

exec 6>&1           # Link file descriptor #6 with stdout.
                    # Saves stdout.

exec > $LOGFILE     # stdout replaced with file "logfile.txt".

# ----------------------------------------------------------- #
# All output from commands in this block sent to file $LOGFILE.

echo -n "Logfile: "
date
echo "-------------------------------------"
echo

echo "Output of \"ls -al\" command"
echo
ls -al
echo; echo
echo "Output of \"df\" command"
echo
df

# ----------------------------------------------------------- #

exec 1>&6 6>&-      # Restore stdout and close file descriptor #6.

echo
echo "== stdout now restored to default == "
echo
ls -al
echo

exit 0

				12.12.3.1.3 Example 19-3. Redirecting both stdin and stdout in the same script with exec

#!/bin/bash
# upperconv.sh
# Converts a specified input file to uppercase.

E_FILE_ACCESS=70
E_WRONG_ARGS=71

if [ ! -r "$1" ]     # Is specified input file readable?
then
  echo "Can't read from input file!"
  echo "Usage: $0 input-file output-file"
  exit $E_FILE_ACCESS
fi                   #  Will exit with same error
                     #+ even if input file ($1) not specified (why?).

if [ -z "$2" ]
then
  echo "Need to specify output file."
  echo "Usage: $0 input-file output-file"
  exit $E_WRONG_ARGS
fi


exec 4<&0
exec < $1            # Will read from input file.

exec 7>&1
exec > $2            # Will write to output file.
                     # Assumes output file writable (add check?).

# -----------------------------------------------
    cat - | tr a-z A-Z   # Uppercase conversion.
#   ^^^^^                # Reads from stdin.
#           ^^^^^^^^^^   # Writes to stdout.
# However, both stdin and stdout were redirected.
# Note that the 'cat' can be omitted.
# -----------------------------------------------

exec 1>&7 7>&-       # Restore stout.
exec 0<&4 4<&-       # Restore stdin.

# After restoration, the following line prints to stdout as expected.
echo "File \"$1\" written to \"$2\" as uppercase conversion."

exit 0

I/O redirection is a clever way of avoiding the dreaded inaccessible variables within a subshell problem.

				12.12.3.1.4 Example 19-4. Avoiding a subshell

#!/bin/bash
# avoid-subshell.sh
# Suggested by Matthew Walker.

Lines=0

echo

cat myfile.txt | while read line;
                 do {
                   echo $line
                   (( Lines++ ));  #  Incremented values of this variable
                                   #+ inaccessible outside loop.
                                   #  Subshell problem.
                 }
                 done

echo "Number of lines read = $Lines"     # 0
                                         # Wrong!

echo "------------------------"


exec 3<> myfile.txt
while read line <&3
do {
  echo "$line"
  (( Lines++ ));                   #  Incremented values of this variable
                                   #+ accessible outside loop.
                                   #  No subshell, no problem.
}
done
exec 3>&-

echo "Number of lines read = $Lines"     # 8

echo

exit 0

# Lines below not seen by script.

$ cat myfile.txt

Line 1.
Line 2.
Line 3.
Line 4.
Line 5.
Line 6.
Line 7.
Line 8.
			12.12.3.2 Redirecting Code Blocks
Blocks of code, such as while, until, and for loops, even if/then test blocks can also incorporate redirection of stdin. Even a function may use this form of redirection (see Example 23-11). The < operator at the end of the code block accomplishes this.

				12.12.3.2.1 Example 19-5. Redirected while loop

#!/bin/bash
# redir2.sh

if [ -z "$1" ]
then
  Filename=names.data       # Default, if no filename specified.
else
  Filename=$1
fi  
#+ Filename=${1:-names.data}
#  can replace the above test (parameter substitution).

count=0

echo

while [ "$name" != Smith ]  # Why is variable $name in quotes?
do
  read name                 # Reads from $Filename, rather than stdin.
  echo $name
  let "count += 1"
done <"$Filename"           # Redirects stdin to file $Filename. 
#    ^^^^^^^^^^^^

echo; echo "$count names read"; echo

exit 0

#  Note that in some older shell scripting languages,
#+ the redirected loop would run as a subshell.
#  Therefore, $count would return 0, the initialized value outside the loop.
#  Bash and ksh avoid starting a subshell *whenever possible*,
#+ so that this script, for example, runs correctly.
#  (Thanks to Heiner Steven for pointing this out.)

#  However . . .
#  Bash *can* sometimes start a subshell in a PIPED "while-read" loop,
#+ as distinct from a REDIRECTED "while" loop.

abc=hi
echo -e "1\n2\n3" | while read l
     do abc="$l"
        echo $abc
     done
echo $abc

#  Thanks, Bruno de Oliveira Schneider, for demonstrating this
#+ with the above snippet of code.
#  And, thanks, Brian Onn, for correcting an annotation error.

				12.12.3.2.2 Example 19-6. Alternate form of redirected while loop

#!/bin/bash

# This is an alternate form of the preceding script.

#  Suggested by Heiner Steven
#+ as a workaround in those situations when a redirect loop
#+ runs as a subshell, and therefore variables inside the loop
# +do not keep their values upon loop termination.


if [ -z "$1" ]
then
  Filename=names.data     # Default, if no filename specified.
else
  Filename=$1
fi  


exec 3<&0                 # Save stdin to file descriptor 3.
exec 0<"$Filename"        # Redirect standard input.

count=0
echo


while [ "$name" != Smith ]
do
  read name               # Reads from redirected stdin ($Filename).
  echo $name
  let "count += 1"
done                      #  Loop reads from file $Filename
                          #+ because of line 20.

#  The original version of this script terminated the "while" loop with
#+      done <"$Filename" 
#  Exercise:
#  Why is this unnecessary?


exec 0<&3                 # Restore old stdin.
exec 3<&-                 # Close temporary fd 3.

echo; echo "$count names read"; echo

exit 0

				12.12.3.2.3 Example 19-7. Redirected until loop

#!/bin/bash
# Same as previous example, but with "until" loop.

if [ -z "$1" ]
then
  Filename=names.data         # Default, if no filename specified.
else
  Filename=$1
fi  

# while [ "$name" != Smith ]
until [ "$name" = Smith ]     # Change  !=  to =.
do
  read name                   # Reads from $Filename, rather than stdin.
  echo $name
done <"$Filename"             # Redirects stdin to file $Filename. 
#    ^^^^^^^^^^^^

# Same results as with "while" loop in previous example.

exit 0

				12.12.3.2.4 Example 19-8. Redirected for loop

#!/bin/bash

if [ -z "$1" ]
then
  Filename=names.data          # Default, if no filename specified.
else
  Filename=$1
fi  

line_count=`wc $Filename | awk '{ print $1 }'`
#           Number of lines in target file.
#
#  Very contrived and kludgy, nevertheless shows that
#+ it's possible to redirect stdin within a "for" loop...
#+ if you're clever enough.
#
# More concise is     line_count=$(wc -l < "$Filename")


for name in `seq $line_count`  # Recall that "seq" prints sequence of numbers.
# while [ "$name" != Smith ]   --   more complicated than a "while" loop   --
do
  read name                    # Reads from $Filename, rather than stdin.
  echo $name
  if [ "$name" = Smith ]       # Need all this extra baggage here.
  then
    break
  fi  
done <"$Filename"              # Redirects stdin to file $Filename. 
#    ^^^^^^^^^^^^

exit 0

We can modify the previous example to also redirect the output of the loop.

				12.12.3.2.5 Example 19-9. Redirected for loop (both stdin and stdout redirected)

#!/bin/bash

if [ -z "$1" ]
then
  Filename=names.data          # Default, if no filename specified.
else
  Filename=$1
fi  

Savefile=$Filename.new         # Filename to save results in.
FinalName=Jonah                # Name to terminate "read" on.

line_count=`wc $Filename | awk '{ print $1 }'`  # Number of lines in target file.


for name in `seq $line_count`
do
  read name
  echo "$name"
  if [ "$name" = "$FinalName" ]
  then
    break
  fi  
done < "$Filename" > "$Savefile"     # Redirects stdin to file $Filename,
#    ^^^^^^^^^^^^^^^^^^^^^^^^^^^       and saves it to backup file.

exit 0

				12.12.3.2.6 Example 19-10. Redirected if/then test

#!/bin/bash

if [ -z "$1" ]
then
  Filename=names.data   # Default, if no filename specified.
else
  Filename=$1
fi  

TRUE=1

if [ "$TRUE" ]          # if true    and   if :   also work.
then
 read name
 echo $name
fi <"$Filename"
#  ^^^^^^^^^^^^

# Reads only first line of file.
# An "if/then" test has no way of iterating unless embedded in a loop.

exit 0

Example 19-11. Data file names.data for above examples

Aristotle
Belisarius
Capablanca
Euler
Goethe
Hamurabi
Jonah
Laplace
Maroczy
Purcell
Schmidt
Semmelweiss
Smith
Turing
Venn
Wilkinson
Znosko-Borowski

#  This is a data file for
#+ "redir2.sh", "redir3.sh", "redir4.sh", "redir4a.sh", "redir5.sh".

Redirecting the stdout of a code block has the effect of saving its output to a file. See Example 3-2.

				12.12.3.2.7 Here documents and IO redirection
Here documents are a special case of redirected code blocks. That being the case, it should be possible to feed the output of a here document into the stdin for a while loop.

# This example by Albert Siersema
# Used with permission (thanks!).

function doesOutput()
 # Could be an external command too, of course.
 # Here we show you can use a function as well.
{
  ls -al *.jpg | awk '{print $5,$9}'
}


nr=0          #  We want the while loop to be able to manipulate these and
totalSize=0   #+ to be able to see the changes after the while finished.

while read fileSize fileName ; do
  echo "$fileName is $fileSize bytes"
  let nr++
  totalSize=$((totalSize+fileSize))   # Or: "let totalSize+=fileSize"
done<<EOF
$(doesOutput)
EOF

echo "$nr files totaling $totalSize bytes"


			12.12.3.3 Applications
Clever use of I/O redirection permits parsing and stitching together snippets of command output (see Example 14-7). This permits generating report and log files.

Example 19-12. Logging events

#!/bin/bash
# logevents.sh
# Author: Stephane Chazelas.
# Used in ABS Guide with permission.

# Event logging to a file.
# Must be run as root (for write access in /var/log).

ROOT_UID=0     # Only users with $UID 0 have root privileges.
E_NOTROOT=67   # Non-root exit error.


if [ "$UID" -ne "$ROOT_UID" ]
then
  echo "Must be root to run this script."
  exit $E_NOTROOT
fi  


FD_DEBUG1=3
FD_DEBUG2=4
FD_DEBUG3=5

# === Uncomment one of the two lines below to activate script. ===
# LOG_EVENTS=1
# LOG_VARS=1


log()  # Writes time and date to log file.
{
echo "$(date)  $*" >&7     # This *appends* the date to the file.
#     ^^^^^^^  command substitution
                           # See below.
}



case $LOG_LEVEL in
 1) exec 3>&2         4> /dev/null 5> /dev/null;;
 2) exec 3>&2         4>&2         5> /dev/null;;
 3) exec 3>&2         4>&2         5>&2;;
 *) exec 3> /dev/null 4> /dev/null 5> /dev/null;;
esac

FD_LOGVARS=6
if [[ $LOG_VARS ]]
then exec 6>> /var/log/vars.log
else exec 6> /dev/null                     # Bury output.
fi

FD_LOGEVENTS=7
if [[ $LOG_EVENTS ]]
then
  # exec 7 >(exec gawk '{print strftime(), $0}' >> /var/log/event.log)
  # Above line fails in versions of Bash more recent than 2.04. Why?
  exec 7>> /var/log/event.log              # Append to "event.log".
  log                                      # Write time and date.
else exec 7> /dev/null                     # Bury output.
fi

echo "DEBUG3: beginning" >&${FD_DEBUG3}

ls -l >&5 2>&4                             # command1 >&5 2>&4

echo "Done"                                # command2 

echo "sending mail" >&${FD_LOGEVENTS}
# Writes "sending mail" to file descriptor #7.


exit 0


		12.12.4 Chapter 20. Subshells

Running a shell script launches a new process, a subshell.

Definition: A subshell is a process launched by a shell (or shell script).

A subshell is a separate instance of the command processor -- the shell that gives you the prompt at the console or in an xterm window. Just as your commands are interpreted at the command line prompt, similarly does a script batch-process a list of commands. Each shell script running is, in effect, a subprocess (child process) of the parent shell.

A shell script can itself launch subprocesses. These subshells let the script do parallel processing, in effect executing multiple subtasks simultaneously.

#!/bin/bash
# subshell-test.sh

(
# Inside parentheses, and therefore a subshell . . .
while [ 1 ]   # Endless loop.
do
  echo "Subshell running . . ."
done
)

#  Script will run forever,
#+ or at least until terminated by a Ctl-C.

exit $?  # End of script (but will never get here).



Now, run the script:
sh subshell-test.sh

And, while the script is running, from a different xterm:
ps -ef | grep subshell-test.sh

UID       PID   PPID  C STIME TTY      TIME     CMD
500       2698  2502  0 14:26 pts/4    00:00:00 sh subshell-test.sh
500       2699  2698 21 14:26 pts/4    00:00:24 sh subshell-test.sh

          ^^^^

Analysis:
PID 2698, the script, launched PID 2699, the subshell.

Note: The "UID ..." line would be filtered out by the "grep" command,
but is shown here for illustrative purposes.

In general, an external command in a script forks off a subprocess, [1] whereas a Bash builtin does not. For this reason, builtins execute more quickly than their external command equivalents.

Command List within Parentheses

( command1; command2; command3; ... )

    A command list embedded between parentheses runs as a subshell.

Variables in a subshell are not visible outside the block of code in the subshell. They are not accessible to the parent process, to the shell that launched the subshell. These are, in effect, variables local to the child process.

			12.12.4.1 Example 20-1. Variable scope in a subshell

#!/bin/bash
# subshell.sh

echo

echo "We are outside the subshell."
echo "Subshell level OUTSIDE subshell = $BASH_SUBSHELL"
# Bash, version 3, adds the new         $BASH_SUBSHELL variable.
echo; echo

outer_variable=Outer
global_variable=
#  Define global variable for "storage" of
#+ value of subshell variable.

(
echo "We are inside the subshell."
echo "Subshell level INSIDE subshell = $BASH_SUBSHELL"
inner_variable=Inner

echo "From inside subshell, \"inner_variable\" = $inner_variable"
echo "From inside subshell, \"outer\" = $outer_variable"

global_variable="$inner_variable"   #  Will this allow "exporting"
                                    #+ a subshell variable?
)

echo; echo
echo "We are outside the subshell."
echo "Subshell level OUTSIDE subshell = $BASH_SUBSHELL"
echo

if [ -z "$inner_variable" ]
then
  echo "inner_variable undefined in main body of shell"
else
  echo "inner_variable defined in main body of shell"
fi

echo "From main body of shell, \"inner_variable\" = $inner_variable"
#  $inner_variable will show as blank (uninitialized)
#+ because variables defined in a subshell are "local variables".
#  Is there a remedy for this?
echo "global_variable = "$global_variable""  # Why doesn't this work?

echo

# =======================================================================

# Additionally ...

echo "-----------------"; echo

var=41                                                 # Global variable.

( let "var+=1"; echo "\$var INSIDE subshell = $var" )  # 42

echo "\$var OUTSIDE subshell = $var"                   # 41
#  Variable operations inside a subshell, even to a GLOBAL variable
#+ do not affect the value of the variable outside the subshell!


exit 0

#  Question:
#  --------
#  Once having exited a subshell,
#+ is there any way to reenter that very same subshell
#+ to modify or access the subshell variables?


Definition: The scope of a variable is the context in which it has meaning, in which it has a value that can be referenced. For example, the scope of a local variable lies only within the function, block of code, or subshell within which it is defined.

Note	While the $BASH_SUBSHELL internal variable indicates the nesting level of a subshell, the $SHLVL variable shows no change within a subshell.

echo " \$BASH_SUBSHELL outside subshell       = $BASH_SUBSHELL"           # 0
  ( echo " \$BASH_SUBSHELL inside subshell        = $BASH_SUBSHELL" )     # 1
  ( ( echo " \$BASH_SUBSHELL inside nested subshell = $BASH_SUBSHELL" ) ) # 2
# ^ ^                           *** nested ***                        ^ ^

echo

echo " \$SHLVL outside subshell = $SHLVL"       # 3
( echo " \$SHLVL inside subshell  = $SHLVL" )   # 3 (No change!)

Directory changes made in a subshell do not carry over to the parent shell.

			12.12.4.2 Example 20-2. List User Profiles

#!/bin/bash
# allprofs.sh: Print all user profiles.

# This script written by Heiner Steven, and modified by the document author.

FILE=.bashrc  #  File containing user profile,
              #+ was ".profile" in original script.

for home in `awk -F: '{print $6}' /etc/passwd`
do
  [ -d "$home" ] || continue    # If no home directory, go to next.
  [ -r "$home" ] || continue    # If not readable, go to next.
  (cd $home; [ -e $FILE ] && less $FILE)
done

#  When script terminates, there is no need to 'cd' back to original directory,
#+ because 'cd $home' takes place in a subshell.

exit 0

			12.12.4.3 A subshell may be used to set up a "dedicated environment" for a command group.

COMMAND1
COMMAND2
COMMAND3
(
  IFS=:
  PATH=/bin
  unset TERMINFO
  set -C
  shift 5
  COMMAND4
  COMMAND5
  exit 3 # Only exits the subshell!
)
# The parent shell has not been affected, and the environment is preserved.
COMMAND6
COMMAND7

As seen here, the exit command only terminates the subshell in which it is running, not the parent shell or script.

			12.12.4.4 One application of such a "dedicated environment" is testing whether a variable is defined.

if (set -u; : $variable) 2> /dev/null
then
  echo "Variable is set."
fi     #  Variable has been set in current script,
       #+ or is an an internal Bash variable,
       #+ or is present in environment (has been exported).

# Could also be written [[ ${variable-x} != x || ${variable-y} != y ]]
# or                    [[ ${variable-x} != x$variable ]]
# or                    [[ ${variable+x} = x ]]
# or                    [[ ${variable-x} != x ]]

			12.12.4.5 Another application is checking for a lock file:

if (set -C; : > lock_file) 2> /dev/null
then
  :   # lock_file didn't exist: no user running the script
else
  echo "Another user is already running that script."
exit 65
fi

#  Code snippet by Stphane Chazelas,
#+ with modifications by Paulo Marcel Coelho Aragao.

+

Processes may execute in parallel within different subshells. This permits breaking a complex task into subcomponents processed concurrently.

			12.12.4.6 Example 20-3. Running parallel processes in subshells

	(cat list1 list2 list3 | sort | uniq > list123) &
	(cat list4 list5 list6 | sort | uniq > list456) &
	# Merges and sorts both sets of lists simultaneously.
	# Running in background ensures parallel execution.
	#
	# Same effect as
	#   cat list1 list2 list3 | sort | uniq > list123 &
	#   cat list4 list5 list6 | sort | uniq > list456 &
	
	wait   # Don't execute the next command until subshells finish.
	
	diff list123 list456

Redirecting I/O to a subshell uses the "|" pipe operator, as in ls -al | (command).

Note	A command block between curly braces does not launch a subshell.

{ command1; command2; command3; . . . commandN; }

		12.12.5 Chapter 21. Restricted Shells
Disabled commands in restricted shells

    . Running a script or portion of a script in restricted mode disables certain commands that would otherwise be available. This is a security measure intended to limit the privileges of the script user and to minimize possible damage from running the script.

The following commands and actions are disabled:

    * Using cd to change the working directory.
    * Changing the values of the $PATH, $SHELL, $BASH_ENV, or $ENV environmental variables.
    * Reading or changing the $SHELLOPTS, shell environmental options.
    * Output redirection.
    * Invoking commands containing one or more /'s.
    * Invoking exec to substitute a different process for the shell.
    * Various other commands that would enable monkeying with or attempting to subvert the script for an unintended purpose.
    * Getting out of restricted mode within the script.

			12.12.5.1 Example 21-1. Running a script in restricted mode

#!/bin/bash

#  Starting the script with "#!/bin/bash -r"
#+ runs entire script in restricted mode.

echo

echo "Changing directory."
cd /usr/local
echo "Now in `pwd`"
echo "Coming back home."
cd
echo "Now in `pwd`"
echo

# Everything up to here in normal, unrestricted mode.

set -r
# set --restricted    has same effect.
echo "==> Now in restricted mode. <=="

echo
echo

echo "Attempting directory change in restricted mode."
cd ..
echo "Still in `pwd`"

echo
echo

echo "\$SHELL = $SHELL"
echo "Attempting to change shell in restricted mode."
SHELL="/bin/ash"
echo
echo "\$SHELL= $SHELL"

echo
echo

echo "Attempting to redirect output in restricted mode."
ls -l /usr/bin > bin.files
ls -l bin.files    # Try to list attempted file creation effort.

echo

exit 0

		12.12.6 Chapter 22. Process Substitution
Piping the stdout  of a command into the stdin of another is a powerful technique. But, what if you need to pipe the stdout of multiple  commands? This is where process substitution comes in.

Process substitution feeds the output of a process (or processes) into the stdin of another process.

Template

Command list enclosed within parentheses

    >(command_list)

    <(command_list)

    Process substitution uses /dev/fd/<n> files to send the results of the process(es) within parentheses to another process. 

Notes
This has the same effect as a named pipe (temp file), and, in fact, named pipes were at one time used in process substitution.


Caution	There is no space between the the "<" or ">" and the parentheses. Space there would give an error message.

bash$ echo >(true)
/dev/fd/63

bash$ echo <(true)
/dev/fd/63
	      

Bash creates a pipe with two file descriptors, --fIn and fOut--. The stdin of true connects to fOut (dup2(fOut, 0)), then Bash passes a /dev/fd/fIn argument to echo. On systems lacking /dev/fd/<n> files, Bash may use temporary files. (Thanks, S.C.)

Process substitution can compare the output of two different commands, or even the output of different options to the same command.

bash$ comm <(ls -l) <(ls -al)
total 12
-rw-rw-r--    1 bozo bozo       78 Mar 10 12:58 File0
-rw-rw-r--    1 bozo bozo       42 Mar 10 12:58 File2
-rw-rw-r--    1 bozo bozo      103 Mar 10 12:58 t2.sh
        total 20
        drwxrwxrwx    2 bozo bozo     4096 Mar 10 18:10 .
        drwx------   72 bozo bozo     4096 Mar 10 17:58 ..
        -rw-rw-r--    1 bozo bozo       78 Mar 10 12:58 File0
        -rw-rw-r--    1 bozo bozo       42 Mar 10 12:58 File2
        -rw-rw-r--    1 bozo bozo      103 Mar 10 12:58 t2.sh

Using process substitution to compare the contents of two directories (to see which filenames are in one, but not the other):

diff <(ls $first_directory) <(ls $second_directory)

Some other usages and uses of process substitution:

read -a list < <( od -Ad -w24 -t u2 /dev/urandom )
#  Read a list of random numbers from /dev/urandom,
#+ process with "od"
#+ and feed into stdin of "read" . . .

#  From "insertion-sort.bash" example script.
#  Courtesy of JuanJo Ciarlante.

cat <(ls -l)
# Same as     ls -l | cat

sort -k 9 <(ls -l /bin) <(ls -l /usr/bin) <(ls -l /usr/X11R6/bin)
# Lists all the files in the 3 main 'bin' directories, and sorts by filename.
# Note that three (count 'em) distinct commands are fed to 'sort'.

 
diff <(command1) <(command2)    # Gives difference in command output.

tar cf >(bzip2 -c > file.tar.bz2) $directory_name
# Calls "tar cf /dev/fd/?? $directory_name", and "bzip2 -c > file.tar.bz2".
#
# Because of the /dev/fd/<n> system feature,
# the pipe between both commands does not need to be named.
#
# This can be emulated.
#
bzip2 -c < pipe > file.tar.bz2&
tar cf pipe $directory_name
rm pipe
#        or
exec 3>&1
tar cf /dev/fd/4 $directory_name 4>&1 >&3 3>&- | bzip2 -c > file.tar.bz2 3>&-
exec 3>&-


# Thanks, Stphane Chazelas

A reader sent in the following interesting example of process substitution.

# Script fragment taken from SuSE distribution:

# --------------------------------------------------------------#
while read  des what mask iface; do
# Some commands ...
done < <(route -n)  
#    ^ ^  First < is redirection, second is process substitution.

# To test it, let's make it do something.
while read  des what mask iface; do
  echo $des $what $mask $iface
done < <(route -n)  

# Output:
# Kernel IP routing table
# Destination Gateway Genmask Flags Metric Ref Use Iface
# 127.0.0.0 0.0.0.0 255.0.0.0 U 0 0 0 lo
# --------------------------------------------------------------#

#  As Stphane Chazelas points out,
#+ an easier-to-understand equivalent is:
route -n |
  while read des what mask iface; do   # Variables set from output of pipe.
    echo $des $what $mask $iface
  done  #  This yields the same output as above.
        #  However, as Ulrich Gayer points out . . .
        #+ this simplified equivalent uses a subshell for the while loop,
        #+ and therefore the variables disappear when the pipe terminates.
	
# --------------------------------------------------------------#
	
#  However, Filip Moritz comments that there is a subtle difference
#+ between the above two examples, as the following shows.

(
route -n | while read x; do ((y++)); done
echo $y # $y is still unset

while read x; do ((y++)); done < <(route -n)
echo $y # $y has the number of lines of output of route -n
)

More generally spoken
(
: | x=x
# seems to start a subshell like
: | ( x=x )
# while
x=x < <(:)
# does not
)

# This is useful, when parsing csv and the like.
# That is, in effect, what the original SuSE code fragment does.

		12.12.7 Chapter 23. Functions
Like "real" programming languages, Bash has functions, though in a somewhat limited implementation. A function is a subroutine, a code block that implements a set of operations, a "black box" that performs a specified task. Wherever there is repetitive code, when a task repeats with only slight variations in procedure, then consider using a function.

function function_name {
command...
}
or

function_name () {
command...
}

This second form will cheer the hearts of C programmers (and is more portable).

As in C, the function's opening bracket may optionally appear on the second line.

function_name ()
{
command...
}

Note	A function may be "compacted" into a single line.

fun () { echo "This is a function"; echo; }
#                                 ^     ^

In this case, however, a semicolon must follow the final command in the function.

fun () { echo "This is a function"; echo } # Error!
#                                       ^

Functions are called, triggered, simply by invoking their names. A function call is equivalent to a command.

			12.12.7.1 Example 23-1. Simple functions

#!/bin/bash

JUST_A_SECOND=1

funky ()
{ # This is about as simple as functions get.
  echo "This is a funky function."
  echo "Now exiting funky function."
} # Function declaration must precede call.


fun ()
{ # A somewhat more complex function.
  i=0
  REPEATS=30

  echo
  echo "And now the fun really begins."
  echo

  sleep $JUST_A_SECOND    # Hey, wait a second!
  while [ $i -lt $REPEATS ]
  do
    echo "----------FUNCTIONS---------->"
    echo "<------------ARE-------------"
    echo "<------------FUN------------>"
    echo
    let "i+=1"
  done
}

  # Now, call the functions.

funky
fun

exit 0

			12.12.7.2 The function definition must precede the first call to it
			There is no method of "declaring" the function, as, for example, in C.

f1
# Will give an error message, since function "f1" not yet defined.

declare -f f1      # This doesn't help either.
f1                 # Still an error message.

# However...

	  
f1 ()
{
  echo "Calling function \"f2\" from within function \"f1\"."
  f2
}

f2 ()
{
  echo "Function \"f2\"."
}

f1  #  Function "f2" is not actually called until this point,
    #+ although it is referenced before its definition.
    #  This is permissible.
    
    # Thanks, S.C.

It is even possible to nest a function within another function, although this is not very useful.

f1 ()
{

  f2 () # nested
  {
    echo "Function \"f2\", inside \"f1\"."
  }

}  

f2  #  Gives an error message.
    #  Even a preceding "declare -f f2" wouldn't help.

echo    

f1  #  Does nothing, since calling "f1" does not automatically call "f2".
f2  #  Now, it's all right to call "f2",
    #+ since its definition has been made visible by calling "f1".

    # Thanks, S.C.

			12.12.7.3 Function declarations can appear in unlikely places
			 even where a command would otherwise go.

ls -l | foo() { echo "foo"; }  # Permissible, but useless.



if [ "$USER" = bozo ]
then
  bozo_greet ()   # Function definition embedded in an if/then construct.
  {
    echo "Hello, Bozo."
  }
fi  

bozo_greet        # Works only for Bozo, and other users get an error.



# Something like this might be useful in some contexts.
NO_EXIT=1   # Will enable function definition below.

[[ $NO_EXIT -eq 1 ]] && exit() { true; }     # Function definition in an "and-list".
# If $NO_EXIT is 1, declares "exit ()".
# This disables the "exit" builtin by aliasing it to "true".

exit  # Invokes "exit ()" function, not "exit" builtin.



# Or, similarly:
filename=file1

[ -f "$filename" ] &&
foo () { rm -f "$filename"; echo "File "$filename" deleted."; } ||
foo () { echo "File "$filename" not found."; touch bar; }

foo

# Thanks, S.C. and Christopher Head

Note	What happens when different versions of the same function appear in a script?

#  As Yan Chen points out,
#  when a function is defined multiple times,
#  the final version is what is invoked.
#  This is not, however, particularly useful.

func ()
{
  echo "First version of func ()."
}

func ()
{
  echo "Second version of func ()."
}

func   # Second version of func ().

exit $?

#  It is even possible to use functions to override
#+ or preempt system commands.
#  Of course, this is *not* advisable.

			12.12.7.1. Complex Functions and Function Complexities
Functions may process arguments passed to them and return an exit status to the script for further processing.

function_name $arg1 $arg2

The function refers to the passed arguments by position (as if they were positional parameters), that is, $1, $2, and so forth.

				12.12.7.1..1 Example 23-2. Function Taking Parameters

#!/bin/bash
# Functions and parameters

DEFAULT=default                             # Default param value.

func2 () {
   if [ -z "$1" ]                           # Is parameter #1 zero length?
   then
     echo "-Parameter #1 is zero length.-"  # Or no parameter passed.
   else
     echo "-Param #1 is \"$1\".-"
   fi

   variable=${1-$DEFAULT}                   #  What does
   echo "variable = $variable"              #+ parameter substitution show?
                                            #  ---------------------------
                                            #  It distinguishes between
                                            #+ no param and a null param.

   if [ "$2" ]
   then
     echo "-Parameter #2 is \"$2\".-"
   fi

   return 0
}

echo
   
echo "Nothing passed."   
func2                          # Called with no params
echo


echo "Zero-length parameter passed."
func2 ""                       # Called with zero-length param
echo

echo "Null parameter passed."
func2 "$uninitialized_param"   # Called with uninitialized param
echo

echo "One parameter passed."   
func2 first           # Called with one param
echo

echo "Two parameters passed."   
func2 first second    # Called with two params
echo

echo "\"\" \"second\" passed."
func2 "" second       # Called with zero-length first parameter
echo                  # and ASCII string as a second one.

exit 0

Important	The shift command works on arguments passed to functions (see Example 33-16).

But, what about command-line arguments passed to the script? Does a function see them? Well, let's clear up the confusion.

				12.12.7.1.2 Example 23-3 Functions and command-line args passed to the script

#!/bin/bash
# func-cmdlinearg.sh
#  Call this script with a command-line argument,
#+ something like $0 arg1.


func ()

{
echo "$1"
}

echo "First call to function: no arg passed."
echo "See if command-line arg is seen."
func
# No! Command-line arg not seen.

echo "============================================================"
echo
echo "Second call to function: command-line arg passed explicitly."
func $1
# Now it's seen!

exit 0

				12.12.7.1.3 Example 23-4 Passing an indirect reference to a function

In contrast to certain other programming languages, shell scripts normally pass only value parameters to functions. Variable names (which are actually pointers), if passed as parameters to functions, will be treated as string literals. Functions interpret their arguments literally.

Indirect variable references (see Example 34-2) provide a clumsy sort of mechanism for passing variable pointers to functions.


#!/bin/bash
# ind-func.sh: Passing an indirect reference to a function.

echo_var ()
{
echo "$1"
}

message=Hello
Hello=Goodbye

echo_var "$message"        # Hello
# Now, let's pass an indirect reference to the function.
echo_var "${!message}"     # Goodbye

echo "-------------"

# What happens if we change the contents of "hello" variable?
Hello="Hello, again!"
echo_var "$message"        # Hello
echo_var "${!message}"     # Hello, again!

exit 0

The next logical question is whether parameters can be dereferenced after being passed to a function.

				12.12.7.1.4 Example 23-5 Dereferencing a parameter passed to a function

#!/bin/bash
# dereference.sh
# Dereferencing parameter passed to a function.
# Script by Bruce W. Clare.

dereference ()
{
     y=\$"$1"   # Name of variable.
     echo $y    # $Junk

     x=`eval "expr \"$y\" "`
     echo $1=$x
     eval "$1=\"Some Different Text \""  # Assign new value.
}

Junk="Some Text"
echo $Junk "before"    # Some Text before

dereference Junk
echo $Junk "after"     # Some Different Text after

exit 0

				12.12.7.1.5 Example 23-6 Again, dereferencing a parameter passed to a function

#!/bin/bash
# ref-params.sh: Dereferencing a parameter passed to a function.
#                (Complex Example)

ITERATIONS=3  # How many times to get input.
icount=1

my_read () {
  #  Called with my_read varname,
  #+ outputs the previous value between brackets as the default value,
  #+ then asks for a new value.

  local local_var

  echo -n "Enter a value "
  eval 'echo -n "[$'$1'] "'  #  Previous value.
# eval echo -n "[\$$1] "     #  Easier to understand,
                             #+ but loses trailing space in user prompt.
  read local_var
  [ -n "$local_var" ] && eval $1=\$local_var

  # "And-list": if "local_var" then set "$1" to its value.
}

echo

while [ "$icount" -le "$ITERATIONS" ]
do
  my_read var
  echo "Entry #$icount = $var"
  let "icount += 1"
  echo
done  


# Thanks to Stephane Chazelas for providing this instructive example.

exit 0

				12.12.7.1.6 Exit and Return

exit status

    Functions return a value, called an exit status. The exit status may be explicitly specified by a return statement, otherwise it is the exit status of the last command in the function (0 if successful, and a non-zero error code if not). This exit status may be used in the script by referencing it as $?. This mechanism effectively permits script functions to have a "return value" similar to C functions.

return

    Terminates a function. A return command [1] optionally takes an integer argument, which is returned to the calling script as the "exit status" of the function, and this exit status is assigned to the variable $?.

					12.12.7.1.6.1 Example 23-7. Maximum of two numbers

    #!/bin/bash
    # max.sh: Maximum of two integers.

    E_PARAM_ERR=250    # If less than 2 params passed to function.
    EQUAL=251          # Return value if both params equal.
    #  Error values out of range of any
    #+ params that might be fed to the function.

    max2 ()             # Returns larger of two numbers.
    {                   # Note: numbers compared must be less than 257.
    if [ -z "$2" ]
    then
      return $E_PARAM_ERR
    fi

    if [ "$1" -eq "$2" ]
    then
      return $EQUAL
    else
      if [ "$1" -gt "$2" ]
      then
        return $1
      else
        return $2
      fi
    fi
    }

    max2 33 34
    return_val=$?

    if [ "$return_val" -eq $E_PARAM_ERR ]
    then
      echo "Need to pass two parameters to the function."
    elif [ "$return_val" -eq $EQUAL ]
      then
        echo "The two numbers are equal."
    else
        echo "The larger of the two numbers is $return_val."
    fi  

      
    exit 0

    #  Exercise (easy):
    #  ---------------
    #  Convert this to an interactive script,
    #+ that is, have the script ask for input (two numbers).

    Tip	For a function to return a string or array, use a dedicated variable.

    count_lines_in_etc_passwd()
    {
      [[ -r /etc/passwd ]] && REPLY=$(echo $(wc -l < /etc/passwd))
      #  If /etc/passwd is readable, set REPLY to line count.
      #  Returns both a parameter value and status information.
      #  The 'echo' seems unnecessary, but . . .
      #+ it removes excess whitespace from the output.
    }

    if count_lines_in_etc_passwd
    then
      echo "There are $REPLY lines in /etc/passwd."
    else
      echo "Cannot count lines in /etc/passwd."
    fi  

    # Thanks, S.C.

					12.12.7.1.6.2 Example 23-8. Converting numbers to Roman numerals

    #!/bin/bash

    # Arabic number to Roman numeral conversion
    # Range: 0 - 200
    # It's crude, but it works.

    # Extending the range and otherwise improving the script is left as an exercise.

    # Usage: roman number-to-convert

    LIMIT=200
    E_ARG_ERR=65
    E_OUT_OF_RANGE=66

    if [ -z "$1" ]
    then
      echo "Usage: `basename $0` number-to-convert"
      exit $E_ARG_ERR
    fi  

    num=$1
    if [ "$num" -gt $LIMIT ]
    then
      echo "Out of range!"
      exit $E_OUT_OF_RANGE
    fi  

    to_roman ()   # Must declare function before first call to it.
    {
    number=$1
    factor=$2
    rchar=$3
    let "remainder = number - factor"
    while [ "$remainder" -ge 0 ]
    do
      echo -n $rchar
      let "number -= factor"
      let "remainder = number - factor"
    done  

    return $number
           # Exercises:
           # ---------
           # 1) Explain how this function works.
           #    Hint: division by successive subtraction.
           # 2) Extend to range of the function.
           #    Hint: use "echo" and command-substitution capture.
    }
       

    to_roman $num 100 C
    num=$?
    to_roman $num 90 LXXXX
    num=$?
    to_roman $num 50 L
    num=$?
    to_roman $num 40 XL
    num=$?
    to_roman $num 10 X
    num=$?
    to_roman $num 9 IX
    num=$?
    to_roman $num 5 V
    num=$?
    to_roman $num 4 IV
    num=$?
    to_roman $num 1 I
    # Successive calls to conversion function!
    # Is this really necessary??? Can it be simplified?

    echo

    exit


    Important	The largest positive integer a function can return is 255. The return command is closely tied to the concept of exit status, which accounts for this particular limitation. Fortunately, there are various workarounds for those situations requiring a large integer return value from a function.

					12.12.7.1.6.3 Example 23-9. Testing large return values in a function

    #!/bin/bash
    # return-test.sh

    # The largest positive value a function can return is 255.

    return_test ()         # Returns whatever passed to it.
    {
      return $1
    }

    return_test 27         # o.k.
    echo $?                # Returns 27.
      
    return_test 255        # Still o.k.
    echo $?                # Returns 255.

    return_test 257        # Error!
    echo $?                # Returns 1 (return code for miscellaneous error).

    # ======================================================
    return_test -151896    # Do large negative numbers work?
    echo $?                # Will this return -151896?
                           # No! It returns 168.
    #  Version of Bash before 2.05b permitted
    #+ large negative integer return values.
    #  Newer versions of Bash plug this loophole.
    #  This may break older scripts.
    #  Caution!
    # ======================================================

    exit 0

    A workaround for obtaining large integer "return values" is to simply assign the "return value" to a global variable.

    Return_Val=   # Global variable to hold oversize return value of function.

    alt_return_test ()
    {
      fvar=$1
      Return_Val=$fvar
      return   # Returns 0 (success).
    }

    alt_return_test 1
    echo $?                              # 0
    echo "return value = $Return_Val"    # 1

    alt_return_test 256
    echo "return value = $Return_Val"    # 256

    alt_return_test 257
    echo "return value = $Return_Val"    # 257

    alt_return_test 25701
    echo "return value = $Return_Val"    #25701

    A more elegant method is to have the function echo its "return value to stdout," and then capture it by command substitution. 

					12.12.7.1.6.4 Example 23-10. Comparing two large integers

    #!/bin/bash
    # max2.sh: Maximum of two LARGE integers.

    #  This is the previous "max.sh" example,
    #+ modified to permit comparing large integers.

    EQUAL=0             # Return value if both params equal.
    E_PARAM_ERR=-99999  # Not enough params passed to function.
    #           ^^^^^^    Out of range of any params that might be passed.

    max2 ()             # "Returns" larger of two numbers.
    {
    if [ -z "$2" ]
    then
      echo $E_PARAM_ERR
      return
    fi

    if [ "$1" -eq "$2" ]
    then
      echo $EQUAL
      return
    else
      if [ "$1" -gt "$2" ]
      then
        retval=$1
      else
        retval=$2
      fi
    fi

    echo $retval        # Echoes (to stdout), rather than returning value.
                        # Why?
    }


    return_val=$(max2 33001 33997)
    #            ^^^^             Function name
    #                 ^^^^^ ^^^^^ Params passed
    #  This is actually a form of command substitution:
    #+ treating a function as if it were a command,
    #+ and assigning the stdout of the function to the variable "return_val."


    # ========================= OUTPUT ========================
    if [ "$return_val" -eq "$E_PARAM_ERR" ]
      then
      echo "Error in parameters passed to comparison function!"
    elif [ "$return_val" -eq "$EQUAL" ]
      then
        echo "The two numbers are equal."
    else
        echo "The larger of the two numbers is $return_val."
    fi
    # =========================================================
      
    exit 0

    #  Exercises:
    #  ---------
    #  1) Find a more elegant way of testing
    #+    the parameters passed to the function.
    #  2) Simplify the if/then structure at "OUTPUT."
    #  3) Rewrite the script to take input from command-line parameters.

    Here is another example of capturing a function "return value." Understanding it requires some knowledge of awk.

					12.12.7.1.6.5 Example: Month length
    month_length ()  # Takes month number as an argument.
    {                # Returns number of days in month.
    monthD="31 28 31 30 31 30 31 31 30 31 30 31"  # Declare as local?
    echo "$monthD" | awk '{ print $'"${1}"' }'    # Tricky.
    #                             ^^^^^^^^^
    # Parameter passed to function  ($1 -- month number), then to awk.
    # Awk sees this as "print $1 . . . print $12" (depending on month number)
    # Template for passing a parameter to embedded awk script:
    #                                 $'"${script_parameter}"'

    #  Needs error checking for correct parameter range (1-12)
    #+ and for February in leap year.
    }

    # ----------------------------------------------
    # Usage example:
    month=4        # April, for example (4th month).
    days_in=$(month_length $month)
    echo $days_in  # 30
    # ----------------------------------------------

    See also Example A-7 and Example A-39.

    Exercise: Using what we have just learned, extend the previous Roman numerals example to accept arbitrarily large input.

				12.12.7.1.7 Redirection

Redirecting the stdin of a function

    A function is essentially a code block, which means its stdin can be redirected (as in Example 3-1).

					12.12.7.1.7.1 Example 23-11. Real name from username

    #!/bin/bash
    # realname.sh
    #
    # From username, gets "real name" from /etc/passwd.


    ARGCOUNT=1       # Expect one arg.
    E_WRONGARGS=65

    file=/etc/passwd
    pattern=$1

    if [ $# -ne "$ARGCOUNT" ]
    then
      echo "Usage: `basename $0` USERNAME"
      exit $E_WRONGARGS
    fi  

    file_excerpt ()    #  Scan file for pattern,
    {                  #+ then print relevant portion of line.
      while read line  # "while" does not necessarily need [ condition ]
      do
        echo "$line" | grep $1 | awk -F":" '{ print $5 }'
        # Have awk use ":" delimiter.
      done
    } <$file  # Redirect into function's stdin.

    file_excerpt $pattern

    # Yes, this entire script could be reduced to
    #       grep PATTERN /etc/passwd | awk -F":" '{ print $5 }'
    # or
    #       awk -F: '/PATTERN/ {print $5}'
    # or
    #       awk -F: '($1 == "username") { print $5 }' # real name from username
    # However, it might not be as instructive.

    exit 0

    There is an alternate, and perhaps less confusing method of redirecting a function's stdin. This involves redirecting the stdin to an embedded bracketed code block within the function.

    # Instead of:
    Function ()
    {
     ...
     } < file

    # Try this:
    Function ()
    {
      {
        ...
       } < file
    }

    # Similarly,

    Function ()  # This works.
    {
      {
       echo $*
      } | tr a b
    }

    Function ()  # This doesn't work.
    {
      echo $*
    } | tr a b   # A nested code block is mandatory here.


    # Thanks, S.C.

			12.12.7.2 Local Variables
What makes a variable local?

local variables

    A variable declared as local is one that is visible only within the block of code in which it appears. It has local "scope." In a function, a local variable has meaning only within that function block.

				12.12.7.2.1 Example 23-12. Local variable visibility

    #!/bin/bash
    # Global and local variables inside a function.

    func ()
    {
      local loc_var=23       # Declared as local variable.
      echo                   # Uses the 'local' builtin.
      echo "\"loc_var\" in function = $loc_var"
      global_var=999         # Not declared as local.
                             # Defaults to global. 
      echo "\"global_var\" in function = $global_var"
    }  

    func

    # Now, to see if local variable "loc_var" exists outside function.

    echo
    echo "\"loc_var\" outside function = $loc_var"
                                          # $loc_var outside function = 
                                          # No, $loc_var not visible globally.
    echo "\"global_var\" outside function = $global_var"
                                          # $global_var outside function = 999
                                          # $global_var is visible globally.
    echo				      

    exit 0
    #  In contrast to C, a Bash variable declared inside a function
    #+ is local *only* if declared as such.

    Caution	Before a function is called, all variables declared within the function are invisible outside the body of the function, not just those explicitly declared as local.

    #!/bin/bash

    func ()
    {
    global_var=37    #  Visible only within the function block
                     #+ before the function has been called. 
    }                #  END OF FUNCTION

    echo "global_var = $global_var"  # global_var =
                                     #  Function "func" has not yet been called,
                                     #+ so $global_var is not visible here.

    func
    echo "global_var = $global_var"  # global_var = 37
                                     # Has been set by function call.

				12.12.7.2.2 Local variables and recursion.

Recursion is an interesting and sometimes useful form of self-reference. Herbert Mayer defines it as ". . . expressing an algorithm by using a simpler version of that same algorithm . . ."

Consider a definition defined in terms of itself, [1] an expression implicit in its own expression, [2] a snake swallowing its own tail, [3] or . . . a function that calls itself. [4]

					12.12.7.2.2.1 Example 23-13. Demonstration of a simple recursive function

#!/bin/bash
# recursion-demo.sh
# Demonstration of recursion.

RECURSIONS=9   # How many times to recurse.
r_count=0      # Must be global. Why?

recurse ()
{
  var="$1"

  while [ "$var" -ge 0 ]
  do
    echo "Recursion count = "$r_count"  +-+  \$var = "$var""
    (( var-- )); (( r_count++ ))
    recurse "$var"  #  Function calls itself (recurses)
  done              #+ until what condition is met?
}

recurse $RECURSIONS

exit $?

Local variables are a useful tool for writing recursive code, but this practice generally involves a great deal of computational overhead and is definitely not recommended in a shell script. [5]

					12.12.7.2.2.2 Example 23-14. Recursion, using a local variable

#!/bin/bash

#               factorial
#               ---------


# Does bash permit recursion?
# Well, yes, but...
# It's so slow that you gotta have rocks in your head to try it.


MAX_ARG=5
E_WRONG_ARGS=65
E_RANGE_ERR=66


if [ -z "$1" ]
then
  echo "Usage: `basename $0` number"
  exit $E_WRONG_ARGS
fi

if [ "$1" -gt $MAX_ARG ]
then
  echo "Out of range (5 is maximum)."
  #  Let's get real now.
  #  If you want greater range than this,
  #+ rewrite it in a Real Programming Language.
  exit $E_RANGE_ERR
fi  

fact ()
{
  local number=$1
  #  Variable "number" must be declared as local,
  #+ otherwise this doesn't work.
  if [ "$number" -eq 0 ]
  then
    factorial=1    # Factorial of 0 = 1.
  else
    let "decrnum = number - 1"
    fact $decrnum  # Recursive function call (the function calls itself).
    let "factorial = $number * $?"
  fi

  return $factorial
}

fact $1
echo "Factorial of $1 is $?."

exit 0

Also see Example A-16 for an example of recursion in a script. Be aware that recursion is resource-intensive and executes slowly, and is therefore generally not appropriate in a script.
Notes
[1]	Otherwise known as redundancy.
[2]	Otherwise known as tautology.
[3]	Otherwise known as a metaphor.
[4]	Otherwise known as a recursive function.
[5]	Too many levels of recursion may crash a script with a segfault.

#!/bin/bash

#  Warning: Running this script could possibly lock up your system!
#  If you're lucky, it will segfault before using up all available memory.

					12.12.7.2.2.3 Example: Recursion limits 
recursive_function ()		   
{
echo "$1"     # Makes the function do something, and hastens the segfault.
(( $1 < $2 )) && recursive_function $(( $1 + 1 )) $2;
#  As long as 1st parameter is less than 2nd,
#+ increment 1st and recurse.
}

recursive_function 1 50000  # Recurse 50,000 levels!
#  Most likely segfaults (depending on stack size, set by ulimit -m).

#  Recursion this deep might cause even a C program to segfault,
#+ by using up all the memory allotted to the stack.


echo "This will probably not print."
exit 0  # This script will not exit normally.

#  Thanks, Stphane Chazelas.

			12.12.7.3 Recursion Without Local Variables
A function may recursively call itself even without use of local variables.

				12.12.7.3.1 Example 23-15. The Fibonacci Sequence

#!/bin/bash
# fibo.sh : Fibonacci sequence (recursive)
# Author: M. Cooper
# License: GPL3

# ---------------------------------
# Fibo(0) = 0
# Fibo(1) = 1
# else
#   Fibo(j) = Fibo(j-1) + Fibo(j-2)
# ---------------------------------

MAXTERM=15       # Number of terms (+1) to generate.
MINIDX=2         # If idx is less than 2, then Fibo(idx) = idx.

Fibonacci ()
{
  idx=$1   # Doesn't need to be local. Why not?
  if [ "$idx" -lt "$MINIDX" ]
  then
    echo "$idx"  # First two terms are 0 1 ... see above.
  else
    (( --idx ))  # j-1
    term1=$( Fibonacci $idx )   #  Fibo(j-1)

    (( --idx ))  # j-2
    term2=$( Fibonacci $idx )   #  Fibo(j-2)

    echo $(( term1 + term2 ))
  fi
  #  An ugly, ugly kludge.
  #  The more elegant implementation of recursive fibo in C
  #+ is a straightforward translation of the algorithm in lines 7 - 10.
}

for i in $(seq 0 $MAXTERM)
do  # Calculate $MAXTERM+1 terms.
  FIBO=$(Fibonacci $i)
  echo -n "$FIBO "
done
# 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610
# Takes a while, doesn't it? Recursion in a script is slow.

echo

exit 0

				12.12.7.3.2 Example 23-16. The Towers of Hanoi

#! /bin/bash
#
# The Towers Of Hanoi
# Bash script
# Copyright (C) 2000 Amit Singh. All Rights Reserved.
# http://hanoi.kernelthread.com
#
# Tested under Bash version 2.05b.0(13)-release.
# Also works under Bash version 3.x.
#
#  Used in "Advanced Bash Scripting Guide"
#+ with permission of script author.
#  Slightly modified and commented by ABS author.

#=================================================================#
#  The Tower of Hanoi is a mathematical puzzle attributed to
#+ Edouard Lucas, a nineteenth-century French mathematician.
#
#  There are three vertical posts set in a base.
#  The first post has a set of annular rings stacked on it.
#  These rings are disks with a hole drilled out of the center,
#+ so they can slip over the posts and rest flat.
#  The rings have different diameters, and they stack in ascending
#+ order, according to size.
#  The smallest ring is on top, and the largest on the bottom.
#
#  The task is to transfer the stack of rings
#+ to one of the other posts.
#  You can move only one ring at a time to another post.
#  You are permitted to move rings back to the original post.
#  You may place a smaller ring atop a larger one,
#+ but *not* vice versa.
#  Again, it is forbidden to place a larger ring atop a smaller one.
#
#  For a small number of rings, only a few moves are required.
#+ For each additional ring,
#+ the required number of moves approximately doubles,
#+ and the "strategy" becomes increasingly complicated.
#
#  For more information, see http://hanoi.kernelthread.com
#+ or pp. 186-92 of _The Armchair Universe_ by A.K. Dewdney.
#
#
#         ...                   ...                    ...
#         | |                   | |                    | |
#        _|_|_                  | |                    | |
#       |_____|                 | |                    | |
#      |_______|                | |                    | |
#     |_________|               | |                    | |
#    |___________|              | |                    | |
#   |             |             | |                    | |
# .--------------------------------------------------------------.
# |**************************************************************|
#          #1                   #2                      #3
#
#=================================================================#


E_NOPARAM=66  # No parameter passed to script.
E_BADPARAM=67 # Illegal number of disks passed to script.
Moves=        # Global variable holding number of moves.
              # Modification to original script.

dohanoi() {   # Recursive function.
    case $1 in
    0)
        ;;
    *)
        dohanoi "$(($1-1))" $2 $4 $3
        echo move $2 "-->" $3
        ((Moves++))          # Modification to original script.
        dohanoi "$(($1-1))" $4 $3 $2
        ;;
    esac
}

case $# in
    1) case $(($1>0)) in     # Must have at least one disk.
       1)  # Nested case statement.
           dohanoi $1 1 3 2
           echo "Total moves = $Moves"   # 2^n - 1, where n = # of disks.
           exit 0;
           ;;
       *)
           echo "$0: illegal value for number of disks";
           exit $E_BADPARAM;
           ;;
       esac
    ;;
    *)
       echo "usage: $0 N"
       echo "       Where \"N\" is the number of disks."
       exit $E_NOPARAM;
       ;;
esac

# Exercises:
# ---------
# 1) Would commands beyond this point ever be executed?
#    Why not? (Easy)
# 2) Explain the workings of the workings of the "dohanoi" function.
#    (Difficult -- see the Dewdney reference, above.)

		12.12.8 Chapter 24. Aliases
A Bash alias is essentially nothing more than a keyboard shortcut, an abbreviation, a means of avoiding typing a long command sequence. If, for example, we include alias lm="ls -l | more" in the ~/.bashrc  file, then each lm typed at the command line will automatically be replaced by a ls -l | more. This can save a great deal of typing at the command line and avoid having to remember complex combinations of commands and options. Setting alias rm="rm -i"  (interactive mode delete) may save a good deal of grief, since it can prevent inadvertently losing important files.

In a script, aliases have very limited usefulness. It would be quite nice if aliases could assume some of the functionality of the C preprocessor, such as macro expansion, but unfortunately Bash does not expand arguments within the alias body. [1] Moreover, a script fails to expand an alias itself within "compound constructs," such as if/then statements, loops, and functions. An added limitation is that an alias will not expand recursively. Almost invariably, whatever we would like an alias to do could be accomplished much more effectively with a function.

			12.12.8.1 Example 24-1. Aliases within a script

#!/bin/bash
# alias.sh

shopt -s expand_aliases
# Must set this option, else script will not expand aliases.


# First, some fun.
alias Jesse_James='echo "\"Alias Jesse James\" was a 1959 comedy starring Bob Hope."'
Jesse_James

echo; echo; echo;

alias ll="ls -l"
# May use either single (') or double (") quotes to define an alias.

echo "Trying aliased \"ll\":"
ll /usr/X11R6/bin/mk*   #* Alias works.

echo

directory=/usr/X11R6/bin/
prefix=mk*  # See if wild card causes problems.
echo "Variables \"directory\" + \"prefix\" = $directory$prefix"
echo

alias lll="ls -l $directory$prefix"

echo "Trying aliased \"lll\":"
lll         # Long listing of all files in /usr/X11R6/bin stating with mk.
# An alias can handle concatenated variables -- including wild card -- o.k.




TRUE=1

echo

if [ TRUE ]
then
  alias rr="ls -l"
  echo "Trying aliased \"rr\" within if/then statement:"
  rr /usr/X11R6/bin/mk*   #* Error message results!
  # Aliases not expanded within compound statements.
  echo "However, previously expanded alias still recognized:"
  ll /usr/X11R6/bin/mk*
fi  

echo

count=0
while [ $count -lt 3 ]
do
  alias rrr="ls -l"
  echo "Trying aliased \"rrr\" within \"while\" loop:"
  rrr /usr/X11R6/bin/mk*   #* Alias will not expand here either.
                           #  alias.sh: line 57: rrr: command not found
  let count+=1
done 

echo; echo

alias xyz='cat $0'   # Script lists itself.
                     # Note strong quotes.
xyz
#  This seems to work,
#+ although the Bash documentation suggests that it shouldn't.
#
#  However, as Steve Jacobson points out,
#+ the "$0" parameter expands immediately upon declaration of the alias.

exit 0

The unalias command removes a previously set alias.

			12.12.8.2 Example 24-2. unalias: Setting and unsetting an alias

#!/bin/bash
# unalias.sh

shopt -s expand_aliases  # Enables alias expansion.

alias llm='ls -al | more'
llm

echo

unalias llm              # Unset alias.
llm
# Error message results, since 'llm' no longer recognized.

exit 0

bash$ ./unalias.sh
total 6
drwxrwxr-x    2 bozo     bozo         3072 Feb  6 14:04 .
drwxr-xr-x   40 bozo     bozo         2048 Feb  6 14:04 ..
-rwxr-xr-x    1 bozo     bozo          199 Feb  6 14:04 unalias.sh

./unalias.sh: llm: command not found

Notes [1]	However, aliases do seem to expand positional parameters.

		12.12.9 Chapter 25. List Constructs
The and list and or list constructs provide a means of processing a number of commands consecutively. These can effectively replace complex nested if/then  or even case statements.

Chaining together commands

and list

    command-1 && command-2 && command-3 && ... command-n

    Each command executes in turn, provided that the previous command has given a return value of true (zero). At the first false (non-zero) return, the command chain terminates (the first command returning false is the last one to execute).

			12.12.9.1 Example 25-1. Using an and list to test for command-line arguments

    #!/bin/bash
    # and list

    if [ ! -z "$1" ] && echo "Argument #1 = $1" && [ ! -z "$2" ] \
    && echo "Argument #2 = $2"
    then
      echo "At least 2 arguments passed to script."
      # All the chained commands return true.
    else
      echo "Less than 2 arguments passed to script."
      # At least one of the chained commands returns false.
    fi  
    # Note that "if [ ! -z $1 ]" works, but its supposed equivalent,
    #   if [ -n $1 ] does not.
    #     However, quoting fixes this.
    #  if [ -n "$1" ] works.
    #     Careful!
    # It is always best to QUOTE tested variables.


    # This accomplishes the same thing, using "pure" if/then statements.
    if [ ! -z "$1" ]
    then
      echo "Argument #1 = $1"
    fi
    if [ ! -z "$2" ]
    then
      echo "Argument #2 = $2"
      echo "At least 2 arguments passed to script."
    else
      echo "Less than 2 arguments passed to script."
    fi
    # It's longer and less elegant than using an "and list".


    exit 0

			12.12.9.2 Example 25-2. Another command-line arg test using an and list

    #!/bin/bash

    ARGS=1        # Number of arguments expected.
    E_BADARGS=65  # Exit value if incorrect number of args passed.

    test $# -ne $ARGS && \
    echo "Usage: `basename $0` $ARGS argument(s)" && exit $E_BADARGS
    #  If condition 1 tests true (wrong number of args passed to script),
    #+ then the rest of the line executes, and script terminates.

    # Line below executes only if the above test fails.
    echo "Correct number of arguments passed to this script."

    exit 0

    # To check exit value, do a "echo $?" after script termination.

    Of course, an and list can also set variables to a default value.

    arg1=$@ && [ -z "$arg1" ] && arg1=DEFAULT
    		
                  # Set $arg1 to command line arguments, if any.
                  # But . . . set to DEFAULT if not specified on command line.

or list

    command-1 || command-2 || command-3 || ... command-n

    Each command executes in turn for as long as the previous command returns false. At the first true return, the command chain terminates (the first command returning true is the last one to execute). This is obviously the inverse of the "and list".

			12.12.9.3 Example 25-3. Using or lists in combination with an and list

    #!/bin/bash

    #  delete.sh, a not-so-cunning file deletion utility.
    #  Usage: delete filename

    E_BADARGS=85

    if [ -z "$1" ]
    then
      echo "Usage: `basename $0` filename"
      exit $E_BADARGS  # No arg? Bail out.
    else  
      file=$1          # Set filename.
    fi  


    [ ! -f "$file" ] && echo "File \"$file\" not found. \
    Cowardly refusing to delete a nonexistent file."
    # AND LIST, to give error message if file not present.
    # Note echo message continued on to a second line with an escape.

    [ ! -f "$file" ] || (rm -f $file; echo "File \"$file\" deleted.")
    # OR LIST, to delete file if present.

    # Note logic inversion above.
    # AND LIST executes on true, OR LIST on false.

    exit $?

    Caution	If the first command in an or list returns true, it will execute.

# ==> The following snippets from the /etc/rc.d/init.d/single
#+==> script by Miquel van Smoorenburg
#+==> illustrate use of "and" and "or" lists.
# ==> "Arrowed" comments added by document author.

[ -x /usr/bin/clear ] && /usr/bin/clear
  # ==> If /usr/bin/clear exists, then invoke it.
  # ==> Checking for the existence of a command before calling it
  #+==> avoids error messages and other awkward consequences.

  # ==> . . .

# If they want to run something in single user mode, might as well run it...
for i in /etc/rc1.d/S[0-9][0-9]* ; do
        # Check if the script is there.
        [ -x "$i" ] || continue
  # ==> If corresponding file in $PWD *not* found,
  #+==> then "continue" by jumping to the top of the loop.

        # Reject backup files and files generated by rpm.
        case "$1" in
                *.rpmsave|*.rpmorig|*.rpmnew|*~|*.orig)
                        continue;;
        esac
        [ "$i" = "/etc/rc1.d/S00single" ] && continue
  # ==> Set script name, but don't execute it yet.
        $i start
done

  # ==> . . .

Important	The exit status of an and list or an or list is the exit status of the last command executed.

Clever combinations of and and or lists are possible, but the logic may easily become convoluted and require close attention to operator precedence rules, and possibly extensive debugging.

false && true || echo false         # false

# Same result as
( false && true ) || echo false     # false
# But NOT
false && ( true || echo false )     # (nothing echoed)

#  Note left-to-right grouping and evaluation of statements,
#+ since the logic operators "&&" and "||" have equal precedence.

#  It's usually best to avoid such complexities.

#  Thanks, S.C.
		12.12.10 Chapter 26. Arrays
Newer versions of Bash support one-dimensional arrays.  Array elements may be initialized with the variable[xx] notation. Alternatively, a script may introduce the entire array by an explicit declare -a variable statement. To dereference (retrieve the contents of) an array element, use curly bracket notation, that is, ${element[xx]}.

			12.12.10.1 Example 26-1. Simple array usage

#!/bin/bash


area[11]=23
area[13]=37
area[51]=UFOs

#  Array members need not be consecutive or contiguous.

#  Some members of the array can be left uninitialized.
#  Gaps in the array are okay.
#  In fact, arrays with sparse data ("sparse arrays")
#+ are useful in spreadsheet-processing software.


echo -n "area[11] = "
echo ${area[11]}    #  {curly brackets} needed.

echo -n "area[13] = "
echo ${area[13]}

echo "Contents of area[51] are ${area[51]}."

# Contents of uninitialized array variable print blank (null variable).
echo -n "area[43] = "
echo ${area[43]}
echo "(area[43] unassigned)"

echo

# Sum of two array variables assigned to third
area[5]=`expr ${area[11]} + ${area[13]}`
echo "area[5] = area[11] + area[13]"
echo -n "area[5] = "
echo ${area[5]}

area[6]=`expr ${area[11]} + ${area[51]}`
echo "area[6] = area[11] + area[51]"
echo -n "area[6] = "
echo ${area[6]}
# This fails because adding an integer to a string is not permitted.

echo; echo; echo

# -----------------------------------------------------------------
# Another array, "area2".
# Another way of assigning array variables...
# array_name=( XXX YYY ZZZ ... )

area2=( zero one two three four )

echo -n "area2[0] = "
echo ${area2[0]}
# Aha, zero-based indexing (first element of array is [0], not [1]).

echo -n "area2[1] = "
echo ${area2[1]}    # [1] is second element of array.
# -----------------------------------------------------------------

echo; echo; echo

# -----------------------------------------------
# Yet another array, "area3".
# Yet another way of assigning array variables...
# array_name=([xx]=XXX [yy]=YYY ...)

area3=([17]=seventeen [24]=twenty-four)

echo -n "area3[17] = "
echo ${area3[17]}

echo -n "area3[24] = "
echo ${area3[24]}
# -----------------------------------------------

exit 0

			12.12.10.2 convenient way of initializing an entire array 
As we have seen, a convenient way of initializing an entire array is the array=( element1 element2 ... elementN ) notation.

Bash permits array operations on variables, even if the variables are not explicitly declared as arrays.

string=abcABC123ABCabc
echo ${string[@]}               # abcABC123ABCabc
echo ${string[*]}               # abcABC123ABCabc 
echo ${string[0]}               # abcABC123ABCabc
echo ${string[1]}               # No output!
                                # Why?
echo ${#string[@]}              # 1
                                # One element in the array.
                                # The string itself.

# Thank you, Michael Zick, for pointing this out.

Once again this demonstrates that Bash variables are untyped.

			12.12.10.3 Example 26-2. Formatting a poem

#!/bin/bash
# poem.sh: Pretty-prints one of the document author's favorite poems.

# Lines of the poem (single stanza).
Line[1]="I do not know which to prefer,"
Line[2]="The beauty of inflections"
Line[3]="Or the beauty of innuendoes,"
Line[4]="The blackbird whistling"
Line[5]="Or just after."

# Attribution.
Attrib[1]=" Wallace Stevens"
Attrib[2]="\"Thirteen Ways of Looking at a Blackbird\""
# This poem is in the Public Domain (copyright expired).

echo

tput bold   # Bold print.

for index in 1 2 3 4 5    # Five lines.
do
  printf "     %s\n" "${Line[index]}"
done

for index in 1 2          # Two attribution lines.
do
  printf "          %s\n" "${Attrib[index]}"
done

tput sgr0   # Reset terminal.
            # See 'tput' docs.

echo

exit 0

# Exercise:
# --------
# Modify this script to pretty-print a poem from a text data file.

Array variables have a syntax all their own, and even standard Bash commands and operators have special options adapted for array use.

			12.12.10.4 Example 26-3. Various array operations

#!/bin/bash
# array-ops.sh: More fun with arrays.


array=( zero one two three four five )
# Element 0   1   2    3     4    5

echo ${array[0]}       #  zero
echo ${array:0}        #  zero
                       #  Parameter expansion of first element,
                       #+ starting at position # 0 (1st character).
echo ${array:1}        #  ero
                       #  Parameter expansion of first element,
                       #+ starting at position # 1 (2nd character).

echo "--------------"

echo ${#array[0]}      #  4
                       #  Length of first element of array.
echo ${#array}         #  4
                       #  Length of first element of array.
                       #  (Alternate notation)

echo ${#array[1]}      #  3
                       #  Length of second element of array.
                       #  Arrays in Bash have zero-based indexing.

echo ${#array[*]}      #  6
                       #  Number of elements in array.
echo ${#array[@]}      #  6
                       #  Number of elements in array.

echo "--------------"

array2=( [0]="first element" [1]="second element" [3]="fourth element" )

echo ${array2[0]}      # first element
echo ${array2[1]}      # second element
echo ${array2[2]}      #
                       # Skipped in initialization, and therefore null.
echo ${array2[3]}      # fourth element


exit 0


			12.12.10.5 Example 26-4. String operations on arrays

Many of the standard string operations work on arrays.

#!/bin/bash
# array-strops.sh: String operations on arrays.

# Script by Michael Zick.
# Fixups: 05 May 08
# Used in ABS Guide with permission.

#  In general, any string operation using the ${name ... } notation
#+ can be applied to all string elements in an array,
#+ with the ${name[@] ... } or ${name[*] ...} notation.


arrayZ=( one two three four five five )

echo

# Trailing Substring Extraction
echo ${arrayZ[@]:0}     # one two three four five five
#                ^        All elements.

echo ${arrayZ[@]:1}     # two three four five five
#                ^        All elements following element[0].

echo ${arrayZ[@]:1:2}   # two three
#                  ^      Only the two elements after element[0].

echo "-----------------------"


# Substring Removal

# Removes shortest match from front of string(s).

echo ${arrayZ[@]#f*r}   # one two three five five
                        # Applied to all elements of the array.
                        # Matches "four" and removes it.

# Longest match from front of string(s)
echo ${arrayZ[@]##t*e}  # one two four five five
                        # Applied to all elements of the array.
                        # Matches "three" and removes it.

# Shortest match from back of string(s)
echo ${arrayZ[@]%h*e}   # one two t four five five
                        # Applied to all elements of the array.
                        # Matches "hree" and removes it.

# Longest match from back of string(s)
echo ${arrayZ[@]%%t*e}  # one two four five five
                        # Applied to all elements of the array.
                        # Matches "three" and removes it.

echo "-----------------------"

# Substring Replacement

# Replace first occurrence of substring with replacement.
echo ${arrayZ[@]/fiv/XYZ}   # one two three four XYZe XYZe
#             ^  ^^^ ^^^      Applied to all elements of the array.

# Replace all occurrences of substring.
echo ${arrayZ[@]//iv/YY}    # one two three four fYYe fYYe
                            # Applied to all elements of the array.

# Delete all occurrences of substring.
# Not specifing a replacement means 'delete.'
echo ${arrayZ[@]//fi/}      # one two three four ve ve
#               ^^            Applied to all elements of the array.

# Replace front-end occurrences of substring.
echo ${arrayZ[@]/#fi/XY}    # one two three four XYve XYve
#                ^            Applied to all elements of the array.

# Replace back-end occurrences of substring.
echo ${arrayZ[@]/%ve/ZZ}    # one two three four fiZZ fiZZ
#                ^            Applied to all elements of the array.

echo ${arrayZ[@]/%o/XX}     # one twXX three four five five
#                ^            Why?

echo "-----------------------"


newstr() {
    echo -n "!!!"
}

echo ${arrayZ[@]/%e/$(newstr)}
#                ^  ^^^^^^^^^
# on!!! two thre!!! four fiv!!! fiv!!!
# Q.E.D: The replacement action is, in effect, an 'assignment.'

echo "-----------------------"

#  Accessing the "For-Each"
echo ${arrayZ[@]//*/$(newstr optional_arguments)}
# !!! !!! !!! !!! !!! !!!

#  Now, if Bash would only pass the matched string
#+ to the function being called . . .

echo

exit 0

#  Before reaching for a Big Hammer -- awk, Perl, or anything else --
#  recall:
#    $( ... ) is command substitution.
#    A function runs as a sub-process.
#    A function writes its output to stdout.
#    Assignment, in conjunction with 'echo' and command substitution,
#+   can read a function's stdout.
#    The name[@] notation specifies a "for-each" operation.
#  Bash is more powerful than you think!

Command substitution can construct the individual elements of an array.

Example 26-5. Loading the contents of a script into an array

#!/bin/bash
# script-array.sh: Loads this script into an array.
# Inspired by an e-mail from Chris Martin (thanks!).

script_contents=( $(cat "$0") )  #  Stores contents of this script ($0)
                                 #+ in an array.

for element in $(seq 0 $((${#script_contents[@]} - 1)))
  do                #  ${#script_contents[@]}
                    #+ gives number of elements in the array.
                    #
                    #  Question:
                    #  Why is  seq 0  necessary?
                    #  Try changing it to seq 1.
  echo -n "${script_contents[$element]}"
                    # List each field of this script on a single line.
# echo -n "${script_contents[element]}" also works because of ${ ... }.
  echo -n " -- "    # Use " -- " as a field separator.
done

echo

exit 0

# Exercise:
# --------
#  Modify this script so it lists itself
#+ in its original format,
#+ complete with whitespace, line breaks, etc.

In an array context, some Bash builtins have a slightly altered meaning. For example, unset deletes array elements, or even an entire array.

			12.12.10.6 Example 26-6. Some special properties of arrays

#!/bin/bash

declare -a colors
#  All subsequent commands in this script will treat
#+ the variable "colors" as an array.

echo "Enter your favorite colors (separated from each other by a space)."

read -a colors    # Enter at least 3 colors to demonstrate features below.
#  Special option to 'read' command,
#+ allowing assignment of elements in an array.

echo

element_count=${#colors[@]}
# Special syntax to extract number of elements in array.
#     element_count=${#colors[*]} works also.
#
#  The "@" variable allows word splitting within quotes
#+ (extracts variables separated by whitespace).
#
#  This corresponds to the behavior of "$@" and "$*"
#+ in positional parameters. 

index=0

while [ "$index" -lt "$element_count" ]
do    # List all the elements in the array.
  echo ${colors[$index]}
  #    ${colors[index]} also works because it's within ${ ... } brackets.
  let "index = $index + 1"
  # Or:
  #    index+=1
  # if running Bash, version 3.1 or later.
done
# Each array element listed on a separate line.
# If this is not desired, use  echo -n "${colors[$index]} "
#
# Doing it with a "for" loop instead:
#   for i in "${colors[@]}"
#   do
#     echo "$i"
#   done
# (Thanks, S.C.)

echo

# Again, list all the elements in the array, but using a more elegant method.
  echo ${colors[@]}          # echo ${colors[*]} also works.

echo

# The "unset" command deletes elements of an array, or entire array.
unset colors[1]              # Remove 2nd element of array.
                             # Same effect as   colors[1]=
echo  ${colors[@]}           # List array again, missing 2nd element.

unset colors                 # Delete entire array.
                             #  unset colors[*] and
                             #+ unset colors[@] also work.
echo; echo -n "Colors gone."			   
echo ${colors[@]}            # List array again, now empty.

exit 0

As seen in the previous example, either ${array_name[@]} or ${array_name[*]} refers to all the elements of the array. Similarly, to get a count of the number of elements in an array, use either ${#array_name[@]} or ${#array_name[*]}. ${#array_name} is the length (number of characters) of ${array_name[0]}, the first element of the array.

			12.12.10.7 Example 26-7. Of empty arrays and empty elements

#!/bin/bash
# empty-array.sh

#  Thanks to Stephane Chazelas for the original example,
#+ and to Michael Zick, Omair Eshkenazi, for extending it.
#  And to Nathan Coulter for clarifications and corrections.


# An empty array is not the same as an array with empty elements.

  array0=( first second third )
  array1=( '' )   # "array1" consists of one empty element.
  array2=( )      # No elements . . . "array2" is empty.
  array3=(   )    # What about this array?


echo
ListArray()
{
echo
echo "Elements in array0:  ${array0[@]}"
echo "Elements in array1:  ${array1[@]}"
echo "Elements in array2:  ${array2[@]}"
echo "Elements in array3:  ${array3[@]}"
echo
echo "Length of first element in array0 = ${#array0}"
echo "Length of first element in array1 = ${#array1}"
echo "Length of first element in array2 = ${#array2}"
echo "Length of first element in array3 = ${#array3}"
echo
echo "Number of elements in array0 = ${#array0[*]}"  # 3
echo "Number of elements in array1 = ${#array1[*]}"  # 1  (Surprise!)
echo "Number of elements in array2 = ${#array2[*]}"  # 0
echo "Number of elements in array3 = ${#array3[*]}"  # 0
}

# ===================================================================

ListArray

# Try extending those arrays.

# Adding an element to an array.
array0=( "${array0[@]}" "new1" )
array1=( "${array1[@]}" "new1" )
array2=( "${array2[@]}" "new1" )
array3=( "${array3[@]}" "new1" )

ListArray

# or
array0[${#array0[*]}]="new2"
array1[${#array1[*]}]="new2"
array2[${#array2[*]}]="new2"
array3[${#array3[*]}]="new2"

ListArray

# When extended as above, arrays are 'stacks' ...
# Above is the 'push' ...
# The stack 'height' is:
height=${#array2[@]}
echo
echo "Stack height for array2 = $height"

# The 'pop' is:
unset array2[${#array2[@]}-1]   #  Arrays are zero-based,
height=${#array2[@]}            #+ which means first element has index 0.
echo
echo "POP"
echo "New stack height for array2 = $height"

ListArray

# List only 2nd and 3rd elements of array0.
from=1		    # Zero-based numbering.
to=2
array3=( ${array0[@]:1:2} )
echo
echo "Elements in array3:  ${array3[@]}"

# Works like a string (array of characters).
# Try some other "string" forms.

# Replacement:
array4=( ${array0[@]/second/2nd} )
echo
echo "Elements in array4:  ${array4[@]}"

# Replace all matching wildcarded string.
array5=( ${array0[@]//new?/old} )
echo
echo "Elements in array5:  ${array5[@]}"

# Just when you are getting the feel for this . . .
array6=( ${array0[@]#*new} )
echo # This one might surprise you.
echo "Elements in array6:  ${array6[@]}"

array7=( ${array0[@]#new1} )
echo # After array6 this should not be a surprise.
echo "Elements in array7:  ${array7[@]}"

# Which looks a lot like . . .
array8=( ${array0[@]/new1/} )
echo
echo "Elements in array8:  ${array8[@]}"

#  So what can one say about this?

#  The string operations are performed on
#+ each of the elements in var[@] in succession.
#  Therefore : Bash supports string vector operations.
#  If the result is a zero length string,
#+ that element disappears in the resulting assignment.
#  However, if the expansion is in quotes, the null elements remain.

#  Michael Zick: Question, are those strings hard or soft quotes?
#  Nathan Coulter: There is no such thing as "soft quotes."
#  What's really happening is that
#+ the pattern matching happens after all the other expansions of [word]
#+ in cases like ${parameter#word}.


zap='new*'
array9=( ${array0[@]/$zap/} )
echo
echo "Number of elements in array9:  ${#array9[@]}"
array9=( "${array0[@]/$zap/}" )
echo "Elements in array9:  ${array9[@]}"
# This time the null elements remain.
echo "Number of elements in array9:  ${#array9[@]}"


# Just when you thought you were still in Kansas . . .
array10=( ${array0[@]#"$zap"} )
echo
echo "Elements in array10:  ${array10[@]}"
# But, the asterisk in zap won't be interpreted if quoted.
array10=( ${array0[@]#"$zap"} )
echo
echo "Elements in array10:  ${array10[@]}"
# Well, maybe we _are_ still in Kansas . . .
# (Revisions to above code block by Nathan Coulter.)


#  Compare array7 with array10.
#  Compare array8 with array9.

#  Reiterating: No such thing as soft quotes!
#  Nathan Coulter's explains:
#  Pattern matching of 'word' in ${parameter#word} is done after
#+ parameter expansion and *before* quote removal.
#  In the normal case, pattern matching is done *after* quote removal.
 
exit

			12.12.10.8 of ${array_name[@]} and ${array_name[*]} notations

The relationship of ${array_name[@]} and ${array_name[*]} is analogous to that between $@ and $*. This powerful array notation has a number of uses.  
# Copying an array.
array2=( "${array1[@]}" )
# or
array2="${array1[@]}"
#
#  However, this fails with "sparse" arrays,
#+ arrays with holes (missing elements) in them,
#+ as Jochen DeSmet points out.
# ------------------------------------------
  array1[0]=0
# array1[1] not assigned
  array1[2]=2
  array2=( "${array1[@]}" )       # Copy it?

echo ${array2[0]}      # 0
echo ${array2[2]}      # (null), should be 2
# ------------------------------------------



# Adding an element to an array.
array=( "${array[@]}" "new element" )
# or
array[${#array[*]}]="new element"

# Thanks, S.C.

Tip	The array=( element1 element2 ... elementN ) initialization operation, with the help of command substitution, makes it possible to load the contents of a text file into an array.

#!/bin/bash

filename=sample_file

#            cat sample_file
#
#            1 a b c
#            2 d e fg


declare -a array1

array1=( `cat "$filename"`)                #  Loads contents
#         List file to stdout              #+ of $filename into array1.
#
#  array1=( `cat "$filename" | tr '\n' ' '`)
#                            change linefeeds in file to spaces. 
#  Not necessary because Bash does word splitting,
#+ changing linefeeds to spaces.

echo ${array1[@]}            # List the array.
#                              1 a b c 2 d e fg
#
#  Each whitespace-separated "word" in the file
#+ has been assigned to an element of the array.

element_count=${#array1[*]}
echo $element_count          # 8

Clever scripting makes it possible to add array operations.

			12.12.10.9 Example 26-8. Initializing arrays

#! /bin/bash
# array-assign.bash

#  Array operations are Bash-specific,
#+ hence the ".bash" in the script name.

# Copyright (c) Michael S. Zick, 2003, All rights reserved.
# License: Unrestricted reuse in any form, for any purpose.
# Version: $ID$
#
# Clarification and additional comments by William Park.

#  Based on an example provided by Stephane Chazelas
#+ which appeared in the book: Advanced Bash Scripting Guide.

# Output format of the 'times' command:
# User CPU <space> System CPU
# User CPU of dead children <space> System CPU of dead children

#  Bash has two versions of assigning all elements of an array
#+ to a new array variable.
#  Both drop 'null reference' elements
#+ in Bash versions 2.04, 2.05a and 2.05b.
#  An additional array assignment that maintains the relationship of
#+ [subscript]=value for arrays may be added to newer versions.

#  Constructs a large array using an internal command,
#+ but anything creating an array of several thousand elements
#+ will do just fine.

declare -a bigOne=( /dev/* )  # All the files in /dev . . . #*/
echo
echo 'Conditions: Unquoted, default IFS, All-Elements-Of'
echo "Number of elements in array is ${#bigOne[@]}"

# set -vx



echo
echo '- - testing: =( ${array[@]} ) - -'
times
declare -a bigTwo=( ${bigOne[@]} )
# Note parens:    ^              ^
times


echo
echo '- - testing: =${array[@]} - -'
times
declare -a bigThree=${bigOne[@]}
# No parentheses this time.
times

#  Comparing the numbers shows that the second form, pointed out
#+ by Stephane Chazelas, is from three to four times faster.
#
#  As William Park explains:
#+ The bigTwo array assigned element by element (because of parentheses),
#+ whereas bigThree assigned as a single string.
#  So, in essence, you have:
#                   bigTwo=( [0]="..." [1]="..." [2]="..." ... )
#                   bigThree=( [0]="... ... ..." )
#
#  Verify this by:  echo ${bigTwo[0]}
#                   echo ${bigThree[0]}


#  I will continue to use the first form in my example descriptions
#+ because I think it is a better illustration of what is happening.

#  The reusable portions of my examples will actual contain
#+ the second form where appropriate because of the speedup.

# MSZ: Sorry about that earlier oversight folks.


#  Note:
#  ----
#  The "declare -a" statements in lines 31 and 43
#+ are not strictly necessary, since it is implicit
#+ in the  Array=( ... )  assignment form.
#  However, eliminating these declarations slows down
#+ the execution of the following sections of the script.
#  Try it, and see.

exit 0

Note	

Adding a superfluous declare -a statement to an array declaration may speed up execution of subsequent operations on the array.

			12.12.10.10 Example 26-9. Copying and concatenating arrays

#! /bin/bash
# CopyArray.sh
#
# This script written by Michael Zick.
# Used here with permission.

#  How-To "Pass by Name & Return by Name"
#+ or "Building your own assignment statement".


CpArray_Mac() {

# Assignment Command Statement Builder

    echo -n 'eval '
    echo -n "$2"                    # Destination name
    echo -n '=( ${'
    echo -n "$1"                    # Source name
    echo -n '[@]} )'

# That could all be a single command.
# Matter of style only.
}

declare -f CopyArray                # Function "Pointer"
CopyArray=CpArray_Mac               # Statement Builder

Hype()
{

# Hype the array named $1.
# (Splice it together with array containing "Really Rocks".)
# Return in array named $2.

    local -a TMP
    local -a hype=( Really Rocks )

    $($CopyArray $1 TMP)
    TMP=( ${TMP[@]} ${hype[@]} )
    $($CopyArray TMP $2)
}

declare -a before=( Advanced Bash Scripting )
declare -a after

echo "Array Before = ${before[@]}"

Hype before after

echo "Array After = ${after[@]}"

# Too much hype?

echo "What ${after[@]:3:2}?"

declare -a modest=( ${after[@]:2:1} ${after[@]:3:2} )
#                    ---- substring extraction ----

echo "Array Modest = ${modest[@]}"

# What happened to 'before' ?

echo "Array Before = ${before[@]}"

exit 0

			12.12.10.11 Example 26-10. More on concatenating arrays

#! /bin/bash
# array-append.bash

# Copyright (c) Michael S. Zick, 2003, All rights reserved.
# License: Unrestricted reuse in any form, for any purpose.
# Version: $ID$
#
# Slightly modified in formatting by M.C.


# Array operations are Bash-specific.
# Legacy UNIX /bin/sh lacks equivalents.


#  Pipe the output of this script to 'more'
#+ so it doesn't scroll off the terminal.


# Subscript packed.
declare -a array1=( zero1 one1 two1 )
# Subscript sparse ([1] is not defined).
declare -a array2=( [0]=zero2 [2]=two2 [3]=three2 )

echo
echo '- Confirm that the array is really subscript sparse. -'
echo "Number of elements: 4"        # Hard-coded for illustration.
for (( i = 0 ; i < 4 ; i++ ))
do
    echo "Element [$i]: ${array2[$i]}"
done
# See also the more general code example in basics-reviewed.bash.


declare -a dest

# Combine (append) two arrays into a third array.
echo
echo 'Conditions: Unquoted, default IFS, All-Elements-Of operator'
echo '- Undefined elements not present, subscripts not maintained. -'
# # The undefined elements do not exist; they are not being dropped.

dest=( ${array1[@]} ${array2[@]} )
# dest=${array1[@]}${array2[@]}     # Strange results, possibly a bug.

# Now, list the result.
echo
echo '- - Testing Array Append - -'
cnt=${#dest[@]}

echo "Number of elements: $cnt"
for (( i = 0 ; i < cnt ; i++ ))
do
    echo "Element [$i]: ${dest[$i]}"
done

# Assign an array to a single array element (twice).
dest[0]=${array1[@]}
dest[1]=${array2[@]}

# List the result.
echo
echo '- - Testing modified array - -'
cnt=${#dest[@]}

echo "Number of elements: $cnt"
for (( i = 0 ; i < cnt ; i++ ))
do
    echo "Element [$i]: ${dest[$i]}"
done

# Examine the modified second element.
echo
echo '- - Reassign and list second element - -'

declare -a subArray=${dest[1]}
cnt=${#subArray[@]}

echo "Number of elements: $cnt"
for (( i = 0 ; i < cnt ; i++ ))
do
    echo "Element [$i]: ${subArray[$i]}"
done

#  The assignment of an entire array to a single element
#+ of another array using the '=${ ... }' array assignment
#+ has converted the array being assigned into a string,
#+ with the elements separated by a space (the first character of IFS).

# If the original elements didn't contain whitespace . . .
# If the original array isn't subscript sparse . . .
# Then we could get the original array structure back again.

# Restore from the modified second element.
echo
echo '- - Listing restored element - -'

declare -a subArray=( ${dest[1]} )
cnt=${#subArray[@]}

echo "Number of elements: $cnt"
for (( i = 0 ; i < cnt ; i++ ))
do
    echo "Element [$i]: ${subArray[$i]}"
done
echo '- - Do not depend on this behavior. - -'
echo '- - This behavior is subject to change - -'
echo '- - in versions of Bash newer than version 2.05b - -'

# MSZ: Sorry about any earlier confusion folks.

exit 0

--

Arrays permit deploying old familiar algorithms as shell scripts. Whether this is necessarily a good idea is left to the reader to decide.

			12.12.10.12 Example 26-11. The Bubble Sort

#!/bin/bash
# bubble.sh: Bubble sort, of sorts.

# Recall the algorithm for a bubble sort. In this particular version...

#  With each successive pass through the array to be sorted,
#+ compare two adjacent elements, and swap them if out of order.
#  At the end of the first pass, the "heaviest" element has sunk to bottom.
#  At the end of the second pass, the next "heaviest" one has sunk next to bottom.
#  And so forth.
#  This means that each successive pass needs to traverse less of the array.
#  You will therefore notice a speeding up in the printing of the later passes.


exchange()
{
  # Swaps two members of the array.
  local temp=${Countries[$1]} #  Temporary storage
                              #+ for element getting swapped out.
  Countries[$1]=${Countries[$2]}
  Countries[$2]=$temp
  
  return
}  

declare -a Countries  #  Declare array,
                      #+ optional here since it's initialized below.

#  Is it permissable to split an array variable over multiple lines
#+ using an escape (\)?
#  Yes.

Countries=(Netherlands Ukraine Zaire Turkey Russia Yemen Syria \
Brazil Argentina Nicaragua Japan Mexico Venezuela Greece England \
Israel Peru Canada Oman Denmark Wales France Kenya \
Xanadu Qatar Liechtenstein Hungary)

# "Xanadu" is the mythical place where, according to Coleridge,
#+ Kubla Khan did a pleasure dome decree.


clear                      # Clear the screen to start with. 

echo "0: ${Countries[*]}"  # List entire array at pass 0.

number_of_elements=${#Countries[@]}
let "comparisons = $number_of_elements - 1"

count=1 # Pass number.

while [ "$comparisons" -gt 0 ]          # Beginning of outer loop
do

  index=0  # Reset index to start of array after each pass.

  while [ "$index" -lt "$comparisons" ] # Beginning of inner loop
  do
    if [ ${Countries[$index]} \> ${Countries[`expr $index + 1`]} ]
    #  If out of order...
    #  Recalling that \> is ASCII comparison operator
    #+ within single brackets.

    #  if [[ ${Countries[$index]} > ${Countries[`expr $index + 1`]} ]]
    #+ also works.
    then
      exchange $index `expr $index + 1`  # Swap.
    fi  
    let "index += 1"  # Or,   index+=1   on Bash, ver. 3.1 or newer.
  done # End of inner loop

# ----------------------------------------------------------------------
# Paulo Marcel Coelho Aragao suggests for-loops as a simpler altenative.
#
# for (( last = $number_of_elements - 1 ; last > 0 ; last-- ))
##                     Fix by C.Y. Hunt          ^   (Thanks!)
# do
#     for (( i = 0 ; i < last ; i++ ))
#     do
#         [[ "${Countries[$i]}" > "${Countries[$((i+1))]}" ]] \
#             && exchange $i $((i+1))
#     done
# done
# ----------------------------------------------------------------------
  

let "comparisons -= 1" #  Since "heaviest" element bubbles to bottom,
                       #+ we need do one less comparison each pass.

echo
echo "$count: ${Countries[@]}"  # Print resultant array at end of each pass.
echo
let "count += 1"                # Increment pass count.

done                            # End of outer loop
                                # All done.

exit 0

--

			12.12.10.13 Is it possible to nest arrays within arrays?

#!/bin/bash
# "Nested" array.

#  Michael Zick provided this example,
#+ with corrections and clarifications by William Park.

AnArray=( $(ls --inode --ignore-backups --almost-all \
	--directory --full-time --color=none --time=status \
	--sort=time -l ${PWD} ) )  # Commands and options.

# Spaces are significant . . . and don't quote anything in the above.

SubArray=( ${AnArray[@]:11:1}  ${AnArray[@]:6:5} )
#  This array has six elements:
#+     SubArray=( [0]=${AnArray[11]} [1]=${AnArray[6]} [2]=${AnArray[7]}
#      [3]=${AnArray[8]} [4]=${AnArray[9]} [5]=${AnArray[10]} )
#
#  Arrays in Bash are (circularly) linked lists
#+ of type string (char *).
#  So, this isn't actually a nested array,
#+ but it's functionally similar.

echo "Current directory and date of last status change:"
echo "${SubArray[@]}"

exit 0

--

Embedded arrays in combination with indirect references create some fascinating possibilities

			12.12.10.14 Example 26-12. Embedded arrays and indirect references

#!/bin/bash
# embedded-arrays.sh
# Embedded arrays and indirect references.

# This script by Dennis Leeuw.
# Used with permission.
# Modified by document author.


ARRAY1=(
        VAR1_1=value11
        VAR1_2=value12
        VAR1_3=value13
)

ARRAY2=(
        VARIABLE="test"
        STRING="VAR1=value1 VAR2=value2 VAR3=value3"
        ARRAY21=${ARRAY1[*]}
)       # Embed ARRAY1 within this second array.

function print () {
        OLD_IFS="$IFS"
        IFS=$'\n'       #  To print each array element
                        #+ on a separate line.
        TEST1="ARRAY2[*]"
        local ${!TEST1} # See what happens if you delete this line.
        #  Indirect reference.
	#  This makes the components of $TEST1
	#+ accessible to this function.


        #  Let's see what we've got so far.
        echo
        echo "\$TEST1 = $TEST1"       #  Just the name of the variable.
        echo; echo
        echo "{\$TEST1} = ${!TEST1}"  #  Contents of the variable.
                                      #  That's what an indirect
                                      #+ reference does.
        echo
        echo "-------------------------------------------"; echo
        echo


        # Print variable
        echo "Variable VARIABLE: $VARIABLE"
	
        # Print a string element
        IFS="$OLD_IFS"
        TEST2="STRING[*]"
        local ${!TEST2}      # Indirect reference (as above).
        echo "String element VAR2: $VAR2 from STRING"

        # Print an array element
        TEST2="ARRAY21[*]"
        local ${!TEST2}      # Indirect reference (as above).
        echo "Array element VAR1_1: $VAR1_1 from ARRAY21"
}

print
echo

exit 0

#   As the author of the script notes,
#+ "you can easily expand it to create named-hashes in bash."
#   (Difficult) exercise for the reader: implement this.

--

Arrays enable implementing a shell script version of the Sieve of Eratosthenes. Of course, a resource-intensive application of this nature should really be written in a compiled language, such as C. It runs excruciatingly slowly as a script.

			12.12.10.15 Example 26-13. The Sieve of Eratosthenes

#!/bin/bash
# sieve.sh (ex68.sh)

# Sieve of Eratosthenes
# Ancient algorithm for finding prime numbers.

#  This runs a couple of orders of magnitude slower
#+ than the equivalent program written in C.

LOWER_LIMIT=1       # Starting with 1.
UPPER_LIMIT=1000    # Up to 1000.
# (You may set this higher . . . if you have time on your hands.)

PRIME=1
NON_PRIME=0

let SPLIT=UPPER_LIMIT/2
# Optimization:
# Need to test numbers only halfway to upper limit (why?).


declare -a Primes
# Primes[] is an array.


initialize ()
{
# Initialize the array.

i=$LOWER_LIMIT
until [ "$i" -gt "$UPPER_LIMIT" ]
do
  Primes[i]=$PRIME
  let "i += 1"
done
#  Assume all array members guilty (prime)
#+ until proven innocent.
}

print_primes ()
{
# Print out the members of the Primes[] array tagged as prime.

i=$LOWER_LIMIT

until [ "$i" -gt "$UPPER_LIMIT" ]
do

  if [ "${Primes[i]}" -eq "$PRIME" ]
  then
    printf "%8d" $i
    # 8 spaces per number gives nice, even columns.
  fi
  
  let "i += 1"
  
done

}

sift () # Sift out the non-primes.
{

let i=$LOWER_LIMIT+1
# We know 1 is prime, so let's start with 2.

until [ "$i" -gt "$UPPER_LIMIT" ]
do

if [ "${Primes[i]}" -eq "$PRIME" ]
# Don't bother sieving numbers already sieved (tagged as non-prime).
then

  t=$i

  while [ "$t" -le "$UPPER_LIMIT" ]
  do
    let "t += $i "
    Primes[t]=$NON_PRIME
    # Tag as non-prime all multiples.
  done

fi  

  let "i += 1"
done  


}


# ==============================================
# main ()
# Invoke the functions sequentially.
initialize
sift
print_primes
# This is what they call structured programming.
# ==============================================

echo

exit 0



# -------------------------------------------------------- #
# Code below line will not execute, because of 'exit.'

#  This improved version of the Sieve, by Stephane Chazelas,
#+ executes somewhat faster.

# Must invoke with command-line argument (limit of primes).

UPPER_LIMIT=$1                  # From command line.
let SPLIT=UPPER_LIMIT/2         # Halfway to max number.

Primes=( '' $(seq $UPPER_LIMIT) )

i=1
until (( ( i += 1 ) > SPLIT ))  # Need check only halfway.
do
  if [[ -n $Primes[i] ]]
  then
    t=$i
    until (( ( t += i ) > UPPER_LIMIT ))
    do
      Primes[t]=
    done
  fi  
done  
echo ${Primes[*]}

exit $?

Example 26-14. The Sieve of Eratosthenes, Optimized

#!/bin/bash
# Optimized Sieve of Eratosthenes
# Script by Jared Martin, with very minor changes by ABS Guide author.
# Used in ABS Guide with permission (thanks!).

# Based on script in Advanced Bash Scripting Guide.
# http://tldp.org/LDP/abs/html/arrays.html#PRIMES0 (ex68.sh).

# http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf (reference)
# Check results against http://primes.utm.edu/lists/small/1000.txt

# Necessary but not sufficient would be, e.g.,
#     (($(sieve 7919 | wc -w) == 1000)) && echo "7919 is the 1000th prime"

UPPER_LIMIT=${1:?"Need an upper limit of primes to search."}

Primes=( '' $(seq ${UPPER_LIMIT}) )

typeset -i i t
Primes[i=1]='' # 1 is not a prime.
until (( ( i += 1 ) > (${UPPER_LIMIT}/i) ))  # Need check only ith-way.
  do                                         # Why?
    if ((${Primes[t=i*(i-1), i]}))
    # Obscure, but instructive, use of arithmetic expansion in subscript.
    then
      until (( ( t += i ) > ${UPPER_LIMIT} ))
        do Primes[t]=; done
    fi
  done

# echo ${Primes[*]}
echo   # Change to original script for pretty-printing (80-col. display).
printf "%8d" ${Primes[*]}
echo; echo

exit $?

Compare these array-based prime number generators with an alternative that does not use arrays, Example A-16.

--

Arrays lend themselves, to some extent, to emulating data structures for which Bash has no native support.

			12.12.10.16 Example 26-15. Emulating a push-down stack

#!/bin/bash
# stack.sh: push-down stack simulation

#  Similar to the CPU stack, a push-down stack stores data items
#+ sequentially, but releases them in reverse order, last-in first-out.

BP=100            #  Base Pointer of stack array.
                  #  Begin at element 100.

SP=$BP            #  Stack Pointer.
                  #  Initialize it to "base" (bottom) of stack.

Data=             #  Contents of stack location.  
                  #  Must use global variable,
                  #+ because of limitation on function return range.

declare -a stack


push()            # Push item on stack.
{
if [ -z "$1" ]    # Nothing to push?
then
  return
fi

let "SP -= 1"     # Bump stack pointer.
stack[$SP]=$1

return
}

pop()                    # Pop item off stack.
{
Data=                    # Empty out data item.

if [ "$SP" -eq "$BP" ]   # Stack empty?
then
  return
fi                       #  This also keeps SP from getting past 100,
                         #+ i.e., prevents a runaway stack.

Data=${stack[$SP]}
let "SP += 1"            # Bump stack pointer.
return
}

status_report()          # Find out what's happening.
{
echo "-------------------------------------"
echo "REPORT"
echo "Stack Pointer = $SP"
echo "Just popped \""$Data"\" off the stack."
echo "-------------------------------------"
echo
}


# =======================================================
# Now, for some fun.

echo

# See if you can pop anything off empty stack.
pop
status_report

echo

push garbage
pop
status_report     # Garbage in, garbage out.      

value1=23; push $value1
value2=skidoo; push $value2
value3=FINAL; push $value3

pop              # FINAL
status_report
pop              # skidoo
status_report
pop              # 23
status_report    # Last-in, first-out!

#  Notice how the stack pointer decrements with each push,
#+ and increments with each pop.

echo

exit 0

# =======================================================


# Exercises:
# ---------

# 1)  Modify the "push()" function to permit pushing
#   + multiple element on the stack with a single function call.

# 2)  Modify the "pop()" function to permit popping
#   + multiple element from the stack with a single function call.

# 3)  Add error checking to the critical functions.
#     That is, return an error code, depending on
#   + successful or unsuccessful completion of the operation,
#   + and take appropriate action.

# 4)  Using this script as a starting point,
#   + write a stack-based 4-function calculator.

--

Fancy manipulation of array "subscripts" may require intermediate variables. For projects involving this, again consider using a more powerful programming language, such as Perl or C.

			12.12.10.17 Example 26-16. Complex array application: Exploring a weird mathematical series

#!/bin/bash

# Douglas Hofstadter's notorious "Q-series":

# Q(1) = Q(2) = 1
# Q(n) = Q(n - Q(n-1)) + Q(n - Q(n-2)), for n>2

#  This is a "chaotic" integer series with strange
#+ and unpredictable behavior.
#  The first 20 terms of the series are:
#  1 1 2 3 3 4 5 5 6 6 6 8 8 8 10 9 10 11 11 12 

#  See Hofstadter's book, _Goedel, Escher, Bach: An Eternal Golden Braid_,
#+ p. 137, ff.


LIMIT=100     # Number of terms to calculate.
LINEWIDTH=20  # Number of terms printed per line.

Q[1]=1        # First two terms of series are 1.
Q[2]=1

echo
echo "Q-series [$LIMIT terms]:"
echo -n "${Q[1]} "             # Output first two terms.
echo -n "${Q[2]} "

for ((n=3; n <= $LIMIT; n++))  # C-like loop expression.
do   # Q[n] = Q[n - Q[n-1]] + Q[n - Q[n-2]]  for n>2
#    Need to break the expression into intermediate terms,
#+   since Bash doesn't handle complex array arithmetic very well.

  let "n1 = $n - 1"        # n-1
  let "n2 = $n - 2"        # n-2
  
  t0=`expr $n - ${Q[n1]}`  # n - Q[n-1]
  t1=`expr $n - ${Q[n2]}`  # n - Q[n-2]
  
  T0=${Q[t0]}              # Q[n - Q[n-1]]
  T1=${Q[t1]}              # Q[n - Q[n-2]]

Q[n]=`expr $T0 + $T1`      # Q[n - Q[n-1]] + Q[n - Q[n-2]]
echo -n "${Q[n]} "

if [ `expr $n % $LINEWIDTH` -eq 0 ]    # Format output.
then   #      ^ modulo
  echo # Break lines into neat chunks.
fi

done

echo

exit 0

#  This is an iterative implementation of the Q-series.
#  The more intuitive recursive implementation is left as an exercise.
#  Warning: calculating this series recursively takes a VERY long time
#+ via a script. C/C++ would be orders of magnitude faster.

--

Bash supports only one-dimensional arrays, though a little trickery permits simulating multi-dimensional ones.

			12.12.10.18 Example 26-17. Simulating a two-dimensional array, then tilting it

#!/bin/bash
# twodim.sh: Simulating a two-dimensional array.

# A one-dimensional array consists of a single row.
# A two-dimensional array stores rows sequentially.

Rows=5
Columns=5
# 5 X 5 Array.

declare -a alpha     # char alpha [Rows] [Columns];
                     # Unnecessary declaration. Why?

load_alpha ()
{
local rc=0
local index

for i in A B C D E F G H I J K L M N O P Q R S T U V W X Y
do     # Use different symbols if you like.
  local row=`expr $rc / $Columns`
  local column=`expr $rc % $Rows`
  let "index = $row * $Rows + $column"
  alpha[$index]=$i
# alpha[$row][$column]
  let "rc += 1"
done  

#  Simpler would be
#+   declare -a alpha=( A B C D E F G H I J K L M N O P Q R S T U V W X Y )
#+ but this somehow lacks the "flavor" of a two-dimensional array.
}

print_alpha ()
{
local row=0
local index

echo

while [ "$row" -lt "$Rows" ]   #  Print out in "row major" order:
do                             #+ columns vary,
                               #+ while row (outer loop) remains the same.
  local column=0

  echo -n "       "            #  Lines up "square" array with rotated one.
  
  while [ "$column" -lt "$Columns" ]
  do
    let "index = $row * $Rows + $column"
    echo -n "${alpha[index]} "  # alpha[$row][$column]
    let "column += 1"
  done

  let "row += 1"
  echo

done  

# The simpler equivalent is
#     echo ${alpha[*]} | xargs -n $Columns

echo
}

filter ()     # Filter out negative array indices.
{

echo -n "  "  # Provides the tilt.
              # Explain how.

if [[ "$1" -ge 0 &&  "$1" -lt "$Rows" && "$2" -ge 0 && "$2" -lt "$Columns" ]]
then
    let "index = $1 * $Rows + $2"
    # Now, print it rotated.
    echo -n " ${alpha[index]}"
    #           alpha[$row][$column]
fi    

}
  



rotate ()  #  Rotate the array 45 degrees --
{          #+ "balance" it on its lower lefthand corner.
local row
local column

for (( row = Rows; row > -Rows; row-- ))
  do       # Step through the array backwards. Why?

  for (( column = 0; column < Columns; column++ ))
  do

    if [ "$row" -ge 0 ]
    then
      let "t1 = $column - $row"
      let "t2 = $column"
    else
      let "t1 = $column"
      let "t2 = $column + $row"
    fi  

    filter $t1 $t2   # Filter out negative array indices.
                     # What happens if you don't do this?
  done

  echo; echo

done 

#  Array rotation inspired by examples (pp. 143-146) in
#+ "Advanced C Programming on the IBM PC," by Herbert Mayer
#+ (see bibliography).
#  This just goes to show that much of what can be done in C
#+ can also be done in shell scripting.

}


#--------------- Now, let the show begin. ------------#
load_alpha     # Load the array.
print_alpha    # Print it out.  
rotate         # Rotate it 45 degrees counterclockwise.
#-----------------------------------------------------#

exit 0

# This is a rather contrived, not to mention inelegant simulation.

# Exercises:
# ---------
# 1)  Rewrite the array loading and printing functions
#     in a more intuitive and less kludgy fashion.
#
# 2)  Figure out how the array rotation functions work.
#     Hint: think about the implications of backwards-indexing an array.
#
# 3)  Rewrite this script to handle a non-square array,
#     such as a 6 X 4 one.
#     Try to minimize "distortion" when the array is rotated.

A two-dimensional array is essentially equivalent to a one-dimensional one, but with additional addressing modes for referencing and manipulating the individual elements by row and column position.

		12.12.11 Chapter 27. /dev and /proc

			12.12.11.1  /dev
The /dev directory contains entries for the physical devices  that may or may not be present in the hardware. [1]  For example, the hard drive partitions containing the mounted filesystem(s) have entries in /dev, as df shows.

bash$ df
Filesystem           1k-blocks      Used Available Use%
 Mounted on
 /dev/hda6               495876    222748    247527  48% /
 /dev/hda1                50755      3887     44248   9% /boot
 /dev/hda8               367013     13262    334803   4% /home
 /dev/hda5              1714416   1123624    503704  70% /usr
	      

				12.12.11.1.1  loopback devices


Among other things, the /dev directory contains loopback devices, such as /dev/loop0. A loopback device is a gimmick that allows an ordinary file to be accessed as if it were a block device. [2] This permits mounting an entire filesystem within a single large file. See Example 16-8 and Example 16-7.

A few of the pseudo-devices in /dev have other specialized uses, such as /dev/null, /dev/zero, /dev/urandom, /dev/sda1 (hard drive partition), /dev/udp (User Datagram Packet port), and /dev/tcp.

For instance:

				12.12.11.1.2 To mount a USB flash drive, 
				append the following line to /etc/fstab. [3]

/dev/sda1    /mnt/flashdrive    auto    noauto,user,noatime    0 0

(See also Example A-25.)

Checking whether a disk is in the CD-burner (soft-linked to /dev/hdc):

head -1 /dev/hdc


#  head: cannot open '/dev/hdc' for reading: No medium found
#  (No disc in the drive.)

#  head: error reading '/dev/hdc': Input/output error
#  (There is a disk in the drive, but it can't be read;
#+  possibly it's an unrecorded CDR blank.)   

#  Stream of characters and assorted gibberish
#  (There is a pre-recorded disk in the drive,
#+ and this is raw output -- a stream of ASCII and binary data.)
#  Here we see the wisdom of using 'head' to limit the output
#+ to manageable proportions, rather than 'cat' or something similar.


#  Now, it's just a matter of checking/parsing the output and taking
#+ appropriate action.

				12.12.11.1.3  /dev/tcp/$host/$port
When executing a command on a /dev/tcp/$host/$port pseudo-device file, Bash opens a TCP connection to the associated socket.

A socket is a communications node associated with a specific I/O port. (This is analogous to a hardware socket, or receptacle, for a connecting cable.) It permits data transfer between hardware devices on the same machine, between machines on the same network, between machines across different networks, and, of course, between machines at different locations on the Internet.

The following examples assume an active Internet connection.

Getting the time from nist.gov:

bash$ cat </dev/tcp/time.nist.gov/13
53082 04-03-18 04:26:54 68 0 0 502.3 UTC(NIST) *
	      

[Mark contributed the above example.]

Downloading a URL:

bash$ exec 5<>/dev/tcp/www.net.cn/80
bash$ echo -e "GET / HTTP/1.0\n" >&5
bash$ cat <&5
	      

[Thanks, Mark and Mihai Maties.]

				12.12.11.1.4 Example 27-1. Using /dev/tcp for troubleshooting

#!/bin/bash
# dev-tcp.sh: /dev/tcp redirection to check Internet connection.

# Script by Troy Engel.
# Used with permission.
 
TCP_HOST=www.dns-diy.com   # A known spam-friendly ISP.
TCP_PORT=80                # Port 80 is http.
  
# Try to connect. (Somewhat similar to a 'ping' . . .) 
echo "HEAD / HTTP/1.0" >/dev/tcp/${TCP_HOST}/${TCP_PORT}
MYEXIT=$?

: <<EXPLANATION
If bash was compiled with --enable-net-redirections, it has the capability of
using a special character device for both TCP and UDP redirections. These
redirections are used identically as STDIN/STDOUT/STDERR. The device entries
are 30,36 for /dev/tcp:

  mknod /dev/tcp c 30 36

>From the bash reference:
/dev/tcp/host/port
    If host is a valid hostname or Internet address, and port is an integer
port number or service name, Bash attempts to open a TCP connection to the
corresponding socket.
EXPLANATION

   
if [ "X$MYEXIT" = "X0" ]; then
  echo "Connection successful. Exit code: $MYEXIT"
else
  echo "Connection unsuccessful. Exit code: $MYEXIT"
fi

exit $MYEXIT

				12.12.11.1.5 Example 27-2. Playing music

#!/bin/bash
# music.sh

# MUSIC WITHOUT EXTERNAL FILES

# Author: Antonio Macchi
# Used in ABS Guide with permission


#  /dev/dsp default = 8000 frames per second, 8 bits per frame (1 byte),
#+ 1 channel (mono)

duration=2000       # If 8000 bytes = 1 second, then 2000 = 1/4 second.
volume=$'\xc0'      # Max volume = \xff (or \x00).
mute=$'\x80'        # No volume = \x80 (the middle).

function mknote ()  # $1=Note Hz in bytes (e.g. A = 440Hz ::
                    #+ 8000 fps / 440 = 16 :: A = 16 bytes per second)
{
  for t in `seq 0 $duration`
  do
    test $(( $t % $1 )) = 0 && echo -n $volume || echo -n $mute
  done
 
}

e=`mknote 49`
g=`mknote 41`
a=`mknote 36`
b=`mknote 32`
c=`mknote 30`
cis=`mknote 29`
d=`mknote 27`
e2=`mknote 24`
n=`mknote 32767`
# European notation.

echo -n "$g$e2$d$c$d$c$a$g$n$g$e$n$g$e2$d$c$c$b$c$cis$n$cis$d \
$n$g$e2$d$c$d$c$a$g$n$g$e$n$g$a$d$c$b$a$b$c" > /dev/dsp
# dsp = Digital Signal Processor

exit $?   # A "bonny" example of a shell script!"

Notes
[1]	The entries in /dev provide mount points for physical and virtual devices. These entries use very little drive space.

Some devices, such as /dev/null, /dev/zero, and /dev/urandom are virtual. They are not actual physical devices and exist only in software.
[2]	A block device reads and/or writes data in chunks, or blocks, in contrast to a character device, which acesses data in character units. Examples of block devices are hard drives, CDROM drives, and flash drives. Examples of character devices are keyboards, modems, sound cards.
[3]	Of course, the mount point /mnt/flashdrive must exist. If not, then, as root, mkdir /mnt/flashdrive.

To actually mount the drive, use the following command: mount /mnt/flashdrive

Newer Linux distros automount flash drives in the /media directory without user intervention.

			12.12.11.2 /proc
The /proc directory is actually a pseudo-filesystem. The files in /proc mirror currently running system and kernel processes  and contain information and statistics about them.

				12.12.11.2.1  Devices


bash$ cat /proc/devices
Character devices:
|   1 mem
|   2 pty
|   3 ttyp
|   4 ttyS
|   5 cua
|   7 vcs
|  10 misc
|  14 sound
|  29 fb
|  36 netlink
| 128 ptm
| 136 pts
| 162 raw
| 254 pcmcia

 Block devices:
|   1 ramdisk
|   2 fd
|   3 ide0
|   9 md



				12.12.11.2.2 interrupts
bash$ cat /proc/interrupts
           CPU0       
|   0:      84505          XT-PIC  timer
|   1:       3375          XT-PIC  keyboard
|   2:          0          XT-PIC  cascade
|   5:          1          XT-PIC  soundblaster
|   8:          1          XT-PIC  rtc
|  12:       4231          XT-PIC  PS/2 Mouse
|  14:     109373          XT-PIC  ide0
 NMI:          0 
 ERR:          0


				12.12.11.2.3 partitions
bash$ cat /proc/partitions
major minor  #blocks  name     rio rmerge rsect ruse wio wmerge wsect wuse running use aveq

|    3     0    3007872 hda 4472 22260 114520 94240 3551 18703 50384 549710 0 111550 644030
|    3     1      52416 hda1 27 395 844 960 4 2 14 180 0 800 1140
|    3     2          1 hda2 0 0 0 0 0 0 0 0 0 0 0
|    3     4     165280 hda4 10 0 20 210 0 0 0 0 0 210 210
    ...



				12.12.11.2.4 more /proc
bash$ cat /proc/loadavg
|0.13 0.42 0.27 2/44 1119



bash$ cat /proc/apm
|1.16 1.2 0x03 0x01 0xff 0x80 -1% -1 ?



				12.12.11.2.5 battery

bash$ cat /proc/acpi/battery/BAT0/info
present:                 yes
 design capacity:         43200 mWh
 last full capacity:      36640 mWh
 battery technology:      rechargeable
 design voltage:          10800 mV
 design capacity warning: 1832 mWh
 design capacity low:     200 mWh
 capacity granularity 1:  1 mWh
 capacity granularity 2:  1 mWh
 model number:            IBM-02K6897
 serial number:            1133
 battery type:            LION
 OEM info:                Panasonic
 
 
 
				12.12.11.2.6 Memory
bash$ fgrep Mem /proc/meminfo
MemTotal:       515216 kB
 MemFree:        266248 kB
         

				12.12.11.2.7 Extract info from /proc
Shell scripts may extract data from certain of the files in /proc. [1]

FS=iso                       # ISO filesystem support in kernel?

grep $FS /proc/filesystems   # iso9660

kernel_version=$( awk '{ print $3 }' /proc/version )

CPU=$( awk '/model name/ {print $5}' < /proc/cpuinfo )

if [ "$CPU" = "Pentium(R)" ]
then
  run_some_commands
  ...
else
  run_other_commands
  ...
fi



cpu_speed=$( fgrep "cpu MHz" /proc/cpuinfo | awk '{print $4}' )
#  Current operating speed (in MHz) of the cpu on your machine.
#  On a laptop this may vary, depending on use of battery
#+ or AC power.

#!/bin/bash
# get-commandline.sh
# Get the command-line parameters of a process.

OPTION=cmdline

# Identify PID.
pid=$( echo $(pidof "$1") | awk '{ print $1 }' )
# Get only first            ^^^^^^^^^^^^^^^^^^ of multiple instances.

echo
echo "Process ID of (first instance of) "$1" = $pid"
echo -n "Command-line arguments: "
cat /proc/"$pid"/"$OPTION" | xargs -0 echo
#   Formats output:        ^^^^^^^^^^^^^^^
#   (Thanks, Han Holl, for the fixup!)

echo; echo


# For example:
# sh get-commandline.sh xterm

+

devfile="/proc/bus/usb/devices"
text="Spd"
USB1="Spd=12"
USB2="Spd=480"


bus_speed=$(fgrep -m 1 "$text" $devfile | awk '{print $9}')
#                 ^^^^ Stop after first match.

if [ "$bus_speed" = "$USB1" ]
then
  echo "USB 1.1 port found."
  # Do something appropriate for USB 1.1.
fi

Note	

It is even possible to control certain peripherals with commands sent to the /proc directory.

	  root# echo on > /proc/acpi/ibm/light
          

This turns on the Thinklight in certain models of IBM/Lenovo Thinkpads. (May not work on all Linux distros.)

Of course, caution is advised when writing to /proc.

The /proc directory contains subdirectories with unusual numerical names. Every one of these names maps to the process ID of a currently running process. Within each of these subdirectories, there are a number of files that hold useful information about the corresponding process. The stat and status files keep running statistics on the process, the cmdline file holds the command-line arguments the process was invoked with, and the exe file is a symbolic link to the complete path name of the invoking process. There are a few more such files, but these seem to be the most interesting from a scripting standpoint.

Example 27-3. Finding the process associated with a PID

#!/bin/bash
# pid-identifier.sh:
# Gives complete path name to process associated with pid.

ARGNO=1  # Number of arguments the script expects.
E_WRONGARGS=65
E_BADPID=66
E_NOSUCHPROCESS=67
E_NOPERMISSION=68
PROCFILE=exe

if [ $# -ne $ARGNO ]
then
  echo "Usage: `basename $0` PID-number" >&2  # Error message >stderr.
  exit $E_WRONGARGS
fi  

pidno=$( ps ax | grep $1 | awk '{ print $1 }' | grep $1 )
# Checks for pid in "ps" listing, field #1.
# Then makes sure it is the actual process, not the process invoked by this script.
# The last "grep $1" filters out this possibility.
#
#    pidno=$( ps ax | awk '{ print $1 }' | grep $1 )
#    also works, as Teemu Huovila, points out.

if [ -z "$pidno" ]  #  If, after all the filtering, the result is a zero-length string,
then                #+ no running process corresponds to the pid given.
  echo "No such process running."
  exit $E_NOSUCHPROCESS
fi  

# Alternatively:
#   if ! ps $1 > /dev/null 2>&1
#   then                # no running process corresponds to the pid given.
#     echo "No such process running."
#     exit $E_NOSUCHPROCESS
#    fi

# To simplify the entire process, use "pidof".


if [ ! -r "/proc/$1/$PROCFILE" ]  # Check for read permission.
then
  echo "Process $1 running, but..."
  echo "Can't get read permission on /proc/$1/$PROCFILE."
  exit $E_NOPERMISSION  # Ordinary user can't access some files in /proc.
fi  

# The last two tests may be replaced by:
#    if ! kill -0 $1 > /dev/null 2>&1 # '0' is not a signal, but
                                      # this will test whether it is possible
                                      # to send a signal to the process.
#    then echo "PID doesn't exist or you're not its owner" >&2
#    exit $E_BADPID
#    fi



exe_file=$( ls -l /proc/$1 | grep "exe" | awk '{ print $11 }' )
# Or       exe_file=$( ls -l /proc/$1/exe | awk '{print $11}' )
#
#  /proc/pid-number/exe is a symbolic link
#+ to the complete path name of the invoking process.

if [ -e "$exe_file" ]  #  If /proc/pid-number/exe exists,
then                   #+ then the corresponding process exists.
  echo "Process #$1 invoked by $exe_file."
else
  echo "No such process running."
fi  


#  This elaborate script can *almost* be replaced by
#       ps ax | grep $1 | awk '{ print $5 }'
#  However, this will not work...
#+ because the fifth field of 'ps' is argv[0] of the process,
#+ not the executable file path.
#
# However, either of the following would work.
#       find /proc/$1/exe -printf '%l\n'
#       lsof -aFn -p $1 -d txt | sed -ne 's/^n//p'

# Additional commentary by Stephane Chazelas.

exit 0

Example 27-4. On-line connect status

#!/bin/bash

PROCNAME=pppd        # ppp daemon
PROCFILENAME=status  # Where to look.
NOTCONNECTED=65
INTERVAL=2           # Update every 2 seconds.

pidno=$( ps ax | grep -v "ps ax" | grep -v grep | grep $PROCNAME |
awk '{ print $1 }' )

# Finding the process number of 'pppd', the 'ppp daemon'.
# Have to filter out the process lines generated by the search itself.
#
#  However, as Oleg Philon points out,
#+ this could have been considerably simplified by using "pidof".
#  pidno=$( pidof $PROCNAME )
#
#  Moral of the story:
#+ When a command sequence gets too complex, look for a shortcut.


if [ -z "$pidno" ]   # If no pid, then process is not running.
then
  echo "Not connected."
  exit $NOTCONNECTED
else
  echo "Connected."; echo
fi

while [ true ]       # Endless loop, script can be improved here.
do

  if [ ! -e "/proc/$pidno/$PROCFILENAME" ]
  # While process running, then "status" file exists.
  then
    echo "Disconnected."
    exit $NOTCONNECTED
  fi

netstat -s | grep "packets received"  # Get some connect statistics.
netstat -s | grep "packets delivered"


  sleep $INTERVAL
  echo; echo

done

exit 0

# As it stands, this script must be terminated with a Control-C.

#    Exercises:
#    ---------
#    Improve the script so it exits on a "q" keystroke.
#    Make the script more user-friendly in other ways.

Warning	

In general, it is dangerous to write to the files in /proc, as this can corrupt the filesystem or crash the machine.
Notes
[1]	

Certain system commands, such as procinfo, free, vmstat, lsdev, and uptime do this as well.

		12.12.12 Chapter 28. Of Zeros and Nulls
/dev/zero  ... /dev/null

			12.12.12.1 Uses of /dev/null

    Think of /dev/null as a black hole. It is essentially the equivalent of a write-only file. Everything written to it disappears. Attempts to read or output from it result in nothing. All the same, /dev/null can be quite useful from both the command line and in scripts.

				12.12.12.1.1  Suppressing stderr and stdout
    Suppressing stdout.

    cat $filename >/dev/null
    # Contents of the file will not list to stdout.

    Suppressing stderr (from Example 15-3).

    rm $badname 2>/dev/null
    #           So error messages [stderr] deep-sixed.

    Suppressing output from both stdout and stderr.

    cat $filename 2>/dev/null >/dev/null
    # If "$filename" does not exist, there will be no error message output.
    # If "$filename" does exist, the contents of the file will not list to stdout.
    # Therefore, no output at all will result from the above line of code.
    #
    #  This can be useful in situations where the return code from a command
    #+ needs to be tested, but no output is desired.
    #
    # cat $filename &>/dev/null
    #     also works, as Baris Cicek points out.

				12.12.12.1.2 Deleting contents of a file, but preserving the file itself, with all attendant permissions 

    cat /dev/null > /var/log/messages
    #  : > /var/log/messages   has same effect, but does not spawn a new process.

    cat /dev/null > /var/log/wtmp

    Automatically emptying the contents of a logfile (especially good for dealing with those nasty "cookies" sent by commercial Web sites):

				12.12.12.1.3 Example 28-1. Hiding the cookie jar

    # Obsolete Netscape browser.
    # Same principle applies to newer browsers.

    if [ -f ~/.netscape/cookies ]  # Remove, if exists.
    then
      rm -f ~/.netscape/cookies
    fi

    ln -s /dev/null ~/.netscape/cookies
    # All cookies now get sent to a black hole, rather than saved to disk.

			12.12.12.1 Uses of /dev/zero

    Like /dev/null, /dev/zero is a pseudo-device file, but it actually produces a stream of nulls (binary zeros, not the ASCII kind). Output written to /dev/zero disappears, and it is fairly difficult to actually read the nulls emitted there, though it can be done with od or a hex editor. The chief use of /dev/zero is creating an initialized dummy file of predetermined length intended as a temporary swap file.

				12.12.12.1.1 Example 28-2. Setting up a swapfile using /dev/zero

    #!/bin/bash
    # Creating a swap file.

    #  A swap file provides a temporary storage cache
    #+ which helps speed up certain filesystem operations.

    ROOT_UID=0         # Root has $UID 0.
    E_WRONG_USER=65    # Not root?

    FILE=/swap
    BLOCKSIZE=1024
    MINBLOCKS=40
    SUCCESS=0


    # This script must be run as root.
    if [ "$UID" -ne "$ROOT_UID" ]
    then
      echo; echo "You must be root to run this script."; echo
      exit $E_WRONG_USER
    fi  
      

    blocks=${1:-$MINBLOCKS}          #  Set to default of 40 blocks,
                                     #+ if nothing specified on command line.
    # This is the equivalent of the command block below.
    # --------------------------------------------------
    # if [ -n "$1" ]
    # then
    #   blocks=$1
    # else
    #   blocks=$MINBLOCKS
    # fi
    # --------------------------------------------------


    if [ "$blocks" -lt $MINBLOCKS ]
    then
      blocks=$MINBLOCKS              # Must be at least 40 blocks long.
    fi  


    ######################################################################
    echo "Creating swap file of size $blocks blocks (KB)."
    dd if=/dev/zero of=$FILE bs=$BLOCKSIZE count=$blocks  # Zero out file.
    mkswap $FILE $blocks             # Designate it a swap file.
    swapon $FILE                     # Activate swap file.
    retcode=$?                       # Everything worked?
    #  Note that if one or more of these commands fails,
    #+ then it could cause nasty problems.
    ######################################################################

    #  Exercise:
    #  Rewrite the above block of code so that if it does not execute
    #+ successfully, then:
    #    1) an error message is echoed to stderr,
    #    2) all temporary files are cleaned up, and
    #    3) the script exits in an orderly fashion with an
    #+      appropriate error code.

    echo "Swap file created and activated."

    exit $retcode

    Another application of /dev/zero is to "zero out" a file of a designated size for a special purpose, such as mounting a filesystem on a loopback device (see Example 16-8) or "securely" deleting a file (see Example 15-60).

				12.12.12.1.2 Example 28-3. Creating a ramdisk

    #!/bin/bash
    # ramdisk.sh

    #  A "ramdisk" is a segment of system RAM memory
    #+ which acts as if it were a filesystem.
    #  Its advantage is very fast access (read/write time).
    #  Disadvantages: volatility, loss of data on reboot or powerdown.
    #+                less RAM available to system.
    #
    #  Of what use is a ramdisk?
    #  Keeping a large dataset, such as a table or dictionary on ramdisk,
    #+ speeds up data lookup, since memory access is much faster than disk access.


    E_NON_ROOT_USER=70             # Must run as root.
    ROOTUSER_NAME=root

    MOUNTPT=/mnt/ramdisk
    SIZE=2000                      # 2K blocks (change as appropriate)
    BLOCKSIZE=1024                 # 1K (1024 byte) block size
    DEVICE=/dev/ram0               # First ram device

    username=`id -nu`
    if [ "$username" != "$ROOTUSER_NAME" ]
    then
      echo "Must be root to run \"`basename $0`\"."
      exit $E_NON_ROOT_USER
    fi

    if [ ! -d "$MOUNTPT" ]         #  Test whether mount point already there,
    then                           #+ so no error if this script is run
      mkdir $MOUNTPT               #+ multiple times.
    fi

    ##############################################################################
    dd if=/dev/zero of=$DEVICE count=$SIZE bs=$BLOCKSIZE  # Zero out RAM device.
                                                          # Why is this necessary?
    mke2fs $DEVICE                 # Create an ext2 filesystem on it.
    mount $DEVICE $MOUNTPT         # Mount it.
    chmod 777 $MOUNTPT             # Enables ordinary user to access ramdisk.
                                   # However, must be root to unmount it.
    ##############################################################################
    # Need to test whether above commands succeed. Could cause problems otherwise.
    # Exercise: modify this script to make it safer.

    echo "\"$MOUNTPT\" now available for use."
    # The ramdisk is now accessible for storing files, even by an ordinary user.

    #  Caution, the ramdisk is volatile, and its contents will disappear
    #+ on reboot or power loss.
    #  Copy anything you want saved to a regular directory.

    # After reboot, run this script to again set up ramdisk.
    # Remounting /mnt/ramdisk without the other steps will not work.

    #  Suitably modified, this script can by invoked in /etc/rc.d/rc.local,
    #+ to set up ramdisk automatically at bootup.
    #  That may be appropriate on, for example, a database server.

    exit 0

    In addition to all the above, /dev/zero is needed by ELF (Executable and Linking Format) UNIX/Linux binaries.


		12.12.13 Chapter 29. Debugging
	

"Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it."

--Brian Kernighan

The Bash shell contains no built-in debugger, and only bare-bones debugging-specific commands and constructs. Syntax errors or outright typos in the script generate cryptic error messages that are often of no help in debugging a non-functional script.

			12.12.13.1 Example 29-1. A buggy script

#!/bin/bash
# ex74.sh

# This is a buggy script.
# Where, oh where is the error?

a=37

if [$a -gt 27 ]
then
  echo $a
fi  

exit 0

Output from script:

./ex74.sh: [37: command not found

What's wrong with the above script? Hint: after the if.

			12.12.13.2 Example 29-2. Missing keyword

#!/bin/bash
# missing-keyword.sh: What error message will this generate?

for a in 1 2 3
do
  echo "$a"
# done     # Required keyword 'done' commented out in line 7.

exit 0  

Output from script:

missing-keyword.sh: line 10: syntax error: unexpected end of file
	

Note that the error message does not necessarily reference the line in which the error occurs, but the line where the Bash interpreter finally becomes aware of the error.

Error messages may disregard comment lines in a script when reporting the line number of a syntax error.

What if the script executes, but does not work as expected? This is the all too familiar logic error.

			12.12.13.3 Example 29-3. test24: another buggy script

#!/bin/bash

#  This script is supposed to delete all filenames in current directory
#+ containing embedded spaces.
#  It doesn't work.
#  Why not?


badname=`ls | grep ' '`

# Try this:
# echo "$badname"

rm "$badname"

exit 0

Try to find out what's wrong with Example 29-3 by uncommenting the echo "$badname" line. Echo statements are useful for seeing whether what you expect is actually what you get.

In this particular case, rm "$badname" will not give the desired results because $badname should not be quoted. Placing it in quotes ensures that rm has only one argument (it will match only one filename). A partial fix is to remove to quotes from $badname and to reset $IFS to contain only a newline, IFS=$'\n'. However, there are simpler ways of going about it.

# Correct methods of deleting filenames containing spaces.
rm *\ *
rm *" "*
rm *' '*
# Thank you. S.C.

Summarizing the symptoms of a buggy script,

|   1.  It bombs with a "syntax error" message, or
|   2.  It runs, but does not work as expected (logic error).
|   3.  It runs, works as expected, but has nasty side effects (logic bomb).

			12.12.13.4 Tools for debugging non-working scripts include

				12.12.13.4.1 Inserting echo statements at critical points in the script to trace the variables, and otherwise give a snapshot of what is going on.

      Tip	Even better is an echo that echoes only when debug is on.

      ### debecho (debug-echo), by Stefano Falsetto ###
      ### Will echo passed parameters only if DEBUG is set to a value. ###
      debecho () {
        if [ ! -z "$DEBUG" ]; then
           echo "$1" >&2
           #         ^^^ to stderr
        fi
      }

      DEBUG=on
      Whatever=whatnot
      debecho $Whatever   # whatnot

      DEBUG=
      Whatever=notwhat
      debecho $Whatever   # (Will not echo.)

				12.12.13.4.2 Using the tee filter to check processes or data flows at critical points.

				12.12.13.4.3 Setting option flags -n -v -x

      sh -n scriptname checks for syntax errors without actually running the script. This is the equivalent of inserting set -n or set -o noexec into the script. Note that certain types of syntax errors can slip past this check.

      sh -v scriptname echoes each command before executing it. This is the equivalent of inserting set -v or set -o verbose in the script.

      The -n and -v flags work well together. sh -nv scriptname gives a verbose syntax check.

      sh -x scriptname echoes the result each command, but in an abbreviated manner. This is the equivalent of inserting set -x or set -o xtrace in the script.

      Inserting set -u or set -o nounset in the script runs it, but gives an unbound variable error message at each attempt to use an undeclared variable.

				12.12.13.4.4 Assert

			Using an "assert" function to test a variable or condition at critical points in a script. (This is an idea borrowed from C.)

      Example 29-4. Testing a condition with an assert

      #!/bin/bash
      # assert.sh

      #######################################################################
      assert ()                 #  If condition false,
      {                         #+ exit from script
                                #+ with appropriate error message.
        E_PARAM_ERR=98
        E_ASSERT_FAILED=99


        if [ -z "$2" ]          #  Not enough parameters passed
        then                    #+ to assert() function.
          return $E_PARAM_ERR   #  No damage done.
        fi

        lineno=$2

        if [ ! $1 ] 
        then
          echo "Assertion failed:  \"$1\""
          echo "File \"$0\", line $lineno"    # Give name of file and line number.
          exit $E_ASSERT_FAILED
        # else
        #   return
        #   and continue executing the script.
        fi  
      } # Insert a similar assert() function into a script you need to debug.    
      #######################################################################


      a=5
      b=4
      condition="$a -lt $b"     #  Error message and exit from script.
                                #  Try setting "condition" to something else
                                #+ and see what happens.

      assert "$condition" $LINENO
      # The remainder of the script executes only if the "assert" does not fail.


      # Some commands.
      # Some more commands . . .
      echo "This statement echoes only if the \"assert\" does not fail."
      # . . .
      # More commands . . .

      exit $?

				12.12.13.4.5 Using the $LINENO variable and the caller builtin.

				12.12.13.4.6 Trapping at exit.

      The exit command in a script triggers a signal 0, terminating the process, that is, the script itself. [1] It is often useful to trap the exit, forcing a "printout" of variables, for example. The trap must be the first command in the script.

Trapping signals

trap Specifies an action on receipt of a signal; also useful for debugging.

    A signal is a message sent to a process, either by the kernel or another process, telling it to take some specified action (usually to terminate). For example, hitting a Control-C sends a user interrupt, an INT signal, to a running program.

    A simple instance:

    trap '' 2
    # Ignore interrupt 2 (Control-C), with no action specified. 

    trap 'echo "Control-C disabled."' 2
    # Message when Control-C pressed.

					12.12.13.4.6.1 Example 29-5. Trapping at exit

#!/bin/bash
# Hunting variables with a trap.

trap 'echo Variable Listing --- a = $a  b = $b' EXIT
#  EXIT is the name of the signal generated upon exit from a script.
#
#  The command specified by the "trap" doesn't execute until
#+ the appropriate signal is sent.

echo "This prints before the \"trap\" --"
echo "even though the script sees the \"trap\" first."
echo

a=39

b=36

exit 0
#  Note that commenting out the 'exit' command makes no difference,
#+ since the script exits in any case after running out of commands.

					12.12.13.4.6.2 Example 29-6. Cleaning up after Control-C

#!/bin/bash
# logon.sh: A quick 'n dirty script to check whether you are on-line yet.

umask 177  # Make sure temp files are not world readable.


TRUE=1
LOGFILE=/var/log/messages
#  Note that $LOGFILE must be readable
#+ (as root, chmod 644 /var/log/messages).
TEMPFILE=temp.$$
#  Create a "unique" temp file name, using process id of the script.
#     Using 'mktemp' is an alternative.
#     For example:
#     TEMPFILE=`mktemp temp.XXXXXX`
KEYWORD=address
#  At logon, the line "remote IP address xxx.xxx.xxx.xxx"
#                      appended to /var/log/messages.
ONLINE=22
USER_INTERRUPT=13
CHECK_LINES=100
#  How many lines in log file to check.

trap 'rm -f $TEMPFILE; exit $USER_INTERRUPT' TERM INT
#  Cleans up the temp file if script interrupted by control-c.

echo

while [ $TRUE ]  #Endless loop.
do
  tail -n $CHECK_LINES $LOGFILE> $TEMPFILE
  #  Saves last 100 lines of system log file as temp file.
  #  Necessary, since newer kernels generate many log messages at log on.
  search=`grep $KEYWORD $TEMPFILE`
  #  Checks for presence of the "IP address" phrase,
  #+ indicating a successful logon.

  if [ ! -z "$search" ] #  Quotes necessary because of possible spaces.
  then
     echo "On-line"
     rm -f $TEMPFILE    #  Clean up temp file.
     exit $ONLINE
  else
     echo -n "."        #  The -n option to echo suppresses newline,
                        #+ so you get continuous rows of dots.
  fi

  sleep 1  
done  


#  Note: if you change the KEYWORD variable to "Exit",
#+ this script can be used while on-line
#+ to check for an unexpected logoff.

# Exercise: Change the script, per the above note,
#           and prettify it.

exit 0


# Nick Drage suggests an alternate method:

while true
  do ifconfig ppp0 | grep UP 1> /dev/null && echo "connected" && exit 0
  echo -n "."   # Prints dots (.....) until connected.
  sleep 2
done

# Problem: Hitting Control-C to terminate this process may be insufficient.
#+         (Dots may keep on echoing.)
# Exercise: Fix this.



# Stephane Chazelas has yet another alternative:

CHECK_INTERVAL=1

while ! tail -n 1 "$LOGFILE" | grep -q "$KEYWORD"
do echo -n .
   sleep $CHECK_INTERVAL
done
echo "On-line"

# Exercise: Discuss the relative strengths and weaknesses
#           of each of these various approaches.

Note	The DEBUG argument to trap causes a specified action to execute after every command in a script. This permits tracing variables, for example.

					12.12.13.4.6.3 Example 29-7. Tracing a variable

#!/bin/bash

trap 'echo "VARIABLE-TRACE> \$variable = \"$variable\""' DEBUG
# Echoes the value of $variable after every command.

variable=29

echo "  Just initialized \$variable to $variable."

let "variable *= 3"
echo "  Just multiplied \$variable by 3."

exit

#  The "trap 'command1 . . . command2 . . .' DEBUG" construct is
#+ more appropriate in the context of a complex script,
#+ where inserting multiple "echo $variable" statements might be
#+ awkward and time-consuming.

# Thanks, Stephane Chazelas for the pointer.


Output of script:

VARIABLE-TRACE> $variable = ""
VARIABLE-TRACE> $variable = "29"
  Just initialized $variable to 29.
VARIABLE-TRACE> $variable = "29"
VARIABLE-TRACE> $variable = "87"
  Just multiplied $variable by 3.
VARIABLE-TRACE> $variable = "87"

Of course, the trap command has other uses aside from debugging.

					12.12.13.4.6.4 Example 29-8. Running multiple processes (on an SMP box)

#!/bin/bash
# parent.sh
# Running multiple processes on an SMP box.
# Author: Tedman Eng

#  This is the first of two scripts,
#+ both of which must be present in the current working directory.




LIMIT=$1         # Total number of process to start
NUMPROC=4        # Number of concurrent threads (forks?)
PROCID=1         # Starting Process ID
echo "My PID is $$"

function start_thread() {
        if [ $PROCID -le $LIMIT ] ; then
                ./child.sh $PROCID&
                let "PROCID++"
        else
           echo "Limit reached."
           wait
           exit
        fi
}

while [ "$NUMPROC" -gt 0 ]; do
        start_thread;
        let "NUMPROC--"
done


while true
do

trap "start_thread" SIGRTMIN

done

exit 0



# ======== Second script follows ========


#!/bin/bash
# child.sh
# Running multiple processes on an SMP box.
# This script is called by parent.sh.
# Author: Tedman Eng

temp=$RANDOM
index=$1
shift
let "temp %= 5"
let "temp += 4"
echo "Starting $index  Time:$temp" "$@"
sleep ${temp}
echo "Ending $index"
kill -s SIGRTMIN $PPID

exit 0


# ======================= SCRIPT AUTHOR'S NOTES ======================= #
#  It's not completely bug free.
#  I ran it with limit = 500 and after the first few hundred iterations,
#+ one of the concurrent threads disappeared!
#  Not sure if this is collisions from trap signals or something else.
#  Once the trap is received, there's a brief moment while executing the
#+ trap handler but before the next trap is set.  During this time, it may
#+ be possible to miss a trap signal, thus miss spawning a child process.

#  No doubt someone may spot the bug and will be writing 
#+ . . . in the future.



# ===================================================================== #



# ----------------------------------------------------------------------#



#################################################################
# The following is the original script written by Vernia Damiano.
# Unfortunately, it doesn't work properly.
#################################################################

#!/bin/bash

#  Must call script with at least one integer parameter
#+ (number of concurrent processes).
#  All other parameters are passed through to the processes started.


INDICE=8        # Total number of process to start
TEMPO=5         # Maximum sleep time per process
E_BADARGS=65    # No arg(s) passed to script.

if [ $# -eq 0 ] # Check for at least one argument passed to script.
then
  echo "Usage: `basename $0` number_of_processes [passed params]"
  exit $E_BADARGS
fi

NUMPROC=$1              # Number of concurrent process
shift
PARAMETRI=( "$@" )      # Parameters of each process

function avvia() {
         local temp
         local index
         temp=$RANDOM
         index=$1
         shift
         let "temp %= $TEMPO"
         let "temp += 1"
         echo "Starting $index Time:$temp" "$@"
         sleep ${temp}
         echo "Ending $index"
         kill -s SIGRTMIN $$
}

function parti() {
         if [ $INDICE -gt 0 ] ; then
              avvia $INDICE "${PARAMETRI[@]}" &
                let "INDICE--"
         else
                trap : SIGRTMIN
         fi
}

trap parti SIGRTMIN

while [ "$NUMPROC" -gt 0 ]; do
         parti;
         let "NUMPROC--"
done

wait
trap - SIGRTMIN

exit $?

: <<SCRIPT_AUTHOR_COMMENTS
I had the need to run a program, with specified options, on a number of
different files, using a SMP machine. So I thought [I'd] keep running
a specified number of processes and start a new one each time . . . one
of these terminates.

The "wait" instruction does not help, since it waits for a given process
or *all* process started in background. So I wrote [this] bash script
that can do the job, using the "trap" instruction.
  --Vernia Damiano
SCRIPT_AUTHOR_COMMENTS

Note	trap '' SIGNAL (two adjacent apostrophes) disables SIGNAL for the remainder of the script. trap SIGNAL restores the functioning of SIGNAL once more. This is useful to protect a critical portion of a script from an undesirable interrupt.

	trap '' 2  # Signal 2 is Control-C, now disabled.
	command
	command
	command
	trap 2     # Reenables Control-C
	
	12.12.13.4.7 Version 3 of Bash adds the following internal variables for use by the debugger.

|   1.  $BASH_ARGC
|
|      Number of command-line arguments passed to script, similar to $#.
|   2.  $BASH_ARGV
|
|      Final command-line parameter passed to script, equivalent ${!#}.
|   3.  $BASH_COMMAND
|
|      Command currently executing.
|   4.  $BASH_EXECUTION_STRING
|
|      The option string following the -c option to Bash.
|   5.  $BASH_LINENO
|
|      In a function, indicates the line number of the function call.
|   6.  $BASH_REMATCH
|
|      Array variable associated with =~ conditional regex matching.
|   7.  $BASH_SOURCE
|
|      Same as $0.
|   8.  $BASH_SUBSHELL

		12.12.14 Chapter 30. Options
Options are settings that change shell and/or script behavior.

The set command enables options within a script. At the point in the script where you want the options to take effect, use set -o option-name or, in short form, set -option-abbrev. These two forms are equivalent.

      #!/bin/bash

      set -o verbose
      # Echoes all commands before executing.
      

      #!/bin/bash

      set -v
      # Exact same effect as above.
      

Note	To disable an option within a script, use set +o option-name or set +option-abbrev.

      #!/bin/bash

      set -o verbose
      # Command echoing on.
      command
      ...
      command

      set +o verbose
      # Command echoing off.
      command
      # Not echoed.


      set -v
      # Command echoing on.
      command
      ...
      command

      set +v
      # Command echoing off.
      command

      exit 0
      

An alternate method of enabling options in a script is to specify them immediately following the #! script header.

      #!/bin/bash -x
      #
      # Body of script follows.
      

It is also possible to enable script options from the command line. Some options that will not work with set are available this way. Among these are -i, force script to run interactive.

bash -v script-name

bash -o verbose script-name

The following is a listing of some useful options. They may be specified in either abbreviated form (preceded by a single dash) or by complete name (preceded by a double dash or by -o).

Table 30-1. Bash options
Abbreviation	Name	Effect
-C	noclobber	Prevent overwriting of files by redirection (may be overridden by >|)
-D	(none)	List double-quoted strings prefixed by $, but do not execute commands in script
-a	allexport	Export all defined variables
-b	notify	Notify when jobs running in background terminate (not of much use in a script)
-c ...	(none)	Read commands from ...
-e	errexit	Abort script at first error, when a command exits with non-zero status (except in until or while loops, if-tests, list constructs)
-f	noglob	Filename expansion (globbing) disabled
-i	interactive	Script runs in interactive mode
-n	noexec	Read commands in script, but do not execute them (syntax check)
-o Option-Name	(none)	Invoke the Option-Name option
-o posix	POSIX	Change the behavior of Bash, or invoked script, to conform to POSIX standard.
-o pipefail	pipe failure	Causes a pipeline to return the exit status of the last command in the pipe that returned a non-zero return value.
-p	privileged	Script runs as "suid" (caution!)
-r	restricted	Script runs in restricted mode (see Chapter 21).
-s	stdin	Read commands from stdin
-t	(none)	Exit after first command
-u	nounset	Attempt to use undefined variable outputs error message, and forces an exit
-v	verbose	Print each command to stdout before executing it
-x	xtrace	Similar to -v, but expands commands
-	(none)	End of options flag. All other arguments are positional parameters.
--	(none)	Unset positional parameters. If arguments given (-- arg1 arg2), positional parameters set to arguments.


		12.12.15 Chapter 31. Gotchas
	

Turandot: Gli enigmi sono tre, la morte una!

Caleph: No, no! Gli enigmi sono tre, una la vita!

--Puccini

(Yosi, Translate: "The riddles are three, death is one"
 "No, No, The riddles are three, life is one"
 )

Here are some (non-recommended!) scripting practices that will bring excitement to an otherwise dull life.

    * Assigning reserved words or characters to variable names.

      case=value0       # Causes problems.
      23skidoo=value1   # Also problems.
      # Variable names starting with a digit are reserved by the shell.
      # Try _23skidoo=value1. Starting variables with an underscore is o.k.

      # However . . .   using just the underscore will not work.
      _=25
      echo $_           # $_ is a special variable set to last arg of last command.

      xyz((!*=value2    # Causes severe problems.
      # As of version 3 of Bash, periods are not allowed within variable names.

    * Using a hyphen or other reserved characters in a variable name (or function name).

      var-1=23
      # Use 'var_1' instead.

      function-whatever ()   # Error
      # Use 'function_whatever ()' instead.

       
      # As of version 3 of Bash, periods are not allowed within function names.
      function.whatever ()   # Error
      # Use 'functionWhatever ()' instead.

    * Using the same name for a variable and a function. This can make a script difficult to understand.

      do_something ()
      {
        echo "This function does something with \"$1\"."
      }

      do_something=do_something

      do_something do_something

      # All this is legal, but highly confusing.

    * Using whitespace inappropriately. In contrast to other programming languages, Bash can be quite finicky about whitespace.

      var1 = 23   # 'var1=23' is correct.
      # On line above, Bash attempts to execute command "var1"
      # with the arguments "=" and "23".
      	
      let c = $a - $b   # 'let c=$a-$b' or 'let "c = $a - $b"' are correct.

      if [ $a -le 5]    # if [ $a -le 5 ]   is correct.
      # if [ "$a" -le 5 ]   is even better.
      # [[ $a -le 5 ]] also works.

    * Not terminating with a semicolon the final command in a code block within curly brackets.

      { ls -l; df; echo "Done." }
      # bash: syntax error: unexpected end of file

      { ls -l; df; echo "Done."; }
      #                        ^     ### Final command needs semicolon.

    * Assuming uninitialized variables (variables before a value is assigned to them) are "zeroed out". An uninitialized variable has a value of null, not zero.

      #!/bin/bash

      echo "uninitialized_var = $uninitialized_var"
      # uninitialized_var =

    * Mixing up = and -eq in a test. Remember, = is for comparing literal variables and -eq for integers.

      if [ "$a" = 273 ]      # Is $a an integer or string?
      if [ "$a" -eq 273 ]    # If $a is an integer.

      # Sometimes you can interchange -eq and = without adverse consequences.
      # However . . .


      a=273.0   # Not an integer.
      	   
      if [ "$a" = 273 ]
      then
        echo "Comparison works."
      else  
        echo "Comparison does not work."
      fi    # Comparison does not work.

      # Same with   a=" 273"  and a="0273".


      # Likewise, problems trying to use "-eq" with non-integer values.
      	   
      if [ "$a" -eq 273.0 ]
      then
        echo "a = $a"
      fi  # Aborts with an error message.  
      # test.sh: [: 273.0: integer expression expected

    * Misusing string comparison operators.

      Example 31-1. Numerical and string comparison are not equivalent

      #!/bin/bash
      # bad-op.sh: Trying to use a string comparison on integers.

      echo
      number=1

      # The following "while loop" has two errors:
      #+ one blatant, and the other subtle.

      while [ "$number" < 5 ]    # Wrong! Should be:  while [ "$number" -lt 5 ]
      do
        echo -n "$number "
        let "number += 1"
      done  
      #  Attempt to run this bombs with the error message:
      #+ bad-op.sh: line 10: 5: No such file or directory
      #  Within single brackets, "<" must be escaped,
      #+ and even then, it's still wrong for comparing integers.


      echo "---------------------"


      while [ "$number" \< 5 ]    #  1 2 3 4
      do                          #
        echo -n "$number "        #  This *seems to work, but . . .
        let "number += 1"         #+ it  actually does an ASCII comparison,
      done                        #+ rather than a numerical one.

      echo; echo "---------------------"

      # This can cause problems. For example:

      lesser=5
      greater=105

      if [ "$greater" \< "$lesser" ]
      then
        echo "$greater is less than $lesser"
      fi                          # 105 is less than 5
      #  In fact, "105" actually is less than "5"
      #+ in a string comparison (ASCII sort order).

      echo

      exit 0

    * Sometimes variables within "test" brackets ([ ]) need to be quoted (double quotes). Failure to do so may cause unexpected behavior. See Example 7-6, Example 19-5, and Example 9-6.
    * Quoting a variable containing whitespace prevents splitting. Sometimes this produces unintended consequences.
    * Commands issued from a script may fail to execute because the script owner lacks execute permission for them. If a user cannot invoke a command from the command line, then putting it into a script will likewise fail. Try changing the attributes of the command in question, perhaps even setting the suid bit (as root, of course).
    * Attempting to use - as a redirection operator (which it is not) will usually result in an unpleasant surprise.

      command1 2> - | command2
      # Trying to redirect error output of command1 into a pipe . . .
      # . . . will not work.	

      command1 2>& - | command2  # Also futile.

      Thanks, S.C.

    * Using Bash version 2+ functionality may cause a bailout with error messages. Older Linux machines may have version 1.XX of Bash as the default installation.

      #!/bin/bash

      minimum_version=2
      # Since Chet Ramey is constantly adding features to Bash,
      # you may set $minimum_version to 2.XX, 3.XX, or whatever is appropriate.
      E_BAD_VERSION=80

      if [ "$BASH_VERSION" \< "$minimum_version" ]
      then
        echo "This script works only with Bash, version $minimum or greater."
        echo "Upgrade strongly recommended."
        exit $E_BAD_VERSION
      fi

      ...
* 
      Using Bash-specific functionality in a Bourne shell script (#!/bin/sh) on a non-Linux machine may cause unexpected behavior. A Linux system usually aliases sh to bash, but this does not necessarily hold true for a generic UNIX machine.
    * Using undocumented features in Bash turns out to be a dangerous practice. In previous releases of this book there were several scripts that depended on the "feature" that, although the maximum value of an exit or return value was 255, that limit did not apply to negative integers. Unfortunately, in version 2.05b and later, that loophole disappeared. See Example 23-9.
    * A script with DOS-type newlines (\r\n) will fail to execute, since #!/bin/bash\r\n is not recognized, not the same as the expected #!/bin/bash\n. The fix is to convert the script to UNIX-style newlines.

      #!/bin/bash

      echo "Here"

      unix2dos $0    # Script changes itself to DOS format.
      chmod 755 $0   # Change back to execute permission.
                     # The 'unix2dos' command removes execute permission.

      ./$0           # Script tries to run itself again.
                     # But it won't work as a DOS file.

      echo "There"

      exit 0

    * A shell script headed by #!/bin/sh will not run in full Bash-compatibility mode. Some Bash-specific functions might be disabled. Scripts that need complete access to all the Bash-specific extensions should start with #!/bin/bash.
    * Putting whitespace in front of the terminating limit string of a here document will cause unexpected behavior in a script.
    * Putting more than one echo statement in a function whose output is captured.

      add2 ()
      {
        echo "Whatever ... "   # Delete this line!
        let "retval = $1 + $2"
          echo $retval
          }

          num1=12
          num2=43
          echo "Sum of $num1 and $num2 = $(add2 $num1 $num2)"

      #   Sum of 12 and 43 = Whatever ... 
      #   55

      #        The "echoes" concatenate.

      This will not work.
    * A script may not export variables back to its parent process, the shell, or to the environment. Just as we learned in biology, a child process can inherit from a parent, but not vice versa.

      WHATEVER=/home/bozo
      export WHATEVER
      exit 0

      bash$ echo $WHATEVER

      bash$ 

      Sure enough, back at the command prompt, $WHATEVER remains unset.
    * Setting and manipulating variables in a subshell, then attempting to use those same variables outside the scope of the subshell will result an unpleasant surprise.

      Example 31-2. Subshell Pitfalls

      #!/bin/bash
      # Pitfalls of variables in a subshell.

      outer_variable=outer
      echo
      echo "outer_variable = $outer_variable"
      echo

      (
      # Begin subshell

      echo "outer_variable inside subshell = $outer_variable"
      inner_variable=inner  # Set
      echo "inner_variable inside subshell = $inner_variable"
      outer_variable=inner  # Will value change globally?
      echo "outer_variable inside subshell = $outer_variable"

      # Will 'exporting' make a difference?
      #    export inner_variable
      #    export outer_variable
      # Try it and see.

      # End subshell
      )

      echo
      echo "inner_variable outside subshell = $inner_variable"  # Unset.
      echo "outer_variable outside subshell = $outer_variable"  # Unchanged.
      echo

      exit 0

      # What happens if you uncomment lines 19 and 20?
      # Does it make a difference?

    * Piping echo output to a read may produce unexpected results. In this scenario, the read acts as if it were running in a subshell. Instead, use the set command (as in Example 14-18).

      Example 31-3. Piping the output of echo to a read

      #!/bin/bash
      #  badread.sh:
      #  Attempting to use 'echo and 'read'
      #+ to assign variables non-interactively.

      a=aaa
      b=bbb
      c=ccc

      echo "one two three" | read a b c
      # Try to reassign a, b, and c.

      echo
      echo "a = $a"  # a = aaa
      echo "b = $b"  # b = bbb
      echo "c = $c"  # c = ccc
      # Reassignment failed.

      # ------------------------------

      # Try the following alternative.

      var=`echo "one two three"`
      set -- $var
      a=$1; b=$2; c=$3

      echo "-------"
      echo "a = $a"  # a = one
      echo "b = $b"  # b = two
      echo "c = $c"  # c = three 
      # Reassignment succeeded.

      # ------------------------------

      #  Note also that an echo to a 'read' works within a subshell.
      #  However, the value of the variable changes *only* within the subshell.

      a=aaa          # Starting all over again.
      b=bbb
      c=ccc

      echo; echo
      echo "one two three" | ( read a b c;
      echo "Inside subshell: "; echo "a = $a"; echo "b = $b"; echo "c = $c" )
      # a = one
      # b = two
      # c = three
      echo "-----------------"
      echo "Outside subshell: "
      echo "a = $a"  # a = aaa
      echo "b = $b"  # b = bbb
      echo "c = $c"  # c = ccc
      echo

      exit 0

      In fact, as Anthony Richardson points out, piping to any loop can cause a similar problem.

      # Loop piping troubles.
      #  This example by Anthony Richardson,
      #+ with addendum by Wilbert Berendsen.


      foundone=false
      find $HOME -type f -atime +30 -size 100k |
      while true
      do
         read f
         echo "$f is over 100KB and has not been accessed in over 30 days"
         echo "Consider moving the file to archives."
         foundone=true
         # ------------------------------------
         echo "Subshell level = $BASH_SUBSHELL"
         # Subshell level = 1
         # Yes, we're inside a subshell.
         # ------------------------------------
      done
         
      #  foundone will always be false here since it is
      #+ set to true inside a subshell
      if [ $foundone = false ]
      then
         echo "No files need archiving."
      fi

      # =====================Now, here is the correct way:=================

      foundone=false
      for f in $(find $HOME -type f -atime +30 -size 100k)  # No pipe here.
      do
         echo "$f is over 100KB and has not been accessed in over 30 days"
         echo "Consider moving the file to archives."
         foundone=true
      done
         
      if [ $foundone = false ]
      then
         echo "No files need archiving."
      fi

      # ==================And here is another alternative==================

      #  Places the part of the script that reads the variables
      #+ within a code block, so they share the same subshell.
      #  Thank you, W.B.

      find $HOME -type f -atime +30 -size 100k | {
           foundone=false
           while read f
           do
             echo "$f is over 100KB and has not been accessed in over 30 days"
             echo "Consider moving the file to archives."
             foundone=true
           done

           if ! $foundone
           then
             echo "No files need archiving."
           fi
      }

      A related problem occurs when trying to write the stdout of a tail -f piped to grep.

      tail -f /var/log/messages | grep "$ERROR_MSG" >> error.log
      # The "error.log" file will not have anything written to it.

    * Using "suid" commands within scripts is risky, as it may compromise system security. [1]
    * Using shell scripts for CGI programming may be problematic. Shell script variables are not "typesafe," and this can cause undesirable behavior as far as CGI is concerned. Moreover, it is difficult to "cracker-proof" shell scripts.
    * Bash does not handle the double slash (//) string correctly.
    * Bash scripts written for Linux or BSD systems may need fixups to run on a commercial UNIX (or Apple OSX) machine. Such scripts often employ the GNU set of commands and filters, which have greater functionality than their generic UNIX counterparts. This is particularly true of such text processing utilites as tr.

 	

Danger is near thee --

Beware, beware, beware, beware.

Many brave hearts are asleep in the deep.

So beware --

Beware.

--A.J. Lamb and H.W. Petrie


		12.12.16 Chapter 32. Scripting With Style
Unofficial Shell Scripting Stylesheet

    * Comment your code. This makes it easier for others to understand (and appreciate), and easier for you to maintain.

      PASS="$PASS${MATRIX:$(($RANDOM%${#MATRIX})):1}"
      #  It made perfect sense when you wrote it last year,
      #+ but now it's a complete mystery.
      #  (From Antek Sawicki's "pw.sh" script.)

      Add descriptive headers to your scripts and functions.

      #!/bin/bash

      #************************************************#
      #                   xyz.sh                       #
      #           written by Bozo Bozeman              #
      #                July 05, 2001                   #
      #                                                #
      #           Clean up project files.              #
      #************************************************#

      E_BADDIR=65                       # No such directory.
      projectdir=/home/bozo/projects    # Directory to clean up.

      # --------------------------------------------------------- #
      # cleanup_pfiles ()                                         #
      # Removes all files in designated directory.                #
      # Parameter: $target_directory                              #
      # Returns: 0 on success, $E_BADDIR if something went wrong. #
      # --------------------------------------------------------- #
      cleanup_pfiles ()
      {
        if [ ! -d "$1" ]  # Test if target directory exists.
        then
          echo "$1 is not a directory."
          return $E_BADDIR
        fi

        rm -f "$1"/*
        return 0   # Success. */
      }  

      cleanup_pfiles $projectdir

      exit 0

      Be sure to put the #!/bin/bash at the beginning of the first line of the script, preceding any comment headers.
    * Avoid using "magic numbers," [1] that is, "hard-wired" literal constants. Use meaningful variable names instead. This makes the script easier to understand and permits making changes and updates without breaking the application.

      if [ -f /var/log/messages ]
      then
        ...
      fi
      # A year later, you decide to change the script to check /var/log/syslog.
      # It is now necessary to manually change the script, instance by instance,
      # and hope nothing breaks.

      # A better way:
      LOGFILE=/var/log/messages  # Only line that needs to be changed.
      if [ -f "$LOGFILE" ]
      then
        ...
      fi

    * Choose descriptive names for variables and functions.

      fl=`ls -al $dirname`                 # Cryptic.
      file_listing=`ls -al $dirname`       # Better.


      MAXVAL=10   # All caps used for a script constant.
      while [ "$index" -le "$MAXVAL" ]
      ...


      E_NOTFOUND=95                        #  Uppercase for an errorcode,
                                           #+ and name prefixed with E_.
      if [ ! -e "$filename" ]
      then
        echo "File $filename not found."
        exit $E_NOTFOUND
      fi  


      MAIL_DIRECTORY=/var/spool/mail/bozo  #  Uppercase for an environmental
      export MAIL_DIRECTORY                #+ variable.


      GetAnswer ()                         #  Mixed case works well for a
      {                                    #+ function name, especially
        prompt=$1                          #+ when it improves legibility.
        echo -n $prompt
        read answer
        return $answer
      }  

      GetAnswer "What is your favorite number? "
      favorite_number=$?
      echo $favorite_number


      _uservariable=23                     # Permissible, but not recommended.
      # It's better for user-defined variables not to start with an underscore.
      # Leave that for system variables.

    * Use exit codes in a systematic and meaningful way.

      E_WRONG_ARGS=65
      ...
      ...
      exit $E_WRONG_ARGS

      See also Appendix D.

      Ender suggests using the exit codes in /usr/include/sysexits.h in shell scripts, though these are primarily intended for C and C++ programming.
    * Use standardized parameter flags for script invocation. Ender proposes the following set of flags.

      -a      All: Return all information (including hidden file info).
      -b      Brief: Short version, usually for other scripts.
      -c      Copy, concatenate, etc.
      -d      Daily: Use information from the whole day, and not merely
              information for a specific instance/user.
      -e      Extended/Elaborate: (often does not include hidden file info).
      -h      Help: Verbose usage w/descs, aux info, discussion, help.
              See also -V.
      -l      Log output of script.
      -m      Manual: Launch man-page for base command.
      -n      Numbers: Numerical data only.
      -r      Recursive: All files in a directory (and/or all sub-dirs).
      -s      Setup & File Maintenance: Config files for this script.
      -u      Usage: List of invocation flags for the script.
      -v      Verbose: Human readable output, more or less formatted.
      -V      Version / License / Copy(right|left) / Contribs (email too).

      See also Section F.1.
    * Break complex scripts into simpler modules. Use functions where appropriate. See Example 34-4.
    * Don't use a complex construct where a simpler one will do.

      COMMAND
      if [ $? -eq 0 ]
      ...
      # Redundant and non-intuitive.

      if COMMAND
      ...
      # More concise (if perhaps not quite as legible).

 	

... reading the UNIX source code to the Bourne shell (/bin/sh). I was shocked at how much simple algorithms could be made cryptic, and therefore useless, by a poor choice of code style. I asked myself, "Could someone be proud of this code?"

--Landon Noll
Notes
[1]	In this context, "magic numbers" have an entirely different meaning than the magic numbers used to designate file types.

		12.12.17 Chapter 33. Miscellany
			12.12.17.1 Interactive and non-interactive shells and scripts
An interactive shell reads commands from user input on a tty. Among other things, such a shell reads startup files on activation, displays a prompt, and enables job control by default. The user can interact with the shell.

A shell running a script is always a non-interactive shell. All the same, the script can still access its tty. It is even possible to emulate an interactive shell in a script.

#!/bin/bash
MY_PROMPT='$ '
while :
do
  echo -n "$MY_PROMPT"
  read line
  eval "$line"
  done

exit 0

#'
# This example script, and much of the above explanation supplied by
# Stphane Chazelas (thanks again).

Let us consider an interactive script to be one that requires input from the user, usually with read statements (see Example 14-3). "Real life" is actually a bit messier than that. For now, assume an interactive script is bound to a tty, a script that a user has invoked from the console or an xterm.

Init and startup scripts are necessarily non-interactive, since they must run without human intervention. Many administrative and system maintenance scripts are likewise non-interactive. Unvarying repetitive tasks cry out for automation by non-interactive scripts.

Non-interactive scripts can run in the background, but interactive ones hang, waiting for input that never comes. Handle that difficulty by having an expect script or embedded here document feed input to an interactive script running as a background job. In the simplest case, redirect a file to supply input to a read statement (read variable <file). These particular workarounds make possible general purpose scripts that run in either interactive or non-interactive modes.

If a script needs to test whether it is running in an interactive shell, it is simply a matter of finding whether the prompt variable, $PS1 is set. (If the user is being prompted for input, then the script needs to display a prompt.)

if [ -z $PS1 ] # no prompt?
then
  # non-interactive
  ...
else
  # interactive
  ...
fi

Alternatively, the script can test for the presence of option "i" in the $- flag.

case $- in
*i*)    # interactive shell
;;
*)      # non-interactive shell
;;
# (Courtesy of "UNIX F.A.Q.," 1993)

Note	Scripts may be forced to run in interactive mode with the -i option or with a #!/bin/bash -i header. Be aware that this can cause erratic script behavior or show error messages even when no error is present.


			12.12.17.2 Operator Precedence

 In a script, operations execute in order of precedence: the higher precedence operations execute before the lower precedence ones. [1]

Table 33-1. Operator Precedence
Operator	Meaning	Comments
	 	HIGHEST PRECEDENCE
var++ var--	post-increment, post-decrement	C-style operators
++var --var	pre-increment, pre-decrement	 
 	 	 
! ~	negation	logical / bitwise, inverts sense of following operator
 	 	 
**	exponentiation	arithmetic operation
* / %	multiplication, division, modulo	arithmetic operation
+ -	addition, subtraction	arithmetic operation
 	 	 
<< >>	left, right shift	bitwise
 	 	 
-z -n	unary comparison	string is/is-not null
-e -f -t -x, etc.	unary comparison	file-test
< -lt > -gt <= -le >= -ge	compound comparison	string and integer
-nt -ot -ef	compound comparison	file-test
== -eq != -ne	equality / inequality	test operators, string and integer
 	 	 
&	AND	bitwise
^	XOR	exclusive OR, bitwise
|	OR	bitwise
 	 	 
&& -a	AND	logical, compound comparison
|| -o	OR	logical, compound comparison
 	 	 
?:	trinary operator	C-style
=	assignment	(do not confuse with equality test)
*= /= %= += -= <<= >>= &=	combination assignment	times-equal, divide-equal, mod-equal, etc.
 	 	 
,	comma	links a sequence of operations
	 	LOWEST PRECEDENCE

In practice, all you really need to remember is the following:

    * The "My Dear Aunt Sally" mantra (multiply, divide, add, subtract) for the familiar arithmetic operations.
    * The compound logical operators, &&, ||, -a, and -o have low precedence.
    * The order of evaluation of equal-precedence operators is usually left-to-right.

Now, let's utilize our knowledge of operator precedence to analyze a couple of lines from the /etc/init.d/functions file, as found in the Fedora Core Linux distro.

while [ -n "$remaining" -a "$retry" -gt 0 ]; do

# This looks rather daunting at first glance.


# Separate the conditions:
while [ -n "$remaining" -a "$retry" -gt 0 ]; do
#       --condition 1-- ^^ --condition 2-

#  If variable "$remaining" is not zero length
#+      AND (-a)
#+ variable "$retry" is greater-than zero
#+ then
#+ the [ expresion-within-condition-brackets ] returns success (0)
#+ and the while-loop executes an iteration.
#  ==============================================================
#  Evaluate "condition 1" and "condition 2" ***before***
#+ ANDing them. Why? Because the AND (-a) has a lower precedence
#+ than the -n and -gt operators,
#+ and therefore gets evaluated *last*.

#################################################################

if [ -f /etc/sysconfig/i18n -a -z "${NOLOCALE:-}" ] ; then


# Again, separate the conditions:
if [ -f /etc/sysconfig/i18n -a -z "${NOLOCALE:-}" ] ; then
#    --condition 1--------- ^^ --condition 2-----

#  If file "/etc/sysconfig/i18n" exists
#+      AND (-a)
#+ variable $NOLOCALE is zero length
#+ then
#+ the [ test-expresion-within-condition-brackets ] returns success (0)
#+ and the commands following execute.
#
#  As before, the AND (-a) gets evaluated *last*
#+ because it has the lowest precedence of the operators within
#+ the test brackets.
#  ==============================================================
#  Note:
#  ${NOLOCALE:-} is a parameter expansion that seems redundant.
#  But, if $NOLOCALE has not been declared, it gets set to *null*,
#+ in effect declaring it.
#  This makes a difference in some contexts.

Tip	

To avoid confusion or error in a complex sequence of test operators, break up the sequence into bracketed sections.

if [ "$v1" -gt "$v2"  -o  "$v1" -lt "$v2"  -a  -e "$filename" ]
# Unclear what's going on here...

if [[ "$v1" -gt "$v2" ]] || [[ "$v1" -lt "$v2" ]] && [[ -e "$filename" ]]
# Much better -- the condition tests are grouped in logical sections.

Notes
[1]	Precedence, in this context, has approximately the same meaning as priority

			12.12.17.3 Shell Wrappers
A wrapper is a shell script that embeds a system command or utility, that saves a set of parameters passed to that command. [1]  Wrapping a script around a complex command line simplifies invoking it. This is expecially useful with sed and awk.

A sed or awk script would normally be invoked from the command line by a sed -e 'commands' or awk 'commands'. Embedding such a script in a Bash script permits calling it more simply, and makes it reusable. This also enables combining the functionality of sed and awk, for example piping the output of a set of sed commands to awk. As a saved executable file, you can then repeatedly invoke it in its original form or modified, without the inconvenience of retyping it on the command line.

				12.12.17.3.1 Example 33-1. shell wrapper

#!/bin/bash

# This simple script removes blank lines from a file.
# No argument checking.
#
# You might wish to add something like:
#
# E_NOARGS=85
# if [ -z "$1" ]
# then
#  echo "Usage: `basename $0` target-file"
#  exit $E_NOARGS
# fi



sed -e /^$/d "$1"
# Same as
#    sed -e '/^$/d' filename
# invoked from the command line.

#  The '-e' means an "editing" command follows (optional here).
#  '^' indicates the beginning of line, '$' the end.
#  This matches lines with nothing between the beginning and the end --
#+ blank lines.
#  The 'd' is the delete command.

#  Quoting the command-line arg permits
#+ whitespace and special characters in the filename.

#  Note that this script doesn't actually change the target file.
#  If you need to do that, redirect its output.

exit

				12.12.17.3.2 Example 33-2. A slightly more complex shell wrapper

#!/bin/bash

#  subst.sh: a script that substitutes one pattern for
#+ another in a file,
#+ i.e., "sh subst.sh Smith Jones letter.txt".
#                     Jones replaces Smith.

ARGS=3         # Script requires 3 arguments.
E_BADARGS=85   # Wrong number of arguments passed to script.

if [ $# -ne "$ARGS" ]
# Test number of arguments to script (always a good idea).
then
  echo "Usage: `basename $0` old-pattern new-pattern filename"
  exit $E_BADARGS
fi

old_pattern=$1
new_pattern=$2

if [ -f "$3" ]
then
    file_name=$3
else
    echo "File \"$3\" does not exist."
    exit $E_BADARGS
fi


# -----------------------------------------------
#  Here is where the heavy work gets done.
sed -e "s/$old_pattern/$new_pattern/g" $file_name
# -----------------------------------------------

#  's' is, of course, the substitute command in sed,
#+ and /pattern/ invokes address matching.
#  The 'g,' or global flag causes substitution for EVERY
#+ occurence of $old_pattern on each line, not just the first.
#  Read the 'sed' docs for an in-depth explanation.

exit $?

				12.12.17.3.3 Example 33-3. A generic shell wrapper that writes to a logfile

#!/bin/bash
#  Generic shell wrapper that performs an operation
#+ and logs it.

# Must set the following two variables.
OPERATION=
#         Can be a complex chain of commands,
#+        for example an awk script or a pipe . . .
LOGFILE=
#         Command-line arguments, if any, for the operation.


OPTIONS="$@"


# Log it.
echo "`date` + `whoami` + $OPERATION "$@"" >> $LOGFILE
# Now, do it.
exec $OPERATION "$@"

# It's necessary to do the logging before the operation.
# Why?

				12.12.17.3.4 Example 33-4. A shell wrapper around an awk script

#!/bin/bash
# pr-ascii.sh: Prints a table of ASCII characters.

START=33   # Range of printable ASCII characters (decimal).
END=127    # Will not work for unprintable chars. (> 127).

echo " Decimal   Hex     Character"   # Header.
echo " -------   ---     ---------"

for ((i=START; i<=END; i++))
do
  echo $i | awk '{printf("  %3d       %2x         %c\n", $1, $1, $1)}'
# The Bash printf builtin will not work in this context:
#     printf "%c" "$i"
done

exit 0


#  Decimal   Hex     Character
#  -------   ---     ---------
#    33       21         !
#    34       22         "
#    35       23         #
#    36       24         $
#
#    . . .
#
#   122       7a         z
#   123       7b         {
#   124       7c         |
#   125       7d         }


#  Redirect the output of this script to a file
#+ or pipe it to "more":  sh pr-asc.sh | more

"
				12.12.17.3.5 Example 33-5. A shell wrapper around another awk script

#!/bin/bash

# Adds up a specified column (of numbers) in the target file.

ARGS=2
E_WRONGARGS=65

if [ $# -ne "$ARGS" ] # Check for proper no. of command line args.
then
   echo "Usage: `basename $0` filename column-number"
   exit $E_WRONGARGS
fi

filename=$1
column_number=$2

#  Passing shell variables to the awk part of the script is a bit tricky.
#  One method is to strong-quote the Bash-script variable
#+ within the awk script.
#     $'$BASH_SCRIPT_VAR'
#      ^                ^
#  This is done in the embedded awk script below.
#  See the awk documentation for more details.

# A multi-line awk script is invoked by:  awk ' ..... '


# Begin awk script.
# -----------------------------
awk '

{ total += $'"${column_number}"'
}
END {
     print total
}     

' "$filename"
# -----------------------------
# End awk script.


#   It may not be safe to pass shell variables to an embedded awk script,
#+  so Stephane Chazelas proposes the following alternative:
#   ---------------------------------------
#   awk -v column_number="$column_number" '
#   { total += $column_number
#   }
#   END {
#       print total
#   }' "$filename"
#   ---------------------------------------


exit 0

For those scripts needing a single do-it-all tool, a Swiss army knife, there is Perl. Perl combines the capabilities of sed and awk, and throws in a large subset of C, to boot. It is modular and contains support for everything ranging from object-oriented programming up to and including the kitchen sink. Short Perl scripts lend themselves to embedding in shell scripts, and there may even be some substance to the claim that Perl can totally replace shell scripting (though the author of this document remains skeptical).

				12.12.17.3.6 Example 33-6. Perl embedded in a Bash script

#!/bin/bash

# Shell commands may precede the Perl script.
echo "This precedes the embedded Perl script within \"$0\"."
echo "==============================================================="

perl -e 'print "This is an embedded Perl script.\n";'
# Like sed, Perl also uses the "-e" option.

echo "==============================================================="
echo "However, the script may also contain shell and system commands."

exit 0

It is even possible to combine a Bash script and Perl script within the same file. Depending on how the script is invoked, either the Bash part or the Perl part will execute.

				12.12.17.3.7 Example 33-7. Bash and Perl scripts combined

#!/bin/bash
# bashandperl.sh

echo "Greetings from the Bash part of the script."
# More Bash commands may follow here.

exit 0
# End of Bash part of the script.

# =======================================================

#!/usr/bin/perl
# This part of the script must be invoked with
#    perl -x bashandperl.sh

print "Greetings from the Perl part of the script.\n";
# More Perl commands may follow here.

# End of Perl part of the script.

bash$ bash bashandperl.sh
Greetings from the Bash part of the script.


bash$ perl -x bashandperl.sh
Greetings from the Perl part of the script.
	      

One interesting example of a complex shell wrapper is Martin Matusiak's undvd script, which provides an easy-to-use command-line interface to the complex mencoder utility. Another example is Itzchak Rehberg's Ext3Undel, a set of scripts to recover deleted file on an ext3 filesystem.
Notes
[1]	Quite a number of Linux utilities are, in fact, shell wrappers. Some examples are /usr/bin/pdf2ps, /usr/bin/batch, and /usr/X11R6/bin/xmkmf.

			12.12.17.4 Tests and Comparisons: Alternatives
For tests, the [[ ]]  construct may be more appropriate than [ ]. Likewise, arithmetic comparisons might benefit from the (( )) construct.

a=8

# All of the comparisons below are equivalent.
test "$a" -lt 16 && echo "yes, $a < 16"         # "and list"
/bin/test "$a" -lt 16 && echo "yes, $a < 16" 
[ "$a" -lt 16 ] && echo "yes, $a < 16" 
[[ $a -lt 16 ]] && echo "yes, $a < 16"          # Quoting variables within
(( a < 16 )) && echo "yes, $a < 16"             # [[ ]] and (( )) not necessary.

city="New York"
# Again, all of the comparisons below are equivalent.
test "$city" \< Paris && echo "Yes, Paris is greater than $city"
                                  # Greater ASCII order.
/bin/test "$city" \< Paris && echo "Yes, Paris is greater than $city" 
[ "$city" \< Paris ] && echo "Yes, Paris is greater than $city" 
[[ $city < Paris ]] && echo "Yes, Paris is greater than $city"
                                  # Need not quote $city.

# Thank you, S.C.

			12.12.17.5 A script calling itself (recursion)
Can a script recursively  call itself? Indeed.

Example 33-8. A (useless) script that recursively calls itself

#!/bin/bash
# recurse.sh

#  Can a script recursively call itself?
#  Yes, but is this of any practical use?
#  (See the following.)

RANGE=10
MAXVAL=9

i=$RANDOM
let "i %= $RANGE"  # Generate a random number between 0 and $RANGE - 1.

if [ "$i" -lt "$MAXVAL" ]
then
  echo "i = $i"
  ./$0             #  Script recursively spawns a new instance of itself.
fi                 #  Each child script does the same, until
                   #+ a generated $i equals $MAXVAL.

#  Using a "while" loop instead of an "if/then" test causes problems.
#  Explain why.

exit 0

# Note:
# ----
# This script must have execute permission for it to work properly.
# This is the case even if it is invoked by an "sh" command.
# Explain why.

			12.12.17.6 Example 33-9. A (useful) script that recursively calls itself

#!/bin/bash
# pb.sh: phone book

# Written by Rick Boivie, and used with permission.
# Modifications by ABS Guide author.

MINARGS=1     #  Script needs at least one argument.
DATAFILE=./phonebook
              #  A data file in current working directory
              #+ named "phonebook" must exist.
PROGNAME=$0
E_NOARGS=70   #  No arguments error.

if [ $# -lt $MINARGS ]; then
      echo "Usage: "$PROGNAME" data-to-look-up"
      exit $E_NOARGS
fi      


if [ $# -eq $MINARGS ]; then
      grep $1 "$DATAFILE"
      # 'grep' prints an error message if $DATAFILE not present.
else
      ( shift; "$PROGNAME" $* ) | grep $1
      # Script recursively calls itself.
fi

exit 0        #  Script exits here.
              #  Therefore, it's o.k. to put
              #+ non-hashmarked comments and data after this point.

# ------------------------------------------------------------------------
Sample "phonebook" datafile:

John Doe        1555 Main St., Baltimore, MD 21228          (410) 222-3333
Mary Moe        9899 Jones Blvd., Warren, NH 03787          (603) 898-3232
Richard Roe     856 E. 7th St., New York, NY 10009          (212) 333-4567
Sam Roe         956 E. 8th St., New York, NY 10009          (212) 444-5678
Zoe Zenobia     4481 N. Baker St., San Francisco, SF 94338  (415) 501-1631
# ------------------------------------------------------------------------

$bash pb.sh Roe
Richard Roe     856 E. 7th St., New York, NY 10009          (212) 333-4567
Sam Roe         956 E. 8th St., New York, NY 10009          (212) 444-5678

$bash pb.sh Roe Sam
Sam Roe         956 E. 8th St., New York, NY 10009          (212) 444-5678

#  When more than one argument is passed to this script,
#+ it prints *only* the line(s) containing all the arguments.

			12.12.17.7 Example 33-10. Another (useful) script that recursively calls itself

#!/bin/bash
# usrmnt.sh, written by Anthony Richardson
# Used with permission.

# usage:       usrmnt.sh
# description: mount device, invoking user must be listed in the
#              MNTUSERS group in the /etc/sudoers file.

# ----------------------------------------------------------
#  This is a usermount script that reruns itself using sudo.
#  A user with the proper permissions only has to type

#   usermount /dev/fd0 /mnt/floppy

# instead of

#   sudo usermount /dev/fd0 /mnt/floppy

#  I use this same technique for all of my
#+ sudo scripts, because I find it convenient.
# ----------------------------------------------------------

#  If SUDO_COMMAND variable is not set we are not being run through
#+ sudo, so rerun ourselves. Pass the user's real and group id . . .

if [ -z "$SUDO_COMMAND" ]
then
   mntusr=$(id -u) grpusr=$(id -g) sudo $0 $*
   exit 0
fi

# We will only get here if we are being run by sudo.
/bin/mount $* -o uid=$mntusr,gid=$grpusr

exit 0

			12.12.17.8 Notes
# Additional notes (from the author of this script): 
# -------------------------------------------------

# 1) Linux allows the "users" option in the /etc/fstab
#    file so that any user can mount removable media.
#    But, on a server, I like to allow only a few
#    individuals access to removable media.
#    I find using sudo gives me more control.

# 2) I also find sudo to be more convenient than
#    accomplishing this task through groups.

# 3) This method gives anyone with proper permissions
#    root access to the mount command, so be careful
#    about who you allow access.
#    You can get finer control over which access can be mounted
#    by using this same technique in separate mntfloppy, mntcdrom,
#    and mntsamba scripts.

Caution	Too many levels of recursion can exhaust the script's stack space, causing a segfault.

			12.12.17.6 "Colorizing" Scripts
The ANSI [1]  escape sequences set screen attributes, such as bold text, and color of foreground and background. DOS batch files commonly used ANSI escape codes for color output, and so can Bash scripts.

				12.12.17.6.1 Example 33-11. A "colorized" address database

#!/bin/bash
# ex30a.sh: "Colorized" version of ex30.sh.
#            Crude address database


clear                                   # Clear the screen.

echo -n "          "
echo -e '\E[37;44m'"\033[1mContact List\033[0m"
                                        # White on blue background
echo; echo
echo -e "\033[1mChoose one of the following persons:\033[0m"
                                        # Bold
tput sgr0
echo "(Enter only the first letter of name.)"
echo
echo -en '\E[47;34m'"\033[1mE\033[0m"   # Blue
tput sgr0                               # Reset colors to "normal."
echo "vans, Roland"                     # "[E]vans, Roland"
echo -en '\E[47;35m'"\033[1mJ\033[0m"   # Magenta
tput sgr0
echo "ones, Mildred"
echo -en '\E[47;32m'"\033[1mS\033[0m"   # Green
tput sgr0
echo "mith, Julie"
echo -en '\E[47;31m'"\033[1mZ\033[0m"   # Red
tput sgr0
echo "ane, Morris"
echo

read person

case "$person" in
# Note variable is quoted.

  "E" | "e" )
  # Accept upper or lowercase input.
  echo
  echo "Roland Evans"
  echo "4321 Floppy Dr."
  echo "Hardscrabble, CO 80753"
  echo "(303) 734-9874"
  echo "(303) 734-9892 fax"
  echo "revans@zzy.net"
  echo "Business partner & old friend"
  ;;

  "J" | "j" )
  echo
  echo "Mildred Jones"
  echo "249 E. 7th St., Apt. 19"
  echo "New York, NY 10009"
  echo "(212) 533-2814"
  echo "(212) 533-9972 fax"
  echo "milliej@loisaida.com"
  echo "Girlfriend"
  echo "Birthday: Feb. 11"
  ;;

# Add info for Smith & Zane later.

          * )
   # Default option.	  
   # Empty input (hitting RETURN) fits here, too.
   echo
   echo "Not yet in database."
  ;;

esac

tput sgr0                               # Reset colors to "normal."

echo

exit 0

				12.12.17.6.2 Example 33-12. Drawing a box

#!/bin/bash
# Draw-box.sh: Drawing a box using ASCII characters.

# Script by Stefano Palmeri, with minor editing by document author.
# Minor edits suggested by Jim Angstadt.
# Used in the "ABS Guide" with permission.


######################################################################
###  draw_box function doc  ###

#  The "draw_box" function lets the user
#+ draw a box into a terminal.       
#
#  Usage: draw_box ROW COLUMN HEIGHT WIDTH [COLOR] 
#  ROW and COLUMN represent the position        
#+ of the upper left angle of the box you're going to draw.
#  ROW and COLUMN must be greater than 0
#+ and less than current terminal dimension.
#  HEIGHT is the number of rows of the box, and must be > 0. 
#  HEIGHT + ROW must be <= than current terminal height. 
#  WIDTH is the number of columns of the box and must be > 0.
#  WIDTH + COLUMN must be <= than current terminal width.
#
# E.g.: If your terminal dimension is 20x80,
#  draw_box 2 3 10 45 is good
#  draw_box 2 3 19 45 has bad HEIGHT value (19+2 > 20)
#  draw_box 2 3 18 78 has bad WIDTH value (78+3 > 80)
#
#  COLOR is the color of the box frame.
#  This is the 5th argument and is optional.
#  0=black 1=red 2=green 3=tan 4=blue 5=purple 6=cyan 7=white.
#  If you pass the function bad arguments,
#+ it will just exit with code 65,
#+ and no messages will be printed on stderr.
#
#  Clear the terminal before you start to draw a box.
#  The clear command is not contained within the function.
#  This allows the user to draw multiple boxes, even overlapping ones.

###  end of draw_box function doc  ### 
######################################################################

draw_box(){

#=============#
HORZ="-"
VERT="|"
CORNER_CHAR="+"

MINARGS=4
E_BADARGS=65
#=============#


if [ $# -lt "$MINARGS" ]; then                 # If args are less than 4, exit.
    exit $E_BADARGS
fi

# Looking for non digit chars in arguments.
# Probably it could be done better (exercise for the reader?).
if echo $@ | tr -d [:blank:] | tr -d [:digit:] | grep . &> /dev/null; then
   exit $E_BADARGS
fi

BOX_HEIGHT=`expr $3 - 1`   #  -1 correction needed because angle char "+" is 
BOX_WIDTH=`expr $4 - 1`    #+ a part of both box height and width.
T_ROWS=`tput lines`        #  Define current terminal dimension 
T_COLS=`tput cols`         #+ in rows and columns.
         
if [ $1 -lt 1 ] || [ $1 -gt $T_ROWS ]; then    #  Start checking if arguments
   exit $E_BADARGS                             #+ are correct.
fi
if [ $2 -lt 1 ] || [ $2 -gt $T_COLS ]; then
   exit $E_BADARGS
fi
if [ `expr $1 + $BOX_HEIGHT + 1` -gt $T_ROWS ]; then
   exit $E_BADARGS
fi
if [ `expr $2 + $BOX_WIDTH + 1` -gt $T_COLS ]; then
   exit $E_BADARGS
fi
if [ $3 -lt 1 ] || [ $4 -lt 1 ]; then
   exit $E_BADARGS
fi                                 # End checking arguments.

plot_char(){                       # Function within a function.
   echo -e "\E[${1};${2}H"$3
}

echo -ne "\E[3${5}m"               # Set box frame color, if defined.

# start drawing the box

count=1                                         #  Draw vertical lines using
for (( r=$1; count<=$BOX_HEIGHT; r++)); do      #+ plot_char function.
  plot_char $r $2 $VERT
  let count=count+1
done 

count=1
c=`expr $2 + $BOX_WIDTH`
for (( r=$1; count<=$BOX_HEIGHT; r++)); do
  plot_char $r $c $VERT
  let count=count+1
done 

count=1                                        #  Draw horizontal lines using
for (( c=$2; count<=$BOX_WIDTH; c++)); do      #+ plot_char function.
  plot_char $1 $c $HORZ
  let count=count+1
done 

count=1
r=`expr $1 + $BOX_HEIGHT`
for (( c=$2; count<=$BOX_WIDTH; c++)); do
  plot_char $r $c $HORZ
  let count=count+1
done 

plot_char $1 $2 $CORNER_CHAR                   # Draw box angles.
plot_char $1 `expr $2 + $BOX_WIDTH` $CORNER_CHAR
plot_char `expr $1 + $BOX_HEIGHT` $2 $CORNER_CHAR
plot_char `expr $1 + $BOX_HEIGHT` `expr $2 + $BOX_WIDTH` $CORNER_CHAR

echo -ne "\E[0m"             #  Restore old colors.

P_ROWS=`expr $T_ROWS - 1`    #  Put the prompt at bottom of the terminal.

echo -e "\E[${P_ROWS};1H"
}      


# Now, let's try drawing a box.
clear                       # Clear the terminal.
R=2      # Row
C=3      # Column
H=10     # Height
W=45     # Width 
col=1    # Color (red)
draw_box $R $C $H $W $col   # Draw the box.

exit 0

# Exercise:
# --------
# Add the option of printing text within the drawn box.

The simplest, and perhaps most useful ANSI escape sequence is bold text, \033[1m ... \033[0m. The \033 represents an escape, the "[1" turns on the bold attribute, while the "[0" switches it off. The "m" terminates each term of the escape sequence.

bash$ echo -e "\033[1mThis is bold text.\033[0m"
	      

A similar escape sequence switches on the underline attribute (on an rxvt and an aterm).

bash$ echo -e "\033[4mThis is underlined text.\033[0m"
	      

Note	

With an echo, the -e option enables the escape sequences.

Other escape sequences change the text and/or background color.

bash$ echo -e '\E[34;47mThis prints in blue.'; tput sgr0


bash$ echo -e '\E[33;44m'"yellow text on blue background"; tput sgr0


bash$ echo -e '\E[1;33;44m'"BOLD yellow text on blue background"; tput sgr0
	      

Note	

It's usually advisable to set the bold attribute for light-colored foreground text.

The tput sgr0 restores the terminal settings to normal. Omitting this lets all subsequent output from that particular terminal remain blue.

Note	

Since tput sgr0 fails to restore terminal settings under certain circumstances, echo -ne \E[0m may be a better choice.

Use the following template for writing colored text on a colored background.

echo -e '\E[COLOR1;COLOR2mSome text goes here.'

The "\E[" begins the escape sequence. The semicolon-separated numbers "COLOR1" and "COLOR2" specify a foreground and a background color, according to the table below. (The order of the numbers does not matter, since the foreground and background numbers fall in non-overlapping ranges.) The "m" terminates the escape sequence, and the text begins immediately after that.

Note also that single quotes enclose the remainder of the command sequence following the echo -e.

The numbers in the following table work for an rxvt terminal. Results may vary for other terminal emulators.

				12.12.17.6.3 Table 33-2. Numbers representing colors in Escape Sequences
Color	Foreground	Background
black	30	40
red	31	41
green	32	42
yellow	33	43
blue	34	44
magenta	35	45
cyan	36	46
white	37	47

				12.12.17.6.4 Example 33-13. Echoing colored text

#!/bin/bash
# color-echo.sh: Echoing text messages in color.

# Modify this script for your own purposes.
# It's easier than hand-coding color.

black='\E[30;47m'
red='\E[31;47m'
green='\E[32;47m'
yellow='\E[33;47m'
blue='\E[34;47m'
magenta='\E[35;47m'
cyan='\E[36;47m'
white='\E[37;47m'


alias Reset="tput sgr0"      #  Reset text attributes to normal
                             #+ without clearing screen.


cecho ()                     # Color-echo.
                             # Argument $1 = message
                             # Argument $2 = color
{
local default_msg="No message passed."
                             # Doesn't really need to be a local variable.

message=${1:-$default_msg}   # Defaults to default message.
color=${2:-$black}           # Defaults to black, if not specified.

  echo -e "$color"
  echo "$message"
  Reset                      # Reset to normal.

  return
}  


# Now, let's try it out.
# ----------------------------------------------------
cecho "Feeling blue..." $blue
cecho "Magenta looks more like purple." $magenta
cecho "Green with envy." $green
cecho "Seeing red?" $red
cecho "Cyan, more familiarly known as aqua." $cyan
cecho "No color passed (defaults to black)."
       # Missing $color argument.
cecho "\"Empty\" color passed (defaults to black)." ""
       # Empty $color argument.
cecho
       # Missing $message and $color arguments.
cecho "" ""
       # Empty $message and $color arguments.
# ----------------------------------------------------

echo

exit 0

# Exercises:
# ---------
# 1) Add the "bold" attribute to the 'cecho ()' function.
# 2) Add options for colored backgrounds.

				12.12.17.6.5 Example 33-14. A "horserace" game

#!/bin/bash
# horserace.sh: Very simple horserace simulation.
# Author: Stefano Palmeri
# Used with permission.

################################################################
#  Goals of the script:
#  playing with escape sequences and terminal colors.
#
#  Exercise:
#  Edit the script to make it run less randomly,
#+ set up a fake betting shop . . .     
#  Um . . . um . . . it's starting to remind me of a movie . . .
#
#  The script gives each horse a random handicap.
#  The odds are calculated upon horse handicap
#+ and are expressed in European(?) style.
#  E.g., odds=3.75 means that if you bet $1 and win,
#+ you receive $3.75.
# 
#  The script has been tested with a GNU/Linux OS,
#+ using xterm and rxvt, and konsole.
#  On a machine with an AMD 900 MHz processor,
#+ the average race time is 75 seconds.    
#  On faster computers the race time would be lower.
#  So, if you want more suspense, reset the USLEEP_ARG variable.
#
#  Script by Stefano Palmeri.
################################################################

E_RUNERR=65

# Check if md5sum and bc are installed. 
if ! which bc &> /dev/null; then
   echo bc is not installed.  
   echo "Can\'t run . . . "
   exit $E_RUNERR
fi
if ! which md5sum &> /dev/null; then
   echo md5sum is not installed.  
   echo "Can\'t run . . . "
   exit $E_RUNERR
fi

#  Set the following variable to slow down script execution.
#  It will be passed as the argument for usleep (man usleep)  
#+ and is expressed in microseconds (500000 = half a second).
USLEEP_ARG=0  

#  Clean up the temp directory, restore terminal cursor and 
#+ terminal colors -- if script interrupted by Ctl-C.
trap 'echo -en "\E[?25h"; echo -en "\E[0m"; stty echo;\
tput cup 20 0; rm -fr  $HORSE_RACE_TMP_DIR'  TERM EXIT
#  See the chapter on debugging for an explanation of 'trap.'

# Set a unique (paranoid) name for the temp directory the script needs.
HORSE_RACE_TMP_DIR=$HOME/.horserace-`date +%s`-`head -c10 /dev/urandom \
| md5sum | head -c30`

# Create the temp directory and move right in.
mkdir $HORSE_RACE_TMP_DIR
cd $HORSE_RACE_TMP_DIR


#  This function moves the cursor to line $1 column $2 and then prints $3.
#  E.g.: "move_and_echo 5 10 linux" is equivalent to
#+ "tput cup 4 9; echo linux", but with one command instead of two.
#  Note: "tput cup" defines 0 0 the upper left angle of the terminal,
#+ echo defines 1 1 the upper left angle of the terminal.
move_and_echo() {
          echo -ne "\E[${1};${2}H""$3" 
}

# Function to generate a pseudo-random number between 1 and 9. 
random_1_9 ()
{
    head -c10 /dev/urandom | md5sum | tr -d [a-z] | tr -d 0 | cut -c1 
}

#  Two functions that simulate "movement," when drawing the horses. 
draw_horse_one() {
               echo -n " "//$MOVE_HORSE//
}
draw_horse_two(){
              echo -n " "\\\\$MOVE_HORSE\\\\ 
}   


# Define current terminal dimension.
N_COLS=`tput cols`
N_LINES=`tput lines`

# Need at least a 20-LINES X 80-COLUMNS terminal. Check it.
if [ $N_COLS -lt 80 ] || [ $N_LINES -lt 20 ]; then
   echo "`basename $0` needs a 80-cols X 20-lines terminal."
   echo "Your terminal is ${N_COLS}-cols X ${N_LINES}-lines."
   exit $E_RUNERR
fi


# Start drawing the race field.

# Need a string of 80 chars. See below.
BLANK80=`seq -s "" 100 | head -c80`

clear

# Set foreground and background colors to white.
echo -ne '\E[37;47m'

# Move the cursor on the upper left angle of the terminal.
tput cup 0 0 

# Draw six white lines.
for n in `seq 5`; do
      echo $BLANK80   # Use the 80 chars string to colorize the terminal.
done

# Sets foreground color to black. 
echo -ne '\E[30m'

move_and_echo 3 1 "START  1"            
move_and_echo 3 75 FINISH
move_and_echo 1 5 "|"
move_and_echo 1 80 "|"
move_and_echo 2 5 "|"
move_and_echo 2 80 "|"
move_and_echo 4 5 "|  2"
move_and_echo 4 80 "|"
move_and_echo 5 5 "V  3"
move_and_echo 5 80 "V"

# Set foreground color to red. 
echo -ne '\E[31m'

# Some ASCII art.
move_and_echo 1 8 "..@@@..@@@@@...@@@@@.@...@..@@@@..."
move_and_echo 2 8 ".@...@...@.......@...@...@.@......."
move_and_echo 3 8 ".@@@@@...@.......@...@@@@@.@@@@...."
move_and_echo 4 8 ".@...@...@.......@...@...@.@......."
move_and_echo 5 8 ".@...@...@.......@...@...@..@@@@..."
move_and_echo 1 43 "@@@@...@@@...@@@@..@@@@..@@@@."
move_and_echo 2 43 "@...@.@...@.@.....@.....@....."
move_and_echo 3 43 "@@@@..@@@@@.@.....@@@@...@@@.."
move_and_echo 4 43 "@..@..@...@.@.....@.........@."
move_and_echo 5 43 "@...@.@...@..@@@@..@@@@.@@@@.."


# Set foreground and background colors to green.
echo -ne '\E[32;42m'

# Draw  eleven green lines.
tput cup 5 0
for n in `seq 11`; do
      echo $BLANK80
done

# Set foreground color to black. 
echo -ne '\E[30m'
tput cup 5 0

# Draw the fences. 
echo "++++++++++++++++++++++++++++++++++++++\
++++++++++++++++++++++++++++++++++++++++++"

tput cup 15 0
echo "++++++++++++++++++++++++++++++++++++++\
++++++++++++++++++++++++++++++++++++++++++"

# Set foreground and background colors to white.
echo -ne '\E[37;47m'

# Draw three white lines.
for n in `seq 3`; do
      echo $BLANK80
done

# Set foreground color to black.
echo -ne '\E[30m'

# Create 9 files to stores handicaps.
for n in `seq 10 7 68`; do
      touch $n
done  

# Set the first type of "horse" the script will draw.
HORSE_TYPE=2

#  Create position-file and odds-file for every "horse".
#+ In these files, store the current position of the horse,
#+ the type and the odds.
for HN in `seq 9`; do
      touch horse_${HN}_position
      touch odds_${HN}
      echo \-1 > horse_${HN}_position
      echo $HORSE_TYPE >>  horse_${HN}_position
      # Define a random handicap for horse.
       HANDICAP=`random_1_9`
      # Check if the random_1_9 function returned a good value.
      while ! echo $HANDICAP | grep [1-9] &> /dev/null; do
                HANDICAP=`random_1_9`
      done
      # Define last handicap position for horse. 
      LHP=`expr $HANDICAP \* 7 + 3`
      for FILE in `seq 10 7 $LHP`; do
            echo $HN >> $FILE
      done   
     
      # Calculate odds.
      case $HANDICAP in 
              1) ODDS=`echo $HANDICAP \* 0.25 + 1.25 | bc`
                                 echo $ODDS > odds_${HN}
              ;;
              2 | 3) ODDS=`echo $HANDICAP \* 0.40 + 1.25 | bc`
                                       echo $ODDS > odds_${HN}
              ;;
              4 | 5 | 6) ODDS=`echo $HANDICAP \* 0.55 + 1.25 | bc`
                                             echo $ODDS > odds_${HN}
              ;; 
              7 | 8) ODDS=`echo $HANDICAP \* 0.75 + 1.25 | bc`
                                       echo $ODDS > odds_${HN}
              ;; 
              9) ODDS=`echo $HANDICAP \* 0.90 + 1.25 | bc`
                                  echo $ODDS > odds_${HN}
      esac


done


# Print odds.
print_odds() {
tput cup 6 0
echo -ne '\E[30;42m'
for HN in `seq 9`; do
      echo "#$HN odds->" `cat odds_${HN}`
done
}

# Draw the horses at starting line.
draw_horses() {
tput cup 6 0
echo -ne '\E[30;42m'
for HN in `seq 9`; do
      echo /\\$HN/\\"                               "
done
}

print_odds

echo -ne '\E[47m'
# Wait for a enter key press to start the race.
# The escape sequence '\E[?25l' disables the cursor.
tput cup 17 0
echo -e '\E[?25l'Press [enter] key to start the race...
read -s

#  Disable normal echoing in the terminal.
#  This avoids key presses that might "contaminate" the screen
#+ during the race.  
stty -echo

# --------------------------------------------------------
# Start the race.

draw_horses
echo -ne '\E[37;47m'
move_and_echo 18 1 $BLANK80
echo -ne '\E[30m'
move_and_echo 18 1 Starting...
sleep 1

# Set the column of the finish line.
WINNING_POS=74

# Define the time the race started.
START_TIME=`date +%s`

# COL variable needed by following "while" construct.
COL=0    

while [ $COL -lt $WINNING_POS ]; do
                   
          MOVE_HORSE=0     
          
          # Check if the random_1_9 function has returned a good value.
          while ! echo $MOVE_HORSE | grep [1-9] &> /dev/null; do
                MOVE_HORSE=`random_1_9`
          done
          
          # Define old type and position of the "randomized horse".
          HORSE_TYPE=`cat  horse_${MOVE_HORSE}_position | tail -n 1`
          COL=$(expr `cat  horse_${MOVE_HORSE}_position | head -n 1`)
          
          ADD_POS=1
          # Check if the current position is an handicap position. 
          if seq 10 7 68 | grep -w $COL &> /dev/null; then
                if grep -w $MOVE_HORSE $COL &> /dev/null; then
                      ADD_POS=0
                      grep -v -w  $MOVE_HORSE $COL > ${COL}_new
                      rm -f $COL
                      mv -f ${COL}_new $COL
                      else ADD_POS=1
                fi 
          else ADD_POS=1
          fi
          COL=`expr $COL + $ADD_POS`
          echo $COL >  horse_${MOVE_HORSE}_position  # Store new position.
                            
         # Choose the type of horse to draw.         
          case $HORSE_TYPE in 
                1) HORSE_TYPE=2; DRAW_HORSE=draw_horse_two
                ;;
                2) HORSE_TYPE=1; DRAW_HORSE=draw_horse_one 
          esac       
          echo $HORSE_TYPE >>  horse_${MOVE_HORSE}_position
          # Store current type.
         
          # Set foreground color to black and background to green.
          echo -ne '\E[30;42m'
          
          # Move the cursor to new horse position.
          tput cup `expr $MOVE_HORSE + 5` \
	  `cat  horse_${MOVE_HORSE}_position | head -n 1` 
          
          # Draw the horse.
          $DRAW_HORSE
           usleep $USLEEP_ARG
          
           # When all horses have gone beyond field line 15, reprint odds.
           touch fieldline15
           if [ $COL = 15 ]; then
             echo $MOVE_HORSE >> fieldline15  
           fi
           if [ `wc -l fieldline15 | cut -f1 -d " "` = 9 ]; then
               print_odds
               : > fieldline15
           fi           
          
          # Define the leading horse.
          HIGHEST_POS=`cat *position | sort -n | tail -1`          
          
          # Set background color to white.
          echo -ne '\E[47m'
          tput cup 17 0
          echo -n Current leader: `grep -w $HIGHEST_POS *position | cut -c7`\
	  "                              "

done  

# Define the time the race finished.
FINISH_TIME=`date +%s`

# Set background color to green and enable blinking text.
echo -ne '\E[30;42m'
echo -en '\E[5m'

# Make the winning horse blink.
tput cup `expr $MOVE_HORSE + 5` \
`cat  horse_${MOVE_HORSE}_position | head -n 1`
$DRAW_HORSE

# Disable blinking text.
echo -en '\E[25m'

# Set foreground and background color to white.
echo -ne '\E[37;47m'
move_and_echo 18 1 $BLANK80

# Set foreground color to black.
echo -ne '\E[30m'

# Make winner blink.
tput cup 17 0
echo -e "\E[5mWINNER: $MOVE_HORSE\E[25m""  Odds: `cat odds_${MOVE_HORSE}`"\
"  Race time: `expr $FINISH_TIME - $START_TIME` secs"

# Restore cursor and old colors.
echo -en "\E[?25h"
echo -en "\E[0m"

# Restore echoing.
stty echo

# Remove race temp directory.
rm -rf $HORSE_RACE_TMP_DIR

tput cup 19 0

exit 0


Caution	
There is, however, a major problem with all this. ANSI escape sequences are emphatically non-portable. What works fine on some terminal emulators (or the console) may work differently, or not at all, on others. A "colorized" script that looks stunning on the script author's machine may produce unreadable output on someone else's. This greatly compromises the usefulness of "colorizing" scripts, and possibly relegates this technique to the status of a gimmick or even a "toy".

Moshe Jacobson's color utility (http://runslinux.net/projects.html#color) considerably simplifies using ANSI escape sequences. It substitutes a clean and logical syntax for the clumsy constructs just discussed.

Henry/teikedvl has likewise created a utility (http://scriptechocolor.sourceforge.net/) to simplify creation of colorized scripts.
Notes
[1]	ANSI is, of course, the acronym for the American National Standards Institute. This august body establishes and maintains various technical and industrial standards.

			12.12.17.7 Optimizations
Most shell scripts are quick n dirty solutions to non-complex problems. As such, optimizing them for speed is not much of an issue. Consider the case, though, where a script carries out an important task, does it well, but runs too slowly. Rewriting it in a compiled language may not be a palatable option. The simplest fix would be to rewrite the parts of the script that slow it down. Is it possible to apply principles of code optimization even to a lowly shell script?

Check the loops in the script. Time consumed by repetitive operations adds up quickly. If at all possible, remove time-consuming operations from within loops.

Use builtin commands in preference to system commands. Builtins execute faster and usually do not launch a subshell when invoked.

Avoid unnecessary commands, particularly in a pipe.

cat "$file" | grep "$word"

grep "$word" "$file"

#  The above command lines have an identical effect,
#+ but the second runs faster since it launches one fewer subprocess.

The cat command seems especially prone to overuse in scripts.

Use the time and times tools to profile computation-intensive commands. Consider rewriting time-critical code sections in C, or even in assembler.

Try to minimize file I/O. Bash is not particularly efficient at handling files, so consider using more appropriate tools for this within the script, such as awk or Perl.

Write your scripts in a modular and coherent form, [1] so they can be reorganized and tightened up as necessary. Some of the optimization techniques applicable to high-level languages may work for scripts, but others, such as loop unrolling, are mostly irrelevant. Above all, use common sense.

For an excellent demonstration of how optimization can dramatically reduce the execution time of a script, see Example 15-47.
Notes
[1]	This usually means liberal use of functions.

			12.12.17.8 Assorted Tips
			
			    12.12.17.8.1. Ideas for more powerful scripts

				12.12.17.8.1.1 TOP DOWN approach

# You have a problem that you want to solve by writing a Bash script. Unfortunately, you don't know quite where to start. One method is to plunge right in and code those parts of the script that come easily, and write the hard parts as pseudo-code.

#!/bin/bash

ARGCOUNT=1                     # Need name as argument.
E_WRONGARGS=65

if [ number-of-arguments is-not-equal-to "$ARGCOUNT" ]
#    ^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^
#  Can't figure out how to code this . . .
#+ . . . so write it in pseudo-code.

then
  echo "Usage: name-of-script name"
  #            ^^^^^^^^^^^^^^     More pseudo-code.
  exit $E_WRONGARGS
fi 

. . .

exit 0


# Later on, substitute working code for the pseudo-code.

# Line 6 becomes:
if [ $# -ne "$ARGCOUNT" ]

# Line 12 becomes:
  echo "Usage: `basename $0` name"

For an example of using pseudo-code, see the Square Root exercise.
# To keep a record of which user scripts have run during a particular session or over a number of sessions, add the following lines to each script you want to keep track of. This will keep a continuing file record of the script names and invocation times.

				12.12.17.8.1.2 Keep track of scripts
# Append (>>) following to end of each script tracked.

whoami>> $SAVE_FILE    # User invoking the script.
echo $0>> $SAVE_FILE   # Script name.
date>> $SAVE_FILE      # Date and time.
echo>> $SAVE_FILE      # Blank line as separator.

#  Of course, SAVE_FILE defined and exported as environmental variable in ~/.bashrc
#+ (something like ~/.scripts-run)

# The >> operator appends lines to a file. What if you wish to prepend a line to an existing file, that is, to paste it in at the beginning?

file=data.txt
title="***This is the title line of data text file***"

echo $title | cat - $file >$file.new
# "cat -" concatenates stdout to $file.
#  End result is
#+ to write a new file with $title appended at *beginning*.

This is a simplified variant of the Example 18-13 script given earlier. And, of course, sed can also do this.
# A shell script may act as an embedded command inside another shell script, a Tcl or wish script, or even a Makefile. It can be invoked as an external shell command in a C program using the system() call, i.e., system("script_name");.
# Setting a variable to the contents of an embedded sed or awk script increases the readability of the surrounding shell wrapper. See Example A-1 and Example 14-20.

				12.12.17.8.1.3 Create script library
# Put together files containing your favorite and most useful definitions and functions. As necessary, "include" one or more of these "library files" in scripts with either the dot (.) or source command.

# SCRIPT LIBRARY
# ------ -------

# Note:
# No "#!" here.
# No "live code" either.


# Useful variable definitions

ROOT_UID=0             # Root has $UID 0.
E_NOTROOT=101          # Not root user error. 
MAXRETVAL=255          # Maximum (positive) return value of a function.
SUCCESS=0
FAILURE=-1



# Functions

Usage ()               # "Usage:" message.
{
  if [ -z "$1" ]       # No arg passed.
  then
    msg=filename
  else
    msg=$@
  fi

  echo "Usage: `basename $0` "$msg""
}  


Check_if_root ()       # Check if root running script.
{                      # From "ex39.sh" example.
  if [ "$UID" -ne "$ROOT_UID" ]
  then
    echo "Must be root to run this script."
    exit $E_NOTROOT
  fi
}  


CreateTempfileName ()  # Creates a "unique" temp filename.
{                      # From "ex51.sh" example.
  prefix=temp
  suffix=`eval date +%s`
  Tempfilename=$prefix.$suffix
}


isalpha2 ()            # Tests whether *entire string* is alphabetic.
{                      # From "isalpha.sh" example.
  [ $# -eq 1 ] || return $FAILURE

  case $1 in
  *[!a-zA-Z]*|"") return $FAILURE;;
  *) return $SUCCESS;;
  esac                 # Thanks, S.C.
}


abs ()                           # Absolute value.
{                                # Caution: Max return value = 255.
  E_ARGERR=-999999

  if [ -z "$1" ]                 # Need arg passed.
  then
    return $E_ARGERR             # Obvious error value returned.
  fi

  if [ "$1" -ge 0 ]              # If non-negative,
  then                           #
    absval=$1                    # stays as-is.
  else                           # Otherwise,
    let "absval = (( 0 - $1 ))"  # change sign.
  fi  

  return $absval
}


tolower ()             #  Converts string(s) passed as argument(s)
{                      #+ to lowercase.

  if [ -z "$1" ]       #  If no argument(s) passed,
  then                 #+ send error message
    echo "(null)"      #+ (C-style void-pointer error message)
    return             #+ and return from function.
  fi  

  echo "$@" | tr A-Z a-z
  # Translate all passed arguments ($@).

  return

				12.12.17.8.1.4  Use command substitution to set a variable to function output.
# For example:
#    oldvar="A seT of miXed-caSe LEtTerS"
#    newvar=`tolower "$oldvar"`
#    echo "$newvar"    # a set of mixed-case letters
#
# Exercise: Rewrite this function to change lowercase passed argument(s)
#           to uppercase ... toupper()  [easy].
}

#

				12.12.17.8.1.5 Use special-purpose comment headers to increase clarity and legibility in scripts.

## Caution.
rm -rf *.zzy   ##  The "-rf" options to "rm" are very dangerous,
               ##+ especially with wild cards.

#+ Line continuation.
#  This is line 1
#+ of a multi-line comment,
#+ and this is the final line.

#* Note.

#o List item.

#> Another point of view.
while [ "$var1" != "end" ]    #> while test "$var1" != "end"

#

Dotan Barak contributes template code for a progress bar in a script.

				12.12.17.8.1.6 Example 33-15. A Progress Bar

#!/bin/bash
# progress-bar.sh

# Author: Dotan Barak (very minor revisions by ABS Guide author).
# Used in ABS Guide with permission (thanks!).


BAR_WIDTH=50
BAR_CHAR_START="["
BAR_CHAR_END="]"
BAR_CHAR_EMPTY="."
BAR_CHAR_FULL="="
BRACKET_CHARS=2
LIMIT=100

print_progress_bar()
{
        # Calculate how many characters will be full.
        let "full_limit = ((($1 - $BRACKET_CHARS) * $2) / $LIMIT)"

        # Calculate how many characters will be empty.
        let "empty_limit = ($1 - $BRACKET_CHARS) - ${full_limit}"

        # Prepare the bar.
        bar_line="${BAR_CHAR_START}"
        for ((j=0; j<full_limit; j++)); do
                bar_line="${bar_line}${BAR_CHAR_FULL}"
        done

        for ((j=0; j<empty_limit; j++)); do
                bar_line="${bar_line}${BAR_CHAR_EMPTY}"
        done

        bar_line="${bar_line}${BAR_CHAR_END}"

        printf "%3d%% %s" $2 ${bar_line}
}

# Here is a sample of code that uses it.
MAX_PERCENT=100
for ((i=0; i<=MAX_PERCENT; i++)); do
        #
        usleep 10000
        # ... Or run some other commands ...
        #
        print_progress_bar ${BAR_WIDTH} ${i}
        echo -en "\r"
done

echo ""

exit

#

A particularly clever use of if-test constructs is for comment blocks.

#!/bin/bash

COMMENT_BLOCK=
#  Try setting the above variable to some value
#+ for an unpleasant surprise.

if [ $COMMENT_BLOCK ]; then

Comment block --
=================================
This is a comment line.
This is another comment line.
This is yet another comment line.
=================================

echo "This will not echo."

Comment blocks are error-free! Whee!

fi

echo "No more comments, please."

exit 0

Compare this with using here documents to comment out code blocks.
#

				12.12.17.8.1.7 $? for using exit status to perform tests
Using the $? exit status variable, a script may test if a parameter contains only digits, so it can be treated as an integer.

#!/bin/bash

SUCCESS=0
E_BADINPUT=65

test "$1" -ne 0 -o "$1" -eq 0 2>/dev/null
# An integer is either equal to 0 or not equal to 0.
# 2>/dev/null suppresses error message.

if [ $? -ne "$SUCCESS" ]
then
  echo "Usage: `basename $0` integer-input"
  exit $E_BADINPUT
fi

let "sum = $1 + 25"             # Would give error if $1 not integer.
echo "Sum = $sum"

# Any variable, not just a command line parameter, can be tested this way.

exit 0

#

				12.12.17.8.1.8 remember the 0-255 range for function return values
The 0 - 255 range for function return values is a severe limitation. Global variables and other workarounds are often problematic. An alternative method for a function to communicate a value back to the main body of the script is to have the function write to stdout (usually with echo) the "return value," and assign this to a variable. This is actually a variant of command substitution.

					12.12.17.8.1.8.1 Example 33-16. Return value trickery

#!/bin/bash
# multiplication.sh

multiply ()                     # Multiplies params passed.
{                               # Will accept a variable number of args.

  local product=1

  until [ -z "$1" ]             # Until uses up arguments passed...
  do
    let "product *= $1"
    shift
  done

  echo $product                 #  Will not echo to stdout,
}                               #+ since this will be assigned to a variable.

mult1=15383; mult2=25211
val1=`multiply $mult1 $mult2`
echo "$mult1 X $mult2 = $val1"
                                # 387820813

mult1=25; mult2=5; mult3=20
val2=`multiply $mult1 $mult2 $mult3`
echo "$mult1 X $mult2 X $mult3 = $val2"
                                # 2500

mult1=188; mult2=37; mult3=25; mult4=47
val3=`multiply $mult1 $mult2 $mult3 $mult4`
echo "$mult1 X $mult2 X $mult3 X $mult4 = $val3"
                                # 8173300

exit 0

					12.12.17.8.1.8.2 The same technique also works for alphanumeric strings. 
					
					This means that a function can "return" a non-numeric value.

capitalize_ichar ()          #  Capitalizes initial character
{                            #+ of argument string(s) passed.

  string0="$@"               # Accepts multiple arguments.

  firstchar=${string0:0:1}   # First character.
  string1=${string0:1}       # Rest of string(s).

  FirstChar=`echo "$firstchar" | tr a-z A-Z`
                             # Capitalize first character.

  echo "$FirstChar$string1"  # Output to stdout.

}  

newstring=`capitalize_ichar "every sentence should start with a capital letter."`
echo "$newstring"          # Every sentence should start with a capital letter.

It is even possible for a function to "return" multiple values with this method.

					12.12.17.8.1.8.3 Example 33-17. Even more return value trickery

#!/bin/bash
# sum-product.sh
# A function may "return" more than one value.

sum_and_product ()   # Calculates both sum and product of passed args.
{
  echo $(( $1 + $2 )) $(( $1 * $2 ))
# Echoes to stdout each calculated value, separated by space.
}

echo
echo "Enter first number "
read first

echo
echo "Enter second number "
read second
echo

retval=`sum_and_product $first $second`      # Assigns output of function.
sum=`echo "$retval" | awk '{print $1}'`      # Assigns first field.
product=`echo "$retval" | awk '{print $2}'`  # Assigns second field.

echo "$first + $second = $sum"
echo "$first * $second = $product"
echo

exit 0

Caution	There can be only one echo statement in the function for this to work. If you alter the previous example:

sum_and_product ()
{
  echo "This is the sum_and_product function." # This messes things up!
  echo $(( $1 + $2 )) $(( $1 * $2 ))
}
...
retval=`sum_and_product $first $second`      # Assigns output of function.
# Now, this will not work correctly.

#

				12.12.17.8.1.9

Next in our bag of tricks are techniques for passing an array to a function, then "returning" an array back to the main body of the script.

Passing an array involves loading the space-separated elements of the array into a variable with command substitution. Getting an array back as the "return value" from a function uses the previously mentioned strategem of echoing the array in the function, then invoking command substitution and the ( ... ) operator to assign it to an array.

Example 33-18. Passing and returning arrays

#!/bin/bash
# array-function.sh: Passing an array to a function and...
#                   "returning" an array from a function


Pass_Array ()
{
  local passed_array   # Local variable.
  passed_array=( `echo "$1"` )
  echo "${passed_array[@]}"
  #  List all the elements of the new array
  #+ declared and set within the function.
}


original_array=( element1 element2 element3 element4 element5 )

echo
echo "original_array = ${original_array[@]}"
#                      List all elements of original array.


# This is the trick that permits passing an array to a function.
# **********************************
argument=`echo ${original_array[@]}`
# **********************************
#  Pack a variable
#+ with all the space-separated elements of the original array.
#
# Note that attempting to just pass the array itself will not work.


# This is the trick that allows grabbing an array as a "return value".
# *****************************************
returned_array=( `Pass_Array "$argument"` )
# *****************************************
# Assign 'echoed' output of function to array variable.

echo "returned_array = ${returned_array[@]}"

echo "============================================================="

#  Now, try it again,
#+ attempting to access (list) the array from outside the function.
Pass_Array "$argument"

# The function itself lists the array, but...
#+ accessing the array from outside the function is forbidden.
echo "Passed array (within function) = ${passed_array[@]}"
# NULL VALUE since this is a variable local to the function.

echo

exit 0

For a more elaborate example of passing arrays to functions, see Example A-10.
#
				12.12.17.8.1.10 Using the double-parentheses construct
				it is possible to use C-style syntax for setting and incrementing/decrementing variables and in for and while loops. See Example 10-12 and Example 10-17.
#

				12.12.17.8.1.11 Setting the path and umask at the beginning of a script 
				makes it more "portable" -- more likely to run on a "foreign" machine whose user may have bollixed up the $PATH and umask.

#!/bin/bash
PATH=/bin:/usr/bin:/usr/local/bin ; export PATH
umask 022   # Files that the script creates will have 755 permission.

# Thanks to Ian D. Allen, for this tip.

#

				12.12.17.8.1.12 Repeatdly feed the output of filter
				A useful scripting technique is to repeatedly feed the output of a filter (by piping) back to the same filter, but with a different set of arguments and/or options. Especially suitable for this are tr and grep.

# From "wstrings.sh" example.

wlist=`strings "$1" | tr A-Z a-z | tr '[:space:]' Z | \
tr -cs '[:alpha:]' Z | tr -s '\173-\377' Z | tr Z ' '`

					12.12.17.8.1.12.1 Example 33-19. Fun with anagrams

#!/bin/bash
# agram.sh: Playing games with anagrams.

# Find anagrams of...
LETTERSET=etaoinshrdlu
FILTER='.......'       # How many letters minimum?
#       1234567

anagram "$LETTERSET" | # Find all anagrams of the letterset...
grep "$FILTER" |       # With at least 7 letters,
grep '^is' |           # starting with 'is'
grep -v 's$' |         # no plurals
grep -v 'ed$'          # no past tense verbs
# Possible to add many combinations of conditions and filters.

#  Uses "anagram" utility
#+ that is part of the author's "yawl" word list package.
#  http://ibiblio.org/pub/Linux/libs/yawl-0.3.2.tar.gz
#  http://personal.riverusers.com/~thegrendel/yawl-0.3.2.tar.gz

exit 0                 # End of code.


bash$ sh agram.sh
islander
isolate
isolead
isotheral



#  Exercises:
#  ---------
#  Modify this script to take the LETTERSET as a command-line parameter.
#  Parameterize the filters in lines 11 - 13 (as with $FILTER),
#+ so that they can be specified by passing arguments to a function.

#  For a slightly different approach to anagramming,
#+ see the agram2.sh script.

See also Example 27-4, Example 15-25, and Example A-9.
#

				12.12.17.8.1.13 annonymous here documents

Use "anonymous here documents" to comment out blocks of code, to save having to individually comment out each line with a #. See Example 18-11.
#

				12.12.17.8.1.14 use whatis to check commands availability
Running a script on a machine that relies on a command that might not be installed is dangerous. Use whatis to avoid potential problems with this.

CMD=command1                 # First choice.
PlanB=command2               # Fallback option.

command_test=$(whatis "$CMD" | grep 'nothing appropriate')
#  If 'command1' not found on system , 'whatis' will return
#+ "command1: nothing appropriate."
#
#  A safer alternative is:
#     command_test=$(whereis "$CMD" | grep \/)
#  But then the sense of the following test would have to be reversed,
#+ since the $command_test variable holds content only if
#+ the $CMD exists on the system.
#     (Thanks, bojster.)


if [[ -z "$command_test" ]]  # Check whether command present.
then
  $CMD option1 option2       #  Run command1 with options.
else                         #  Otherwise,
  $PlanB                     #+ run command2. 
fi

#

				12.12.17.8.1.15 Caution when using if-grep test
An if-grep test may not return expected results in an error case, when text is output to stderr, rather that stdout.

if ls -l nonexistent_filename | grep -q 'No such file or directory'
  then echo "File \"nonexistent_filename\" does not exist."
fi

Redirecting stderr to stdout fixes this.

if ls -l nonexistent_filename 2>&1 | grep -q 'No such file or directory'
#                             ^^^^
  then echo "File \"nonexistent_filename\" does not exist."
fi

# Thanks, Chris Martin, for pointing this out.

#

				12.12.17.8.1.16 If you absolutely must access a subshell variable outside the subshell, here's a way to do it.

TMPFILE=tmpfile                  # Create a temp file to store the variable.

(   # Inside the subshell ...
inner_variable=Inner
echo $inner_variable
echo $inner_variable >>$TMPFILE  # Append to temp file.
)

    # Outside the subshell ...

echo; echo "-----"; echo
echo $inner_variable             # Null, as expected.
echo "-----"; echo

# Now ...
read inner_variable <$TMPFILE    # Read back shell variable.
rm -f "$TMPFILE"                 # Get rid of temp file.
echo "$inner_variable"           # It's an ugly kludge, but it works.

#

The run-parts command is handy for running a set of command scripts in a particular sequence, especially in combination with cron or at.
#

For doing multiple revisions on a complex script, use the rcs Revision Control System package.

Among other benefits of this is automatically updated ID header tags. The co command in rcs does a parameter replacement of certain reserved key words, for example, replacing # $Id$ in a script with something like:

# $Id: hello-world.sh,v 1.1 2004/10/16 02:43:05 bozo Exp $

			    12.12.17.8.2. Widgets
It would be nice to be able to invoke X-Windows widgets from a shell script. There happen to exist several packages that purport to do so, namely Xscript, Xmenu, and widtools. The first two of these no longer seem to be maintained. Fortunately, it is still possible to obtain widtools here.

Caution	The widtools (widget tools) package requires the XForms library to be installed. Additionally, the Makefile needs some judicious editing before the package will build on a typical Linux system. Finally, three of the six widgets offered do not work (and, in fact, segfault).

The dialog family of tools offers a method of calling "dialog" widgets from a shell script. The original dialog utility works in a text console, but its successors, gdialog, Xdialog, and kdialog use X-Windows-based widget sets.

				12.12.17.8.2..1 Example 33-20. Widgets invoked from a shell script

#!/bin/bash
# dialog.sh: Using 'gdialog' widgets.

# Must have 'gdialog' installed on your system to run this script.
# Or, you can replace all instance of 'gdialog' below with 'kdialog' ...
# Version 1.1 (corrected 04/05/05)

# This script was inspired by the following article.
#     "Scripting for X Productivity," by Marco Fioretti,
#      LINUX JOURNAL, Issue 113, September 2003, pp. 86-9.
# Thank you, all you good people at LJ.


# Input error in dialog box.
E_INPUT=65
# Dimensions of display, input widgets.
HEIGHT=50
WIDTH=60

# Output file name (constructed out of script name).
OUTFILE=$0.output

# Display this script in a text widget.
gdialog --title "Displaying: $0" --textbox $0 $HEIGHT $WIDTH



# Now, we'll try saving input in a file.
echo -n "VARIABLE=" > $OUTFILE
gdialog --title "User Input" --inputbox "Enter variable, please:" \
$HEIGHT $WIDTH 2>> $OUTFILE


if [ "$?" -eq 0 ]
# It's good practice to check exit status.
then
  echo "Executed \"dialog box\" without errors."
else
  echo "Error(s) in \"dialog box\" execution."
        # Or, clicked on "Cancel", instead of "OK" button.
  rm $OUTFILE
  exit $E_INPUT
fi



# Now, we'll retrieve and display the saved variable.
. $OUTFILE   # 'Source' the saved file.
echo "The variable input in the \"input box\" was: "$VARIABLE""


rm $OUTFILE  # Clean up by removing the temp file.
             # Some applications may need to retain this file.

exit $?

# Exercise: Rewrite this script using the 'zenity' widget set.

The xmessage command is a simple method of popping up a message/query window. For example:

xmessage Fatal error in script! -button exit

The latest entry in the widget sweepstakes is zenity. This utility pops up GTK+ dialog widgets-and-windows, and it works very nicely within a script.

get_info ()
{
  zenity --entry       #  Pops up query window . . .
                       #+ and prints user entry to stdout.

                       #  Also try the --calendar and --scale options.
}

answer=$( get_info )   #  Capture stdout in $answer variable.

echo "User entered: "$answer""

For other methods of scripting with widgets, try Tk or wish (Tcl derivatives), PerlTk (Perl with Tk extensions), tksh (ksh with Tk extensions), XForms4Perl (Perl with XForms extensions), Gtk-Perl (Perl with Gtk extensions), or PyQt (Python with Qt extensions).

			12.12.17.9 Security Issues
			
			    12.12.17.9.1 Infected Shell Scripts
			    A brief warning about script security is indicated. A shell script may contain a worm, trojan, or even a virus. For that reason, never run as root a script (or permit it to be inserted into the system startup scripts in /etc/rc.d) unless you have obtained said script from a trusted source or you have carefully analyzed it to make certain it does nothing harmful.

Various researchers at Bell Labs and other sites, including M. Douglas McIlroy, Tom Duff, and Fred Cohen have investigated the implications of shell script viruses. They conclude that it is all too easy for even a novice, a "script kiddie," to write one. [1]

Here is yet another reason to learn scripting. Being able to look at and understand scripts may protect your system from being compromised by a rogue script.

			    12.12.17.9.2 Hiding Shell Script Source
For security purposes, it may be necessary to render a script unreadable. If only there were a utility to create a stripped binary executable from a script. Francisco Rosales' shc -- generic shell script compiler does exactly that.

Unfortunately, according to an article in the October, 2005 Linux Journal, the binary can, in at least some cases, be decrypted to recover the original script source. Still, this could be a useful method of keeping scripts secure from all but the most skilled hackers.

			    12.12.17.9.3 Writing Secure Shell Scripts
	Dan Stromberg suggests the following guidelines for writing (relatively) secure shell scripts.

    *

      Don't put secret data in environment variables.
    *

      Don't pass secret data in an external command's arguments (pass them in via a pipe or redirection instead).
    *

      Set your $PATH carefully. Don't just trust whatever path you inherit from the caller if your script is running as root. In fact, whenever you use an environment variable inherited from the caller, think about what could happen if the caller put something misleading in the variable, e.g., if the caller set $HOME to /etc.

Notes
[1]	See Marius van Oers' article, Unix Shell Scripting Malware, and also the Denning reference in the bibliography.		
			12.12.17.10 Portability Issues
			This book deals specifically with Bash scripting on a GNU/Linux system. All the same, users of sh  and ksh will find much of value here.

As it happens, many of the various shells and scripting languages seem to be converging toward the POSIX 1003.2 standard. Invoking Bash with the --posix option or inserting a set -o posix at the head of a script causes Bash to conform very closely to this standard. Another alternative is to use a #!/bin/sh sha-bang header in the script, rather than #!/bin/bash. [1] Note that /bin/sh is a link to /bin/bash in Linux and certain other flavors of UNIX, and a script invoked this way disables extended Bash functionality.

Most Bash scripts will run as-is under ksh, and vice-versa, since Chet Ramey has been busily porting ksh features to the latest versions of Bash.

On a commercial UNIX machine, scripts using GNU-specific features of standard commands may not work. This has become less of a problem in the last few years, as the GNU utilities have pretty much displaced their proprietary counterparts even on "big-iron" UNIX. Caldera's release of the source to many of the original UNIX utilities has accelerated the trend.

Bash has certain features that the traditional Bourne shell lacks. Among these are:

    * Certain extended invocation options
    * Command substitution using $( ) notation
    * The double brackets extended test construct
    * The double-parentheses arithmetic-evaluation construct
    * Certain string manipulation operations
    * Process substitution
    * A Regular Expression matching operator
    * Bash-specific builtins

See the Bash F.A.Q. for a complete listing.
Notes
[1]	Or, better yet, #!/bin/env sh.
			12.12.17.11 Shell Scripting Under Windows
			Even users running that other OS can run UNIX-like shell scripts, and therefore benefit from many of the lessons of this book. The  Cygwin package from Cygnus and the MKS utilities from Mortice Kern Associates add shell scripting capabilities to Windows.

There have been intimations that a future release of Windows will contain Bash-like command line scripting capabilities, but that remains to be seen.

		12.12.18 Chapter 34. Bash, versions 2 and 3
			12.12.18.1 Bash, version 2
 The current version of Bash, the one you have running on your machine, is most likely version 2.xx.yy or 3.xx.yy.

bash$ echo $BASH_VERSION
3.2.25(1)-release
	      

The version 2 update of the classic Bash scripting language added array variables, [1] string and parameter expansion, and a better method of indirect variable references, among other features.

Example 34-1. String expansion

#!/bin/bash

# String expansion.
# Introduced with version 2 of Bash.

#  Strings of the form $'xxx'
#+ have the standard escaped characters interpreted. 

echo $'Ringing bell 3 times \a \a \a'
     # May only ring once with certain terminals.
     # Or ...
     # May not ring at all, depending on terminal settings.
echo $'Three form feeds \f \f \f'
echo $'10 newlines \n\n\n\n\n\n\n\n\n\n'
echo $'\102\141\163\150'   # Bash
     # Octal equivalent of characters.

exit

Example 34-2. Indirect variable references - the new way

#!/bin/bash

# Indirect variable referencing.
# This has a few of the attributes of references in C++.


a=letter_of_alphabet
letter_of_alphabet=z

echo "a = $a"           # Direct reference.

echo "Now a = ${!a}"    # Indirect reference.
# The ${!variable} notation is greatly superior to the old "eval var1=\$$var2"

echo

t=table_cell_3
table_cell_3=24
echo "t = ${!t}"                      # t = 24
table_cell_3=387
echo "Value of t changed to ${!t}"    # 387

#  This is useful for referencing members of an array or table,
#+ or for simulating a multi-dimensional array.
#  An indexing option (analogous to pointer arithmetic)
#+ would have been nice. Sigh.

exit 0

# See also, ind-ref.sh example.

Example 34-3. Simple database application, using indirect variable referencing

#!/bin/bash
# resistor-inventory.sh
# Simple database / table-lookup application.

# ============================================================== #
# Data

B1723_value=470                                   # Ohms
B1723_powerdissip=.25                             # Watts
B1723_colorcode="yellow-violet-brown"             # Color bands
B1723_loc=173                                     # Where they are
B1723_inventory=78                                # How many

B1724_value=1000
B1724_powerdissip=.25
B1724_colorcode="brown-black-red"
B1724_loc=24N
B1724_inventory=243

B1725_value=10000
B1725_powerdissip=.125
B1725_colorcode="brown-black-orange"
B1725_loc=24N
B1725_inventory=89

# ============================================================== #


echo

PS3='Enter catalog number: '

echo

select catalog_number in "B1723" "B1724" "B1725"
do
  Inv=${catalog_number}_inventory
  Val=${catalog_number}_value
  Pdissip=${catalog_number}_powerdissip
  Loc=${catalog_number}_loc
  Ccode=${catalog_number}_colorcode

  echo
  echo "Catalog number $catalog_number:"
  # Now, retrieve value, using indirect referencing.
  echo "There are ${!Inv} of  [${!Val} ohm / ${!Pdissip} watt]\
  resistors in stock."  #        ^             ^
  echo "These are located in bin # ${!Loc}."
  echo "Their color code is \"${!Ccode}\"."

  break
done

echo; echo

# Exercises:
# ---------
# 1) Rewrite this script to read its data from an external file.
# 2) Rewrite this script to use arrays,
#+   rather than indirect variable referencing.
#    Which method is more straightforward and intuitive?
#    Which method is easier to code?


# Notes:
# -----
#  Shell scripts are inappropriate for anything except the most simple
#+ database applications, and even then it involves workarounds and kludges.
#  Much better is to use a language with native support for data structures,
#+ such as C++ or Java (or even Perl).

exit 0

Example 34-4. Using arrays and other miscellaneous trickery to deal four random hands from a deck of cards

#!/bin/bash

# Cards:
# Deals four random hands from a deck of cards.

UNPICKED=0
PICKED=1

DUPE_CARD=99

LOWER_LIMIT=0
UPPER_LIMIT=51
CARDS_IN_SUIT=13
CARDS=52

declare -a Deck
declare -a Suits
declare -a Cards
#  It would have been easier to implement and more intuitive
#+ with a single, 3-dimensional array.
#  Perhaps a future version of Bash will support multidimensional arrays.


initialize_Deck ()
{
i=$LOWER_LIMIT
until [ "$i" -gt $UPPER_LIMIT ]
do
  Deck[i]=$UNPICKED   # Set each card of "Deck" as unpicked.
  let "i += 1"
done
echo
}

initialize_Suits ()
{
Suits[0]=C #Clubs
Suits[1]=D #Diamonds
Suits[2]=H #Hearts
Suits[3]=S #Spades
}

initialize_Cards ()
{
Cards=(2 3 4 5 6 7 8 9 10 J Q K A)
# Alternate method of initializing an array.
}

pick_a_card ()
{
card_number=$RANDOM
let "card_number %= $CARDS"
if [ "${Deck[card_number]}" -eq $UNPICKED ]
then
  Deck[card_number]=$PICKED
  return $card_number
else  
  return $DUPE_CARD
fi
}

parse_card ()
{
number=$1
let "suit_number = number / CARDS_IN_SUIT"
suit=${Suits[suit_number]}
echo -n "$suit-"
let "card_no = number % CARDS_IN_SUIT"
Card=${Cards[card_no]}
printf %-4s $Card
# Print cards in neat columns.
}

seed_random ()  # Seed random number generator.
{               # What happens if you don't do this?
seed=`eval date +%s`
let "seed %= 32766"
RANDOM=$seed
#  What are some other methods
#+ of seeding the random number generator?
}

deal_cards ()
{
echo

cards_picked=0
while [ "$cards_picked" -le $UPPER_LIMIT ]
do
  pick_a_card
  t=$?

  if [ "$t" -ne $DUPE_CARD ]
  then
    parse_card $t

    u=$cards_picked+1
    # Change back to 1-based indexing (temporarily). Why?
    let "u %= $CARDS_IN_SUIT"
    if [ "$u" -eq 0 ]   # Nested if/then condition test.
    then
     echo
     echo
    fi
    # Separate hands.

    let "cards_picked += 1"
  fi  
done  

echo

return 0
}


# Structured programming:
# Entire program logic modularized in functions.

#================
seed_random
initialize_Deck
initialize_Suits
initialize_Cards
deal_cards
#================

exit 0



# Exercise 1:
# Add comments to thoroughly document this script.

# Exercise 2:
# Add a routine (function) to print out each hand sorted in suits.
# You may add other bells and whistles if you like.

# Exercise 3:
# Simplify and streamline the logic of the script.

Notes
[1]	

Chet Ramey has promised associative arrays (a nifty Perl feature) in a future Bash release. As of version 3.2, this has not yet happened.

			12.12.18.2 Bash, version 3
			On July 27, 2004, Chet Ramey released version 3 of Bash. This update fixed quite a number of bugs and added new features.

Some of the more important added features:

    *

      A new, more generalized {a..z} brace expansion operator.

      #!/bin/bash

      for i in {1..10}
      #  Simpler and more straightforward than
      #+ for i in $(seq 10)
      do
        echo -n "$i "
      done

      echo

      # 1 2 3 4 5 6 7 8 9 10



      # Or just . . .

      echo {a..z}    #  a b c d e f g h i j k l m n o p q r s t u v w x y z
      echo {z..a}    #  z y x w v u t s r q p o n m l k j i h g f e d c b a
                     #  Works backwards, too.
      echo {3..-2}   #  3 2 1 0 -1 -2
      echo {X..d}    #  X Y Z [  ] ^ _ ` a b c d
                     #  Shows (some of) the ASCII characters between Z and a,
                     #+ but don't rely on this type of behavior because . . .
      echo {]..a}    #  {]..a}
                     #  Why?

    *

      The ${!array[@]} operator, which expands to all the indices of a given array.

      #!/bin/bash

      Array=(element-zero element-one element-two element-three)

      echo ${Array[0]}   # element-zero
                         # First element of array.

      echo ${!Array[@]}  # 0 1 2 3
                         # All the indices of Array.

      for i in ${!Array[@]}
      do
        echo ${Array[i]} # element-zero
                         # element-one
                         # element-two
                         # element-three
                         #
                         # All the elements in Array.
      done

    *

      The =~ Regular Expression matching operator within a double brackets test expression. (Perl has a similar operator.)

      #!/bin/bash

      variable="This is a fine mess."

      echo "$variable"

      # Regex matching with =~ operator within [[ double brackets ]].
      if [[ "$variable" =~ "T.........fin*es*" ]]
      #                    ^                 ^
      # NOTE: Quoting not necessary, as of version 3.2 of Bash.
      then
        echo "match found"
            # match found
      fi

      Or, more usefully:

      #!/bin/bash

      input=$1


      if [[ "$input" =~ "[1-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]" ]]
      #                 ^ NOTE: Quoting not necessary, as of version 3.2 of Bash.
      # NNN-NN-NNNN (where each N is a digit). Initial digit must not be 0.
      then
        echo "Social Security number."
        # Process SSN.
      else
        echo "Not a Social Security number!"
        # Or, ask for corrected input.
      fi

      For additional examples of using the =~ operator, see Example A-31, Example 18-14, Example A-37, and Example A-26.
    *

      The new set -o pipefail option is useful for debugging pipes. If this option is set, then the exit status of a pipe is the exit status of the last command in the pipe to fail (return a non-zero value), rather than the actual final command in the pipe.

      See Example 15-43.

Caution	

The update to version 3 of Bash breaks a few scripts that worked under earlier versions. Test critical legacy scripts to make sure they still work!

As it happens, a couple of the scripts in the Advanced Bash Scripting Guide had to be fixed up (see Example A-21 and Example 9-4, for instance).
			
"
			    12.12.18.2.1 Bash, version 3.1
The version 3.1 update of Bash introduces a number of bugfixes and a few minor changes.

    *

      The += operator is now permitted in in places where previously only the = assignment operator was recognized.

      a=1
      echo $a        # 1

      a+=5           # Won't work under versions of Bash earlier than 3.1.
      echo $a        # 15

      a+=Hello
      echo $a        # 15Hello

      Here, += functions as a string concatenation operator. Note that its behavior in this particular context is different than within a let construct.

      a=1
      echo $a        # 1

      let a+=5       # Integer arithmetic, rather than string concatenation.
      echo $a        # 6

      let a+=Hello   # Doesn't "add" anything to a.
      echo $a        # 6

			    12.12.18.2.2 Bash, version 3.2
This is pretty much a bugfix update.

    *

      In global parameter substitutions, the pattern no longer anchors at the start of the string.
    *

      The --wordexp option disables process substitution.
    *

      The =~ Regular Expression match operator no longer requires quoting of the pattern within [[ ... ]].

      Caution	

      In fact, quoting in this context is not advisable as it may cause regex evaluation to fail. See the Ubuntu Bug List and Wikinerds on Bash syntax.

      With Bash version 3.2.25(1), running on Fedora Core, quoting works, but do not assume this will be the case on your machine.


13. Paralel, Cuncurency, LWPs, multiple threads

	13.1 Wait for Background Process to complete
$ ./wait.sh 
Thu Feb 10 15:59:50 CST 2005
Thu Feb 10 16:00:00 CST 2005
hello
$ cat wait.sh
date
sleep 10 &
wait $!
date
echo "hello"
$

		13.1.1 Run multiple processes and wait for them to complete
SingleTest(){

        (( limit = 5 ))
        (( iter = 0 ))

        while ((iter < limit ))
        do
                echo "iteration ${iter}"
                (( iter += 1 ))
        done
}

SingleTest &
SingleTest &
SingleTest &
SingleTest &
SingleTest &
SingleTest &

wait $!
echo "Terminated all tests"

		13.1.2 parallelism or multiple threads in BASH

 
I was working on a Nagios check the other day, which was looping over a number of items and assessing their status. I found that the check would routinely time out if the number of items was large. So, to make it scale I thought spawning the individual steps to run in parallel and then evaluating the status at the end would be a nice way to do it. There are many programming languagues that make this quite easy, but BASH isn't really know as one of those. Since the script was running pretty well as written in BASH I set out to try and stick with it rather than redoing the whole script. Here is what seems to work for this case.

Basically I rely on starting a background job, named pipe and the bash built in wait. The named pipe provides the ability to not have many individual output files, since I don't have much output to contend with.

Here is what the skeleton script looks like:


#!/bin/bash
 
OUTPUT="/tmp/.test"
mkfifo $OUTPUT &> /dev/null
 
# this is the slow running function
slow () {
  echo "begin $1"
  sleep 3;
  echo "slow $1" > $OUTPUT &
  echo "end $1"
}
 
# here the function is spwaned
for x in {1..3} ; do
  echo "spawn $x";
  slow $x &
done
 
# we wait for all the child processes to finish
echo waiting
wait
echo done waiting
 
# then we read the output
cat $OUTPUT
rm $OUTPUT

If you run the script you'll see something like this:

# ./foo.sh
spawn 1
spawn 2
begin 1
spawn 3
waiting
begin 3
begin 2
end 1
end 3
end 2
done waiting
slow 1
slow 2
slow 3
#

You can see that the processes don't even finish in order, which is exactly what I needed to deal with.

The interesting bits are that the function call must be backgrounded and the same with the output to the named pipe. It's also possible trap the exit code of the slow script.

One possible negative is that if the script is interrupted you might end up with some or all of the output from the last time the script was run. Then again, that may also be desirable outcome.

Here's to named pipes!

		13.1.3 My example,
#!/bin/bash
#===============================================================================
#
#          FILE:  multiple_slowFS_file_fetchers.bash
#       
#         USAGE:  multiple_slowFS_file_fetchers.bash
# 
#   DESCRIPTION:  Go to IPCentral and extract all ACS 5.1 libs
#   Must be done MT since the archive is extremely slow
# 
#       OPTIONS:  ---
#  REQUIREMENTS:  ---
#          BUGS:  ---
#         NOTES:  ---
#        AUTHOR:   Yosi Izaq 
#       COMPANY:  
#       VERSION:  1.0
#       CREATED:  06/06/2007 11:38:08 AM IDT
#      REVISION:  ---
#===============================================================================

ARCHIVE_LOC="/auto/ipcentral-vault-1/ipcentral-prod/unpacked/projects/ACS 5.1"
TRG_LOC="/users/yizaq/temp"
ARCHIVE_NAME="acs_5_1_src_publication_"

cd "$ARCHIVE_LOC"

ArchiveLibs(){


        echo "archiving libs starting with letter $1"
        echo "exec: tar cvhz ${TRG_LOC}/${ARCHIVE_NAME}$1.tarz $1*"
        #touch ${TRG_LOC}/${ARCHIVE_NAME}$1.tarz
        tar -zcvhf ${TRG_LOC}/${ARCHIVE_NAME}$1.tarz $1*
}

for let in {a..z} ; do
        ArchiveLibs "$let" &
        sleep 1
done

wait $!
echo "Terminated all archive threads"
		13.1.4

14. Cookbook solutions 

	14.1 Reverse bash array (reverse list)
Currently there's no reverse primitive (like in perl and python), so have to do it the manual way:
		14.1.1 Pure Bash solution
a=(alpha beta gamma delta epsilon);
len=${#a[@]};

echo ${a[@]};

i=0;
while (($i < $len/2 )); do
     tmp=${a[i]};
     a[i]=${a[$len-$i-1]};
     a[$len-$i-1]=$tmp;  
     ((i++));
done

echo ${a[@]};

		14.1.2 Using AWK 
-> Possible solution
 vector=( one two three )
 echo ${vector[@]}
one two three
 vector=( $(echo ${vector[@]} | awk '{split($0,A); for (el in A) res = A[el]" "res; print res}') )
 echo ${vector[@]}
three two one

-> More consice:
 echo "one two three four" | awk '{for (i=NF;i>=1;i--) printf $i" "} END{print ""}'
four three two one

		14.1.3 As a function 
function my_reverse(){

        local arr
        arr=( `echo "$1"` )
        echo ${arr[@]}| awk '{for (i=NF;i>=1;i--) printf $i" "} END{print ""}'
}

Using that function:
-> For just printing the reversed array:
#Just experminet with passing and retrieving arrays to/from function
# and checking that reverse utility function is working.
orig_arr=( aaa bbb ccc ddd )
argument=`echo ${orig_arr[@]}`
reversed_arr=( `my_reverse "$argument"` )
#echo "${reversed_arr[@]}"

-> For using a reversed array:
# uninstall in reverse order of installment
argument=`echo ${RPM_NAMES[@]}`
RPM_NAMES=( `my_reverse "$argument"` )


	14.2 Monitor file size doesn't exceed given quota

[root@acs-yizaq-01 ~]# while true; do if test $( stat  /opt/CSCOacs/logs/monit.log  | awk '/Size:/ { print $2}'  ) -gt 11535158999 ; then echo monit exceeds quota flushing it; echo /dev/null > /opt/CSCOacs/logs/monit.log ; fi ; sleep 60; done

You have new mail in /var/spool/mail/root
[root@acs-yizaq-01 ~]# while true; do if test $( stat  /opt/CSCOacs/logs/monit.log  | awk '/Size:/ { print $2}'  ) -gt 1153 ; then echo monit exceeds quota flushing it; echo /dev/null > /opt/CSCOacs/logs/monit.log ; fi ; sleep 60; done
monit exceeds quota flushing it

[root@acs-yizaq-01 ~]# ls -lrh /opt/CSCOacs/logs/monit.log
-rw------- 1 root root 10 Mar 19 17:47 /opt/CSCOacs/logs/monit.log

	14.3 Time

		14.3.1 Linux - bash script to calculate time elapsed
ex:
[root@cd-pos-13-139 tmp]# STARTTIME=$(date +%s)
[root@cd-pos-13-139 tmp]# ENDTIME=$(date +%s)
[root@cd-pos-13-139 tmp]# echo "Elapsed time is $((  $ENDTIME - $STARTTIME )) seconds"
Elapsed time is 8 seconds
[root@cd-pos-13-139 tmp]# if (( $((  $ENDTIME - $STARTTIME )) < 10 )) 
> then
> echo "Elapsed time is less than 10 seconds"
> else
> echo "Elapsed time is more than or equal 10 seconds"
> fi
Elapsed time is less than 10 seconds
[root@cd-pos-13-139 tmp]# STARTTIME=$(date +%s)
[root@cd-pos-13-139 tmp]# ENDTIME=$(date +%s)
[root@cd-pos-13-139 tmp]# echo "Elapsed time is $((  $ENDTIME - $STARTTIME )) seconds"
Elapsed time is 55 seconds
[root@cd-pos-13-139 tmp]# if (( $((  $ENDTIME - $STARTTIME )) < 10 )) ; then echo "Elapsed time is less than 10 seconds"; else echo "Elapsed time is more than or equal 10 seconds"; fi
Elapsed time is more than or equal 10 seconds

		14.3.2

	14.4 Locks

		14.4.1 Lock your script (against parallel run)

			14.4.1.1  flock


				14.4.1.1.1  Elegant Locking of BASH Program
NOV 6TH, 2012 | COMMENTS
Intro

I want to block program from running twice simultaneously. Why would I want such a thing? Lets say you have a program that creates the directory /tmp/prog and update files inside this directory. If you run the program twice at the same time, files inside this directory will get clobbered. Searching the net for solution, flock comes up as a good way to solve the problem. flock is part of the util-linux package.

Basic solution

Here is an example posted at stackoverflow:

1
2
3
4
5
6
7
8
9
10
11
12
#!/bin/bash

# Makes sure we exit if flock fails.
set -e

(
    # Wait for lock on /var/lock/.myscript.exclusivelock (fd 200) for 10 seconds
    flock -n 200

    # Do stuff

) 200>/var/lock/.myscript.exclusivelock
At the heart of the locking mechanizm is the last line, which create the file /var/lock/.myscript.exclusivelock using file descriptor 200. The syntax 9>textfile, is the way in BASH to create textfile using file descriptor 9. Then we check if the file is locked in line 8, flock -n 200 using the file descriptor 200 we used to create the lock file with. So while the critical code after line 8, that runs in the sub shell, is running, the file /var/lock/.myscript.exclusivelock stays locked, and will be released when the sub shell exits.

Next step

My first rule of programming in BASH, is to have all the code functional and the only line that is globally executed is main like this:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
#!/bin/bash

do_A() {
    ...
}

do_B() {
    ...
}

main() {
    do_A
    do_B
}
main
So using this example, to lock the program we can do this:

1
2
3
4
5
6
7
8
9
10
main() {
    do_A
    do_B
}

(
    flock -n 200
    main

) 200>/var/lock/.myscript.exclusivelock
or:

1
2
3
4
5
6
7
8
9
main() {
    (
        flock -n 200
        do_A
        do_B

    ) 200>/var/lock/.myscript.exclusivelock
}
main
First example breaks my rule, and main is not the only global code, but is not too bad. The second example, does not look good to me. It seems that main have more syntax complexity then it should. What we really want, in order to keep the code clean, is creating a lock function that will behave like this:

1
2
3
4
5
main() {
    lock || exit 1
    do_A
    do_B
}
Creating a locking function

To move locking to a function, well need to get rid of this sub shell syntax.

1
2
3
4
5
(
    flock -n 200
    ...

) 200>/var/lock/.myscript.exclusivelock
The answer is to be found in jdimpsons blog post using flock to protect critical sections in shell scripts. Using exec to create the lock file:

exec 200>/var/lock/.myscript.exclusivelock
Now we can crate the lock file, and use flock to acquire it:

1
2
3
4
5
6
7
8
9
10
main() {
    exec 200>/var/lock/.myscript.exclusivelock

    flock -n 200 \
        || exit 1

    do_A
    do_B
}
main
Lets create the lock function:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
lock() {
    exec 200>/var/lock/.myscript.exclusivelock

    flock -n 200 \
        && return 0 \
        || return 1
}

main() {
    lock || exit 1

    do_A
    do_B
}
main
So now we have hard coded function ;-) What can we do next? Lets get rid of the magic number 200 and the lock filename, and turn them to a variables.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
#!/bin/bash

readonly PROGNAME=$(basename "$0")
readonly LOCKFILE_DIR=/tmp
readonly LOCK_FD=200

lock() {
    local prefix=$1
    local fd=${2:-$LOCK_FD}
    local lock_file=$LOCKFILE_DIR/$prefix.lock

    # create lock file
    eval "exec $fd>$lock_file"

    # acquier the lock
    flock -n $fd \
        && return 0 \
        || return 1
}

eexit() {
    local error_str="$@"

    echo $error_str
    exit 1
}

main() {
    lock $PROGNAME \
        || eexit "Only one instance of $PROGNAME can run at one time."

    do_A
    do_B
}
main
So now we have a lock function that does what we want. It gets the prefix of the lock filename, and then variable fd is 200 by default, but you can specify different file descriptor number like this lock $PROGNAME 500. The important change in the lock function is the turning of 200 to a variable $fd, and to be able to execute the lock file creation, we use eval. Try it without eval and see what happens. You will get error that there is no command 200.

Conclusion

We arrived from script like locking mechanism to a well closed lock function, that will create exclusivity of the program running. I would go further and paste this lock command to a library of its own. Then source it. i.e. source /usr/lib/lock.sh. Look again at the main function and see how elegant and expressive it is. i.e. lock program or exit the program, because another instance of the program is already running.

nJoy,
Kfir

			14.4.1.2
		14.4.2

	14.5
15.  odds and ends

	15.1  Block signals
		15.1.1  SIGTERM, block ctrl+x

one way to do it:
#!/bin/sh

trap "echo 'Trap sprung!'" INT TERM
while 'true'; do sleep 5; done

Or:
#!/usr/bin/bash

trap 'echo "you typed ctrl/c"; ' INT
while true
do
 sleep 20
done

		15.1.2 Catching signals

			15.1.2.1 Finding the signal man page

Your system contains a man page listing all the available signals, but depending on your operating system, it might be opened in a different way. On most Linux systems, this will be man 7 signal. When in doubt, locate the exact man page and section using commands like

man -k signal | grep list

or

apropos signal | grep list

Signal names can be found using kill -l.

			15.1.2.2 Signals to your Bash shell

In the absence of any traps, an interactive Bash shell ignores SIGTERM and SIGQUIT. SIGINT is caught and handled, and if job control is active, SIGTTIN, SIGTTOU and SIGTSTP are also ignored. Commands that are run as the result of a command substitution also ignore these signals, when keyboard generated.

SIGHUP by default exits a shell. An interactive shell will send a SIGHUP to all jobs, running or stopped; see the documentation on the disown built-in if you want to disable this default behavior for a particular process. Use the huponexit option for killing all jobs upon receiving a SIGHUP signal, using the shopt built-in.

Sending signals using the shell

The following signals can be sent using the Bash shell:

Table 12.1. Control signals in Bash

Standard key combination	Meaning
Ctrl+C	The interrupt signal, sends SIGINT to the job running in the foreground.
Ctrl+Y	The delayed suspend character. Causes a running process to be stopped when it attempts to read input from the terminal. Control is returned to the shell, the user can foreground, background or kill the process. Delayed suspend is only available on operating systems supporting this feature.
Ctrl+Z	The suspend signal, sends a SIGTSTP to a running program, thus stopping it and returning control to the shell.

	Terminal settings
Check your stty settings. Suspend and resume of output is usually disabled if you are using modern terminal emulations. The standard xterm supports Ctrl+S and Ctrl+Q by default.

			15.1.2.3 Usage of signals with kill

Most modern shells, Bash included, have a built-in kill function. In Bash, both signal names and numbers are accepted as options, and arguments may be job or process IDs. An exit status can be reported using the -l option: zero when at least one signal was successfully sent, non-zero if an error occurred.

Using the kill command from /usr/bin, your system might enable extra options, such as the ability to kill processes from other than your own user ID and specifying processes by name, like with pgrep and pkill.

Both kill commands send the TERM signal if none is given.

This is a list of the most common signals:

Table 12.2. Common kill signals

Signal name	Signal value	Effect
SIGHUP	1	Hangup
SIGINT	2	Interrupt from keyboard
SIGKILL	9	Kill signal
SIGTERM	15	Termination signal
SIGSTOP	17,19,23	Stop the process

	SIGKILL and SIGSTOP
SIGKILL and SIGSTOP can not be caught, blocked or ignored.

When killing a process or series of processes, it is common sense to start trying with the least dangerous signal, SIGTERM. That way, programs that care about an orderly shutdown get the chance to follow the procedures that they have been designed to execute when getting the SIGTERM signal, such as cleaning up and closing open files. If you send a SIGKILL to a process, you remove any chance for the process to do a tidy cleanup and shutdown, which might have unfortunate consequences.

But if a clean termination does not work, the INT orKILL signals might be the only way. For instance, when a process does not die using Ctrl+C, it is best to use the kill -9 on that process ID:

maud: ~> ps -ef | grep stuck_process
maud    5607   2214  0 20:05 pts/5    00:00:02 stuck_process

maud: ~> kill -9 5607

maud: ~> ps -ef | grep stuck_process
maud    5614    2214 0 20:15 pts/5    00:00:00 grep stuck_process
[1]+ Killed		stuck_process
When a process starts up several instances, killall might be easier. It takes the same option as the kill command, but applies on all instances of a given process. Test this command before using it in a production environment, since it might not work as expected on some of the commercial Unices.

id=__bash_trap_signals__
			15.1.2.4 Traps

There might be situations when you don't want users of your scripts to exit untimely using keyboard abort sequences, for example because input has to be provided or cleanup has to be done. The trap statement catches these sequences and can be programmed to execute a list of commands upon catching those signals.

The syntax for the trap statement is straightforward:

trap [COMMANDS] [SIGNALS]

This instructs the trap command to catch the listed SIGNALS, which may be signal names with or without the SIG prefix, or signal numbers. If a signal is 0 or EXIT, the COMMANDS are executed when the shell exits. If one of the signals is DEBUG, the list of COMMANDS is executed after every simple command. A signal may also be specified as ERR; in that case COMMANDS are executed each time a simple command exits with a non-zero status. Note that these commands will not be executed when the non-zero exit status comes from part of an if statement, or from a while or until loop. Neither will they be executed if a logical AND (&&) or OR (||) result in a non-zero exit code, or when a command's return status is inverted using the ! operator.

The return status of the trap command itself is zero unless an invalid signal specification is encountered. The trap command takes a couple of options, which are documented in the Bash info pages.

Here is a very simple example, catching Ctrl+C from the user, upon which a message is printed. When you try to kill this program without specifying the KILL signal, nothing will happen:

#!/bin/bash
# traptest.sh

trap "echo Booh!" SIGINT SIGTERM
echo "pid is $$"

while :			# This is the same as "while true".
do
        sleep 60	# This script is not really doing anything.
done


<URL:/cygdrive/c/work/scripts/bash/traptest.sh>

			15.1.2.5 How Bash interprets traps

When Bash receives a signal for which a trap has been set while waiting for a command to complete, the trap will not be executed until the command completes. When Bash is waiting for an asynchronous command via the wait built-in, the reception of a signal for which a trap has been set will cause the wait built-in to return immediately with an exit status greater than 128, immediately after which the trap is executed.

			15.1.2.6 More examples

Detecting when a variable is used

When debugging longer scripts, you might want to give a variable the trace attribute and trap DEBUG messages for that variable. Normally you would just declare a variable using an assignment like VARIABLE=value. Replacing the declaration of the variable with the following lines might provide valuable information about what your script is doing:

declare -t VARIABLE=value

trap "echo VARIABLE is being used here." DEBUG

# rest of the script
Removing rubbish upon exit

The whatis command relies on a database which is regularly built using the makewhatis.cron script with cron:

#!/bin/bash

LOCKFILE=/var/lock/makewhatis.lock

# Previous makewhatis should execute successfully:

[ -f $LOCKFILE ] && exit 0

# Upon exit, remove lockfile.

trap "{ rm -f $LOCKFILE ; exit 255; }" EXIT

touch $LOCKFILE
makewhatis -u -w
exit 0
		15.1.3
	15.2 Tutorial: Conditions in bash scripting (if statements)
If you use bash for scripting you will undoubtedly have to use conditions a lot, for example for an if ... then construct or a while loop. The syntax of these conditions can seem a bit daunting to learn and use. This tutorial aims to help the reader understanding conditions in bash, and provides a comprehensive list of the possibilities. A small amount of general shell knowledge is assumed.


		15.2.1 Introduction
Bash features a lot of built-in checks and comparisons, coming in quite handy in many situations. You've probably seen if statements like the following before:

if [ $foo -ge 3 ]; then

The condition in this example is essentially a command. It may sound strange, but surrounding a comparison with square brackets is the same as using the built-in test command, like this:

if test $foo -ge 3; then

If $foo is Greater then or Equal to 3, the block after 'then' will be executed. If you always wondered why bash tends to use -ge or -eq instead of >= or ==, it's because this condition type originates from a command, where -ge and -eq are options.
And that's what if does essentially, checking the exit status of a command. I'll explain that in more detail further in the tutorial.
There also are built-in checks that are more specific to shells. What
about this one?

if [ -f regularfile ]; then

The above condition is true if the file 'regularfile' exists and
is a regular file. A regular file means that it's not a block or
character device, or a directory. This way, you can make sure a usable
file exists before doing something with it. You can even check if a
file is readable!

if [ -r readablefile]; then

The above condition is true if the file 'readablefile' exists and is readable. Easy, isn't it?

		15.2.2 The syntax of an if statement (a short explanation)
The basic syntax of an if ... then statement is like this:

if <condition>; then
<commands>
fi

The condition is, depending on its type, surrounded by certain
brackets, eg. [ ]. You can read about the different types further on
in the tutorial. You can add commands to be executed when the condition is false using the else keyword, and use the elif (elseif) keyword to execute commands on another condition if the primary condition is false. The else keyword always comes last. Example:

if [ -r somefile ]; then
content=$(cat somefile)
elif [ -f somefile ]; then
echo "The file 'somefile' exists but is not readable to the script."
else
echo "The file 'somefile' does not exist."
fi

A short explanation of the example: first we check if the file somefile is readable ("if [ -r somefile ]"). If so, we read it into a variable. If not, we check if it actually exists ("elif [ -f somefile ]"). If that's true, we report that it exists but isn't readable (if it was, we would have read the content). If the file doesn't exist, we report so, too. The condition at elif is only executed if the condition at if was false. The commands belonging to else are only executed if both conditions are false.

		15.2.3 The basic rules of conditions
When you start writing and using your own conditions, there are some rules you should know to prevent getting errors that are hard to trace. Here follow three important ones:

Always keep spaces between the brackets and the actual check/comparison. The following won't work:
if [$foo -ge 3]; then

Bash will complain about a "missing `]'".
Always terminate the line before putting a new keyword like "then". The words if, then, else, elif and fi are shell keywords, meaning that they cannot share the same line. Put a ";" between the previous statement and the keyword or place the keyword on the start of a new line. Bash will throw errors like "syntax error near unexpected token `fi'" if you don't.
It is a good habit to quote string variables if you use them in conditions, because otherwise they are likely to give trouble if they contain
spaces and/or newlines. By quoting I mean:
if [ "$stringvar" == "tux" ]; then

There are a few cases in which you should not
quote, but they are rare. You will see one of them further on in the tutorial.
Also, there are two things that may be useful to know:

You can invert a condition by putting an "!" in front of it. Example:
if [ ! -f regularfile ]; then

Be sure to place the "!" inside the brackets!
You can combine conditions by using certain operators. For the single-bracket syntax that we've been using so far, you can use "-a" for and and "-o" for or. Example:
if [ $foo -ge 3 -a $foo -lt 10 ]; then

The above condition will return true if $foo contains an integer greater than or equal to 3 and Less Than 10. You can read more about these combining expressions at the respective condition syntaxes.
And, one more basic thing: don't forget that conditions can also be used in other statements, like while and until. It is outside the scope of this tutorial to explain those, but you can read about them at the Bash Guide for Beginners.

Anyway, I've only shown you conditions between single brackets so far. There are more syntaxes, however, as you will read in the next section.

		15.2.4 Different condition syntaxes
Bash features different syntaxes for conditions. I will list the three of them:

			15.2.4.1 Single-bracket syntax
This is the condition syntax you have already seen in the previous paragraphs; it's the oldest supported syntax. It supports three types of conditions:

File-based conditions
Allows different kinds of checks on a file. Example:
if [ -L symboliclink ]; then

The above condition is true if the file 'symboliclink' exists and is a symbolic link. For more file-based conditions see the table below.
String-based conditions
Allows checks on a string and comparing of strings. Example one:
if [ -z "$emptystring" ]; then

The above condition is true if $emptystring is an empty string or an uninitialized variable. Example two:
if [ "$stringvar1" == "cheese" ]; then

The above condition is true if $stringvar1 contains just the string "cheese". For more string-based conditions see the table below.
Arithmetic (number-based) conditions
Allows comparing integer numbers. Example:
if [ $num -lt 1 ]; then

The above condition returns true if $num is less than 1. For more arithmetic conditions see the table below.

			15.2.4.2 Double-bracket syntax
You may have encountered conditions enclosed in double square brackets already, which look like this:

if [[ "$stringvar" == *string* ]]; then

The double-bracket syntax serves as an enhanced version of the single-bracket syntax; it mainly has the same features, but also some important differences with it. I will list them here:

The first difference can be seen in the above example; when comparing strings, the double-bracket syntax features shell globbing. This means that an asterisk ("*") will expand to literally anything, just as you probably know from normal command-line usage. Therefore, if $stringvar contains the phrase "string" anywhere, the condition will return true. Other forms of shell globbing are allowed, too. If you'd like to match both "String" and "string", you could use the following syntax:
if [[ "$stringvar" == *[sS]tring* ]]; then

Note that only general shell globbing is allowed. Bash-specific things like {1..4} or {foo,bar} will not work. Also note that the globbing will not work if you quote the right string. In this case you should leave it unquoted.
The second difference is that word splitting is prevented. Therefore, you could omit placing quotes around string variables and use a condition like the following without problems:
if [[ $stringvarwithspaces != foo ]]; then

Nevertheless, the quoting string variables remains a good habit, so I recommend just to keep doing it.
The third difference consists of not expanding filenames. I will illustrate this difference using two examples, starting with the old single-bracket situation:
if [ -a *.sh ]; then

The above condition will return true if there is one single file in the working directory that has a .sh extension. If there are none, it will return false. If there are several .sh files, bash will throw an error and stop executing the script. This is because *.sh is expanded to the files in the working directory. Using double brackets prevents this:
if [[ -a *.sh ]]; then

The above condition will return true only if there is a file in the working directory called "*.sh", no matter what other .sh files exist. The asterisk is taken literally, because the double-bracket syntax does not expand filenames.
The fourth difference is the addition of more generally known combining expressions, or, more specific, the operators "&&" and "||". Example:
if [[ $num -eq 3 && "$stringvar" == foo ]]; then

The above condition returns true if $num is equal to 3 and $stringvar is equal to "foo". The -a and -o known from the single-bracket syntax is supported, too.
Note that the and operator has precedence over the or operator, meaning that "&&" or "-a" will be evaluated before "||" or "-o".
The fifth difference is that the double-bracket syntax allows regex pattern matching using the "=~" operator. See the table for more information.

			15.2.4.3 Double-parenthesis syntax
There also is another syntax for arithmetic (number-based) conditions, most likely adopted from the Korn shell:

if (( $num <= 5 )); then

The above condition is true if $num is less than or equal to 5. This syntax may seem more familiar to programmers. It features all the 'normal' operators, like "==", "<" and ">=". It supports the "&&" and "||" combining expressions (but not the -a and -o ones!). It is equivalent to the built-in let command.

		15.2.5 Table of conditions
The following table list the condition possibilities for both the single- and the double-bracket syntax. Save a single exception, the examples are given in single-bracket syntax, but are always compatible with double brackets.

			15.2.5.1 File-based conditions:
Condition	True if	Example/explanation
[ -a existingfile ]	file 'existingfile' exists.	if [ -a tmp.tmp ]; then
    rm -f tmp.tmp # Make sure we're not bothered by an old temporary file
fi
[ -b blockspecialfile ]	file 'blockspecialfile' exists and is block special.	Block special files are special kernel files found in /dev, mainly used for ATA devices like hard disks, cd-roms and floppy disks.
if [ -b /dev/fd0 ]; then
    dd if=floppy.img of=/dev/fd0 # Write an image to a floppy
fi
[ -c characterspecialfile ]	file 'characterspecialfile' exists and is character special.	Character special files are special kernel files found in /dev, used for all kinds of purposes (audio hardware, tty's, but also /dev/null).
if [ -c /dev/dsp ]; then
    cat raw.wav > /dev/dsp # This actually works for certain raw wav files
fi
[ -d directory ]	file 'directory' exists and is a directory.	In UNIX-style, directories are a special kind of file.
if [ -d ~/.kde ]; then
    echo "You seem to be a kde user."
fi
[ -e existingfile ]	file 'existingfile' exists.	(same as -a, see that entry for an example)
[ -f regularfile ]	file 'regularfile' exists and is a regular file.	A regular file is neither a block or character special file nor a directory.
if [ -f ~/.bashrc ]; then
    source ~/.bashrc
fi
[ -g sgidfile ]	file 'sgidfile' exists and is set-group-ID.	When the SGID-bit is set on a directory, all files created in that directory will inherit the group of the directory.
if [ -g . ]; then
   echo "Created files are inheriting the group '$(ls -ld . | awk '{ print $4 }')' from the working directory."
fi
[ -G fileownedbyeffectivegroup ]	file 'fileownedbyeffectivegroup' exists and is owned by the effective group ID.	The effective group id is the primary group id of the executing user.
if [ ! -G file ]; then # An exclamation mark inverts the outcome of the condition following it
   chgrp $(id -g) file # Change the group if it's not the effective one
fi
[ -h symboliclink ]	file 'symboliclink' exists and is a symbolic link.	if [ -h $pathtofile ]; then
    pathtofile=$(readlink -e $pathtofile) # Make sure $pathtofile contains the actual file and not a symlink to it
fi
[ -k stickyfile ]	file 'stickyfile' exists and has its sticky bit set.	The sticky bit has got quite a history, but is now used to prevent world-writable directories from having their contents deletable by anyone.
if [ ! -k /tmp ]; then # An exclamation mark inverts the outcome of the condition following it
    echo "Warning! Anyone can delete and/or rename your files in /tmp!"
fi
[ -L symboliclink ]	file 'symboliclink' exists and is a symbolic link.	(same as -h, see that entry for an example)
[ -N modifiedsincelastread ]	file 'modifiedsincelastread' exists and was modified after the last read.	if [ -N /etc/crontab ]; then
    killall -HUP crond # SIGHUP makes crond reread all crontabs
fi
[ -O fileownedbyeffectiveuser ]	file 'fileownedbyeffectiveuser' exists and is owned by the user executing the script.	if [ -O file ]; then
    chmod 600 file # Makes the file private, which is a bad idea if you don't own it
fi
[ -p namedpipe ]	file 'namedpipe' exists and is a named pipe.	A named pipe is a file in /dev/fd/ that can be read just once. See my bash tutorial for a case in which it's used.
if [ -p $file ]; then
    cp $file tmp.tmp # Make sure we'll be able to read
    file="tmp.tmp"    # the file as many times as we like
fi
[ -r readablefile ]	file 'readablefile' exists and is readable to the script.	if [-r file ]; then
    content=$(cat file) # Set $content to the content of the file
fi
[ -s nonemptyfile ]	file 'nonemptyfile' exists and has a size of more than 0 bytes.	if [ -s logfile ]; then
    gzip logfile    # Backup the old logfile
    touch logfile # before creating a fresh one.
fi
[ -S socket ]	file 'socket' exists and is a socket.	A socket file is used for inter-process communication, and features an interface similar to a network connection.
if [ -S /var/lib/mysql/mysql.sock ]; then
    mysql --socket=/var/lib/mysql/mysql.sock # See this MySQL tip
fi
[ -t openterminal ]	file descriptor 'openterminal' exists and refers to an open terminal.	Virtually everything is done using files on Linux/UNIX, and the terminal is no exception.
if [ -t /dev/pts/3 ]; then
    echo -e "\nHello there. Message from terminal $(tty) to you." > /dev/pts/3 # Anyone using that terminal will actually see this message!
fi
[ -u suidfile ]	file 'suidfile' exists and is set-user-ID.	Setting the suid-bit on a file causes execution of that file to be done with the credentials of the owner of the file, not of the executing user.
if [ -u executable ]; then
    echo "Running program executable as user $(ls -l executable | awk '{ print $3 }')."
fi
[ -w writeablefile ]	file 'writeablefile' exists and is writeable to the script.	if [ -w /dev/hda ]; then
    grub-install /dev/hda
fi
[ -x executablefile ]	file 'executablefile' exists and is executable for the script.	Note that the execute permission on a directory means that it's searchable (you can see which files it contains).
if [ -x /root ]; then
    echo "You can view the contents of the /root directory."
fi
[ newerfile -nt olderfile ]	file 'newerfile' was changed more recently than 'olderfile', or if 'newerfile' exists and 'olderfile' doesn't.	if [ story.txt1 -nt story.txt ]; then
    echo "story.txt1 is newer than story.txt; I suggest continuing with the former."
fi
[ olderfile -ot newerfile ]	file 'olderfile' was changed longer ago than 'newerfile', or if 'newerfile' exists and 'olderfile' doesn't.	if [ /mnt/remote/remotefile -ot localfile ]; then
    cp -f localfile /mnt/remote/remotefile # Make sure the remote location has the newest version of the file, too
fi
[ same -ef file ]	file 'same' and file 'file' refer to the same device/inode number.	if [ /dev/cdrom -ef /dev/dvd ]; then
    echo "Your primary cd drive appears to read dvd's, too."
fi

			15.2.5.2 String-based conditions:
Condition	True if	Example/explanation
[ STRING1 == STRING2 ]	STRING1 is equal to STRING2.	if [ "$1" == "moo" ]; then
    echo $cow # Ever tried executing 'apt-get moo'?
fi
Note: you can also use a single "=" instead of a double one.
[ STRING1 != STRING2 ]	STRING1 is not equal to STRING2.	if [ "$userinput" != "$password" ]; then
    echo "Access denied! Wrong password!"
    exit 1 # Stops script execution right here
fi
[ STRING1 \> STRING2 ]	STRING1 sorts after STRING2 in the current locale (lexographically).	The backslash before the angle bracket is there because the bracket needs to be escaped to be interpreted correctly. As an example we have a basic bubble sort:
(Don't feel ashamed if you don't understand this, it is a more complex example)
 
array=( linux tutorial blog )
swaps=1
while (( swaps > 0 )); do
   
swaps=0
    for (( i=0; i < (( ${#array[@]} - 1 )) ; i++ )); do
        if [ "${array[$i]}" \> "${array[$(( i + 1 ))]}" ]; then # Here is the sorting condition
            tempstring=${array[$i]}
            array[$i]=${array[$(( i + 1 ))]}
            array[$(( i + 1 ))]=$tempstring
            (( swaps=swaps + 1 ))
        fi
    done
done
echo ${array[@]} # Returns "blog linux tutorial"
[ STRING1 \< STRING2 ]	STRING1 sorts before STRING2 in the current locale (lexographically).
[ -n NONEMPTYSTRING ]	NONEMPTYSTRING has a length of more than zero.	This condition only accepts valid strings, so be sure to quote anything you give to it.
if [ -n "$userinput" ]; then
    userinput=parse($userinput) # Only parse if the user actually gave some input.
fi
Note that you can also omit the "-n", as brackets with just a string in it behave the same.
[ -z EMPTYSTRING ]	EMPTYSTRING is an empty string.	This condition also accepts non-string input, like an uninitialized variable:
if [ -z $uninitializedvar ]; then
    uninitializedvar="initialized" # -z returns true on an uninitialized variable, so we initialize it here.
fi
Double-bracket syntax only:
[[ STRING1 =~ REGEXPATTERN ]]	STRING1 matches REGEXPATTERN.	If you are familiar with Regular Expressions, you can use this conditions to perform a regex match.
if [[ "$email" =~ "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}\b" ]]; then
    echo "\$email contains a valid e-mail address."
fi

			15.2.5.3 Arithmetic (number-based) conditions:
Condition	True if	Example/explanation
[ NUM1 -eq NUM2 ]	NUM1 is EQual to NUM2.	These conditions only accept integer numbers. Strings will be converted to integer numbers, if possible. Some random examples:
if [ $? -eq 0 ]; then # $? returns the exit status of the previous command
    echo "Previous command ran succesfully."
fi
if [ $(ps -p $pid -o ni=) -ne $(nice) ]; then
    echo "Process $pid is running with a non-default nice value"
fi
if [ $num -lt 0 ]; then
    echo "Negative numbers not allowed; exiting..."
    exit 1
fi
[ NUM1 -ne NUM2 ]	NUM1 is Not Equal to NUM2.
[ NUM1 -gt NUM2 ]	NUM1 is Greater Than NUM2.
[ NUM1 -ge NUM2 ]	NUM1 is Greater than or Equal to NUM2.
[ NUM1 -lt NUM2 ]	NUM1 is Less Than NUM2.
[ NUM1 -le NUM2 ]	NUM1 is Less than or Equal to NUM2.

			15.2.5.4 Miscellaneous conditions:
Condition	True if	Example/explanation
[ -o shelloption ]	shell option 'shelloption' is enabled.	Shell options modify the behaviour of bash, except a few unmodifiable ones that indicate the shell status.
if [ ! -o checkwinsize ] # An exclamation mark inverts the outcome of the condition following it
    echo "Shell option checkwinsize is disabled; enabling it so you can resize you terminal window without problems."
    shopt -s checkwinsize # This shell option is modifiable
fi
if [ -o login_shell ]; then
    echo "This a a login shell." # This shell option is not modifiable

fi
With the double-parenthesis syntax, you can use the following conditions:

			15.2.5.5 Double-parenthesis syntax conditions:
Condition	True if	Example/explanation
(( NUM1 == NUM2 ))	NUM1 is equal to NUM2.	These conditions only accept integer numbers. Strings will be converted to integer numbers, if possible. Some random examples:
if (( $? == 0 )); then # $? returns the exit status of the previous command
    echo "Previous command ran succesfully."
fi
if (( $(ps -p $pid -o ni=) != $(nice) )); then
    echo "Process $pid is running with a non-default nice value"
fi
if (( $num < 0 )); then
    echo "Negative numbers not allowed; exiting..."
    exit 1
fi
(( NUM1 != NUM2 ))	NUM1 is not equal to NUM2.
(( NUM1 > NUM2 ))	NUM1 is greater than NUM2.
(( NUM1 >= NUM2 ))	NUM1 is greater than or equal to NUM2.
(( NUM1 < NUM2 ))	NUM1 is less than NUM2.
(( NUM1 <= NUM2 ))	NUM1 is less than or equal to NUM2.
After this dry information load, here's a bit of explanation for those who want to know more...

		15.2.6 Diving a little deeper
I said I'd tell more about the fact that if essentially checks the exit status of commands. And so I will. The basic rule of bash when it comes to conditions is 0 equals true, >0 equals false.
That's pretty much the opposite of many programming languages where 0 equals false and 1 (or more) equals true. The reason behind this is that shells like bash deal with programs a lot. By UNIX convention, programs use an exit status for indicating whether execution went alright or an error occured. As a succesful execution doesn't require any explanation, it needs only one exit status. If there was a problem, however, it is useful to know what went wrong. Therefore, 0 is used for a succesful execution, and 1-255 to indicate what kind of error occured. The meaning of the numbers 1-255 differs depending on the program returning them.

Anyway, if executes the block after then when the command returns 0. Yes, conditions are commands. The phrase [ $foo -ge 3 ] returns an exit status, and the other two syntaxes as well! Therefore, there's a neat trick you can use to quickly test a condition:

[ $foo -ge 3 ] && echo true

In this example, "echo true" is only executed if "[ $foo -ge 3 ]" returns 0 (true). Why is that, you might ask. It's because bash only evaluates a condition when needed. When using the and combining expression, both conditions need to be true to make the combining expression return true. If the first condition returns false, it doesn't matter what the second one returns; the result will be false. Therefore, bash doesn't evaluate the second condition, and that's the reason why "echo true" is not executed in the example. This is the same for the or operator ("||"), where the second condition is not evaluated if the first one is true.

Well, so much for the diving. If you want to know even more, I'd like to point you to the Advanced Bash-Scripting Guide and maybe the Bash Reference Manual.

		15.2.7 Conclusion
In this tutorial, you've been able to make a start at understanding the many possibilities of conditions in bash scripting. You've been able to read about the basic rules of writing and using conditions, about the three syntaxes and their properties, and maybe you took the opportunity to dive a little deeper. I hope you enjoyed the reading as much as I enjoyed the writing. You can always return here to look up conditions in the table (bookmark that link to see the table directly), or to refresh your knowledge. If you have any suggestions, additions or other feedback, feel free to comment. Thanks for reading and happy scripting!

"
	15.3 The case statement
The case statement is good alternative to multilevel if-then-else-fi statement. It enable you to match several values against one variable. It is easier to read and write.
Contents [hide]
1 Syntax
1.1 Example
1.2 Using Multiple Patterns
1.3 Creating a backup script
Syntax

The syntax is as follows:
          case  $variable-name  in
                pattern1)       
     		    command1
                    ...
                    ....
                    commandN
                    ;;
                pattern2)
     		    command1
                    ...
                    ....
                    commandN
                    ;;            
                patternN)       
     		    command1
                    ...
                    ....
                    commandN
                    ;;
                *)              
          esac 
OR
          case  $variable-name  in
                pattern1|pattern2|pattern3)       
     		    command1
                    ...
                    ....
                    commandN
                    ;;
                pattern4|pattern5|pattern6)
     		    command1
                    ...
                    ....
                    commandN
                    ;;            
                pattern7|pattern8|patternN)       
     		    command1
                    ...
                    ....
                    commandN
                    ;;
                *)              
          esac 
The case statement allows you to easily check pattern (conditions) and then process a command-line if that condition evaluates to true.
In other words the $variable-name is compared against the patterns until a match is found.
*) acts as default and it is executed if no match is found.
The pattern can include wildcards.
You must include ;; at the end of each commandN. The shell executes all the statements up to the two semicolons that are next to each other.
The esac is always required to indicate end of case statement.
Example
Create a shell script called rental.sh:
#!/bin/bash
 
# if no command line arg given
# set rental to Unknown
if [ -z $1 ]
then
  rental="*** Unknown vehicle ***"
elif [ -n $1 ]
then
# otherwise make first arg as a rental
  rental=$1
fi
 
# use case statement to make decision for rental
case $rental in
   "car") echo "For $rental rental is Rs.20 per k/m.";;
   "van") echo "For $rental rental is Rs.10 per k/m.";;
   "jeep") echo "For $rental rental is Rs.5 per k/m.";;
   "bicycle") echo "For $rental rental 20 paisa per k/m.";;
   "enfield") echo "For $rental rental Rs.3  per k/m.";;
   "thunderbird") echo "For $rental rental Rs.5 per k/m.";;
   *) echo "Sorry, I can not get a $rental rental  for you!";;
esac
Save and close the file. Run it as follows:
chmod +x rental.sh
./rental.sh 
./rental.sh jeep
./rental.sh enfield
./rental.sh bike
Sample outputs:
Sorry, I can not get a *** Unknown vehicle *** rental  for you!
For jeep rental is Rs.5 per k/m.
For enfield rental Rs.3  per k/m.
Sorry, I can not get a bike rental  for you!
The case statement first checks $rental against each option for a match. If it matches "car", the echo command will display rental for car. If it matches "van", the echo command will display rental for van and so on. If it matches nothing i.e. * (default option), an appropriate warning message is printed.
Using Multiple Patterns
#!/bin/bash
NOW=$(date +"%a")
case $NOW in
	Mon)	
		echo "Full backup";;
	Tue|Wed|Thu|Fri)
		echo "Partial backup";;
	Sat|Sun)	
		echo "No backup";;
	*) ;;
esac
The following shell script demonstrate the concept of command line parameters processing using the case statement (casecmdargs.sh):
#!/bin/bash
OPT=$1   # option
FILE=$2  # filename
 
# test -e and -E command line args matching
case $OPT in
  -e|-E) 
  	echo "Editing $2 file..." 
        # make sure filename is passed else an error displayed   
  	[ -z $FILE ] && { echo "File name missing"; exit 1; } || vi $FILE	
  	;;
  -c|-C) 
  	echo "Displaying $2 file..." 
  	[ -z $FILE ] && { echo "File name missing"; exit 1; } || cat $FILE	
  	;;
  -d|-D) 
  	echo "Today is $(date)" 
  	;;
   *) 
    echo "Bad argument!" 
    echo "Usage: $0 -ecd filename"
    echo "	-e file : Edit file."
    echo "	-c file : Display file."
    echo "	-d      : Display current date and time."	
    ;;
esac
Run it as follows:
chmod +x casecmdargs.sh
./casecmdargs.sh
./casecmdargs.sh -e /tmp/file
./casecmdargs.sh -E /tmp/file
./casecmdargs.sh -e 
./casecmdargs.sh -D
Creating a backup script
Create a backup script called allinonebackup.sh:
#!/bin/bash
# A shell script to backup mysql, webserver and files to tape
opt=$1
case $opt in
        sql)
                echo "Running mysql backup using mysqldump tool..."
                ;;
        sync)
                echo "Running backup using rsync tool..."
                ;;
        tar)
                echo "Running tape backup using tar tool..."
                ;;
        *)
        	    echo "Backup shell script utility"
                echo "Usage: $0 {sql|sync|tar}"
                echo "	sql  : Run mySQL backup utility."
                echo "	sync : Run web server backup utility."	
                echo "	tar  : Run tape backup utility."	;;
esac
Save and close the file. Run it as follows:
chmod +x allinonebackup.sh
# run sql backup
./allinonebackup.sh sql
# Dump file system using tape device
./allinonebackup.sh tar
# however, the following will fail as patterns are case sensitive
# you must use command line argument tar and not TAR, Tar, TaR etc. 
./allinonebackup.sh TAR

	15.4


16. FAQ

	16.1  How to trim whitespace from bash variable?

		16.1.1  I needed to trim whitespace from a script when the IFS variable was set to something else. Relying on perl did the trick:

# trim() { echo $1; } # doesn't seem to work, as it's affected by IFS

trim() { echo "$1" | perl -p -e 's/^\s+|\s+$//g'; }

strings="after --> , <-- before,  <-- both -->  "

OLD_IFS=$IFS
IFS=","
for str in ${strings}; do
  str=$(trim "${str}")
  echo "str= '${str}'"
done
IFS=$OLD_IFS


		16.1.2 assignments ignore leading and trailing whitespace and as such can be used to trim

$ var=`echo '   hello'`; echo $var
hello

		16.1.3 You can use old-school tr. For example, this returns the number of modified files in a git repository, whitespaces stripped.

MYVAR=`git ls-files -m|wc -l|tr -d ' '`


		16.1.4 This will remove all spaces ...

echo " test test test " | tr -d ' '
so this results in

testtesttest
This will remove trailing spaces...

echo " test test test " | sed 's/ *$//g'
which results in

 test test test
This will remove leading spaces...

echo " test test test " | sed 's/^ *//g'
which results in

test test test

		16.1.5 # "Remove leading & trailing whitespace from a Bash variable",
# http://codesnippets.joyent.com/posts/show/1816

var="    abc    "
var="${var#"${var%%[![:space:]]*}"}"   # remove leading whitespace characters
var="${var%"${var##*[![:space:]]}"}"   # remove trailing whitespace characters
echo "$var"

		16.1.6 how to read a file line by line
http://en.kioskea.net/faq/1757-how-to-read-a-file-line-by-line
This article introduces the concept of playing a file line by line in Linux with the help of examples and tips along with a guided tour of initiating a loop. The article discusses the errors committed while reading a file line by line on the Linux platform. With samples and illustrations, it shows how the 'for loop' and 'while loop' differ in their respective outputs. It also provides tips on how to use the while loop and depicts its syntax. It concludes with the process behind initiating a loop along with the side effects the while loops can exhibit.

One of the most common errors when using scripts bash on GNU / Linux is to read a file line by line by using a for loop (for line in $ (cat file.txt) do. ..), which in this example leads to an assessment for each line and not every word of the file.
It is possible to change the value of the variable $ IFS (Internal Field Separator, internal field separator) with a for loop before starting the loop.

Sample output with a for loop:
for line in $ (cat file.txt) do echo "$ line" done

This           
is                
row           
No           
1           
This           
is                 
row           
No           
2           
This           
[...]           


The solution is to use a while loop coupled with the internal read.

It is possible to get the result with a for loop provided to change the value of the variable $ IFS (Internal Field Separator, internal field separator) before starting the loop.

While loop

The while loop remains the most appropriate and easiest way to read a file line by line.
Syntax

while read line           
do           
    command           
done <file 


Example
The starting file:

This is line 1     

    This is line 2
    This is line 3
    This is line 4
    This is line 5 



The instructions in the command line:

while read line; do echo -e "$line\n"; done < file.txt



or in a "bash" script:

#! / bin / bash           

while read line           
do           
    echo-e "$ line \ n"           
done <file.txt           

The output on the screen (stdout):           
This is line 1        

This is line 2        

This is line 3           

This is line 4           

This is line 5   


Tips
It is entirely possible from a structured file (like an address book or /etc/passwd, for example), to retrieve the values of each field and assign them to several variables with the command 'read'. Be careful to properly assign the IFS variable with good field separators (space by default).

Example:

#! /bin/bash          

while IFS=: read user pass uid gid full home shell          
do          
echo -e "$full :\n\          
 Pseudo : $user\n\          
 UID :\t $uid\n\          
 GID :\t $gid\n\          
 Home :\t $home\n\          
 Shell :\t $shell\n\n"          
done < /etc/passwd


Bonus

while read i; do echo -e "Parameter : $i"; done < <(echo -e "a\nab\nc")


Initiate a Loop
Although the while loop is the easiest method, it has its side effects. It obliterates the formatting of lines including spaces and tabs.

    Moreover, the for loop coupled with a change of IFS helps keep the structure of the document output. 



Syntax

old_IFS=$IFS      # save the field separator           
IFS=$'\n'     # new field separator, the end of line           
for line in $(cat fichier)          
do          
   command          
done          
IFS=$old_IFS     # restore default field separator 

		16.1.7
	16.2 Match comment lines in file, regexp match example
snippet:
if [[ "#aaa" =~ ^#[:alnum:]+ ]] ; then echo xxx; else echo yyy; fi
xxx
$ if [[ "#aaa" =~ ^[:alnum:]+ ]] ; then echo xxx; else echo yyy; fi
yyy

file read loop:

	16.3 Edit file from bash script

		16.3.1 perl
File manipulation isn't normally done by Bash, but by programs invoked by Bash, e.g.:

> perl -pi -e 's/abc/XYZ/g' /tmp/file.txt
The -i flag tells it do do in-place replacement.

See man perlrun for more details, including how to take a backup file of the original.

		16.3.2 Sed

The easiest way is to use sed (or perl):

sed -ie 's/abc/XYZ/g' /tmp/file.txt

Which will invoke sed to do an inplace edit. This can be called from bash.

If you really really want to use just bash, then the following can work:

		16.3.3 pure bash
while read a ; do echo ${a//abc/XYZ} ; done < /tmp/file.txt > /tmp/file.txt.t ; mv /tmp/file.txt{.t,}

This loops over each line, doing a substitution, and writing to a temporary file (don't want to clobber the input). The move at the end just moves temporary to the original name.

		16.3.4 ex
Bash, like other shells, is just a tool for coordinating other commands. Typically you would try to use standard UNIX commands, but you can of course use Bash to invoke anything, including your own compiled programs, other shell scripts, Python and Perl scripts etc.

In this case, there are a couple of ways to do it.

If you want to read a file, and write it to another file, doing search/replace as you go, use sed:

sed 's/abc/XYZ/g' <infile >outfile
If you want to edit the file in place (as if opening the file in an editor, editing it, then saving it) supply instructions to the line editor 'ex'

echo "%s/abc/XYZ/g
w
q
" | ex file
Ex is like vi without the fullscreen mode. You can give it the same commands you would at vi's ':' prompt.

		16.3.5 ed
		# delete all lines matching foobar 
ed -s test.txt <<< $'g/foobar/d\nw'


		16.3.6
	16.4 Quoting


		16.4.1 execute commands bash script quoting problem

Ex:

                         echo "sed directive: sed -ie 's/$ftype[ \t]$perc[ \t]$size/$ftype $perc $Q_SIZE/' ${DISK_QUOTAS_CFG_FILE}"
                         sed -ie 's/$ftype[ \t]$perc[ \t]$size/$ftype $perc $Q_SIZE/' ${DISK_QUOTAS_CFG_FILE}

Echo will look fine but command won't work due to shell giving semantic interpretation to some keywords chars.
use eval to assemble the command correctly:

                         eval "sed -ie 's/$ftype[ \t]$perc[ \t]$size/$ftype $perc $Q_SIZE/' ${DISK_QUOTAS_CFG_FILE}"

		16.4.2

	16.5 How to define hash tables in bash?
--> Bash 4 natively supports this feature. You declare an associative array by doing:

declare -A animals
You can fill it up with elements using the normal array assignment operator:

animals=( ["moo"]="cow" )
Or merge them:

declare -A animals=( ["moo"]="cow" )
Then use them just like normal arrays:

echo "${animals["moo"]}"
for sound in "${!animals[@]}"; do echo "$sound - ${animals["$sound"]}"; done
In bash 3, you don't have associative arrays. Do not use eval to emulate them. You must avoid eval like the plague, because it is the plague of shell scripting.

First and foremost: Consider upgrading to bash 4. Seriously. The future is now, stop living in the past and suffering from it by forcing stupid broken and ugly hacks on your code.

If you have some silly excuse why you "can't upgrade", declare is a far safer option. It does not evaluate data as bash code like eval does, and as such it does not allow arbitrary code injection quite so easily.

Let's prepare the answer by introducing the concepts:

First, indirection (seriously; never use this unless you're mentally ill or have some other bad excuse for writing hacks).

$ animals_moo=cow; sound=moo; i="animals_$sound"; echo "${!i}"
cow
Secondly, declare:

$ sound=moo; animal=cow; declare "animals_$sound=$animal"; echo "$animals_moo"
cow
Bring them together:

# Set a value:
declare "array_$index=$value"

# Get a value:
arrayGet() { 
    local array=$1 index=$2
    local i="${array}_$index"
    printf '%s' "${!i}"
}
Let's use it:

$ sound=moo
$ animal=cow
$ declare "animals_$sound=$animal"
$ arrayGet animals "$sound"
cow
Note: declare cannot be put in a function. Any use of declare inside a bash function turns the variable it creates local to the scope of that function, meaning we can't access or modify global arrays with it.

Once more. Upgrade to bash 4. If you can't, consider awk before doing ugly hacks as described above. And definitely stay the heck away from eval hackery.

--> #!/bin/bash

# Array pretending to be a Pythonic dictionary
ARRAY=( "cow:moo"
        "dinosaur:roar"
        "bird:chirp"
        "bash:rock" )

for animal in ${ARRAY[@]} ; do
    KEY=${animal%%:*}
    VALUE=${animal##*:}
    printf "%s likes to %s.\n" $KEY $VALUE
done

echo -e "${ARRAY[1]%%:*} is an extinct animal which likes to ${ARRAY[1]##*:}\n"
The BASH 4 way is better of course, but if you need a hack ...only a hack will do. You could search the array/hash with similar techniques.

--> use awk

--> Use this trick in bash < 4
hput () {
  eval hash"$1"='$2'
}

hget () {
  eval echo '${hash'"$1"'#hash}'
}
hput France Paris
hput Netherlands Amsterdam
hput Spain Madrid
echo `hget France` and `hget Netherlands` and `hget Spain`
$ sh hash.sh
Paris and Amsterdam and Madrid

This uses the shells environment variable hash table :)

--> 

	16.6 Tokenizing a string, split a string


		16.6.1 Bash: How to tokenize a string variable? 

-> Use the shell's automatic tokenization of unquoted variables:

$ string="john is 17 years old"
$ for word in $string; do echo "$word"; done
john
is
17
years
old
If you want to change the delimiter you can set the $IFS variable, which stands for internal field separator. The default value of $IFS is " \t\n" (space, tab, newline).

$ string="john_is_17_years_old"
$ (IFS='_'; for word in $string; do echo "$word"; done)
john
is
17
years
old
(Note that in this second example I added parentheses around the second line. This creates a sub-shell so that the change to $IFS doesn't persist. You generally don't want to permanently change $IFS as it can wreak havoc on unsuspecting shell commands.)

-> $ string="john is 17 years old"
$ tokens=( $string )
$ echo ${tokens[*]} 

-> you can try something like this :

#!/bin/bash
n=0
a=/home/file.txt
for i in `cat ${a} | tr ' ' '\n'` ; do
   str=${str},${i}
   let n=$n+1
   var=`echo "var${n}"`
   echo $var is ... ${i}
done

-> $ string="john is 17 years old"
$ set -- $string
$ echo $1
john
$ echo $2
is
$ echo $3
17

-> 
		16.6.2 Split a string on newlines (bash)

-> old=$IFS
IFS='
'
array=`cat Submissions`
for ...
    ...
done
IFS=$old

-> Do your really need to store it in an array?
If not, you can do it faster and saving some memory:
Code:
#!/bin/bash

while read subid ; do
   x=`db2 "select count(*) from table where uniquekey='$subid'"
   if [ "x" == "0" ]; then
        echo "No submissions here!"
   elif [ "x" == SQL* ]; then
        echo "Fix your SQL, silly."
   fi
done <Submissions

the read command stores input in a variable until the enter or return key is pressed
so here the read command store input from file Submissions (<Submissions) and
stop to store in subid variable each time it reads a end of line (as a return or enter key)

Basically the code posted by hko should use less memory as it doesn't store all the 
Submission lines before work with it, instead it stores line per line in memory

Note, this uses less memory and works on one line at a time
It seems risky to use on a file that is R/W at the same time.

-> My example:
echo "$IFS" | cat -vte
 ^I$
$
[root@acs-e4t01 bin]# !572
OIFS=$IFS; IFS='
';
[root@acs-e4t01 bin]# !535
echo "$IFS" | cat -vte
$
$
[root@acs-e4t01 bin]# !574; !575
Note, the difference between quoting ("") and not. Shell will tokenize according to IFS when not quoting!

for l in "${D_ARR[@]}"; do echo ">>> $l"; done; for l in ${D_ARR[@]}; do echo ">>> $l"; done
>>> #File type, The limit ( of disk size) or Fix, The actual limit
ade-log Fix 50
monit-log       Fix 55
mgmt-audit-log 0.015 2
mgmt-log 0.281 39
apache-log      Fix 55
rt-log 0.281 39
rt-config-cache Fix 1000
rt-core Fix 2000
local-store 26.74 3723
acs-db  Fix 3000
acs-db-log      Fix 100
acs-db-err-log  Fix 100
view-log        Fix 155
view-db 42.23 5880
view-db-log     Fix 100
view-db-log     Fix 100
centrify-system Fix 50
ad-agent-log    Fix 55
backup 29.562 4116
backup-log      Fix 50
backup-log      Fix 50
backup-success-log      Fix 50
backup-success-log      Fix 50
patch   Fix 1000
upgrade-log     Fix 55
>>> #File type, The limit ( of disk size) or Fix, The actual limit
>>> ade-log     Fix 50
>>> monit-log   Fix 55
>>> mgmt-audit-log 0.015 2
>>> mgmt-log 0.281 39
>>> apache-log  Fix 55
>>> rt-log 0.281 39
>>> rt-config-cache     Fix 1000
>>> rt-core     Fix 2000
>>> local-store 26.74 3723
>>> acs-db      Fix 3000
>>> acs-db-log  Fix 100
>>> acs-db-err-log      Fix 100
>>> view-log    Fix 155
>>> view-db 42.23 5880
>>> view-db-log Fix 100
>>> view-db-log Fix 100
>>> centrify-system     Fix 50
>>> ad-agent-log        Fix 55
>>> backup 29.562 4116
>>> backup-log  Fix 50
>>> backup-log  Fix 50
>>> backup-success-log  Fix 50
>>> backup-success-log  Fix 50
>>> patch       Fix 1000
>>> upgrade-log Fix 55

[root@acs-e4t01 bin]# !576
IFS=$OIFS
[root@acs-e4t01 bin]# echo "$IFS" | cat -vte
 ^I$
$

		16.6.3

	16.7 How do I prompt a user for confirmation in bash script?
yes no prompt bash


read -p "Are you sure? " -n 1 -r
if [[ $REPLY =~ ^[Yy]$ ]]
then
    # do dangerous stuff
fi

or
use case/esac.

read -p "Continue (y/n)?" choice
case "$choice" in 
  y|Y ) echo "yes";;
  n|N ) echo "no";;
  * ) echo "invalid";;
esac
advantage:

1) neater,
2) can use "OR" condition easier
3) can use character range, eg [yY][Es][Ss]

	16.8 redirect stderr to stdout

# service --status-all 2>&1 | grep named

	16.9 Extract directory path from file name 
        In Bash, if VAR="/home/me/mydir/file.c", how do I get "/home/me/mydir"?
dirname and basename are the tools you're looking for for extracting path components:
$ VAR=/home/me/mydir/file.c
$ DIR=$(dirname "${VAR}")
$ echo "${DIR}"
/home/me/mydir
$ basename "${VAR}"
file.c
They're not internal Bash commands but they're part of the POSIX standard (see dirname, basename) and so should be available on the vast majority of systems that will be running Bash.


$ export VAR=/home/me/mydir/file.c
$ export DIR=${VAR%/*}
$ echo "${DIR}"
/home/me/mydir
$ echo "${VAR##*/}"
file.c


On a related note, if you only have the filename or relative path, dirname on its own won't help. For me, the answer ended up being readlink.
fname='txtfile'
echo $(dirname "$fname") # output: .
echo $(readlink -f "$fname") # output: /home/me/work/txtfile
You can then combine the two to get just the directory.
echo $(dirname $(readlink -f "$fname")) # output: /home/me/work

	16.10
17. Pro Bash Programming: Scripting the GNU/Linux Shell

By: Chris F.A. Johnson

Publisher: Apress

Pub. Date: October 18, 2009

Print ISBN-13: 978-1-4302-1997-2

Web ISBN-10: 1-4302-1997-1
Chapter 1. Hello, World! Your First Shell Program

Section 1.1. The Code

Section 1.2. The File

Section 1.3. Choosing and Using a Text Editor

Section 1.4. Building a Better "Hello, World!"

Section 1.5. Summary

Section 1.6. Exercises
Download ChapterDownload Chapter
1 TokenChapter 2. Input, Output, and Throughput

Section 2.1. Parameter and Variables

Section 2.2. Arguments and Options

Section 2.3. echo, and Why You Should Avoid It

Section 2.4. printf: Formatting and Printing Data

Section 2.5. Line Continuation

Section 2.6. Standard Input/Output Streams and Redirection

Section 2.7. Reading Input

Section 2.8. Pipelines

Section 2.9. Command Substitution

Section 2.10. Summary

Section 2.11. Exercises
Download ChapterDownload Chapter
1 TokenChapter 3. Looping and Branching

Section 3.1. Exit Status

Section 3.2. Testing an Expression

Section 3.3. Lists

Section 3.4. Conditional execution

Section 3.5. Looping

Section 3.6. Summary

Section 3.7. Exercises
Download ChapterDownload Chapter
1 TokenChapter 4. Command-Line Parsing and Expansion

Section 4.1. Quoting

Section 4.2. Brace Expansion

Section 4.3. Tilde Expansion

Section 4.4. Parameter and Variable Expansion

Section 4.5. Arithmetic Expansion

Section 4.6. Command Substitution

Section 4.7. Word Splitting

Section 4.8. Pathname Expansion

Section 4.9. Process Substitution

Section 4.10. Parsing Options

Section 4.11. Summary

Section 4.12. Exercises
Download ChapterDownload Chapter
1 TokenChapter 5. Parameters and Variables

Section 5.1. The Scope of a Variable: Can You See It from Here?

Section 5.2. Shell Variables

Section 5.3. The Naming of Variables

Section 5.4. Parameter Expansion

Section 5.5. Positional Parameters

Section 5.6. Arrays

Section 5.7. Summary

Section 5.8. Exercises
Download ChapterDownload Chapter
1 TokenChapter 6. Shell Functions

Section 6.1. Definition Syntax

Section 6.2. Compound Commands

Section 6.3. Getting Results

Section 6.4. Function Libraries

Section 6.5. Sample Script

Section 6.6. Summary

Section 6.7. Exercises
Download ChapterDownload Chapter
1 TokenChapter 7. String Manipulation

Section 7.1. Concatenation

Section 7.2. Processing Character by Character

Section 7.3. Case Conversion

Section 7.4. Comparing Contents Without Regard to Case

Section 7.5. Check for Valid Variable Name

Section 7.6. Insert One String into Another

Section 7.7. Overlay

Section 7.8. Trim Unwanted Characters

Section 7.9. Index

Section 7.10. Summary

Section 7.11. Exercises
	17.8. File Operations and Commands

Because the shell is an interpreted language, it is comparatively slow. Many operations on files are best done with external commands that implicitly loop over the lines of a file. At other times, the shell itself is more efficient. This chapter looks at how the shell works with filesboth shell options that modify and extend file name expansion and shell options that read and modify the contents of files. Several external commands that work on files are explained, often accompanied by examples of when not to use them.

Some of the scripts in this chapter use an especially prepared file containing the King James version of the Bible. The file can be downloaded from http://cfaj.freeshell.org/kjv/kjv.txt. Download it to your home directory with wget:

wget http://cfaj.freeshell.org/kjv/kjv.txt


In this file, each verse of the bible is on a single line preceded by the name of the book and the chapter and verse numbers, all delimited with colons:

Genesis:001:001:In the beginning God created the heaven and the earth.
Exodus:020:013:Thou shalt not kill.
Exodus:022:018:Thou shalt not suffer a witch to live.
John:011:035:Jesus wept.


The path to the file will be kept in the variable kjv, which will be used whenever the file is needed.

export kjv=$HOME/kjv.txt

		17.8.1 Section 8.1. Reading a File
The most basic method of reading the contents of a file is a while loop with its input redirected:

while read ## no name supplied so the variable REPLY is used
do
  : do something with "$REPLY" here
done < "$kjv"


The file will be stored, one line at a time, in the variable REPLY. More commonly, one or more variable names will be supplied as arguments to read:

while read name phone
do
  printf "Name: %10s\tPhone: %s\n" "$name" "$phone"
done < "$file"


The lines are split using the characters in IFS as word delimiters. If the file contained in $file contains these two lines:

John 555-1234
Jane 555-7531


the output of the previous snippet will be as follows:

Name: John     Phone: 555-1234
Name: Jane     Phone: 555-7531


By changing the value of IFS before the read command, other characters can be used for word splitting. The same script, using only a hyphen in IFS instead of the default space, tab, and newline, would produce this:

$ while IFS=- read name phone
> do
> printf "Name: %10s\tPhone: %s\n" "$name" "$phone"
> done < "$file"
Name: John 555 Phone: 1234
Name: Jane 555 Phone: 7531


Placing an assignment in front of a command causes it to be local to that command and does not change its value elsewhere in the script.

To read the King James version of the Bible (henceforth referred to as KJV), the field separator IFS should be set to a colon so that lines can be split into book, chapter, verse, and text, each being assigned to a separate variable (Listing 8-1).
Listing 8.1. kjvfirsts, Print Book, Chapter, Verse, and First Words from KJV

while IFS=: read book chapter verse text
do
  firstword=${text%% *}
  printf "%s %s:%s %s\n" "$book" "$chapter" "$verse" "$firstword"
done < "$kjv"


The output (with more than 31,000 lines replaced by a single ellipsis) looks like this:

Genesis 001:001 In
Genesis 001:002 And
Genesis 001:003 And
...
Revelation 022:019 And
Revelation 022:020 He
Revelation 022:021 The


On my computer, a 1.6GHz Pentium 4 with many applications running, this script takes more than half a minute to run. The same task written in awk takes about a quarter of the time. See the section on awk later in this chapter for the script.

The awk programming language is often used in shell scripts when the shell itself is too slow (as in this case) or when features not present in the shell are required (for example, arithmetic using decimal fractions). The language is explained in somewhat more detail in the following section.

		17.8.2 Section 8.2. External Commands

		17.8.3 Section 8.3. Regular Expressions

		17.8.4 Section 8.4. File Name Expansion Options

		17.8.5 Section 8.5. Summary

		17.8.6 Section 8.6. Exercises


1 TokenChapter 9. Reserved Words and Builtin Commands

Section 9.1. help, Display Information About Builtin Commands

Section 9.2. time, Print Time Taken for Execution of a Command

Section 9.3. read, Read a Line from an Input Stream

Section 9.4. type, Display Information About Commands

Section 9.5. builtin, Execute a Builtin Command

Section 9.6. command, Execute a Command or Display Information About Commands

Section 9.7. pwd, Print the Current Working Directory

Section 9.8. Deprecated Builtins

Section 9.9. Dynamically Loadable Builtins

Section 9.10. Summary

Section 9.11. Exercises
Download ChapterDownload Chapter
1 TokenChapter 10. Writing Bug-Free Scripts and Debugging the Rest

Section 10.1. Prevention Is Better Than Cure

Section 10.2. Debugging a Script

Section 10.3. Summary

Section 10.4. Exercises
Download ChapterDownload Chapter
1 TokenChapter 11. Programming for the Command Line

Section 11.1. Manipulating the Directory Stack

Section 11.2. Filesystem Functions

Section 11.3. Miscellaneous Functions

Section 11.4. Managing Man Pages

Section 11.5. Games

Section 11.6. Summary

Section 11.7. Exercises
Download ChapterDownload Chapter
1 TokenChapter 12. Runtime Configuration

Section 12.1. Defining Variables

Section 12.2. Command-Line Options and Arguments

Section 12.3. Menus

Section 12.4. Q&A Dialogue

Section 12.5. Configuration Files

Section 12.6. Scripts with Several Names

Section 12.7. Environment Variables

Section 12.8. All Together Now

Section 12.9. Summary

Section 12.10. Exercises
Download ChapterDownload Chapter
1 TokenChapter 13. Data Processing

Section 13.1. Arrays

Section 13.2. Data File Formats

Section 13.3. Summary

Section 13.4. Exercises
Download ChapterDownload Chapter
1 TokenChapter 14. Scripting the Screen

Section 14.1. Teletypewriter vs. Canvas

Section 14.2. Stretching the Canvas

Section 14.3. Priming the Canvas

Section 14.4. Moving the Cursor

Section 14.5. Changing Rendition Modes and Colors

Section 14.6. Placing a Block of Text on the Screen

Section 14.7. Scrolling Text

Section 14.8. Rolling Dice

Section 14.9. Summary

Section 14.10. Exercises
Download ChapterDownload Chapter
1 TokenChapter 15. Entry-Level Programming

Section 15.1. Single-Key Entry

Section 15.2. History in Scripts

Section 15.3. Sanity Checking

Section 15.4. Form Entry

Section 15.5. Reading the Mouse

Section 15.6. Summary

Section 15.7. Exercises
Appendix A. Shell Variables

Section A.1. BASH

Section A.2. BASHPID

Section A.3. BASH_ALIASES

Section A.4. BASH_ARGC

Section A.5. BASH_ARGV

Section A.6. BASH_CMDS

Section A.7. BASH_COMMAND

Section A.8. BASH_EXECUTION_STRING

Section A.9. BASH_LINENO

Section A.10. BASH_REMATCH

Section A.11. BASH_SOURCE

Section A.12. BASH_SUBSHELL

Section A.13. BASH_VERSINFO

Section A.14. BASH_VERSION

Section A.15. COMP_CWORD

Section A.16. COMP_KEY

Section A.17. COMP_LINE

Section A.18. COMP_POINT

Section A.19. COMP_TYPE

Section A.20. COMP_WORDBREAKS

Section A.21. COMP_WORDS

Section A.22. DIRSTACK

Section A.23. EUID

Section A.24. FUNCNAME

Section A.25. GROUPS

Section A.26. HISTCMD

Section A.27. HOSTNAME

Section A.28. HOSTTYPE

Section A.29. LINENO

Section A.30. MACHTYPE

Section A.31. OLDPWD

Section A.32. OPTARG

Section A.33. OPTIND

Section A.34. OSTYPE

Section A.35. PIPESTATUS

Section A.36. PPID

Section A.37. PWD

Section A.38. RANDOM

Section A.39. REPLY

Section A.40. SECONDS

Section A.41. SHELLOPTS

Section A.42. SHLVL

Section A.43. UID

Section A.44. BASH_ENV

Section A.45. CDPATH

Section A.46. COLUMNS

Section A.47. COMPREPLY

Section A.48. EMACS

Section A.49. FCEDIT

Section A.50. FIGNORE

Section A.51. GLOBIGNORE

Section A.52. HISTCONTROL

Section A.53. HISTFILE

Section A.54. HISTFILESIZE

Section A.55. HISTIGNORE

Section A.56. HISTSIZE

Section A.57. HISTTIMEFORMAT

Section A.58. HOME

Section A.59. HOSTFILE

Section A.60. IFS

Section A.61. IGNOREEOF

Section A.62. INPUTRC

Section A.63. LANG

Section A.64. LC_ALL

Section A.65. LC_COLLATE

Section A.66. LC_CTYPE

Section A.67. LC_MESSAGES

Section A.68. LC_NUMERIC

Section A.69. LINES

Section A.70. MAIL

Section A.71. MAILCHECK

Section A.72. MAILPATH

Section A.73. OPTERR

Section A.74. PATH

Section A.75. POSIXLY_CORRECT

Section A.76. PROMPT_COMMAND

Section A.77. PROMPT_DIRTRIM

Section A.78. PS1

Section A.79. PS2

Section A.80. PS3

Section A.81. PS4

Section A.82. SHELL

Section A.83. TIMEFORMAT

Section A.84. TMOUT

Section A.85. TMPDIR

Section A.86. auto_resume

Section A.87. histchars

18.  My examples

	18.1  loop over words in string
[yizaq@yizaq-WS:Thu Sep 20:/cygdrive/c/Program Files (x86)/Emerald Editor Community/Crimson Editor SVN286:]$ export T="jjj kkk l"
[yizaq@yizaq-WS:Mon Sep 24:/cygdrive/c/Program Files (x86)/Emerald Editor Community/Crimson Editor SVN286:]$ echo $T
jjj kkk l
[yizaq@yizaq-WS:Mon Sep 24:/cygdrive/c/Program Files (x86)/Emerald Editor Community/Crimson Editor SVN286:]$ for w in $T; do echo $w; done
jjj
kkk
l

- answers from http://stackoverflow.com/questions/1469849/how-to-split-one-string-into-multiple-strings-in-bash-shell

-- Just use the shells "set" built-in. For example,

set $text

After that, individual words in $text will be in $1, $2, $3, etc. For robustness, one usually does

set -- junk $text
shift

to handle the case where $text is empty or start with a dash. For example:

text="This is          a              test"
set -- junk $text
shift
for word; do
  echo "[$word]"
done

This prints

[This]
[is]
[a]
[test]

-- 
$ echo "This is   a sentence." | tr -s " " "\012"
This
is
a
sentence.

For checking for spaces, use grep:

$ echo "This is   a sentence." | grep " " > /dev/null
$ echo $?
0
$ echo "Thisisasentence." | grep " " > /dev/null     
$ echo $?
1

-- 
For checking spaces just with bash:

[[ "$str" = "${str% *}" ]] && echo "no spaces" || echo "has spaces"

-- 
 0 down vote
	

(A) To split a sentence into its words (space separated) you can simply use the default IFS by using

array=( $string )


Example running the following snippet

#!/bin/bash

sentence="this is the \"sentence\"   'you' want to split"
words=( $sentence )

len="${#words[@]}"
echo "words counted: $len"

printf "%s\n" "${words[@]}" ## print array

will output

words counted: 8
this
is
the
"sentence"
'you'
want
to
split

As you can see you can use single or double quotes too without any problem

Notes:
-- this is basically the same of mob's answer, but in this way you store the array for any further needing. If you only need a single loop, you can use his answer, which is one line shorter :)
-- please refer to this question for alternate methods to split a string based on delimiter.


(B) To check for a character in a string you can also use a regular expression match.
Example to check for the presence of a space character you can use:

regex='\s{1,}'
if [[ "$sentence" =~ $regex ]]
    then
        echo "Space here!";
fi


	18.2

19. Pattern Matching & globes

	19.1 http://mywiki.wooledge.org/BashGuide/Patterns

Patterns

BASH offers three different kinds of pattern matching. Pattern matching serves two roles in the shell: selecting filenames within a directory, or determining whether a string conforms to a desired format.

On the command line you will mostly use globs. These are a fairly straight-forward form of patterns that can easily be used to match a range of files, or to check variables against simple rules.

The second type of pattern matching involves extended globs, which allow more complicated expressions than regular globs.

Since version 3.0, Bash also supports regular expression patterns. These will be useful mainly in scripts to test user input or parse data. (You can't use a regular expression to select filenames; only globs and extended globs can do that.)


Pattern: A pattern is a string with a special format designed to match filenames, or to check, classify or validate data strings.

Glob Patterns

Globs are a very important concept in Bash, if only for their incredible convenience. Properly understanding globs will benefit you in many ways. Globs are basically patterns that can be used to match filenames or other strings.

Globs are composed of normal characters and metacharacters. Metacharacters are characters that have a special meaning. These are the metacharacters that can be used in globs:

*: Matches any string, including the null string.
?: Matches any single character.
[...]: Matches any one of the enclosed characters.
Globs are implicitly anchored at both ends. What this means is that a glob must match a whole string (filename or data string). A glob of a* will not match the string cat, because it only matches the at, not the whole string. A glob of ca*, however, would match cat.

Here's an example of how we can use glob patterns to expand to filenames:


$ ls
a  abc  b  c
$ echo *
a abc b c
$ echo a*
a abc
Bash sees the glob, for example a*. It expands this glob, by looking in the current directory and matching it against all files there. Any filenames that match the glob are gathered up and sorted, and then the list of filenames is used in place of the glob. As a result, the statement echo a* is replaced by the statement echo a abc, which is then executed.

When a glob is used to match filenames, the * and ? characters cannot match a slash (/) character. So, for instance, the glob */bin might match foo/bin but it cannot match /usr/local/bin. When globs match patterns, the / restriction is removed.

Bash performs filename expansions after word splitting has already been done. Therefore, filenames generated by a glob will not be split; they will always be handled correctly. For example:


$ touch "a b.txt"
$ ls
a b.txt
$ rm *
$ ls
Here, * is expanded into the single filename "a b.txt". This filename will be passed as a single argument to rm. Using globs to enumerate files is always a better idea than using `ls` for that purpose. Here's an example with some more complex syntax which we will cover later on, but it will illustrate the reason very well:


$ ls
a b.txt
$ for file in `ls`; do rm "$file"; done
rm: cannot remove `a': No such file or directory
rm: cannot remove `b.txt': No such file or directory
$ for file in *; do rm "$file"; done
$ ls
Here we use the for command to go through the output of the ls command. The ls command prints the string a b.txt. The for command splits that string into words over which it iterates. As a result, for iterates over first a, and then b.txt. Naturally, this is not what we want. The glob, however, expands in the proper form. It results in the string "a b.txt", which for takes as a single argument.

In addition to filename expansion, globs may also be used to check whether data matches a specific format. For example, we might be given a filename, and need to take different actions depending on its extension:


$ filename="somefile.jpg"
$ if [[ $filename = *.jpg ]]; then
> echo "$filename is a jpeg"
> fi
somefile.jpg is a jpeg
The [[ keyword and the case keyword (which we will discuss in more detail later) both offer the opportunity to check a string against a glob -- either regular globs, or extended globs, if the latter have been enabled.


Good Practice: 
You should always use globs instead of ls (or similar) to enumerate files. Globs will always expand safely and minimize the risk for bugs. 
You can sometimes end up with some very weird filenames. Most scripts aren't tested against all the odd cases that they may end up being used with. Don't let your script be one of those!

In The Manual: Pattern Matching

In the FAQ: 
How can I use a logical AND/OR/NOT in a shell pattern (glob)?

Glob: A glob is a string that can match certain strings or filenames.

Extended Globs

Bash also supports a feature called Extended Globs. These globs are more powerful in nature; technically, they are equivalent to regular expressions, although the syntax looks different than most people are used to. This feature is turned off by default, but can be turned on with the shopt command, which is used to toggle shell options:


$ shopt -s extglob
?(list): Matches zero or one occurrence of the given patterns.
*(list): Matches zero or more occurrences of the given patterns.
+(list): Matches one or more occurrences of the given patterns.
@(list): Matches one of the given patterns.
!(list): Matches anything except one of the given patterns.
The list inside the parentheses is a list of globs or extended globs separated by the | character. Here's an example:


$ ls
names.txt  tokyo.jpg  california.bmp
$ echo !(*jpg|*bmp)
names.txt
Our extended glob expands to anything that does not match the *jpg or the *bmp pattern. Only the text file passes for that, so it is expanded.


Regular Expressions

Regular expressions (regex) are similar to Glob Patterns, but they can only be used for pattern matching, not for filename matching. Since 3.0, Bash supports the =~ operator to the [[ keyword. This operator matches the string that comes before it against the regex pattern that follows it. When the string matches the pattern, [[ returns with an exit code of 0 ("true"). If the string does not match the pattern, an exit code of 1 ("false") is returned. In case the pattern's syntax is invalid, [[ will abort the operation and return an exit code of 2.

Bash uses the Extended Regular Expression (ERE) dialect. We will not cover regexes in depth in this guide, but if you are interested in this concept, please read up on RegularExpression, or Extended Regular Expressions.

Regular Expression patterns that use capturing groups (parentheses) will have their captured strings assigned to the BASH_REMATCH variable for later retrieval.

Let's illustrate how regex can be used in Bash:


$ langRegex='(..)_(..)'
$ if [[ $LANG =~ $langRegex ]]
> then
>     echo "Your country code (ISO 3166-1-alpha-2) is ${BASH_REMATCH[2]}."
>     echo "Your language code (ISO 639-1) is ${BASH_REMATCH[1]}."
> else
>     echo "Your locale was not recognised"
> fi
Be aware that regex parsing in Bash has changed between releases 3.1 and 3.2. Before 3.2 it was safe to wrap your regex pattern in quotes but this has changed in 3.2. Since then, regex should always be unquoted. You should protect any special characters by escaping it using a backslash. The best way to always be compatible is to put your regex in a variable and expand that variable in [[ without quotes, as we showed above.


Good Practice: 
Since the way regex is used in 3.2 is also valid in 3.1 we highly recommend you just never quote your regex. Remember to keep special characters properly escaped!
For cross-compatibility (to avoid having to escape parentheses, pipes and so on) use a variable to store your regex, e.g. re='^\*( >| *Applying |.*\.diff|.*\.patch)'; [[ $var =~ $re ]] This is much easier to maintain since you only write ERE syntax and avoid the need for shell-escaping, as well as being compatible with all 3.x BASH versions.
See also Chet Ramey's Bash FAQ, section E14.

In The Manual: Regex(3)

In the FAQ: 
I want to check if [[ $var == foo or $var == bar or $var == more ... without repeating $var n times.

Regular Expression: A regular expression is a more complex pattern that can be used to match specific strings (but unlike globs cannot expand to filenames).

Brace Expansion

Then, there is Brace Expansion. Brace Expansion technically does not fit in the category of patterns, but it is similar. Globs only expand to actual filenames, but brace expansions will expand to any possible permutation of their contents. Here's how they work:


$ echo th{e,a}n
then than
$ echo {/home/*,/root}/.*profile
/home/axxo/.bash_profile /home/lhunath/.profile /root/.bash_profile /root/.profile
$ echo {1..9}
1 2 3 4 5 6 7 8 9
$ echo {0,1}{0..9}
00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19
The brace expansion is replaced by a list of words, just like a glob is. However, these words aren't necessarily filenames, and they are not sorted (than would have come before then if they were).

Brace expansion happens before filename expansion. In the second echo command above, we used a combination of brace expansion and globs. The brace expansion goes first, and we get:


$ echo /home/*/.*profile /root/.*profile
After the brace expansion, the globs are expanded, and we get the filenames as the final result.

Brace expansions can only be used to generate lists of words. They cannot be used for pattern matching

	19.2 BASH_REMATCH examples

		19.2.1 Capture script


When working with regular expressions in a shell script the norm is to use grep or sed or some other external command/program. Since version 3 of bash (released in 2004) there is another option: bash's built-in regular expression comparison operator "=~".

Bash's regular expression comparison operator takes a string on the left and an extended regular expression on the right. It returns 0 (success) if the regular expression matches the string, otherwise it returns 1 (failure).

In addition to doing simple matching, bash regular expressions support sub-patterns surrounded by parenthesis for capturing parts of the match. The matches are assigned to an array variable BASH_REMATCH. The entire match is assigned to BASH_REMATCH[0], the first sub-pattern is assigned to BASH_REMATCH[1], etc..

The following example script takes a regular expression as its first argument and one or more strings to match against. It then cycles through the strings and outputs the results of the match process:

#!/bin.bash

if [[ $# -lt 2 ]]; then
    echo "Usage: $0 PATTERN STRINGS..."
    exit 1
fi
regex=$1
shift
echo "regex: $regex"
echo

while [[ $1 ]]
do
    if [[ $1 =~ $regex ]]; then
        echo "$1 matches"
        i=1
        n=${#BASH_REMATCH[*]}
        while [[ $i -lt $n ]]
        do
            echo "  capture[$i]: ${BASH_REMATCH[$i]}"
            let i++
        done
    else
        echo "$1 does not match"
    fi
    shift
done
Assuming the script is saved in "bashre.sh", the following sample shows its output:

  # sh bashre.sh 'aa(b{2,3}[xyz])cc' aabbxcc aabbcc
  regex: aa(b{2,3}[xyz])cc

  aabbxcc matches
    capture[1]: bbx
  aabbcc does not match

		19.2.2
	19.3
20. mac, tags: macos, mac, osx, bash 

    20.1 upgrade bash version
Source: https://www.shell-tips.com/mac/upgrade-bash/
GNU Bashicon mdi-link-variant is a powerful shell. Unfortunately the Mac OS operating systems doesnt provide the latest version which may prevent you to take advantage of the latest features that came with Bash 4 and 5. Also, running an outdated bash version probably expose you to some major vulnerabilities.

Mac OS comes with Bash version 3 which is quite limiting and lack key features like the bash associative arraysicon mdi-link-variant, improved auto-completion, better Posix conformance, etc

- determine version:
[i500695@WYLQRXL9LQ:2022-04-03 15:33:06:~/git/portal-cf-cdm-store-service:]2001$ bash --version
bash --version
GNU bash, version 3.2.57(1)-release (arm64-apple-darwin21)
Copyright (C) 2007 Free Software Foundation, Inc.
history -a
[i500695@WYLQRXL9LQ:2022-04-03 15:33:13:~/git/portal-cf-cdm-store-service:]2002$ echo version=${BASH_VERSION}  major version ${BASH_VERSINFO} 
echo version=${BASH_VERSION}  major version ${BASH_VERSINFO} 
version=3.2.57(1)-release major version 3

- if not already installed, install brew 
$ /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 
$ brew upgrade 
$ brew install bash 
[i500695@WYLQRXL9LQ:2022-04-03 15:45:59:~:]2004$ exec bash
Loading yosi izaq BASHRC for SAP MAC environment
LOADING i500695 aliases for SAP MAC environment
[i500695@WYLQRXL9LQ:2022-04-03 15:46:25:~:]2001$ echo version=${BASH_VERSION}  major version ${BASH_VERSINFO} 
version=5.1.16(1)-release major version 5
[i500695@WYLQRXL9LQ:2022-04-03 15:46:28:~:]2002$ bash --version
GNU bash, version 5.1.16(1)-release (aarch64-apple-darwin21.1.0)

- note default bash is still 3. 
$ /bin/bash --version
GNU bash, version 3.2.57(1)-release (arm64-apple-darwin21)
Copyright (C) 2007 Free Software Foundation, Inc.

- But brew kindly set bash to brew install
[i500695@WYLQRXL9LQ:2022-04-03 15:48:01:~:]2006$ ls $(brew --prefix)/bin/bash
/opt/homebrew/bin/bash@
[i500695@WYLQRXL9LQ:2022-04-03 15:49:41:~:]2007$  $(brew --prefix)/bin/bash --version
GNU bash, version 5.1.16(1)-release (aarch64-apple-darwin21.1.0)
[i500695@WYLQRXL9LQ:2022-04-03 15:49:50:~:]2008$ which bash
/opt/homebrew/bin/bash

- add brew bash to allowed shels:
$ cat /private/etc/shells 
# List of acceptable shells for chpass(1).
# Ftpd will not allow users to connect who are not using
# one of these shells.

/bin/bash
/bin/csh
/bin/dash
/bin/ksh
/bin/sh
/bin/tcsh
/bin/zsh

[i500695@WYLQRXL9LQ:2022-04-03 15:49:53:~:]2009$ echo $(brew --prefix)/bin/bash | sudo tee -a /private/etc/shells
Password:
/opt/homebrew/bin/bash
[i500695@WYLQRXL9LQ:2022-04-03 15:52:51:~:]2010$ tail -n 1 /private/etc/shells 
/opt/homebrew/bin/bash
$ 

- And set shell for my user. two ways:
  -- [i500695@WYLQRXL9LQ:2022-04-03 15:56:47:~:]2004$ sudo chpass -s $(brew --prefix)/bin/bash 'Yosi Izaq'
Changing shell for i500695. 
or
    -- go to the Menu > System Preferences... > Users & Groups. Unlock the pane, control click on your user to select Advanced Options..., then update the Login shell 
    to$(brew --prefix)/bin/bash , on my mac its /opt/homebrew/bin/bash 


    20.2

21. bash versions features , tags: bash versions features 

    21.1 bash version 1
    21.2 bash version 2
https://tldp.org/LDP/abs/html/bash2.html

        21.2.1  String expansion.
# Introduced with version 2 of Bash.

#  Strings of the form $'xxx'
#+ have the standard escaped characters interpreted. 

echo $'Ringing bell 3 times \a \a \a'
     # May only ring once with certain terminals.
     # Or ...
     # May not ring at all, depending on terminal settings.
echo $'Three form feeds \f \f \f'
echo $'10 newlines \n\n\n\n\n\n\n\n\n\n'
echo $'\102\141\163\150'
     #   B   a   s   h
     # Octal equivalent of characters.

        21.2.2  Indirect variable referencing.
# This has a few of the attributes of references in C++.


a=letter_of_alphabet
letter_of_alphabet=z

echo "a = $a"           # Direct reference.

echo "Now a = ${!a}"    # Indirect reference.
#  The ${!variable} notation is more intuitive than the old
#+ eval var1=\$$var2

echo

t=table_cell_3
table_cell_3=24
echo "t = ${!t}"                      # t = 24
table_cell_3=387
echo "Value of t changed to ${!t}"    # 387
# No 'eval' necessary.

#  This is useful for referencing members of an array or table,
#+ or for simulating a multi-dimensional array.
#  An indexing option (analogous

Simple database application, using indirect variable referencing

#!/bin/bash
# resistor-inventory.sh
# Simple database / table-lookup application.

# ============================================================== #
# Data

B1723_value=470                                   # Ohms
B1723_powerdissip=.25                             # Watts
B1723_colorcode="yellow-violet-brown"             # Color bands
B1723_loc=173                                     # Where they are
B1723_inventory=78                                # How many

B1724_value=1000
B1724_powerdissip=.25
B1724_colorcode="brown-black-red"
B1724_loc=24N
B1724_inventory=243

B1725_value=10000
B1725_powerdissip=.125
B1725_colorcode="brown-black-orange"
B1725_loc=24N
B1725_inventory=89

# ============================================================== #


echo

PS3='Enter catalog number: '

echo

select catalog_number in "B1723" "B1724" "B1725"
do
  Inv=${catalog_number}_inventory
  Val=${catalog_number}_value
  Pdissip=${catalog_number}_powerdissip
  Loc=${catalog_number}_loc
  Ccode=${catalog_number}_colorcode

  echo
  echo "Catalog number $catalog_number:"
  # Now, retrieve value, using indirect referencing.
  echo "There are ${!Inv} of  [${!Val} ohm / ${!Pdissip} watt]\
  resistors in stock."  #        ^             ^
  # As of Bash 4.2, you can replace "ohm" with \u2126 (using echo -e).
  echo "These are located in bin # ${!Loc}."
  echo "Their color code is \"${!Ccode}\"."

  break
done

echo; echo

# Exercises:
# ---------
# 1) Rewrite this script to read its data from an external file.
# 2) Rewrite this script to use arrays,
#+   rather than indirect variable referencing.
#    Which method is more straightforward and intuitive?
#    Which method is easier to code?


# Notes:
# -----
#  Shell scripts are inappropriate for anything except the most simple
#+ database applications, and even then it involves workarounds and kludges.
#  Much better is to use a language with native support for data structures,
#+ such as C++ or Java (or even Perl).

Using arrays and other miscellaneous trickery to deal four random hands from a deck of cards

#!/bin/bash
# cards.sh

# Deals four random hands from a deck of cards.

UNPICKED=0
PICKED=1

DUPE_CARD=99

LOWER_LIMIT=0
UPPER_LIMIT=51
CARDS_IN_SUIT=13
CARDS=52

declare -a Deck
declare -a Suits
declare -a Cards
#  It would have been easier to implement and more intuitive
#+ with a single, 3-dimensional array.
#  Perhaps a future version of Bash will support multidimensional arrays.


initialize_Deck ()
{
i=$LOWER_LIMIT
until [ "$i" -gt $UPPER_LIMIT ]
do
  Deck[i]=$UNPICKED   # Set each card of "Deck" as unpicked.
  let "i += 1"
done
echo
}

initialize_Suits ()
{
Suits[0]=C #Clubs
Suits[1]=D #Diamonds
Suits[2]=H #Hearts
Suits[3]=S #Spades
}

initialize_Cards ()
{
Cards=(2 3 4 5 6 7 8 9 10 J Q K A)
# Alternate method of initializing an array.
}

pick_a_card ()
{
card_number=$RANDOM
let "card_number %= $CARDS" # Restrict range to 0 - 51, i.e., 52 cards.
if [ "${Deck[card_number]}" -eq $UNPICKED ]
then
  Deck[card_number]=$PICKED
  return $card_number
else  
  return $DUPE_CARD
fi
}

parse_card ()
{
number=$1
let "suit_number = number / CARDS_IN_SUIT"
suit=${Suits[suit_number]}
echo -n "$suit-"
let "card_no = number % CARDS_IN_SUIT"
Card=${Cards[card_no]}
printf %-4s $Card
# Print cards in neat columns.
}

seed_random ()  # Seed random number generator.
{               # What happens if you don't do this?
seed=`eval date +%s`
let "seed %= 32766"
RANDOM=$seed
} # Consider other methods of seeding the random number generator.

deal_cards ()
{
echo

cards_picked=0
while [ "$cards_picked" -le $UPPER_LIMIT ]
do
  pick_a_card
  t=$?

  if [ "$t" -ne $DUPE_CARD ]
  then
    parse_card $t

    u=$cards_picked+1
    # Change back to 1-based indexing, temporarily. Why?
    let "u %= $CARDS_IN_SUIT"
    if [ "$u" -eq 0 ]   # Nested if/then condition test.
    then
     echo
     echo
    fi                  # Each hand set apart with a blank line.

    let "cards_picked += 1"
  fi  
done  

echo

return 0
}


# Structured programming:
# Entire program logic modularized in functions.

#===============
seed_random
initialize_Deck
initialize_Suits
initialize_Cards
deal_cards
#===============

exit



# Exercise 1:
# Add comments to thoroughly document this script.

# Exercise 2:
# Add a routine (function) to print out each hand sorted in suits.
# You may add other bells and whistles if you like.

# Exercise 3:
# Simplify and streamline the logic of the script.

        21.2.3 forEach in bash 
[i500695@WYLQRXL9LQ:2022-04-03 16:17:06:~:]2031$ select n in 1 2 3 ; do echo $n; break; done
1) 1
2) 2
3) 3
#? ^C
        21.2.4
    21.3 bash version 3
On July 27, 2004, Chet Ramey released version 3 of Bash. This update fixed quite a number of bugs and added new features.

Some of the more important added features:

        21.3.1 A new, more generalized {a..z} brace expansion operator.

            21.3.1.1 my examples


[i500695@WYLQRXL9LQ:2022-04-03 16:52:36:~/git/portal-cf-transport-service:]2036$ for i in {1..5}; do echo $i; done
1
2
3
4
5
[i500695@WYLQRXL9LQ:2022-04-03 18:03:57:~/git/portal-cf-transport-service:]2037$ echo {1..10}
1 2 3 4 5 6 7 8 9 10
[i500695@WYLQRXL9LQ:2022-04-03 18:04:11:~/git/portal-cf-transport-service:]2038$ echo {a..z}
a b c d e f g h i j k l m n o p q r s t u v w x y z
[i500695@WYLQRXL9LQ:2022-04-03 18:04:15:~/git/portal-cf-transport-service:]2039$ echo {10..1}
10 9 8 7 6 5 4 3 2 1
[i500695@WYLQRXL9LQ:2022-04-03 18:04:22:~/git/portal-cf-transport-service:]2040$ echo {z..a}
z y x w v u t s r q p o n m l k j i h g f e d c b a
[i500695@WYLQRXL9LQ:2022-04-03 18:04:27:~/git/portal-cf-transport-service:]2041$ echo {Z..a}
Z [  ] ^ _ ` a
[i500695@WYLQRXL9LQ:2022-04-03 18:06:22:~/git/portal-cf-transport-service:]2046$ echo "number #"{1..10}
number #1 number #2 number #3 number #4 number #5 number #6 number #7 number #8 number #9 number #10

            21.3.1.2 from source
#!/bin/bash

for i in {1..10}
#  Simpler and more straightforward than
#+ for i in $(seq 10)
do
  echo -n "$i "
done

echo

# 1 2 3 4 5 6 7 8 9 10



# Or just . . .

echo {a..z}    #  a b c d e f g h i j k l m n o p q r s t u v w x y z
echo {e..m}    #  e f g h i j k l m
echo {z..a}    #  z y x w v u t s r q p o n m l k j i h g f e d c b a
               #  Works backwards, too.
echo {25..30}  #  25 26 27 28 29 30
echo {3..-2}   #  3 2 1 0 -1 -2
echo {X..d}    #  X Y Z [  ] ^ _ ` a b c d
               #  Shows (some of) the ASCII characters between Z and a,
               #+ but don't rely on this type of behavior because . . .
echo {]..a}    #  {]..a}
               #  Why?


# You can tack on prefixes and suffixes.
echo "Number #"{1..4}, "..."
     # Number #1, Number #2, Number #3, Number #4, ...


# You can concatenate brace-expansion sets.
echo {1..3}{x..z}" +" "..."
     # 1x + 1y + 1z + 2x + 2y + 2z + 3x + 3y + 3z + ...
     # Generates an algebraic expression.
     # This could be used to find permutations.

# You can nest brace-expansion sets.
echo {{a..c},{1..3}}
     # a b c 1 2 3
     # The "comma operator" splices together strings.

# ########## ######### ############ ########### ######### ###############
# Unfortunately, brace expansion does not lend itself to parameterization.
var1=1
var2=5
echo {$var1..$var2}   # {1..5}


# Yet, as Emiliano G. points out, using "eval" overcomes this limitation.

start=0
end=10
for index in $(eval echo {$start..$end})
do
  echo -n "$index "   # 0 1 2 3 4 5 6 7 8 9 10 
done

echo

        21.3.2 The ${!array[@]} operator, which expands to all the indices of a given array. iterate array
my example:
[i500695@WYLQRXL9LQ:2022-04-05 15:37:04:~/work/code/nodejs/tutorial:]2025$ arr=(a b c d)
[i500695@WYLQRXL9LQ:2022-04-05 15:37:32:~/work/code/nodejs/tutorial:]2028$ echo ${arr[0]}
a
[i500695@WYLQRXL9LQ:2022-04-05 15:37:45:~/work/code/nodejs/tutorial:]2029$ for i in {0..3}; do echo ${arr[i]}; done
a
b
c
d
[i500695@WYLQRXL9LQ:2022-04-05 15:38:15:~/work/code/nodejs/tutorial:]2030$ for i in ${!arr[@]}; do echo ${arr[i]}; done
a
b
c
d
source:
#!/bin/bash

Array=(element-zero element-one element-two element-three)

echo ${Array[0]}   # element-zero
                   # First element of array.

echo ${!Array[@]}  # 0 1 2 3
                   # All the indices of Array.

for i in ${!Array[@]}
do
  echo ${Array[i]} # element-zero
                   # element-one
                   # element-two
                   # element-three
                   #
                   # All the elements in Array.
done


        21.3.3 The =~ Regular Expression matching operator within a double brackets test expression. (Perl has a similar operator.)
my-example:
[i500695@WYLQRXL9LQ:2022-04-05 15:38:40:~/work/code/nodejs/tutorial:]2031$ tstr='a test string'
[i500695@WYLQRXL9LQ:2022-04-05 16:12:59:~/work/code/nodejs/tutorial:]2042$ echo $tstr
a test string
[i500695@WYLQRXL9LQ:2022-04-05 16:13:08:~/work/code/nodejs/tutorial:]2043$ if [[ "$tstr" =~ ^a.*ring$ ]]; then echo "match found"; fi
match found

source:
#!/bin/bash

variable="This is a fine mess."

echo "$variable"

# Regex matching with =~ operator within [[ double brackets ]].
if [[ "$variable" =~ T.........fin*es* ]]
# NOTE: As of version 3.2 of Bash, expression to match no longer quoted.
then
  echo "match found"
      # match found
fi

Or, more usefully:

#!/bin/bash

input=$1


if [[ "$input" =~ "[0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]" ]]
#                 ^ NOTE: Quoting not necessary, as of version 3.2 of Bash.
# NNN-NN-NNNN (where each N is a digit).
then
  echo "Social Security number."
  # Process SSN.
else
  echo "Not a Social Security number!"
  # Or, ask for corrected input.
fi

    21.4 bash version 4
Chet Ramey announced Version 4 of Bash on the 20th of February, 2009


        21.4.1 Associative arrays.

An associative array can be thought of as a set of two linked arrays -- one holding the data, and the other the keys that index the individual elements of the data array
[i500695@WYLQRXL9LQ:2022-04-05 18:44:54:~/work/code/bash/bashv4:]2058$ cat !$
cat associative_arrays_demo.sh
declare -A ages

ages["Yosi"]=45
ages["Deby"]=44
ages["May"]=15
ages["Itay"]=10
ages["Kay"]=7
ages["Aimy"]=6

echo "Yosi's ages is ${ages[yosi]}"
echo "Deby's ages is ${ages[Deby]}"
echo "May's ages is ${ages[May]}"
echo "Itay's ages is ${ages[Itay]}"
echo "Kay's ages is ${ages[Kay]}"
echo "Aimy's ages is ${ages[Aimy]}"

        21.4.2 Enhancements to the case construct: the ;;& and ;& terminators.

Example 37-7. Testing characters

#!/bin/bash4

test_char ()
{
  case "$1" in
    [[:print:]] )  echo "$1 is a printable character.";;&       # |
    # The ;;& terminator continues to the next pattern test.      |
    [[:alnum:]] )  echo "$1 is an alpha/numeric character.";;&  # v
    [[:alpha:]] )  echo "$1 is an alphabetic character.";;&     # v
    [[:lower:]] )  echo "$1 is a lowercase alphabetic character.";;&
    [[:digit:]] )  echo "$1 is an numeric character.";&         # |
    # The ;& terminator executes the next statement ...         # |
    %%%@@@@@    )  echo "********************************";;    # v
#   ^^^^^^^^  ... even with a dummy pattern.
  esac
}

echo

test_char 3
# 3 is a printable character.
# 3 is an alpha/numeric character.
# 3 is an numeric character.
# ********************************
echo

test_char m
# m is a printable character.
# m is an alpha/numeric character.
# m is an alphabetic character.
# m is a lowercase alphabetic character.
echo

test_char /
# / is a printable character.

echo

# The ;;& terminator can save complex if/then conditions.
# The ;& is somewhat less useful.

        21.4.3 The new coproc builtin enables two parallel processes to communicate and interact. 
        As Chet Ramey states in the Bash FAQ [2] , ver. 4.01:

    There is a new 'coproc' reserved word that specifies a coprocess:
    an asynchronous command run with two pipes connected to the creating
    shell. Coprocs can be named. The input and output file descriptors
    and the PID of the coprocess are available to the calling shell in
    variables with coproc-specific names.

    George Dimitriu explains,
    "... coproc ... is a feature used in Bash process substitution,
    which now is made publicly available."
    This means it can be explicitly invoked in a script, rather than
    just being a behind-the-scenes mechanism used by Bash.

Coprocesses use file descriptors. File descriptors enable processes and pipes to communicate.

#!/bin/bash4
# A coprocess communicates with a while-read loop.


coproc { cat mx_data.txt; sleep 2; }
#                         ^^^^^^^
# Try running this without "sleep 2" and see what happens.

while read -u ${COPROC[0]} line    #  ${COPROC[0]} is the
do                                 #+ file descriptor of the coprocess.
  echo "$line" | sed -e 's/line/NOT-ORIGINAL-TEXT/'
done

kill $COPROC_PID                   #  No longer need the coprocess,
                                   #+ so kill its PID.

But, be careful!

#!/bin/bash4

echo; echo
a=aaa
b=bbb
c=ccc

coproc echo "one two three"
while read -u ${COPROC[0]} a b c;  #  Note that this loop
do                                 #+ runs in a subshell.
  echo "Inside while-read loop: ";
  echo "a = $a"; echo "b = $b"; echo "c = $c"
  echo "coproc file descriptor: ${COPROC[0]}"
done 

# a = one
# b = two
# c = three
# So far, so good, but ...

echo "-----------------"
echo "Outside while-read loop: "
echo "a = $a"  # a =
echo "b = $b"  # b =
echo "c = $c"  # c =
echo "coproc file descriptor: ${COPROC[0]}"
echo
#  The coproc is still running, but ...
#+ it still doesn't enable the parent process
#+ to "inherit" variables from the child process, the while-read loop.

#  Compare this to the "badread.sh" script.

Caution	
The coprocess is asynchronous, and this might cause a problem. It may terminate before another process has finished communicating with it.

#!/bin/bash4

coproc cpname { for i in {0..10}; do echo "index = $i"; done; }
#      ^^^^^^ This is a *named* coprocess.
read -u ${cpname[0]}
echo $REPLY         #  index = 0
echo ${COPROC[0]}   #+ No output ... the coprocess timed out
#  after the first loop iteration.



# However, George Dimitriu has a partial fix.

coproc cpname { for i in {0..10}; do echo "index = $i"; done; sleep 1;
echo hi > myo; cat - >> myo; }
#       ^^^^^ This is a *named* coprocess.

echo "I am main"$'\04' >&${cpname[1]}
myfd=${cpname[0]}
echo myfd=$myfd

### while read -u $myfd
### do
###   echo $REPLY;
### done

echo $cpname_PID

#  Run this with and without the commented-out while-loop, and it is
#+ apparent that each process, the executing shell and the coprocess,
#+ waits for the other to finish writing in its own write-enabled pipe.

        21.4.4 Parameter substitution gets case-modification operators.

#!/bin/bash4

var=veryMixedUpVariable
echo ${var}            # veryMixedUpVariable
echo ${var^}           # VeryMixedUpVariable
#         *              First char --> uppercase.
echo ${var^^}          # VERYMIXEDUPVARIABLE
#         **             All chars  --> uppercase.
echo ${var,}           # veryMixedUpVariable
#         *              First char --> lowercase.
echo ${var,,}          # verymixedupvariable
#         **             All chars  --> lowercase.

        21.4.5 The declare builtin now accepts the -l lowercase and -c capitalize options.

#!/bin/bash4

declare -l var1            # Will change to lowercase
var1=MixedCaseVARIABLE
echo "$var1"               # mixedcasevariable
# Same effect as             echo $var1 | tr A-Z a-z

declare -c var2            # Changes only initial char to uppercase.
var2=originally_lowercase
echo "$var2"               # Originally_lowercase
# NOT the same effect as     echo $var2 | tr a-z A-Z

        21.4.6 Brace expansion has more options.

Increment/decrement, specified in the final term within braces.

#!/bin/bash4

echo {40..60..2}
# 40 42 44 46 48 50 52 54 56 58 60
# All the even numbers, between 40 and 60.

echo {60..40..2}
# 60 58 56 54 52 50 48 46 44 42 40
# All the even numbers, between 40 and 60, counting backwards.
# In effect, a decrement.
echo {60..40..-2}
# The same output. The minus sign is not necessary.

# But, what about letters and symbols?
echo {X..d}
# X Y Z [  ] ^ _ ` a b c d
# Does not echo the \ which escapes a space.

Zero-padding, specified in the first term within braces, prefixes each term in the output with the same number of zeroes.

bash4$ echo {010..15}
010 011 012 013 014 015


bash4$ echo {000..10}
000 001 002 003 004 005 006 007 008 009 010

        21.4.7 Substring extraction on positional parameters now starts with $0 as the zero-index.
#!/bin/bash
# show-params.bash
# Requires version 4+ of Bash.

# Invoke this scripts with at least one positional parameter.

E_BADPARAMS=99

if [ -z "$1" ]
then
  echo "Usage $0 param1 ..."
  exit $E_BADPARAMS
fi

echo ${@:0}

# bash3 show-params.bash4 one two three
# one two three

# bash4 show-params.bash4 one two three
# show-params.bash4 one two three

# $0                $1  $2  $3

        21.4.8 The new ** globbing operator matches filenames and directories recursively.
[i500695@WYLQRXL9LQ:2022-04-07 13:30:00:~/git/cdm-import-service:]2003$ shopt -s globstar
# Must enable globstar, otherwise ** doesn't work.  # The globstar shell option is new to version 4 of Bash.

[i500695@WYLQRXL9LQ:2022-04-07 18:14:26:~/git/cdm-import-service:]2004$ for file in *; do echo $file; done
CODEOWNERS
..
renovate.json
[i500695@WYLQRXL9LQ:2022-04-07 18:14:50:~/git/cdm-import-service:]2005$ for file in **; do echo $file; done
CODEOWNERS
...
src/app/app.controller.ts


        21.4.9 command_not_found_handle
[i500695@WYLQRXL9LQ:2022-04-07 18:17:15:~/git/cdm-import-service:]2006$ command_not_found_handle ()
{ # Accepts implicit parameters.
  echo "The following command is not valid: \""$1\"""
  echo "With the following argument(s): \""$2\"" \""$3\"""   # $4, $5 ...
} 
[i500695@WYLQRXL9LQ:2022-04-07 18:17:17:~/git/cdm-import-service:]2007$ ccc 
The following command is not valid: "ccc"
With the following argument(s): "" ""
[i500695@WYLQRXL9LQ:2022-04-07 18:17:20:~/git/cdm-import-service:]2008$ ddd 111
The following command is not valid: "ddd"
With the following argument(s): "111" ""


        21.4.10 Here documents embedded in $( ... ) command substitution constructs may terminate with a simple ).

#!/bin/bash
# here-commsub.sh
# Requires Bash version -ge 4.1 ...

multi_line_var=$( cat <<ENDxxx
------------------------------
This is line 1 of the variable
This is line 2 of the variable
This is line 3 of the variable
------------------------------
ENDxxx)

#  Rather than what Bash 4.0 requires:
#+ that the terminating limit string and
#+ the terminating close-parenthesis be on separate lines.

# ENDxxx
# )
[i500695@WYLQRXL9LQ:2022-04-07 18:19:02:~/git/cdm-import-service:]2010$ echo $multi_line_var 
------------------------------ This is line 1 of the variable This is line 2 of the variable This is line 3 of the variable ------------------------------


        21.4.11 Negative array indices permit counting backwards from the end of an array.
#!/bin/bash
# neg-array.sh
# Requires Bash, version -ge 4.2.

array=( zero one two three four five )   # Six-element array.
#         0    1   2    3    4    5
#        -6   -5  -4   -3   -2   -1

# Negative array indices now permitted.
echo ${array[-1]}   # five
echo ${array[-2]}   # four
# ...
echo ${array[-6]}   # zero
# Negative array indices count backward from the last element+1.

# But, you cannot index past the beginning of the array.
echo ${array[-7]}   # array: bad array subscript


# So, what is this new feature good for?

echo "The last element in the array is "${array[-1]}""
# Which is quite a bit more straightforward than:
echo "The last element in the array is "${array[${#array[*]}-1]}""
echo

# And ...

index=0
let "neg_element_count = 0 - ${#array[*]}"
# Number of elements, converted to a negative number.

while [ $index -gt $neg_element_count ]; do
  ((index--)); echo -n "${array[index]} "
done  # Lists the elements in the array, backwards.
      # We have just simulated the "tac" command on this array.

echo

# See also neg-offset.sh.

        21.4.12 Negative parameter in string-extraction construct

#!/bin/bash
# Bash, version -ge 4.2
# Negative length-index in substring extraction.
# Important: It changes the interpretation of this construct!

stringZ=abcABC123ABCabc

echo ${stringZ}                              # abcABC123ABCabc
#                   Position within string:    0123456789.....
echo ${stringZ:2:3}                          #   cAB
#  Count 2 chars forward from string beginning, and extract 3 chars.
#  ${string:position:length}

#  So far, nothing new, but now ...

                                             # abcABC123ABCabc
#                   Position within string:    0123....6543210
echo ${stringZ:3:-6}                         #    ABC123
#                ^
#  Index 3 chars forward from beginning and 6 chars backward from end,
#+ and extract everything in between.
#  ${string:offset-from-front:offset-from-end}
#  When the "length" parameter is negative, 
#+ it serves as an offset-from-end parameter.

        21.4.13
    21.5 bash version 5
Source: https://www.shell-tips.com/bash/what-is-new-in-gnu-bash-5/ 
https://lists.gnu.org/archive/html/bug-bash/2019-01/msg00063.html
The most notable new features are several new shell variables: BASH_ARGV0,
EPOCHSECONDS, and EPOCHREALTIME. The `history' builtin can remove ranges of
history entries and understands negative arguments as offsets from the end
of the history list. There is an option to allow local variables to inherit
the value of a variable with the same name at a preceding scope. There is
a new shell option that, when enabled, causes the shell to attempt to
expand associative array subscripts only once (this is an issue when they
are used in arithmetic expressions).  The `globasciiranges' shell option
is now enabled by default; it can be set to off by default at configuration
time.
        21.5.1 


    21.6 bash version 6

    21.7
22. command line scripts, tags:  command line scripts, CLI, arguments, parameters

    22.1 chatgpt 


        22.1.1 command line scripts, tags:  command line scripts, CLI, arguments, parameters
There are several ways to write a Bash script that receives arguments. Here are a few examples:

Using positional parameters:
#!/bin/bash

# Script to process two input arguments
echo "First argument: $1"
echo "Second argument: $2"


In this example, the script takes two arguments as positional parameters ($1 and $2). The values of these parameters are printed to the console using the echo command.

Using the getopts command:
#!/bin/bash

while getopts ":a:b:" opt; do
  case $opt in
    a)
      arg1="$OPTARG"
      ;;
    b)
      arg2="$OPTARG"
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      exit 1
      ;;
    :)
      echo "Option -$OPTARG requires an argument." >&2
      exit 1
      ;;
  esac
done

echo "First argument: $arg1"
echo "Second argument: $arg2"

In this example, the getopts command is used to parse command line options and arguments. The script defines two options (-a and -b) and assigns the values of these options to the variables $arg1 and $arg2, respectively.

Using environment variables:
#!/bin/bash

# Script to process two input arguments
echo "First argument: $MY_VAR1"
echo "Second argument: $MY_VAR2"

In this example, the script expects the arguments to be passed as environment variables (MY_VAR1 and MY_VAR2). These variables can be set before running the script, like so:
export MY_VAR1="hello"
export MY_VAR2="world"
./myscript.sh

Using command line arguments with flags:
#!/bin/bash

# Script to process two input arguments
while getopts ":a:b:" opt; do
  case $opt in
    a)
      arg1="$OPTARG"
      ;;
    b)
      arg2="$OPTARG"
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      exit 1
      ;;
    :)
      echo "Option -$OPTARG requires an argument." >&2
      exit 1
      ;;
  esac
done

shift $((OPTIND-1))

echo "First argument: $arg1"
echo "Second argument: $arg2"
echo "Remaining arguments: $@"

In this example, the script uses the getopts command to parse options and arguments, as in example 2. However, it also uses the shift command to remove the options from the argument list. This allows the remaining arguments to be processed as positional parameters (accessed using $@). The script can be run like so:

./myscript.sh -a hello -b world foo bar baz
In this case, $1 is set to foo, $2 is set to bar, and $3 is set to baz.

        22.1.2 are there additional ways
Yes, there are additional ways to write a Bash script that receives arguments. Here are a few more examples:

Using the read command:
#!/bin/bash

# Script to process two input arguments
read -p "Enter first argument: " arg1
read -p "Enter second argument: " arg2

echo "First argument: $arg1"
echo "Second argument: $arg2"
In this example, the read command is used to prompt the user to enter the arguments. The values entered are assigned to the variables $arg1 and $arg2, respectively.

Using command line arguments with a loop:
#!/bin/bash

# Script to process any number of input arguments
for arg in "$@"
do
  echo "$arg"
done
In this example, the script processes any number of input arguments using a for loop. The loop iterates over the values in $@, which contains all of the command line arguments, and prints each one to the console.

Using a configuration file:
#!/bin/bash

# Script to process input arguments from a configuration file
source myconfig.conf

echo "First argument: $arg1"
echo "Second argument: $arg2"
In this example, the script reads the arguments from a configuration file called myconfig.conf. The file should contain variable assignments, like so:

arg1="hello"
arg2="world"
The source command is used to read the file and set the variables $arg1 and $arg2 to the values specified in the file.

These are just a few examples of the many ways you can write a Bash script that receives arguments. The method you choose will depend on the specific requirements of your script and the preferences of the user.

        22.1.3 yet more ways
Sure, here are a few more ways to write a Bash script that receives arguments:

Using command line arguments with shift and a loop:
#!/bin/bash

# Script to process any number of input arguments
while [[ $# -gt 0 ]]
do
  case "$1" in
    -a|--arg1)
      arg1="$2"
      shift 2
      ;;
    -b|--arg2)
      arg2="$2"
      shift 2
      ;;
    *)
      echo "Unknown option: $1"
      exit 1
      ;;
  esac
done

echo "First argument: $arg1"
echo "Second argument: $arg2"
In this example, the script uses a while loop to iterate over the command line arguments. The case statement is used to parse the options (-a or --arg1 and -b or --arg2) and assign the values to the variables $arg1 and $arg2, respectively. The shift command is used to remove the processed arguments from the argument list.

Using command line arguments with getopts and shift:
#!/bin/bash

# Script to process two input arguments
while getopts ":a:b:" opt; do
  case $opt in
    a)
      arg1="$OPTARG"
      ;;
    b)
      arg2="$OPTARG"
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      exit 1
      ;;
    :)
      echo "Option -$OPTARG requires an argument." >&2
      exit 1
      ;;
  esac
done

shift $((OPTIND-1))

echo "First argument: $arg1"
echo "Second argument: $arg2"
echo "Remaining arguments: $@"
This example is similar to example 4, but uses shift to remove the processed arguments from the argument list after parsing the options with getopts. The remaining arguments can be processed as positional parameters (accessed using $@).

Using a configuration file with source and command line arguments:
#!/bin/bash

# Script to process input arguments from a configuration file and command line
source myconfig.conf

while [[ $# -gt 0 ]]
do
  case "$1" in
    -a|--arg1)
      arg1="$2"
      shift 2
      ;;
    -b|--arg2)
      arg2="$2"
      shift 2
      ;;
    *)
      echo "Unknown option: $1"
      exit 1
      ;;
  esac
done

echo "First argument: $arg1"
echo "Second argument: $arg2"
echo "Config argument: $configarg"
In this example, the script uses both a configuration file (myconfig.conf) and command line arguments. The source command is used to read the configuration file and set the variable $configarg to the specified value. The command line arguments are parsed using a case statement, as in example 8, and assigned to the variables $arg1 and $arg2, respectively.

These are just a few more examples of the many ways you can write a Bash script that receives arguments. The best method will depend on the specific requirements of your script and the preferences of the user.

        22.1.4 bash script to process a text file containing a list of names

ChatGPT
Sure, here is an example Bash script to process a text file containing a list of names:

#!/bin/bash

# Script to process a list of names from a file

# Check that a filename was provided
if [ $# -eq 0 ]
then
  echo "Please provide a filename."
  exit 1
fi

# Check that the file exists and is readable
if [ ! -f $1 ] || [ ! -r $1 ]
then
  echo "File not found or not readable."
  exit 1
fi

# Read the file line by line and process each name
while read name
do
  echo "Hello, $name!"
done < $1
This script takes one argument, which should be the name of the file containing the list of names. It first checks that a filename was provided, and then checks that the file exists and is readable. If either of these checks fails, the script exits with an error message.

Assuming the file exists and is readable, the script reads the file line by line using a while loop and the read command. For each line (i.e., each name), the script outputs a greeting using the echo command.

You can run this script by calling it with the filename as the only argument:

$ ./process_names.sh names.txt
Assuming the file names.txt exists in the same directory as the script, the script will output a greeting for each name in the file.





User
can it be done differently?
ChatGPT
Yes, there are different ways to process a text file containing a list of names in a Bash script. Here are a couple of additional approaches:

Using a for loop with cat:
#!/bin/bash

# Script to process a list of names from a file

# Check that a filename was provided
if [ $# -eq 0 ]
then
  echo "Please provide a filename."
  exit 1
fi

# Check that the file exists and is readable
if [ ! -f $1 ] || [ ! -r $1 ]
then
  echo "File not found or not readable."
  exit 1
fi

# Process each name in the file using a for loop and cat
for name in $(cat $1)
do
  echo "Hello, $name!"
done
In this approach, the cat command is used to output the contents of the file as a stream of text, and the for loop iterates over each name in the stream. The script checks for the existence and readability of the file as in the previous example.

Using while loop with IFS:
#!/bin/bash

# Script to process a list of names from a file

# Check that a filename was provided
if [ $# -eq 0 ]
then
  echo "Please provide a filename."
  exit 1
fi

# Check that the file exists and is readable
if [ ! -f $1 ] || [ ! -r $1 ]
then
  echo "File not found or not readable."
  exit 1
fi

# Read the file line by line and process each name
while IFS= read -r name
do
  echo "Hello, $name!"
done < $1
This approach uses the IFS (Internal Field Separator) variable to set the delimiter for the read command to the newline character, so that each line of the file is read as a separate item. The while loop iterates over each item, which is assigned to the $name variable. The script checks for the existence and readability of the file as in the previous example.

These are just a couple of examples of how you can process a text file containing a list of names in a Bash script. The best approach will depend on the specific requirements of your script and the format of the file.





User
yet more ways
ChatGPT
Sure, here are a few more ways to process a text file containing a list of names in a Bash script:

Using awk:
#!/bin/bash

# Script to process a list of names from a file

# Check that a filename was provided
if [ $# -eq 0 ]
then
  echo "Please provide a filename."
  exit 1
fi

# Check that the file exists and is readable
if [ ! -f $1 ] || [ ! -r $1 ]
then
  echo "File not found or not readable."
  exit 1
fi

# Use awk to process each name in the file
awk '{print "Hello,", $0, "!"}' $1
In this approach, awk is used to process each line of the file and output a greeting for each name. The $0 variable in awk represents the entire line, so we can use it to reference each name in the file. The script checks for the existence and readability of the file as in the previous examples.

Using sed:
#!/bin/bash

# Script to process a list of names from a file

# Check that a filename was provided
if [ $# -eq 0 ]
then
  echo "Please provide a filename."
  exit 1
fi

# Check that the file exists and is readable
if [ ! -f $1 ] || [ ! -r $1 ]
then
  echo "File not found or not readable."
  exit 1
fi

# Use sed to process each name in the file
sed 's/^/Hello, /; s/$/!/' $1
In this approach, sed is used to process each line of the file and add a greeting to each name. The first s command adds "Hello, " to the beginning of each line (^ represents the beginning of the line), and the second s command adds "!" to the end of each line ($ represents the end of the line). The script checks for the existence and readability of the file as in the previous examples.

These are just a few more examples of how you can process a text file containing a list of names in a Bash script. There are many other commands and utilities available in Bash that you can use to manipulate and process text files.

        22.1.5 parse json file containing an array of names and print each name bash

ChatGPT
You can use the jq command to parse a JSON file containing an array of names and print each name in Bash. Here's an example script:

#!/bin/bash

# Script to parse a JSON file containing an array of names

# Check that a filename was provided
if [ $# -eq 0 ]
then
  echo "Please provide a filename."
  exit 1
fi

# Check that the file exists and is readable
if [ ! -f $1 ] || [ ! -r $1 ]
then
  echo "File not found or not readable."
  exit 1
fi

# Use jq to parse the JSON file and print each name
jq -r '.[]' $1
In this script, we first check that a filename was provided as an argument and that the file exists and is readable. Then we use the jq command with the -r option to parse the JSON file and print each element of the top-level array. The . represents the top-level of the JSON object, and [] is used to select all elements of the array. The -r option tells jq to output the results as raw strings, without any additional formatting.

For example, if the JSON file names.json contains the following array of names:
[
  "Alice",
  "Bob",
  "Charlie"
]
Running the script with ./parse_names.sh names.json would output:

Alice
Bob
Charlie
Note that this script assumes that the input JSON file contains an array of names at the top level. If your JSON file has a different structure, you may need to modify the jq command to extract the names in the appropriate way.


User
names array is the value of property 'names'
ChatGPT
If the names array is the value of a property called "names" in the JSON file, you can modify the jq command to extract the array and print each element. Here's an updated script:

bash
Copy code
#!/bin/bash

# Script to parse a JSON file containing a "names" property with an array of names

# Check that a filename was provided
if [ $# -eq 0 ]
then
  echo "Please provide a filename."
  exit 1
fi

# Check that the file exists and is readable
if [ ! -f $1 ] || [ ! -r $1 ]
then
  echo "File not found or not readable."
  exit 1
fi

# Use jq to extract the "names" property and print each name
jq -r '.names[]' $1
In this updated script, we use the jq command to extract the "names" property with the .names selector, and then use the [] operator to extract each element of the array. The -r option is used to output the results as raw strings, without any additional formatting.

For example, if the JSON file names.json contains the following object with a "names" property:

{
  "names": [
    "Alice",
    "Bob",
    "Charlie"
  ]
}
Running the script with ./parse_names.sh names.json would output:

Alice
Bob
Charlie
Again, if your JSON file has a different structure or property name, you may need to modify the jq command accordingly.

User
is it possible without jq
ChatGPT
Yes, it is possible to extract and print the names from a JSON file without using jq, but it would require more complex scripting in Bash.

One way to achieve this would be to use grep and sed commands to extract the names from the JSON file. Here's an example script:

bash
Copy code
#!/bin/bash

# Script to extract names from a JSON file without using jq

# Check that a filename was provided
if [ $# -eq 0 ]
then
  echo "Please provide a filename."
  exit 1
fi

# Check that the file exists and is readable
if [ ! -f $1 ] || [ ! -r $1 ]
then
  echo "File not found or not readable."
  exit 1
fi

# Use grep to find the "names" property and sed to extract the array
names=$(grep -o '"names":[^]]*' $1 | sed 's/"names"://')

# Use sed to remove the brackets and quotes from the array
names=$(echo $names | sed 's/[][]//g; s/"//g')

# Loop through the names and print each one
for name in $names
do
  echo $name
done
In this script, we first use grep to search for the "names" property in the JSON file and extract the array using a regular expression. The [^]]* pattern matches any characters that are not a closing bracket ], so we capture all the characters between the "names" property and the end of the array.

We then use sed to remove the "names" property from the captured string, as well as any remaining quotes and brackets. This leaves us with a comma-separated list of names, which we can loop through and print using a for loop.

Note that this approach assumes that the "names" property is a top-level property in the JSON file and that the names array does not contain any nested arrays or objects. If your JSON file has a different structure, this script may not work correctly.

        22.1.6 parse json file containing an array of names and load the names into an array then iterate over the array of names
You can use the jq command-line tool to parse JSON files in Bash. Here's an example of how you can use jq to load an array of names from a JSON file and iterate over it in Bash:

#!/bin/bash

# Load the names from the JSON file into an array
names=($(jq -r '.names[]' names.json))

# Iterate over the array of names
for name in "${names[@]}"
do
  echo "Name: $name"
done
Assuming your JSON file names.json looks like this:

{
  "names": [
    "Alice",
    "Bob",
    "Charlie"
  ]
}
The above script will output:

Name: Alice
Name: Bob
Name: Charlie
In the script, the jq command with the -r option outputs the values of the .names[] array in raw format (i.e., without quotes) and uses the command substitution $(...) to load the output into the names array. Then, the for loop iterates over the array and prints each name using echo.

        22.1.7 linux delete all files with specific pattern 
- my way jj 
ex: alias del_orig="find . -name '*.orig' | xargs rm"

- gpt way:
You can use the `rm` command with the `-f` (force) and `-r` (recursive) options to delete all files with a specific pattern in a directory and its subdirectories.

Here's an example command that deletes all files with the `.txt` extension in the current directory and its subdirectories:

```
rm -rf *.txt
```

In this command, `rm` is the command to remove files, `-r` specifies that it should be done recursively, `-f` specifies that it should be done forcefully (without prompting for confirmation), and `*.txt` is the pattern that matches all files with the `.txt` extension.

You should be careful when using this command, as it will delete all files that match the pattern without prompting for confirmation. It's a good idea to test the command first by running it with the `-i` option, which prompts for confirmation before deleting each file:

```
rm -rfi *.txt
```

This will list all the files that match the pattern and ask you to confirm each deletion.

It's also a good idea to double-check the pattern before running the command, to make sure that you're only deleting the files that you intend to delete.

- can I use find and rm to achieve the same
Yes, you can use the `find` command along with the `rm` command to achieve the same result as using `rm` with a pattern.

Here's an example command that deletes all files with the `.txt` extension in the current directory and its subdirectories using `find` and `rm`:

```
find . -name "*.txt" -type f -delete
```

In this command, `find` is used to locate all files with the `.txt` extension (`-name "*.txt"`) that are regular files (`-type f`) in the current directory and its subdirectories (`.`), and the `-delete` option is used to delete them.

Again, you should be careful when using this command, as it will delete all files that match the pattern without prompting for confirmation. It's a good idea to test the command first by running it with the `-print` option, which will list the files that would be deleted:

```
find . -name "*.txt" -type f -print
```

If you're satisfied with the list of files, you can run the command again without the `-print` option to actually delete the files.

It's also worth noting that the `find` command is more flexible than using a pattern with `rm`, as it allows you to search for files based on a variety of criteria, such as file size, modification time, and ownership. This can be useful if you need to delete files based on more specific criteria.

- an I use pipe and exec for same result in bash

Yes, you can use a pipe and the `exec` command to achieve the same result as using `find` and `rm` together.

Here's an example command that deletes all files with the `.txt` extension in the current directory and its subdirectories using a pipe and the `exec` command:

```
find . -name "*.txt" -type f -print0 | xargs -0 -I{} sh -c 'exec rm "{}"'
```

In this command, `find` is used to locate all files with the `.txt` extension (`-name "*.txt"`) that are regular files (`-type f`) in the current directory and its subdirectories (`.`), and the `-print0` option is used to separate the filenames with null characters instead of newlines.

The `|` symbol is used to pipe the output of `find` to `xargs`, which reads the null-separated filenames and passes them to the `rm` command.

The `-0` option is used with `xargs` to interpret the input as null-separated filenames, and the `-I{}` option is used to replace occurrences of `{}` in the `sh -c` command with the filename.

Finally, the `exec` command is used in the `sh -c` command to replace the shell process with the `rm` command, which deletes the file.

Again, you should be careful when using this command, as it will delete all files that match the pattern without prompting for confirmation. It's a good idea to test the command first by running it with the `-print0` option and omitting the `| xargs -0 -I{} sh -c 'exec rm "{}"'` part of the command, which will list the files that would be deleted:

```
find . -name "*.txt" -type f -print0
```

If you're satisfied with the list of files, you can run the full command again to actually delete the files.

It's worth noting that using a pipe and the `exec` command can be less efficient than using `find` and `rm` together, as it involves starting a new shell process for each file. However, for small numbers of files, the difference in performance may not be noticeable.


        22.1.8
    22.2


23.
