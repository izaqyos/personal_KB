.........................................Table Of Contents...............................................................
1. Write to file <URL:#tn=1. Write to file>
2. C time and date utilities <URL:#tn=2. C time and date utilities>
	2.1 CTime, time.h <URL:#tn=	2.1 CTime, time.h>
		2.1.1 Elapsed time <URL:#tn=		2.1.1 Elapsed time>
		2.1.2 My elapsed time + timer example <URL:#tn=		2.1.2 My elapsed time + timer example>
		2.1.3 http://stackoverflow.com/questions/1468596/calculating-elapsed-time-in-a-c-program-in-milliseconds <URL:#tn=		2.1.3 http://stackoverflow.com/questions/1468596/calculating-elapsed-time-in-a-c-program-in-milliseconds>
		2.1.4 <URL:#tn=		2.1.4>
3. Best books to learn C from <URL:#tn=3. Best books to learn C from>
4.  Language Popular rankings <URL:#tn=4.  Language Popular rankings>
	4.1  http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html <URL:#tn=	4.1  http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html>
5. Process control <URL:#tn=5. Process control>
	5.1  YoLinux Tutorial: Fork, Exec and Process control <URL:#tn=	5.1  YoLinux Tutorial: Fork, Exec and Process control>
	5.2 WAIT(2) Linux Programmer's Manual		        <URL:#tn=	5.2 WAIT(2) Linux Programmer's Manual		       >
6.  Signal handling <URL:#tn=6.  Signal handling>
	6.1  signalfd <URL:#tn=	6.1  signalfd>
		6.1.1   Linux man page <URL:#tn=		6.1.1   Linux man page>
		6.1.2 Code examples <URL:#tn=		6.1.2 Code examples>
			6.1.2.1 Waiting for a signal with timeout using sigtimedwait() <URL:#tn=			6.1.2.1 Waiting for a signal with timeout using sigtimedwait()>
			6.1.2.2 Blocking signals with sigprocmask() <URL:#tn=			6.1.2.2 Blocking signals with sigprocmask()>
			6.1.2.3 Handling interruption of system calls by signals <URL:#tn=			6.1.2.3 Handling interruption of system calls by signals>
			6.1.2.4 Example of using signalfd() <URL:#tn=			6.1.2.4 Example of using signalfd()>
			6.1.2.5 Example of using sigaction() <URL:#tn=			6.1.2.5 Example of using sigaction()>
			6.1.2.6 SIGBUS handling <URL:#tn=			6.1.2.6 SIGBUS handling>
			6.1.2.7 SIGCHLD handler <URL:#tn=			6.1.2.7 SIGCHLD handler>
			6.1.2.8 Using pselect() to avoid a signal race <URL:#tn=			6.1.2.8 Using pselect() to avoid a signal race>
			6.1.2.9 Signal race with select() and accept() <URL:#tn=			6.1.2.9 Signal race with select() and accept()>
			6.1.2.10 <URL:#tn=			6.1.2.10>
	6.2 Select <URL:#tn=	6.2 Select>
		6.2.1 example <URL:#tn=		6.2.1 example>
		6.2.2 <URL:#tn=		6.2.2>
	6.3 epoll <URL:#tn=	6.3 epoll>
		6.3.1 Description <URL:#tn=		6.3.1 Description>
		6.3.2 Using epoll() For Asynchronous Network Programming <URL:#tn=		6.3.2 Using epoll() For Asynchronous Network Programming>
		6.3.3 <URL:#tn=		6.3.3>
	6.4 libevent <URL:#tn=	6.4 libevent>
		6.4.1 event-test.c <URL:#tn=		6.4.1 event-test.c>
7. C How to Program, 5th edition <URL:#tn=7. C How to Program, 5th edition>
	7.1 Introduction <URL:#tn=	7.1 Introduction>
		7.1.1 History of C <URL:#tn=		7.1.1 History of C>
		7.1.2 C Standard Library <URL:#tn=		7.1.2 C Standard Library>
		7.1.3 C++ <URL:#tn=		7.1.3 C++>
		7.1.4 Java <URL:#tn=		7.1.4 Java>
		7.1.5 BASIC, Visual Basic, Visual C++, Visual C# and .NET <URL:#tn=		7.1.5 BASIC, Visual Basic, Visual C++, Visual C# and .NET>
		7.1.6 Key Software Trend: Object Technology <URL:#tn=		7.1.6 Key Software Trend: Object Technology>
		7.1.7 Typical C Program Development Environment <URL:#tn=		7.1.7 Typical C Program Development Environment>
		7.1.8 Hardware Trends <URL:#tn=		7.1.8 Hardware Trends>
		7.1.9 History of the Internet <URL:#tn=		7.1.9 History of the Internet>
		7.1.10 History of theWorldWideWeb <URL:#tn=		7.1.10 History of theWorldWideWeb>
		7.1.11 Notes About C and This Book <URL:#tn=		7.1.11 Notes About C and This Book>
		7.1.12 Web Resources <URL:#tn=		7.1.12 Web Resources>
		7.1.13 Summary <URL:#tn=		7.1.13 Summary>
		7.1.14 <URL:#tn=		7.1.14>
	7.2 Introduction <URL:#tn=	7.2 Introduction>
		7.2.1 Introduction <URL:#tn=		7.2.1 Introduction>
		7.2.2 A Simple C Program: Printing a Line of Text <URL:#tn=		7.2.2 A Simple C Program: Printing a Line of Text>
		7.2.3 Another Simple C Program: Adding Two Integers <URL:#tn=		7.2.3 Another Simple C Program: Adding Two Integers>
		7.2.4 Memory Concepts <URL:#tn=		7.2.4 Memory Concepts>
		7.2.5 Arithmetic in C <URL:#tn=		7.2.5 Arithmetic in C>
		7.2.6 Decision Making: Equality and Relational Operators <URL:#tn=		7.2.6 Decision Making: Equality and Relational Operators>
	7.3 <URL:#tn=	7.3>
	7.40 Source code examples <URL:#tn=	7.40 Source code examples>
		7.40.1  loops <URL:#tn=		7.40.1  loops>
			7.40.1.1  Average <URL:#tn=			7.40.1.1  Average>
			7.40.1.2 <URL:#tn=			7.40.1.2>
		7.40.2 Operators <URL:#tn=		7.40.2 Operators>
			7.40.2.1 Pre and Post increment <URL:#tn=			7.40.2.1 Pre and Post increment>
			7.40.2.2 <URL:#tn=			7.40.2.2>
		7.40.3 <URL:#tn=		7.40.3>
	7.41 <URL:#tn=	7.41>
8. FAQS <URL:#tn=8. FAQS>
	8.1 Compilation errors <URL:#tn=	8.1 Compilation errors>
		8.1.1 UTF8 BOM, or stray error  <URL:#tn=		8.1.1 UTF8 BOM, or stray error >
		8.1.2 <URL:#tn=		8.1.2>
	8.2 Files <URL:#tn=	8.2 Files>
		8.2.1  How can I get a file's size in C?  <URL:#tn=		8.2.1  How can I get a file's size in C? >
		8.2.2  Read from file <URL:#tn=		8.2.2  Read from file>
			8.2.2.1  Read from file line by line <URL:#tn=			8.2.2.1  Read from file line by line>
		8.2.3 Read from file char by char <URL:#tn=		8.2.3 Read from file char by char>
		8.2.4 function <cstdio> fscanf <URL:#tn=		8.2.4 function <cstdio> fscanf>
	8.3 List & calculate size of files in given directory <URL:#tn=	8.3 List & calculate size of files in given directory>
		8.3.1  <URL:#tn=		8.3.1 >
	8.4 pointers to pointers <URL:#tn=	8.4 pointers to pointers>
		8.4.1  Use cases <URL:#tn=		8.4.1  Use cases>
		8.4.2 <URL:#tn=		8.4.2>
	8.5 <URL:#tn=	8.5>
9. Network programming <URL:#tn=9. Network programming>
	9.1  IPv4 TCP Client <URL:#tn=	9.1  IPv4 TCP Client>
	9.2 IPv4 TCP Server <URL:#tn=	9.2 IPv4 TCP Server>
	9.3 Creating and Destroying Sockets <URL:#tn=	9.3 Creating and Destroying Sockets>
	9.4 Specifying Addresses <URL:#tn=	9.4 Specifying Addresses>
		9.4.1 Generic Addresses <URL:#tn=		9.4.1 Generic Addresses>
		9.4.2 IPv4 Addresses <URL:#tn=		9.4.2 IPv4 Addresses>
		9.4.3 IPv6 Addresses <URL:#tn=		9.4.3 IPv6 Addresses>
		9.4.4 Generic Address Storage <URL:#tn=		9.4.4 Generic Address Storage>
		9.4.5 Binary/String Address Conversion <URL:#tn=		9.4.5 Binary/String Address Conversion>
2.4.6. Getting a Socket’s Associated Addresses <URL:#tn=2.4.6. Getting a Socket’s Associated Addresses>
	9.5 Connecting a Socket <URL:#tn=	9.5 Connecting a Socket>
	9.6 Binding to an Address <URL:#tn=	9.6 Binding to an Address>
	9.7 Handling Incoming Connections <URL:#tn=	9.7 Handling Incoming Connections>
	9.8 Communication <URL:#tn=	9.8 Communication>
	9.9 Using IPv6 <URL:#tn=	9.9 Using IPv6>
	9.10 Non blocking I/O <URL:#tn=	9.10 Non blocking I/O>
		9.10.1 Nonblocking Sockets <URL:#tn=		9.10.1 Nonblocking Sockets>
		9.10.2 Asynchronous I/O <URL:#tn=		9.10.2 Asynchronous I/O>
		9.10.3 Timeouts <URL:#tn=		9.10.3 Timeouts>
	9.11 Select() server example <URL:#tn=	9.11 Select() server example>
	9.12 DNS <URL:#tn=	9.12 DNS>
		9.12.1 New Network Database Functions <URL:#tn=		9.12.1 New Network Database Functions>
			9.12.1.1  getnameinfo <URL:#tn=			9.12.1.1  getnameinfo>
				9.12.1.1.1  Host Functions <URL:#tn=				9.12.1.1.1  Host Functions>
				9.12.1.1.2 Network Functions <URL:#tn=				9.12.1.1.2 Network Functions>
				9.12.1.1.3 Protocol Functions <URL:#tn=				9.12.1.1.3 Protocol Functions>
				9.12.1.1.4 Service Functions <URL:#tn=				9.12.1.1.4 Service Functions>
				9.12.1.1.5 Network Interface Functions <URL:#tn=				9.12.1.1.5 Network Interface Functions>
		9.12.2 getaddrinfo <URL:#tn=		9.12.2 getaddrinfo>
		9.12.3 <URL:#tn=		9.12.3>
	9.13 <URL:#tn=	9.13>
10. Daemon <URL:#tn=10. Daemon>
	10.1 Creating a Daemon Process in C Language with an Example Program  <URL:#tn=	10.1 Creating a Daemon Process in C Language with an Example Program >
		10.1.1  Also print pid of daemon <URL:#tn=		10.1.1  Also print pid of daemon>
		10.1.2 <URL:#tn=		10.1.2>
	10.2 More Professional example, lwsmd  <URL:#tn=	10.2 More Professional example, lwsmd >
	10.3 <URL:#tn=	10.3>
11. libs <URL:#tn=11. libs>
	11.1 stdio <URL:#tn=	11.1 stdio>
		11.1.1 printf <URL:#tn=		11.1.1 printf>
		11.1.2 <URL:#tn=		11.1.2>
	11.2 <URL:#tn=	11.2>
12. Keywords <URL:#tn=12. Keywords>
	12.1 The UNION keyword. <URL:#tn=	12.1 The UNION keyword.>
		12.1.1 Example <URL:#tn=		12.1.1 Example>
		12.1.2 <URL:#tn=		12.1.2>
	12.2 <URL:#tn=	12.2>
13. Recipes <URL:#tn=13. Recipes>
	13.1  Files <URL:#tn=	13.1  Files>
		13.1.1  Setup a marker file to indicate Process was shutdown rather than crashed <URL:#tn=		13.1.1  Setup a marker file to indicate Process was shutdown rather than crashed>
	13.2 Memory <URL:#tn=	13.2 Memory>
		13.2.1  Memory allocating service function demo <URL:#tn=		13.2.1  Memory allocating service function demo>
		13.2.2 <URL:#tn=		13.2.2>
	13.3 C Function Converts ASCII Hex to Binary <URL:#tn=	13.3 C Function Converts ASCII Hex to Binary>
	13.4 <URL:#tn=	13.4>
14. Code generation <URL:#tn=14. Code generation>
	14.1 Flex byson <URL:#tn=	14.1 Flex byson>
		14.1.1  Tutorial <URL:#tn=		14.1.1  Tutorial>
23.4 <URL:#tn=23.4>
23.4 <URL:#tn=23.4>
		14.1.2 <URL:#tn=		14.1.2>
	14.2 <URL:#tn=	14.2>
15. Strings <URL:#tn=15. Strings>
	15.1  string.h <URL:#tn=	15.1  string.h>
		15.1.1  Functions <URL:#tn=		15.1.1  Functions>
	15.2 idioms, common operations, Recipes <URL:#tn=	15.2 idioms, common operations, Recipes>
		15.2.1 Starts with <URL:#tn=		15.2.1 Starts with>
		15.2.2 Tokenize, split <URL:#tn=		15.2.2 Tokenize, split>
			15.2.2.1  strsep is better than strtok_r <URL:#tn=			15.2.2.1  strsep is better than strtok_r>
			15.2.2.2 Splitting a String C++ <URL:#tn=			15.2.2.2 Splitting a String C++>
		15.2.3 replace substring  <URL:#tn=		15.2.3 replace substring >
			15.2.3.1 My example, replace substring "dirName.*," with "dirname:dirname" <URL:#tn=			15.2.3.1 My example, replace substring "dirName.*," with "dirname:dirname">
			15.2.3.2 <URL:#tn=			15.2.3.2>
		15.2.4 <URL:#tn=		15.2.4>
	15.3 <URL:#tn=	15.3>
16. <URL:#tn=16.>
.................................................END TOC..............................................




























1. Write to file
	#include <stdio.h>
	int main()
	{
	FILE *file;
	file = fopen("file.txt","a+"); /* apend file (add text to
	a file or create a file if it does not exist.*/
	fprintf(file,"%s","This is just an example :)"); /*writes*/
	fclose(file); /*done!*/
	getchar(); /* pause and wait for key */
	return 0;
	}

2. C time and date utilities
	2.1 CTime, time.h
	Functions
	Time manipulation
	clock	Clock program (function)
	difftime	Return difference between two times (function)
	mktime	Convert tm structure to time_t (function)
	time	Get current time (function)

	Conversion:
	asctime	Convert tm structure to string (function)
	ctime	Convert time_t value to string (function)
	gmtime	Convert time_t to tm as UTC time (function)
	localtime	Convert time_t to tm as local time (function)
	strftime	Format time to string (function)

	Macros
	CLOCKS_PER_SEC	Clock ticks per second (macro)
	NULL	Null pointer (macro)

	types
	clock_t	Clock type (type)
	size_t	Unsigned integral type (type)
	time_t	Time type (type)
	struct tm	Time structure (type)

		2.1.1 Elapsed time
Elapsed Time

One way to represent an elapsed time is with a simple arithmetic data type, as with the following function to compute the elapsed time between two calendar times. This function is declared in time.h.

Function: double difftime (time_t time1, time_t time0)
Preliminary: | MT-Safe | AS-Safe | AC-Safe | See POSIX Safety Concepts.

The difftime function returns the number of seconds of elapsed time between calendar time time1 and calendar time time0, as a value of type double. The difference ignores leap seconds unless leap second support is enabled.

In the GNU C Library, you can simply subtract time_t values. But on other systems, the time_t data type might use some other encoding where subtraction doesn’t work directly.

The GNU C Library provides two data types specifically for representing an elapsed time. They are used by various GNU C Library functions, and you can use them for your own purposes too. They’re exactly the same except that one has a resolution in microseconds, and the other, newer one, is in nanoseconds.

Data Type: struct timeval
The struct timeval structure represents an elapsed time. It is declared in sys/time.h and has the following members:

time_t tv_sec
This represents the number of whole seconds of elapsed time.

long int tv_usec
This is the rest of the elapsed time (a fraction of a second), represented as the number of microseconds. It is always less than one million.

Data Type: struct timespec
The struct timespec structure represents an elapsed time. It is declared in time.h and has the following members:

time_t tv_sec
This represents the number of whole seconds of elapsed time.

long int tv_nsec
This is the rest of the elapsed time (a fraction of a second), represented as the number of nanoseconds. It is always less than one billion.

It is often necessary to subtract two values of type struct timeval or struct timespec. Here is the best way to do this. It works even on some peculiar operating systems where the tv_sec member has an unsigned type.

/* Subtract the ‘struct timeval’ values X and Y,
   storing the result in RESULT.
   Return 1 if the difference is negative, otherwise 0. */

int
timeval_subtract (result, x, y)
     struct timeval *result, *x, *y;
{
  /* Perform the carry for the later subtraction by updating y. */
  if (x->tv_usec < y->tv_usec) {
    int nsec = (y->tv_usec - x->tv_usec) / 1000000 + 1;
    y->tv_usec -= 1000000 * nsec;
    y->tv_sec += nsec;
  }
  if (x->tv_usec - y->tv_usec > 1000000) {
    int nsec = (x->tv_usec - y->tv_usec) / 1000000;
    y->tv_usec += 1000000 * nsec;
    y->tv_sec -= nsec;
  }

  /* Compute the time remaining to wait.
     tv_usec is certainly positive. */
  result->tv_sec = x->tv_sec - y->tv_sec;
  result->tv_usec = x->tv_usec - y->tv_usec;

  /* Return 1 if result is negative. */
  return x->tv_sec < y->tv_sec;
}
Common functions that use struct timeval are gettimeofday and settimeofday.

There are no GNU C Library functions specifically oriented toward dealing with elapsed times, but the calendar time, processor time, and alarm and sleeping functions have a lot to do with them.

example:
#include <iostream>
#include <sys/time.h>                // for gettimeofday()
using namespace std;

int main()
{
    struct timeval t1, t2;
    double elapsedTime;

    // start timer
    gettimeofday(&t1, NULL);

    // do something
    // ...

    // stop timer
    gettimeofday(&t2, NULL);

    // compute and print the elapsed time in millisec
    elapsedTime = (t2.tv_sec - t1.tv_sec) * 1000.0;      // sec to ms
    elapsedTime += (t2.tv_usec - t1.tv_usec) / 1000.0;   // us to ms
    cout << elapsedTime << " ms.\n";

    return 0;
}
		2.1.2 My elapsed time + timer example
r ~/Desktop/Work/code/C/elapsed_time.c
/*
 * =====================================================================================
 *
 *       Filename:  elapsed_time.c
 *
 *    Description:  Timer
 *
 *        Version:  1.0
 *        Created:  10/06/2015 18:02:41
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  YOSI IZAQ
 *   Organization:  
 *
 * =====================================================================================
 */
#include <stdlib.h>
#include <stdio.h>
#include <sys/time.h> // for gettimeofday 
#include <time.h> // for nanosleep

int main()
{
	
	printf("Enter number of seconds for timer\n");
	double sec =0;
	double elapsed =0;
	scanf("%lf",&sec);


	printf("Starting timer for %lf seconds \n", sec);

	struct timeval t1,t2;

	//start timer
	gettimeofday(&t1, NULL);

	struct timespec time2sleep;
        time2sleep.tv_nsec = 1000000*1 ; // 1 ms = 100k nano sec
        time2sleep.tv_sec = 0; 
	
        int wholesecpassed = 1;
	while (1)
	{

	    nanosleep(&time2sleep , NULL);
	    gettimeofday(&t2, NULL);

	    elapsed = (t2.tv_sec-t1.tv_sec) *1000 ; // sec->ms
	    elapsed += (t2.tv_usec-t1.tv_usec) /1000 ; // microsec->ms

	    //printf("Elapsed time %lf milli seconds, counted whole seconds less than %d \n", elapsed, wholesecpassed);

	    if ( elapsed > (wholesecpassed * 1000) )
	    {
		    printf("%d\n",wholesecpassed);
		    wholesecpassed ++;
	    }

	    if (elapsed > (sec * 1000) )
	    {
		    printf("Timer has expired! \n");
		    exit(0);
	    }
	}


}

|    [yizaq@YIZAQ-M-D1BW:Tue Oct 06:~/Desktop/Work/code/C:]$ gcc elapsed_time.c  -o elapsed_time
|    [yizaq@YIZAQ-M-D1BW:Tue Oct 06:~/Desktop/Work/code/C:]$ ./elapsed_time 
|    Enter number of seconds for timer
|    5.6
|    Starting timer for 5.600000 seconds 
|    1
|    2
|    3
|    4
|    5
|    Timer has expired! 


		2.1.3 http://stackoverflow.com/questions/1468596/calculating-elapsed-time-in-a-c-program-in-milliseconds
#include <sys/time.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>

/* Return 1 if the difference is negative, otherwise 0.  */
int timeval_subtract(struct timeval *result, struct timeval *t2, struct timeval *t1)
{
    long int diff = (t2->tv_usec + 1000000 * t2->tv_sec) - (t1->tv_usec + 1000000 * t1->tv_sec);
    result->tv_sec = diff / 1000000;
    result->tv_usec = diff % 1000000;

    return (diff<0);
}

void timeval_print(struct timeval *tv)
{
    char buffer[30];
    time_t curtime;

    printf("%ld.%06ld", tv->tv_sec, tv->tv_usec);
    curtime = tv->tv_sec;
    strftime(buffer, 30, "%m-%d-%Y  %T", localtime(&curtime));
    printf(" = %s.%06ld\n", buffer, tv->tv_usec);
}

int main()
{
    struct timeval tvBegin, tvEnd, tvDiff;

    // begin
    gettimeofday(&tvBegin, NULL);
    timeval_print(&tvBegin);

    // lengthy operation
    int i,j;
    for(i=0;i<999999L;++i) {
    	j=sqrt(i);
    }

    //end
    gettimeofday(&tvEnd, NULL);
    timeval_print(&tvEnd);

    // diff
    timeval_subtract(&tvDiff, &tvEnd, &tvBegin);
    printf("%ld.%06ld\n", tvDiff.tv_sec, tvDiff.tv_usec);

    return 0;
}

		2.1.4
3. Best books to learn C from
What are the best books I can learn C from?

If you wish to learn C, the classic text - the "Bible" - is "The C Programming Language", 2nd Edition, by Brian Kernighan and Dennis Ritchie. This hallowed text describes and explains ANSI C. K& R2 is renowned for its brevity, clarity, elegance and completeness; but these very factors can make it heavy going for the beginner. http://cm.bell-labs.com/cm/cs/cbook/

K N King's "C Programming: A Modern Approach" is another text frequently recommended on comp.lang.c. This book is a good, thorough introduction to C that is a lot easier to work with from a beginner's perspective. http://knking.com/books/c/

Another frequently recommended book on C is "C - How to Program", 2nd Edition, by H M Deitel and P J Deitel. Please note that I have not had a chance to read this book, and include the reference on the strength of the the recommendation of a number of regular posters to comp.lang.c. http://www.deitel.com/products_and_services/publications/chtp2.htm

4.  Language Popular rankings

	4.1  http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html


5. Process control

	5.1  YoLinux Tutorial: Fork, Exec and Process control
fork():

The fork() system call will spawn a new child process which is an identical process to the parent except that has a new system process ID. The process is copied in memory from the parent and a new process structure is assigned by the kernel. The return value of the function is which discriminates the two threads of execution. A zero is returned by the fork function in the child's process.

The environment, resource limits, umask, controlling terminal, current working directory, root directory, signal masks and other process resources are also duplicated from the parent in the forked child process.

Example:

    #include <iostream>
    #include <string>
     
    // Required by for routine
    #include <sys/types.h>
    #include <unistd.h>
     
    #include <stdlib.h>   // Declaration for exit()
     
    using namespace std;
     
    int globalVariable = 2;
     
    main()
    {
       string sIdentifier;
       int    iStackVariable = 20;
     
       pid_t pID = fork();
       if (pID == 0)                // child
       {
          // Code only executed by child process
     
          sIdentifier = "Child Process: ";
          globalVariable++;
          iStackVariable++;
        }
        else if (pID < 0)            // failed to fork
        {
            cerr << "Failed to fork" << endl;
            exit(1);
            // Throw exception
        }
        else                                   // parent
        {
          // Code only executed by parent process
     
          sIdentifier = "Parent Process:";
        }
     
        // Code executed by both parent and child.
       
        cout << sIdentifier;
        cout << " Global variable: " << globalVariable;
        cout << " Stack variable: "  << iStackVariable << endl;
    }

    Compile: g++ -o ForkTest ForkTest.cpp
    Run: ForkTest

    Parent Process: Global variable: 2 Stack variable: 20
    Child Process:  Global variable: 3 Stack variable: 21

[Potential Pitfall]: Some memory duplicated by a forked process such as file pointers, will cause intermixed output from both processes. Use the wait() function so that the processes do not access the file at the same time or open unique file descriptors. Some like stdout or stderr will be shared unless synchronized using wait() or some other mechanism. The file close on exit is another gotcha. A terminating process will close files before exiting. File locks set by the parent process are not inherited by the child process.

[Potential Pitfall]: Race conditions can be created due to the unpredictability of when the kernel scheduler runs portions or time slices of the process. One can use wait(). the use of sleep() does not guarentee reliability of execution on a heavily loaded system as the scheduler behavior is not predictable by the application.

Note on exit() vs _exit(): The C library function exit() calls the kernel system call _exit() internally. The kernel system call _exit() will cause the kernel to close descriptors, free memory, and perform the kernel terminating process clean-up. The C library function exit() call will flush I/O buffers and perform aditional clean-up before calling _exit() internally. The function exit(status) causes the executable to return "status" as the return code for main(). When exit(status) is called by a child process, it allows the parent process to examine the terminating status of the child (if it terminates first). Without this call (or a call from main() to return()) and specifying the status argument, the process will not return a value.

    #include <stdlib.h>

    void exit(int status);
                    

    	

    #include <unistd.h>

    void _exit(int status);
                    

Man Pages:

    * fork - create a child process

vfork():

The vfork() function is the same as fork() except that it does not make a copy of the address space. The memory is shared reducing the overhead of spawning a new process with a unique copy of all the memory. This is typically used when using fork() to exec() a process and terminate. The vfork() function also executes the child process first and resumes the parent process when the child terminates.

    #include <iostream>
    #include <string>
     
    // Required by for routine
    #include <sys/types.h>
    #include <unistd.h>
     
    using namespace std;
     
     
    int globalVariable = 2;
     
    main()
    {
       string sIdentifier;
       int    iStackVariable = 20;
     
       pid_t pID = vfork();
       if (pID == 0)                // child
       {
          // Code only executed by child process
     
          sIdentifier = "Child Process: ";
          globalVariable++;
          iStackVariable++;
          cout << sIdentifier;
          cout << " Global variable: " << globalVariable;
          cout << " Stack variable: "  << iStackVariable << endl;
          _exit(0);
        }
        else if (pID < 0)            // failed to fork
        {
            cerr << "Failed to fork" << endl;
            exit(1);
            // Throw exception
        }
        else                                   // parent
        {
          // Code only executed by parent process
     
          sIdentifier = "Parent Process:";
        }
     
        // executed only by parent
     
        cout << sIdentifier;
        cout << " Global variable: " << globalVariable;
        cout << " Stack variable: "  << iStackVariable << endl;
        exit(0);
    }

    Compile: g++ -o VForkTest VForkTest.cpp
    Run: VForkTest

    Child Process:  Global variable: 3 Stack variable: 21
    Parent Process: Global variable: 3 Stack variable: 21
                    

Note: The child process executed first, updated the variables which are shared between the processes and NOT unique, and then the parent process executes using variables which the child has updated.

[Potential Pitfall]: A deadlock condition may occur if the child process does not terminate, the parent process will not proceed.

Man Pages:

    * vfork - create a child process and block parent
    * _exit - - terminate the current process

clone():

The function clone() creates a new child process which shares memory, file descriptors and signal handlers with the parent. It implements threads and thus launches a function as a child. The child terminates when the parent terminates.
See the YoLinux POSIX threads tutorial

Man Pages:

    * clone - create a child process

wait():

The parent process will often want to wait until all child processes have been completed. this can be implemented with the wait() function call.

wait(): Blocks calling process until the child process terminates. If child process has already teminated, the wait() call returns immediately. if the calling process has multiple child processes, the function returns when one returns.

waitpid(): Options available to block calling process for a particular child process not the first one.

    Code snipet:
    #include <sys/wait.h>
     
    ...
     
          pid_t pID = <i>set to child process id with call to fork OR:</i>
                      // If set <-1, wait for any child process whose process group ID = abs(pID)
                      // If = -1, wait  for  any child process. Same as wait().
                      // If =  0, wait for any child process whose process group ID is same as calling process.
                      // If >  0, wait for the child whose process ID = pID.
     
    ...
          int childExitStatus;
     
          pid_t ws = waitpid( pID, &childExitStatus, WNOHANG);
     
          if( WIFEXITED(childExitStatus) )
          {
             // Child process exited thus exec failed.
             // LOG failure of exec in child process.
             cout << "Result of waitpid: Child process exited thus exec failed." << endl;
          }
    OR
    ...
    int childExitStatus;
     
    pid_t ws = waitpid( pID, &childExitStatus, 0);
     
    if( !WIFEXITED(childExitStatus) )
    {
       cerr << "waitpid() exited with an error: Status= "
            << WEXITSTATUS(childExitStatus)
            << endl;
    }
    else if( WIFSIGNALED(childExitStatus) )
    {
       cerr << "waitpid() exited due to a signal: "
            << WTERMSIG(childExitStatus)
            << endl;
    }

Notes:

    * See man page for options: WNOHANG, WUNTRACED.
    * See man page for return macros: WIFEXITED(), WEXITSTATUS(), WIFSIGNALED(), WTERMSIG(), WIFSTOPPED(), WSTOPSIG().
    * See man page for errors: ECHILD, EINVAL, EINTR. (Also see sample of error processing below.)

Man Pages:

    * wait / waitpid - wait for process termination

Set system group ID and process ID:

Avoids orphaned process group when parent terminates. When parent dies, this will be a zombie. (No parent process. Parent=1) Instead, create a new process group for the child. Later process the group is terminated to stop all spawned processes. Thus all subsequent processes should be of this group if they are to be terminated by the process group id. Process group leader has the same process id and group process id. If not changed then the process group is that of the parent. Set the process group id to that of the child process.

    #include <sys/types.h>
    #include <unistd.h>
     
    #ifdef __gnu_linux__
          pid_t pgid = setpgid(child_pID, child_pID);
    #endif
     
          ...
          ...
     
          if( pgid < 0)
          {
            cout << "Failed to set process group ID" << endl;
            _exit(0);      // If exec fails then exit forked process.
          }
    Use the setgid call to set the group id of the current process. Requires root access.

    The macro testing for __gnu_linux__ is for cross platform support as man other OS's use a different system call.

Man Pages:

    * setpgid/getpgid setpgrp/getpgrp - set process group
    * setsid - creates a session and sets the process group ID
    * getuid/geteuid - get user identity
    * setgid - set group identity
    * getgid/getegid - get group (real/effective) identity
    * setreuid/setregid - set real user or group identity

Kill all processes in a process group:
This is the real reason to set up a process group. One may kill all the processes in the process group without having to keep track of how many processes have been forked and all of their process id's.

See /usr/include/bits/signum.h for list of signals.

    ...
     
    int  killReturn = killpg( pID, SIGKILL);  // Kill child process group
     
    if( killReturn == ESRCH)      // pid does not exist
    {
       cout << "Group does not exist!" << endl;
    }
    else if( killReturn == EPERM) // No permission to send signal
    {
       cout << "No permission to send signal!" << endl;
    }
    else
       cout << "Signal sent. All Ok!" << endl;
     
    ...

Man Pages:

    * killpg - send signal to a process group
    * kill - send signal to a process
    * signal (2) - ANSI C signal handling
    * signal (7) - List of available signals
    * sigaction - POSIX signal handling functions.
    * pause (2) - wait for signal
    * raise (3) - send a signal to a current process

system() and popen():

The system() call will execute an OS shell command as described by a character command string. This function is implemented using fork(), exec() and waitpid(). The command string is executed by calling /bin/sh -c command-string. During execution of the command, SIGCHLD will be blocked, and SIGINT and SIGQUIT will be ignored. The call "blocks" and waits for the task to be performed before continuing.

    #include <stdio.h>
    #include <stdlib.h>
    main()
    {
        system("ls -l");
        printf("Command done!");
    }
    The statement "Command done!" will not print untill the "ls -l" command has completed. 

The popen() call opens a process by creating a pipe, forking, and invoking the shell (bourne shell on Linux). The advantage to using popen() is that it will allow one to interrogate the results of the command issued.

This example opens a pipe which executes the shell command "ls -l". The results are read and printed out.

    #include <stdio.h>
    main()
    {
       FILE *fpipe;
       char *command="ls -l";
       char line[256];
     
       if ( !(fpipe = (FILE*)popen(command,"r")) )
       {  // If fpipe is NULL
          perror("Problems with pipe");
          exit(1);
       }
     
       while ( fgets( line, sizeof line, fpipe))
       {
         printf("%s", line);
       }
       pclose(fpipe);
    }

The second argument to popen:

    * r: Read from stdin (command results)
    * w: write to stdout (command)
    * For stderr: command="ls -l 2>&1","w");

Man Pages:

    * system - execute a shell command
    * popen - process I/O

exec() functions and execve():

The exec() family of functions will initiate a program from within a program. They are also various front-end functions to execve().

The functions return an integer error code. (0=Ok/-1=Fail).

execl() and execlp():
The function call "execl()" initiates a new program in the same environment in which it is operating. An executable (with fully qualified path. i.e. /bin/ls) and arguments are passed to the function. Note that "arg0" is the command/file name to execute.

int execl(const char *path, const char *arg0, const char *arg1, const char *arg2, ... const char *argn, (char *) 0);

    #include <unistd.h>
    main()
    {
       execl("/bin/ls", "/bin/ls", "-r", "-t", "-l", (char *) 0);
    }
    Where all function arguments are null terminated strings. The list of arguments is terminated by NULL. 

The routine execlp() will perform the same purpose except that it will use environment variable PATH to determine which executable to process. Thus a fully qualified path name would not have to be used. The first argument to the function could instead be "ls". The function execlp() can also take the fully qualified name as it also resolves explicitly.

Man Pages:

    * execl / execlp - execute

execv() and execvp():
This is the same as execl() except that the arguments are passed as null terminated array of pointers to char. The first element "argv[0]" is the command name.

int execv(const char *path, char *const argv[]);

    #include <unistd.h>
    main()
    {
       char *args[] = {"/bin/ls", "-r", "-t", "-l", (char *) 0 };
     
       execv("/bin/ls", args);
    }

The routine execvp() will perform the same purpose except that it will use environment variable PATH to determine which executable to process. Thus a fully qualified path name would not have to be used. The first argument to the function could instead be "ls". The function execvp() can also take the fully qualified name as it also resolves explicitly.

Man Pages:

    * execv / execvp - execute

execve():
The function call "execve()" executes a process in an environment which it assigns.

Set the environment variables:

Assignment:

       char *env[] = { "USER=user1", "PATH=/usr/bin:/bin:/opt/bin", (char *) 0 };
                    


OR

Read from file:

    #include <iostream>
    #include <fstream>
    #include <string>
    #include <vector>
     
    // Required by for routine
    #include <sys/types.h>
    #include <unistd.h>
     
    using namespace std;
     
    //   Class definition:
     
    class CReadEnvironmentVariablesFile
    {
     public:
        CReadEnvironmentVariablesFile() { m_NumberOfEnvironmentVariables=0; };
       ~CReadEnvironmentVariablesFile();
        char **ReadFile(string& envFile);
     private:
        int m_NumberOfEnvironmentVariables;
        char **m_envp;
    };
     
    //   Read environment variables:
     
    char **
    CReadEnvironmentVariablesFile::ReadFile(string& envFile)
    {
       int ii;
       string tmpStr;
       vector<string> vEnvironmentVariables;
     
       if( envFile.empty() ) return 0;
     
       ifstream inputFile( envFile.c_str(), ios::in);
       if( !inputFile )
       {
           cerr << "Could not open config file: " << envFile << endl;
           return 0;
       }
     
       while( !inputFile.eof() )
       {
           getline(inputFile, tmpStr);
           if( !tmpStr.empty() ) vEnvironmentVariables.push_back(tmpStr);
       }
     
       inputFile.close();
     
       m_NumberOfEnvironmentVariables = vEnvironmentVariables.size();
     
       // ---------------------------------------
       // Generate envp environment variable list
       // ---------------------------------------
     
       // Allocate pointers to strings.
       // +1 for array terminating NULL string
     
       m_envp = new char * [m_NumberOfEnvironmentVariables + 1];
     
       // Allocate arrays of character strings.
        
       for(ii=0; ii < m_NumberOfEnvironmentVariables; ii++)
       {
          // Character string terminated with a NULL character.
          m_envp[ii] = new char [vEnvironmentVariables[ii].size()+1];
          strcpy( m_envp[ii], vEnvironmentVariables[ii].c_str());
       }
     
       // must terminate array with null string
       m_envp[ii] = (char*) 0;
     
       return m_envp;
    }
     
    //   Free memory:
     
    CReadEnvironmentVariablesFile::~CReadEnvironmentVariablesFile()
    {
       int ii;
     
       // Free array's of characters
       for(ii=0; ii < m_NumberOfEnvironmentVariables; ii++)
       {
          delete [] m_envp[ii];
       }
     
       // Free array of pointers.
       delete [] m_envp;
    }

Call execve:

    string getErrMsg(int errnum);
     
    main()
    {
       string envFile("environment_variables.conf");
       CReadEnvironmentVariablesFile readEnvFile;
       char **Env_envp = readEnvFile.ReadFile(envFile);
     
       // Command to execute
       char *Env_argv[] = { "/bin/ls", "-l", "-a", (char *) 0 };
     
       pid_t pID = fork();
       if (pID == 0)                // child
       {
          // This version of exec accepts environment variables.
          // Function call does not return on success.
     
          int execReturn = execve (Env_argv[0], Env_argv, Env_envp);
     
          cout << "Failure! execve error code=" << execReturn << endl;
     
          cout << getErrMsg(execReturn) << endl;
     
          _exit(0); // If exec fails then exit forked process.
       }
       else if (pID < 0)             // failed to fork
       {
          cerr << "Failed to fork" << endl;
       }
       else                             // parent
       {
          cout << "Parent Process" << endl;
       }
    }

Handle errors:

    string getErrMsg(int errnum)
    {
     
        switch ( errnum ) {
     
    #ifdef EACCES
            case EACCES :
            {
                return "EACCES Permission denied";
            }
    #endif
     
    #ifdef EPERM
            case EPERM :
            {
                return "EPERM Not super-user";
            }
    #endif
     
    #ifdef E2BIG
            case E2BIG :
            {
                return "E2BIG Arg list too long";
            }
    #endif
     
    #ifdef ENOEXEC
            case ENOEXEC :
            {
                return "ENOEXEC Exec format error";
            }
    #endif
     
    #ifdef EFAULT
            case EFAULT :
            {
                return "EFAULT Bad address";
            }
    #endif
     
    #ifdef ENAMETOOLONG
            case ENAMETOOLONG :
            {
                return "ENAMETOOLONG path name is too long     ";
            }
    #endif
     
    #ifdef ENOENT
            case ENOENT :
            {
                return "ENOENT No such file or directory";
            }
    #endif
     
    #ifdef ENOMEM
            case ENOMEM :
            {
                return "ENOMEM Not enough core";
            }
    #endif
     
    #ifdef ENOTDIR
            case ENOTDIR :
            {
                return "ENOTDIR Not a directory";
            }
    #endif
     
    #ifdef ELOOP
            case ELOOP :
            {
                return "ELOOP Too many symbolic links";
            }
    #endif
     
    #ifdef ETXTBSY
            case ETXTBSY :
            {
                return "ETXTBSY Text file busy";
            }
    #endif
     
    #ifdef EIO
            case EIO :
            {
                return "EIO I/O error";
            }
    #endif
     
    #ifdef ENFILE
            case ENFILE :
            {
                return "ENFILE Too many open files in system";
            }
    #endif
     
    #ifdef EINVAL
            case EINVAL :
            {
                return "EINVAL Invalid argument";
            }
    #endif
     
    #ifdef EISDIR
            case EISDIR :
            {
                return "EISDIR Is a directory";
            }
    #endif
     
    #ifdef ELIBBAD
            case ELIBBAD :
            {
                return "ELIBBAD Accessing a corrupted shared lib";
            }
    #endif
             
            default :
            {
                std::string errorMsg(strerror(errnum));
                if ( errnum ) return errorMsg;
            }
         }
    }

Man Pages:

    * strerror / strerror_r - return string describing error code
    * errno - number of last error
    * perror - print a system error message

Data File: environment_variables.conf

    PATH=/usr/bin:/bin
    MANPATH=/opt/man
    LANG=C
    DISPLAY=:0.0

Man Pages:

    * execve - execute with given environment

Note: Don't mix malloc() and new. Choose one form of memory allocation and stick with it.

Malloc:

    ..
    ...
     
       int ii;
     
       m_envp = (char **) calloc((m_NumberOfEnvironmentVariables+1), sizeof(char **));
     
    ...
       // Allocate arrays of character strings.
       int ii;
       for(ii=0; ii < NumberOfEnvironmentVariables; ii++)
       {
          // NULL terminated
          m_envp[ii] = (char *) malloc(vEnvironmentVariables[ii].size()+1);
          strcpy( m_envp[ii], vEnvironmentVariables[ii].c_str());
       }
     
       // must terminate with null
       m_envp[ii] = (char*) 0;
     
       return m_envp;
    }
    ...

Free:

    ...
     
    // Free array's of characters
     
    for(ii=0; ii < m_NumberOfEnvironmentVariables; ii++)
    {
       free(m_envp[ii]);
    }
     
    // Free array of pointers.
     
    free(m_envp);
     
    ...

	5.2 WAIT(2) Linux Programmer's Manual		       



NAME
       wait, waitpid, waitid - wait for process to change state

SYNOPSIS
       #include <sys/types.h>
       #include <sys/wait.h>

       pid_t wait(int *status);

       pid_t waitpid(pid_t pid, int *status, int options);

       int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       waitid(): _SVID_SOURCE || _XOPEN_SOURCE

DESCRIPTION
       All of these system calls are used to wait for state changes in a child
       of the calling process, and obtain information about  the  child  whose
       state  has changed.  A state change is considered to be: the child ter-
       minated; the child was stopped by a signal; or the child was resumed by
       a  signal.  In the case of a terminated child, performing a wait allows
       the system to release the resources associated with  the  child;  if  a
       wait  is not performed, then terminated the child remains in a "zombie"
       state (see NOTES below).

       If a child has already changed state, then these calls  return  immedi-
       ately.	Otherwise  they  block until either a child changes state or a
       signal handler interrupts the call (assuming that system calls are  not
       automatically restarted using the SA_RESTART flag of sigaction(2)).  In
       the remainder of this page, a child whose state has changed  and  which
       has  not  yet  been  waited upon by one of these system calls is termed
       waitable.

   wait() and waitpid()
       The wait() system call suspends execution of the calling process  until
       one  of	its children terminates.  The call wait(&status) is equivalent
       to:

	   waitpid(-1, &status, 0);

       The waitpid() system call suspends execution  of  the  calling  process
       until a child specified by pid argument has changed state.  By default,
       waitpid() waits only for terminated children, but this behavior is mod-
       ifiable via the options argument, as described below.

       The value of pid can be:

       < -1   meaning  wait  for  any  child process whose process group ID is
	      equal to the absolute value of pid.

       -1     meaning wait for any child process.

       0      meaning wait for any child process whose	process  group	ID  is
	      equal to that of the calling process.

       > 0    meaning  wait  for  the  child  whose process ID is equal to the
	      value of pid.

       The value of options is an OR of zero or more  of  the  following  con-
       stants:

       WNOHANG	   return immediately if no child has exited.

       WUNTRACED   also  return  if  a	child  has stopped (but not traced via
		   ptrace(2)).	Status for traced children which have  stopped
		   is provided even if this option is not specified.

       WCONTINUED  (Since  Linux  2.6.10)  also  return if a stopped child has
		   been resumed by delivery of SIGCONT.

       (For Linux-only options, see below.)

       The  WUNTRACED  and  WCONTINUED	options  are  only  effective  if  the
       SA_NOCLDSTOP  flag  has not been set for the SIGCHLD signal (see sigac-
       tion(2)).

       If status is not NULL, wait() and waitpid() store status information in
       the  int  to  which  it points.	This integer can be inspected with the
       following macros (which take the integer itself as an argument,	not  a
       pointer to it, as is done in wait() and waitpid()!):

       WIFEXITED(status)
	      returns true if the child terminated normally, that is, by call-
	      ing exit(3) or _exit(2), or by returning from main().

       WEXITSTATUS(status)
	      returns the exit status of the  child.   This  consists  of  the
	      least  significant  8 bits of the status argument that the child
	      specified in a call to exit(3) or _exit(2) or  as  the  argument
	      for  a  return  statement  in main().  This macro should only be
	      employed if WIFEXITED returned true.

       WIFSIGNALED(status)
	      returns true if the child process was terminated by a signal.

       WTERMSIG(status)
	      returns the number of the signal that caused the	child  process
	      to terminate.  This macro should only be employed if WIFSIGNALED
	      returned true.

       WCOREDUMP(status)
	      returns true if the child produced  a  core  dump.   This  macro
	      should  only  be	employed  if  WIFSIGNALED returned true.  This
	      macro is not specified in POSIX.1-2001 and is not  available  on
	      some  Unix  implementations  (e.g.,  AIX, SunOS).  Only use this
	      enclosed in #ifdef WCOREDUMP ... #endif.

       WIFSTOPPED(status)
	      returns true if the child process was stopped by delivery  of  a
	      signal;  this  is  only possible if the call was done using WUN-
	      TRACED or when the child is being traced (see ptrace(2)).

       WSTOPSIG(status)
	      returns the number of the signal which caused the child to stop.
	      This  macro should only be employed if WIFSTOPPED returned true.

       WIFCONTINUED(status)
	      (Since Linux 2.6.10) returns  true  if  the  child  process  was
	      resumed by delivery of SIGCONT.

   waitid()
       The  waitid()  system  call (available since Linux 2.6.9) provides more
       precise control over which child state changes to wait for.

       The idtype and id arguments select the child(ren) to wait for, as  fol-
       lows:

       idtype == P_PID
	      Wait for the child whose process ID matches id.

       idtype == P_PGID
	      Wait for any child whose process group ID matches id.

       idtype == P_ALL
	      Wait for any child; id is ignored.

       The  child state changes to wait for are specified by ORing one or more
       of the following flags in options:

       WEXITED	   Wait for children that have terminated.

       WSTOPPED    Wait for children that have been stopped by delivery  of  a
		   signal.

       WCONTINUED  Wait  for  (previously  stopped)  children  that  have been
		   resumed by delivery of SIGCONT.

       The following flags may additionally be ORed in options:

       WNOHANG	   As for waitpid().

       WNOWAIT	   Leave the child in a waitable state; a later wait call  can
		   be used to again retrieve the child status information.

       Upon  successful  return, waitid() fills in the following fields of the
       siginfo_t structure pointed to by infop:

       si_pid	   The process ID of the child.

       si_uid	   The real user ID of the child.  (This field is not  set  on
		   most other implementations.)

       si_signo    Always set to SIGCHLD.

       si_status   Either  the	exit status of the child, as given to _exit(2)
		   (or exit(3)), or the signal that caused the child to termi-
		   nate,  stop, or continue.  The si_code field can be used to
		   determine how to interpret this field.

       si_code	   Set	to  one  of:  CLD_EXITED  (child   called   _exit(2));
		   CLD_KILLED  (child  killed  by  signal); CLD_STOPPED (child
		   stopped by signal); or CLD_CONTINUED  (child  continued  by
		   SIGCONT).

       If  WNOHANG  was  specified  in options and there were no children in a
       waitable state, then waitid() returns 0 immediately and	the  state  of
       the siginfo_t structure pointed to by infop is unspecified.  To distin-
       guish this case from that where a child was in a waitable  state,  zero
       out  the  si_pid field before the call and check for a nonzero value in
       this field after the call returns.

RETURN VALUE
       wait(): on success, returns the process ID of the terminated child;  on
       error, -1 is returned.

       waitpid():  on success, returns the process ID of the child whose state
       has changed; if WNOHANG was specified and one or more child(ren) speci-
       fied  by pid exist, but have not yet changed state, then 0 is returned.
       On error, -1 is returned.

       waitid(): returns 0 on success or  if  WNOHANG  was  specified  and  no
       child(ren)  specified  by  id  has  yet	changed state; on error, -1 is
       returned.

       Each of these calls sets errno to an appropriate value in the  case  of
       an error.

ERRORS
       ECHILD (for  wait()) The calling process does not have any unwaited-for
	      children.

       ECHILD (for waitpid() or waitid()) The process specified by pid	(wait-
	      pid())  or  idtype  and id (waitid()) does not exist or is not a
	      child of the calling process.  (This can happen  for  one's  own
	      child if the action for SIGCHLD is set to SIG_IGN.  See also the
	      Linux Notes section about threads.)

       EINTR  WNOHANG was not set and an unblocked signal  or  a  SIGCHLD  was
	      caught.

       EINVAL The options argument was invalid.

CONFORMING TO
       SVr4, 4.3BSD, POSIX.1-2001.

NOTES
       A  child  that  terminates, but has not been waited for becomes a "zom-
       bie".  The kernel maintains a minimal set of information about the zom-
       bie  process  (PID,  termination status, resource usage information) in
       order to allow the parent to later perform a wait to obtain information
       about  the  child.   As long as a zombie is not removed from the system
       via a wait, it will consume a slot in the kernel process table, and  if
       this  table fills, it will not be possible to create further processes.
       If a parent process terminates, then its "zombie" children (if any) are
       adopted	by  init(8), which automatically performs a wait to remove the
       zombies.

       POSIX.1-2001 specifies that if the disposition of  SIGCHLD  is  set  to
       SIG_IGN or the SA_NOCLDWAIT flag is set for SIGCHLD (see sigaction(2)),
       then children that terminate do not become zombies and a call to wait()
       or  waitpid()  will  block until all children have terminated, and then
       fail with errno set to ECHILD.  (The original POSIX standard  left  the
       behavior  of  setting  SIGCHLD to SIG_IGN unspecified.)	Linux 2.6 con-
       forms to this specification.  However, Linux  2.4  (and	earlier)  does
       not:  if  a  wait()  or	waitpid()  call is made while SIGCHLD is being
       ignored, the call  behaves  just  as  though  SIGCHLD  were  not  being
       ignored,  that  is, the call blocks until the next child terminates and
       then returns the process ID and status of that child.

   Linux Notes
       In the Linux kernel, a kernel-scheduled thread is not a	distinct  con-
       struct  from  a process.  Instead, a thread is simply a process that is
       created using the Linux-unique clone(2)	system	call;  other  routines
       such  as  the  portable	pthread_create(3)  call  are implemented using
       clone(2).  Before Linux 2.4, a thread was just a special case of a pro-
       cess, and as a consequence one thread could not wait on the children of
       another thread, even when the latter belongs to the same thread	group.
       However,  POSIX	prescribes  such  functionality, and since Linux 2.4 a
       thread can, and by default will, wait on children of other  threads  in
       the same thread group.

       The  following Linux-specific options are for use with children created
       using clone(2); they cannot be used with waitid():

       __WCLONE
	      Wait for "clone" children only.  If omitted then wait for  "non-
	      clone" children only.  (A "clone" child is one which delivers no
	      signal, or a signal  other  than	SIGCHLD  to  its  parent  upon
	      termination.)   This  option is ignored if __WALL is also speci-
	      fied.

       __WALL (Since Linux 2.4) Wait for  all  children,  regardless  of  type
	      ("clone" or "non-clone").

       __WNOTHREAD
	      (Since  Linux  2.4) Do not wait for children of other threads in
	      the same thread group.  This was the default before Linux 2.4.

EXAMPLE
       The following program demonstrates the use of  fork(2)  and  waitpid().
       The  program  creates  a child process.	If no command-line argument is
       supplied to the program, then the child suspends  its  execution  using
       pause(2),  to  allow the user to send signals to the child.  Otherwise,
       if a command-line argument is supplied, then the  child	exits  immedi-
       ately,  using the integer supplied on the command line as the exit sta-
       tus.  The parent process executes a loop that monitors the child  using
       waitpid(), and uses the W*() macros described above to analyze the wait
       status value.

       The following shell session demonstrates the use of the program:

       $ ./a.out &
       Child PID is 32360
       [1] 32359
       $ kill -STOP 32360
       stopped by signal 19
       $ kill -CONT 32360
       continued
       $ kill -TERM 32360
       killed by signal 15
       [1]+  Done		     ./a.out
       $

       #include <sys/wait.h>
       #include <stdlib.h>
       #include <unistd.h>
       #include <stdio.h>

       int
       main(int argc, char *argv[])
       {
	   pid_t cpid, w;
	   int status;

	   cpid = fork();
	   if (cpid == -1) {
	       perror("fork");
	       exit(EXIT_FAILURE);
	   }

	   if (cpid == 0) {	       /* Code executed by child */
	       printf("Child PID is %ld\n", (long) getpid());
	       if (argc == 1)
		   pause();		       /* Wait for signals */
	       _exit(atoi(argv[1]));

	   } else {		       /* Code executed by parent */
	       do {
		   w = waitpid(cpid, &status, WUNTRACED | WCONTINUED);
		   if (w == -1) {
		       perror("waitpid");
		       exit(EXIT_FAILURE);
		   }

		   if (WIFEXITED(status)) {
		       printf("exited, status=%d\n", WEXITSTATUS(status));
		   } else if (WIFSIGNALED(status)) {
		       printf("killed by signal %d\n", WTERMSIG(status));
		   } else if (WIFSTOPPED(status)) {
		       printf("stopped by signal %d\n", WSTOPSIG(status));
		   } else if (WIFCONTINUED(status)) {
		       printf("continued\n");
		   }
	       } while (!WIFEXITED(status) && !WIFSIGNALED(status));
	       exit(EXIT_SUCCESS);
	   }
       }

SEE ALSO
       _exit(2), clone(2), fork(2),  kill(2),  ptrace(2),  sigaction(2),  sig-
       nal(2), wait4(2), pthread_create(3), credentials(7), signal(7)

COLOPHON
       This  page  is  part of release 2.77 of the Linux man-pages project.  A
       description of the project, and information about reporting  bugs,  can
       be found at http://www.kernel.org/doc/man-pages/.



6.  Signal handling

	6.1  signalfd
		6.1.1   Linux man page


signalfd - create a file descriptor for accepting signals
Synopsis

#include <sys/signalfd.h>

int signalfd(int fd, const sigset_t *mask, int flags);
Description

signalfd() creates a file descriptor that can be used to accept signals targeted at the caller. This provides an alternative to the use of a signal handler or sigwaitinfo(2), and has the advantage that the file descriptor may be monitored by select(2), poll(2), and epoll(7). The mask argument specifies the set of signals that the caller wishes to accept via the file descriptor. This argument is a signal set whose contents can be initialized using the macros described in sigsetops(3). Normally, the set of signals to be received via the file descriptor should be blocked using sigprocmask(2), to prevent the signals being handled according to their default dispositions. It is not possible to receive SIGKILL or SIGSTOP signals via a signalfd file descriptor; these signals are silently ignored if specified in mask.

If the fd argument is -1, then the call creates a new file descriptor and associates the signal set specified in mask with that descriptor. If fd is not -1, then it must specify a valid existing signalfd file descriptor, and mask is used to replace the signal set associated with that descriptor.

The flags argument is currently unused, and must be specified as zero. In the future, it may be used to request additional functionality.

signalfd() returns a file descriptor that supports the following operations:

read(2)
    If one or more of the signals specified in mask is pending for the process, then the buffer supplied to read(2) is used to return one or more signalfd_siginfo structures (see below) that describe the signals. The read(2) returns information for as many signals as are pending and will fit in the supplied buffer. The buffer must be at least sizeof(struct signalfd_siginfo) bytes. The return value of the read(2) is the total number of bytes read. 
    As a consequence of the read(2), the signals are consumed, so that they are no longer pending for the process (i.e., will not be caught by signal handlers, and cannot be accepted using sigwaitinfo(2)).

    If none of the signals in mask is pending for the process, then the read(2) either blocks until one of the signals in mask is generated for the process, or fails with the error EAGAIN if the file descriptor has been made non-blocking (via the use of the fcntl(2) F_SETFL operation to set the O_NONBLOCK flag). 
poll(2), select(2) (and similar)
    The file descriptor is readable (the select(2) readfds argument; the poll(2) POLLIN flag) if one or more of the signals in mask is pending for the process. 
    The signalfd file descriptor also supports the other file-descriptor multiplexing APIs: pselect(2), ppoll(2), and epoll(7). 
close(2)
    When the file descriptor is no longer required it should be closed. When all file descriptors associated with the same signalfd object have been closed, the resources for object are freed by the kernel. 

The signalfd_siginfo structure

The format of the signalfd_siginfo structure(s) returned by read(2)s from a signalfd file descriptor is as follows:

    struct signalfd_siginfo {/
        uint32_t  ssi_signo;
        int32_t   ssi_errno;
        int32_t   ssi_code;
        uint32_t  ssi_pid;
        uint32_t  ssi_uid;
        int32_t   ssi_fd;
        uint32_t  ssi_tid;
        uint32_t  ssi_band;
        uint32_t  ssi_overrun;
        uint32_t  ssi_trapno;
        int32_t   ssi_status;
        int32_t   ssi_int;
        uintptr_t ssi_ptr;
        uint64_t  ssi_utime;
        uint64_t  ssi_stime;
        uint64_t  ssi_addr;
        uint8_t   pad[X];  /* Pad size to 128 bytes (allow space
                              additional fields in the future) */
    };

Each of the fields in this structure is analogous to the similarly named field in the siginfo_t structure. The siginfo_t structure is described in sigaction(2). Not all fields in the returned signalfd_siginfo structure will be valid for a specific signal; the set of valid fields can be determined from the value returned in the ssi_code field. This field is the analog of the siginfo_t si_code field; see sigaction(2) for details.

fork(2) semantics

After a fork(2), the child inherits a copy of the signalfd file descriptor. The file descriptor refers to the same underlying file object as the corresponding descriptor in the parent, and read(2)s in the child will return information about signals generated for the parent (the process that created the object using signalfd().

execve(2) semantics

Just like any other file descriptor, a signalfd file descriptor remains open across an execve(2), unless it has been marked for close-on-exec (see fcntl(2)). Any signals that were available for reading before the execve(2) remain available to the newly loaded program. (This is analogous to traditional signal semantics, where a blocked signal that is pending remains pending across an execve(2).) (This is analogous to traditional signal semantics, where a blocked signal that is pending remains pending across an execve(2).)

Thread semantics

The semantics of signalfd file descriptors in a multithreaded program mirror the standard semantics for signals. In other words, when a thread reads from a signalfd file descriptor, it will read the signals that are directed to the thread itself and the signals that are directed to the process (i.e., the entire thread group). (A thread will not be able to read signals that are directed to other threads in the process.)

Return Value

On success, signalfd() returns a signalfd file descriptor; this is either a new file descriptor (if fd was -1), or fd if fd was a valid signalfd file descriptor. On error, -1 is returned and errno is set to indicate the error.
Errors

EBADF

The fd file descriptor is not a valid file descriptor.

EINVAL

fd is not a valid signalfd file descriptor; or, flags is nonzero.

EMFILE

The per-process limit of open file descriptors has been reached.

ENFILE

The system-wide limit on the total number of open files has been reached.

ENODEV

Could not mount (internal) anonymous inode device.

ENOMEM

There was insufficient memory to create a new signalfd file descriptor.

Versions

signalfd() is available on Linux since kernel 2.6.22. Working support is provided in glibc since version 2.8.
Conforming To

signalfd() is Linux-specific.
Notes

The underlying Linux system call requires an additional argument, size_t sizemask, which specifies the size of the mask argument. The glibc signalfd() wrapper function does not include this argument, since it provides the required value for the underlying system call.

The flags argument is a glibc addition to the underlying system call.

A process can create multiple signalfd file descriptors. This makes it possible to accept different signals on different file descriptors. (This may be useful if monitoring the file descriptors using select(2), poll(2), or epoll(7): the arrival of different signals will make different descriptors ready.) If a signal appears in the mask of more than one of the file descriptors, then occurrences of that signal can be read (once) from any one of the descriptors.
Example

The program below accepts the signals SIGINT and SIGQUIT via a signalfd file descriptor. The program terminates after accepting a SIGQUIT signal. The following shell session demonstrates the use of the program:

    $ ./signalfd_demo
    ^C                    # Control-C generates SIGINT
    Got SIGINT
    ^C
    Got SIGINT
    ^\                    # Control-\ generates SIGQUIT
    Got SIGQUIT
    $

#include <sys/signalfd.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

#define handle_error(msg) \
    do { perror(msg); exit(EXIT_FAILURE); } while (0)

int
main(int argc, char *argv[])
{
    sigset_t mask;
    int sfd;
    struct signalfd_siginfo fdsi;
    ssize_t s;

   sigemptyset(&mask);
    sigaddset(&mask, SIGINT);
    sigaddset(&mask, SIGQUIT);

   /* Block signals so that they aren't handled
       according to their default dispositions */

   if (sigprocmask(SIG_BLOCK, &mask, NULL) == -1)
        handle_error("sigprocmask");

   sfd = signalfd(-1, &mask, 0);
    if (sfd == -1)
        handle_error("signalfd");

   for (;;) {
        s = read(sfd, &fdsi, sizeof(struct signalfd_siginfo));
        if (s != sizeof(struct signalfd_siginfo))
            handle_error("read");

       if (fdsi.signo == SIGINT) {
            printf("Got SIGINT\n");
        } else if (fdsi.signo == SIGQUIT) {
            printf("Got SIGQUIT\n");
            exit(EXIT_SUCCESS);
        } else {
            printf("Read unexpected signal\n");
        }
    }
}

See Also

eventfd(2), poll(2), read(2), select(2), sigaction(2), sigprocmask(2), sigwaitinfo(2), timerfd_create(2), sigsetops(3), epoll(7), signal(7)
Colophon

This page is part of release 2.78 of the Linux man-pages project. A description of the project, and information about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.
die.net

    site search Google Custom Search

Library
    online dictionary
    linux docs
    linux man pages
    page load time

Toys
    world sunlight
    moon phase
    trace explorer


		6.1.2 Code examples

			6.1.2.1 Waiting for a signal with timeout using sigtimedwait()
Submitted by daper on Tue, 02/03/2009 - 00:28

/* The program creates a child process and waits for it to finish. If a timeout
 * elapses the child is killed. Waiting is done using sigtimedwait(). Race
 * condition is avoided by blocking the SIGCHLD signal before fork().
 */
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
 
static pid_t fork_child (void)
{
	int p = fork ();
 
	if (p == -1) {
		perror ("fork");
		exit (1);
	}
 
	if (p == 0) {
		puts ("child: sleeping...");
		sleep (10);
		puts ("child: exiting");
		exit (0);
	}
 
	return p;
}
 
int main (int argc, char *argv[])
{
	sigset_t mask;
	sigset_t orig_mask;
	struct timespec timeout;
	pid_t pid;
 
	sigemptyset (&mask);
	sigaddset (&mask, SIGCHLD);
 
	if (sigprocmask(SIG_BLOCK, &mask, &orig_mask) < 0) {
		perror ("sigprocmask");
		return 1;
	}
 
	pid = fork_child ();
 
	timeout.tv_sec = 5;
	timeout.tv_nsec = 0;
 
	do {
		if (sigtimedwait(&mask, NULL, &timeout) < 0) {
			if (errno == EINTR) {
				/* Interrupted by a signal other than SIGCHLD. */
				continue;
			}
			else if (errno == EAGAIN) {
				printf ("Timeout, killing child\n");
				kill (pid, SIGKILL);
			}
			else {
				perror ("sigtimedwait");
				return 1;
			}
		}
 
		break;
	} while (1);
 
	if (waitpid(pid, NULL, 0) < 0) {
		perror ("waitpid");
		return 1;
	}
 
	return 0;
}


			6.1.2.2 Blocking signals with sigprocmask()
Submitted by daper on Tue, 02/03/2009 - 00:21

/** This program blocks SIGTERM signal for 10 seconds using sigprocmask(2)
 * After that the signal is unblocked and the queued signal is handled.
 */
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
 
static int got_signal = 0;
 
static void hdl (int sig)
{
	got_signal = 1;
}
 
int main (int argc, char *argv[])
{
	sigset_t mask;
	sigset_t orig_mask;
	struct sigaction act;
 
	memset (&act, 0, sizeof(act));
	act.sa_handler = hdl;
 
	if (sigaction(SIGTERM, &act, 0)) {
		perror ("sigaction");
		return 1;
	}
 
	sigemptyset (&mask);
	sigaddset (&mask, SIGTERM);
 
	if (sigprocmask(SIG_BLOCK, &mask, &orig_mask) < 0) {
		perror ("sigprocmask");
		return 1;
	}
 
	sleep (10);
 
	if (sigprocmask(SIG_SETMASK, &orig_mask, NULL) < 0) {
		perror ("sigprocmask");
		return 1;
	}
 
	sleep (1);
 
	if (got_signal)
		puts ("Got signal");
 
	return 0;
}

			6.1.2.3 Handling interruption of system calls by signals
Submitted by daper on Tue, 02/03/2009 - 00:12

/** Example of handling cases when system calls are interrupted by
 * a signal. This program copies its standard input to the standard output.
 * Here read() and write() may be interrupted. Additionally after receiving
 * a signal the program prints how much data it transfered so far.
 */
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
 
static volatile int print_stats = 0;
 
size_t total_read = 0;
size_t total_write = 0;
 
static void hdl (int sig)
{
	print_stats = 1;
}
 
static void do_print_stats (void)
{
	if (print_stats) {
		print_stats = 0;
		fprintf (stderr, "Read: %zd, Write: %zd\n", total_read, total_write);
	}
}
 
int main (int argc, char *argv[])
{
	ssize_t nread;
	ssize_t nwrite;
	struct sigaction act;
 
	memset (&act, 0, sizeof(act));
 
	act.sa_handler = hdl;
 
	if (sigaction(SIGUSR1, &act, NULL) < 0) {
		perror ("sigaction");
		return 1;
	}
 
	do {
		char buf[512];
 
		nread = read (0, buf, sizeof(buf));
		if (nread < 0) {
			if (errno != EINTR) {
				perror ("read");
				return 1;
			}
 
			/* We are here because the read() call was interrupted before
			 * anything was read. */
 
			do_print_stats ();
		}
		else if (nread == 0)
			break;
		else {
			ssize_t written = 0;
			total_read += nread;
 
			while (written < nread) {
				nwrite = write (1, buf + written, nread - written);
				if (nwrite < 0) {
					if (errno != EINTR) {
						perror ("write");
						return 1;
					}
 
					/* We are here because write() call was interrupted
					 * before anything could be written. */
 
				}
				else {
					written += nwrite;
					total_write += nwrite;
				}
 
				do_print_stats ();
			}
		}
 
	} while (1);
 
	return 0;
}


			6.1.2.4 Example of using signalfd()
Submitted by daper on Mon, 02/02/2009 - 18:32

/* Example of use of a Linux-specific call - signalfd() to handle signals using
 * a file descriptor.
 */
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <sys/signalfd.h>
#include <string.h>
 
int main (int argc, char *argv[])
{
	int sfd;
	sigset_t mask;
 
	/* We will handle SIGTERM and SIGINT. */
	sigemptyset (&mask);
	sigaddset (&mask, SIGTERM);
	sigaddset (&mask, SIGINT);
 
	/* Block the signals thet we handle using signalfd(), so they don't
	 * cause signal handlers or default signal actions to execute. */
	if (sigprocmask(SIG_BLOCK, &mask, NULL) < 0) {
		perror ("sigprocmask");
		return 1;
	}
 
	/* Create a file descriptor from which we will read the signals. */
	sfd = signalfd (-1, &mask, 0);
	if (sfd < 0) {
		perror ("signalfd");
		return 1;
	}
 
	while (1) {
 
		/** The buffor for read(), this structure contains information
		 * about the signal we've read. */
		struct signalfd_siginfo si;
 
		ssize_t res;
 
		res = read (sfd, &si, sizeof(si));
 
		if (res < 0) {
			perror ("read");
			return 1;
		}
		if (res != sizeof(si)) {
			fprintf (stderr, "Something wrong\n");
			return 1;
		}
 
		if (si.ssi_signo == SIGTERM)
			printf ("Got SIGTERM\n");
		else if (si.ssi_signo == SIGINT) {
 
 
			printf ("Bye!\n");
			break;
		}
		else {
			fprintf (stderr, "Got some unhandled signal\n");
			return 1;
		}
	}
 
	/* Close the file descriptor if we no longer need it. */
	close (sfd);
 
	return 0;
}

			6.1.2.5 Example of using sigaction()
Submitted by daper on Mon, 02/02/2009 - 18:25

/* Example of using sigaction() to setup a signal handler with 3 arguments
 * including siginfo_t.
 */
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>
 
static void hdl (int sig, siginfo_t *siginfo, void *context)
{
	printf ("Sending PID: %ld, UID: %ld\n",
			(long)siginfo->si_pid, (long)siginfo->si_uid);
}
 
int main (int argc, char *argv[])
{
	struct sigaction act;
 
	memset (&act, '\0', sizeof(act));
 
	/* Use the sa_sigaction field because the handles has two additional parameters */
	act.sa_sigaction = &hdl;
 
	/* The SA_SIGINFO flag tells sigaction() to use the sa_sigaction field, not sa_handler. */
	act.sa_flags = SA_SIGINFO;
 
	if (sigaction(SIGTERM, &act, NULL) < 0) {
		perror ("sigaction");
		return 1;
	}
 
	while (1)
		sleep (10);
 
	return 0;
}

			6.1.2.6 SIGBUS handling
Submitted by daper on Mon, 01/19/2009 - 19:46

/* Example of SIGBUS handling. A read from mmap()ed memory is invalid because
 * a file was shrinked. SIGBUS is sent to the process, but we handle it and
 * jump to another place in the program so it doesn't crash.
 *
 * Run this program with or without the 'shrink' argument.
 */
#include <sys/types.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <setjmp.h>
 
/* Size of the file in pages. */
#define FILE_SIZE	4
 
/* Environment and blocked signal state for restoration in a signal handler. */
static sigjmp_buf sj_env;
 
static void sigbus_hdl (int sig, siginfo_t *siginfo, void *ptr)
{
 
	/* Jump (goto) to the saved program state where we don't use mmapped()
	 * memory. */
	siglongjmp (sj_env, 1);
}
 
int main (int argc, char *argv[])
{
	struct sigaction act;
	int fd = -1;
	char *mem = NULL;
	size_t file_size;
 
	memset (&act, 0, sizeof(act));
	act.sa_sigaction = sigbus_hdl;
	act.sa_flags = SA_SIGINFO;
 
	if (sigaction(SIGBUS, &act, 0)) {
		perror ("sigaction");
		return 1;
	}
 
	file_size = sysconf(_SC_PAGE_SIZE) * FILE_SIZE;
 
	fd = open ("file_for_mmap", O_RDWR | O_CREAT | O_TRUNC, 0644);
	if (fd < 0) {
		perror ("open");
		return 1;
	}
 
	/* Enlarge the file to file_size bytes. */
	if (ftruncate(fd, file_size) < 0) {
		perror ("ftruncate");
		return 1;
	}
 
	mem = mmap (NULL, file_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
	if (mem == MAP_FAILED) {
		perror ("mmap");
		return 1;
	}
 
	/* Remember this point as a state that we can return to using
	 * siglongjmp(). If this function returns a value other than 0
	 * it means that we are here because of siglongjmp().
	 */
	if (sigsetjmp(sj_env, 1)) {
		fprintf (stderr, "Failed to read from mapped file\n");
 
		if (mem) {
			if (munmap(mem, file_size) < 0) {
				perror ("munmap");
				return 1;
			}
		}
 
		if (fd >= 0)
			close (fd);
 
		return 1;
	}
 
	if (argc > 1 && !strcmp(argv[1], "shrink")) {
 
		/* Shrink the file to half of it's size. */
		if (ftruncate(fd, file_size / 2) < 0) {
			perror ("ftruncate");
			return 1;
		}
	}
 
	/* Read from mmapped() memory. */
	if (memchr(mem, 'd', file_size)) {
		puts ("found 'd'!");
	}
	else
		puts ("'d' not found");
 
	munmap (mem, FILE_SIZE);
	close (fd);
 
	return 0;
}


			6.1.2.7 SIGCHLD handler
Submitted by daper on Sun, 01/18/2009 - 14:16

/* Simplest dead child cleanup in a SIGCHLD handler. Prevent zombie processes
 * but don't actually do anything with the information that a child died.
 */
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
 
/* SIGCHLD handler. */
static void sigchld_hdl (int sig)
{
	/* Wait for all dead processes.
	 * We use a non-blocking call to be sure this signal handler will not
	 * block if a child was cleaned up in another part of the program. */
	while (waitpid(-1, NULL, WNOHANG) > 0) {
	}
}
 
int main (int argc, char *argv[])
{
	struct sigaction act;
	int i;
 
	memset (&act, 0, sizeof(act));
	act.sa_handler = sigchld_hdl;
 
	if (sigaction(SIGCHLD, &act, 0)) {
		perror ("sigaction");
		return 1;
	}
 
	/* Make some children. */
	for (i = 0; i < 50; i++) {
		switch (fork()) {
			case -1:
				perror ("fork");
				return 1;
			case 0:
				return 0;
		}
	}
 
	/* Wait until we get a sleep() call that is not interrupted by a signal. */
	while (sleep(1)) {
	}
 
	return 0;
}

			6.1.2.8 Using pselect() to avoid a signal race
Submitted by daper on Tue, 01/13/2009 - 23:28

/* An example of a free of signal race program using sigprocmask() and
 * pselect(). */
#include <sys/select.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
 
/* Flag that tells the daemon to exit. */
static volatile int exit_request = 0;
 
/* Signal handler. */
static void hdl (int sig)
{
	exit_request = 1;
}
 
/* Accept client on listening socket lfd and close the connection
 * immediatelly. */
static void handle_client (int lfd)
{
	int sock = accept (lfd, NULL, 0);
	if (sock < 0) {
		perror ("accept");
		exit (1);
	}
 
	puts ("accepted client");
 
	close (sock);
}
 
int main (int argc, char *argv[])
{
	int lfd;
	struct sockaddr_in myaddr;
	int yes = 1;
	sigset_t mask;
	sigset_t orig_mask;
	struct sigaction act;
 
	memset (&act, 0, sizeof(act));
	act.sa_handler = hdl;
 
	/* This server should shut down on SIGTERM. */
	if (sigaction(SIGTERM, &act, 0)) {
		perror ("sigaction");
		return 1;
	}
 
	sigemptyset (&mask);
	sigaddset (&mask, SIGTERM);
 
	if (sigprocmask(SIG_BLOCK, &mask, &orig_mask) < 0) {
		perror ("sigprocmask");
		return 1;
	}
 
	lfd = socket (AF_INET, SOCK_STREAM, 0);
	if (lfd < 0) {
		perror ("socket");
		return 1;
	}
 
	if (setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR,
				&yes, sizeof(int)) == -1) {
		perror ("setsockopt");
		return 1;
	}
 
	memset (&myaddr, 0, sizeof(myaddr));
	myaddr.sin_family = AF_INET;
	myaddr.sin_addr.s_addr = INADDR_ANY;
	myaddr.sin_port = htons (10000);
 
	if (bind(lfd, (struct sockaddr *)&myaddr, sizeof(myaddr)) < 0) {
		perror ("bind");
		return 1;
	}
 
	if (listen(lfd, 5) < 0) {
		perror ("listen");
		return 1;
	}
 
	while (!exit_request) {
		fd_set fds;
		int res;
 
		/* BANG! we can get SIGTERM at this point, but it will be
		 * delivered while we are in pselect(), because now
		 * we block SIGTERM.
		 */
 
		FD_ZERO (&fds);
		FD_SET (lfd, &fds);
 
		res = pselect (lfd + 1, &fds, NULL, NULL, NULL, &orig_mask);
		if (res < 0 && errno != EINTR) {
			perror ("select");
			return 1;
		}
		else if (exit_request) {
			puts ("exit");
			break;
		}
		else if (exit_request)
			break;
		else if (res == 0)
			continue;
 
		if (FD_ISSET(lfd, &fds)) {
			handle_client (lfd);
		}
	}
 
	return 0;
}

			6.1.2.9 Signal race with select() and accept()
Submitted by daper on Tue, 01/13/2009 - 22:46

/* An example of a signal race condition using the traditional UNIX functions:
 * signal(), select(), accept ().
 */
#include <sys/select.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
 
/* Flag that tells the daemon to exit. */
static volatile int exit_request = 0;
 
/* Signal handler. */
static void hdl (int sig)
{
	exit_request = 1;
}
 
/* Accept client on listening socket lfd and close the connection
 * immediatelly. */
static void handle_client (int lfd)
{
	int sock = accept (lfd, NULL, 0);
	if (sock < 0) {
		perror ("accept");
		exit (1);
	}
 
	puts ("accepted client");
 
	close (sock);
}
 
int main (int argc, char *argv[])
{
	int lfd;
	struct sockaddr_in myaddr;
	int yes = 1;
 
	/* This server should shut down on SIGTERM. */
	signal (SIGTERM, hdl);
 
	lfd = socket (AF_INET, SOCK_STREAM, 0);
	if (lfd < 0) {
		perror ("socket");
		return 1;
	}
 
	if (setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR,
				&yes, sizeof(int)) == -1) {
		perror ("setsockopt");
		return 1;
	}
 
	memset (&myaddr, 0, sizeof(myaddr));
	myaddr.sin_family = AF_INET;
	myaddr.sin_addr.s_addr = INADDR_ANY;
	myaddr.sin_port = htons (10000);
 
	if (bind(lfd, (struct sockaddr *)&myaddr, sizeof(myaddr)) < 0) {
		perror ("bind");
		return 1;
	}
 
	if (listen(lfd, 5) < 0) {
		perror ("listen");
		return 1;
	}
 
	while (!exit_request) {
		fd_set fds;
		int res;
 
		/* BANG! we can get SIGTERM at this point. */
 
		FD_ZERO (&fds);
		FD_SET (lfd, &fds);
 
		res = select (lfd + 1, &fds, NULL, NULL, NULL);
		if (res < 0 && errno != EINTR) {
			perror ("select");
			return 1;
		}
		else if (exit_request) {
			puts ("exit");
			break;
		}
		else if (exit_request)
			break;
		else if (res == 0)
			continue;
 
		if (FD_ISSET(lfd, &fds)) {
			handle_client (lfd);
		}
	}
 
	return 0;
}


			6.1.2.10
	6.2 Select


		6.2.1 example
Socket flow of events: Server that uses non-blocking I/O and select()
The following calls are used in the example:

|   1. The socket() function returns a socket descriptor representing an endpoint. The statement also identifies that the INET (Internet Protocol) address family with the TCP transport (SOCK_STREAM) will be used for this socket.
|   2. The ioctl() function allows the local address to be reused when the server is restarted before the required wait time expires. In this example, it sets the socket to be non-blocking. All of the sockets for the incoming connections will also be non-blocking since they will inherit that state from the listening socket.
|   3. After the socket descriptor is created, the bind() function gets a unique name for the socket.
|   4. The listen() allows the server to accept incoming client connections.
|   5. The server uses the accept() function to accept an incoming connection request. The accept() call will block indefinitely waiting for the incoming connection to arrive.
|   6. The select() function allows the process to wait for an event to occur and to wake up the process when the event occurs. In this example, the select () function returns a number that represents the socket descriptors that are ready to be processed.

      0
          Indicates that the process will timeout. In this example, the timeout is set for 30 seconds. 

      -1
          Indicates that the process has failed. 

      1
          Indicates only one descriptor is ready to be processed. In this example, when a 1 is returned the FD_ISSET and the subsequent socket calls complete only once. 

      n
          Indicates multiple descriptors waiting to be processed. In this example, when an n is returned the FD_ISSET and subsequent code loops and completes the requests in the order they are received by the server. 

|   7. The accept() and recv() functions are completed when the EWOULDBLOCK is returned.
|   8. The send() function echoes the data back to the client.
|   9. The close() function closes any open socket descriptors. 

For information on the use of code examples, see the code disclaimer.

#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <errno.h>
 
#define SERVER_PORT  12345
 
#define TRUE             1
#define FALSE            0
 
main (int argc, char *argv[])
{
   int    i, len, rc, on = 1;
   int    listen_sd, max_sd, new_sd;
   int    desc_ready, end_server = FALSE;
   int    close_conn;
   char   buffer[80];
   struct sockaddr_in   addr;
   struct timeval       timeout;
   struct fd_set        master_set, working_set;
 
   /*************************************************************/
   /* Create an AF_INET stream socket to receive incoming       */
   /* connections on                                            */
   /*************************************************************/
   listen_sd = socket(AF_INET, SOCK_STREAM, 0);
   if (listen_sd < 0)
   {
      perror("socket() failed");
      exit(-1);
   }
 
   /*************************************************************/
   /* Allow socket descriptor to be reuseable                   */
   /*************************************************************/
   rc = setsockopt(listen_sd, SOL_SOCKET,  SO_REUSEADDR,
                   (char *)&on, sizeof(on));
   if (rc < 0)
   {
      perror("setsockopt() failed");
      close(listen_sd);
      exit(-1);
   }
 
   /*************************************************************/
   /* Set socket to be non-blocking.  All of the sockets for    */
   /* the incoming connections will also be non-blocking since  */
   /* they will inherit that state from the listening socket.   */
   /*************************************************************/
   rc = ioctl(listen_sd, FIONBIO, (char *)&on);
   if (rc < 0)
   {
      perror("ioctl() failed");
      close(listen_sd);
      exit(-1);
   }
 
   /*************************************************************/
   /* Bind the socket                                           */
   /*************************************************************/
   memset(&addr, 0, sizeof(addr));
   addr.sin_family      = AF_INET;
   addr.sin_addr.s_addr = htonl(INADDR_ANY);
   addr.sin_port        = htons(SERVER_PORT);
   rc = bind(listen_sd,
             (struct sockaddr *)&addr, sizeof(addr));
   if (rc < 0)
   {
      perror("bind() failed");
      close(listen_sd);
      exit(-1);
   }
 
   /*************************************************************/
   /* Set the listen back log                                   */
   /*************************************************************/
   rc = listen(listen_sd, 32);
   if (rc < 0)
   {
      perror("listen() failed");
      close(listen_sd);
      exit(-1);
   }
 
   /*************************************************************/
   /* Initialize the master fd_set                              */
   /*************************************************************/
   FD_ZERO(&master_set);
   max_sd = listen_sd;
   FD_SET(listen_sd, &master_set);
 
   /*************************************************************/
   /* Initialize the timeval struct to 3 minutes.  If no        */
   /* activity after 3 minutes this program will end.           */
   /*************************************************************/
   timeout.tv_sec  = 3 * 60;
   timeout.tv_usec = 0;
 
   /*************************************************************/
   /* Loop waiting for incoming connects or for incoming data   */
   /* on any of the connected sockets.                          */
   /*************************************************************/
   do
   {
      /**********************************************************/
      /* Copy the master fd_set over to the working fd_set.     */
      /**********************************************************/
      memcpy(&working_set, &master_set, sizeof(master_set));
 
      /**********************************************************/
      /* Call select() and wait 5 minutes for it to complete.   */
      /**********************************************************/
      printf("Waiting on select()...\n");
      rc = select(max_sd + 1, &working_set, NULL, NULL, &timeout);
 
      /**********************************************************/
      /* Check to see if the select call failed.                */
      /**********************************************************/
      if (rc < 0)
      {
         perror("  select() failed");
         break;
      }
 
      /**********************************************************/
      /* Check to see if the 5 minute time out expired.         */
      /**********************************************************/
      if (rc == 0)
      {
         printf("  select() timed out.  End program.\n");
         break;
      }
 
      /**********************************************************/
      /* One or more descriptors are readable.  Need to         */
      /* determine which ones they are.                         */
      /**********************************************************/
      desc_ready = rc;
      for (i=0; i <= max_sd  &&  desc_ready > 0; ++i)
      {
         /*******************************************************/
         /* Check to see if this descriptor is ready            */
         /*******************************************************/
         if (FD_ISSET(i, &working_set))
         {
            /****************************************************/
            /* A descriptor was found that was readable - one   */
            /* less has to be looked for.  This is being done   */
            /* so that we can stop looking at the working set   */
            /* once we have found all of the descriptors that   */
            /* were ready.                                      */
            /****************************************************/
            desc_ready -= 1;
 
            /****************************************************/
            /* Check to see if this is the listening socket     */
            /****************************************************/
            if (i == listen_sd)
            {
               printf("  Listening socket is readable\n");
               /*************************************************/
               /* Accept all incoming connections that are      */
               /* queued up on the listening socket before we   */
               /* loop back and call select again.              */
               /*************************************************/
               do
               {
                  /**********************************************/
                  /* Accept each incoming connection.  If       */
                  /* accept fails with EWOULDBLOCK, then we     */
                  /* have accepted all of them.  Any other      */
                  /* failure on accept will cause us to end the */
                  /* server.                                    */
                  /**********************************************/
                  new_sd = accept(listen_sd, NULL, NULL);
                  if (new_sd < 0)
                  {
                     if (errno != EWOULDBLOCK)
                     {
                        perror("  accept() failed");
                        end_server = TRUE;
                     }
                     break;
                  }
 
                  /**********************************************/
                  /* Add the new incoming connection to the     */
                  /* master read set                            */
                  /**********************************************/
                  printf("  New incoming connection - %d\n", new_sd);
                  FD_SET(new_sd, &master_set);
                  if (new_sd > max_sd)
                     max_sd = new_sd;
 
                  /**********************************************/
                  /* Loop back up and accept another incoming   */
                  /* connection                                 */
                  /**********************************************/
               } while (new_sd != -1);
            }
 
            /****************************************************/
            /* This is not the listening socket, therefore an   */
            /* existing connection must be readable             */
            /****************************************************/
            else
            {
               printf("  Descriptor %d is readable\n", i);
               close_conn = FALSE;
               /*************************************************/
               /* Receive all incoming data on this socket      */
               /* before we loop back and call select again.    */
               /*************************************************/
               do
               {
                  /**********************************************/
                  /* Receive data on this connection until the  */
                  /* recv fails with EWOULDBLOCK.  If any other */
                  /* failure occurs, we will close the          */
                  /* connection.                                */
                  /**********************************************/
                  rc = recv(i, buffer, sizeof(buffer), 0);
                  if (rc < 0)
                  {
                     if (errno != EWOULDBLOCK)
                     {
                        perror("  recv() failed");
                        close_conn = TRUE;
                     }
                     break;
                  }
 
                  /**********************************************/
                  /* Check to see if the connection has been    */
                  /* closed by the client                       */
                  /**********************************************/
                  if (rc == 0)
                  {
                     printf("  Connection closed\n");
                     close_conn = TRUE;
                     break;
                  }
 
                  /**********************************************/
                  /* Data was recevied                          */
                  /**********************************************/
                  len = rc;
                  printf("  %d bytes received\n", len);
 
                  /**********************************************/
                  /* Echo the data back to the client           */
                  /**********************************************/
                  rc = send(i, buffer, len, 0);
                  if (rc < 0)
                  {
                     perror("  send() failed");
                     close_conn = TRUE;
                     break;
                  }
 
               } while (TRUE);
 
               /*************************************************/
               /* If the close_conn flag was turned on, we need */
               /* to clean up this active connection.  This     */
               /* clean up process includes removing the        */
               /* descriptor from the master set and            */
               /* determining the new maximum descriptor value  */
               /* based on the bits that are still turned on in */
               /* the master set.                               */
               /*************************************************/
               if (close_conn)
               {
                  close(i);
                  FD_CLR(i, &master_set);
                  if (i == max_sd)
                  {
                     while (FD_ISSET(max_sd, &master_set) == FALSE)
                        max_sd -= 1;
                  }
               }
            } /* End of existing connection is readable */
         } /* End of if (FD_ISSET(i, &working_set)) */
      } /* End of loop through selectable descriptors */
 
   } while (end_server == FALSE);
 
   /*************************************************************/
   /* Cleanup all of the sockets that are open                  */
   /*************************************************************/
   for (i=0; i <= max_sd; ++i)
   {
      if (FD_ISSET(i, &master_set))
         close(i);
   }
}

		6.2.2

	6.3 epoll

		6.3.1 Description
epoll is a scalable event notification mechanism for Linux, first introduced in Linux 2.5.44 [1]. It is meant to replace the older POSIX select(2) and poll(2) system calls, to achieve better performance in more demanding applications, where the number of watched file descriptors is large (unlike the older system calls, which operate at O(n), epoll operates in O(1) [2]). epoll is similar to FreeBSD's kqueue, in that it operates on a configurable kernel object, exposed to user space as a file descriptor of its own.

 API

int epoll_create(int size);

Creates an epoll object and returns its file descriptor.

int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);

Controls (configures) which file descriptors are watched by this object, and for which events.

int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);

Waits for any of the registered events, until at least one occurs or the timeout elapses.

 Triggering Modes

epoll provides both edge-triggered and level-triggered modes. In edge-triggered mode, a call to epoll_wait will return only when a new event is enqueued with the epoll object, while in level-triggered mode, epoll_wait will return as long as the condition withholds.

For instance, if a pipe, registered with epoll, has received data, a call to epoll_wait will return, signaling that the presence of data to read. Suppose the reader only consumed part of data from the buffer. In level-triggered mode, further calls to epoll_wait will return immediately, as long as the pipe's buffer contains data to be read. In edge-triggered mode, however, epoll_wait will return only once new data is written to the pipe.

 See also

    * libevent

		6.3.2 Using epoll() For Asynchronous Network Programming

General way to implement tcp servers is “one thread/process per connection”. But on high loads this approach can be not so efficient and we need to use another patterns of connection handling. In this article I will describe how to implement tcp-server with synchronous connections handling using epoll() system call of Linux 2.6. kernel.

epoll is a new system call introduced in Linux 2.6. It is designed to replace the deprecated select (and also poll). Unlike these earlier system calls, which are O(n), epoll is an O(1) algorithm – this means that it scales well as the number of watched file descriptors increase. select uses a linear search through the list of watched file descriptors, which causes its O(n) behaviour, whereas epoll uses callbacks in the kernel file structure.

Another fundamental difference of epoll is that it can be used in an edge-triggered, as opposed to level-triggered, fashion. This means that you receive “hints” when the kernel believes the file descriptor has become ready for I/O, as opposed to being told “I/O can be carried out on this file descriptor”. This has a couple of minor advantages: kernel space doesn’t need to keep track of the state of the file descriptor, although it might just push that problem into user space, and user space programs can be more flexible (e.g. the readiness change notification can just be ignored).

To use epoll method you need to make following steps in your application:

    * Create specific file descriptor for epoll calls:

        epfd = epoll_create(EPOLL_QUEUE_LEN);


      where EPOLL_QUEUE_LEN is the maximum number of connection descriptors you expect to manage at one time. The return value is a file descriptor that will be used in epoll calls later. This descriptor can be closed with close() when you do not longer need it.
    * After first step you can add your descriptors to epoll with following call:

        static struct epoll_event ev;
        int client_sock;
        ...
        ev.events = EPOLLIN | EPOLLPRI | EPOLLERR | EPOLLHUP;
        ev.data.fd = client_sock;
        int res = epoll_ctl(epfd, EPOLL_CTL_ADD, client_sock, &ev);


      where ev is epoll event configuration sctucture, EPOLL_CTL_ADD – predefined command constant to add sockets to epoll. Detailed description of epoll_ctl flags can be found in epoll_ctl(2) man page. When client_sock descriptor will be closed, it will be automatically deleted from epoll descriptor.
    * When all your descriptors will be added to epoll, your process can idle and wait to something to do with epoll’ed sockets:

        while (1) {
          // wait for something to do...
          int nfds = epoll_wait(epfd, events,
                                      MAX_EPOLL_EVENTS_PER_RUN,
                                      EPOLL_RUN_TIMEOUT);
          if (nfds < 0) die("Error in epoll_wait!");

          // for each ready socket
          for(int i = 0; i < nfds; i++) {
            int fd = events[i].data.fd;
            handle_io_on_socket(fd);
          }
        }

Typical architecture of your application (networking part) is described below. This architecture allow almost unlimited scalability of your application on single and multi-processor systems:

    * Listener – thread that performs bind() and listen() calls and waits for incoming conncetions. Then new connection arrives, this thread can do accept() on listening socket an send accepted connection socket to one of the I/O-workers.
    * I/O-Worker(s) – one or more threads to receive connections from listener and to add them to epoll. Main loop of the generic I/O-worker looks like last step of epoll using pattern described above.
    * Data Processing Worker(s) – one or more threads to receive data from and send data to I/O-workers and to perform data processing.

As you can see, epoll() API is very simple but believe me, it is very powerful. Linear scalability allows you to manage huge amounts of parallel connections with small amout of worker processes comparing to classical one-thread per connection.

		6.3.3

	6.4 libevent
libevent is an asynchronous event notification software library.

The libevent API provides a mechanism to execute a callback function when a specific event occurs on a file descriptor or after a timeout has been reached. Furthermore, libevent also supports callbacks due to signals or regular timeouts.

libevent is meant to replace the event loop found in event-driven network servers. An application just needs to call event_dispatch() and then add or remove events dynamically without having to change the event loop.

Currently, libevent supports /dev/poll, kqueue(2), select(2), poll(2), epoll(4) and Solaris's event ports. It also has experimental support for real-time signals. The internal event mechanism is completely independent of the exposed event API, and a simple update of libevent can provide new functionality without having to redesign the applications. As a result, libevent allows for portable application development and provides the most scalable event notification mechanism available on an operating system.

Using callbacks on signals, libevent makes it easy to write secure signal handlers as none of the user supplied signal handling code runs in the signal's context.


		6.4.1 event-test.c
/*
 * Compile with:
 * cc -I/usr/local/include -o event-test event-test.c -L/usr/local/lib -levent
 */

#include <sys/types.h>
#include <sys/stat.h>
#ifndef WIN32
#include <sys/queue.h>
#include <unistd.h>
#include <sys/time.h>
#else
#include <windows.h>
#endif
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

#include <event.h>

void
fifo_read(int fd, short event, void *arg)
{
	char buf[255];
	int len;
	struct event *ev = arg;
#ifdef WIN32
	DWORD dwBytesRead;
#endif

	/* Reschedule this event */
	event_add(ev, NULL);

	fprintf(stderr, "fifo_read called with fd: %d, event: %d, arg: %p\n",
		fd, event, arg);
#ifdef WIN32
	len = ReadFile((HANDLE)fd, buf, sizeof(buf) - 1, &dwBytesRead, NULL);

	// Check for end of file. 
	if(len && dwBytesRead == 0) {
		fprintf(stderr, "End Of File");
		event_del(ev);
		return;
	}

	buf[dwBytesRead + 1] = '\0';
#else
	len = read(fd, buf, sizeof(buf) - 1);

	if (len == -1) {
		perror("read");
		return;
	} else if (len == 0) {
		fprintf(stderr, "Connection closed\n");
		return;
	}

	buf[len] = '\0';
#endif
	fprintf(stdout, "Read: %s\n", buf);
}

int
main (int argc, char **argv)
{
	struct event evfifo;
#ifdef WIN32
	HANDLE socket;
	// Open a file. 
	socket = CreateFile("test.txt",     // open File 
			GENERIC_READ,                 // open for reading 
			0,                            // do not share 
			NULL,                         // no security 
			OPEN_EXISTING,                // existing file only 
			FILE_ATTRIBUTE_NORMAL,        // normal file 
			NULL);                        // no attr. template 

	if(socket == INVALID_HANDLE_VALUE)
		return 1;

#else
	struct stat st;
	char *fifo = "event.fifo";
	int socket;
 
	if (lstat (fifo, &st) == 0) {
		if ((st.st_mode & S_IFMT) == S_IFREG) {
			errno = EEXIST;
			perror("lstat");
			exit (1);
		}
	}

	unlink (fifo);
	if (mkfifo (fifo, 0600) == -1) {
		perror("mkfifo");
		exit (1);
	}

	/* Linux pipes are broken, we need O_RDWR instead of O_RDONLY */
#ifdef __linux
	socket = open (fifo, O_RDWR | O_NONBLOCK, 0);
#else
	socket = open (fifo, O_RDONLY | O_NONBLOCK, 0);
#endif

	if (socket == -1) {
		perror("open");
		exit (1);
	}

	fprintf(stderr, "Write data to %s\n", fifo);
#endif
	/* Initalize the event library */
	event_init();

	/* Initalize one event */
#ifdef WIN32
	event_set(&evfifo, (int)socket, EV_READ, fifo_read, &evfifo);
#else
	event_set(&evfifo, socket, EV_READ, fifo_read, &evfifo);
#endif

	/* Add it to the active events, without a timeout */
	event_add(&evfifo, NULL);
	
	event_dispatch();
#ifdef WIN32
	CloseHandle(socket);
#endif
	return (0);
}



7. C How to Program, 5th edition

	7.1 Introduction


		7.1.1 History of C
C evolved from two previous languages, BCPL and B. BCPL was developed in 1967 by
Martin Richards as a language for writing operating-systems software and compilers. Ken
Thompson modeled many features in his B language after their counterparts in BCPL,
and in 1970 he used B to create early versions of the UNIX operating system at Bell Laboratories
on a DEC PDP-7 computer. Both BCPL and B were “typeless” languages—every
data item occupied one “word” in memory, and the burden of typing variables fell on
the shoulders of the programmer.
The C language was evolved from B by Dennis Ritchie at Bell Laboratories and was
originally implemented on a DEC PDP-11 computer in 1972. C uses many of the important
concepts of BCPL and B while adding data typing and other powerful features. C ini-tially became widely known as the development language of the UNIX operating system.
Today, virtually all new major operating systems are written in C and/or C++. C is available
for most computers. C is also hardware independent. With careful design, it is possible
to write C programs that are portable to most computers.
By the late 1970s, C had evolved into what is now referred to as “traditional C.” The
publication in 1978 of Kernighan and Ritchie’s book, The C Programming Language, drew
wide attention to the language. This became one of the most successful computer science
books of all time.
The rapid expansion of C over various types of computers (sometimes called hardware
platforms) led to many variations that were similar but often incompatible. This was
a serious problem for programmers who needed to develop code that would run on several
platforms. It became clear that a standard version of C was needed. In 1983, the X3J11
technical committee was created under the American National Standards Committee on
Computers and Information Processing (X3) to “provide an unambiguous and machineindependent
definition of the language.” In 1989, the standard was approved; this standard
was updated in 1999. The standards document is referred to as INCITS/ISO/IEC 9899-1999. Copies may be ordered from the American National Standards Institute
(www.ansi.org) at webstore.ansi.org/ansidocstore.
C99 is a revised standard for the C programming language that refines and expands
the capabilities of C. C99 has not been widely adopted, and not all popular C compilers
support it. Of the compilers that do offer C99 support, most implement only a subset of
the new features. Chapters 1–16 of this book are based on the widely adopted international
Standard (ANSI/ISO) C. Chapter 17 introduces C99 and provides links to popular
C99 compilers and IDEs.
Portability Tip 1.1
Because C is a hardware-independent, widely available language, applications written in C can
run with little or no modifications on a wide range of different computer systems. 1.1
[Note: We will include many of these Portability Tips to highlight techniques that
will help you write programs that can run, with little or no modification, on a variety of
computers. We will also highlight Good Programming Practices (practices that can help
you write programs that are clear, understandable, maintainable and easy to test and
debug—that is, eliminate errors), Common Programming Errors (problems to watch out
for, so you do not make these same errors in your programs), Performance Tips (techniques
that will help you write programs that run faster and use less memory), Error-Prevention
Tips (techniques that will help you remove bugs from your programs and, more
important, help you write bug-free programs in the first place) and Software Engineering
Observations (concepts that affect and improve the overall architecture and quality of a
software system, and particularly of large software systems). Many of these techniques and
practices are only guidelines; you will, no doubt, develop your own preferred programming
style.]


		7.1.2 C Standard Library
As you will learn in Chapter 5, C programs consist of modules or pieces called functions.
You can program all the functions you need to form a C program, but most C programmers
take advantage of a rich collection of existing functions called the C Standard Li-brary. Thus, there are really two pieces to learning how to program in C. The first is
learning the C language itself, and the second is learning how to use the functions in the
C Standard Library. Throughout the book, we discuss many of these functions. P.J.
Plauger’s The Standard C Library is required reading for programmers who need a deep
understanding of the library functions, how to implement them and how to use them to
write portable code.
This textbook encourages a building-block approach to creating programs. Avoid
reinventing the wheel. Instead, use existing pieces—this is called software reusability, and
it is a key to the developing field of object-oriented programming, as we will see in our
treatment of C++ beginning in Chapter 18. When programming in C you will typically
use the following building blocks:
• C Standard Library functions
• Functions you create yourself
• Functions other people have created and made available to you
The advantage of creating your own functions is that you will know exactly how they
work. You will be able to examine the C code. The disadvantage is the time-consuming
effort that goes into designing, developing and debugging new functions.
If you use existing functions, you can avoid reinventing the wheel. In the case of the
Standard C functions, you know that they are carefully written, and you know that
because you are using functions that are available on virtually all Standard C implementations,
your programs will have a greater chance of being portable and error-free.
Performance Tip 1.1
Using Standard C library functions instead of writing your own comparable versions can improve
program performance, because these functions are carefully written to perform efficiently.1.1
Portability Tip 1.2
Using Standard C library functions instead of writing your own comparable versions can improve
program portability, because these functions are used in virtually all Standard C implementations.


		7.1.3 C++
C++ was developed by Bjarne Stroustrup at Bell Laboratories. It has its roots in C, providing
a number of features that “spruce up” the C language. More important, it provides capabilities
for object-oriented programming. C++ has become a dominant language in
both industry and universities.
Objects are essentially reusable software components that model items in the real
world. Software developers are discovering that using a modular, object-oriented design
and implementation approach can make software development groups much more productive
than is possible with conventional programming techniques.
Many people feel that the best educational strategy today is to master C, then study
C++. Therefore, in Chapters 18–27 of C How to Program: Fifth Edition, we present a condensed
treatment of C++ selected from our book C++ How to Program.We hope that you
find this valuable and that it will encourage you to pursue further study of C++ after com-pleting this book. As you study C++, check out our online C++ Resource Center at
www.deitel.com/cplusplus.

		7.1.4 Java
Many people believe that the next major area in which microprocessors will have a profound
impact is that of intelligent consumer electronic devices. In 1991, recognizing this,
Sun Microsystems funded an internal corporate research project code-named Green. The
project resulted in the development of a language based on C and C++, which its creator,
James Gosling, called Oak after an oak tree outside his window at Sun. It was later discovered
that there already was a computer language called Oak. When a group of Sun people
visited a local coffee place, the name Java was suggested and it stuck.
The Green project ran into some difficulties. The marketplace for intelligent consumer
electronic devices was not developing as quickly as Sun had anticipated. Worse yet,
a major contract for which Sun had competed was awarded to another company, putting
the project in danger of being canceled. By sheer good fortune, the World Wide Web
exploded in popularity in 1993, and Sun saw the immediate potential of using Java to
create web pages with so-called dynamic content.
Sun formally announced Java at a trade show in May 1995. Ordinarily, an event such
as this would not have generated much attention, but Java generated immediate interest
in the business community because of the phenomenal interest in the World Wide Web.
Java is now used to create web pages with dynamic and interactive content, develop largescale
enterprise applications, enhance the functionality of web servers (the computers that
provide the content we see in web browsers), provide applications for consumer devices
(such as cell phones, pagers and personal digital assistants) and do many more things.
In November of 1995, we were following the development of Java by Sun Microsystems
and we attended an Internet conference in Boston. A representative from Sun Microsystems
gave a rousing presentation on Java. As the talk proceeded, it became clear to us
that Java would certainly play a significant part in the development of interactive, multimedia
web pages. But we immediately saw a much greater potential for the language. We
saw Java as a superb language for teaching programming language students the essentials
of graphics, images, animation, audio, video, database, networking, multithreading and
collaborative computing.
In addition to its prominence in developing Internet- and intranet-based applications,
Java has become the language of choice for implementing software for devices that communicate
over a network (such as cellular phones, pagers and personal digital assistants).
Do not be surprised when your new stereo and other devices in your home are networked
together using Java technology!

		7.1.5 BASIC, Visual Basic, Visual C++, Visual C# and .NET

The BASIC (Beginner’s All-Purpose Symbolic Instruction Code) programming language
was developed in the mid-1960s by Professors John Kemeny and Thomas Kurtz of Dartmouth
College as a language for writing simple programs. BASIC’s primary purpose was
to familiarize novices with programming techniques. Visual Basic was introduced by Microsoft
in 1991 to simplify the process of developing Microsoft Windows applications.
Visual Basic, Visual C++ and Visual C# are designed for Microsoft’s new .NET programming
platform. All three languages make use of .NET’s powerful library of reusable
software components called the Framework Class Library (FCL).
Comparably to Java, the .NET platform enables web-based applications to be distributed
to many devices (even cell phones) and to desktop computers. The C# programming
language was designed specifically for the .NET platform as a language that would enable
programmers to migrate easily to .NET. C++, Java and C# all have their roots in the C programming
language.


		7.1.6 Key Software Trend: Object Technology
One of the authors, HMD, remembers the great frustration that was felt in the 1960s by
software development organizations, especially those developing large-scale projects. During
his undergraduate years, HMD had the privilege of working summers at a leading
computer vendor on the teams developing timesharing, virtual-memory operating systems.
This was a great experience for a college student. In the summer of 1967, reality set
in when the company “decommitted” from producing as a commercial product the particular
system on which hundreds of people had been working for many years. It was difficult
to get this software right. Software is “complex stuff.”
Improvements to software technology did start to appear, with the benefits of socalled
structured programming (and the related disciplines of structured systems analysis
and design) being realized in the 1970s. But not until the 1990s, when the technology of
object-oriented programming became widely used, did software developers finally feel
they had the tools for making major strides in the software development process.
Actually, object technology dates back to the mid 1960s. The C++ programming language,
developed at AT&T by Bjarne Stroustrup in the early 1980s, is based on two languages—
C and Simula 67, a simulation programming language developed in Europe and
released in 1967. C++ absorbed the features of C and added Simula’s capabilities for creating
and manipulating objects. Neither C nor C++ was originally intended for wide use
beyond the AT&T research laboratories. But grassroots support rapidly developed for
each.
What are objects and why are they special? Object technology is a packaging scheme
that enables programmers to create meaningful software units. These are large and highly
focused on particular applications areas. There are date objects, time objects, paycheck
objects, invoice objects, audio objects, video objects, file objects, record objects and so on.
In fact, almost any noun can be reasonably represented as an object.
We live in a world of objects. Just look around you. There are cars, planes, people,
animals, buildings, traffic lights, elevators, and the like. Before object-oriented languages
appeared, programming languages (such as Fortran, Pascal, Basic and C) were focused on
actions (verbs) rather than on things or objects (nouns). Now, with the availability of popular
object-oriented languages such as Java and C++, programmers continue to live in an
object-oriented world but can conveniently program in an object-oriented (noun-oriented)
manner. This is a more natural process than procedural programming and has
resulted in significant productivity enhancements.
A key problem with procedural programming is that the program units do not easily
mirror real-world entities effectively, so these units are not particularly reusable. It is not
unusual for programmers to “start fresh” on each new project and have to write similar software “from scratch.” Time and money are wasted as people repeatedly reinvent the
wheel. With object technology, the software entities created (called classes), if properly
designed, tend to be much more reusable on future projects. Using libraries of reusable
componentry, such as the .NET FCL and those produced by many other software development
organizations, can greatly reduce the amount of effort required to implement certain
kinds of systems (as compared to the effort reinventing these capabilities on new
projects).
Some organizations report that software reuse is not, in fact, the key benefit they get
from object-oriented programming. Rather, object-oriented programming tends to produce
software that is more understandable, better organized and easier to maintain,
modify and debug. This can be significant, because it has been estimated that as much as 80% of software costs are associated not with the original efforts to develop the software
but with the continued evolution and maintenance of that software throughout its lifetime.
Clearly, whatever its perceived benefits, object-oriented programming will be the key
programming methodology for the next several decades.

		7.1.7 Typical C Program Development Environment
C systems generally consist of several parts: a program development environment, the language
and the C Standard Library. The following discussion explains the typical C development
environment shown in Fig. 1.1.
C programs typically go through six phases to be executed (Fig. 1.1). These are: edit,
preprocess, compile, link, load and execute. Although C How to Program is a generic C
textbook (written independently of the details of any particular operating system), we concentrate
in this section on a typical Linux-based C system. [Note: The programs in this
book will run with little or no modification on most current C systems, including
Microsoft Windows-based systems.] If you are not using a Linux system, refer to the manuals
for your system or ask your instructor how to accomplish these tasks in your environment.
Also, check out our C Resource Center at www.deitel.com/C to locate “getting
started” tutorials for popular C compilers and development environments.
Phase 1: Creating a Program
Phase 1 consists of editing a file. This is accomplished with an editor program. Two editors
widely used on Linux systems are vi and emacs. Software packages for the C/C++ integrated
program development environments such as Borland C++ Builder and Microsoft
Visual Studio have editors that are integrated into the programming environment. We assume
that the reader knows how to edit a program. The programmer types a C program
with the editor, makes corrections if necessary, then stores the program on a secondary
storage device such as a disk. C program file names should end with the .c extension.
Phases 2 and 3: Preprocessing and Compiling a C Program
In Phase 2, the programmer gives the command to compile the program. The compiler
translates the C program into machine language-code (also referred to as object code). In
a C system, a preprocessor program executes automatically before the compiler’s translation
phase begins. The C preprocessor obeys special commands called preprocessor directives,
which indicate that certain manipulations are to be performed on the program before compilation. These manipulations usually consist of including other files in the file
to be compiled and performing various text replacements. The most common preprocessor
directives are discussed in the early chapters; a detailed discussion of preprocessor fea-tures appears in Chapter 13. In Phase 3, the compiler translates the C program into
machine-language code.
Phase 4: Linking
The next phase is called linking. C programs typically contain references to functions defined
elsewhere, such as in the standard libraries or in the private libraries of groups of programmers
working on a particular project. The object code produced by the C compiler
typically contains “holes” due to these missing parts. A linker links the object code with
the code for the missing functions to produce an executable image (with no missing pieces).
On a typical Linux system, the command to compile and link a program is called cc
(or gcc). To compile and link a program named welcome.c type
cc welcome.c
at the Linux prompt and press the Enter key (or Return key). [Note: Linux commands are
case sensitive; make sure that you type lowercase c’s and that the letters in the filename are
in the appropriate case.] If the program compiles and links correctly, a file called a.out is
produced. This is the executable image of our welcome.c program.
Phase 5: Loading
The next phase is called loading. Before a program can be executed, the program must first
be placed in memory. This is done by the loader, which takes the executable image from
disk and transfers it to memory. Additional components from shared libraries that support
the program are also loaded.
Phase 6: Execution
Finally, the computer, under the control of its CPU, executes the program one instruction
at a time. To load and execute the program on a Linux system, type ./a.out at the Linux
prompt and press Enter.
Problems That May Occur at Execution Time
Programs do not always work on the first try. Each of the preceding phases can fail because
of various errors that we will discuss. For example, an executing program might attempt
to divide by zero (an illegal operation on computers just as in arithmetic). This would
cause the computer to print an error message. You would then return to the edit phase,
make the necessary corrections and proceed through the remaining phases again to determine
that the corrections work properly.
Most programs in C input and/or output data. Certain C functions take their input
from stdin (the standard input stream), which is normally the keyboard, but stdin can
be connected to another stream. Data is often output to stdout (the standard output
stream), which is normally the computer screen, but stdout can be connected to another
stream. When we say that a program prints a result, we normally mean that the result is
displayed on a screen. Data may be output to devices such as disks and printers. There is
also a standard error stream referred to as stderr. The stderr stream (normally connected
to the screen) is used for displaying error messages. It is common to route regular
output data, i.e., stdout, to a device other than the screen while keeping stderr assigned
to the screen so that the user can be immediately informed of errors. 

		7.1.8 Hardware Trends
Every year, people generally expect to pay at least a little more for most products and services.
The opposite has been the case in the computer and communications fields, especially
with regard to the costs of hardware supporting these technologies. For many
decades, hardware costs have fallen rapidly, if not precipitously. Every year or two, the capacities
of computers have approximately doubled without any increase in price. This often
is called Moore’s Law, named after the person who first identified and explained the
trend, Gordon Moore, cofounder of Intel—the company that manufactures the vast majority
of the processors in today’s personal computers. Moore’s Law and similar trends are
especially true in relation to the amount of memory that computers have for programs, the
amount of secondary storage (such as disk storage) they have to hold programs and data
over longer periods of time, and their processor speeds—the speeds at which computers
execute programs (i.e., do their work). Similar growth has occurred in the communications
field, in which costs have plummeted as demand for communications bandwidth has
attracted intense competition. We know of no other fields in which technology improves
so quickly and costs fall so rapidly. Such improvement in the computing and communications
fields is truly fostering the so-called Information Revolution.
When computer use exploded in the 1960s and 1970s, many people discussed the
dramatic improvements in human productivity that computing and communications
would cause, but these improvements did not materialize. Organizations were spending
vast sums of money on these technologies, but without realizing the expected productivity
gains. The invention of microprocessor chip technology and its wide deployment in the
late 1970s and 1980s laid the groundwork for the productivity improvements that individuals
and businesses have achieved in recent years.


		7.1.9 History of the Internet
In the late 1960s, one of the authors (HMD) was a graduate student at MIT. His research
at MIT’s Project Mac (now the Laboratory for Computer Science—the home of the
World Wide Web Consortium) was funded by ARPA—the Advanced Research Projects
Agency of the Department of Defense. ARPA sponsored a conference at which several dozen
ARPA-funded graduate students were brought together at the University of Illinois at
Urbana-Champaign to meet and share ideas. During this conference, ARPA rolled out the
blueprints for networking the main computer systems of about a dozen ARPA-funded universities
and research institutions. They were to be connected with communications lines
operating at a then-stunning 56KB (i.e., 56,000 bits per second), at a time when most people
(of the few who could) were connecting over telephone lines at a rate of 110 bits per
second. HMD vividly recalls the excitement at that conference. Researchers at Harvard in
Massachusetts talked about communication with the Univac 1108 “supercomputer”

across the country at the University of Utah to handle calculations related to their computer
graphics research. Many other intriguing possibilities were raised. Academic research
was about to take a giant leap forward. Shortly after this conference, ARPA proceeded to
implement what quickly became called the ARPAnet, the grandparent of today’s Internet.
Things worked out differently than originally planned. Although the ARPAnet did
enable researchers to share each others’ computers, its chief benefit proved to be its capability
of quick and easy communication via what came to be known as electronic mail (email).
This is true even today on the Internet, with e-mail and other services facilitating
communications of all kinds among nearly a billion people worldwide.
One of ARPA’s primary goals for the network was to allow multiple users to send and
receive information at the same time over the same communications paths (such as phone
lines). The network operated with a technique called packet switching, in which digital
data was sent in small packages called packets. The packets contained data, address information,
error-control information and sequencing information. The address information
was used to route the packets of data to their destination. The sequencing information was
used to help reassemble the packets (which—because of complex routing mechanisms—
could actually arrive out of order) into their original order for presentation to the recipient.
Packets of many people were intermixed on the same lines. This packet-switching technique
greatly reduced transmission costs as compared to those of dedicated communications
lines.
The network was designed to operate without centralized control. This meant that if
a portion of the network should fail, the remaining working portions would still be able
to route packets from senders to receivers over alternate paths.
The protocol for communicating over the ARPAnet became known as TCP—the
Transmission Control Protocol. TCP ensured that messages were properly routed from
sender to receiver and that they messages arrived intact.
In parallel with the early evolution of the Internet, organizations worldwide were
implementing their own networks for both intraorganization (i.e., within the organization)
and interorganization (i.e., between organizations) communication. A huge variety
of networking hardware and software appeared. One challenge was to get these to intercommunicate.
ARPA accomplished this with the development of IP—the Internetworking
Protocol), truly creating a “network of networks,” the current architecture of the
Internet. The combined set of protocols is now commonly called TCP/IP.
Initially, use of the Internet was limited to colleges and research institutions; then the
military became a big user. Eventually, the government decided to allow access to the
Internet for commercial purposes. At first there was resentment among the research and
military communities—it was felt that response times would become poor as “the net”
became saturated with so many users.
In fact, the exact opposite has occurred. Businesses rapidly realized that, by making
effective use of the Internet, they could tune their operations and offer new and better services
to their clients, so they started spending vasts amounts of money to develop and
enhance the Internet. This generated fierce competition among the communications carriers
and the hardware and software suppliers to meet the demand. The result is that bandwidth
(i.e., the information-carrying capacity of communications lines) on the Internet
has increased tremendously and costs have plummeted. Countries worldwide now realize
that the Internet is crucial to their economic prosperity and competitiveness.

		7.1.10 History of theWorldWideWeb
The World Wide Web allows computer users to locate and view over the Internet multimedia-
based documents (i.e., documents with text, graphics, animations, audios and/or
videos) on almost any subject. Even though the Internet was developed more than three
decades ago, the introduction of the World Wide Web was a relatively recent event. In 1990, Tim Berners-Lee of CERN (the European Laboratory for Particle Physics) developed
the World Wide Web and several communication protocols that form its backbone.
The Internet and the World Wide Web will surely be listed among the most important
and profound creations of humankind. In the past, most computer applications ran
on “stand-alone” computers, i.e., computers that were not connected to one another.
Today’s applications can be written to communicate among the world’s hundreds of millions
of computers. The Internet mixes computing and communications technologies. It
makes our work easier. It makes information instantly and conveniently accessible worldwide.
It enables individuals and small businesses to get worldwide exposure. It is changing
the way business is done. People can search for the best prices on virtually any product or
service. Special-interest communities can stay in touch with one another. Researchers can
be made instantly aware of the latest breakthroughs worldwide. 

		7.1.11 Notes About C and This Book
Experienced C programmers sometimes take pride in being able to create weird, contorted,
convoluted usages of the language. This is a poor programming practice. It makes programs
more difficult to read, more likely to behave strangely, more difficult to test and
debug and more difficult to adapt to changing requirements. This book is geared for novice
programmers, so we stress program clarity. The following is our first “good programming
practice.”
Good Programming Practice 1.1
Write your C programs in a simple and straightforward manner. This is sometimes referred to
as KIS (“keep it simple”). Do not “stretch” the language by trying bizarre usages. 1.1
You may have heard that C is a portable language and that programs written in C can
run on many different computers. Portability is an elusive goal. The Standard C document
contains a lengthy list of portability issues, and complete books have been written that discuss
portability.
Portability Tip 1.3
Although it is possible to write portable programs, there are many problems between different C
compilers and different computers that make portability difficult to achieve. Simply writing programs
in C does not guarantee portability. The progammer will often need to deal directly with
complex computer variations. 1.3
We have done a careful walkthrough of the C Standard document and audited our
presentation against it for completeness and accuracy. However, C is a rich language, and
there are some subtleties in the language and some advanced subjects we have not covered.
If you need additional technical details on C, we suggest that you read the C Standard document
itself or the book by Kernighan and Ritchie.

We have limited our discussions in Chapters 1–16 to ANSI/ISO C. Many features of
this version of C are not compatible with older C implementations, so you may find that
some of the programs in this text do not work on older C compilers. Chapter 17 introduces
the newer C99 standard, which has not been widely accepted, but whose use is
growing.
Software Engineering Observation 1.1
Read the manuals for the version of C you are using. Reference these manuals frequently to be
sure you are aware of the rich collection of C features and that you are using these features
correctly. 1.1
Software Engineering Observation 1.2
Your computer and compiler are good teachers. If you are not sure how a feature of C works,
write a sample program with that feature, compile and run the program and see what happens. 1.2


		7.1.12 Web Resources
C Standard and Working Group
If you’d like to look at the precise definition of the C language or to follow the working
group that maintains and evolves C, visit the following sites:
www.open-std.org/jtc1/sc22/wg14/
Homepage of the C working group that governs the evolution of the C standard.
www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf
Rationale for the C standard. This document explains many changes that have been made to C over
the years.
www.open-std.org/jtc1/sc22/wg14/www/standards.html#9899
Provides access to the most recent publicly accessible version of the international C standard document,
the rationale for C99 and Technical Corrigendum 1 and Technical Corrigendum 2.
Free C/C++ Compilers and Development Tools
msdn.microsoft.com/vstudio/express/visualc/download/
Download the free Microsoft Visual C++ .NET 2005 Express Edition software. Full versions of the
software can be purchased through this site.
www.borland.com/bcppbuilder
Download the free trial edition of Borland C++Builder 2006. Full versions of the software can be
purchased through this site.
http://www.freescale.com/webapp/sps/site/overview.jsp?nodeId=01272600612247
Download the free trial edition of Freescale CodeWarrior Compiler. Full versions of the software
can be purchased through this site.
developer.intel.com/software/products/compilers/cwin/index.htm
Download the free trial edition of the Intel C++ Compiler 9.1 for Windows. Full versions of the
software can be purchased through this site.
gcc.gnu.org/install/binaries.html
Download the free, open-source GNU C++ compiler for a variety of systems.
developer.apple.com/tools/mpw-tools/
Download the free, open-source Macintosh Programmer’s Workshop for use with Mac OS 7.x, 8.x,
and 9.x.
www.bloodshed.net/devcpp.html
Free Bloodshed Dev-C++ IDE (Integrated Development Environment) for use with the MinGW
and Cygwin ports of the GNU Compiler.
sources.redhat.com/cygwin/
Download Cygwin, a free program that allows developers to use the GNU compiler and to develop
programs in a Linux-like environment onWindows systems.
www.mingw.org/
Download MinGW, another free program that allows developers to create programs in a Linux-like
environment onWindows systems.
www.codeblocks.org/
Download Code::Blocks—a free, open-source, cross-platform C++ IDE.
www.digitalmars.com/download/dmcpp.html
Digital Mars C/C++ compiler for Win32.
www.members.tripod.com/%7Eladsoft/frindx.htm?cc386.htm
LadSoft CC386 32-bit C compiler.
www.orbworks.com/
C compiler for use with PalmOs,WinCE andWin32.
www.c-compiler.com/
Miracle C by Tadeusz Szocik. This compiler is free to use, but a registered version that includes
source code of the compiler is also available on this site.
developer.sun.com/
Download the free Sun Studio compilers for Solaris and Linux.


		7.1.13 Summary
Section 1.1 Introduction
• Software (i.e., the instructions you write to command computers to perform actions and make
decisions) controls computers (often referred to as hardware).
• C was standardized in 1989 in the United States through the American National Standards Institute
(ANSI) then worldwide through the International Standards Organization (ISO).
• Computer use is increasing in almost every field of endeavor. In an era of steadily rising costs,
computing costs have been decreasing dramatically due to rapid developments in both hardware
and software technologies. Computers that might have filled large rooms and cost millions of
dollars a few decades ago can now be inscribed on the surfaces of silicon chips smaller than a fingernail,
costing perhaps a few dollars each.
• Silicon-chip technology has made computing so economical that about a billion general-purpose
computers are in use worldwide.

Section 1.2 What Is a Computer?
• A computer is a device capable of performing computations and making logical decisions at
speeds billions of times faster than human beings can. Today’s fastest supercomputers can peform
trillions of additions per second. Trillion-instruction-per-second computers are already
functioning in research laboratories!
• Computers process data under the control of sets of instructions called computer programs.
These computer programs guide the computer through orderly sets of actions specified by people
called computer programmers.
• A computer is comprised of various devices (such as the keyboard, screen, mouse, disks, memory,
DVD, CD-ROM and processing units) that are referred to as hardware.
• The computer programs that run on a computer are referred to as software.
• Hardware costs have been declining dramatically in recent years, to the point that personal computers
have become commodities.

Section 1.3 Computer Organization
• Regardless of differences in physical appearance, virtually every computer may be envisioned as
being divided into six logical units.
• The input unit is the “receiving” section of the computer. It obtains information (data and computer
programs) from input devices and places this information at the disposal of the other units
so that the information can be processed.
• The output unit is the “shipping” section of the computer. It takes information that has been
processed by the computer and places it on various output devices to make the information available
for use outside the computer.
• The memory unit is the rapid-access, relatively low-capacity “warehouse” section of the computer.
It retains information that has been entered through the input unit, so the information may
be made available for processing when needed. The memory unit also retains processed information
until that it can be placed on output devices by the output unit. The memory unit is often
called either memory or primary memory.
• The arithmetic and logic unit (ALU) is the “manufacturing” section of the computer. It is responsible
for performing calculations such as addition, subtraction, multiplication and division.
It contains the decision mechanisms that allow the computer, for example, to compare two items
from the memory unit to determine whether they are equal.
• The central processing unit (CPU) is the “administrative” section of the computer. It is the computer’s
coordinator and is responsible for supervising the operation of the other sections. The
CPU tells the input unit when information should be read into the memory unit, tells the ALU
when information from the memory unit should be used in calculations and tells the output unit
when to send information from the memory unit to certain output devices.
• Many of today’s computers have multiple processing units and, hence, can perform many operations
simultaneously—such computers are called multiprocessors.
• The secondary storage unit is the long-term, high-capacity “warehousing” section of the computer.
Programs or data not actively being used by the other units normally are placed on secondary
storage devices (such as disks) until they are again needed. Information in secondary storage takes
much longer to access than information in primary memory, but the cost per unit of secondary
storage is much less than that of primary memory.

Section 1.4 Early Operating Systems
• Early computers were capable of performing only one job or task at a time. This form of computer
operation is often called single-user batch processing.
• Software systems called operating systems were developed to help make it more convenient to
use computers. Early operating systems managed the smooth transition between jobs. This minimized
the time it took for computer operators to switch between jobs and hence increased the
amount of work, or throughput, computers could process.
• As computers became more powerful, it became evident that single-user batch processing rarely
utilized computer resources efficiently, because most of the time was spent waiting for slow input/
output devices to complete their tasks. It was thought that many jobs or tasks could be made

to share the resources of the computer to achieve better utilization. This is called multitasking.
Multitasking involves the “simultaneous” operation of many jobs on the computer—the computer
shares its resources among the jobs competing for its attention.
• In the 1960s, several groups pioneered timesharing operating systems. Timesharing is a special
case of multitasking, in which users access the computer through terminals, typically devices with
keyboards and screens. In a typical timesharing computer system, dozens or even hundreds of
users, sharing the computer at once. The computer actually does not process all the users simultaneously.
Rather, it runs a small portion of one user’s job, then moves on to service the next user.
The computer does this so quickly that it may provide service to each user several times per second.
Thus, the users’ programs appear to be running simultaneously. An advantage of timesharing
is that the user receives almost immediate responses to requests rather than having to wait
long periods for results.

Section 1.5 Personal, Distributed and Client/Server Computing
• In 1977, Apple Computer popularized the phenomenon of personal computing.
• In 1981, IBM, the world’s largest computer vendor, introduced the IBM Personal Computer,
which quickly legitimized personal computing.
• Personal computers were “stand-alone” units—people did their work on their own computers,
then transported disks back and forth to share information (often called “sneakernet”).
• Although early personal computers were not powerful enough to timeshare several users, these
machines could be linked together in computer networks, sometimes over telephone lines and
sometimes in local area networks (LANs) within an organization. This led to the phenomenon
of distributed computing, in which an organization’s computing, instead of being performed
strictly at some central computer installation, is distributed over networks to the sites at which
the work of the organization is performed.
• Personal computers were powerful enough to handle the computing requirements of individual
users, and to handle the basic communications tasks of passing information between one another
electronically.
• Today’s personal computers are as powerful as the million-dollar machines of just few decades ago.
• The most powerful desktop machines—called workstations—provide individual users with
enormous capabilities.
• Today, information is shared easily across computer networks, where computers called file servers
offer a common store data that may be used by client computers distributed throughout the
network—hence the term client/server computing.

Section 1.6 Machine Languages, Assembly Languages and High-Level Languages
• Programmers write instructions in various programming languages, some directly understandable
by computers and others requiring intermediate translation steps.
• Hundreds of computer languages are in use today. These may be divided into three general
types—machine languages, assembly languages and high-level languages.
• Any computer can directly understand only its own machine language—the “natural language”
of a particular computer. Machine languages generally consist of strings of numbers (ultimately
reduced to 1s and 0s) that instruct computers to perform their most elementary operations, one
at a time. Machine languages are machine dependent (i.e., a particular machine language can be
used on only one type of computer). Such languages are cumbersome for humans.
• Machine-language programming was simply too slow and tedious for most programmers. Instead
of using the strings of numbers that computers could directly understand, programmers be-

gan using English-like abbreviations to represent elementary operations. These abbreviations
formed the basis of assembly languages. Translator programs called assemblers convert assemblylanguage
programs to machine language at computer speeds. Although assembly language is
clearer to humans, it is incomprehensible to computers until translated to machine language.
• Computer usage increased rapidly with the advent of assembly languages, but programming in
these languages still required many instructions to accomplish even the simplest tasks. To speed
the programming process, high-level languages were developed, in which single statements could
be written to accomplish substantial tasks. The translator programs that convert high-level language
programs into machine language are called compilers. High-level languages allow programmers
to write instructions that look almost like everyday English and contain commonly
used mathematical notations. C, C++ and Java are among the most powerful and most widely
used high-level programming languages.
• The process of compiling a high-level language program into machine language can take a considerable
amount of computer time. Interpreter programs were developed to execute high-level
language programs directly without the need for compiling those programs into machine language.
Although compiled programs execute much faster than interpreted programs, interpreters
are popular in program development environments, in which programs are recompiled frequently
as new features are added and errors are corrected. Once a program is developed, a compiled
version can be produced to run most efficiently.

Section 1.7 Fortran, COBOL, Pascal and Ada
• Fortran was developed by IBM Corporation in the 1950s to be used for scientific and engineering
applications that require complex mathematical computations.
• COBOL was developed in 1959 by computer manufacturers, the government and industrial
computer users. COBOL is used for commercial applications that require precise and efficient
manipulation of large amounts of data.
• Research activity in the 1960s resulted in the evolution of structured programming—a disciplined
approach to writing programs that are clearer than unstructured programs, easier to test
and debug and easier to modify.
• One of the more tangible results of this research was the development of the Pascal programming
language by Professor Niklaus Wirth in 1971. Pascal was designed for teaching structured programming
and rapidly became the preferred programming language in most colleges.
• The Ada programming language was developed under the sponsorship of the U.S. Department
of Defense (DOD) during the 1970s and early 1980s. Hundreds of separate languages were being
used to produce the DOD’s massive command-and-control software systems. The DOD
wanted a single language that would fill most of its needs. Ada was named after Lady Ada Lovelace,
daughter of the poet Lord Byron. Lady Lovelace is credited with writing the world’s first
computer program in the early 1800s (for the Analytical Engine mechanical computing device
designed by Charles Babbage). One important capability of Ada is called multitasking, which allows
programmers to specify that many activities are to occur in parallel.

Section 1.8 History of C
• C evolved from two previous languages, BCPL and B. BCPL was developed in 1967 by Martin
Richards as a language for writing operating systems software and compilers. Ken Thompson
modeled many features in his B language after their counterparts in BCPL and in 1970, at Bell
Laboratories used B to create early versions of the UNIX operating system on a DEC PDP-7
computer. Both BCPL and B were “typeless” languages—every data item occupied one “word”
in memory, and the burden of typing variables fell on the shoulders of the programmer.

• The C language was evolved from B by Dennis Ritchie at Bell Laboratories and was originally
implemented in 1972 on a DEC PDP-11 computer. C uses many of the important concepts of
BCPL and B while adding data typing and other powerful features.
• C initially became widely known as the development language of the UNIX operating system.
Today, virtually all new major operating systems are written in C and/or C++.
• C is available for most computers. C is also hardware independent. With careful design, it is possible
to write C programs that are portable to most computers.
• By the late 1970s, C had evolved into what is now referred to as “traditional C.” The publication
in 1978 of Kernighan and Ritchie’s book, The C Programming Language, drew wide attention to
the language.
• The rapid expansion of C over various types of computers (sometimes called hardware platforms)
led to many variations that were similar but often incompatible. This was a serious problem for
program developers, who needed to develop code that would run on several platforms. It became
clear that a standard version of C was needed.
• In 1983, the X3J11 technical committee was created under the American National Standards
Committee on Computers and Information Processing (X3) to “provide an unambiguous and
machine-independent definition of the language.” In 1989, the standard was approved; this standard
was updated in 1999. The standards document is referred to as INCITS/ISO/IEC 9899- 1999. Copies of this document may be ordered from the American National Standards Institute
(www.ansi.org) at webstore.ansi.org/ansidocstore.
• C99 is a revised standard for the C programming language that refines and expands the capabilities
of C. Although it has not been widely adopted, support for it is growing. Chapter 17 introduces
C99. The front part of this book is based on the widely adopted international Standard C.

Section 1.9 C Standard Library
• C programs consist of modules or pieces called functions. You can program all the functions you
need to form a C program, but most C programmers take advantage of a rich collection of existing
functions called the C Standard Library. Thus, there are really two pieces to learning how to
program in C. The first is learning the C language itself, and the second is learning how to use
the functions in the C Standard Library.
• When programming in C you will typically use C Standard Library functions, functions you create
yourself and functions other people have created and made available to you.
• The advantage of creating your own functions is that you will know exactly how they work. You
will be able to examine the C code. The disadvantage is the time-consuming effort that goes into
designing and developing new functions.
• If you use existing functions, you can avoid reinventing the wheel. In the case of the Standard C
functions, you know that they are carefully written, and you know that because you are using
functions that are available on virtually all Standard C implementations, your programs will have
a greater chance of being portable.

Section 1.10 C++
• C++ was developed by Bjarne Stroustrup at Bell Laboratories. It has its roots in C and provides
capabilities for object-oriented programming.
• Objects are essentially reusable software components that model items in the real world.
• Software developers are discovering that using a modular, object-oriented design and implementation
approach can make software development groups much more productive than is possible
with conventional programming techniques.

Section 1.11 Java
• Many people believe that the next major area in which microprocessors will have a profound impact
is that of intelligent consumer electronic devices. In 1991, recognizing this, Sun Microsystems
funded an internal corporate research project code-named Green. The project resulted in
the development of Java.
• The World Wide Web exploded in popularity in 1993, and Sun saw the immediate potential of
using Java to create web pages with dynamic content.
• Sun formally announced Java at a trade show in May 1995. Java generated immediate interest in
the business community because of the phenomenal interest in the World Wide Web. Java is
now used to create web pages with dynamic and interactive content, develop large-scale enterprise
applications, enhance the functionality of web servers (the computers that provide the content
we see in our web browsers), provide applications for consumer devices (such as cell phones,
pagers and personal digital assistants) and do many more things.

Section 1.12 BASIC, Visual Basic, Visual C++, Visual C# and .NET
• The BASIC (Beginner’s All-Purpose Symbolic Instruction Code) programming language was developed
in the mid-1960s by Professors John Kemeny and Thomas Kurtz of Dartmouth College
as a language for writing simple programs. BASIC’s primary purpose was to familiarize novices
with programming techniques.
• Visual Basic was introduced by Microsoft in 1991 to simplify the process of developing Microsoft
Windows applications.
• Visual Basic, Visual C++ and Visual C# are designed for Microsoft’s .NET programming platform.
All three languages make use of .NET’s powerful library of reusable software components
called the Framework Class Library (FCL).
• Comparably to Java, the .NET platform enables web-based applications to be distributed to
many devices (even cell phones) and to desktop computers. The C# programming language was
designed specifically for the .NET platform as a language that would enable programmers to migrate
easily to .NET.
• C++, Java and C# all have their roots in the C programming language.

Section 1.13 Key Software Trend: Object Technology
• Improvements to software technology started to appear, with the benefits of so-called structured
programming (and the related disciplines of structured systems analysis and design) being realized
in the 1970s. But until the 1990s, when the technology of object-oriented programming became
widely used, that software did developers finally feel they had the necessary tools for making
major strides in the software development process.
• Object technology dates back to the mid 1960s. The C++ programming language, developed at
AT&T by Bjarne Stroustrup in the early 1980s, is based on two languages—C and Simula 67, a
simulation programming language developed in Europe and released in 1967. C++ absorbed the
features of C and added Simula’s capabilities for creating and manipulating objects. Neither C
nor C++ was originally intended for wide use beyond the AT&T research laboratories. But grassroots
support rapidly developed for each.
• Object technology is a packaging scheme that enables programmers to create meaningful software
units.
• Before object-oriented languages appeared, programming languages (such as Fortran, Pascal, Basic
and C) were focussed on actions (verbs) rather than on things or objects (nouns). Now, with
the availability of popular object-oriented languages such as Java and C++, programmers continue
to live in an object-oriented world but can conveniently program in an object-oriented (noun-oriented) manner. This is a more natural process than procedural programming and has resulted
in significant productivity enhancements.
• A key problem with procedural programming is that the program units do not easily mirror realworld
entities effectively, so these units are not particularly reusable. It is not unusual for programmers
to “start fresh” on each new project and have to write similar software “from scratch.”
• With object technology, the software entities created (called classes), if properly designed, tend
to be much more reusable on future projects.
• Using libraries of reusable componentry can greatly reduce the amount of effort required to implement
certain kinds of systems.
• Object-oriented programming tends to produce software that is more understandable, better organized
and easier to maintain, modify and debug.

Section 1.14 Typical C Program Development Environment
• You create a program by editing a file with an editor program. Software packages for the C/C++
integrated program development environments such as Borland C++ Builder and Microsoft Visual
Studio have editors that are integrated into the programming environment.
• C program file names should end with the .c extension.
• Compilers translate programs into machine-language code (also referred to as object code).
• In a C system, a preprocessor program executes automatically before the compiler’s translation
phase begins. The C preprocessor obeys special commands called preprocessor directives, which
indicate that certain manipulations are to be performed on the program before compilation.
These manipulations usually consist of including other files in the file to be compiled and performing
various text replacements.
• C programs typically contain references to functions defined elsewhere, such as in the standard
libraries or in the private libraries of groups of programmers working on a particular project. The
object code produced by the C compiler typically contains “holes” due to these missing parts. A
linker links the object code with the code for the missing functions to produce an executable image
(with no missing pieces).
• Before a program can be executed, it must first be placed in memory. This is done by the loader,
which takes the executable image from disk and transfers it to memory. Additional components
from shared libraries that support the program are also loaded.
• The computer, under the control of its CPU, executes the program one instruction at a time.

Section 1.15 Hardware Trends
• Every year, people generally expect to pay at least a little more for most products and services.
The opposite has been the case in the computer and communications fields, especially with regard
to the costs of hardware supporting these technologies. For many decades, hardware costs
have fallen rapidly, if not precipitously.
• Every year or two, the capacities of computers have approximately doubled without any increase
in price. This often is called Moore’s Law, named after the person who first identified and explained
the trend, Gordon Moore, cofounder of Intel—the company that manufactures the vast
majority of the processors in today’s personal computers.
• Moore’s Law is especially true in relation to the amount of memory that computers have for programs,
the amount of secondary storage (such as disk storage) they have to hold programs and
data over longer periods of time, and their processor speeds—the speeds at which computers execute
their programs (i.e., do their work).
• Similar growth has occurred in the communications field, in which costs have plummeted as
enormous demand for communications bandwidth has attracted intense competition.

Section 1.16 History of the Internet
• In the late 1960s, ARPA—the Advanced Research Projects Agency of the Department of Defense—
rolled out the blueprints for networking the main computer systems of about a dozen
ARPA-funded universities and research institutions. The network quickly became called the
ARPAnet, the grandparent of today’s Internet.
• ARPAnet’s chief benefit proved to be its capability of quick and easy communication via what
came to be known as electronic mail (e-mail). This is true even today on the Internet, with e-mail
and related services facilitating communications of all kinds among nearly a billion people worldwide.
• The network operated with a technique called packet switching in, which digital data was sent
in small packages called packets. The packets contained data, address information, error-control
information and sequencing information. The address information was used to route the packets
of data to their destination. The sequencing information was used to help reassemble the packets
into their original order for presentation to the recipient. Packets of many people were intermixed
on the same lines. This packet-switching technique greatly reduced transmission costs as
compared to those of dedicated communications lines.
• The network was designed to operate without centralized control. This meant that if a portion
of the network should fail, the remaining working portions would still be able to route packets
from senders to receivers over alternate paths.
• The protocol for communicating over the ARPAnet became known as TCP—the Transmission
Control Protocol. TCP ensured that messages were properly routed from sender to receiver and
that they arrived intact.
• In parallel with the early evolution of the Internet, organizations worldwide were implementing
their own networks for both intraorganization and interorganization communication. A huge variety
of networking hardware and software appeared. One challenge was to get these to intercommunicate.
ARPA accomplished this with the development of IP—the Internetworking
Protocol), truly creating a “network of networks,” the current architecture of the Internet. The
combined set of protocols is now commonly called TCP/IP.
• Use of the Internet was limited at first to colleges and research institutions; then the military became
a big user. Eventually, the government decided to allow access to the Internet for commercial
purposes.
• Businesses rapidly realized that, by making effective use of the Internet, they could tune their operations
and offer new and better services to their clients, so they started spending vasts amounts
of money to develop and enhance the Internet. This generated fierce competition among the
communications carriers and the hardware and software suppliers to meet the demand. The result
is that bandwidth on the Internet has increased tremendously and costs have plummeted.

Section 1.17 History of the World Wide Web
• The World Wide Web allows computer users to locate and view over the Internet multimediabased
documents on almost any subject. Even though the Internet was developed more than
three decades ago, the introduction of the World Wide Web was a relatively recent event. In 1990, Tim Berners-Lee of CERN (the European Laboratory for Particle Physics) developed the
World Wide Web and several communication protocols that form its backbone.
• The Internet and the World Wide Web will surely be listed among the most important and profound
creations of humankind. 
• Today’s applications can be written to communicate among the world’s hundreds of millions of
computers. The Internet mixes computing and communications technologies. It makes our
work easier. It makes information instantly and conveniently accessible worldwide. It enables individuals
and small businesses to get worldwide exposure. It is changing the way business is done.
People can search for the best prices on virtually any product or service. Special-interest communities
can stay in touch with one another. Researchers can be made instantly aware of the latest
breakthroughs worldwide.

		7.1.14

	7.2 Introduction
to C
Programming
OBJECTIVES
In this chapter, you will learn
■ To write simple computer programs in C.
■ To use simple input and output statements.
■ The fundamental data types.
■ Computer memory concepts.
■ To use arithmetic operators.
■ The precedence of arithmetic operators.
■ To write simple decision-making statements.

Note, my source code examples are in: /cygdrive/c/work/code/C/CHowToProgramm5thEd/

		7.2.1 Introduction
The C language facilitates a structured and disciplined approach to computer program design.
In this chapter we introduce C programming and present several examples that illustrate
many important features of C. Each example is carefully analyzed, one statement at
a time. In Chapters 3 and 4 we present an introduction to structured programming in C.
We then use the structured approach throughout the remainder of the text.

		7.2.2 A Simple C Program: Printing a Line of Text
C uses some notations that may appear strange to people who have not programmed computers.
We begin by considering a simple C program. Our first example prints a line of
text. The program and the program’s screen output are shown in Fig. 2.1.
Even though this program is simple, it illustrates several important features of the C
language.

/* Fig. 2.1: fig02_01.c
A first program in C */
#include <stdio.h>

/* function main begins program execution */
int main( void )
{
printf( "Welcome to C!\n" );

 return 0; /* indicate that program ended successfully */

 } /* end function main */

<URL:/cygdrive/c/work/code/C/CHowToProgramm5thEd/hello_world.c>

We now consider each line of the program in detail. Lines 1 and 2
/* Fig. 2.1: fig02_01.c
A first program in C */
begin with /* and end with */ indicating that these two lines are a comment. You insert
comments to document programs and improve program readability. Comments do not
cause the computer to perform any action when the program is run. Comments are ignored by the C compiler and do not cause any machine-language object code to be
generated. The preceding comment simply describes the figure number, file name and
purpose of the program. Comments also help other people read and understand your program,
but too many comments can make a program difficult to read.

Common Programming Error 2.1
Forgetting to terminate a comment with */. 2.1
Common Programming Error 2.2
Starting a comment with the characters */ or ending a comment with the characters /*. 2.2
*/

Line 3
#include <stdio.h>
is a directive to the C preprocessor. Lines beginning with # are processed by the preprocessor
before the program is compiled. Line 3 tells the preprocessor to include the contents
of the standard input/output header (<stdio.h>) in the program. This header contains
information used by the compiler when compiling calls to standard input/output library
functions such as printf.We explain the contents of headers in more detail in Chapter 5.


Line 6
int main( void )
is a part of every C program. The parentheses after main indicate that main is a program
building block called a function. C programs contain one or more functions, one of which
must be main. Every program in C begins executing at the function main. Functions can
return information. The keyword int to the left of main indicates that main “returns” an
integer (whole number) value. We will explain what it means for a function to “return a
value” when we demonstrate how to create your own functions in Chapter 5, C Functions.
For now, simply include the keyword int to the left of main in each of your programs.
Functions also can receive information when they are called upon to execute. The void in
parentheses here means that main does not receive any information. In Chapter 14, Other
C Topics, we’ll show an example of main receiving information.

Good Programming Practice 2.1
Every function should be preceded by a comment describing the purpose of the function. 2.1
A left brace, {, begins the body of every function (line 7). A corresponding right brace
ends each function (line 12). This pair of braces and the portion of the program between
the braces is called a block. The block is an important program unit in C.


Line 8
printf( "Welcome to C!\n" );
instructs the computer to perform an action, namely to print on the screen the string of
characters marked by the quotation marks. A string is sometimes called a character string,
a message or a literal. The entire line, including printf, its argument within the paren-theses and the semicolon (;), is called a statement. Every statement must end with a semicolon
(also known as the statement terminator). When the preceding printf statement
is executed, it prints the message Welcome to C! on the screen. The characters normally
print exactly as they appear between the double quotes in the printf statement. Notice
that the characters \n were not printed on the screen. The backslash (\) is called an escape
character. It indicates that printf is supposed to do something out of the ordinary. When
encountering a backslash in a string, the compiler looks ahead at the next character and
combines it with the backslash to form an escape sequence. The escape sequence \n means
newline. When a newline appears in the string output by a printf, the newline causes the
cursor to position to the beginning of the next line on the screen. Some common escape
sequences are listed in Fig. 2.2.


The last two escape sequences in Fig. 2.2 may seem strange. Because the backslash has
special meaning in a string, i.e., the compiler recognizes it as an escape character, we use a
double backslash (\\) to place a single backslash in a string. Printing a double quote also
presents a problem because double quotes mark the boundary of a string—such quotes are
not printed. By using the escape sequence \" in a string to be output by printf, we indicate
that printf should display a double quote.


Line 10
return 0; /* indicate that program ended successfully */
is included at the end of every main function. The keyword return is one of several means
we will use to exit a function. When the return statement is used at the end of main as
shown here, the value 0 indicates that the program has terminated successfully. In
Chapter 5 we discuss functions in detail, and the reasons for including this statement will
become clear. For now, simply include this statement in each program, or the compiler
might produce a warning on some systems. The right brace, }, (line 12) indicates that the
end of main has been reached.


Good Programming Practice 2.2
Add a comment to the line containing the right brace, }, that closes every function, including
main. 2.2
We said that printf causes the computer to perform an action. As any program
executes, it performs a variety of actions and makes decisions. At the end of this chapter,


Escape sequence Description
\n Newline. Position the cursor at the beginning of the next line.
\t Horizontal tab. Move the cursor to the next tab stop.
\a Alert. Sound the system bell.
\\ Backslash. Insert a backslash character in a string.
\" Double quote. Insert a double-quote character in a string.

we discuss decision making. In Chapter 3, we discuss this action/decision model of programming
in depth.

Common Programming Error 2.3
Typing the name of the output function printf as print in a program. 

It is important to note that standard library functions like printf and scanf are not
part of the C programming language. For example, the compiler cannot find a spelling
error in printf or scanf.When the compiler compiles a printf statement, it merely provides
space in the object program for a “call” to the library function. But the compiler does
not know where the library functions are—the linker does. When the linker runs, it locates
the library functions and inserts the proper calls to these library functions in the object
program. Now the object program is complete and ready to be executed. For this reason,
the linked program is called an executable. If the function name is misspelled, it is the
linker which will spot the error, because it will not be able to match the name in the C
program with the name of any known function in the libraries.


Good Programming Practice 2.3
The last character printed by a function that displays output should be a newline (\n). This ensures
that the function will leave the screen cursor positioned at the beginning of a new line. Conventions
of this nature encourage software reusability—a key goal in software development environments. 

Good Programming Practice 2.4
Indent the entire body of each function one level of indentation (we recommend three spaces)
within the braces that define the body of the function. This indentation emphasizes the functional
structure of programs and helps make programs easier to read. 

Good Programming Practice 2.5
Set a convention for the size of indent you prefer and then uniformly apply that convention. The
tab key may be used to create indents, but tab stops may vary. We recommend using three spaces
per level of indent. 

The printf function can print Welcome to C! several different ways. For example, the
program of Fig. 2.3 produces the same output as the program of Fig. 2.1. This works
because each printf resumes printing where the previous printf stopped printing. The
first printf (line 8) prints Welcome followed by a space and the second printf (line 9)
begins printing on the same line immediately following the space.
One printf can print several lines by using additional newline characters as in
Fig. 2.4. Each time the \n (newline) escape sequence is encountered, output continues at
the beginning of the next line.

/* function main begins program execution */
int main( void )
{


 return 0; /* indicate that program ended successfully */

 } /* end function main */

Welcome to C!


/* Fig. 2.4: fig02_04.c
Printing multiple lines with a single printf */
#include <stdio.h>

/* function main begins program execution */
int main( void )
{
printf( "Welcome to C!\n" );

 return 0; /* indicate that program ended successfully */

 } /* end function main */

Welcome
to
C!

		7.2.3 Another Simple C Program: Adding Two Integers

Our next program uses the Standard Library function scanf to obtain two integers typed
by a user at the keyboard, computes the sum of these values and prints the result using
printf. The program and sample output are shown in Fig. 2.5. [Note that in the input/
output dialog of Fig. 2.5, we highlight the numbers input by the user.]
The comment in lines 1–2 states the purpose of the program. As we stated earlier,
every program begins execution with main. The left brace { (line 7) marks the beginning
of the body of main and the corresponding right brace } (line 24) marks the end of main.

Lines 8–10
int integer1; /* first number to be input by user */
int integer2; /* second number to be input by user */
int sum; /* variable in which sum will be stored */

are definitions. The names integer1, integer2 and sum are the names of variables. A
variable is a location in memory where a value can be stored for use by a program. These
definitions specify that the variables integer1, integer2 and sum are of type int, which
means that these variables will hold integer values, i.e., whole numbers such as 7, –11, 0,
31914 and the like. All variables must be defined with a name and a data type immediately
after the left brace that begins the body of main before they can be used in a program.
There are other data types besides int in C. Note that the preceding definitions could have
been combined into a single definition statement as follows:
int integer1, integer2, sum;
A variable name in C is any valid identifier. An identifier is a series of characters consisting
of letters, digits and underscores ( _ ) that does not begin with a digit. An identifier
can be of any length, but only the first 31 characters are required to be recognized by C
compilers according to the C standard. C is case sensitive—uppercase and lowercase letters
are different in C, so a1 and A1 are different identifiers.

Common Programming Error 2.4
Using a capital letter where a lowercase letter should be used (for example, typing Main instead
of main).


		7.2.4 Memory Concepts
Variable names such as integer1, integer2 and sum actually correspond to locations in
the computer’s memory. Every variable has a name, a type and a value.
In the addition program of Fig. 2.5, when the statement (line 13)
scanf( "%d", &integer1 ); /* read an integer */
is executed, the value typed by the user is placed into a memory location to which the
name integer1 has been assigned. Suppose the user enters the number 45 as the value for
integer1. The computer will place 45 into location integer1 as shown in Fig. 2.6.
Whenever a value is placed in a memory location, the value replaces the previous value
in that location; thus, placing a new value into a memory location is said to be destructive.
Returning to our addition program again, when the statement (line 16)
scanf( "%d", &integer2 ); /* read an integer */
is executed, suppose the user enters the value 72. This value is placed into location integer2,
and memory appears as in Fig. 2.7. Note that these locations are not necessarily
adjacent in memory.
Once the program has obtained values for integer1 and integer2, it adds these
values and places the sum into variable sum. The statement (line 18)
sum = integer1 + integer2; /* assign total to sum */
that performs the addition also replaces whatever value was stored in sum. This occurs
when the calculated sum of integer1 and integer2 is placed into location sum (destroying
the value already in sum). After sum is calculated, memory appears as in Fig. 2.8. Note that
the values of integer1 and integer2 appear exactly as they did before they were used in
the calculation of sum. These values were used, but not destroyed, as the computer performed
the calculation. Thus, when a value is read from a memory location, the process is
said to be nondestructive

		7.2.5 Arithmetic in C
Most C programs perform arithmetic calculations. The C arithmetic operators are summarized
in Fig. 2.9. Note the use of various special symbols not used in algebra. The asterisk
(*) indicates multiplication and the percent sign (%) denotes the remainder
operator, which is introduced below. In algebra, if we want to multiply a times b, we can
simply place these single-letter variable names side by side as in ab. In C, however, if we
were to do this, ab would be interpreted as a single, two-letter name (or identifier). Therefore,
C (and other programming languages, in general) require that multiplication be explicitly
denoted by using the * operator as in a * b.
The arithmetic operators are all binary operators. For example, the expression 3 + 7
contains the binary operator + and the operands 3 and 7.
Integer division yields an integer result. For example, the expression 7 / 4 evaluates
to 1 and the expression 17 / 5 evaluates to 3. C provides the remainder operator, %, which
yields the remainder after integer division. The remainder operator is an integer operator
that can be used only with integer operands. The expression x % y yields the remainder
after x is divided by y. Thus, 7 % 4 yields 3 and 17 % 5 yields 2. We will discuss many interesting
applications of the remainder operator.

Fig. 2.8 | Memory locations after a calculation.
C operation Arithmetic operator Algebraic expression C expression
Addition + f + 7 f + 7
Subtraction – p – c p - c
Multiplication * bm b * m
Division / x / y or or x ÷ y x / y
Remainder % r mod s r % s

Common Programming Error 2.15
An attempt to divide by zero is normally undefined on computer systems and generally results in
a fatal error, i.e., an error that causes the program to terminate immediately without having successfully
performed its job. Nonfatal errors allow programs to run to completion, often producing
incorrect results. 2.15


Arithmetic Expressions in Straight-Line Form
Arithmetic expressions in C must be written in straight-line form to facilitate entering
programs into the computer. Thus, expressions such as “a divided by b” must be written
as a/b so that all operators and operands appear in a straight line. The algebraic notation
is generally not acceptable to compilers, although some special-purpose software packages
do exist that support more natural notation for complex mathematical expressions.
Parentheses for Grouping Subexpressions
Parentheses are used in C expressions in the same manner as in algebraic expressions. For
example, to multiply a times the quantity b + c we write a * ( b + c ).


Rules of Operator Precedence
C applies the operators in arithmetic expressions in a precise sequence determined by the
following rules of operator precedence, which are generally the same as those in algebra:
a. Operators in expressions contained within pairs of parentheses are evaluated first.
Thus, parentheses may be used to force the order of evaluation to occur in any sequence
desired by the programmer. Parentheses are said to be at the “highest level of precedence.”
In cases of nested, or embedded, parentheses, such as
( ( a + b ) + c )
the operators in the innermost pair of parentheses are applied first.
b. Multiplication, division and remainder operations are applied first. If an expression
contains several multiplication, division and remainder operations, evaluation
proceeds from left to right. Multiplication, division and remainder are
said to be on the same level of precedence.
c. Addition and subtraction operations are evaluated next. If an expression contains
several addition and subtraction operations, evaluation proceeds from left to right.
Addition and subtraction also have the same level of precedence, which is lower
than the precedence of the multiplication, division and remainder operations.
The rules of operator precedence specify the order C uses to evaluate expressions.
When we say evaluation proceeds from left to right, we are referring to the associativity of
the operators. We will see that some operators associate from right to left. Figure 2.10
summarizes these rules of operator precedence.

Sample Algebraic and C Expressions
Now let us consider several expressions in light of the rules of operator precedence. Each
example lists an algebraic expression and its C equivalent. The following example calculates
the arithmetic mean (average) of five terms:

		7.2.6 Decision Making: Equality and Relational Operators

	7.3

	7.40 Source code examples

		7.40.1  loops

			7.40.1.1  Average
/*
 * =====================================================================================
 *
 *       Filename:  average.c
 *
 *    Description:  calculate average using sentinel controlled repetition
 *
 *        Version:  1.0
 *        Created:  08/21/11 10:03:34
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Yosi Izaq (), yizaq@cisco.com
 *        Company:  CISCO
 *
 * =====================================================================================
 */


#include	<stdlib.h>
#include	<stdio.h>

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  main
 *  Description:  
 * =====================================================================================
 */
	int
main ( int argc, char *argv[] )
{
	int counter = 0;
	int total = 0;
	int grade = 0;
	float average = 0;


	printf ("Please enter grade. -1 to end.\n");
	scanf("%d", &grade);

	while (grade != -1) //sentinel controlled loop. For countr controlled loop use (counter <= value) logic for example
	{
		counter++;
		total+=grade;


		printf ("Please enter grade. -1 to end.\n");
		scanf("%d", &grade);

	}

	if (counter>0 ) 
	{
		average = (float) total/counter; //cast to float to prevent truncation
	}
	else //avoid division by zero
	{
		average = 0;
	}
	printf("You entered %d grades. Average is %.4f\n",counter, average); //print average with four digits of precision

	return EXIT_SUCCESS;
}				/* ----------  end of function main  ---------- */

Run:
[yizaq@yizaq-WS:Sun Aug 21:/cygdrive/c/work/code/C/CHowToProgramm5thEd:]$ sed -ie '1s/^\xef\xbb\xbf//'  average.c
[yizaq@yizaq-WS:Sun Aug 21:/cygdrive/c/work/code/C/CHowToProgramm5thEd:]$ gcc average.c 
average.c: In function `main':
average.c:55: error: expected `;' before `}' token
[yizaq@yizaq-WS:Sun Aug 21:/cygdrive/c/work/code/C/CHowToProgramm5thEd:]$ gcc average.c 
[yizaq@yizaq-WS:Sun Aug 21:/cygdrive/c/work/code/C/CHowToProgramm5thEd:]$ a.exe 
Please enter grade. -1 to end.
4
Please enter grade. -1 to end.
2
Please enter grade. -1 to end.
6
Please enter grade. -1 to end.
-1
You entered 3 grades. Average is 4.000000[yizaq@yizaq-WS:Sun Aug 21:/cygdrive/c/work/code/C/CHowToProgramm5thEd:]$ a.exe 
Please enter grade. -1 to end.
-1
You entered 0 grades. Average is 0.000000[yizaq@yizaq-WS:Sun Aug 21:/cygdrive/c/work/code/C/CHowToProgramm5thEd:]$ 

			7.40.1.2
		7.40.2 Operators

			7.40.2.1 Pre and Post increment
Post increment will first use original value, then increment
Pre increment will first increment then use incremented value, 
/*
 * =====================================================================================
 *
 *       Filename:  pre_post_increment.c
 *
 *    Description:  demonstrates pre & post increment operators
 *
 *        Version:  1.0
 *        Created:  08/21/11 14:36:33
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Yosi Izaq (), yizaq@cisco.com
 *        Company:  CISCO
 *
 * =====================================================================================
 */

#include	<stdlib.h>
#include	<stdio.h>

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  main
 *  Description:  
 * =====================================================================================
 */
	int
main ( int argc, char *argv[] )
{
	int var = 5;

	//Post increment
	printf("Var is: %d\n",var);
	printf("Var is: %d\n",var++);
	printf("Var is: %d\n",var);

	var = 5;
	//Pre increment
	printf("Var is: %d\n",var);
	printf("Var is: %d\n",++var);
	printf("Var is: %d\n",var);

	return EXIT_SUCCESS;
}				/* ----------  end of function main  ---------- */
sed -ie '1s/^\xef\xbb\xbf//'  pre_post_increment.c
[yizaq@yizaq-WS:Sun Aug 21:/cygdrive/c/work/code/C/CHowToProgramm5thEd:]$ gcc pre_post_increment.c 
[yizaq@yizaq-WS:Sun Aug 21:/cygdrive/c/work/code/C/CHowToProgramm5thEd:]$ a.exe 
Var is: 5
Var is: 5
Var is: 6
Var is: 5
Var is: 6
Var is: 6

			7.40.2.2

		7.40.3
	7.41
8. FAQS

	8.1 Compilation errors


		8.1.1 UTF8 BOM, or stray error 
[yizaq@yizaq-WS:Sun Aug 21:/cygdrive/c/work/code/C/CHowToProgramm5thEd:]$ gcc average.c 
average.c:1: error: stray `\357' in program
average.c:1: error: stray `\273' in program
average.c:1: error: stray `\277' in program


To fix, remove BOM. A few recepies:
awk '{if(NR==1)sub(/^\xef\xbb\xbf/,"");print}' average.c  > average1.c

g++ -x c++ <(xxd -g 1 -s 3 test.cpp | xxd -g 1 -s -3 -r) -o a.out

sed -ie '1s/^\xef\xbb\xbf//' text.txt

utf8bom(1) - Linux man page

Name

utf8bom - handling Byte Order Mark for UTF-8 files.

Synopsis

utf8bom [options]

utf8bom -insert -dir /path/to/dir -recursive

utf8bom -strip -file /path/to/file
		8.1.2

	8.2 Files


		8.2.1  How can I get a file's size in C? 

-> My answer:
cat /cygdrive/c/work/code/C/calculateFileSize.c

/*
 * =====================================================================================
 *
 *       Filename:  calculateFileSize.c
 *
 *    Description:  
 *
 *        Version:  1.0
 *        Created:  12/18/11 11:40:23
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Yosi Izaq (), yizaq@cisco.com
 *        Company:  CISCO
 *
 * =====================================================================================
 */
#include <stdio.h>
#include <sys/stat.h>

int main(void)
{

   FILE *fp;
   char filename[80];
   long length;

   printf("input file name:");
   gets(filename);
   fp=fopen(filename,"rb");

   if(fp==NULL) {
      printf("file not found!\n");
   }
   else {
      fseek(fp,0L,SEEK_END);
      length=ftell(fp);
      printf("the file's length using fseek is %1dB\n",length);
      fseek(fp,0L,SEEK_SET);
      fclose(fp);

	struct stat st;
	stat(filename, &st);
	unsigned int size = st.st_size;
       printf("the file's length using stat is %1dB\n",size);
   }

   return 0;
}


[yizaq@yizaq-WS:Sun Dec 18:/cygdrive/c/work/code/C:]$ ./a.exe 
input file name:calculateFileSize.c
the file's length using fseek is 1029B
the file's length using stat is 1029B

-> You need to seek to the end of the file and then ask for the position:

fseek(fp, 0L, SEEK_END);
sz = ftell(fp);

You can then seek back to the beginning:

fseek(fp, 0L, SEEK_SET);

	
answered Oct 26 '08 at 20:57
Rob Walker
| 18.8k14179
	
25 	 
	
If you use ftell, then you must open the file in binary mode. If you open it in text mode, ftell only returns a "cookie" that is only usable by fseek. – camh Oct 27 '08 at 10:14
2 	 
	
@camh - Thanks man. This comment solved a problem I had with a file sizing algorithm. For the record, one opens a file in binary mode by putting a 'b' at the end of fopen's mode string. – T.E.D. May 18 '10 at 10:42
	
LOL, yeah right, Windows inherited this stupid text/binary mode nonsense from DOS. This is easily forgotten nowadays. Actually the POSIX standard even mandates that any POSIX system must be able to cope with the "b" flag in fopen calls (to be compatible with the C standard!), but on the same hand it mandates, that the implementation must ignore it entirely, since this flag has no effect on POSIX systems (those don't know any such thing as a text mode and always open in binary mode). – Mecki Sep 9 at 17:46
1 	 
	
Yo uh, use rewind before people forget what it means – bobobobo Sep 23 at 16:55

-> 
There are two basic methods:

fseek(f, 0, SEEK_END); // seek to end of file
size = ftell(f); // get current file pointer
fseek(f, 0, SEEK_SET); // seek back to beginning of file
// proceed with allocating memory and reading the file

Or, you can use stat, if you know the filename:

struct stat st;
stat(filename, &st);
size = st.st_size;

-> 
#include <stdio.h>

int main(void)
{

   FILE *fp;
   char filename[80];
   long length;

   printf("input file name:");
   gets(filename);
   fp=fopen(filename,"rb");

   if(fp==NULL) {
      printf("file not found!\n");
   }
   else {
      fseek(fp,OL,SEEK_END);
      length=ftell(fp);
      printf("the file's length is %1dB\n",length);
      fclose(fp);
   }

   return 0;
}

- 



		8.2.2  Read from file

			8.2.2.1  Read from file line by line

#define _GNU_SOURCE
   #include <stdio.h>
   #include <stdlib.h>

   int
   main(void)
   {
       FILE * fp;
       char * line = NULL;
       size_t len = 0;
       ssize_t read;

       fp = fopen("/etc/motd", "r");
       if (fp == NULL)
           exit(EXIT_FAILURE);

       while ((read = getline(&line, &len, fp)) != -1) {
           printf("Retrieved line of length %zu :\n", read);
           printf("%s", line);
       }

       fclose(fp);
       if (line)
           free(line);
       exit(EXIT_SUCCESS);
   }
		8.2.3 Read from file char by char
#include <stdio.h>
#include <stdlib.h>
 
int main()
{
   char ch, file_name[25];
   FILE *fp;
 
   printf("Enter the name of file you wish to see\n");
   gets(file_name);
 
   fp = fopen(file_name,"r"); // read mode
 
   if( fp == NULL )
   {
      perror("Error while opening the file.\n");
      exit(EXIT_FAILURE);
   }
 
   printf("The contents of %s file are :\n", file_name);
 
   while( ( ch = fgetc(fp) ) != EOF )
      printf("%c",ch);
 
   fclose(fp);
   return 0;
}

		8.2.4 function <cstdio> fscanf
int fscanf ( FILE * stream, const char * format, ... );
Read formatted data from stream
Reads data from the stream and stores them according to the parameter format into the locations pointed by the additional arguments.

The additional arguments should point to already allocated objects of the type specified by their corresponding format specifier within the format string.

Parameters
stream
Pointer to a FILE object that identifies the input stream to read data from.
format
C string that contains a sequence of characters that control how characters extracted from the stream are treated:
Whitespace character: the function will read and ignore any whitespace characters encountered before the next non-whitespace character (whitespace characters include spaces, newline and tab characters -- see isspace). A single whitespace in the format string validates any quantity of whitespace characters extracted from the stream (including none).
Non-whitespace character, except format specifier (%): Any character that is not either a whitespace character (blank, newline or tab) or part of a format specifier (which begin with a % character) causes the function to read the next character from the stream, compare it to this non-whitespace character and if it matches, it is discarded and the function continues with the next character of format. If the character does not match, the function fails, returning and leaving subsequent characters of the stream unread.
Format specifiers: A sequence formed by an initial percentage sign (%) indicates a format specifier, which is used to specify the type and format of the data to be retrieved from the stream and stored into the locations pointed by the additional arguments.

A format specifier for fscanf follows this prototype:

%[*][width][length]specifier 

Where the specifier character at the end is the most significant component, since it defines which characters are extracted, their interpretation and the type of its corresponding argument:
specifier	Description	Characters extracted
i, u	Integer	Any number of digits, optionally preceded by a sign (+ or -).
Decimal digits assumed by default (0-9), but a 0 prefix introduces octal digits (0-7), and 0x hexadecimal digits (0-f).
d	Decimal integer	Any number of decimal digits (0-9), optionally preceded by a sign (+ or -).
o	Octal integer	Any number of octal digits (0-7), optionally preceded by a sign (+ or -).
x	Hexadecimal integer	Any number of hexadecimal digits (0-9, a-f, A-F), optionally preceded by 0x or 0X, and all optionally preceded by a sign (+ or -).
f, e, g	Floating point number	A series of decimal digits, optionally containing a decimal point, optionally preceeded by a sign (+ or -) and optionally followed by the e or E character and a decimal integer (or some of the other sequences supported by strtod).
Implementations complying with C99 also support hexadecimal floating-point format when preceded by 0x or 0X.
a
c	Character	The next character. If a width other than 1 is specified, the function reads exactly width characters and stores them in the successive locations of the array passed as argument. No null character is appended at the end.
s	String of characters	Any number of non-whitespace characters, stopping at the first whitespace character found. A terminating null character is automatically added at the end of the stored sequence.
p	Pointer address	A sequence of characters representing a pointer. The particular format used depends on the system and library implementation, but it is the same as the one used to format %p in fprintf.
[characters]	Scanset	Any number of the characters specified between the brackets.
A dash (-) that is not the first character may produce non-portable behavior in some library implementations.
[^characters]	Negated scanset	Any number of characters none of them specified as characters between the brackets.
n	Count	No input is consumed.
The number of characters read so far from stream is stored in the pointed location.
%	%	A % followed by another % matches a single %.
Except for n, at least one character shall be consumed by any specifier. Otherwise the match fails, and the scan ends there.

The format specifier can also contain sub-specifiers: asterisk (*), width and length (in that order), which are optional and follow these specifications:
sub-specifier	description
*	An optional starting asterisk indicates that the data is to be read from the stream but ignored (i.e. it is not stored in the location pointed by an argument).
width	Specifies the maximum number of characters to be read in the current reading operation (optional).
length	One of hh, h, l, ll, j, z, t, L (optional).
This alters the expected type of the storage pointed by the corresponding argument (see below).

This is a chart showing the types expected for the corresponding arguments where input is stored (both with and without a length sub-specifier):
specifiers
length	d i	u o x	f e g a	c s [] [^]	p	n
(none)	int*	unsigned int*	float*	char*	void**	int*
hh	signed char*	unsigned char*				signed char*
h	short int*	unsigned short int*				short int*
l	long int*	unsigned long int*	double*	wchar_t*		long int*
ll	long long int*	unsigned long long int*				long long int*
j	intmax_t*	uintmax_t*				intmax_t*
z	size_t*	size_t*				size_t*
t	ptrdiff_t*	ptrdiff_t*				ptrdiff_t*
L			long double*			
Note: Yellow rows indicate specifiers and sub-specifiers introduced by C99.
... (additional arguments)
Depending on the format string, the function may expect a sequence of additional arguments, each containing a pointer to allocated storage where the interpretation of the extracted characters is stored with the appropriate type.
There should be at least as many of these arguments as the number of values stored by the format specifiers. Additional arguments are ignored by the function.
These arguments are expected to be pointers: to store the result of a fscanf operation on a regular variable, its name should be preceded by the reference operator (&) (see example).

Return Value
On success, the function returns the number of items of the argument list successfully filled. This count can match the expected number of items or be less (even zero) due to a matching failure, a reading error, or the reach of the end-of-file.

If a reading error happens or the end-of-file is reached while reading, the proper indicator is set (feof or ferror). And, if either happens before any data could be successfully read, EOF is returned.

If an encoding error happens interpreting wide characters, the function sets errno to EILSEQ.

Example
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
/* fscanf example */
#include <stdio.h>

int main ()
{
  char str [80];
  float f;
  FILE * pFile;

  pFile = fopen ("myfile.txt","w+");
  fprintf (pFile, "%f %s", 3.1416, "PI");
  rewind (pFile);
  fscanf (pFile, "%f", &f);
  fscanf (pFile, "%s", str);
  fclose (pFile);
  printf ("I have read: %f and %s \n",f,str);
  return 0;
}
Edit & Run


This sample code creates a file called myfile.txt and writes a float number and a string to it. Then, the stream is rewinded and both values are read with fscanf. It finally produces an output similar to:
I have read: 3.141600 and PI

Compatibility
Particular library implementations may support additional specifiers and sub-specifiers.
Those listed here are supported by the latest C and C++ standards (both published in 2011), but those in yellow were introduced by C99 (only required for C++ implementations since C++11), and may not be supported by libraries that comply with older standards.

See also
scanf
Read formatted data from stdin (function )
fprintf
Write formatted data to stream (function )
fread
Read block of data from stream (function )
fgets
Get string from stream (function )
	8.3 List & calculate size of files in given directory
/*
 * =====================================================================================
 *
 *       Filename:  glob_ex.c
 *
 *    Description:  
 *
 *        Version:  1.0
 *        Created:  02/23/12 16:10:26
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Yosi Izaq (), yizaq@cisco.com
 *        Company:  CISCO
 *
 * =====================================================================================
 */
#include <dirent.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <inttypes.h>

  typedef unsigned long long	uint64_t;

int  main()
{
	DIR *dir;
	struct dirent *ent;
	dir = opendir (".");
	if (dir != NULL) {

	  /* print all the files and directories within directory */
	  while ((ent = readdir (dir)) != NULL) {
	    printf ("%s: len %d, type: %s.\n", ent->d_name, strlen(ent->d_name) , (ent->d_name+strlen(ent->d_name) -3)  );
	    if (!strcmp ((const char *)( ent->d_name+strlen(ent->d_name) -3) , "txt") )
	    {
		    int result = 0;
		    struct stat64 statbuff;
		    result = stat64 (ent->d_name, &statbuff);
		    uint64_t size = statbuff.st_size;

		    printf("Found txt file. Size: %llu \n",size); 
	    }

	  }
	  closedir (dir);
	} else {
	  /* could not open directory */
	  perror ("");
	  return 1;
	}

	return 0;
} 

		8.3.1 


	8.4 pointers to pointers

		8.4.1  Use cases
Functions that modify a pointer parameter. Ex: allocate memory and return pointer to newly allocated memory.
Pass pointer to string (char * in native C)

		8.4.2

	8.5
9. Network programming

	9.1  IPv4 TCP Client

The distinction between client and server is important because each uses the sockets interface differently at certain steps in the communication. We first focus on the client. Its job is to initiate communication with a server that is passively waiting to be contacted.

The typical TCP client’s communication involves four basic steps:
| 1.  Create a TCP socket using socket().
| 
| 2.  Establish a connection to the server using connect().
| 
| 3.  Communicate using send and recv().
| 
| 4.  Close the connection with close().

TCPEchoClient4.c is an implementation of a TCP echo client for IPv4.

TCPEchoClient4.c

 1  #include <stdio.h>
 2  #include <stdlib.h>
 3  #include <string.h>
 4  #include <unistd.h>
 5  #include <sys/types.h>
 6  #include <sys/socket.h>
 7  #include <netinet/in.h>
 8  #include <arpa/inet.h>
 9  #include "Practical.h"
10
11  int main(int argc, char *argv[]) {
12
13    if (argc < 3 ||  argc > 4) // Test for correct number of arguments
14      DieWithUserMessage("Parameter(s)",
15          "<Server Address> <Echo Word> [<Server Port>]");
16
17    char *servIP = argv[1];     // First arg: server IP address (dotted quad)
18    char *echoString = argv[2]; // Second arg: string to echo
19
20    // Third arg (optional): server port (numeric).  7 is well-known echo port
21    in_port_t servPort = (argc == 4) ? atoi(argv[3]) : 7;
22
23    // Create a reliable, stream socket using TCP
24    int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
25    if (sock < 0)
26      DieWithSystemMessage("socket() failed");
27
28    // Construct the server address structure
29    struct sockaddr_in servAddr;            // Server address
30    memset(&servAddr, 0, sizeof(servAddr)); // Zero out structure
31    servAddr.sin_family = AF_INET;          // IPv4 address family
32    // Convert address
33    int rtnVal = inet_pton(AF_INET, servIP, &servAddr.sin_addr.s_addr);
34    if (rtnVal == 0)
35      DieWithUserMessage("inet_pton() failed", "invalid address string");
36    else if (rtnVal < 0)
37      DieWithSystemMessage("inet_pton() failed");
38    servAddr.sin_port = htons(servPort);    // Server port
39
40    // Establish the connection to the echo server
41    if (connect(sock, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)
42      DieWithSystemMessage("connect() failed");
43
44    size_t echoStringLen = strlen(echoString); // Determine input length
45
46    // Send the string to the server
47    ssize_t numBytes = send(sock, echoString, echoStringLen, 0);
48    if (numBytes < 0)
49      DieWithSystemMessage("send() failed");
50    else if (numBytes != echoStringLen)
51      DieWithUserMessage("send()", "sent unexpected number of bytes");
52
53    // Receive the same string back from the server
54    unsigned int totalBytesRcvd = 0; // Count of total bytes received
55    fputs("Received: ", stdout);     // Setup to print the echoed string
56    while (totalBytesRcvd < echoStringLen) {
57      char buffer[BUFSIZE]; // I/O buffer
58      /* Receive up to the buffer size (minus 1 to leave space for
59       a null terminator) bytes from the sender */
60      numBytes = recv(sock, buffer, BUFSIZE - 1, 0);
61      if (numBytes < 0)
62        DieWithSystemMessage("recv() failed");
63      else if (numBytes == 0)
64        DieWithUserMessage("recv()", "connection closed prematurely");
65      totalBytesRcvd += numBytes; // Keep tally of total bytes
66      buffer[numBytes] = '\0';    // Terminate the string!
67      fputs(buffer, stdout);      // Print the echo buffer
68    }
69
70    fputc('\n', stdout); // Print a final linefeed
71
72    close(sock);
73    exit(0);
74  }

					  


TCPEchoClient4.c

Our TCPEchoClient4.c does the following:

    Application setup and parameter parsing: lines 1–21

        Include files: lines 1–9

        These header files declare the standard functions and constants of the API. Consult your documentation (e.g., man pages) for the appropriate include files for socket functions and data structures on your system. We utilize our own include file, Practical.h, with prototypes for our own functions, which we describe below.

        Typical parameter parsing and sanity checking: lines 13–21

        The IPv4 address and string to echo are passed in as the first two parameters. Optionally, the client takes the server port as the third parameter. If no port is provided, the client uses the well-known echo protocol port, 7.

    TCP socket creation: lines 23–26

    We create a socket using the socket() function. The socket is for IPv4 (AF_INET) using the stream-based protocol (SOCK_STREAM) called TCP (IPPROTO_TCP). socket() returns an integer-valued descriptor or “handle” for the socket if successful. If socket fails, it returns −1, and we call our error-handling function, DieWithSystemMessage() (described later), to print an informative hint and exit.

    Prepare address and establish connection: lines 28–42

        Prepare sockaddr_in structure to hold server address: lines 29–30

        To connect a socket, we have to specify the address and port to connect to. The sock-addr_in structure is defined to be a “container” for this information. The call to memset() ensures that any parts of the structure that we do not explicitly set contain zero.

        Filling in the sockaddr_in: lines 31–38

        We must set the address family (AF_INET), Internet address, and port number. The function inet_pton() converts the string representation of the server’s Internet address (passed as a command-line argument in dotted-quad notation) into a 32-bit binary representation. The server’s port number was converted from a command-line string to binary earlier; the call to htons() (“host to network short”) ensures that the binary value is formatted as required by the API. (Reasons for this are described in Chapter 5.)

        Connecting: lines 40–42

        The connect() function establishes a connection between the given socket and the one identified by the address and port in the sockaddr_in structure. Because the Sockets API is generic, the pointer to the sockaddr_in address structure (which is specific to IPv4 addresses) needs to be cast to the generic type (sockaddr*), and the actual size of the address data structure must be supplied.

    Send echo string to server: lines 44–51

    We find the length of the argument string and save it for later use. A pointer to the echo string is passed to the send() call; the string itself was stored somewhere (like all command-line arguments) when the application was started. We do not really care where it is; we just need to know the address of the first byte and how many bytes to send. (Note that we do not send the end-of-string marker character (0) that is at the end of the argument string—and all strings in C). send() returns the number of bytes sent if successful and −1 otherwise. If send() fails or sends the wrong number of bytes, we must deal with the error. Note that sending the wrong number of bytes will not happen here. Nevertheless, it’s a good idea to include the test because errors can occur in some contexts.

    Receive echo server reply: lines 53–70

    TCP is a byte-stream protocol. One implication of this type of protocol is that send() boundaries are not preserved. In other words: The bytes sent by a call to send() on one end of a connection may not all be returned by a single call to recv() on the other end. (We discuss this issue in more detail in Chapter 7.) So we need to repeatedly receive bytes until we have received as many as we sent. In all likelihood, this loop will only be executed once because the data from the server will in fact be returned all at once; however, that is not guaranteed to happen, and so we have to allow for the possibility that multiple reads are required. This is a basic principle of writing applications that use sockets: you must never assume anything about what the network and the program at the other end are going to do.

        Receive a block of bytes: lines 57–65

        recv() blocks until data is available, returning the number of bytes copied into the buffer or −1 in case of failure. A return value of zero indicates that the application at the other end closed the TCP connection. Note that the size parameter passed to recv() reserves space for adding a terminating null character.

        Print buffer: lines 66–67

        We print the data sent by the server as it is received. We add the terminating null character (0) at the end of each chunk of received data so that it can be treated as a string by fputs(). We do not check whether the bytes received are the same as the bytes sent. The server may send something completely different (up to the length of the string we sent), and it will be written to the standard output.

        Print newline: line 70

        When we have received as many bytes as we sent, we exit the loop and print a newline.

    Terminate connection and exit: lines 72–73

    The close() function informs the remote socket that communication is ended, and then deallocates local resources of the socket.

Our client application (and indeed all the programs in this book) makes use of two error-handling functions:

     DieWithUserMessage(const char *msg, const char *detail)
     DieWithSystemMessage(const char *msg)


Both functions print a user-supplied message string (msg) to stderr, followed by a detail message string; they then call exit() with an error return code, causing the application to terminate. The only difference is the source of the detail message. For DieWithUserMessage(), the detail message is user-supplied. For DieWithSystemMessage(), the detail message is supplied by the system based on the value of the special variable errno (which describes the reason for the most recent failure, if any, of a system call). We call DieWithSystemMessage() only if the error situation results from a call to a system call that sets errno. (To keep our programs simple, our examples do not contain much code devoted to recovering from errors—they simply punt and exit. Production code generally should not give up so easily.)

Occasionally, we need to supply information to the user without exiting; we use printf() if we need formatting capabilities, and fputs() otherwise. In particular, we try to avoid using printf() to output fixed, preformatted strings. One thing that you should never do is to pass text received from the network as the first argument to printf(). It creates a serious security vulnerability. Use fputs() instead.

    Note: the DieWith...() functions are declared in the header “Practical.h.” However, the actual implementation of these functions is contained in the file DieWithMessage.c, which should be compiled and linked with all example applications in this text.

DieWithMessage.c

 1    #include <stdio.h>
 2    #include <stdlib.h>
 3
 4    void DieWithUserMessage(const char *msg, const char *detail) {
 5      fputs(msg, stderr);
 6      fputs(": ", stderr);
 7      fputs(detail, stderr);
 8      fputc('\n', stderr);
 9      exit(1);
10    }
11
12    void DieWithSystemMessage(const char *msg) {
13      perror(msg);
14      exit(1);
15    }


DieWithMessage.c

If we compile TCPEchoClient4.c and DieWithMessage.c to create program TCPEchoClient4, we can communicate with an echo server with Internet address 169.1.1.1 as follows:

     % TCPEchoClient4 169.1.1.1 "Echo this!"
     Received: Echo this!


For our client to work, we need a server. Many systems include an echo server for debugging and testing purposes; however, for security reasons, such servers are often initially disabled. If you don’t have access to an echo server, that’s okay because we’re about to write one.

	9.2 IPv4 TCP Server

We now turn our focus to constructing a TCP server. The server’s job is to set up a communication endpoint and passively wait for a connection from the client. There are four general steps for basic TCP server communication:
|1.  Create a TCP socket using socket().
|
|2.  Assign a port number to the socket with bind().
|
|3.  Tell the system to allow connections to be made to that port, using listen().
|
|4.  Repeatedly do the following:

    Call accept() to get a new socket for each client connection.

    Communicate with the client via that new socket using send() and recv().

    Close the client connection using close().

Creating the socket, sending, receiving, and closing are the same as in the client. The differences in the server’s use of sockets have to do with binding an address to the socket and then using the socket as a way to obtain other sockets that are connected to clients. (We’ll elaborate on this in the comments following the code.) The server’s communication with each client is as simple as can be: it simply receives data on the client connection and sends the same data back over to the client; it repeats this until the client closes its end of the connection, at which point no more data will be forthcoming.

TCPEchoServer4.c
Code View: Scroll / Show All

 1  #include <stdio.h>
 2  #include <stdlib.h>
 3  #include <string.h>
 4  #include <sys/types.h>
 5  #include <sys/socket.h>
 6  #include <netinet/in.h>
 7  #include <arpa/inet.h>
 8  #include "Practical.h"
 9
10  static const int MAXPENDING = 5; // Maximum outstanding connection requests
11
12  int main(int argc, char *argv[]) {
13
14  if (argc != 2) // Test for correct number of arguments
15    DieWithUserMessage("Parameter(s)", "<Server Port>");
16
17  in_port_t servPort = atoi(argv[1]); // First arg:   local port
18
19  // Create socket for incoming connections
20  int servSock; // Socket descriptor for server
21  if ((servSock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
22    DieWithSystemMessage("socket() failed");
23
24  // Construct local address structure
25  struct sockaddr_in servAddr;                  // Local address
26  memset(&servAddr, 0, sizeof(servAddr));       // Zero out structure
27  servAddr.sin_family = AF_INET;                // IPv4 address family
28  servAddr.sin_addr.s_addr = htonl(INADDR_ANY); // Any incoming interface
29  servAddr.sin_port = htons(servPort);          // Local port
30
31  // Bind to the local address
32  if (bind(servSock, (struct sockaddr*) &servAddr, sizeof(servAddr)) < 0)
33    DieWithSystemMessage("bind() failed");
34
35  // Mark the socket so it will listen for incoming connections
36  if (listen(servSock, MAXPENDING) < 0)
37    DieWithSystemMessage("listen() failed");
38
39  for (;;) { // Run forever
40    struct sockaddr_in clntAddr; // Client address
41    // Set length of client address structure (in-out parameter)
42    socklen_t clntAddrLen = sizeof(clntAddr);
43
44    // Wait for a client to connect
45    int clntSock = accept(servSock, (struct sockaddr *) &clntAddr, &clntAddrLen);
46    if (clntSock < 0)
47      DieWithSystemMessage("accept() failed");
48
49    // clntSock is connected to a client!
50
51    char clntName[INET_ADDRSTRLEN]; // String to contain client address
52    if (inet_ntop(AF_INET, &clntAddr.sin_addr.s_addr, clntName,
53        sizeof(clntName)) != NULL)
54      printf("Handling client %s/%d\n", clntName, ntohs(clntAddr.sin_port));
55    else
56      puts("Unable to get client address");
57
58      HandleTCPClient(clntSock);
59    }
60    // NOT REACHED
61  }

					  


TCPEchoServer4.c

    Program setup and parameter parsing: lines 1–17

    We convert the port number from string to numeric value using atoi(); if the first argument is not a number, atoi() will return 0, which will cause an error later when we call bind().

    Socket creation and setup: lines 19–37

        Create a TCP socket: lines 20–22

        We create a stream socket just like we did in the client.

        Fill in desired endpoint address: lines 25–29

        On the server, we need to associate our server socket with an address and port number so that client connections get to the right place. Since we are writing for IPv4, we use a sockaddr_in structure for this. Because we don’t much care which address we are on (any one assigned to the machine the server is running on will be OK), we let the system pick it by specifying the wildcard address INADDR_ANY as our desired Internet address. (This is usually the right thing to do for servers, and it saves the server from having to find out any actual Internet address.) Before setting both address and port number in the sockaddr_in, we convert each to network byte order using htonl() and htons(). (See Section 5.1.2 for details.)

        Bind socket to specified address and port: lines 32–33

        As noted above, the server’s socket needs to be associated with a local address and port; the function that accomplishes this is bind(). Notice that while the client has to supply the server’s address to connect(), the server has to specify its own address to bind(). It is this piece of information (i.e., the server’s address and port) that they have to agree on to communicate; neither one really needs to know the client’s address. Note that bind() may fail for various reasons; one of the most important is that some other socket is already bound to the specified port (see Section 7.5). Also, on some systems special privileges are required to bind to certain ports (typically those with numbers less than 1024).

        Set the socket to listen: lines 36–37

        The listen() call tells the TCP implementation to allow incoming connections from clients. Before the call to listen(), any incoming connection requests to the socket’s address would be silently rejected—that is, the connect() would fail at the client.

    Iteratively handle incoming connections: lines 39–59

        Accept an incoming connection: lines 40–47

        As discussed above, a TCP socket on which listen() has been called is used differently than the one we saw in the client application. Instead of sending and receiving on the socket, the server application calls accept(), which blocks until an incoming connection is made to the listening socket’s port number. At that point, accept() returns a descriptor for a new socket, which is already connected to the initiating remote socket. The second argument points to a sockaddr_in structure, and the third argument is a pointer to the length of that structure. Upon success, the sockaddr_in contains the Internet address and port of the client to which the returned socket is connected; the address’s length has been written into the integer pointed to by the third argument. Note that the socket referenced by the returned descriptor is already connected; among other things this means it is ready for sending and receiving. (For details about what happens in the underlying implementation, see Section 7.4.1 in Chapter 7.)

        Report connected client: lines 51–56

        At this point clntAddr contains the address and port number of the connecting client; we provide a “Caller ID” function and print out the client’s information. As you might expect, inet_ntop() is the inverse of inet_pton(), which we used in the client. It takes the binary representation of the client’s address and converts it to a dotted-quad string. Because the implementation deals with ports and addresses in so-called network byte order (Section 5.1.2), we have to convert the port number before passing it to printf() (inet_pton() takes care of this transparently for addresses).

        Handle echo client: line 58

        HandleTCPClient() takes care of the “application protocol.” We discuss it below. Thus, we have factored out the “echo”-specific part of the server.

We have factored out the function that implements the “echo” part of our echo server. Although this application protocol only takes a few lines to implement, it’s good design practice to isolate its details from the rest of the server code. This promotes code reuse.

HandleTCPClient() receives data on the given socket and sends it back on the same socket, iterating as long as recv() returns a positive value (indicating that something was received). recv() blocks until something is received or the client closes the connection. When the client closes the connection normally, recv() returns 0. You can find HandleTCPClient() in the file TCPServerUtility.c.

HandleTCPClient()
Code View: Scroll / Show All

 1  void HandleTCPClient(int clntSocket) {
 2    char buffer[BUFSIZE]; // Buffer for echo string
 3
 4    // Receive message from client
 5    ssize_t numBytesRcvd = recv(clntSocket, buffer, BUFSIZE, 0);
 6    if (numBytesRcvd < 0)
 7      DieWithSystemMessage("recv() failed");
 8
 9      // Send received string and receive again until end of stream
10      while (numBytesRcvd > 0) { // 0 indicates end of stream
11        // Echo message back to client
12       ssize_t numBytesSent = send(clntSocket, buffer, numBytesRcvd, 0);
13       if (numBytesSent < 0)
14         DieWithSystemMessage("send() failed");
15       else if (numBytesSent != numBytesRcvd)
16         DieWithUserMessage("send()", "sent unexpected number of bytes");
17
18       // See if there is more data to receive
19       numBytesRcvd = recv(clntSocket, buffer, BUFSIZE, 0);
20       if (numBytesRcvd < 0)
21         DieWithSystemMessage("recv() failed");
22    }
23
24    close(clntSocket); // Close client socket
25  }

					  


HandleTCPClient()

Suppose we compile TCPEchoServer4.c, DieWithMessage.c, TCPServerUtility.c, and Address-Utility.c into the executable program TCPEchoServer4, and run that program on a host with Internet (IPv4) address 169.1.1.1, port 5000. Suppose also that we run our client on a host with Internet address 169.1.1.2 and connect it to the server. The server’s output should look like this:

     % TCPEchoServer4 5000
     Handling client 169.1.1.2


While the client’s output looks like this:

     % TCPEchoClient4 169.1.1.1 "Echo this!" 5000
     Received: Echo this!


The server binds its socket to port 5000 and waits for a connection request from the client. The client connects, sends the message “Echo this!” to the server, and receives the echoed response. In this command we have to supply TCPEchoClient with the port number on the command line because it is talking to our echo server, which is on port 5000 rather than the well-known port 7.

We have mentioned that a key principle for coding network applications using sockets is Defensive Programming: your code must not make assumptions about anything received over the network. What if you want to “play” with your TCP server to see how it responds to various incorrect client behaviors? You could write a TCP client that sends bogus messages and prints results; this, however, can be tedious and time-consuming. A quicker alternative is to use the telnet program available on most systems. This is a command-line tool that connects to a server, sends whatever text you type, and prints the response. Telnet takes two parameters: the server and port. For example, to telnet to our example echo server from above, try

     % telnet 169.1.1.1 5000


Now type your string to echo and telnet will print the server response. The behavior of telnet differs between implementations, so you may need to research the specifics of its use on your system.

Now that we’ve seen a complete client and server, let’s look at the individual functions that make up the Sockets API in a bit more detail.


	9.3 Creating and Destroying Sockets

To communicate using TCP or UDP, a program begins by asking the operating system to create an instance of the socket abstraction. The function that accomplishes this is socket(); its parameters specify the flavor of socket needed by the program.

int socket(int domain, int type, int protocol)


The first parameter determines the communication domain of the socket. Recall that the Sockets API provides a generic interface for a large number of communication domains; however, we are only interested in IPv4 (AF_INET) and IPv6 (AF_INET6). Note that you may see some programs use PF_XXX here instead of AF_XXX. Typically, these values are equal, in which case they are interchangeable, but this is (alas) not guaranteed.[1]

    [1] Truth be told, this is an ugly part of the Sockets interface, and the documentation is simply not helpful.

The second parameter specifies the type of the socket. The type determines the semantics of data transmission with the socket—for example, whether transmission is reliable, whether message boundaries are preserved, and so on. The constant SOCK_STREAM specifies a socket with reliable byte-stream semantics, whereas SOCK_DGRAM specifies a best-effort datagram socket.

The third parameter specifies the particular end-to-end protocol to be used. For both IPv4 and IPv6, we want TCP (identified by the constant IPPROTO_TCP) for a stream socket, or UDP (identified by IPPROTO_UDP) for a datagram socket. Supplying the constant 0 as the third parameter causes the system to select the default end-to-end protocol for the specified protocol family and type. Because there is currently only one choice for stream sockets in the TCP/IP protocol family, we could specify 0 instead of giving the protocol number explicitly. Someday, however, there might be other end-to-end protocols in the Internet protocol family that implement the same semantics. In that case, specifying 0 might result in the use of a different protocol, which might or might not be desirable. The main thing is to ensure that the communicating programs are using the same end-to-end protocol.

We said earlier that socket() returns a handle for the communication instance. On UNIX-derived systems, it is an integer: a nonnegative value for success and −1 for failure. A nonfailure value should be treated as an opaque handle, like a file descriptor. (In reality, it is a file descriptor, taken from the same space as the numbers returned by open().) This handle, which we call a socket descriptor, is passed to other API functions to identify the socket abstraction on which the operation is to be carried out.

When an application is finished with a socket, it calls close(), giving the descriptor for the socket that is no longer needed.

int close(int socket)


close() tells the underlying protocol stack to initiate any actions required to shut down communications and deallocate any resources associated with the socket. close() returns 0 on success or −1 on failure. Once close() has been called, invoking other operations (e.g., send() and recv()) on the socket results in an error.


	9.4 Specifying Addresses

Applications using sockets need to be able to identify the remote endpoint(s) with which they will communicate. We’ve already seen that a client must specify the address and port number of the server application with which it needs to communicate. In addition, the sockets layer sometimes needs to pass addresses to the application. For example, a feature analogous to “Caller ID” in the telephone network lets a server know the address and port number of each client that communicates with it.

In this section, we describe the data structures used as containers for this information by the Sockets API.

		9.4.1 Generic Addresses

The Sockets API defines a generic data type—the sockaddr structure—for specifying addresses associated with sockets:

     struct sockaddr {
         sa_family_t sa_family;  // Address family (e.g., AF_INET)
         char sa_data[14];       // Family-specific address information
     };


The first part of this address structure defines the address family—the space to which the address belongs. For our purposes, we will always use the system-defined constants AF_INET and AF_INET6, which specify the Internet address families for IPv4 and IPv6, respectively. The second part is a blob of bits whose exact form depends on the address family. (This is a typical way of dealing with heterogeneity in operating systems and networking.) As we discussed in Section 1.2, socket addresses for the Internet protocol family have two parts: a 32-bit (IPv4) or 128-bit (IPv6) Internet address and a 16-bit port number.[2]

    [2] The astute reader may have noticed that the generic sockaddr structure is not big enough to hold both a 16-byte IPv6 address and a 2-byte port number. We’ll deal with this difficulty shortly.

		9.4.2 IPv4 Addresses

The particular form of the sockaddr structure that is used for TCP/IP socket addresses depends on the IP version. For IPv4, use the sockaddr_in structure.

     struct in_addr {
         uint32_t s_addr;       // Internet address (32 bits)
     };

     struct sockaddr_in {
         sa_family_t sin_family;   // Internet protocol (AF_INET)
         in_port_t sin_port;       // Address port (16 bits)
         struct in_addr sin_addr;  // IPv4 address (32 bits)
         char sin_zero[8];         // Not used
     };


As you can see, the sockaddr_in structure has fields for the port number and Internet address in addition to the address family. It is important to understand that sockaddr_in is just a more detailed view of the data in a sockaddr structure, tailored to sockets using IPv4. Thus, we can fill in the fields of a sockaddr_in and then cast (a pointer to) it to a (pointer to a) sockaddr and pass it to the socket functions, which look at the sa_family field to learn the actual type, then cast back to the appropriate type.

		9.4.3 IPv6 Addresses

For IPv6, use the sockaddr_in6 structure.

     struct in_addr {
        uint32_t s_addr[16];        // Internet address (128 bits)
     };

     struct sockaddr_in6 {
         sa_family_t sin6_family;   // Internet protocol (AF_INET6)
         in_port_t sin6_port;       // Address port (16 bits)
         uint32_t sin6_flowinfo;    // Flow information
         struct in6_addr sin6_addr; // IPv6 address (128 bits)
         uint32_t sin6_scope_id;    // Scope identifier
     };


The sockaddr_in6 structure has additional fields beyond those of a sockaddr_in. These are intended for capabilities of the IPv6 protocol that are not commonly used. They will be (mostly) ignored in this book.

As with sockaddr_in, we must cast (a pointer to) the sockaddr_in6 to (a pointer to) a sockaddr in order to pass it to the various socket functions. Again, the implementation uses the address family field to determine the actual type of the argument.

		9.4.4 Generic Address Storage

If you know anything about how data structures are allocated in C, you may have already noticed that a sockaddr is not big enough to hold a sockaddr_in6. (If you don’t know anything about it, don’t fear: much of what you need to know will be covered in Chapter 5.) In particular, what if we want to allocate an address structure, but we don’t know the actual address type (e.g., IPv4 or IPv6)? The generic sockaddr won’t work because it’s too small for some address structures.[3] To solve this problem, the socket designers created the sockaddr_storage structure, which is guaranteed to be as large as any supported address type.

    [3] You may wonder why this is so (we do). The reasons apparently have to do with backward-compatibility: the Sockets API was first specified a long time ago, before IPv6, when resources were scarcer and there was no reason to have a bigger structure. Changing it now to make it bigger would apparently break binary-compatibility with some applications.

     struct sockaddr_storage {
        sa_family_t
        ...
        // Padding and fields to get correct length and alignment
        ...
     };


As with sockaddr, we still have the leading family field to determine the actual type of the address; however, with sockaddr_storage we have sufficient space for any address type. (For a hint about how this could be accomplished, refer to the discussion of how the C compiler lays out structures in memory, in Section 5.1.6.)

One final note on addresses. On some platforms, the address structures contain an additional field that stores the length of the address structure in bytes. For sockaddr, sockaddr_in, sockaddr_in6, and sockaddr_storage, the extra fields are called sa_len, sin_len, sin6_len, and ss_len, respectively. Since a length field is not available on all systems, avoid using it. Typically, platforms that use this form of structure define a value (e.g., SIN6_LEN) that can be tested for at compile time to see if the length field is present.

		9.4.5 Binary/String Address Conversion

For socket functions to understand addresses, they must be in “numeric” (i.e., binary) form; however, addresses for human use are generally “printable” strings (e.g., 192.168.1.1 or 1::1). We can convert addresses from printable string to numeric using the inet_pton() function (pton = printable to numeric):

int inet_pton(int addressFamily, const char *src, void *dst)


The first parameter, addressFamily, specifies the address family of the address being converted. Recall that the Sockets API provides a generic interface for a large number of communication domains. However, we are only interested here in IPv4 (AF_INET) and IPv6 (AF_INET6). The src parameter references a null-terminated character string containing the address to convert. The dst parameter points to a block of memory in the caller’s space to hold the result; its length must be sufficient to hold the result (at least 4 bytes for IPv4 and 16 bytes for IPv6). inet_pton() returns 1 if the conversion succeeds, with the address referenced by dst in network byte order; 0 if the string pointed to by src is not formatted as a valid address; and −1 if the specified address family is unknown.

We can go the other way, converting addresses from numeric to printable form, using inet_ntop() (ntop = numeric to printable):

const char *inet_ntop(int addressFamily, const void *src, char *dst, socklen_t dstBytes)


The first parameter, addressFamily, specifies the type of the address being converted. The second parameter src points to the first byte of a block of memory containing the numeric address to convert. The size of the block is determined by the address family. The dst parameter points to a buffer (block of memory) allocated in the caller’s space, into which the resulting string will be copied; its size is given by dstBytes. How do we know what size to make the block of memory? The system-defined constants INET_ADDRSTRLEN (for IPv4) and INET6_ADDRSTRLEN (for IPv6) indicate the longest possible resulting string (in bytes). inet_ntop() returns a pointer to the string containing the printable address (i.e., the third argument) if the conversion succeeds and NULL otherwise.
2.4.6. Getting a Socket’s Associated Addresses

The system associates a local and foreign address with each connected socket (TCP or UDP). Later we’ll discuss the details of how these values are assigned. We can find out these addresses using getsockname() for the local address and getpeername() for the foreign address. Both methods return a sockaddr structure containing the Internet address and port information.

int getpeername(int socket, struct sockaddr *remoteAddress, socklen_t *addressLength)

int getsockname(int socket, struct sockaddr *localAddress, socklen_t *addressLength)


The socket parameter is the descriptor of the socket whose address information we want. The remoteAddress and localAddress parameters point to address structures into which the address information will be placed by the implementation; they are always cast to sockaddr * by the caller. If we don’t know the IP protocol version a priori, we should pass in a (pointer to a) sockaddr_storage to receive the result. As with other socket calls using sockaddr, the addressLength is an in-out parameter specifying the length of the buffer (input) and returned address structure (output) in bytes.


	9.5 Connecting a Socket

A TCP socket must be connected to another socket before any data can be sent through it. In this sense using TCP sockets is something like using the telephone network. Before you can talk, you have to specify the number you want, and a connection must be established; if the connection cannot be established, you have to try again later. The connection establishment process is the biggest difference between clients and servers: The client initiates the connection while the server waits passively for clients to connect to it. (For additional details about the connection process and how it relates to the API functions, see Section 7.4.) To establish a connection with a server, we call connect() on the socket.

int connect(int socket, const struct sockaddr *foreignAddress, socklen_t addressLength)


The first argument, socket, is the descriptor created by socket(). foreignAddress is declared to be a pointer to a sockaddr because the Sockets API is generic; for our purposes, it will always be a pointer to either a sockaddr_in or sockaddr_in6 containing the Internet address and port of the server. addressLength specifies the length of the address structure, typically given as sizeof(struct sockaddr_in) or sizeof(struct sockaddr_in6). When connect() returns, the socket is connected, and communication can proceed with calls to send() and recv().


	9.6 Binding to an Address

As we have noted already, client and server “rendezvous” at the server’s address and port. For that to work, the server must first be associated with that address and port. This is accomplished using bind(). Again, note that the client supplies the server’s address to connect(), but the server has to specify its own address to bind(). Neither client nor server application needs to know the client’s address in order for them to communicate. (Of course, the server may wish to know the client’s address for logging or other purposes.)

int bind(int socket, struct sockaddr *localAddress, socklen_t addressSize)


The first parameter is the descriptor returned by an earlier call to socket(). As with connect(), the address parameter is declared as a pointer to a sockaddr, but for TCP/IP applications, it will always point to a sockaddr_in (for IPv4) or sockaddr_in6 (for IPv6), containing the Internet address of the local interface and the port to listen on. The addressSize parameter is the size of the address structure. bind() returns 0 on success and −1 on failure.

It is important to realize that it is not possible for a program to bind a socket to an arbitrary Internet address—if a specific Internet address is given (of either type), the call will only succeed if that address is assigned to the host on which the program is running. A server on a host with multiple Internet addresses might bind to a specific one because it only wants to accept connections that arrive to that address. Typically, however, the server wants to accept connections sent to any of the host’s addresses, and so sets the address part of the sockaddr to the “wildcard” address INADDR_ANY for IPv4 or in6addr_any for IPv6. The semantics of the wildcard address are that it matches any specific address. For a server, this means that it will receive connections addressed to any of the host’s addresses (of the specified type).

While bind() is mostly used by servers, a client can also use bind() to specify its local address/port. For those TCP clients that don’t pick their own local address/port with bind(), the local Internet address and port are determined during the call to connect(). Thus, a client must call bind() before calling connect() if it is going to use it.

You can initialize a in6_addr structure to the wildcard address with IN6ADDR_ANY_INIT; however, this special constant may only be used as an “initializer” in a declaration. Note well that while INADDR_ANY is defined to be in host byte order and, consequently, must be converted to network byte order with htonl() before being used as an argument to bind(), in6addr_any and IN6ADDR_ANY_INIT are already in network byte order.

Finally, if you supply the port number 0 to bind(), the system will select an unused local port for you.


	9.7 Handling Incoming Connections

After binding, the server socket has an address (or at least a port). Another step is required to instruct the underlying protocol implementation to listen for connections from clients; this is done by calling listen() on the socket.

int listen(int socket, int queueLimit)


The listen() function causes internal state changes to the given socket, so that incoming TCP connection requests will be processed and then queued for acceptance by the program. (Section 7.4 in Chapter 7 has more details about the life cycle of a TCP connection.) The queue-Limit parameter specifies an upper bound on the number of incoming connections that can be waiting at any time. The precise effect of queueLimit is very system dependent, so consult your local system’s technical specifications.[4] listen() returns 0 on success and −1 on failure.

    [4] For information about using “man” pages, see the preface.

Once a socket is configured to listen, the program can begin accepting client connections on it. At first it might seem that a server should now wait for a connection on the socket that it has set up, send and receive through that socket, close it, and then repeat the process. However, that is not the way it works. The socket that has been bound to a port and marked “listening” is never actually used for sending and receiving. Instead, it is used as a way of getting new sockets, one for each client connection; the server then sends and receives on the new sockets. The server gets a socket for an incoming client connection by calling accept().

int accept(int socket, struct sockaddr *clientAddress, socklen_t *addressLength)


This function dequeues the next connection on the queue for socket. If the queue is empty, accept() blocks until a connection request arrives. When successful, accept() fills in the sockaddr structure pointed to by clientAddress, with the address and port of the client at the other end of the connection. Upon invocation, the addressLength parameter should specify the size of the structure pointed to by clientAddress (i.e., the space available); upon return it contains the size of the actual address returned. A common beginner mistake is to fail to initialize the integer that addressLength points to so it contains the length of the structure that clientAddress points to. The following shows the correct way:

     struct sockaddr_storage address;
     socklen_t addrLength = sizeof(address);
     int newConnection = accept(sock, &address, &addrLength);


AQ1

If successful, accept() returns a descriptor for a new socket that is connected to the client. The socket passed as the first parameter to accept() is unchanged (not connected to the client) and continues to listen for new connection requests. On failure, accept() returns −1. On most systems, accept() only fails when passed a bad socket descriptior. However, on some platforms it may return an error if the new socket has experienced a network-level error after being created and before being accepted.


	9.8 Communication

Once a socket is “connected,” you can begin sending and receiving data. As we’ve seen, a client creates a connected socket by calling connect(), and a connected socket is returned by accept() on a server. After connection, the distinction between client and server effectively disappears, at least as far as the Sockets API is concerned. Through a connected TCP socket, you can communicate using send() and recv().

ssize_t send(int socket, const void *msg, size_t msgLength, int flags)

ssize_t recv(int socket, void *rcvBuffer, size_t bufferLength, int flags)


These functions have very similar arguments. The first parameter socket is the descriptor for the connected socket through which data is to be sent or received. For send(), msg points to the sequence of bytes to be sent, and msgLength is the number of bytes to send. The default behavior for send() is to block until all of the data is sent. (We revisit this behavior in Section 6.3 and Chapter 7.) For recv(), rcvBuffer points to the buffer—that is, an area in memory such as a character array—where received data will be placed, and bufferLength gives the length of the buffer, which is the maximum number of bytes that can be received at once. The default behavior for recv() is to block until at least some bytes can be transferred. (On most systems, the minimum amount of data that will cause the caller of recv() to unblock is 1 byte.)

The flags parameter in both send() and recv() provides a way to change some aspects of the default behavior of the socket call. Setting flags to 0 specifies the default behavior. send() and recv() return the number of bytes sent or received or −1 for failure. (See also Section 6.3.)

Remember: TCP is a byte-stream protocol, so send() boundaries are not preserved. The number of bytes read in a single call to recv on the receiver is not necessarily determined by the number of bytes written by a single call to send(). If you call send() with 3000 bytes, it may take several calls to recv() to get all 3000 bytes, even if you pass a 5000-byte buffer to each recv() call. If you call send() with 100 bytes four times, you might receive all 400 bytes with a single call to recv(). A common mistake when writing TCP socket applications involves assuming that if you write all of the data with one send() you can read it all with one recv(). All these possibilities are illustrated in Chapter 7.

	9.9 Using IPv6

So far, we’ve seen a client and server that work only with IPv4. What if you want to use IPv6? The changes are relatively minor and basically involve using the IPv6 equivalents for the address structure and constants. Let’s look at the IPv6 version of our TCP echo server.

TCPEchoServer6.c
Code View: Scroll / Show All

 1  #include <stdio.h>
 2  #include <stdlib.h>
 3  #include <string.h>
 4  #include <sys/types.h>
 5  #include <sys/socket.h>
 6  #include <netinet/in.h>
 7  #include <arpa/inet.h>
 8  #include "Practical.h"
 9
10  static const int MAXPENDING = 5; // Maximum outstanding connection requests
11
12  int main(int argc, char *argv[]) {
13
14    if (argc != 2) // Test for correct number of arguments
15      DieWithUserMessage("Parameter(s)", "<Server Port>");
16
17    in_port_t servPort = atoi(argv[1]); // First arg:   local port
18
19    // Create socket for incoming connections
20    int servSock = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
21    if (servSock < 0)
22      DieWithSystemMessage("socket() failed");
23
24    // Construct local address structure
25    struct sockaddr_in6 servAddr;           // Local address
26    memset(&servAddr, 0, sizeof(servAddr)); // Zero out structure
27    servAddr.sin6_family = AF_INET6;        // IPv6 address family
28    servAddr.sin6_addr = in6addr_any;       // Any incoming interface
29    servAddr.sin6_port = htons(servPort);   // Local port
30
31    // Bind to the local address
32    if (bind(servSock, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)
33      DieWithSystemMessage("bind() failed");
34
35    // Mark the socket so it will listen for incoming connections
36    if (listen(servSock, MAXPENDING) < 0)
37      DieWithSystemMessage("listen() failed");
38
39    for (;;) { // Run forever
40      struct sockaddr_in6 clntAddr; // Client address
41      // Set length of client address structure (in-out parameter)
42      socklen_t clntAddrLen = sizeof(clntAddr);
43
44      // Wait for a client to connect
45      int clntSock = accept(servSock, (struct sockaddr *) &clntAddr, &clntAddrLen);
46      if (clntSock < 0)
47        DieWithSystemMessage("accept() failed");
48
49      // clntSock is connected to a client!
50
51      char clntName[INET6_ADDRSTRLEN]; // Array to contain client address string
52      if (inet_ntop(AF_INET6, &clntAddr.sin6_addr.s6_addr, clntName,
53          sizeof(clntName)) != NULL)
54        printf("Handling client %s/%d\n", clntName, ntohs(clntAddr.sin6_port));
55      else
56        puts("Unable to get client address");
57
58      HandleTCPClient(clntSock);
59    }
60    // NOT REACHED
61  }

					  


TCPEchoServer6.c

    Socket creation: lines 19–22

    We construct an IPv6 socket by specifying the communication domain as AF_INET6.

    Fill in local address: lines 24–29

    For the local address, we use the IPv6 (struct sockaddr_in6) address structure and constants (AF_INET6 and in6addr_any). One subtle difference is that we do not have to convert in6addr_any to network byte order as we did with INADDR_ANY.

    Report connected client: lines 51–56

    clntAddr, which contains the address of the connecting client, is declared as an IPv6 socket address structure. When we convert the numeric address representation to a string, the maximum string length is now INET6_ADDRSTRLEN. Finally, our call to inet_ntop() uses an IPv6 address.

You’ve now seen both IPv4- and IPv6-specific clients and servers. In Chapter 3 we will see how they can be made to work with either type of address.

	9.10 Non blocking I/O
The default behavior of a socket call is to block until the requested action is completed. For example, the recv() function in TCPEchoClient.c (page 44) does not return until at least one message from the echo server is received. Of course, a process with a blocked function is suspended by the operating system.

A socket call may block for several reasons. Data reception functions (recv() and recvfrom()) block if data is not available. A send() on a TCP socket may block if there is not sufficient space to buffer the transmitted data (see Section 7.1). Connection-related functions for TCP sockets block until a connection has been established. For example, accept() in TCPEchoServer.c (page 48) blocks until a client establishes a connection with connect(). Long round-trip times, high error rate connections, or a slow (or deceased) server may cause a call to connect() to block for a significant amount of time. In all of these cases, the function returns only after the request has been satisfied.

What about a program that has other tasks to perform while waiting for call completion (e.g., update busy cursor or respond to user requests)? These programs may have no time to wait on a blocked system call. What about lost UDP datagrams? In UDPEchoClient.c (page 54), the client sends a datagram to the server and then waits to receive a response. If either the datagram sent from the client or the echoed datagram from the server is lost, our echo client blocks indefinitely. In this case, we need recvfrom() to unblock after some amount of time to allow the client to handle the datagram loss. Fortunately, several mechanisms are available for controlling unwanted blocking behaviors. We deal with three such solutions here: nonblocking sockets, asynchronous I/O, and timeouts.

		9.10.1 Nonblocking Sockets

One obvious solution to the problem of undesirable blocking is to change the behavior of the socket so that all calls are nonblocking. For such a socket, if a requested operation can be completed immediately, the call’s return value indicates success; otherwise it indicates failure (usually −1). In either case the call does not block indefinitely. In the case of failure, we need the ability to distinguish between failure due to blocking and other types of failures. If the failure occurred because the call would have blocked, the system sets errno to EWOULDBLOCK,[2] except for connect(), which returns an errno of EINPROGRESS.

    [2] Some sockets implementations return EAGAIN. On many systems, EAGAIN and EWOULDBLOCK are the same error number.

We can change the default blocking behavior with a call to fcntl() (“file control”).

int fcntl(int socket, int command, ...)


As the name suggests, this call can be used with any kind of file: socket must be a valid file (or socket) descriptor. The operation to be performed is given by command, which is always a system-defined constant. The behavior we want to modify is controlled by flags (not the same as socket options) associated with the descriptor, which we can get and set with the F_GETFL and F_SETFL commands. When setting the socket flags, we must specify the new flags in a variable-length argument list. The flag that controls nonblocking behavior is O_NONBLOCK. When getting the socket flags, the variable-length argument list is empty. We demonstrate the use of a nonblocking socket in the next section, where we describe asynchronous I/O in UDPEchoServer-SIGIO.c (page 109).

There are a few exceptions to this model of nonblocking sockets. For UDP sockets, there are no send buffers, so send() and sendto() never return EWOULDBLOCK. For all but the connect() socket call, the requested operation either completes before returning or none of the operation is performed. For example, recv() either receives data from the socket or returns an error. A nonblocking connect() is different. For UDP, connect() simply assigns a destination address for future data transmissions so that it never blocks. For TCP, connect() initiates the TCP connection setup. If the connection cannot be completed without blocking, connect() returns an error, setting errno to EINPROGRESS, indicating that the socket is still working on making the TCP connection. Of course, subsequent data sends and receives cannot happen until the connection is established. Determining when the connection is complete is beyond the scope of this text,[3] so we recommend not setting the socket to nonblocking until after the call to connect().

    [3] Well, mostly. Connection completion can be detected using the select() call, described in Section 6.5.

For eliminating blocking during individual send and receive operations, an alternative is available on some platforms. The flags parameter of send(), recv(), sendto(), and recvfrom() allows for modification of some aspects of the behavior on a particular call. Some implementations support the MSG_DONTWAIT flag, which causes nonblocking behavior in any call where it is set in flags.

		9.10.2 Asynchronous I/O

The difficulty with nonblocking socket calls is that there is no way of knowing when one would succeed, except by periodically trying it until it does (a process known as “polling”). Why not have the operating system inform the program when a socket call will be successful? That way the program can spend its time doing other work until notified that the socket is ready for something to happen. This is called asynchronous I/O, and it works by having the SIGIO signal delivered to the process when some I/O–related event occurs on the socket.

Arranging for SIGIO involves three steps. First, we inform the system of the desired disposition of the signal using sigaction(). Then we ensure that signals related to the socket will be delivered to this process (because multiple processes can have access to the same socket, there might be ambiguity about which should get it) by making it the owner of the socket, using fcntl(). Finally, we mark the socket as being primed for asynchronous I/O by setting a flag (FASYNC), again via fcntl().

In our next example, we adapt UDPEchoServer.c (page 57) to use asynchronous I/O with nonblocking socket calls. The modified server is able to perform other tasks when there are no clients needing an echo. After creating and binding the socket, instead of calling recvfrom() and blocking until a datagram arrives, the asynchronous echo server establishes a signal handler for SIGIO and begins doing other work. When a datagram arrives, the SIGIO signal is delivered to the process, triggering execution of the handler function. The handler function calls recvfrom(), echoes back any received datagrams, and then returns, whereupon the main program continues whatever it was doing. Our description details only the code that differs from the original UDP echo server.

UDPEchoServer–SIGIO.c
Code View: Scroll / Show All

  1      #include <stdio.h>
  2      #include <stdlib.h>
  3      #include <string.h>
  4      #include <unistd.h>
  5      #include <fcntl.h>
  6      #include <sys/file.h>
  7      #include <signal.h>
  8      #include <errno.h>
  9      #include <sys/types.h>
 10      #include <sys/socket.h>
 11      #include <netdb.h>
 12      #include "Practical.h"
 13
 14      void UseIdleTime();                // Execution during idle time
 15      void SIGIOHandler(int signalType); // Handle SIGIO
 16
 17      int servSock; // Socket -- GLOBAL for signal handler
 18
 19      int main(int argc, char *argv[]) {
 20
 21      if (argc != 2) // Test for correct number of arguments
 22      DieWithUserMessage("Parameter(s)", "<Server Port/Service>");
 23
 24      char *service = argv[1]; // First arg:   local port
 25
 26      // Construct the server address structure
 27      struct addrinfo addrCriteria;                   // Criteria for address
 28      memset(&addrCriteria, 0, sizeof(addrCriteria)); // Zero out structure
 29      addrCriteria.ai_family = AF_UNSPEC;             // Any address family
 30      addrCriteria.ai_flags = AI_PASSIVE;             // Accept on any address/port
 31      addrCriteria.ai_socktype = SOCK_DGRAM;          // Only datagram sockets
 32      addrCriteria.ai_protocol = IPPROTO_UDP;         // Only UDP protocol
 33
 34      struct addrinfo *servAddr; // List of server addresses
 35      int rtnVal = getaddrinfo(NULL, service, &addrCriteria, &servAddr);
 36      if (rtnVal != 0)
 37       DieWithUserMessage("getaddrinfo() failed", gai_strerror(rtnVal));
 39      // Create socket for incoming connections
 40      servSock = socket(servAddr->ai_family, servAddr->ai_socktype,
 41          servAddr->ai_protocol);
 42      if (servSock < 0)
 43        DieWithSystemMessage("socket() failed");
 44
 45      // Bind to the local address
 46      if (bind(servSock, servAddr->ai_addr, servAddr->ai_addrlen) < 0)
 47        DieWithSystemMessage("bind() failed");
 48
 49      // Free address list allocated by getaddrinfo()
 50      freeaddrinfo(servAddr);
 51
 52      struct sigaction handler;
 53      handler.sa_handler = SIGIOHandler; // Set signal handler for SIGIO
 54      // Create mask that mask all signals
 55      if (sigfillset(&handler.sa_mask) < 0)
 56        DieWithSystemMessage("sigfillset() failed");
 57      handler.sa_flags = 0;      // No flags
 58
 59      if (sigaction(SIGIO, &handler, 0) < 0)
 60        DieWithSystemMessage("sigaction() failed for SIGIO");
 61
 62      // We must own the socket to receive the SIGIO message
 63      if (fcntl(servSock, F_SETOWN, getpid()) < 0)
 64        DieWithSystemMessage("Unable to set process owner to us");
 65
 66      // Arrange for nonblocking I/O and SIGIO delivery
 67      if (fcntl(servSock, F_SETFL, O_NONBLOCK | FASYNC) < 0)
 68        DieWithSystemMessage(
 69           "Unable to put client sock into non-blocking/async mode");
 70
 71      // Go off and do real work; echoing happens in the background
 72
 73      for (;;)
 74        UseIdleTime();
 75      // NOT REACHED
 76  }
 77
 78    void UseIdleTime() {
 79      puts(".");
 80      sleep(3); // 3 seconds of activity
 81  }
 82
 83    void SIGIOHandler(int signalType) {
 84      ssize_t numBytesRcvd;
 85      do { // As long as there is input...
 86        struct sockaddr_storage clntAddr;   // Address of datagram source
 87        size_t clntLen = sizeof(clntAddr);  // Address length in-out parameter
 88        char buffer[MAXSTRINGLENGTH];       // Datagram buffer
 89
 90        numBytesRcvd = recvfrom(servSock, buffer, MAXSTRINGLENGTH, 0,
 91            (struct sockaddr *) &clntAddr, &clntLen);
 92        if (numBytesRcvd < 0) {
 93            // Only acceptable error: recvfrom() would have blocked
 94            if (errno != EWOULDBLOCK)
 95              DieWithSystemMessage("recvfrom() failed");
 96       } else {
 97         fprintf(stdout, "Handling client ");
 98         PrintSocketAddress((struct sockaddr *) &clntAddr, stdout);
 99         fputc('\n', stdout);
100
101         ssize_t numBytesSent = sendto(servSock, buffer, numBytesRcvd, 0,
102             (struct sockaddr *) &clntAddr, sizeof(clntAddr));
103         if (numBytesSent < 0)
104           DieWithSystemMessage("sendto() failed");
105         else if (numBytesSent != numBytesRcvd)
106            DieWithUserMessage("sendto()", "sent unexpected number of bytes");
107      }
108    } while (numBytesRcvd >= 0);
109    // Nothing left to receive
110  }

					  


UDPEchoServer–SIGIO.c

    Program setup and parameter parsing: lines 1–24

    Prototypes for signal and idle time handler: lines 14–15

    UseIdleTime() simulates the other tasks of the UDP echo server. SIGIOHandler() handles SIGIO signals. Note well: UseIdleTime() must be prepared for any “slow” system calls—such as reading from a terminal device—to return −1 as a result of the SIGIO signal being delivered and handled (in which case it should simply verify that errno is EINTR and resume whatever it was doing).

    Server socket descriptor: line 17

    We give the socket descriptor a global scope so that it can be accessed by the SIGIO handler function.

    Set up signal handling: lines 52–69 handler is the sigaction structure that describes our desired signal-handling behavior. We fill it in, giving the address of the handling routine and the set of signals we want blocked.

        Fill in the pointer to the desired handler: line 53

        Specify signals to be blocked during handling: lines 55–56

        Specify how to handle the SIGIO signal: lines 59–60

        Arrange for SIGIO to go to this process: lines 63–64

        The F_SETOWN command identifies the process to receive SIGIO for this socket.

        Set flags for nonblocking and asynchronous I/O: lines 67–69

        Finally, we mark the socket (with the FASYNC flag[4]) to indicate that asynchronous I/O is in use, so SIGIO will be delivered on packet arrival. (Everything up to this point was just saying how to deal with SIGIO.) Because we do not want SIGIOHandler() to block in recvfrom(), we also set the O_NONBLOCK flag.

            [4] The name may be different (e.g., O_ASYNC) on some platforms.

    Run forever using idle time when available: lines 73–74

    Perform nonechoing server tasks: lines 78–81

    Handle asynchronous I/O: lines 83–110

    This code is very similar to the loop in our earlier UDPEchoServer.c (page 57). One difference is that here we loop until there are no more pending echo requests to satisfy and then return; this technique enables the main program thread to continue what it was doing.

        Receive echo request: lines 90–99

        The first call to recvfrom() receives the datagram whose arrival prompted the SIGIO signal. Additional datagrams may arrive during execution of the handler, so the do/while loop continues to call recvfrom() until no more datagrams remain to be received. Because sock is a nonblocking socket, recvfrom() then returns −1 with errno set to EWOULDBLOCK, terminating the loop and the handler function.

        Send echo reply: lines 101–106

        Just as in the original UDP echo server, sendto() repeats the message back to the client.

		9.10.3 Timeouts

In the previous subsection, we relied on the system to notify our program of the occurrence of an I/O–related event. Sometimes, however, we may actually need to know that some I/O event has not happened for a certain time period. For example, we have already mentioned that UDP messages can be lost; in case of such a loss, our UDP echo client (or any other client that uses UDP, for that matter) will never receive a response to its request. Of course, the client cannot tell directly whether a loss has occurred, so it sets a limit on how long it will wait for a response. For example, the UDP echo client might assume that if the server has not responded to its request within two seconds, the server will never respond. The client’s reaction to this two-second timeout might be to give up or to try again by resending the request.

The standard method of implementing timeouts is to set an alarm before calling a blocking function.

unsigned int alarm(unsigned int secs)


alarm() starts a timer, which expires after the specified number of seconds (secs); alarm() returns the number of seconds remaining for any previously scheduled alarm (or 0 if no alarm was scheduled). When the timer expires, a SIGALRM signal is sent to the process, and the handler function for SIGALRM, if any, is executed.

The code we showed earlier in UDPEchoClient.c (page 54) has a problem if either the echo request or the response is lost: The client blocks indefinitely on recvfrom(), waiting for a datagram that will never arrive. Our next example program, UDPEchoClient-Timeout.c, modifies the original UDP echo client to retransmit the request message if a response from the echo server is not received within a time limit of two seconds. To implement this, the new client installs a handler for SIGALRM, and just before calling recvfrom(), it sets an alarm for two seconds. At the end of that interval of time, the SIGALRM signal is delivered, and the handler is invoked. When the handler returns, the blocked recvfrom() returns −1 with errno equal to EINTR. The client then resends the echo request to the server. This timeout and retransmission of the echo request happens up to five times before the client gives up and reports failure. Our program description only details the code that differs from the original UDP echo client.

UDPEchoClient–Timeout.c
Code View: Scroll / Show All

  1    #include <stdio.h>
  2    #include <stdlib.h>
  3    #include <string.h>
  4    #include <unistd.h>
  5    #include <errno.h>
  6    #include <signal.h>
  7    #include <sys/socket.h>
  8    #include <netinet/in.h>
  9    #include <netdb.h>
 10    #include "Practical.h"
 11
 12    static const unsigned int TIMEOUT_SECS = 2; // Seconds between retransmits
 13    static const unsigned int MAXTRIES = 5;     // Tries before giving up
 14
 15    unsigned int tries = 0; // Count of times sent - GLOBAL for signal-handler access
 16
 17    void CatchAlarm(int ignored); // Handler for SIGALRM
 18
 19    int main(int argc, char *argv[]) {
 20
 21      if ((argc < 3) || (argc > 4)) // Test for correct number of arguments
 22       DieWithUserMessage("Parameter(s)",
 23           "<Server Address/Name> <Echo Word> [<Server Port/Service>]\n");
 24
 25      char *server = argv[1];         // First arg: server address/name
 26      char *echoString = argv[2];     // Second arg: word to echo
 27
 28      size_t echoStringLen = strlen(echoString);
 29      if (echoStringLen > MAXSTRINGLENGTH)
 30       DieWithUserMessage(echoString, "too long");
 31
 32      char *service = (argc == 4) ? argv[3] : "echo";
 33
 34      // Tell the system what kind(s) of address info we want
 35      struct addrinfo addrCriteria;                   // Criteria for address
 36      memset(&addrCriteria, 0, sizeof(addrCriteria)); // Zero out structure
 37      addrCriteria.ai_family = AF_UNSPEC;             // Any address family
 38      addrCriteria.ai_socktype = SOCK_DGRAM;          // Only datagram sockets
 39      addrCriteria.ai_protocol = IPPROTO_UDP;         // Only UDP protocol
 40
 41      // Get address(es)
 42      struct addrinfo *servAddr; // Holder for returned list of server addrs
 43      int rtnVal = getaddrinfo(server, service, &addrCriteria, &servAddr);
 44      if (rtnVal != 0)
 45       DieWithUserMessage("getaddrinfo() failed", gai_strerror(rtnVal));
 46
 47      // Create a reliable, stream socket using TCP
 48      int sock = socket(servAddr->ai_family, servAddr->ai_socktype,
 49          servAddr->ai_protocol); // Socket descriptor for client
 50      if (sock < 0)
 51       DieWithSystemMessage("socket() failed");
 52
 53      // Set signal handler for alarm signal
 54      struct sigaction handler; // Signal handler
 55      handler.sa_handler = CatchAlarm;
 56      if (sigfillset(&handler.sa_mask) < 0) // Block everything in handler
 57       DieWithSystemMessage("sigfillset() failed");
 58      handler.sa_flags = 0;
 59
 60      if (sigaction(SIGALRM, &handler, 0) < 0)
 61       DieWithSystemMessage("sigaction() failed for SIGALRM");
 62
 63      // Send the string to the server
 64      ssize_t numBytes = sendto(sock, echoString, echoStringLen, 0,
 65          servAddr->ai_addr, servAddr->ai_addrlen);
 66      if (numBytes < 0)
 67       DieWithSystemMessage("sendto() failed");
 68      else if (numBytes != echoStringLen)
 69        DieWithUserMessage("sendto() error", "sent unexpected number of bytes");
 70
 71      // Receive a response
 72
 73      struct sockaddr_storage fromAddr; // Source address of server
 74      // Set length of from address structure (in-out parameter)
 75      socklen_t fromAddrLen = sizeof(fromAddr);
 76      alarm(TIMEOUT_SECS); // Set the timeout
 77      char buffer[MAXSTRINGLENGTH + 1]; // I/O buffer
 78      while ((numBytes = recvfrom(sock, buffer, MAXSTRINGLENGTH, 0,
 79          (struct sockaddr *) &fromAddr, &fromAddrLen)) < 0) {
 80        if (errno == EINTR) {         // Alarm went off
 81          if (tries < MAXTRIES) { // Incremented by signal handler
 82           numBytes = sendto(sock, echoString, echoStringLen, 0,
 83              (struct sockaddr *) servAddr->ai_addr, servAddr->ai_addrlen);
 84           if (numBytes < 0)
 85             DieWithSystemMessage("sendto() failed");
 86           else if (numBytes != echoStringLen)
 87             DieWithUserMessage("sendto() error", "sent unexpected number of bytes");
 88           } else
 89               DieWithUserMessage("No Response", "unable to communicate with server");
 90        } else
 91          DieWithSystemMessage("recvfrom() failed");
 92      }
 93
 94      // recvfrom() got something -- cancel the timeout
 95      alarm(0);
 96
 97      buffer[echoStringLen] = '\0';         // Null-terminate the received data
 98      printf("Received: %s\n", buffer); // Print the received data
 99
100     close(sock);
101     exit(0);
102   }
103
104    // Handler for SIGALRM
105    void CatchAlarm(int ignored) {
106         tries += 1;
107    }

					  


UDPEchoClient–Timeout.c

    Program setup and parameter parsing: lines 1–32

    Timeout setup: lines 12–17

    tries is a global variable so that it can be accessed in the signal handler.

    Establish signal handler for SIGALRM: lines 53–61

    This is similar to what we did for SIGIO in UDPEchoServer-SIGIO.c.

    Start the alarm timer: line 76

    When/if the alarm timer expires, the handler CatchAlarm() will be invoked.

    Retransmission loop: lines 78–92

    We have to loop here because the SIGALRM will cause the recvfrom() to return −1. When that happens, we decide whether or not it was a timeout and, if so, retransmit.

        Attempt reception: lines 78–79

        Discover the reason for recvfrom() failure: lines 80–91

        If errno equals EINTR, recvfrom() returned because it was interrupted by the SIGALRM while waiting for datagram arrival and not because we got a packet. In this case we assume either the echo request or reply is lost. If we have not exceeded the maximum number of retransmission attempts, we retransmit the request to the server; otherwise, we report a failure. After retransmission, we reset the alarm timer to wake us again if the timeout expires.

    Handle echo response reception: lines 95–98

        Cancel the alarm timer: line 95

        Ensure that message is null-terminated: line 97

        printf() will output bytes until it encounters a null byte, so we need to make sure one is present (otherwise, our program may crash).

        Print the received message: line 98

	9.11 Select() server example
Applying select(2) to a Server

The preceding text has described the select(2) function in some detail. Now it's time to put the function to work in an example. The next modified example of the RPN calculating server will make use of the select(2) function call for read events only. This limitation was imposed to keep the programming example relatively short and simple to understand. The limitations of this demonstration will be discussed in more detail later.

The RPN server required a few modifications to the engine module rpneng.c, which are reflected in the new source module rpneng2.c. Rather than re-list the entire module, only the minor changes are shown in the context diff of Listing 11.4.
Listing 11.4. rpneng2.c—diff -c rpneng.c rpneng2.c

Code View: Scroll / Show All

$ diff -c rpneng.c rpneng2.c
*** rpneng.c    Mon Sep 13 22:13:56 1999
--- rpneng2.c   Wed Sep 15 21:55:20 1999
***************
*** 18,25 ****
   * RPN Stack:
   */
  #define MAX_STACK       32
! static mpz_t *stack[MAX_STACK];
! static int sp = 0;

  /*
   * Allocate a new mpz_t value:
--- 18,25 ----
   * RPN Stack:
   */
  #define MAX_STACK       32
! mpz_t **stack;
! int sp = 0;

  /*
   * Allocate a new mpz_t value:
***************
*** 45,51 ****
  /*
   * Free an allocated mpz_t value:
   */
! static void
  rpn_free(mpz_t **v) {
      mpz_clear(**v);
      free(*v);
--- 45,51 ----
  /*
   * Free an allocated mpz_t value:
   */
! void
  rpn_free(mpz_t **v) {
      mpz_clear(**v);
      free(*v);
$


					  


The major change that is present in the rpneng2.c module is that the RPN stack array (variable stack) and its stack pointer (variable sp) are declared to be external in scope. Static function rpn_free() is made external also. This allows the variables and the function to be accessed from the main source module, which you'll examine in the example in Listing 11.5.
Listing 11.5. rpnsrv2.c—The RPN Server Using select(2)

Code View: Scroll / Show All

1:   /* rpnsrv2.c:
2:    *
3:    * Example RPN Server
4:    * using select(2):
5:    */
6:   #include <stdio.h>
7:   #include <unistd.h>
8:   #include <stdlib.h>
9:   #include <errno.h>
10:  #include <string.h>
11:  #include <time.h>
12:  #include <sys/time.h>
13:  #include <sys/types.h>
14:  #include <sys/socket.h>
15:  #include <netinet/in.h>
16:  #include <arpa/inet.h>
17:  #include <netdb.h>
18:  #include <sys/wait.h>
19:  #include <gmp.h>
20:
21:  #ifndef SHUT_RDWR
22:  #define SHUT_RDWR 3
23:  #endif
24:
25:  extern int mkaddr(void *addr,
26:      int *addr_len,
27:      char *input_address,
28:      char *protocol);
29:
30:  extern void rpn_process(FILE *tx,
31:      char *buf);
32:
33:  extern void rpn_free(mpz_t **v);
34:
35:  #define MAX_STACK       32
36:  #define MAX_CLIENTS     64
37:
38:  /*
39:   * Declared in rpneng2.c:
40:   */
41:  extern mpz_t **stack;
42:  extern int sp;
43:
44:  /*
45:   * Client context Info:
46:   */
47:  typedef struct {
48:      mpz_t   **stack;  /* Stack Array */
49:      int     sp;          /* Stack ptr */
50:      FILE    *rx;         /* Recv FILE */
51:      FILE    *tx;         /* Xmit FILE */
52:  } ClientInfo;
53:
54:  ClientInfo client[MAX_CLIENTS];
55:
56:  /*
57:   * This function reports the error and
58:   * exits back to the shell:
59:   */
60:  static void
61:  bail(const char *on_what) {
62:      if ( errno != 0 ) {
63:          fputs(strerror(errno),stderr);
64:          fputs(": ",stderr);
65:      }
66:      fputs(on_what,stderr);
67:      fputc('\n',stderr);
68:      exit(1);
69:  }
70:
71:  /*
72:   * Process client c:
73:   */
74:  static int
75:  process_client(int c) {
76:      char buf[4096];          /* I/O Buffer */
77:      FILE *rx = client[c].rx;
78:      FILE *tx = client[c].tx;
79:
80:      /*
81:       * Install correct RPN stack:
82:       */
83:      stack = client[c].stack;
84:      sp = client[c].sp;
85:
86:      /*
87:       * If not EOF, process one line:
88:       */
89:      if ( !feof(rx)
90:        && fgets(buf,sizeof buf,rx) )
91:          rpn_process(tx,buf);
92:
93:      if ( !feof(rx) ) {
94:          /* Save SP and exit */
95:          client[c].sp = sp;  
96:          return 0;
97:      }
98:
99:      /*
100:      * Close this client's connection:
101:      */
102:     fclose(tx);
103:     shutdown(fileno(rx),SHUT_RDWR);
104:     fclose(rx);
105:
106:     client[c].rx = client[c].tx = NULL;
107:
108:     while ( sp > 0 )
109:         rpn_free(&stack[--sp]);
110:     free(stack);
111:
112:     client[c].stack = NULL;
113:     client[c].sp = 0;
114:
115:     return EOF;
116: }
117:
118: /*
119:  * Main program:
120:  */   
121: int
122: main(int argc,char **argv) {
123:     int z;
124:     char *srvr_addr = "127.0.0.1:9090";
125:     struct sockaddr_in adr_srvr;/* AF_INET */
126:     struct sockaddr_in adr_clnt;/* AF_INET */
127:     int len_inet;                /* length */
128:     int s = −1;                  /* Socket */
129:     int c = −1;           /* Client socket */
130:     int n;    /* return val from select(2) */
131:     int mx;                  /* Max fd + 1 */
132:     fd_set rx_set;             /* Read set */
133:     fd_set wk_set;          /* Working set */
134:     struct timeval tv;    /* Timeout value */
135:
136:     /*
137:      * Initialize client structure:
138:      */
139:     for ( z=0; z<MAX_CLIENTS; ++z ) {
140:         client[z].stack = NULL;
141:         client[z].sp = 0;
142:         client[z].rx = NULL;
143:         client[z].tx = NULL;
144:     }
145:
146:     /*
147:      * Use a server address from the command
148:      * line, otherwise default to 127.0.0.1:
149:      */
150:     if ( argc >= 2 )
151:         srvr_addr = argv[1];
152:
153:     len_inet = sizeof adr_srvr;
154:     z = mkaddr(&adr_srvr,&len_inet,
155:         srvr_addr,"tcp");
156:
157:     if ( z < 0 || !adr_srvr.sin_port ) {
158:         fprintf(stderr,"Invalid server "
159:             "address, or no port number "
160:             "was specified.\n");
161:         exit(1);
162:     }
163:
164:     /*
165:      * Create a TCP/IP socket to use:
166:      */
167:     s = socket(PF_INET,SOCK_STREAM,0);
168:     if ( s == −1 )
169:         bail("socket(2)");
170:
171:     /*
172:      * Bind the server address:
173:      */
174:     z = bind(s,(struct sockaddr *)&adr_srvr,
175:             len_inet);
176:     if ( z == −1 )
177:         bail("bind(2)");
178:
179:     /*
180:      * Make it a listening socket:
181:      */
182:     z = listen(s,10);
183:     if ( z == −1 )
184:         bail("listen(2)");
185:
186:     /*
187:      * Express interest in socket
188:      * s for read events:
189:      */
190:     FD_ZERO(&rx_set);   /* Init. */
191:     FD_SET(s,&rx_set);    /* + s */
192:     mx = s + 1;    /* max fd + 1 */
193:
194:     /*
195:      * Start the server loop:
196:      */
197:     for (;;) {
198:         /*
199:          * Copy the rx_set to wk_set:
200:          */
201:         FD_ZERO(&wk_set);
202:         for ( z=0; z<mx; ++z ) {
203:             if ( FD_ISSET(z,&rx_set) )
204:                 FD_SET(z,&wk_set);
205:         }
206:
207:         /*
208:          * Sample timeout of 2.03 secs:
209:          */
210:         tv.tv_sec = 2;
211:         tv.tv_usec = 30000;
212:
213:         n = select(mx,&wk_set,NULL,NULL,&tv);
214:         if ( n == −1 ) {
215:             fprintf(stderr,"%s: select(2)\n",
216:                 strerror(errno));
217:             exit(1);
218:         } else if ( !n ) {
219:             /* puts("Timeout."); */
220:             continue;
221:         }
222:
223:         /*
224:          * Check if a connect has occured:
225:          */
226:         if ( FD_ISSET(s,&wk_set) ) {
227:             /*
228:              * Wait for a connect:
229:              */
230:             len_inet = sizeof adr_clnt;
231:             c = accept(s,
232:                 (struct sockaddr *)&adr_clnt,
233:                 &len_inet);
234:             if ( c == −1 )
235:                 bail("accept(2)");
236:
237:             /*
238:              * See if we've exceeded server
239:              * capacity. If so, close the
240:              * socket and wait for the
241:              * next event:
242:              */
243:             if ( c >= MAX_CLIENTS ) {
244:                 close(c);   /* At capacity */
245:                 continue;
246:             }
247:
248:             /*
249:              * Create streams:
250:              */
251:             client[c].rx = fdopen(c,"r");
252:             if ( !client[c].rx ) {
253:                 close(c);  /* Failed */
254:                 continue;
255:             }
256:
257:             client[c].tx = fdopen(dup(c),"w");
258:             if ( !client[c].tx ) {
259:                 fclose(client[c].rx);
260:                 continue;
261:             }
262:
263:             if ( c + 1 > mx )
264:                 mx = c + 1;
265:
266:             /*
267:              * Set both streams to line
268:              * buffered mode:
269:              */
270:             setlinebuf(client[c].rx);
271:             setlinebuf(client[c].tx);
272:
273:             /*
274:              * Allocate a stack:
275:              */
276:             client[c].sp = 0;
277:             client[c].stack =
278:                 (mpz_t **) malloc(
279:                     sizeof (mpz_t *)
280:                     * MAX_STACK);
281:
282:             FD_SET(c,&rx_set);
283:         }
284:
285:         /*
286:          * Check for client activity:
287:          */
288:         for ( c=0; c<mx; ++c ) {
289:             if ( c == s )
290:                 continue;   /* Not s */
291:             if ( FD_ISSET(c,&wk_set) ) {
292:                 if ( process_client(c) == EOF ) {
293:                     FD_CLR(c,&rx_set);
294:                 }
295:             }
296:         }
297:
298:         /*
299:          * Reduce mx if we are able to:
300:          */
301:         for ( c = mx - 1;
302:               c >= 0 && !FD_ISSET(c,&rx_set);
303:               c = mx - 1 )
304:                 mx = c;
305:     }
306:
307:     /* Control never gets here */
308:     return 0;
309: }


					  


The source module rpnsrv2.c contains quite a number of changes. First, examine the structural overview of the program:

    Include file <sys/time.h> is added to define the data structure timeval (line 12).

    The function prototype is declared for rpn_free() in line 33.

    The MAX_STACK macro is copied from rpnsrv2.c in line 35. The macro MAX_CLIENTS defines the maximum number of client processes supported by this server (line 36).

    The external declarations for stack and sp are defined in lines 41 and 42.

    The information about each client is maintained in this program by the data type ClientInfo, which is declared in lines 47 to 52.

    The ClientInfo array client[] is declared in line 54.

    A new client processing function, process_client(), is defined in lines 74 to 116.

    A number of new declarations are present in the main() program. The first of these is the value n, which is declared in line 130. This variable receives the return value from the select(2) call in line 207.

    Variable mx in line 131 will hold the maximum file descriptor that select(2) is interested in, plus one.

    Two file descriptor sets, rx_set and wk_set, are declared in lines 132 and 133.

    A timeout value structure, tv, is declared in line 134.

There are several significant changes made to the main flow of the main() program, which will be examined now. The following outlines the general steps that are executed by the server program:

    The ClientInfo array client[] is initialized first, in the for loop of lines 139 to 144.

    The usual socket creation, the bind(2) call and listen(2) call, are performed in lines 150 to 184.

    rx_set is zeroed out in line 190. rx_set will function as the master set of sockets for which the server is interested in read events.

    The FD_SET macro is called to enter socket s into the file descriptor set rx_set (line 191). This is done because a connect to this socket is considered a read event that select(2) will respond to.

    The variable mx is initialized to s + 1. This variable will hold the maximum file descriptor plus one. At this moment, there is only the one file descriptor s in the set. Hence, the program knows that the value of mx is currently and simply the value s + 1 (line 192).

    The server for loop begins in line 197.

    The FD_ZERO macro is called for the wk_set file descriptor set in line 201. This clears all bits in it to the zero (off) state. wk_set will function as the working set for this program, since select(2) will modify the sets that are passed to it.

    The for loop in lines 202 to 205 copy all file descriptors logged in rx_set to the work set wk_set.

    The timeout values are established in lines 210 to 211. It is necessary to establish the values each time select(2) is called, because these values are changed upon return from the function.

    The select(2) function is invoked in line 213. The return value is assigned to the variable n. Note that the wk_set is passed as the read file descriptor set in argument 2. Upon return from the select(2) function, the only bits that will remain in this set will be for the sockets that have data to be read (in the case of socket s, a client has connected).

    The value of n is tested for −1 in line 214. Lines 215 to 217 report the error and exit if an error should occur. An error here probably indicates a programming error. The error EINTR should be handled, however, if the program is handling signals at all.

    Lines 218 to 220 show how you can intercept a timeout event. The program shown simply does nothing and restarts the loop at step 6.

    The FD_ISSET macro is used to test whether socket s is present in set wk_set (line 226). If it is, this indicates that a client has just connected to the server socket s.

    The client connect is accepted in lines 230 to 235 if the test in step 12 is true. Note that the accept(2) call will not block the execution of the server here, because the select(2) function result guarantees that we have a connected client waiting to be accepted.

    Client connect processing continues with line 243. If the socket number (file descriptor) is greater than or equal to MAX_CLIENTS, the server rejects the connection in line 244 by closing the socket and looping back to step 6. In this program, the socket number is used as a subscript into the client[] array, and, as such, it must be less than the value of MAX_CLIENTS in this program.

    The usual FILE streams rx and tx are created and the buffering modes set in lines 251 to 271. Note, however, that in lines 263 and 264 the variable mx is increased to the new connected socket plus one, if the mx value needs increasing. Recall that mx must contain the maximum file descriptor value plus one, for the select(2) call.

    The client[] entry for this client is further initialized by allocating a stack for the client and resetting its stack pointer sp to zero (lines 276 to 280).

    Finally, FD_SET is used on set rx_set in line 282 to register the new client in the list of interesting file descriptors.

The steps just shown cover the server initialization and the accepting of new client connections. The following steps are used when clients send data to the server to be processed:

    Line 226 invokes the FD_ISSET macro to test whether the socket s has any input data. If it has, the client accept process just described is executed in lines 227 to 283.

    A for loop in line 288 iterates through all file descriptors less than the maximum value mx.

    Line 289 causes processing to be skipped for socket s, since only accept(2) is used on that socket.

    The FD_ISSET macro is called in line 291 to see if socket c has data waiting to be read (by testing descriptor set wk_set).

    If step 4 evaluates as true, then the function process_client() is called (line 292) with the socket number c as its input argument.

    If the function call in step 5 returns the value EOF in line 292, then socket c is removed from the rx_set in line 293, using the FD_CLR macro. This is necessary because the socket has been closed by the process_client() function and obviously will no longer return any data to be read.

    The for loop in lines 301 to 304 perform the job of lowering the value of mx if it is possible. This is not essential, but it can help the performance of the select(2) call and the server when this value is maintained as small as possible.

Now it's time to examine the steps employed by the function process_client(). These steps are as follows:

    The local variables rx and tx are established in lines 77 and 78 for programming convenience, from the client[c] array member. Note that the socket number c is used as a subscript into the client[] array.

    The RPN stack is established for the client by assigning values from client[c] into the external variables stack and sp (lines 83 and 84).

    Line 89 makes certain that end of file has not already been detected. If it has been, this will be handled in code that follows.

    Line 90 fetches one text line to be processed by the server. If this fgets(3) call should return an end-of-file indication, the code that follows will close things up for this client.

    The rpn_process() function call is executed to carry out the client request (line 91).

    End of file is tested in line 93. If this tests false, then the current sp value is saved back into the client[c] array member for future use. Then the function returns zero to indicate that EOF has not yet been seen (line 96).

    When the execution reaches line 102, it is known that the client has shut down its writing end of the socket. The function fclose(3) is called to force write out any unbuffered data to the client.

    The shutdown(2) function is called in line 103 to force a socket shutdown (this is not essential in this case, but is used for demonstration purposes).

    The rx stream is closed in line 104 for this client.

    Lines 106 to 113 free the client's leftover stack, if any, and clear the client[] array entry.

    Finally, EOF is returned in line 115.

Notice that step 11 causes source line 293 to remove the socket number c from the list of sockets that select(2) should report on.

Tip

It should be noted that even if no data is sent by the client process to be read, the act of the client closing the socket will cause select(2) to register a read event. Your code should always anticipate an end-of-file event.

Testing the select(2)-Based Server

The source code for the select(2) version of the RPN calculating server can be compiled as follows:

$ make rpnsrv2
gcc -c  -D_GNU_SOURCE -Wall -Wreturn-type rpnsrv2.c
gcc -c  -D_GNU_SOURCE -Wall -Wreturn-type rpneng2.c
gcc -c  -D_GNU_SOURCE -Wall -Wreturn-type mkaddr.c
gcc rpnsrv2.o rpneng2.o mkaddr.o -o rpnsrv2 -lgmp
$


The server executable rpnsrv2 will execute as one single process, even when many clients connect to the server. To allow this to be tested, you will first want to start the server itself. The following launch of the server permits it to be contacted on any allowable interface on your system:

$ ./rpnsrv2 '*:9099' &
[1] 730
$


The server is launched and placed into the background. The command-line argument of '*:9099' tells the server to specify a wild IP number, but to listen on TCP/IP port number 9099 for connects.

In order to properly test that this select(2) logic is operational, it is necessary to connect to the server with at least two simultaneous sessions. Without X Window sessions, this can be done from multiple console sessions. Using the X Window interface, you can easily start multiple terminal sessions for testing purposes.

Listing 11.6 shows one example xterm session using telnet to connect to the server. While this session is going on, another session, shown in Listing 11.7, is also created at the same time. It is only important that both sessions be connected to the server at the same time. Switching back and forth between sessions, the server should respond to each session as commands are provided to it.
Listing 11.6. First telnet Session with rpnsrv2

$ telnet localhost 9099
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
#:44
0:
#:7777777777777777
1:
genprime
0:
=
0:3478699960711639
^]
telnet>c
Connection closed.
$


The second example telnet session is shown in Listing 11.7. Keep in mind that these are example sessions. You are free to exercise any of the functions of the RPN server in your own testing.
Listing 11.7. Second Session with rpnsrv2

$ telnet localhost 9099
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
#:99
0:
#:9999999999999999
1:
genprime
0:
=
0:3039223729873609
^]
telnet> c
Connection closed.
$


While the sessions of Listings 11.6 and 11.7 were in progress, a list of processes were produced in a third session, which is shown in Listing 11.8.
Listing 11.8. List of Processes During rpnsrv2 Access

$ ps -af
UID        PID  PPID  C STIME TTY          TIME CMD
wwg        730   629  0 21:51 pts/1    00:00:00 ./rpnsrv2 *:9099
wwg        731   629  0 21:58 pts/1    00:00:00 telnet localhost 9099
wwg        754   752  0 21:59 pts/5    00:00:00 telnet localhost 9099
wwg        757   665  0 21:59 pts/3    00:00:00 ps -af
$


The process listing in Listing 11.8 clearly shows that, while the two telnet sessions (PID 731 and 754) were connected to the rpnsrv2 process, there was only one process representing the server (PID 730). As each input line was entered in the telnet sessions, a response was received after pressing Enter in either of the two open sessions. This demonstrates the capability of the one process to serve multiple connected clients.
Limitations of the Example

It was noted earlier that only read events were used for this server example. Even accepting this limitation of the demo server, there is still some exposure to difficulty, should a wayward client program decide to play havoc.

Consider what would happen if a client process were to do the following:

    Send three bytes: '#', ':', and '9'.

    Wait for a long time or an indefinite period.

The server end would experience the following events:

    Three bytes would be received at the receiving end of the server socket for the client.

    The select(2) call would return with an indication that the client socket has data to be read.

    The fgets(3) function would eventually be called in line 90 of Listing 11.5.

    The fgets(3) function waits indefinitely because, after reading all available data, there is no linefeed character to indicate that the end of the line has been received.

The server becomes blocked in the fgets(3) call at this point, and now no other client will be serviced either (they will all appear to have a hung connection).

The preceding discussion demonstrates that, while select(2) makes it possible to handle many sockets in one process, the design of the server tends to be complex in order to avoid hangs.

The write side of the operation is equally complex. While the select(2) call can indicate when a write(2) call will not block, it does not indicate how much data can be written without blocking. For servers that might return large amounts of data in a response, this is a serious problem. Again, special buffering techniques must be applied to successfully utilize select(2) in a robust server process.

	9.12 DNS

		9.12.1 New Network Database Functions

			9.12.1.1  getnameinfo
These network database functions provide information about hosts, networks, protocols, and services. I already introduced the most important of these functions, getaddrinfo, in Section 8.2.6. Another handy function, gethostname, was in Section 8.2.7. Here I’ll describe the rest, grouped according to the kind of information they deal with.

				9.12.1.1.1  Host Functions

The three functions for scanning the host database are:

sethostent—start host-database scan

#include <netdb.h>

void sethostent(
    int stayopen         /* leave connection open? */
);


gethostent—get next host-database entry

#include <netdb.h>

struct hostent *gethostent(void);
/* Returns next entry or NULL on end of database (errno not defined) */


endhostent—end host-database scan

#include <netdb.h>

void endhostent(void);


struct hostent—structure for host-database functions

struct hostent {
    char *h_name;         /* official host name */
    char **h_aliases;     /* array of alternative host names */
    int h_addrtype;       /* address family (not type) */
    int h_length;         /* length of each address */
    char **h_addr_list;   /* array of pointers to network addresses */
};



You can call gethostent in a loop to scan through all the known host names. You start the scan with sethostent, using the argument to indicate whether the connection to the host database should stay open, or whether gethostent should open and close it each time it’s called. You call endhostent at the end. Thus, it sounds like a lot could be happening, but in practice all these functions are likely to do is scan the /etc/hosts file on the local machine.

There are two arrays in the hostent structure, each terminated with a NULL pointer. One, h_aliases, is an array of alternate host names. The other, h_addr_list, is an array of pointers to network addresses. For AF_INET, these are IP addresses stored as 32-bit binary numbers in network byte order; therefore, use ntohl (Section 8.1.4) to convert them to local byte order, or use inet_ntoa (Section 8.2.3) or inet_ntop (Section 8.9.5) to get them as a dotted string

Here’s an example:

static void hostdb(void)
{
    struct hostent *h;

    sethostent(true);
    while ((h = gethostent()) != NULL)
        display_hostent(h);
    endhostent();
}

static void display_hostent(struct hostent *h)
{
    int i;

    printf("name: %s; type: %d; len: %d\n", h->h_name, h->h_addrtype,
      h->h_length);
    for (i = 0; h->h_aliases[i] != NULL; i++)
        printf("\t%s\n", h->h_aliases[i]);
    if (h->h_addrtype == AF_INET) {
        for (i = 0; h->h_addr_list[i] != NULL; i++)
            printf("\t%s\n",
              inet_ntoa(*((struct in_addr *)h->h_addr_list[i])));
    }
}


The output from a little main program (not shown) that called hostdb was:

|name: localhost; type: 2; len: 4
|        127.0.0.1
|name: sol; type: 2; len: 4
|        loghost
|        192.168.0.10
|name: bsd; type: 2; len: 4
|        192.168.0.15
|name: suse2; type: 2; len: 4
|        suse2.MSHOME
|        192.168.0.19


For comparison, here’s what the /etc/hosts file looked like on the same system:

| 127.0.0.1       localhost
| 192.168.0.10    sol     loghost
| 192.168.0.15    bsd
| 192.168.0.19    suse2   suse2.MSHOME


To look up a host by its name, you can call gethostbyname. It uses DNS if such access is available, not only the /etc/hosts file. In fact, it was the primary way you got network addresses until getaddrinfo came along, and it’s still used a lot more than getaddrinfo is because gethostbyname is very old, and that’s how almost everyone learned to do things. But, unlike with getaddrinfo, with gethostbyname all you get is the IP address—you still have to build the sockaddr_in structure yourself, as we did in Section 8.2.3. In addition, gethostbyname can’t handle IPv6 addresses. Here’s the synopsis:

gethostbyname—look up host by name

#include <netdb.h>

struct hostent *gethostbyname(
    const char *nodename,      /* node name */
);
/* Returns pointer to hostent or NULL on error (sets h_errno) */



The parenthetical remark at the end of the synopsis is no misprint—this function really does set h_errno, not errno, and the codes it uses aren’t errno codes, either. (I didn’t code an “ec” macro for h_errno because I don’t use the function.)

Here’s an example (display_hostent is from the previous example):

static void gethostbyname_ex(void)
{
    struct hostent *h;

    if ((h = gethostbyname("www.yahoo.com")) == NULL) {
        if (h_errno == HOST_NOT_FOUND)
            printf("host not found\n");
        else
            printf("h_errno = %d\n", h_errno);
    }
    else
        display_hostent(h);
}


Here’s the output we got from a call to this function:

|name: www.yahoo.akadns.net; type: 2; len: 4
|        www.yahoo.com
|        66.218.71.95
|        66.218.70.49
|        66.218.71.88
|        66.218.71.81
|        66.218.71.86
|        66.218.71.92
|        66.218.71.94
|        66.218.71.89
|        66.218.70.48
|        66.218.71.93
|        66.218.70.50
|        66.218.71.87
|        66.218.71.84


You may want to compare this to the output shown in Section 8.2.6, where we did pretty much the same thing with a call to getaddrinfo.

The opposite of gethostbyname is gethostbyaddr, which uses the host database (perhaps DNS) to translate an IP address to a name:

gethostbyaddr—look up host by address

#include <netdb.h>

struct hostent *gethostbyaddr(
    const void *addr,      /* IP address */
    socklen_t len,         /* length of address */
    int family             /* family (called "type" in SUS) */
);
/* Returns pointer to hostent or NULL on error (sets h_errno) */



Here’s an example program (inet_addr is in Section 8.2.3):

static void gethostbyaddr_ex(void)
{
    struct hostent *h;
    in_addr_t a;

    ec_neg1( a = inet_addr("66.218.71.94") )
    if ((h = gethostbyaddr(&a, sizeof(a), AF_INET)) == NULL) {
        if (h_errno == HOST_NOT_FOUND)
            printf("address not found\n");
        else
            printf("h_errno = %d\n", h_errno);
    }
    else
        display_hostent(h);
    return;
EC_CLEANUP_BGN
    EC_FLUSH("gethostbyaddr_ex")
EC_CLEANUP_END
}


The output:

name: w15.www.scd.yahoo.com; type: 2; len: 4
|        66.218.71.94


What happened is that when we got the IP addresses for www.yahoo.com, 66.218.71.94 was on the list, but when we asked for that IP’s name we got w15.www.scd.yahoo.com. That’s the way DNS works—apparently Yahoo uses a lot of servers, which, of course, it must.

gethostbyaddr is just as obsolete as gethostbyname. The modern function is the counterpart to getaddrinfo (Section 8.2.6), called getnameinfo:

getnameinfo—get name information

#include <sys/socket.h>
#include <netdb.h>

int getnameinfo(
    const struct sockaddr *sa,    /* socket address */
    socklen_t sa_len,             /* socket-address length */
    char *nodename,               /* node name */
    socklen_t nodelen,            /* node-name buffer length */
    char *servname,               /* service name */
    socklen_t servlen,            /* service-name buffer length */
    unsigned flags                /* flags */
);
/* Returns 0 on success or error number on error */



getnameinfo takes a whole socket address, not just a bare IP address, because it potentially works with lots of different families. Most importantly, it works with IPv6 addresses, which gethostbyname doesn’t. The answers come back into two buffers: nodename, of length nodelen, for the node (or host) name, and servname, of length servlen, for the service name. If a buffer pointer is NULL or its length is 0, you don’t get that information back.

Like getaddrinfo, the error numbers returned by getnameinfo aren’t errno codes, but special “EAI” codes, and you can use the function gai_strerror (Section 8.2.6) on them if you want. Or, use the ec_ai macro that we’ve provided just for these two functions.

Various flags that you can OR together control what getnameinfo returns:

NI_NOFQDN	Return just the node name part of local hosts, not the fully qualified domain name.
NI_NUMERICHOST	Return the numeric form (dotted notation for IPv4, colon notation for IPv6) of the address instead of the name.
NI_NAMEREQD	Return an error if the host’s name can’t be found. Normally the numeric form is returned in this case.
NI_NUMERICSERV	Return the port number (as a string) instead of the service name.
NI_DGRAM	Look for a SOCK_DGRAM (UDP) service. Normally it looks for a SOCK_STREAM (TCP) service.


Here’s an example:

static void getnameinfo_ex(void)
{
    struct sockaddr_in sa;
    char nodename[200], servname[200];

    sa.sin_family = AF_INET;
    sa.sin_port = htons(80);
    sa.sin_addr.s_addr =  inet_addr("216.109.125.70");
    ec_ai( getnameinfo((struct sockaddr *)&sa, sizeof(sa), nodename,
      sizeof(nodename), servname, sizeof(servname), 0) )
    printf("node: %s; service: %s\n", nodename, servname);
    return;

EC_CLEANUP_BGN
    EC_FLUSH("getnameinfo_ex")
EC_CLEANUP_END
}
------------------------------------------------------------------------ 
Another example:
#include <arpa/inet.h>
#include <netdb.h>
 
int main()
{
  struct sockaddr_in sa;
  sa.sin_family = AF_INET;
  inet_pton(AF_INET, "127.0.0.1", &sa.sin_addr);
 
  char node[NI_MAXHOST];
  int res = getnameinfo((struct sockaddr*)&sa, sizeof(sa), node, sizeof(node), NULL, 0, 0);
  if (res)
  {
    printf("&#37;s\n", gai_strerror(res));
    exit(1);
  }
  printf("%s\n", node);
 
  return 0;
}
------------------------------------------------------------------------ 

The output:

node: w17.www.dcn.yahoo.com; service: http


Another host-oriented function to talk about is:

gethostid—get identifier for local host

#include <unistd.h>

long gethostid(void);
/* Returns identifier (no error return) */



gethostid looks like it might return the local machine’s IP, but it doesn’t necessarily do that. All it’s required to do is return a unique identifier, and whether that even works probably depends on whether such an identifier has been set at boot time. I’ve documented it here just so you don’t accidentally confuse it with a useful function.

There’s another function, not directly associated with networking, that provides information to identify the system:

uname—get info about current system

#include <sys/utsname.h>

int uname(
    struct utsname *info      /* returned info */
);
/* Returns non-negative value on success or -1 on error (sets errno) */


struct utsname—structure for uname

struct utsname {
    char sysname[];           /* OS name */
    char nodename[];          /* node name within network */
    char release[];           /* release number (as string) */
    char version[];           /* version number (as string) */
    char machine[];           /* hardware type or computer model */
};



Unfortunately, none of the members of the utsname structure[8] are standardized, so you can’t use them to control your application’s processing. It would be nice, say, to test the machine member to see if you’re on an Intel CPU; however, each system that runs on that CPU formats the string the way it wants, and the word “Intel” or “x86” might not even be there. What you can do is use the strings for display purposes—maybe to label performance-testing output. And, naturally, the uname system call is the guts of the uname command, our version (lacking options) of which is:

    [8] Empty brackets as shown in the synopsis aren’t legal C, but you get the idea. Each implementation allocates whatever space it needs.

int main(void)
{
    struct utsname info;

    ec_neg1( uname(&info) )
    printf("sysname = %s\n", info.sysname);
    printf("nodename = %s\n", info.nodename);
    printf("release = %s\n", info.release);
    printf("version = %s\n", info.version);
    printf("machine = %s\n", info.machine);
    exit(EXIT_SUCCESS);

EC_CLEANUP_BGN
    exit(EXIT_FAILURE);
EC_CLEANUP_END
}


Here’s the output[9] from running this program on our four test systems; see if you can spot any patterns:

    [9] Output was folded to fit within the page margins.

sysname = SunOS
nodename = sol
release = 5.8
version = Generic_108529-13
machine = i86pc

sysname = Darwin
nodename = Marc-Rochkinds-Computer.local.
release = 6.6
version = Darwin Kernel Version 6.6: Thu May  1 21:48:54 PDT 2003;
  root:xnu/xnu-344.34.obj~1/RELEASE_PPC
machine = Power Macintosh

sysname = FreeBSD
nodename = bsd.MSHOME
release = 4.6-RELEASE
version = FreeBSD 4.6-RELEASE #0: Tue Jun
machine = i386

sysname = Linux
nodename = suse2
release = 2.4.18-4GB
version = #1 Wed Mar 27 13:57:05 UTC 2002
machine = i686


				9.12.1.1.2 Network Functions

Functions in this category get information about networks that the local machine might be connected to. First come three functions like the ones for hosts (e.g., gethostent) for scanning for networks:

setnetent—start network-database scan

#include <netdb.h>

void setnetent(
    int stayopen         /* leave connection open? */
);


getnetent—get network-database entry

#include <netdb.h>

struct netent *getnetent(void);
/* Returns pointer to netent or NULL on end (errno not defined) */


endnetent—end network-database scan

#include <netdb.h>

void endnetent(void);


struct netent—structure for network-database functions

struct netent {
    char *n_name;         /* official network name */
    char **n_aliases;     /* array of alternative network names */
    int n_addrtype;       /* address family (not type) */
    uint32_t n_net;       /* network number */
};



Here’s an example:

static void netdb(void)
{
    struct netent *n;

    setnetent(true);
    while ((n = getnetent()) != NULL)
        display_netent(n);
    endnetent();
}

static void display_netent(struct netent *n)
{
    int i;

    printf("name: %s; type: %d; number: %lu\n", n->n_name, n->n_addrtype,
      (unsigned long)n->n_net);
    for (i = 0; n->n_aliases[i] != NULL; i++)
        printf("\t%s\n", n->n_aliases[i]);
}


With this output:

name: loopback; type: 2; number: 127
name: arpanet; type: 2; number: 10
        arpa


Most, if not all, machines have a loopback network for testing. This machine (running Solaris) also has a connection to an Internet network that it calls “arpanet” in honor of its history. Remember that the “type” displayed is really the family; it turns out that the macro AF_INET is defined as 2.

Analogously to the host database, there are functions for finding an entry by network number or by name:

getnetbyname—look up network by name

#include <netdb.h>

struct netent *getnetbyname(
    const char *name       /* network name (to match n_name member) */
);
/* Returns pointer to netent or NULL if not found (errno not defined) */


getnetbyaddr—look up network by number

#include <netdb.h>

struct netent *getnetbyaddr(
    uint32_t net,          /* network number (to match n_net member) */
    int type               /* family (to match n_addrtype member) */
);
/* Returns pointer to netent or NULL if not found (errno not defined) */



				9.12.1.1.3 Protocol Functions

Following the pattern, the functions for scanning the protocol database are:

setprotoent—start protocol-database scan

#include <netdb.h>

void setprotoent(
    int stayopen          /* leave connection open? */
);


getprotoent—get protocol-database entry

#include <netdb.h>

struct protoent *getprotoent(void);
/* Returns pointer to protoent or NULL on end (errno not defined) */


endprotoent—end protocol-database scan

#include <netdb.h>

void endprotoent(void);


struct protoent—structure for protocol-database functions

struct protoent {
    char *p_name;          /* official protocol name */
    char **p_aliases;      /* array of alternative protocol names */
    int p_proto;           /* protocol number */
};



On some systems, you can use a protocol number for a protocol level when you call setsockopt or getsockopt, but that’s nonstandard.

The example code is pretty obvious if you’ve been reading along:

static void protodb(void)
{
    struct protoent *p;

    setprotoent(true);
    while ((p = getprotoent()) != NULL)
       display_protoent(p);
    endprotoent();
}

static void display_protoent(struct protoent *p)
{
    int i;

    printf("name: %s; number: %d\n", p->p_name, p->p_proto);
    for (i = 0; p->p_aliases[i] != NULL; i++)
        printf("\t%s\n", p->p_aliases[i]);
}


But the output is pretty interesting. On SuSE Linux I got 135 protocols. Here’s just part of the output:
Code View: Scroll / Show All

...
name: mobile; number: 55
        MOBILE
name: tlsp; number: 56
        TLSP
name: skip; number: 57
        SKIP
name: ipv6-icmp; number: 58
        IPv6-ICMP
        ICMPV6
        icmpv6
        icmp6
name: ipv6-nonxt; number: 59
        IPv6-NoNxt
name: ipv6-opts; number: 60
        IPv6-Opts
name: cftp; number: 62
        CFTP
name: sat-expak; number: 64
        SAT-EXPAK
name: kryptolan; number: 65
        KRYPTOLAN
...

					  


There are the two more predictable functions to round out the set:

getprotobyname—look up protocol by name

#include <netdb.h>

struct protoent *getprotobyname(
    const char *name           /* protocol name */
);
/* Returns pointer to protoent or NULL if not found (errno not defined) */


getprotobynumber—look up protocol by number

#include <netdb.h>

struct protoent *getprotobynumber(
    int proto                  /* protocol number */
);
/* Returns pointer to protoent or NULL if not found (errno not defined) */



				9.12.1.1.4 Service Functions

There’s one more set of scanning and get-by-name and number functions, this time for services. These scan the local system’s /etc/services file.

setservent—start service-database scan

#include <netdb.h>

void setservent(
    int stayopen            /* leave connection open? */
);


getservent—get service-database entry

#include <netdb.h>

struct servent *getservent(void);
/* Returns pointer to servent or NULL on end (errno not defined) */


endservent—end service-database scan

#include <netdb.h>

void endservent(void);


struct servent—structure for service-database functions

struct servent {
    char *s_name;          /* official service name */
    char **s_aliases;      /* array of alternative service names */
    int s_port;            /* port number */
    char *s_proto;         /* name of protocol for this service */
};


getservbyname—look up service by name

#include <netdb.h>

struct servent *getservbyname(
    const char *name,      /* service name */
    const char *proto      /* protocol name */
);
/* Returns pointer to protoent or NULL if not found (errno not defined) */


getservbyport—look up service by port

#include <netdb.h>

struct servent *getservbyport(
    int port,              /* port */
    const char *proto      /* protocol name */
);
/* Returns pointer to protoent or NULL if not found (errno not defined) */



And our last example of this ilk is:

static void servdb(void)
{
    struct servent *s;

    setservent(true);
    while ((s = getservent()) != NULL)
        display_servent(s);
    endservent();
}

static void display_servent(struct servent *s)
{
    int i;
    printf("name: %s; port: %d; protocol: %s\n", s->s_name,
       ntohs(s->s_port), s->s_proto);
    for (i = 0; s->s_aliases[i] != NULL; i++)
        printf("\t%s\n", s->s_aliases[i]);
}


The output is huge because /etc/services files are typically huge. Here’s a fragment:

...
name: ftp-data; port: 20; protocol: tcp
name: ftp-data; port: 20; protocol: udp
name: ftp; port: 21; protocol: tcp
name: fsp; port: 21; protocol: udp
name: ssh; port: 22; protocol: tcp
name: ssh; port: 22; protocol: udp
name: telnet; port: 23; protocol: tcp
name: telnet; port: 23; protocol: udp
name: smtp; port: 25; protocol: tcp
        mail
name: smtp; port: 25; protocol: udp
        mail
name: nsw-fe; port: 27; protocol: tcp
name: nsw-fe; port: 27; protocol: udp
name: msg-icp; port: 29; protocol: tcp
name: msg-icp; port: 29; protocol: udp
name: msg-auth; port: 31; protocol: tcp
name: msg-auth; port: 31; protocol: udp
...


				9.12.1.1.5 Network Interface Functions

There’s a set of functions to retrieve the names of the network interfaces and their index numbers. First, here’s a function that gets them all as an array of if_nameindex structures and a corresponding function to free the array:

if_nameindex—get all network interface names and indexes

#include <net/if.h>

struct if_nameindex *if_nameindex(void);
/* Returns array or NULL on error (sets errno) */


if_freenameindex—free array allocated by if_nameindex

#include <net/if.h>

void if_freenameindex(
    struct if_nameindex *ptr /* pointer to array */
  );


struct if_nameindex—structure for network-interface functions

struct if_nameindex {
    unsigned if_index;    /* interface index */
    char *if_name;        /* interface name */
};



Here’s a function that displays the indexes and interfaces:

static void ifdb(void)
{
    struct if_nameindex *ni;
    int i;

    ec_null( ni = if_nameindex() )
    for (i = 0; ni[i].if_index != 0 || ni[i].if_name != NULL; i++)
        printf("index: %d; name: %s\n", ni[i].if_index, ni[i].if_name);
    if_freenameindex(ni);
    return;

EC_CLEANUP_BGN
    EC_FLUSH("ifdb")
EC_CLEANUP_END
}


The output on Solaris was:

index: 1; name: lo0
index: 2; name: iprb0


and on SuSE Linux:

index: 1; name: lo
index: 2; name: eth0


These sort of match up with the network names displayed by the functions in Section 8.8.2: a loopback interface, and an Internet interface using Ethernet.

There’s another function to map a name to its index:

if_nametoindex—map network interface name to index

#include <net/if.h>

unsigned if_nametoindex(
     const char *ifname    /* interface name */
);
/* Returns index or 0 on error (errno not defined) */



Be careful—this function returns 0 if the name isn’t found, not –1.

To map an index to a name, you call:

if_indextoname—map network interface index to name

#include <net/if.h>

char *if_indextoname(
    unsigned ifindex,      /* interface index */
    char *ifname           /* interface name */
);
/* Returns name or NULL on error (sets errno) */



The ifname argument must be a buffer of at least IF_NAMESIZE bytes, which includes space for the terminating NUL byte. It also returns a pointer to that buffer.

		9.12.2 getaddrinfo
#include <irs/netdb.h>  /* if irs headers in standard location else use
                        #include "irs/netdb.h" and use -I /usr/include/test
                        in compile/linker if using the sample test locations*/
#include <netinet/in.h> /* for sockaddr_in and sockaddr_in6 */
#include <arpa/inet.h>  /* for inet_ntop */
#include <stdio.h>      /* for printf */
/* other includes as necessary */

#define GOOD 0          /* good return code */
#define BAD  1          /* fail return code */

int do_getaddrinfo(char *hostname)
{
     struct addrinfo *results=NULL;
     struct addrinfo *loop=NULL;      /* addrinfo structure pointers - defined in netdb.h */
     int      code;                   /* getaddrinfo return code */
     struct sockaddr_in  *sa4;        /* to manipulate IPv4 addresses */
     struct sockaddr_in6 *sa6;        /* to manipulate IPv6 addresses */
     char                 v6[42];     /* for max IPv6 address */

     code = getaddrinfo(hostname, NULL, NULL, &results); /* no hints */
     if(code != 0)
     {
         /* failed */
         printf("getaddrinfo for %s failed=%s", hostname,gai_strerror(code));
         return BAD;
     }else{
         for (loop = results; loop != NULL; loop = loop->ai_next)
         {
             switch(loop->ai_family)
             {
             case AF_INET: /* IPv4 type */
                 sa4 = (struct sockaddr_in *)loop->ai_addr; /* cast to IPv4 socket type */
                 printf("IPv4 name=%s A=%s", hostname, inet_ntoa(sa4->sin_addr) );
                 break;
             case AF_INET6: /* IPv6 type*/
                 sa6 = (struct sockaddr_in6 *)loop->ai_addr; /* cast to IPv6 socket type */
                 printf("IPv4 name=%s AAAA=%s", hostname,
                             inet_ntop(loop->ai_family, &sa6->sin6_addr, v6,42) );
                 break;
             default:
                 printf("Unknown family %d", loop->ai_family);
                 break;
             }
         }
     }
     freeaddrinfo(results);
     return GOOD;
}

					  


getaddrinfo() uses the default order of searching (defined in /etc/nsswitch.conf) so local files such as hosts will always be searched before using DNS.
		9.12.3

	9.13
10. Daemon

	10.1 Creating a Daemon Process in C Language with an Example Program 
A daemon process is a process which runs in background and has no controlling terminal.

Since a daemon process usually has no controlling terminal so almost no user interaction is required. Daemon processes are used to provide services that can well be done in background without any user interaction.

For example a process that runs in background and observes network activity and logs any suspicious communication can be developed as a daemon process.
Daemon Process Design

A daemon process can be developed just like any other process but there is one thing that differentiates it with any other normal process ie having no controlling terminal. This is a major design aspect in creating a daemon process. This can be achieved by :

    Create a normal process (Parent process)
    Create a child process from within the above parent process
    The process hierarchy at this stage looks like :  TERMINAL -> PARENT PROCESS -> CHILD PROCESS
    Terminate the the parent process.
    The child process now becomes orphan and is taken over by the init process.
    Call setsid() function to run the process in new session and have a new group.
    After the above step we can say that now this process becomes a daemon process without having a controlling terminal.
    Change the working directory of the daemon process to root and close stdin, stdout and stderr file descriptors.
    Let the main logic of daemon process run.

So we see that above steps mark basic design steps for creating a daemon.
C fork() Function

Before creating an actual running daemon following the above stated design steps, lets first learn a bit about the fork() system call.

fork() system creates a child process that is exact replica of the parent process. This new process is referred as ‘child’ process.

This system call gets called once (in parent process) but returns twice (once in parent and second time in child). Note that after the fork() system call, whether the parent will run first or the child is non-deterministic. It purely depends on the context switch mechanism. This call returns zero in child while returns PID of child process in the parent process.

Following are some important aspects of this call :

    The child has its own unique process ID, and this PID does not match the ID of any existing process group.
    The child’s parent process ID is the same as the parent’s process ID.
    The child does not inherit its parent’s memory locks.
    Process resource utilization and CPU time counters are reset to zero in the child.
    The child’s set of pending signals is initially empty.
    The child does not inherit semaphore adjustments from its parent.
    The child does not inherit record locks from its parent.
    The child does not inherit timers from its parent.
    The child does not inherit outstanding asynchronous I/O operations from its parent, nor does it inherit  any  asynchronous I/O contexts from its parent.

For more insight information, please read the man page of this system call.
The Implementation

Based on the design as mentioned in the first section. Here is the complete implementation :

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
int main(int argc, char* argv[])
{
FILE *fp= NULL;
pid_t process_id = 0;
pid_t sid = 0;
// Create child process
process_id = fork();
// Indication of fork() failure
if (process_id < 0)
{
printf("fork failed!\n");
// Return failure in exit status
exit(1);
}
// PARENT PROCESS. Need to kill it.
if (process_id > 0)
{
printf("process_id of child process %d \n", process_id);
// return success in exit status
exit(0);
}
//unmask the file mode
umask(0);
//set new session
sid = setsid();
if(sid < 0)
{
// Return failure
exit(1);
}
// Change the current working directory to root.
chdir("/");
// Close stdin. stdout and stderr
close(STDIN_FILENO);
close(STDOUT_FILENO);
close(STDERR_FILENO);
// Open a log file in write mode.
fp = fopen ("Log.txt", "w+");
while (1)
{
//Dont block context switches, let the process sleep for some time
sleep(1);
fprintf(fp, "Logging info...\n");
fflush(fp);
// Implement and call some function that does core work for this daemon.
}
fclose(fp);
return (0);
}

Following is the way through which the code was compiled and executed:

$ gcc -Wall deamon.c -o deamon
$ sudo ./deamon
process_id of child process 2936

Just observe that the control immediately came back to the terminal ie the daemon is now not associated to any terminal.

When you check the log.txt file located in the root directory, you could see that this daemon process is running.

$
$ tail -f /Log.txt
Logging info...
Logging info...
Logging info...
Logging info...
Logging info...
Logging info...
Logging info...
Logging info...
Logging info...
Logging info...

		10.1.1  Also print pid of daemon
add:

FILE *fp1= NULL;
...
// Open a log file in write mode.
fp = fopen ("Log.txt", "w+");
fp1 = fopen ("daemon.pid", "w+");
fprintf(fp1, "%d",getpid());
fclose(fp1);

		10.1.2

	10.2 More Professional example, lwsmd 
static
DWORD
LwSmDaemonize(
    VOID
    )
{
    DWORD dwError = 0;
    pid_t pid = -1;
    int ret = 0;
    int devNull = -1;
    int i = 0;

    /* Open a pipe so the daemon process can notify us
       when it is ready to accept connections.  This means
       the foreground process will not exit until the daemon
       is fully usable */
    if (pipe(gState.notifyPipe) != 0)
    {
        dwError = LwMapErrnoToLwError(errno);
        BAIL_ON_ERROR(dwError);
    }

    pid = fork();

    if (pid < 0)
    {
        dwError = LwMapErrnoToLwError(errno);
        BAIL_ON_ERROR(dwError);
    }
    else if (pid > 0)
    {
        /* We are the foreground process */

        /* Close the write end of the pipe since we don't need it */
        close(gState.notifyPipe[1]);

        /* Wait until daemon process indicates it is fully started by sending error code */
        do
        {
            ret = read(gState.notifyPipe[0], &dwError, sizeof(dwError));
        } while (ret < 0 && errno == EINTR);

        if (dwError)
        {
            fprintf(stderr, "Error: %s (%d)\n", LwWin32ExtErrorToName(dwError), (int) dwError);
        }

        exit(dwError ? 1 : 0);
    }
    
    /* We are the intermediate background process.
       Isolate ourselves from the state of the foreground process
       by changing directory, becoming a session leader,
       redirecting stdout/stderr/stdin to /dev/null, and setting
       a reasonable umask */
    if (chdir("/") != 0)
    {
        dwError = LwMapErrnoToLwError(errno);
        BAIL_ON_ERROR(dwError);
    }

    if (setsid() < 0)
    {
        dwError = LwMapErrnoToLwError(errno);
        BAIL_ON_ERROR(dwError);
    }

    if ((devNull = open("/dev/null", O_RDWR)) < 0)
    {
        dwError = LwMapErrnoToLwError(errno);
        BAIL_ON_ERROR(dwError);
    }

    for (i = 0; i <= 2; i++)
    {
        if (dup2(devNull, i) < 0)
        {
            dwError = LwMapErrnoToLwError(errno);
            BAIL_ON_ERROR(dwError);
        }
    }

    close(devNull);
    umask(0022);

    /* Now that we are isolated, fork the actual daemon process and exit */
    pid = fork();

    if (pid < 0)
    {
        dwError = LwMapErrnoToLwError(errno);
        BAIL_ON_ERROR(dwError);
    }
    else if (pid > 0)
    {
        /* The intermediate background process exits here */
        exit(0);
    }

    /* We are the actual daemon process, continue with startup */

    /* Close the read end of the notification pipe now since we don't need it */
    close(gState.notifyPipe[0]);

    /* Prevent the write end of the notification pipe from being inherited by children */
    if (fcntl(gState.notifyPipe[1], F_SETFD, FD_CLOEXEC) < 0)
    {
        dwError = LwMapErrnoToLwError(errno);
        BAIL_ON_ERROR(dwError);
    }

error:

    return dwError;
}
	10.3

11. libs

	11.1 stdio

		11.1.1 printf
function
<cstdio>
printf
int printf ( const char * format, ... );
Print formatted data to stdout
Writes the C string pointed by format to the standard output (stdout). If format includes format specifiers (subsequences beginning with %), the additional arguments following format are formatted and inserted in the resulting string replacing their respective specifiers.

Parameters
format
C string that contains the text to be written to stdout.
It can optionally contain embedded format specifiers that are replaced by the values specified in subsequent additional arguments and formatted as requested.

A format specifier follows this prototype: [see compatibility note below] 
%[flags][width][.precision][length]specifier 

Where the specifier character at the end is the most significant component, since it defines the type and the interpretation of its corresponding argument:
specifier	Output	Example
d or i	Signed decimal integer	392
u	Unsigned decimal integer	7235
o	Unsigned octal	610
x	Unsigned hexadecimal integer	7fa
X	Unsigned hexadecimal integer (uppercase)	7FA
f	Decimal floating point, lowercase	392.65
F	Decimal floating point, uppercase	392.65
e	Scientific notation (mantissa/exponent), lowercase	3.9265e+2
E	Scientific notation (mantissa/exponent), uppercase	3.9265E+2
g	Use the shortest representation: %e or %f	392.65
G	Use the shortest representation: %E or %F	392.65
a	Hexadecimal floating point, lowercase	-0xc.90fep-2
A	Hexadecimal floating point, uppercase	-0XC.90FEP-2
c	Character	a
s	String of characters	sample
p	Pointer address	b8000000
n	Nothing printed.
The corresponding argument must be a pointer to a signed int.
The number of characters written so far is stored in the pointed location.	
%	A % followed by another % character will write a single % to the stream.	%

The format specifier can also contain sub-specifiers: flags, width, .precision and modifiers (in that order), which are optional and follow these specifications:

flags	description
-	Left-justify within the given field width; Right justification is the default (see width sub-specifier).
+	Forces to preceed the result with a plus or minus sign (+ or -) even for positive numbers. By default, only negative numbers are preceded with a - sign.
(space)	If no sign is going to be written, a blank space is inserted before the value.
#	Used with o, x or X specifiers the value is preceeded with 0, 0x or 0X respectively for values different than zero.
Used with a, A, e, E, f, F, g or G it forces the written output to contain a decimal point even if no more digits follow. By default, if no digits follow, no decimal point is written.
0	Left-pads the number with zeroes (0) instead of spaces when padding is specified (see width sub-specifier).

width	description
(number)	Minimum number of characters to be printed. If the value to be printed is shorter than this number, the result is padded with blank spaces. The value is not truncated even if the result is larger.
*	The width is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted.

.precision	description
.number	For integer specifiers (d, i, o, u, x, X): precision specifies the minimum number of digits to be written. If the value to be written is shorter than this number, the result is padded with leading zeros. The value is not truncated even if the result is longer. A precision of 0 means that no character is written for the value 0.
For a, A, e, E, f and F specifiers: this is the number of digits to be printed after the decimal point (by default, this is 6).
For g and G specifiers: This is the maximum number of significant digits to be printed.
For s: this is the maximum number of characters to be printed. By default all characters are printed until the ending null character is encountered.
If the period is specified without an explicit value for precision, 0 is assumed.
.*	The precision is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted.

The length sub-specifier modifies the length of the data type. This is a chart showing the types used to interpret the corresponding arguments with and without length specifier (if a different type is used, the proper type promotion or conversion is performed, if allowed):
specifiers
length	d i	u o x X	f F e E g G a A	c	s	p	n
(none)	int	unsigned int	double	int	char*	void*	int*
hh	signed char	unsigned char					signed char*
h	short int	unsigned short int					short int*
l	long int	unsigned long int		wint_t	wchar_t*		long int*
ll	long long int	unsigned long long int					long long int*
j	intmax_t	uintmax_t					intmax_t*
z	size_t	size_t					size_t*
t	ptrdiff_t	ptrdiff_t					ptrdiff_t*
L			long double				
Note that the c specifier takes an int (or wint_t) as argument, but performs the proper conversion to a char value (or a wchar_t) before formatting it for output.

Note: Yellow rows indicate specifiers and sub-specifiers introduced by C99. See <cinttypes> for the specifiers for extended types.
... (additional arguments)
Depending on the format string, the function may expect a sequence of additional arguments, each containing a value to be used to replace a format specifier in the format string (or a pointer to a storage location, for n).
There should be at least as many of these arguments as the number of values specified in the format specifiers. Additional arguments are ignored by the function.

Return Value
On success, the total number of characters written is returned.

If a writing error occurs, the error indicator (ferror) is set and a negative number is returned.

If a multibyte character encoding error occurs while writing wide characters, errno is set to EILSEQ and a negative number is returned.

Example
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
/* printf example */
#include <stdio.h>

int main()
{
   printf ("Characters: %c %c \n", 'a', 65);
   printf ("Decimals: %d %ld\n", 1977, 650000L);
   printf ("Preceding with blanks: %10d \n", 1977);
   printf ("Preceding with zeros: %010d \n", 1977);
   printf ("Some different radices: %d %x %o %#x %#o \n", 100, 100, 100, 100, 100);
   printf ("floats: %4.2f %+.0e %E \n", 3.1416, 3.1416, 3.1416);
   printf ("Width trick: %*d \n", 5, 10);
   printf ("%s \n", "A string");
   return 0;
}


Output:

Characters: a A
Decimals: 1977 650000
Preceding with blanks:       1977
Preceding with zeros: 0000001977
Some different radices: 100 64 144 0x64 0144
floats: 3.14 +3e+000 3.141600E+000
Width trick:    10
A string

Compatibility
Particular library implementations may support additional specifiers and sub-specifiers.
Those listed here are supported by the latest C and C++ standards (both published in 2011), but those in yellow were introduced in C99 (only required for C++ implementations since C++11), and may not be supported by libraries that comply with older standards.

See also
puts
Write string to stdout (function )
scanf
Read formatted data from stdin (function )
fprintf
Write formatted data to stream (function )
fwrite
Write block of data to stream (function )
		11.1.2

	11.2

12. Keywords

	12.1 The UNION keyword.

The union keyword allows several variables of different type and size to occupy the same storage location.
The syntax to define a union is simular to the struct keyword as shown below:

	union union_def { int a; float b; char c;} ;
and a variable declared with either of these statements:
	union union_def union_var;
	union { int a; float b; char c;} union_var;
If you wish to initalise a variable you can say:
	union { int a; float b; char c;} union_var=97;
By default the first variable (a) is initalised.
To assign a value to a variable you can say:

	union_var.b=99.99;
	union_var.a=34;
	union_var.c='x';
It's important to note that the storage will only hold ONE value, looking at the three lines above, union_var.a overwrites union_var.b and then union_var.c overwrites union_var.a
I have yet to see more than one use for this keyword.

		12.1.1 Example
Unions are usually used with the company of a discriminator: a variable indicating which of the fields of the union is valid. For example, let's say you want to create your own Variant type:

struct my_variant_t {
    int type;
    union {
        char char_value;
        short short_value;
        int int_value;
        long long_value;
        float float_value;
        double double_value;
        void* ptr_value;
    };
};
Then you would use it such as:

/* construct a new float variant instance */
void init_float(struct my_variant_t* v, float initial_value) {
    v->type = VAR_FLOAT;
    v->float_value = initial_value;
}

/* Increments the value of the variant by the given int */
void inc_variant_by_int(struct my_variant_t* v, int n) {
    switch (v->type) {
    case VAR_FLOAT:
        v->float_value += n;
        break;

    case VAR_INT:
        v->int_value += n;
        break;
    ...
    }
}
This is actually a pretty common idiom, specially on Visual Basic internals.

For a real example see SDL's SDL_Event union. (actual source code here). There is a type field at the top of the union, and the same field is repeated on every SDL_*Event struct. Then, to handle the correct event you need to check the value of the type field.

The benefits are simple: there is one single data type to handle all event types without using unnecessary memory.
		12.1.2


	12.2

13. Recipes

	13.1  Files


		13.1.1  Setup a marker file to indicate Process was shutdown rather than crashed
/*
 * =====================================================================================
 *
 *       Filename:  ProcShutDownMarkerFile.c
 *
 *    Description:  Setup a marker file to indicate Process was shutdown rather than crashed
 *
 *        Version:  1.0
 *        Created:  01/07/2014 10:55:40
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Yosi Izaq
 *   Organization:  
 *
 * =====================================================================================
 */
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <stdio.h>
#include <sys/stat.h>
#include <time.h>
#include <unistd.h>

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  main
 *  Description:  
 * =====================================================================================
 */
	int
main ( int argc, char *argv[] )
{
        time_t rawtime;
        struct tm * p_timeinfo;
	FILE	*p_marker;										/* input-file pointer */
	char	*p_marker_file_name = ".lwsmd_maker";		/* input-file name    */

	struct stat   stat_buffer;   
	if (stat (p_marker_file_name , &stat_buffer) )
	{
		printf(" Marker file %s doesn't exist. Process was shutdown correctly. Creting now... \n ", p_marker_file_name);

	        p_marker	= fopen( p_marker_file_name, "a+" );
	        if ( p_marker == NULL ) {
	        	fprintf ( stderr, "couldn't open file '%s'; %s\n", p_marker_file_name, strerror(errno) );
	        	exit (EXIT_FAILURE);
	        }
	        if( fclose(p_marker) == EOF ) {			/* close input file   */ fprintf ( stderr, "couldn't close file '%s'; %s\n", p_marker_file_name, strerror(errno) );
	        	exit (EXIT_FAILURE);
	        }
	}
	else
	{
		printf(" Marker file %s exist. Process was not shutdown correctly!  \n ", p_marker_file_name);
	}


	for (int i=20; i>0; --i) // 20 sec
	{
		time ( &rawtime );
                p_timeinfo = localtime ( &rawtime );
		printf(" Simulate daemon, time - %s\n ", asctime(p_timeinfo));
		sleep(1);

	}

	//proper shutdown, delete marker
	if( remove( p_marker_file_name) != 0 ) perror( "Error deleting marker file" );
	else printf( "Marker file successfully deleted\n" );

	return EXIT_SUCCESS;
}				/* ----------  end of function main  ---------- */

- Run example:
[yizaq@yizaq-mac:Tue Jan 07:~/Desktop/Work/code/C:]$ a.out 
 Marker file .lwsmd_maker doesn't exist. Process was shutdown correctly. Creting now... 
  Simulate daemon, time - Tue Jan  7 12:31:16 2014

  Simulate daemon, time - Tue Jan  7 12:31:17 2014

  Simulate daemon, time - Tue Jan  7 12:31:18 2014

  Simulate daemon, time - Tue Jan  7 12:31:19 2014

  Simulate daemon, time - Tue Jan  7 12:31:20 2014

  Simulate daemon, time - Tue Jan  7 12:31:21 2014

  Simulate daemon, time - Tue Jan  7 12:31:22 2014

  Simulate daemon, time - Tue Jan  7 12:31:23 2014

  Simulate daemon, time - Tue Jan  7 12:31:24 2014

  Simulate daemon, time - Tue Jan  7 12:31:25 2014

  Simulate daemon, time - Tue Jan  7 12:31:26 2014

  Simulate daemon, time - Tue Jan  7 12:31:27 2014

  Simulate daemon, time - Tue Jan  7 12:31:28 2014

  Simulate daemon, time - Tue Jan  7 12:31:29 2014

  Simulate daemon, time - Tue Jan  7 12:31:30 2014

  Simulate daemon, time - Tue Jan  7 12:31:31 2014

  Simulate daemon, time - Tue Jan  7 12:31:32 2014

  Simulate daemon, time - Tue Jan  7 12:31:33 2014

  Simulate daemon, time - Tue Jan  7 12:31:34 2014

  Simulate daemon, time - Tue Jan  7 12:31:35 2014

 Marker file successfully deleted
[yizaq@yizaq-mac:Tue Jan 07:~/Desktop/Work/code/C:]$ a.out 
 Marker file .lwsmd_maker doesn't exist. Process was shutdown correctly. Creting now... 
  Simulate daemon, time - Tue Jan  7 12:31:40 2014

  Simulate daemon, time - Tue Jan  7 12:31:41 2014

  Simulate daemon, time - Tue Jan  7 12:31:42 2014

  Simulate daemon, time - Tue Jan  7 12:31:43 2014

  Simulate daemon, time - Tue Jan  7 12:31:44 2014

^C
[yizaq@yizaq-mac:Tue Jan 07:~/Desktop/Work/code/C:]$ a.out 
 Marker file .lwsmd_maker exist. Process was not shutdown correctly!  
  Simulate daemon, time - Tue Jan  7 12:31:47 2014

  Simulate daemon, time - Tue Jan  7 12:31:48 2014

^C
[yizaq@yizaq-mac:Tue Jan 07:~/Desktop/Work/code/C:]$ a.out 
 Marker file .lwsmd_maker exist. Process was not shutdown correctly!  
  Simulate daemon, time - Tue Jan  7 12:31:51 2014

  Simulate daemon, time - Tue Jan  7 12:31:52 2014

  Simulate daemon, time - Tue Jan  7 12:31:53 2014

  Simulate daemon, time - Tue Jan  7 12:31:54 2014

  Simulate daemon, time - Tue Jan  7 12:31:55 2014

  Simulate daemon, time - Tue Jan  7 12:31:56 2014

  Simulate daemon, time - Tue Jan  7 12:31:57 2014

  Simulate daemon, time - Tue Jan  7 12:31:58 2014

  Simulate daemon, time - Tue Jan  7 12:31:59 2014

  Simulate daemon, time - Tue Jan  7 12:32:00 2014

  Simulate daemon, time - Tue Jan  7 12:32:01 2014

  Simulate daemon, time - Tue Jan  7 12:32:02 2014

  Simulate daemon, time - Tue Jan  7 12:32:03 2014

  Simulate daemon, time - Tue Jan  7 12:32:04 2014

  Simulate daemon, time - Tue Jan  7 12:32:05 2014

  Simulate daemon, time - Tue Jan  7 12:32:06 2014

  Simulate daemon, time - Tue Jan  7 12:32:07 2014

  Simulate daemon, time - Tue Jan  7 12:32:08 2014

  Simulate daemon, time - Tue Jan  7 12:32:09 2014

  Simulate daemon, time - Tue Jan  7 12:32:10 2014

 Marker file successfully deleted


	13.2 Memory
		13.2.1  Memory allocating service function demo
[yizaq@YIZAQ-M-D1BW:Mon Apr 14:~/Desktop/Work/code/C:]$ gcc MemAlloc.c 
[yizaq@YIZAQ-M-D1BW:Mon Apr 14:~/Desktop/Work/code/C:]$ a.out
Starting memory allocation in C demo...
f_memUser - Starting memory allocation using function 
f_alloc - Starting memory allocation function 
f_alloc - calloc...
f_alloc - malloc...
f_alloc - memcpy...
f_alloc - increment...
f_alloc - Copied string is abcd
f_alloc - 2nd malloc...
f_alloc - 2nd memcpy...
f_alloc - 2nd increment...
f_alloc - Copied string is xxx
f_alloc - Copied string is yy. Total length is 2
f_alloc - Ptr to char** array is 0x7fb403c03950, passed 0x7fff531c1a28, deref 0x7fb403c03950
f_memUser - Ptr to char** array is 0x7fb403c03950
f_memUser - Returned 2 length of string list
Str 1 is abcd
Str 2 is xxx
Str 3 is yy

- Code

/*
 * =====================================================================================
 *
 *       Filename:  MemAlloc.c
 *
 *    Description:  Excersise in memory allocating functions
 *
 *        Version:  1.0
 *        Created:  04/13/2014 19:35:28
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Yosi Izaq
 *   Organization:  
 *
 * =====================================================================================
 */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int f_alloc(char *** pppCharArr, unsigned int * piLen)
{

	const unsigned int ic_cells = 3;
	char str1[5] = "abcd"; 
	char str2[4] = "xxx"; 
	char str3[3] = "yy"; 
	printf("%s - Starting memory allocation function \n", __func__);

	printf("%s - calloc...\n", __func__);
	*pppCharArr = (char **) calloc(ic_cells, sizeof(char *) );
	//piLen =  calloc(1, sizeof(unsigned int ) ) ;
	*piLen = 0;
	char ** ppTmpCharArr = *pppCharArr;

	printf("%s - malloc...\n", __func__);
        ppTmpCharArr[*piLen] = malloc(strlen(str1) +1);
	printf("%s - memcpy...\n", __func__);
	memcpy(ppTmpCharArr[*piLen], str1, strlen(str1) +1); 
	printf("%s - increment...\n", __func__);
	printf("%s - Copied string is %s\n", __func__, ppTmpCharArr[*piLen] );
	(*piLen)++;

	printf("%s - 2nd malloc...\n", __func__);
        ppTmpCharArr[*piLen] = malloc(strlen(str2) +1);
	printf("%s - 2nd memcpy...\n", __func__);
	memcpy(ppTmpCharArr[*piLen], str2, strlen(str2) +1); 
	printf("%s - 2nd increment...\n", __func__);
	printf("%s - Copied string is %s\n", __func__, ppTmpCharArr[*piLen] );
	(*piLen)++;

        ppTmpCharArr[*piLen] = malloc(strlen(str3) +1);
	memcpy(ppTmpCharArr[*piLen], str3, strlen(str3) +1); 
	printf("%s - Copied string is %s. Total length is %u\n", __func__, ppTmpCharArr[*piLen], *piLen );

	printf("%s - Ptr to char** array is %p, passed %p, deref %p\n", __func__, ppTmpCharArr ,  pppCharArr ,  *pppCharArr);
	return 0;
}

int f_memUser()
{

	printf("%s - Starting memory allocation using function \n", __func__);
char ** ppCharArr;
unsigned int  iLen = 0;

	f_alloc(&ppCharArr, &iLen);

	printf("%s - Ptr to char** array is %p\n", __func__, ppCharArr );
	printf("%s - Returned %u length of string list\n", __func__, iLen);
	for (unsigned int i = 0; i < iLen+1; i++) {
		printf("Str %u is %s. Freeing it...\n",i+1, ppCharArr[i]);
		free (ppCharArr[i]); 
	}


	printf("%s - Free char** array\n", __func__);
        free (ppCharArr); 

	return 0;
}

int main(int argc, const char *argv[])
{
	printf("Starting memory allocation in C demo...\n");

	f_memUser();
	return 0;
}



		13.2.2


	13.3 C Function Converts ASCII Hex to Binary

The C listing in the text file attached to EDN BBS /DI_SIG #1436 is a simple function that converts an ASCII hexadecimal string to binary. The function htoi works very much like the standard atoi library function.

/*****************************************************************************

Software Design Note - htoi function

The standard C library contains functions to convert an ASCII numeric string 
to integer, long, or floating binary numbers.  However the library doesn't 
provide a simple function to convert an ASCII hexadecimal string to binary.  
That's what htoi does.

The htoi function works like the atoi library function, except it assumes the 
string is ASCII hexadecimal (upper or lower case).  Like atoi, htoi skips over 
leading whitespace (tabs or spaces), terminates on the first non-hex 
character, and has no provision for detecting overflow.

The function accepts one parameter, a pointer to the most-significant ASCII 
hex digit.  The function returns an unsigned int from 0x0000 to 0xffff (or up 
to 0xffffffff with compilers that support 32-bit integers).

Here are some examples of how to use htoi:

unsigned int nbr1, nbr2, nbr3;
char string1 [] = "  12ab  ";
char string2 [] = "\t\t  7Fxx";
char string3 [] = "Aa55Bb66 1234";
                                ----result----
    nbr1 = htoi (string1);      nbr1 is 0x12ab
    nbr2 = htoi (string2);      nbr2 is 0x7f
    nbr3 = htoi (string3);       nbr3 is 0xbb66 (0xaa55bb66 on 32-bit systems)
    nbr3 = htoi (&string3[8]);  nbr3 is 0x1234

*****************************************************************************/

unsigned int htoi (const char *ptr)
{
unsigned int value = 0;
char ch = *ptr;

/*--------------------------------------------------------------------------*/

    while (ch == ' ' || ch == '\t')
        ch = *(++ptr);

    for (;;) {

        if (ch >= '0' && ch <= '9')
            value = (value << 4) + (ch - '0');
        else if (ch >= 'A' && ch <= 'F')
            value = (value << 4) + (ch - 'A' + 10);
        else if (ch >= 'a' && ch <= 'f')
            value = (value << 4) + (ch - 'a' + 10);
        else
            return value;
        ch = *(++ptr);
    }
}

	13.4
14. Code generation


	14.1 Flex byson


		14.1.1  Tutorial

	w w w . a q u a m e n t u s . c o m
  What are Flex and Bison?
    lex vs. flex, yacc vs. bison
    what we'll do!
  Flex
    reading from a file
  Bison
    a makefile
    forcing carriage returns
    line numbers
  Tips
    directly returning terminal characters
    actions before the end of the grammar
    whitespace in flex/bison files
    avoiding -lfl and link problems with yywrap
    renaming identifiers
    moving output
  Advanced
    start states
    reading gzipped input
  Regular expression overview

What are Flex and Bison?

Flex and Bison are aging unix utilities that help you write very fast parsers for almost arbitrary file formats. Formally, they implement Look-Ahead-Left-Right (as opposed to "recursive descent") parsing of non-ambiguous context-free (as opposed to "natural language") grammars.

Why should you learn the Flex/Bison pattern syntax when you could just write your own parser? Well, several reasons. First, Flex and Bison will generate a parser that is virually guaranteed to be faster than anything you could write manually in a reasonable amount of time. Second, updating and fixing Flex and Bison source files is a lot easier than updating and fixing custom parser code. Third, Flex and Bison have mechanisms for error handling and recovery, which is something you definitely don't want to try to bolt onto a custom parser. Finally, Flex and Bison have been around for a long time, so they far freer from bugs than newer code.

This webpage is supposed to be a tutorial for complete novices needing to use Flex and Bison for some real project. I wrote it as I was learning them, so hopefully it explains things right as you need to know them. The Flex and Bison tutorials I found Googling around tended to be really heavy on theory and details.


lex vs. flex, yacc vs. bison

In addition to hearing about "flex and bison", you will also hear about "lex and yacc". "lex and yacc" are the original tools; "flex and bison" are their almost completely compatible newer versions. Only very old code uses lex and yacc; most of the world has moved on to Flex and Bison.

All four of the above are C-based tools; they're written in C, but more important their output is C code. However, my project was in C++ -- so this is also a tutorial on how to use C++ with Flex and Bison!


what we'll do!

Let's create a Flex/Bison parser for a silly format that I'll call "snazzle". Snazzle files have four general sections:

a header that just says "sNaZZle 1.0", with version info,
a typedef section that defines types like "type foo" and "type bas",
a body section with actual data consisting of 4 numbers and one of the types,
and a footer that just says "end".
(I don't have a particular file format or program in mind, I'm just coming up with this.) Here's an example of our silly format:
sNaZZle 1.3
type foo
type bar
type bas
0 0 10 5        foo
20 10 30 20     foo
7 8 12 13       bas
78 124 100 256  bar
end
For making parsers, you want to start at the high level because that's how Bison thinks about them. We start by saying that a "snazzlefile" is comprised of four general parts; we'll call them "header", "typedefs", "body", and "footer". Then we describe the sub-parts that comprise each of those four general parts, and then what comprises each of the those sub-parts, and so on until we get all the way down what are called terminal symbols. Terminal symbols are the smallest units of your grammar -- for our example here, integers like "15" are one of our terminal symbols. (But not the individual characters "1" and "5" that make it up.) Terminal symbols are the boundary between Flex and Bison: Flex sees the individual "1" and "5" characters but combines them into "15" before giving it to Bison.


Flex

For our silly snazzle files, we'll make 3 terminal symbol types: a NUMBER that's basically an integer, a FLOAT that's a floating-point number (which we only need for the version), and a STRING which is pretty much everything else. Furthermore, since this is a tutorial, let's show off Flex's power by making a program that just lexes our input without using Bison to parse it. Here's the first whack:

snazzle.l
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
%{
#include <iostream>
using namespace std;
#define YY_DECL extern "C" int yylex()
%}
%%
[ \t\n]         ;
[0-9]+\.[0-9]+  { cout << "Found a floating-point number:" << yytext << endl; }
[0-9]+          { cout << "Found an integer:" << yytext << endl; }
[a-zA-Z0-9]+    { cout << "Found a string: " << yytext << endl; }
%%
main() {
	// lex through the input:
	yylex();
}
Flex and Bison files have three sections:

the first is sort of "control" information,
the second is the actual token/grammar definitions,
the last is C code to be copied verbatim to the output.
These sections are divided by %%, which you see on lines 6 and 11. Let's go through this line by line.
Lines 1 (and 5) are delimeters that tell Flex that lines 2 through 4 are C code to be copied directly to the generated lexer.
Lines 2 and 3 are to get access to cout.
Line 4 is to force the g++ compiler to not apply "name-mangling" to the yylex identifier. If we don't do this, g++ generates the function's name as something like "_Z5yylexv", where no one will ever be able to find it or link to it.
Line 6 is %%, which means we're done with the control section and moving on to the token section. Notice that we don't have much in our control section -- the Bison control section gets a lot more usage than the Flex one. And here, we wouldn't need one at all if we weren't using this from C++.
Lines 7-10 are all the same (simple) format: a regular expression (a topic in its own right, which I touch on not at all exhaustively at the end of this page) and an action. When Flex is reading through an input file and can match one of the regular expressions, it executes the action. The regular expression is not Perl's idea of a regular expression, so you can't use "\d", but the normal stuff is all available. The action is just C code that is copied into the eventual flex output; accordingly, you can have a single statement or you can have curly braces with a whole bunch of statements. Some specifics on the file format I discovered: the action has to be left-justified (if there's whitespace beginning a line where a pattern is expected, the line is considered a comment!); the separation between the pattern and the action is just whitespace (even just a single space will do); the action is not limited to a single line if you use curly braces.
Line 11 is another %% delimiter, meaning we're done with the second section and we can go onto the third.
Lines 12-15 are the third section, which is exclusively for copied C code. (Notice that, unlike the control section at the top, there is no "%{" or "%}".) We don't normally need to put anything in this section for the Flex file, but for this example we're going to put a main() function in here so that we can execute the output without having to make another file and link them together.
This example can be compiled by running this:

% flex snazzle.l
This will produce the file "lex.yy.c", which we can then compile with g++:
% g++ lex.yy.c -lfl -o snazzle
Notice the "-lfl", which links in the dynamic flex libraries. (If you don't have Flex installed, and you can't get it installed, you might try "-ll" instead -- that requests lex's .so instead of flex's .so. If that doesn't work, ask someone who'll know where on your system the Flex libraries are kept.) (Or, leave the -l off completely, and do a quick Google search to figure out how to implement stub versions of the missing functions it complains about.)
If all went as planned, you should be able to run it and enter stuff on STDIN to be lexed:

% ./snazzle
90
Found an integer:90
23.4
Found a floating-point number:23.4
4 5 6
Found an integer:4
Found an integer:5
Found an integer:6
this is text!
Found a string: this
Found a string: is
Found a string: text
 !
Pretty cool! Notice that the exclamation mark at the very end was just echoed: when Flex finds something that doesn't match any of the regexs it echos it to STDOUT. Usually this is a good indication that your token definitions aren't complete enough, but to get rid of it for now you could just add ". ;" to the token section, which will match anything (the "." of regex nomenclature) and do nothing with it (the empty C statement ";").

Now for a little more detail on the syntax for the middle section. In general, it is really as simple as "a regex match" followed by "what to do with it". The "what to do with it" can vary a lot though - for example, most parsers completely ignore whitespace, which you can do by making the "action" just a semicolon:

[ \t] ;  // ignore all whitespace
Most parsers also want to keep track of the line number, which you would do by catching all the carriage returns and incrementing a line counter. However, you want the carriage return itself to be ignored as if it were whitespace, so even though you have an action performed here you want to not put a return statement in it:
\n    { ++linenum; }  // increment line count, but don't return a token
Pretty much everything else will need to return a token to Bison, but more on that later.

reading from a file

OK, first big upgrade: reading from a file. Right now we're reading from STDIN, which is kind of annoying, because most of the time you'd really like to pick a file to read from. Flex reads its input from a global pointer to a C FILE variable called yyin, which is set to STDIN by default. All you have to do is set that pointer to your own file handle, and it'll read from it instead. That changes our example as follows (the differences are in bold):

snazzle.l
%{
#include <iostream>
using namespace std;
#define YY_DECL extern "C" int yylex()
%}
%%
[ \t\n]          ;
[0-9]+\.[0-9]+   { cout << "Found a floating-point number:" << yytext << endl; }
[0-9]+           { cout << "Found an integer:" << yytext << endl; }
[a-zA-Z0-9]+     { cout << "Found a string: " << yytext << endl; }
.                ;
%%
main() {
	
	// open a file handle to a particular file:
	FILE *myfile = fopen("a.snazzle.file", "r");
	// make sure it's valid:
	if (!myfile) {
		cout << "I can't open a.snazzle.file!" << endl;
		return -1;
	}
	// set lex to read from it instead of defaulting to STDIN:
	yyin = myfile;
	
	// lex through the input:
	yylex();
}
Here's how to run our new code, though there's nothing earth-shattering:

% flex snazzle.l
% g++ lex.yy.c -lfl -o snazzle
% cat a.snazzle.file
90
23.4
4 5 6
this is text!
% ./snazzle
Found an integer:90
Found a floating-point number:23.4
Found an integer:4
Found an integer:5
Found an integer:6
Found a string: this
Found a string: is
Found a string: text
%

Bison

The first thing we have to do in our silly parser is to start defining the terminal tokens, which for us are ints, floats, and strings. Even though these are the types of tokens (which is what Flex returns), defining token types is done in the Bison file. We're also going to move main() into the copied-C-code section of the Bison file now:

snazzle.y
%{
#include <cstdio>
#include <iostream>
using namespace std;

// stuff from flex that bison needs to know about:
extern "C" int yylex();
extern "C" int yyparse();
extern "C" FILE *yyin;
 
void yyerror(const char *s);
%}

// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "yystype".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "yystype":
%union {
	int ival;
	float fval;
	char *sval;
}

// define the "terminal symbol" token types I'm going to use (in CAPS
// by convention), and associate each with a field of the union:
%token <ival> INT
%token <fval> FLOAT
%token <sval> STRING

%%
// this is the actual grammar that bison will parse, but for right now it's just
// something silly to echo to the screen what bison gets from flex.  We'll
// make a real one shortly:
snazzle:
	INT snazzle      { cout << "bison found an int: " << $1 << endl; }
	| FLOAT snazzle  { cout << "bison found a float: " << $1 << endl; }
	| STRING snazzle { cout << "bison found a string: " << $1 << endl; }
	| INT            { cout << "bison found an int: " << $1 << endl; }
	| FLOAT          { cout << "bison found a float: " << $1 << endl; }
	| STRING         { cout << "bison found a string: " << $1 << endl; }
	;
%%

main() {
	// open a file handle to a particular file:
	FILE *myfile = fopen("a.snazzle.file", "r");
	// make sure it is valid:
	if (!myfile) {
		cout << "I can't open a.snazzle.file!" << endl;
		return -1;
	}
	// set flex to read from it instead of defaulting to STDIN:
	yyin = myfile;
	
	// parse through the input until there is no more:
	do {
		yyparse();
	} while (!feof(yyin));
	
}

void yyerror(const char *s) {
	cout << "EEK, parse error!  Message: " << s << endl;
	// might as well halt now:
	exit(-1);
}

Now that the Bison file knows what the terminal types are, we can use them in the Flex file to make our life easier:

snazzle.l
%{
#include <cstdio>
#include <iostream>
using namespace std;
#define YY_DECL extern "C" int yylex()

#include "snazzle.tab.h"  // to get the token types that we return

%}
%%
[ \t\n]           ;
[0-9]+\.[0-9]+ { yylval.fval = atof(yytext); return FLOAT; }
[0-9]+            { yylval.ival = atoi(yytext); return INT; }
[a-zA-Z0-9]+      {
	// we have to copy because we can't rely on yytext not changing underneath us:
	yylval.sval = strdup(yytext);
	return STRING;
}
.                ;
%%
Since the Flex file now has to #include a file generated by Bison (snazzle.tab.h), we have to run Bison first:

% bison -d snazzle.y
% flex snazzle.l
% g++ snazzle.tab.c lex.yy.c -lfl -o snazzle
% ./snazzle
bison found a string: text
bison found a string: is
bison found a string: this
bison found an int: 6
bison found an int: 5
bison found an int: 4
bison found a float: 23.4
bison found an int: 90
%
You'll notice that the input is echoed out backward! This is because for each of the rules you define, Bison does not perform the action until it matches the complete rule. In the above example, all of the recursive rules were right-recursive (i.e. they looked like "foo: bar foo", instead of "foo: foo bar"). The right-recursive search will print the output backwards since it has to match EVERYTHING before it can start figuring out what's what, AND it has another major drawback: if your input is big enough, right-recursive rules will overflow Bison's internal stack! So a better implementation of the Bison grammar would be left-recursion:

snazzle.y
%{
#include <cstdio>
#include <iostream>
using namespace std;

#include "y.tab.h"  // to get the token types that we return

// stuff from flex that bison needs to know about:
extern "C" int yylex();
extern "C" int yyparse();
extern "C" FILE *yyin;
 
void yyerror(const char *s);
%}

// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "yystype".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "yystype":
%union {
	int ival;
	float fval;
	char *sval;
}

// define the "terminal symbol" token types I'm going to use (in CAPS
// by convention), and associate each with a field of the union:
%token <ival> INT
%token <fval> FLOAT
%token <sval> STRING

%%
// this is the actual grammar that bison will parse, but for right now it's just
// something silly to echo to the screen what bison gets from flex.  We'll
// make a real one shortly:
snazzle:
	snazzle INT { cout << "bison found an int: " << $2 << endl; }
	| snazzle FLOAT { cout << "bison found a float: " << $2 << endl; }
	| snazzle STRING { cout << "bison found a string: " << $2 << endl; } 
	| INT { cout << "bison found an int: " << $1 << endl; }
	| FLOAT { cout << "bison found a float: " << $1 << endl; }
	| STRING { cout << "bison found a string: " << $1 << endl; }
	;
%%

main() {
	// open a file handle to a particular file:
	FILE *myfile = fopen("a.snazzle.file", "r");
	// make sure it is valid:
	if (!myfile) {
		cout << "I can't open a.snazzle.file!" << endl;
		return -1;
	}
	// set flex to read from it instead of defaulting to STDIN:
	yyin = myfile;
	// parse through the input until there is no more:
	do {
		yyparse();
	} while (!feof(yyin));
}

void yyerror(const char *s) {
	cout << "EEK, parse error!  Message: " << s << endl;
	// might as well halt now:
	exit(-1);
}
(Note that we also had to change the $1 in the cout to a $2 since the thing we wanted to print out is now the second element in the rule.) This gives us the output we would hope for:

% bison -d snazzle.y
% g++ snazzle.tab.c lex.yy.c -lfl -o snazzle
% ./snazzle
bison found an int: 90
bison found a float: 23.4
bison found an int: 4
bison found an int: 5
bison found an int: 6
bison found a string: this
bison found a string: is
bison found a string: text
%
Now that the groundwork is completed, we can finally define the real file format in the Bison file. First we make the easy tokens: the ones that are used to represent constant strings like SNAZZLE, TYPE, and END, respectively representing the strings "sNaZZle", "type", and "end". Then we flesh out the actual rules in the Bison grammar, and end up with this beautiful object d'art:

snazzle.l
%{
#include <iostream>
#include "snazzle.tab.h"
using namespace std;
#define YY_DECL extern "C" int yylex()
%}
%%
[ \t] ;
sNaZZle        { return SNAZZLE; }
type           { return TYPE; }
end            { return END; }
[0-9]+\.[0-9]+ { yylval.fval = atof(yytext); return FLOAT; }
[0-9]+         { yylval.ival = atoi(yytext); return INT; }
[a-zA-Z0-9]+   {
	// we have to copy because we can't rely on yytext not changing underneath us:
	yylval.sval = strdup(yytext);
	return STRING;
}
.              ;
%%
snazzle.y
%{
#include <cstdio>
#include <iostream>
using namespace std;

#include "y.tab.h"  // to get the token types that we return

// stuff from flex that bison needs to know about:
extern "C" int yylex();
extern "C" int yyparse();
extern "C" FILE *yyin;
 
void yyerror(const char *s);
%}

// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "yystype".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "yystype":
%union {
	int ival;
	float fval;
	char *sval;
}

// define the constant-string tokens:
%token SNAZZLE TYPE
%token END

// define the "terminal symbol" token types I'm going to use (in CAPS
// by convention), and associate each with a field of the union:
%token <ival> INT
%token <fval> FLOAT
%token <sval> STRING

%%

// the first rule defined is the highest-level rule, which in our
// case is just the concept of a whole "snazzle file":
snazzle:
	header template body_section footer { cout << "done with a snazzle file!" << endl; }
	;
header:
	SNAZZLE FLOAT { cout << "reading a snazzle file version " << $2 << endl; }
	;
template:
	typelines
	;
typelines:
	typelines typeline
	| typeline
	;
typeline:
	TYPE STRING { cout << "new defined snazzle type: " << $2 << endl; }
	;
body_section:
	body_lines
	;
body_lines:
	body_lines body_line
	| body_line
	;
body_line:
	INT INT INT INT STRING { cout << "new snazzle: " << $1 << $2 << $3 << $4 << $5 << endl; }
	;
footer:
	END
	;

%%

main() {
	// open a file handle to a particular file:
	FILE *myfile = fopen("in.snazzle", "r");
	// make sure it's valid:
	if (!myfile) {
		cout << "I can't open a.snazzle.file!" << endl;
		return -1;
	}
	// set flex to read from it instead of defaulting to STDIN:
	yyin = myfile;

	// parse through the input until there is no more:
	do {
		yyparse();
	} while (!feof(yyin));
	
}

void yyerror(const char *s) {
	cout << "EEK, parse error!  Message: " << s << endl;
	// might as well halt now:
	exit(-1);
}
This is compiled and run just like the others:

% bison -d snazzle.y
% flex snazzle.l
% g++ snazzle.tab.c lex.yy.c -lfl -o snazzle
% cat in.snazzle
sNaZZle 1.3
type foo
type bar
type bas
0 0 10 5 foo
20 10 30 20 foo
7 8 12 13 bas
78 124 100 256 bar
end

% ./snazzle
reading a snazzle file version 1.3
new defined snazzle type: foo
new defined snazzle type: bar
new defined snazzle type: bas
new snazzle: 00105foo
new snazzle: 20103020foo
new snazzle: 781213bas
new snazzle: 78124100256bar
done with a snazzle file!
%
So, that concludes this little tutorial, or at least the baseline part of it. I'm now going to pick a few upgrades at random and show you how they might be done.


a makefile

When you finally get sick of manually rerunning Flex and Bison, and also forgetting in which order to do it, I heartily recommend setting up a makefile. Here's a sample one I made:

% cat Makefile
snazzle.tab.c snazzle.tab.h: snazzle.y
	bison -d snazzle.y

lex.yy.c: snazzle.l snazzle.tab.h
	flex snazzle.l

snazzle: lex.yy.c snazzle.tab.c snazzle.tab.h
	g++ snazzle.tab.c lex.yy.c -lfl -o snazzle
% make snazzle
bison -d snazzle.y
flex snazzle.l
g++ snazzle.tab.c lex.yy.c -lfl -o snazzle
%

forcing carriage returns

Next tweak: you'll notice that this completely ignores whitespace, so that you could put the entire snazzle file on a single line and it'll still be okay. You may or may not want this behaviour, but let's assume that's bad, and require there to be carriage returns after the lines just like there is in the sample file "in.snazzle". To do this, we need to do two things: recognize the '\n' token (flex), and add it to the grammar (bison):

snazzle.l
%{
#include 
#include "snazzle.tab.h"
using namespace std;
#define YY_DECL extern "C" int yylex()
%}
%%
[ \t\n]          ;
sNaZZle        { return SNAZZLE; }
type           { return TYPE; }
end            { return END; }
[0-9]+\.[0-9]+ { yylval.fval = atof(yytext); return FLOAT; }
[0-9]+         { yylval.ival = atoi(yytext); return INT; }
[a-zA-Z0-9]+   {
	// we have to copy because we can't rely on yytext not changing underneath us:
	yylval.sval = strdup(yytext);
	return STRING;
}
\n             return ENDL;
.              ;
%%
snazzle.y
%{
#include <cstdio>
#include <iostream>
using namespace std;

#include "y.tab.h"  // to get the token types that we return

// stuff from flex that bison needs to know about:
extern "C" int yylex();
extern "C" int yyparse();
extern "C" FILE *yyin;
 
void yyerror(const char *s);
%}

// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "yystype".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "yystype":
%union {
	int ival;
	float fval;
	char *sval;
}

// define the constant-string tokens:
%token SNAZZLE TYPE
%token END ENDL

// define the "terminal symbol" token types I'm going to use (in CAPS
// by convention), and associate each with a field of the union:
%token <ival> INT
%token <fval> FLOAT
%token <sval> STRING
%%
// the first rule defined is the highest-level rule, which in our
// case is just the concept of a whole "snazzle file":
snazzle:
header template body_section footer { cout << "done with a snazzle file!" << endl; }
	;
header:
	SNAZZLE FLOAT ENDL { cout << "reading a snazzle file version " << $2 << endl; }
	;
template:
	typelines
	;
typelines:
	typelines typeline
	| typeline
	;
typeline:
	TYPE STRING ENDL { cout << "new defined snazzle type: " << $2 << endl; }
	;
body_section:
	body_lines
	;
body_lines:
	body_lines body_line
	| body_line
	;
body_line:
	INT INT INT INT STRING ENDL { cout << "new snazzle: " << $1 << $2 << $3 << $4 << $5 << endl; }
	;
footer:
	END ENDL
	;
%%

main() {
	// open a file handle to a particular file:
	FILE *myfile = fopen("a.snazzle.file", "r");
	// make sure it's valid:
	if (!myfile) {
		cout << "I can't open a.snazzle.file!" << endl;
		return -1;
	}
	// set lex to read from it instead of defaulting to STDIN:
	yyin = myfile;

	// parse through the input until there is no more:	
	do {
		yyparse();
	} while (!feof(yyin));
	
}

void yyerror(const char *s) {
	cout << "EEK, parse error!  Message: " << s << endl;
	// might as well halt now:
	exit(-1);
}
But when we go to run it, we get a parse error:

% make
% ./snazzle
reading a snazzle file version 1.3
new defined snazzle type: foo
new defined snazzle type: bar
new defined snazzle type: bas
new snazzle: 00105foo
new snazzle: 20103020foo
new snazzle: 781213bas
new snazzle: 78124100256bar
done with a snazzle file!
EEK, parse error!  Message: syntax error
%
Why?? Well, it turns out that in.snazzle has an extra carriage return at the end:

% cat in.snazzle
sNaZZle 1.3
type foo
type bar
type bas
0 0 10 5 foo
20 10 30 20 foo
7 8 12 13 bas
78 124 100 256 bar
end

%
And if we remove it, snazzle would be happy:

% cat in.snazzle
sNaZZle 1.3
type foo
type bar
type bas
0 0 10 5 foo
20 10 30 20 foo
7 8 12 13 bas
78 124 100 256 bar
end
% ./snazzle
reading a snazzle file version 1.3
new defined snazzle type: foo
new defined snazzle type: bar
new defined snazzle type: bas
new snazzle: 00105foo
new snazzle: 20103020foo
new snazzle: 781213bas
new snazzle: 78124100256bar
done with a snazzle file!
%
But that really isn't the best solution, as requiring all input files to have exactly one carriage return after data is a little unreasonable. We need to make it more general. Specifically, we should allow any number of carriage returns between lines. In Bison-land, this is best stated as "each line may be followed with one or more carriage returns", like so:

snazzle.y
%{
#include <cstdio>
#include <iostream>
using namespace std;

#include "y.tab.h"  // to get the token types that we return

// stuff from flex that bison needs to know about:
extern "C" int yylex();
extern "C" int yyparse();
extern "C" FILE *yyin;
 
void yyerror(const char *s);
%}

// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "yystype".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "yystype":
%union {
	int ival;
	float fval;
	char *sval;
}

// define the constant-string tokens:
%token SNAZZLE TYPE
%token END ENDL

// define the "terminal symbol" token types I'm going to use (in CAPS
// by convention), and associate each with a field of the union:
%token <ival> INT
%token <fval> FLOAT
%token <sval> STRING

%%
// the first rule defined is the highest-level rule, which in our
// case is just the concept of a whole "snazzle file":
snazzle:
header template body_section footer { cout << "done with a snazzle file!" << endl; }
	;
header:
	SNAZZLE FLOAT ENDLS { cout << "reading a snazzle file version " << $2 << endl; }
	;
template:
	typelines
	;
typelines:
	typelines typeline
	| typeline
	;
typeline:
	TYPE STRING ENDLS { cout << "new defined snazzle type: " << $2 << endl; }
	;
body_section:
	body_lines
	;
body_lines:
	body_lines body_line
	| body_line
	;
body_line:
	INT INT INT INT STRING ENDLS { cout << "new snazzle: " << $1 << $2 << $3 << $4 << $5 << endl; }
	;
footer:
	END ENDLS
	;
ENDLS:
	ENDLS ENDL
	| ENDL ;
%%
Note that this didn't require any changes to the flex file -- the underlying tokens didn't change, just how we used them. And of course, this actually works:

% make
flex snazzle.l
g++ snazzle.tab.c lex.yy.c -lfl -o snazzle
% cat in.snazzle
sNaZZle 1.3
type foo
type bar
type bas


0 0 10 5 foo
20 10 30 20 foo
7 8 12 13 bas

78 124 100 256 bar

end


% ./snazzle
reading a snazzle file version 1.3
new defined snazzle type: foo
new defined snazzle type: bar
new defined snazzle type: bas
new snazzle: 00105foo
new snazzle: 20103020foo
new snazzle: 781213bas
new snazzle: 78124100256bar
done with a snazzle file!
%

line numbers

Next little tweak: wouldn't it have been nice if that parse error had given us the line to look at, so that we didn't have to guess-and-check the grammar? Unfortunately Flex has no guaranteed way to get the line number (well, there's yylineno, but it's almost completely manual, and in some situations makes your parser very slow, so you might as well just do it yourself). The best way to keep track of the line number is to have a global variable that you update whenever you see a carriage return:

snazzle.l
%{
#include 
#include "y.tab.h"
using namespace std;
#define YY_DECL extern "C" int yylex()
int line_num = 1;
%}
%%
[ \t]          ;
sNaZZle        { return SNAZZLE; }
type           { return TYPE; }
end            { return END; }
[0-9]+\.[0-9]+ { yylval.fval = atof(yytext); return FLOAT; }
[0-9]+         { yylval.ival = atoi(yytext); return INT; }
[a-zA-Z0-9]+   {
	yylval.sval = strdup(yytext);
	return STRING;
}
\n             { ++line_num; return ENDL; }
.              ;
%%
snazzle.y
%{
#include <cstdio>
#include <iostream>
using namespace std;

#include "y.tab.h"  // to get the token types that we return

// stuff from flex that bison needs to know about:
extern "C" int yylex();
extern "C" int yyparse();
extern "C" FILE *yyin;
extern int line_num;
 
void yyerror(const char *s);
%}

// Bison fundamentally works by asking flex to get the next token, which it
// returns as an object of type "yystype".  But tokens could be of any
// arbitrary data type!  So we deal with that in Bison by defining a C union
// holding each of the types of tokens that Flex could return, and have Bison
// use that union instead of "int" for the definition of "yystype":
%union {
	int ival;
	float fval;
	char *sval;
}

// define the constant-string tokens:
%token SNAZZLE TYPE
%token END ENDL

// define the "terminal symbol" token types I'm going to use (in CAPS
// by convention), and associate each with a field of the union:
%token <ival> INT
%token <fval> FLOAT
%token <sval> STRING

%%
// the first rule defined is the highest-level rule, which in our
// case is just the concept of a whole "snazzle file":
snazzle:
	header template body_section footer { cout < "done with a snazzle file!" < endl; }
	;
header:
	SNAZZLE FLOAT ENDLS { cout < "reading a snazzle file version " < $2 < endl; }
	;
template:
	typelines
	;
typelines:
	typelines typeline
	| typeline
	;
typeline:
	TYPE STRING ENDLS { cout < "new defined snazzle type: " < $2 < endl; }
	;
body_section:
	body_lines
	;
body_lines:
	body_lines body_line
	| body_line
	;
body_line:
	INT INT INT INT STRING ENDLS { cout < "new snazzle: " < $1 < $2 < $3 < $4 < $5 < endl; }
	;
footer:
	END ENDLS
	;
ENDLS:
	ENDLS ENDL
	| ENDL ;
%%

main() {
	// open a file handle to a particular file:
	FILE *myfile = fopen("in.snazzle", "r");
	// make sure it's valid:
	if (!myfile) {
		cout << "I can't open a.snazzle.file!" << endl;
		return -1;
	}
	// set lex to read from it instead of defaulting to STDIN:
	yyin = myfile;

	// parse through the input until there is no more:
	
	do {
		yyparse();
	} while (!feof(yyin));
	
}

void yyerror(const char *s) {
	cout << "EEK, parse error on line " << line_num << "!  Message: " << s << endl;
	// might as well halt now:
	exit(-1);
}
Which is pretty cool when you make a "type oops" definition in the middle of the body instead of where it's supposed to be:

% make
bison -d snazzle.y
flex snazzle.l
g++ snazzle.tab.c lex.yy.c -lfl -o snazzle
% cat in.snazzle
sNaZZle 1.3
type foo
type bar
type bas
0 0 10 5 foo
20 10 30 20 foo
type oops
7 8 12 13 bas
78 124 100 256 bar
end
% ./snazzle
reading a snazzle file version 1.3
new defined snazzle type: foo
new defined snazzle type: bar
new defined snazzle type: bas
new snazzle: 00105foo
EEK, parse error on line 7!  Message: syntax error
%
Of course, "syntax error" isn't very helpful, but at least you've got the line number. :)


Tips


directly returning terminal characters

If you have individual characters that are also terminal symbols, you can have Flex return them directly instead of having to create a %token for them:

\(                { return '('; }
;                 { return ';'; }
You could also list a bunch of them in a single line with this shortcut:
[\(\)\{\}:;=,]    { return yytext[0]; }
On the Bison side, you can also use them directly:

thing: FOO '(' BAR ';'

actions before the end of the grammar

The coolest thing I've discovered about Bison so far is that you can put action statements in the middle of the grammar instead of just at the end. This means you can get information as soon as it's read, which I find is very useful. For example, a C++ function call might look like this:

functioncall:
	returntype name '(' args ')' body
You can always add actions at the end of the line, like this:
functioncall:
	returntype name '(' args ')' body { cout << "defined function '" << $2 << "'' << endl; }
But then you get the function name after 'body' is evaluated, which means the whole thing has been parsed before you find out what it was! However, you can embed the code block in the middle of the grammar and it will be run before 'body' is evaluated:
functioncall:
	returntype name { cout << "defining function '" << $2 << << endl; } '(' args ')' body

whitespace in flex/bison files

I've discovered that, unlike most unix tools, Flex and Bison are surprisingly lenient about whitespacing. This is really nice, because it's hard enough to understand their syntax without the ability to reindent things. The following are all equivalent:

thing: FOO ':' BAR { cout << "found a foo-bar!" << endl; }
	| BAS ':' BAR { cout << "found a bas-bar!" << endl; }

thing:
	FOO ':' BAR { cout << "found a foo-bar!" << endl; }
	|
	BAS ':' BAR { cout << "found a bas-bar!" << endl; }

thing:
	FOO ':' BAR {
		cout << "found a foo-bar!" << endl; }
	| BAS ':' BAR {
		cout << "found a bas-bar!" << endl; }

avoiding -lfl and link problems with yywrap

If you know that you only want to parse one file at a time (usually a good assumption), you don't need to provide your own yywrap function that would just return 1. Inside your flex file, you can say %option noyywrap and the generated output will define yywrap as a local macro returning 1. This has the added bonus of removing the requirement to link with the flex libraries, since they're only needed to get the default yywrap defined as a function returning 1.


renaming identifiers

Flex and Bison generate code that uses the global namespace, which means that if you ever try to have more than one in a single program you're going to have identifier collisions. To get around that, you can tell both Flex and Bison to prefix their identifiers with a custom string you specify.

In Flex, you can use either the command line option -P foo or the option syntax %option prefix="foo" in the first section of the file.

In Bison, you can use either the command line option -p foo or the option syntax %name-prefix "foo".


moving output

Similar to why you rename identifiers, you usually don't want to use the default output file names because multiple parsers will all step on each other.

In Flex, you can specify either -o lex.foo.cc on the command line (it has to be before your input file!) or %option outfile="lex.foo.cc" in the first section of the .l file.

In Bison, you can specify either -o "foo.tab.cc" on the command line or %output "foo.tab.cc" in the first section of the .y file. However, Bison usually names its output after its input anyway; an input file named "foo.y" will already generate "foo.tab.c".


Advanced


start states

In a Flex/Bison grammer, it is almost impossible to allow multiline commenting such as C's /* .. */. What you really want is for the parser go into a sort of "ignore everything" state when it sees "/*", and go back to normal when it sees "*/". Clearly you wouldn't want Bison to do this, or else you'd have to put optional 'comment' targets all over every contruct in your syntax; you can see how it fell to Flex to implement some way to do this.

Flex allows you to specify start states, which are just regex pattern rules like any other but they're only matched if you're in a particular state. The syntax for a pattern that should only be matched if we're in state 'FOO' looks like this:

<FOO>bar     ;  // we're in state FOO and we saw "bar"
Note that you come up with the state names -- they're not predefined or anything. Though when you create a state, you do have to declare it in your Flex file's control section (that's the first section, before the first "%%"):

%x FOO
So how do you get into the state? There's a special Flex construct (I think it's ultimately a C macro) that goes into any regular code block to get there:

bar          { BEGIN(FOO); }  // we saw a "bar", so go into the "FOO" state
And how about getting back out of that state and going back to where you were initially? Instead of somthing obvious (say, "END()"?), they decided to make a default state called "INITIAL." Any Flex match pattern that doesn't have a state in front of it is assumed to be in the INITIAL state. To get back to it, you just jump to it:
bas          { BEGIN(INITIAL); }  // jump back to normal pattern matching
Note that the BEGIN thing is for all intents and purposes normal C code, despite the fact that it's not. :) What that means is that you can treat it like code and put it anywhere you want -- you can even make it conditional:
bar          { do_something(); BEGIN(FOO); do_something_else(); }
..
bar          { if (some_value == 42) BEGIN(FOO); }
..
Back to the original problem -- multiline commenting. Here's a way to do C-style block commenting using start states:

\/\*                    { // start of a comment: go to a 'COMMENTS' state.
	BEGIN(COMMENTS);
	}
<COMMENTS>\*\/    {   // end of a comment: go back to normal parsing.
	BEGIN(INITIAL);
	}
<COMMENTS>\n      { ++linenum; }   // still have to increment line numbers inside of comments!
<COMMENTS>.       ;   // ignore every other character while we're in this state
Note that you can also have a Flex match pertain to multiple states by listing them all:

<MYSTATE,ANOTHERSTATE>foo { ... }
This occasionally comes in handy, such as keeping you from having to duplicate the line-counting pattern/code above.

reading gzipped input

This is, surprisingly, rather easy. The basic idea is to filter Flex's input through libz. libz is very nice because it will pass through, unchanged, any input which isn't zipped -- so we don't need to check if the input is zipped and handle it differently!

For reference, the API to libz is available here (last I looked). I have been consistently surprised with how easy it is to use libz directly to avoid silly hacks like "popen"ing "gunzip -c" and redirecting its output. Kudos to the libz team!

In the first section of your Flex file, you'll want to declare that you have a better input function, and then tell Flex it has to use yours instead:

extern int my_abstractread(char *buff, int buffsize);
#define YY_INPUT(buff, res, buffsize) (res = my_abstractread(buff, buffsize))
Somewhere or another (I put it in my top-level files because it doesn't have to go in with the Flex/Bison source) you need to define your input function. Mine looks like this:

#include <zlib.h>  // direct access to the gzip API

// (ew!) global variable for the gzip stream.
gzFile my_gzfile = 0;

int my_abstractread(char *buff, int buffsize) {

	// called on a request by Flex to get the next 'buffsize' bytes of data
	// from the input, and return the number of bytes read.

	int res = gzread(my_gzfile, buff, buffsize);
	if (res == -1) {
		// file error!
		abort();
	}

	return res;
}
Then, instead of using fopen, you use libz:

// libz is very nice in that it handles unzipped files as well, which
// means that no matter what the input file is we can just pass it
// through gzopen and not worry about it:
my_gzfile = gzopen(filename.c_str(), "r");
if (!my_gzfile)  {
	// file cannot be opened
	abort();
}
And finally, you have to change your yyparse()-calling loop to use these new file handles instead of yyin:

do {
	myparse();
} while (!gzeof(my_gzfile));

Regular expression overview

You've used regexs before without knowing it, for example when you use wildcards on file names:

  % ls *asdf*
  asdf
  asdf2
  asdf3
  new.asdf
  new.asdf.mangled
  %
The shell's idea of regular expressions isn't quite accurate with the "real" definition of regular expressions, but at least the idea is the same. Here, we're telling ls to list all the files that have "asdf" somewhere in the name. We could ask for just the files starting with asdf by saying "asdf*", or all the files ending with asdf with "*asdf". The asterisk basically means "anything can go here".

Regular expressions are really just the scientific deconstruction of such pattern matching. As such, you can imagine they're not a whole lot of fun. :) There's actually an entire O'Reilly book dedicated to them, if you really want to see what they're all about. (I'd love to make a wisecrack about being great for insomnia, but right now it's ranked #5,076 on Amazon's sales rank. Guess it can't be too unbearable!)

With that said, my little overview here is clearly not going to be exhaustive, but should give you the general idea. Flex's regular expressions consist of "characters" and "meta-characters". "Characters" are interpreted literally as real text, whereas "meta-characters" change how the search works. For example, listing "foo" as a regular expression will match exactly one string, which is "foo". But if you add the metacharacter "+" (which means "one or more of the previous character") after the "f" to get "f+oo", it will match "foo", "ffoo", and "ffffffffffffffffoo". A table of meta-characters follows:

metacharacter	description
+	previous expression can match one or more times
*	previous expression can match zero or more times
?	previous expression can match zero or one time
.	can match any character except the carriage return '\n'

I say "expression" above instead of just "character" because you can also make groups of things by enclosing whatever you want in parentheses.

Brackets are very cool -- by saying "[abcde]", it will match any one of the characters in the brackets, so you'll match "a" and "b" but not "ac". If you add a plus after the closing bracket, though, then you will match "ac" as well. Brackets also allow negation: "[^abc]" will match anything that's not in the brackets, so "d" and "foo" would pass but not "b".

Most useful of all, brackets allow for ranges: "[a-e]" is the same as "[abcde]". So you will frequently see stuff like "[0-9]+" to match integer values, or "[a-zA-Z]+" to match words, etc.

So how do you match an actual bracket, or an actual period, if the regular expression searcher is immediately going to think you're defining a meta-character? By adding a backslash (\) in front of it! So "a\.b" will match the string "a.b" but not "acb", whereas "a.b" as a regular expression will match both. And to be complete, backslash itself can be backslashed, so that "a\\." will match the string "a\b". (What fun!)

This stuff just takes some playing with to get used to. It's not really that bad. :)

Chris verBurg
2011-12-08
		14.1.2

	14.2
15. Strings

	15.1  string.h

		15.1.1  Functions
Copying:
memcpy
Copy block of memory (function )
memmove
Move block of memory (function )
strcpy
Copy string (function )
strncpy
Copy characters from string (function )

Concatenation:
strcat
Concatenate strings (function )
strncat
Append characters from string (function )

Comparison:
memcmp
Compare two blocks of memory (function )
strcmp
Compare two strings (function )
strcoll
Compare two strings using locale (function )
strncmp
Compare characters of two strings (function )
strxfrm
Transform string using locale (function )

Searching:
memchr
Locate character in block of memory (function )
strchr
Locate first occurrence of character in string (function )
strcspn
Get span until character in string (function )
strpbrk
Locate characters in string (function )
strrchr
Locate last occurrence of character in string (function )
strspn
Get span of character set in string (function )
strstr
Locate substring (function )
strtok
Split string into tokens (function )

Other:
memset
Fill block of memory (function )
strerror
Get pointer to error message string (function )
strlen
Get string length (function )

Macros
NULL
Null pointer (macro )

Types
size_t
Unsigned integral type (type )

	15.2 idioms, common operations, Recipes

		15.2.1 Starts with
bool StartsWith(const char *a, const char *b)
{
   if(strncmp(a, b, strlen(b)) == 0) return 1;
   return 0;
}

...

if(StartsWith("http://stackoverflow.com", "http://")) { 
   // do something
}else {
  // do something else
}
		15.2.2 Tokenize, split

			15.2.2.1  strsep is better than strtok_r
http://www.quora.com/How-do-you-write-a-C-program-to-split-a-string-by-a-delimiter

Costya Perepelitsa
5 upvotes by Anonymous, Aditya N. Joshi, Quora User, (more)
Executive Summary: Use strtok_r for natural languages and strsep for everything else.

I think the answers so far illustrate beautifully how confusing this issue can be. :p
There are many ways to do this, but most of the ones you'll hear are often... less than ideal.

Some people mentioned strtok, which was the Old Way. It uses global state variables which are hidden from you, making it a poor choice for multi-threaded code, or even sufficiently complicated code that'll require you to use it in more than one function; it's easy to accidentally start tokenizing one string using another's context, making your program behave unpredictably. Outside of simple, quick & dirty programs, you should avoid it.

Only one person (as of this writing) suggested strtok_r. This is a fine suggestion. It works by putting that hidden global state variable into an opaque "context" variable you must pass for each invocation. This makes it effective but, in my opinion, ugly.

Someone else suggested the use of strcspn, which only returns the length of the next token and therefore requires that you do your own string splitting. It's not a bad idea, but there are easier ways that do that work for you.

One person reinvented the wheel that is the lexer, but in an inefficient and highly insecure way, and still another gave you C++ when you asked for C. Those are known risks when asking the Internet to help you with C, I'm afraid.

My preferred method of tokenizing a string is to use strsep. Like strtok_r (and strtok before it), it overwrites delimiter characters in the string with null bytes, so if you wanted to keep a copy of the original, untokenized string, you had best make a copy (strdup is the easiest way to do this). strsep has a few differences from strtok_r that will be made apparent in the example code below. The gist of it is that strtok_r is better for tokenizing natural languages (like English) and strsep is better for more well-defined input like CSV.


Example strtok_r code:
The following is a simple program that reads in one line at a time, tokenizes each line using strtok_r, and then prints all of its tokens.
I split on whitespace as well as commas to illustrate an important difference in the way strtok_r and strsep behave regarding starting and ending delimiters as well as repeated delimiters.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char **strsplit(const char* str, const char* delim, size_t* numtokens) {
    // copy the original string so that we don't overwrite parts of it
    // (don't do this if you don't need to keep the old line,
    // as this is less efficient)
    char *s = strdup(str);

    // these three variables are part of a very common idiom to
    // implement a dynamically-growing array
    size_t tokens_alloc = 1;
    size_t tokens_used = 0;
    char **tokens = calloc(tokens_alloc, sizeof(char*));

    char *token, *strtok_ctx;
    for (token = strtok_r(s, delim, &strtok_ctx);
            token != NULL;
            token = strtok_r(NULL, delim, &strtok_ctx)) {
        // check if we need to allocate more space for tokens
        if (tokens_used == tokens_alloc) {
            tokens_alloc *= 2;
            tokens = realloc(tokens, tokens_alloc * sizeof(char*));
        }
        tokens[tokens_used++] = strdup(token);
    }

    // cleanup
    if (tokens_used == 0) {
        free(tokens);
        tokens = NULL;
    } else {
        tokens = realloc(tokens, tokens_used * sizeof(char*));
    }
    *numtokens = tokens_used;
    free(s);

    return tokens;
}


int main(void) {
    char *line = NULL;
    size_t linelen;

    char **tokens;
    size_t numtokens;

    while (getline(&line, &linelen, stdin) != -1) {
        tokens = strsplit(line, ", \t\n", &numtokens);
        for (size_t i = 0; i < numtokens; i++) {
            printf("    token: \"%s\"\n", tokens[i]);
            free(tokens[i]);
        }
        if (tokens != NULL)
            free(tokens);
    }

    if (line != NULL) free(line);

    return EXIT_SUCCESS;
}

In my opinion, the need for that context variable (strtok_ctx in my example, above) is ugly, and the fact that strtok_r requires a different calling convention for tokens after the first makes it annoying to write loops for.

Example run:
$ gcc -Wall -Wextra -Werror -g -o split split.c
$ ./split
foo,bar,baz
    token: "foo"
    token: "bar"
    token: "baz"
,,foo,,bar,,baz,,
    token: "foo"
    token: "bar"
    token: "baz"
^D
$

Note how, in the second line, any delimiters at the start and end are skipped, and several consecutive occurrences of delimiters are treated as one delimiter.
This makes strtok_r great for tokenizing natural languages because you'd be filtering out all of those blanks anyway, but less viable for, say, CSV files, where you definitely want to keep the empty values.
That is, if ,,foo,,bar,,baz,, were in a CSV file, you would be expecting 9 values, the 3rd, 5th, and 7th of which are non-empty strings, but strtok_r would only give you the non-empty values with no way of knowing the positions in which they appear.


Example strsep code:
I'll just rewrite the strsplit function from the earlier example.
char **strsplit(const char* str, const char* delim, size_t* numtokens) {
    char *s = strdup(str);
    size_t tokens_alloc = 1;
    size_t tokens_used = 0;
    char **tokens = calloc(tokens_alloc, sizeof(char*));
    char *token, *rest = s;

    while ((token = strsep(&rest, delim)) != NULL) {
        if (tokens_used == tokens_alloc) {
            tokens_alloc *= 2;
            tokens = realloc(tokens, tokens_alloc * sizeof(char*));
        }
        tokens[tokens_used++] = strdup(token);
    }

    if (tokens_used == 0) {
        free(tokens);
        tokens = NULL;
    } else {
        tokens = realloc(tokens, tokens_used * sizeof(char*));
    }
    *numtokens = tokens_used;
    free(s);

    return tokens;
}

The primary difference to notice in the code is that that huge, multi-line for statement can be replaced with a much nicer while loop. And while strsep does need an extra char* variable just like strtok_r does, you actually know what it will be used for: storing the rest of the string after the token. This makes strsep more convenient if your program wants to partially tokenize a string (e.g. if your program takes command lines and dispatches to other functions based on the command).

Example run:
$ gcc -Wall -Wextra -Werror -g -o split split.c
$ ./split
foo bar baz
    token: "foo"
    token: "bar"
    token: "baz"
    token: ""
,,foo,,bar,,baz,,
    token: ""
    token: ""
    token: "foo"
    token: ""
    token: "bar"
    token: ""
    token: "baz"
    token: ""
    token: ""
    token: ""
^D
$

The main difference is that each and every delimiter is split on; start and end delimiters are not skipped and consecutive delimiters are not lumped together as a single delimiter.
The other important thing to notice is where that final empty token comes from in each line: that's the result of splitting on the newline character, '\n'. Because strsep does not ignore delimiters at the end of the string, it splits on the newline character as well (when it's one of the delimiter characters), producing an extra, empty token. Depending upon your use case, you may want to check for a terminating newline and remove it before tokenizing the line to avoid getting this extra token.


It deserves mention, however, that for sufficiently complicated tokenization rules (e.g. as used by compilers when reading in your source code), it is best to use a lexer. A lexer is a developer tool that takes regular expressions describing tokens and automatically generates efficient functions for you to use to tokenize input according to those rules.
The most popular lexer for C is flex. Only the sorriest excuses of Linux package managers would fail to include flex in their repositories; you should have no trouble in getting a hold of it.

			15.2.2.2 Splitting a String C++
Problem
You want to split a delimited string into multiple strings. For example, you may want to split the string "Name|Address|Phone" into three separate strings, "Name", "Address", and "Phone", with the delimiter removed.

Solution
Use basic_string's find member function to advance from one occurrence of the delimiter to the next, and substr to copy each substring out of the original string. You can use any standard sequence to hold the results; Example 4-10 uses a vector.

Example 4-10. Split a delimited string
#include <string>
#include <vector>
#include <functional>
#include <iostream>

using namespace std;

void split(const string& s, char c,
           vector<string>& v) {
   string::size_type i = 0;
   string::size_type j = s.find(c);

   while (j != string::npos) {
      v.push_back(s.substr(i, j-i));
      i = ++j;
      j = s.find(c, j);

      if (j == string::npos)
         v.push_back(s.substr(i, s.length()));
   }
}

int main() {
   vector<string> v;
   string s = "Account Name|Address 1|Address 2|City";

   split(s, '|', v);

   for (int i = 0; i < v.size(); ++i) {
      cout << v[i] << '\n';
   }
}
		15.2.3 replace substring 

			15.2.3.1 My example, replace substring "dirName.*," with "dirname:dirname"
    char * psValueResult = NULL; // Will contain final string for X509V3_EXT_conf_nid
    char * psDirNameResult = NULL; // Will contain dirName substring. i.e. "dirName:/C=Yo/O=Cisco/OU=Security/CN=SAMPG"
    const char * psDirNameVal = "dirName";
    char * psDirNameLoc = NULL;
    char * psCommaLoc = NULL;
    if (  ( psDirNameLoc = strstr(pValue , psDirNameVal )) != NULL ) // handle dirname
    {
            g_pILog->logDebug(__FILE__,__LINE__, rc, "addDirNametoCSR_SAN() - Found dirName field, position: %s\n", psDirNameLoc);
            if (pValue == psDirNameLoc)
            {
                    if (  ( psCommaLoc = strstr(pValue , "," )) != NULL )
                    {
                        g_pILog->logDebug(__FILE__,__LINE__, rc, "addDirNametoCSR_SAN() - Process dirName plus additional fields \n");
                        psValueResult = (char *) malloc ( strlen ("dirName:dirname") +strlen(psCommaLoc)+1);
                        sprintf(psValueResult,"%s%s", "dirName:dirname", psCommaLoc);
                        psDirNameResult = (char *)malloc ( (psCommaLoc - pValue) +1);
                        strncpy(psDirNameResult,pValue,psCommaLoc - pValue);
                        psDirNameResult[ (psCommaLoc - pValue)  ] = '\0';

                    }
                    else // pValue only contains dirName 
                    {
                        g_pILog->logDebug(__FILE__,__LINE__, rc, "addDirNametoCSR_SAN() - Process dirName only \n");
                        psValueResult = (char *)malloc ( strlen ("dirName:dirname") +1);
                        strcpy(psValueResult,"dirName:dirname");
                        psDirNameResult = (char *)malloc ( strlen (pValue) +1);
                        strcpy(psDirNameResult,pValue);
                    }
            }
            else // dirName at the end or middle
            {
                    if (  ( psCommaLoc = strstr(psDirNameLoc , "," )) != NULL ) //middle
                    {
                        g_pILog->logDebug(__FILE__,__LINE__, rc, "addDirNametoCSR_SAN() - Process dirName at middle\n");
                        psValueResult = (char *)malloc ( strlen ("dirName:dirname") + (psDirNameLoc - pValue) +strlen(psCommaLoc) +1);
                        strncpy(psValueResult,pValue,psDirNameLoc - pValue);
                        strncpy(psValueResult+(psDirNameLoc - pValue),"dirName:dirname",strlen ("dirName:dirname"));
                        strcpy(psValueResult+(psDirNameLoc - pValue) + strlen ("dirName:dirname"),psCommaLoc );
                        psDirNameResult = (char *)malloc ( ( psCommaLoc - psDirNameLoc ) +1);
                        strncpy(psDirNameResult,psDirNameLoc, ( psCommaLoc - psDirNameLoc ));
                        psDirNameResult[ psCommaLoc - psDirNameLoc] = '\0'; 

                    }
                    else //end
                    {
                        g_pILog->logDebug(__FILE__,__LINE__, rc, "addDirNametoCSR_SAN() - Process dirName at end\n");
                        psValueResult = (char *)malloc ( strlen ("dirName:dirname") + (psDirNameLoc - pValue) +1);
                        strncpy(psValueResult,pValue,psDirNameLoc - pValue);
                        strncpy(psValueResult+(psDirNameLoc - pValue),"dirName:dirname",strlen ("dirName:dirname"));
                        psValueResult[  strlen ("dirName:dirname") + (psDirNameLoc - pValue) ] = '\0';
                        psDirNameResult = (char *)malloc ( strlen(psDirNameLoc ) +1);
                        strcpy(psDirNameResult,psDirNameLoc);
                    }

            }
                g_pILog->logDebug(__FILE__,__LINE__, rc, "addDirNametoCSR_SAN() -  dirName field: [%s], Final string is [%s]", psDirNameResult, psValueResult);
    }// if (  ( psDirNameLoc = strstr(pValue , psDirNameVal )) != NULL ) // handle dirname
    else
    {
        g_pILog->logWarn(__FILE__,__LINE__, rc, "addDirNametoCSR_SAN() - dirName not found. this method only handles dirName so it will do nothing.");
        return rc;
    }

			15.2.3.2


		15.2.4

	15.3

16.
