.........................................Table Of Contents...............................................................
1. Debug perl script <URL:#tn=1. Debug perl script>
2. Learning Perl, 5th Edition <URL:#tn=2. Learning Perl, 5th Edition>
	2.1 Chapter 1. Introduction <URL:#tn=	2.1 Chapter 1. Introduction>
		2.1.1 Questions and Answers <URL:#tn=		2.1.1 Questions and Answers>
			2.1.1.1 Why Are There So Many Footnotes? <URL:#tn=			2.1.1.1 Why Are There So Many Footnotes?>
			2.1.1.2 What About the Exercises and Their Answers? <URL:#tn=			2.1.1.2 What About the Exercises and Their Answers?>
			2.1.1.3 What Do Those Numbers at the Start of the Exercise Mean? <URL:#tn=			2.1.1.3 What Do Those Numbers at the Start of the Exercise Mean?>
			2.1.1.4 What If I'm a Perl Course Instructor? <URL:#tn=			2.1.1.4 What If I'm a Perl Course Instructor?>
		2.1.2 What Does "Perl" Stand For? <URL:#tn=		2.1.2 What Does "Perl" Stand For?>
			2.1.2.1 What Does "Perl" Stand For? <URL:#tn=			2.1.2.1 What Does "Perl" Stand For?>
			2.1.2.2 Why Did Larry Create Perl? <URL:#tn=			2.1.2.2 Why Did Larry Create Perl?>
			2.1.2.3 Why Didn't Larry Just Use Some Other Language? <URL:#tn=			2.1.2.3 Why Didn't Larry Just Use Some Other Language?>
			2.1.2.4 Is Perl Easy or Hard? <URL:#tn=			2.1.2.4 Is Perl Easy or Hard?>
			2.1.2.5 How Did Perl Get to Be So Popular? <URL:#tn=			2.1.2.5 How Did Perl Get to Be So Popular?>
			2.1.2.6 What's Happening with Perl Now? <URL:#tn=			2.1.2.6 What's Happening with Perl Now?>
			2.1.2.7 What's Perl Really Good For? <URL:#tn=			2.1.2.7 What's Perl Really Good For?>
			2.1.2.8 What Is Perl Not Good For? <URL:#tn=			2.1.2.8 What Is Perl Not Good For?>
		2.1.3 How Can I Get Perl? <URL:#tn=		2.1.3 How Can I Get Perl?>
			2.1.3.1 What Is CPAN? <URL:#tn=			2.1.3.1 What Is CPAN?>
			2.1.3.2 How Can I Get Support for Perl? <URL:#tn=			2.1.3.2 How Can I Get Support for Perl?>
			2.1.3.3 Are There Any Other Kinds of Support? <URL:#tn=			2.1.3.3 Are There Any Other Kinds of Support?>
			2.1.3.4 What If I Find a Bug in Perl? <URL:#tn=			2.1.3.4 What If I Find a Bug in Perl?>
		2.1.4 How Do I Make a Perl Program? <URL:#tn=		2.1.4 How Do I Make a Perl Program?>
			2.1.4.1 A Simple Program <URL:#tn=			2.1.4.1 A Simple Program>
			2.1.4.2 What's Inside That Program? <URL:#tn=			2.1.4.2 What's Inside That Program?>
			2.1.4.3 How Do I Compile Perl? <URL:#tn=			2.1.4.3 How Do I Compile Perl?>
		2.1.5 A Whirlwind Tour of Perl <URL:#tn=		2.1.5 A Whirlwind Tour of Perl>
		2.1.6 Exercises <URL:#tn=		2.1.6 Exercises>
			2.1.6.1  <URL:#tn=			2.1.6.1 >
			2.1.6.2  <URL:#tn=			2.1.6.2 >
	2.2 Scalar Data <URL:#tn=	2.2 Scalar Data>
		2.2.1  Numbers <URL:#tn=		2.2.1  Numbers>
			2.2.1.1. All Numbers Have the Same Format Internally <URL:#tn=			2.2.1.1. All Numbers Have the Same Format Internally>
			2.2.1.2. Floating-Point Literals <URL:#tn=			2.2.1.2. Floating-Point Literals>
			2.2.1.3. Integer Literals <URL:#tn=			2.2.1.3. Integer Literals>
			2.2.1.4. Nondecimal Integer Literals <URL:#tn=			2.2.1.4. Nondecimal Integer Literals>
			2.2.1.5. Numeric Operators <URL:#tn=			2.2.1.5. Numeric Operators>
		2.2.2 Strings <URL:#tn=		2.2.2 Strings>
			2.2.2.1. Single-Quoted String Literals <URL:#tn=			2.2.2.1. Single-Quoted String Literals>
			2.2.2.2. Double-Quoted String Literals <URL:#tn=			2.2.2.2. Double-Quoted String Literals>
			2.2.2.3. String Operators <URL:#tn=			2.2.2.3. String Operators>
			2.2.2.4. Automatic Conversion Between Numbers and Strings <URL:#tn=			2.2.2.4. Automatic Conversion Between Numbers and Strings>
		2.2.3  Perl's Built-in Warnings <URL:#tn=		2.2.3  Perl's Built-in Warnings>
		2.2.4  Scalar Variables <URL:#tn=		2.2.4  Scalar Variables>
			2.2.4.1. Choosing Good Variable Names <URL:#tn=			2.2.4.1. Choosing Good Variable Names>
			2.2.4.2. Scalar Assignment <URL:#tn=			2.2.4.2. Scalar Assignment>
			2.2.4.3. Binary Assignment Operators <URL:#tn=			2.2.4.3. Binary Assignment Operators>
		2.2.5  Output with print <URL:#tn=		2.2.5  Output with print>
			2.2.5.1. Interpolation of Scalar Variables into Strings <URL:#tn=			2.2.5.1. Interpolation of Scalar Variables into Strings>
			2.2.5.2. Operator Precedence and Associativity <URL:#tn=			2.2.5.2. Operator Precedence and Associativity>
			2.2.5.3. Comparison Operators <URL:#tn=			2.2.5.3. Comparison Operators>
		2.2.6  The if Control Structure <URL:#tn=		2.2.6  The if Control Structure>
			2.2.6.1. Boolean Values <URL:#tn=			2.2.6.1. Boolean Values>
		2.2.7  Getting User Input <URL:#tn=		2.2.7  Getting User Input>
		2.2.8  The chomp Operator <URL:#tn=		2.2.8  The chomp Operator>
		2.2.9  The while Control Structure <URL:#tn=		2.2.9  The while Control Structure>
		2.2.10 The undef Value <URL:#tn=		2.2.10 The undef Value>
		2.2.11 The defined Function <URL:#tn=		2.2.11 The defined Function>
		2.2.12 Exercises <URL:#tn=		2.2.12 Exercises>
	2.3 List and arrays <URL:#tn=	2.3 List and arrays>
		2.3.1 Accessing Elements of an Array <URL:#tn=		2.3.1 Accessing Elements of an Array>
		2.3.2 Special Array Indices <URL:#tn=		2.3.2 Special Array Indices>
		2.3.3 List Literals <URL:#tn=		2.3.3 List Literals>
			2.3.3.1 The qw Shortcut <URL:#tn=			2.3.3.1 The qw Shortcut>
		2.3.4 List Assignment <URL:#tn=		2.3.4 List Assignment>
			2.3.4.1 The pop and push Operators <URL:#tn=			2.3.4.1 The pop and push Operators>
			2.3.4.2 The shift and unshift Operators <URL:#tn=			2.3.4.2 The shift and unshift Operators>
		2.3.5 Interpolating Arrays into Strings <URL:#tn=		2.3.5 Interpolating Arrays into Strings>
		2.3.6 The foreach Control Structure <URL:#tn=		2.3.6 The foreach Control Structure>
			2.3.6.1 Perl's Favorite Default: $_ <URL:#tn=			2.3.6.1 Perl's Favorite Default: $_>
			2.3.6.2 The reverse Operator <URL:#tn=			2.3.6.2 The reverse Operator>
			2.3.6.3 The sort Operator <URL:#tn=			2.3.6.3 The sort Operator>
		2.3.7 Scalar and List Context <URL:#tn=		2.3.7 Scalar and List Context>
			2.3.7.1 Using List-Producing Expressions in Scalar Context <URL:#tn=			2.3.7.1 Using List-Producing Expressions in Scalar Context>
			2.3.7.2 Using Scalar-Producing Expressions in List Context <URL:#tn=			2.3.7.2 Using Scalar-Producing Expressions in List Context>
			2.3.7.3 Forcing Scalar Context <URL:#tn=			2.3.7.3 Forcing Scalar Context>
		2.3.8 <STDIN> in List Context <URL:#tn=		2.3.8 <STDIN> in List Context>
		2.3.9 Exercises <URL:#tn=		2.3.9 Exercises>
	2.4 Subroutines <URL:#tn=	2.4 Subroutines>
		2.4.1  Defining a Subroutine <URL:#tn=		2.4.1  Defining a Subroutine>
		2.4.2  Invoking a Subroutine <URL:#tn=		2.4.2  Invoking a Subroutine>
		2.4.3  Return Values <URL:#tn=		2.4.3  Return Values>
		2.4.4  Arguments <URL:#tn=		2.4.4  Arguments>
		2.4.5  Private Variables in Subroutines <URL:#tn=		2.4.5  Private Variables in Subroutines>
		2.4.6  Variable-Length Parameter Lists <URL:#tn=		2.4.6  Variable-Length Parameter Lists>
			2.4.6.1  A Better &max Routine <URL:#tn=			2.4.6.1  A Better &max Routine>
			2.4.6.2 Empty Parameter Lists <URL:#tn=			2.4.6.2 Empty Parameter Lists>
		2.4.7  Notes on Lexical (my) Variables <URL:#tn=		2.4.7  Notes on Lexical (my) Variables>
		2.4.8  The use strict Pragma <URL:#tn=		2.4.8  The use strict Pragma>
		2.4.9  The return Operator <URL:#tn=		2.4.9  The return Operator>
				2.4.9.1  Omitting the Ampersand <URL:#tn=				2.4.9.1  Omitting the Ampersand>
			2.4.10 Nonscalar Return Values <URL:#tn=			2.4.10 Nonscalar Return Values>
			2.4.11 Persistent, Private Variables <URL:#tn=			2.4.11 Persistent, Private Variables>
			2.4.12 Exercises <URL:#tn=			2.4.12 Exercises>
	2.5 Input and output <URL:#tn=	2.5 Input and output>
		2.5.1  Input from Standard Input <URL:#tn=		2.5.1  Input from Standard Input>
		2.5.2  Input from the Diamond Operator <URL:#tn=		2.5.2  Input from the Diamond Operator>
		2.5.3  The Invocation Arguments <URL:#tn=		2.5.3  The Invocation Arguments>
		2.5.4  Output to Standard Output <URL:#tn=		2.5.4  Output to Standard Output>
		2.5.5  Formatted Output with printf <URL:#tn=		2.5.5  Formatted Output with printf>
		      5.25/12;  # the value looks like "0.44%" <URL:#tn=		      5.25/12;  # the value looks like "0.44%">
		      5.5.1. Arrays and printf <URL:#tn=		      5.5.1. Arrays and printf>
		2.5.6  Filehandles <URL:#tn=		2.5.6  Filehandles>
		2.5.7  Opening a Filehandle <URL:#tn=		2.5.7  Opening a Filehandle>
			2.5.7.1  Bad Filehandles <URL:#tn=			2.5.7.1  Bad Filehandles>
			2.5.7.2 Closing a Filehandle <URL:#tn=			2.5.7.2 Closing a Filehandle>
		2.5.8  Fatal Errors with die <URL:#tn=		2.5.8  Fatal Errors with die>
			2.5.8.1  Warning Messages with warn <URL:#tn=			2.5.8.1  Warning Messages with warn>
		2.5.9  Using Filehandles <URL:#tn=		2.5.9  Using Filehandles>
			2.5.9.1  Changing the Default Output Filehandle <URL:#tn=			2.5.9.1  Changing the Default Output Filehandle>
		2.5.10 Reopening a Standard Filehandle <URL:#tn=		2.5.10 Reopening a Standard Filehandle>
		2.5.11 Output with say <URL:#tn=		2.5.11 Output with say>
		2.5.12 Exercises <URL:#tn=		2.5.12 Exercises>
	2.6 Hashes <URL:#tn=	2.6 Hashes>
		2.6.1 What Is a Hash? <URL:#tn=		2.6.1 What Is a Hash?>
			2.6.1.1 Why Use a Hash? <URL:#tn=			2.6.1.1 Why Use a Hash?>
		2.6.2 Hash Element Access <URL:#tn=		2.6.2 Hash Element Access>
			2.6.2.1 The Hash As a Whole <URL:#tn=			2.6.2.1 The Hash As a Whole>
			2.6.2.2 Hash Assignment <URL:#tn=			2.6.2.2 Hash Assignment>
			2.6.2.3 The Big Arrow <URL:#tn=			2.6.2.3 The Big Arrow>
		2.6.3 Hash Functions <URL:#tn=		2.6.3 Hash Functions>
			2.6.3.1 The keys and values Functions <URL:#tn=			2.6.3.1 The keys and values Functions>
			2.6.3.2 The each Function <URL:#tn=			2.6.3.2 The each Function>
		2.6.4 Typical Use of a Hash <URL:#tn=		2.6.4 Typical Use of a Hash>
			2.6.4.1 The exists Function <URL:#tn=			2.6.4.1 The exists Function>
			2.6.4.2 The delete Function <URL:#tn=			2.6.4.2 The delete Function>
			2.6.4.3 Hash Element Interpolation <URL:#tn=			2.6.4.3 Hash Element Interpolation>
		2.6.5 The %ENV hash <URL:#tn=		2.6.5 The %ENV hash>
		2.6.6 Exercises <URL:#tn=		2.6.6 Exercises>
	2.7 In the World of Regular Expressions <URL:#tn=	2.7 In the World of Regular Expressions>
		2.7.1 What Are Regular Expressions? <URL:#tn=		2.7.1 What Are Regular Expressions?>
		2.7.2 Using Simple Patterns <URL:#tn=		2.7.2 Using Simple Patterns>
			2.7.2.1 About Metacharacters <URL:#tn=			2.7.2.1 About Metacharacters>
			2.7.2.2 Simple Quantifiers <URL:#tn=			2.7.2.2 Simple Quantifiers>
			2.7.2.3 Grouping in Patterns <URL:#tn=			2.7.2.3 Grouping in Patterns>
			2.7.2.4 Alternatives <URL:#tn=			2.7.2.4 Alternatives>
		2.7.3 Character Classes <URL:#tn=		2.7.3 Character Classes>
			2.7.3.1 Character Class Shortcuts <URL:#tn=			2.7.3.1 Character Class Shortcuts>
7.3.2. Negating the Shortcuts <URL:#tn=7.3.2. Negating the Shortcuts>
		2.7.4 Exercises <URL:#tn=		2.7.4 Exercises>
	2.8 Matching with Regular Expressions <URL:#tn=	2.8 Matching with Regular Expressions>
		2.8.1  Matches with m// <URL:#tn=		2.8.1  Matches with m//>
		2.8.2  Option Modifiers <URL:#tn=		2.8.2  Option Modifiers>
			2.8.2.1  Case-Insensitive Matching with /i <URL:#tn=			2.8.2.1  Case-Insensitive Matching with /i>
			2.8.2.2 Matching Any Character with /s <URL:#tn=			2.8.2.2 Matching Any Character with /s>
			2.8.2.3 Adding Whitespace with /x <URL:#tn=			2.8.2.3 Adding Whitespace with /x>
			2.8.2.4 Combining Option Modifiers <URL:#tn=			2.8.2.4 Combining Option Modifiers>
			2.8.2.5 Other Options <URL:#tn=			2.8.2.5 Other Options>
		2.8.3  Anchors <URL:#tn=		2.8.3  Anchors>
			2.8.3.1  Word Anchors <URL:#tn=			2.8.3.1  Word Anchors>
		2.8.4  The Binding Operator, =~ <URL:#tn=		2.8.4  The Binding Operator, =~>
		2.8.5  Interpolating into Patterns <URL:#tn=		2.8.5  Interpolating into Patterns>
		2.8.6  The Match Variables <URL:#tn=		2.8.6  The Match Variables>
			2.8.6.1  The Persistence of Memory <URL:#tn=			2.8.6.1  The Persistence of Memory>
			2.8.6.2 Noncapturing Parentheses <URL:#tn=			2.8.6.2 Noncapturing Parentheses>
		2.8.7 Named Captures <URL:#tn=		2.8.7 Named Captures>
		2.8.8 The Automatic Match Variables <URL:#tn=		2.8.8 The Automatic Match Variables>
		2.8.7  General Quantifiers <URL:#tn=		2.8.7  General Quantifiers>
		2.8.8  Precedence <URL:#tn=		2.8.8  Precedence>
			2.8.8.1  Examples of Precedence <URL:#tn=			2.8.8.1  Examples of Precedence>
			2.8.8.2 And There's More <URL:#tn=			2.8.8.2 And There's More>
		2.8.9  A Pattern Test Program <URL:#tn=		2.8.9  A Pattern Test Program>
		2.8.10 Exercises <URL:#tn=		2.8.10 Exercises>
	2.9 Processing Text with Regular Expressions <URL:#tn=	2.9 Processing Text with Regular Expressions>
		2.9.1 Substitutions with s/// <URL:#tn=		2.9.1 Substitutions with s///>
			2.9.1.1 Global Replacements with /g <URL:#tn=			2.9.1.1 Global Replacements with /g>
			2.9.1.2 Different Delimiters <URL:#tn=			2.9.1.2 Different Delimiters>
			2.9.1.3 Option Modifiers <URL:#tn=			2.9.1.3 Option Modifiers>
			2.9.1.4 The Binding Operator <URL:#tn=			2.9.1.4 The Binding Operator>
			2.9.1.5 Case Shifting <URL:#tn=			2.9.1.5 Case Shifting>
		2.9.2 The split Operator <URL:#tn=		2.9.2 The split Operator>
		2.9.3 The join Function <URL:#tn=		2.9.3 The join Function>
		2.9.4 m// in List Context <URL:#tn=		2.9.4 m// in List Context>
		2.9.5 More Powerful Regular Expressions <URL:#tn=		2.9.5 More Powerful Regular Expressions>
			2.9.5.1 Nongreedy Quantifiers <URL:#tn=			2.9.5.1 Nongreedy Quantifiers>
			2.9.5.2 Matching Multiple-Line Text <URL:#tn=			2.9.5.2 Matching Multiple-Line Text>
			2.9.5.3 Updating Many Files <URL:#tn=			2.9.5.3 Updating Many Files>
			2.9.5.4 In-Place Editing from the Command Line <URL:#tn=			2.9.5.4 In-Place Editing from the Command Line>
		2.9.6 Exercises	 <URL:#tn=		2.9.6 Exercises	>
	2.10 More Control Structures <URL:#tn=	2.10 More Control Structures>
		2.10.1  The unless Control Structure <URL:#tn=		2.10.1  The unless Control Structure>
			2.10.1.1  The else Clause with unless <URL:#tn=			2.10.1.1  The else Clause with unless>
		2.10.2  The until Control Structure <URL:#tn=		2.10.2  The until Control Structure>
		2.10.3  Expression Modifiers <URL:#tn=		2.10.3  Expression Modifiers>
		2.10.4  The Naked Block Control Structure <URL:#tn=		2.10.4  The Naked Block Control Structure>
		2.10.5  The elsif Clause <URL:#tn=		2.10.5  The elsif Clause>
		2.10.6  Autoincrement and Autodecrement <URL:#tn=		2.10.6  Autoincrement and Autodecrement>
			2.10.6.1  The Value of Autoincrement <URL:#tn=			2.10.6.1  The Value of Autoincrement>
		2.10.7  The for Control Structure <URL:#tn=		2.10.7  The for Control Structure>
			2.10.7.1  The Secret Connection Between foreach and for <URL:#tn=			2.10.7.1  The Secret Connection Between foreach and for>
		2.10.8  Loop Controls <URL:#tn=		2.10.8  Loop Controls>
			2.10.8.1  The last Operator (C's break) <URL:#tn=			2.10.8.1  The last Operator (C's break)>
			2.10.8.2 The next Operator (C's continue) <URL:#tn=			2.10.8.2 The next Operator (C's continue)>
			2.10.8.3 The redo Operator <URL:#tn=			2.10.8.3 The redo Operator>
			2.10.8.4 Labeled Blocks <URL:#tn=			2.10.8.4 Labeled Blocks>
		2.10.9  The Ternary Operator, ?: <URL:#tn=		2.10.9  The Ternary Operator, ?:>
		2.10.10 Logical Operators <URL:#tn=		2.10.10 Logical Operators>
			2.10.10.1 The Value of a Short-Circuit Operator <URL:#tn=			2.10.10.1 The Value of a Short-Circuit Operator>
			2.10.10.2 The defined-or Operator <URL:#tn=			2.10.10.2 The defined-or Operator>
			2.10.10.3 Control Structures Using Partial-Evaluation Operators <URL:#tn=			2.10.10.3 Control Structures Using Partial-Evaluation Operators>
		2.10.11 Exercises	 <URL:#tn=		2.10.11 Exercises	>
	2.11 Perl Modules <URL:#tn=	2.11 Perl Modules>
		2.11.1 Finding Modules <URL:#tn=		2.11.1 Finding Modules>
			2.11.1.1 Finding Modules <URL:#tn=			2.11.1.1 Finding Modules>
		2.11.2 Installing Modules <URL:#tn=		2.11.2 Installing Modules>
		2.11.3 Using Simple Modules <URL:#tn=		2.11.3 Using Simple Modules>
			2.11.3.1 The File::Basename Module <URL:#tn=			2.11.3.1 The File::Basename Module>
			2.11.3.2 Using Only Some Functions from a Module <URL:#tn=			2.11.3.2 Using Only Some Functions from a Module>
			2.11.3.3 The File::Spec Module <URL:#tn=			2.11.3.3 The File::Spec Module>
			2.11.3.4 CGI.pm <URL:#tn=			2.11.3.4 CGI.pm>
			2.11.3.5 Databases and DBI <URL:#tn=			2.11.3.5 Databases and DBI>
		2.11.4 Exercise	 <URL:#tn=		2.11.4 Exercise	>
	2.12 File Tests <URL:#tn=	2.12 File Tests>
		2.12.1 File Test Operators <URL:#tn=		2.12.1 File Test Operators>
			2.12.1.1 Table 12-1. File tests and their meanings <URL:#tn=			2.12.1.1 Table 12-1. File tests and their meanings>
			2.12.1.2 Testing Several Attributes of the Same File <URL:#tn=			2.12.1.2 Testing Several Attributes of the Same File>
			2.12.1.3 Stacked File Test Operators <URL:#tn=			2.12.1.3 Stacked File Test Operators>
		2.12.2 The stat and lstat Functions <URL:#tn=		2.12.2 The stat and lstat Functions>
		2.12.3 The localtime Function <URL:#tn=		2.12.3 The localtime Function>
		2.12.4 Bitwise Operators <URL:#tn=		2.12.4 Bitwise Operators>
			2.12.4.1 Using Bitstrings <URL:#tn=			2.12.4.1 Using Bitstrings>
		2.12.5 Exercises <URL:#tn=		2.12.5 Exercises>
	2.13 Directory Operations <URL:#tn=	2.13 Directory Operations>
		2.13.1  Moving Around the Directory Tree <URL:#tn=		2.13.1  Moving Around the Directory Tree>
		2.13.2  Globbing <URL:#tn=		2.13.2  Globbing>
		2.13.3  An Alternate Syntax for Globbing <URL:#tn=		2.13.3  An Alternate Syntax for Globbing>
		2.13.4  Directory Handles <URL:#tn=		2.13.4  Directory Handles>
		2.13.5  Recursive Directory Listing <URL:#tn=		2.13.5  Recursive Directory Listing>
		2.13.6  Manipulating Files and Directories <URL:#tn=		2.13.6  Manipulating Files and Directories>
		2.13.7  Removing Files <URL:#tn=		2.13.7  Removing Files>
		2.13.8  Renaming Files <URL:#tn=		2.13.8  Renaming Files>
		2.13.9  Links and Files <URL:#tn=		2.13.9  Links and Files>
		2.13.10 Making and Removing Directories <URL:#tn=		2.13.10 Making and Removing Directories>
		2.13.11 Modifying Permissions <URL:#tn=		2.13.11 Modifying Permissions>
		2.13.12 Changing Ownership <URL:#tn=		2.13.12 Changing Ownership>
		2.13.13 Changing Timestamps <URL:#tn=		2.13.13 Changing Timestamps>
		2.13.14 Exercises	 <URL:#tn=		2.13.14 Exercises	>
	2.14 Strings and Sorting <URL:#tn=	2.14 Strings and Sorting>
		2.14.1 Finding a Substring with index <URL:#tn=		2.14.1 Finding a Substring with index>
		2.14.2 Manipulating a Substring with substr <URL:#tn=		2.14.2 Manipulating a Substring with substr>
		2.14.3 Formatting Data with sprintf <URL:#tn=		2.14.3 Formatting Data with sprintf>
			2.14.3.1 Using sprintf with "Money Numbers" <URL:#tn=			2.14.3.1 Using sprintf with "Money Numbers">
		2.14.4 Advanced Sorting <URL:#tn=		2.14.4 Advanced Sorting>
			2.14.4.1 Sorting a Hash by Value <URL:#tn=			2.14.4.1 Sorting a Hash by Value>
			2.14.4.2 Sorting by Multiple Keys <URL:#tn=			2.14.4.2 Sorting by Multiple Keys>
		2.14.5 Exercises <URL:#tn=		2.14.5 Exercises>
	2.15 Smart Matching and given-when <URL:#tn=	2.15 Smart Matching and given-when>
		2.15.2. Smart Match Precedence <URL:#tn=		2.15.2. Smart Match Precedence>
		2.15.3 The given Statement <URL:#tn=		2.15.3 The given Statement>
			2.15.3.1 Dumb Matching <URL:#tn=			2.15.3.1 Dumb Matching>
		2.15.4. when with Many Items <URL:#tn=		2.15.4. when with Many Items>
		2.15.5. Exercises <URL:#tn=		2.15.5. Exercises>
	2.16 Process Management <URL:#tn=	2.16 Process Management>
		2.16.1 The system Function <URL:#tn=		2.16.1 The system Function>
			2.16.1.1 Avoiding the Shell <URL:#tn=			2.16.1.1 Avoiding the Shell>
		2.16.2 The exec Function <URL:#tn=		2.16.2 The exec Function>
		2.16.3 The Environment Variables <URL:#tn=		2.16.3 The Environment Variables>
		2.16.4 Using Backquotes to Capture Output <URL:#tn=		2.16.4 Using Backquotes to Capture Output>
			2.16.4.1  Using Backquotes in a List Context <URL:#tn=			2.16.4.1  Using Backquotes in a List Context>
		2.16.5 Processes as Filehandles <URL:#tn=		2.16.5 Processes as Filehandles>
		2.16.6 Getting Down and Dirty with Fork <URL:#tn=		2.16.6 Getting Down and Dirty with Fork>
		2.16.7 Sending and Receiving Signals <URL:#tn=		2.16.7 Sending and Receiving Signals>
		2.16.8 Exercises <URL:#tn=		2.16.8 Exercises>
	2.17 Some Advanced Perl Techniques <URL:#tn=	2.17 Some Advanced Perl Techniques>
		2.17.1 Trapping Errors with eval <URL:#tn=		2.17.1 Trapping Errors with eval>
			2.17.1.1 Trapping Errors with eval <URL:#tn=			2.17.1.1 Trapping Errors with eval>
		2.17.2 Picking Items from a List with grep <URL:#tn=		2.17.2 Picking Items from a List with grep>
		2.17.3 Transforming Items from a List with map <URL:#tn=		2.17.3 Transforming Items from a List with map>
		2.17.4 Unquoted Hash Keys <URL:#tn=		2.17.4 Unquoted Hash Keys>
		2.17.5 Slices <URL:#tn=		2.17.5 Slices>
			2.17.5.1 Array Slice <URL:#tn=			2.17.5.1 Array Slice>
			2.17.5.2 Hash Slice <URL:#tn=			2.17.5.2 Hash Slice>
		2.17.6 Exercise <URL:#tn=		2.17.6 Exercise>
	2.18 Exercise Answers <URL:#tn=	2.18 Exercise Answers>
	2.19 Beyond the Llama <URL:#tn=	2.19 Beyond the Llama>
3. Intermediate Perl, 1st Edition <URL:#tn=3. Intermediate Perl, 1st Edition>
4. Mastering Perl <URL:#tn=4. Mastering Perl>
5. Command line flags, parameters processing <URL:#tn=5. Command line flags, parameters processing>
	5.1 getopts <URL:#tn=	5.1 getopts>
		5.1.1 Perl Getopt and GetOptions <URL:#tn=		5.1.1 Perl Getopt and GetOptions>
		5.1.2 Process options passed to a program using getopts(). <URL:#tn=		5.1.2 Process options passed to a program using getopts().>
		5.1.3 <URL:#tn=		5.1.3>
	5.2 <URL:#tn=	5.2>
6.  cookbook Recipes <URL:#tn=6.  cookbook Recipes>
	6.1  sort <URL:#tn=	6.1  sort>
		6.1.1  "sort" a hash  <URL:#tn=		6.1.1  "sort" a hash >
			6.1.1.1  "sort" a hash by key  <URL:#tn=			6.1.1.1  "sort" a hash by key >
			6.1.1.2  "sort" a hash by value  <URL:#tn=			6.1.1.2  "sort" a hash by value >
			6.1.1.3 <URL:#tn=			6.1.1.3>
		6.1.2 <URL:#tn=		6.1.2>
	6.2 Perl Cookbook, 2nd Edition <URL:#tn=	6.2 Perl Cookbook, 2nd Edition>
		6.2.1 Chapter 1, Strings <URL:#tn=		6.2.1 Chapter 1, Strings>
			6.2.1.1 substr <URL:#tn=			6.2.1.1 substr>
		6.2.2 Establishing a Default Value <URL:#tn=		6.2.2 Establishing a Default Value>
		6.2.3 Exchanging Values Without Using Temporary Variables <URL:#tn=		6.2.3 Exchanging Values Without Using Temporary Variables>
		6.2.4 Converting Between Characters and Values <URL:#tn=		6.2.4 Converting Between Characters and Values>
102.97.99.807.97.100.101 <URL:#tn=102.97.99.807.97.100.101>
66.61.63.327.61.64.65 <URL:#tn=66.61.63.327.61.64.65>
		6.2.5 Using Named Unicode Characters <URL:#tn=		6.2.5 Using Named Unicode Characters>
		6.2.6 Reversing a String by Word or Character <URL:#tn=		6.2.6 Reversing a String by Word or Character>
		6.2.7 Processing a String One Character at a Time <URL:#tn=		6.2.7 Processing a String One Character at a Time>
		6.2.8 Treating Unicode Combined Characters as Single Characters <URL:#tn=		6.2.8 Treating Unicode Combined Characters as Single Characters>
		6.2.9 Canonicalizing Strings with Unicode Combined Characters <URL:#tn=		6.2.9 Canonicalizing Strings with Unicode Combined Characters>
		6.2.10 Treating a Unicode String as Octets <URL:#tn=		6.2.10 Treating a Unicode String as Octets>
		6.2.11 Expanding and Compressing Tabs <URL:#tn=		6.2.11 Expanding and Compressing Tabs>
		6.2.12 Expanding Variables in User Input <URL:#tn=		6.2.12 Expanding Variables in User Input>
		6.2.13 Controlling Case <URL:#tn=		6.2.13 Controlling Case>
		6.2.14 Properly Capitalizing a Title or Headline <URL:#tn=		6.2.14 Properly Capitalizing a Title or Headline>
		6.2.15 <URL:#tn=		6.2.15>
		6.2.16 Indenting Here Documents <URL:#tn=		6.2.16 Indenting Here Documents>
		6.2.17 Reformatting Paragraphs <URL:#tn=		6.2.17 Reformatting Paragraphs>
		6.2.18 Escaping Characters <URL:#tn=		6.2.18 Escaping Characters>
		6.2.19 Trimming Blanks from the Ends of a String <URL:#tn=		6.2.19 Trimming Blanks from the Ends of a String>
		6.2.20 Parsing Comma-Separated Data <URL:#tn=		6.2.20 Parsing Comma-Separated Data>
		6.2.21 Constant Variables <URL:#tn=		6.2.21 Constant Variables>
		6.2.22 Soundex Matching <URL:#tn=		6.2.22 Soundex Matching>
		6.2.23 Program: fixstyle <URL:#tn=		6.2.23 Program: fixstyle>
		6.2.24 Program: psgrep <URL:#tn=		6.2.24 Program: psgrep>
	6.3 Numbers <URL:#tn=	6.3 Numbers>
		6.3.1 Introduction <URL:#tn=		6.3.1 Introduction>
		6.3.2 Checking Whether a String Is a Valid Number <URL:#tn=		6.3.2 Checking Whether a String Is a Valid Number>
		6.3.3 Rounding Floating-Point Numbers <URL:#tn=		6.3.3 Rounding Floating-Point Numbers>
1.0000e-07       0.0000        1e-07 <URL:#tn=1.0000e-07       0.0000        1e-07>
1.0100e+01      10.1000         10.1 <URL:#tn=1.0100e+01      10.1000         10.1>
1.0000e+01      10.0000           10 <URL:#tn=1.0000e+01      10.0000           10>
1.0000e+05  100000.1000        1e+05 <URL:#tn=1.0000e+05  100000.1000        1e+05>
0.625 is 0.625 <URL:#tn=0.625 is 0.625>
0.725 is 0.724999999999999977795539507497 <URL:#tn=0.725 is 0.724999999999999977795539507497>
0.325 is 0.33 or 0.325000000000000011102230246252 <URL:#tn=0.325 is 0.33 or 0.325000000000000011102230246252>
0.725 is 0.72 or 0.724999999999999977795539507497 <URL:#tn=0.725 is 0.72 or 0.724999999999999977795539507497>
 0.5  0 <URL:#tn= 0.5  0>
 1.5  2 <URL:#tn= 1.5  2>
 2.5  2 <URL:#tn= 2.5  2>
 3.5  4 <URL:#tn= 3.5  4>
 4.5  4 <URL:#tn= 4.5  4>
   0.5        0        0        0        1 <URL:#tn=   0.5        0        0        0        1>
   1.5        2        1        1        2 <URL:#tn=   1.5        2        1        1        2>
   2.5        2        2        2        3 <URL:#tn=   2.5        2        2        2        3>
   3.5        4        3        3        4 <URL:#tn=   3.5        4        3        3        4>
   4.5        4        4        4        5 <URL:#tn=   4.5        4        4        4        5>
   5.5        6        5        5        6 <URL:#tn=   5.5        6        5        5        6>
   6.5        6        6        6        7 <URL:#tn=   6.5        6        6        6        7>
   6.5        6        6        0       13 <URL:#tn=   6.5        6        6        0       13>
		6.3.4 Comparing Floating-Point Numbers <URL:#tn=		6.3.4 Comparing Floating-Point Numbers>
		6.3.5 Operating on a Series of Integers <URL:#tn=		6.3.5 Operating on a Series of Integers>
		6.3.6 Working with Roman Numerals <URL:#tn=		6.3.6 Working with Roman Numerals>
		6.3.7 Generating Random Numbers <URL:#tn=		6.3.7 Generating Random Numbers>
		6.3.8 Generating Repeatable Random Number Sequences <URL:#tn=		6.3.8 Generating Repeatable Random Number Sequences>
		6.3.9 Making Numbers Even More Random <URL:#tn=		6.3.9 Making Numbers Even More Random>
		6.3.10 Generating Biased Random Numbers <URL:#tn=		6.3.10 Generating Biased Random Numbers>
		6.3.11 Doing Trigonometry in Degrees, Not Radians <URL:#tn=		6.3.11 Doing Trigonometry in Degrees, Not Radians>
		6.3.12 Calculating More Trigonometric Functions <URL:#tn=		6.3.12 Calculating More Trigonometric Functions>
		6.3.13 Taking Logarithms <URL:#tn=		6.3.13 Taking Logarithms>
		6.3.14 Multiplying Matrices <URL:#tn=		6.3.14 Multiplying Matrices>
		6.3.15 Using Complex Numbers <URL:#tn=		6.3.15 Using Complex Numbers>
		6.3.16 Converting Binary, Octal, and Hexadecimal Numbers <URL:#tn=		6.3.16 Converting Binary, Octal, and Hexadecimal Numbers>
		6.3.17 Putting Commas in Numbers <URL:#tn=		6.3.17 Putting Commas in Numbers>
		6.3.18 Printing Correct Plurals <URL:#tn=		6.3.18 Printing Correct Plurals>
		6.3.19 Program: Calculating Prime Factors <URL:#tn=		6.3.19 Program: Calculating Prime Factors>
		6.3.20  Dates and Times <URL:#tn=		6.3.20  Dates and Times>
			6.3.20.1   Finding Today’s Date <URL:#tn=			6.3.20.1   Finding Today’s Date>
			6.3.20.2   Converting DMYHMS to Epoch Seconds <URL:#tn=			6.3.20.2   Converting DMYHMS to Epoch Seconds>
			6.3.20.3   Converting Epoch Seconds to DMYHMS <URL:#tn=			6.3.20.3   Converting Epoch Seconds to DMYHMS>
			6.3.20.4   Adding to or Subtracting from a Date <URL:#tn=			6.3.20.4   Adding to or Subtracting from a Date>
			6.3.20.5   Difference of Two Dates <URL:#tn=			6.3.20.5   Difference of Two Dates>
			6.3.20.6   Day in a Week/Month/Year or Week Number <URL:#tn=			6.3.20.6   Day in a Week/Month/Year or Week Number>
			6.3.20.7   arsing Dates and Times from Strings <URL:#tn=			6.3.20.7   arsing Dates and Times from Strings>
			6.3.20.8   Printing a Date <URL:#tn=			6.3.20.8   Printing a Date>
			6.3.20.9   High-Resolution Timers <URL:#tn=			6.3.20.9   High-Resolution Timers>
			6.3.20.10  Short Sleeps <URL:#tn=			6.3.20.10  Short Sleeps>
			6.3.20.11  Program: hopdelta <URL:#tn=			6.3.20.11  Program: hopdelta>
			6.3.20.12   <URL:#tn=			6.3.20.12  >
		6.3.21 <URL:#tn=		6.3.21>
	6.4 Arrays <URL:#tn=	6.4 Arrays>
		6.4.1  Specifying a List in Your Program <URL:#tn=		6.4.1  Specifying a List in Your Program>
		6.4.2   <URL:#tn=		6.4.2  >
		6.4.3   <URL:#tn=		6.4.3  >
		6.4.4   <URL:#tn=		6.4.4  >
		6.4.5   <URL:#tn=		6.4.5  >
		6.4.6   <URL:#tn=		6.4.6  >
		6.4.7   <URL:#tn=		6.4.7  >
		6.4.8   <URL:#tn=		6.4.8  >
		6.4.9   <URL:#tn=		6.4.9  >
		6.4.10  <URL:#tn=		6.4.10 >
		6.4.11  <URL:#tn=		6.4.11 >
		6.4.12  <URL:#tn=		6.4.12 >
		6.4.13  <URL:#tn=		6.4.13 >
		6.4.14  <URL:#tn=		6.4.14 >
		6.4.15  <URL:#tn=		6.4.15 >
		6.4.16  <URL:#tn=		6.4.16 >
		6.4.17  <URL:#tn=		6.4.17 >
		6.4.18  <URL:#tn=		6.4.18 >
		6.4.19  <URL:#tn=		6.4.19 >
		6.4.20  <URL:#tn=		6.4.20 >
		6.4.21  <URL:#tn=		6.4.21 >
	6.5  <URL:#tn=	6.5 >
	6.6  <URL:#tn=	6.6 >
	6.7  <URL:#tn=	6.7 >
	6.8  <URL:#tn=	6.8 >
	6.9  <URL:#tn=	6.9 >
	6.10 <URL:#tn=	6.10>
	6.11 <URL:#tn=	6.11>
	6.12 <URL:#tn=	6.12>
	6.13 <URL:#tn=	6.13>
	6.14 <URL:#tn=	6.14>
	6.15 <URL:#tn=	6.15>
	6.16 <URL:#tn=	6.16>
	6.17 <URL:#tn=	6.17>
	6.18 <URL:#tn=	6.18>
	6.19 <URL:#tn=	6.19>
	6.20 <URL:#tn=	6.20>
	6.21 <URL:#tn=	6.21>
	6.22 <URL:#tn=	6.22>
7.  My examples <URL:#tn=7.  My examples>
	7.1  Print all fields in file lines that match a pattern <URL:#tn=	7.1  Print all fields in file lines that match a pattern>
	7.2 Looping <URL:#tn=	7.2 Looping>
		7.2.1 looping over an array <URL:#tn=		7.2.1 looping over an array>
	7.3 regexp <URL:#tn=	7.3 regexp>
		7.3.1  non greedy match - .*? <URL:#tn=		7.3.1  non greedy match - .*?>
		7.3.2 <URL:#tn=		7.3.2>
	7.4 Filter user names from file, sort and uniq them <URL:#tn=	7.4 Filter user names from file, sort and uniq them>
	7.5 DNS query host address <URL:#tn=	7.5 DNS query host address>
		7.5.1 Using Net::DNS <URL:#tn=		7.5.1 Using Net::DNS>
		7.5.2  Using gethostbyname  <URL:#tn=		7.5.2  Using gethostbyname >
		7.5.3 Using nslookup, also use output to block traffic  <URL:#tn=		7.5.3 Using nslookup, also use output to block traffic >
	7.6  replace last line matching pattern <URL:#tn=	7.6  replace last line matching pattern>
8. Oneliners <URL:#tn=8. Oneliners>
	8.1 Intro <URL:#tn=	8.1 Intro>
	8.2 Spacing <URL:#tn=	8.2 Spacing>
		8.2.1 Double-space a file <URL:#tn=		8.2.1 Double-space a file>
		8.2.2 Triple-space a file <URL:#tn=		8.2.2 Triple-space a file>
		8.2.3 N-space a file <URL:#tn=		8.2.3 N-space a file>
		8.2.4 Add a blank line before every line <URL:#tn=		8.2.4 Add a blank line before every line>
		8.2.5 Remove all blank lines <URL:#tn=		8.2.5 Remove all blank lines>
		8.2.6 Remove all consecutive blank lines, leaving only one <URL:#tn=		8.2.6 Remove all consecutive blank lines, leaving only one>
		8.2.7 Compress/expand all blank lines into N consecutive lines <URL:#tn=		8.2.7 Compress/expand all blank lines into N consecutive lines>
		8.2.8 Double-space between all words <URL:#tn=		8.2.8 Double-space between all words>
		8.2.9 Remove all spacing between words <URL:#tn=		8.2.9 Remove all spacing between words>
		8.2.10 Change all spacing between words to one space <URL:#tn=		8.2.10 Change all spacing between words to one space>
		8.2.11 Insert a space between all characters <URL:#tn=		8.2.11 Insert a space between all characters>
		8.2.12 <URL:#tn=		8.2.12>
		8.3 Numbering <URL:#tn=		8.3 Numbering>
			8.3.1  Number all lines in a file <URL:#tn=			8.3.1  Number all lines in a file>
			8.3.2  Number only non-empty lines in a file <URL:#tn=			8.3.2  Number only non-empty lines in a file>
			8.3.3  Number and print only non-empty lines in a file (drop empty lines) <URL:#tn=			8.3.3  Number and print only non-empty lines in a file (drop empty lines)>
			8.3.4  Number all lines but print line numbers only for non-empty lines <URL:#tn=			8.3.4  Number all lines but print line numbers only for non-empty lines>
			8.3.5  Number only lines that match a pattern; print others unmodified <URL:#tn=			8.3.5  Number only lines that match a pattern; print others unmodified>
			8.3.6  Number and print only lines that match a pattern <URL:#tn=			8.3.6  Number and print only lines that match a pattern>
			8.3.7  Number all lines in a file using a custom format <URL:#tn=			8.3.7  Number all lines in a file using a custom format>
			8.3.8  Print the total number of lines in a file (emulate wc -l) <URL:#tn=			8.3.8  Print the total number of lines in a file (emulate wc -l)>
			8.3.9  3.10 Print the number of non-empty lines in a file <URL:#tn=			8.3.9  3.10 Print the number of non-empty lines in a file>
			8.3.10 Print the number of empty lines in a file <URL:#tn=			8.3.10 Print the number of empty lines in a file>
			8.3.11  <URL:#tn=			8.3.11 >
			8.3.12 Number words across all lines <URL:#tn=			8.3.12 Number words across all lines>
			8.3.13 Number words on each individual line <URL:#tn=			8.3.13 Number words on each individual line>
			8.3.14 Replace all words with their numeric positions <URL:#tn=			8.3.14 Replace all words with their numeric positions>
			8.3.15   <URL:#tn=			8.3.15  >
			8.3.16  <URL:#tn=			8.3.16 >
		8.4 Calculations <URL:#tn=		8.4 Calculations>
			8.4.1  Check if a number is a prime <URL:#tn=			8.4.1  Check if a number is a prime>
			8.4.2  Print the sum of all fields on each line <URL:#tn=			8.4.2  Print the sum of all fields on each line>
			8.4.3  Print the sum of all fields on all lines <URL:#tn=			8.4.3  Print the sum of all fields on all lines>
			8.4.4  Shuffle all fields on each line <URL:#tn=			8.4.4  Shuffle all fields on each line>
			8.4.5  Find the numerically smallest element (minimum element) on each line <URL:#tn=			8.4.5  Find the numerically smallest element (minimum element) on each line>
			8.4.6  Find the numerically smallest element (minimum element) over all lines <URL:#tn=			8.4.6  Find the numerically smallest element (minimum element) over all lines>
			8.4.7   Find the numerically largest element (maximum element) on each line <URL:#tn=			8.4.7   Find the numerically largest element (maximum element) on each line>
			8.4.8  Find the numerically largest element (maximum element) over all lines <URL:#tn=			8.4.8  Find the numerically largest element (maximum element) over all lines>
			8.4.9  Print the total number of fields on each line <URL:#tn=			8.4.9  Print the total number of fields on each line>
			8.4.10 Print the total number of fields on each line, followed by the line <URL:#tn=			8.4.10 Print the total number of fields on each line, followed by the line>
			8.4.11 Print the total number of fields on all lines <URL:#tn=			8.4.11 Print the total number of fields on all lines>
			8.4.12 Print the total number of fields that match a pattern <URL:#tn=			8.4.12 Print the total number of fields that match a pattern>
			8.4.13 Print the total number of lines that match a pattern <URL:#tn=			8.4.13 Print the total number of lines that match a pattern>
			8.4.14 Print the number π <URL:#tn=			8.4.14 Print the number π>
			8.4.15 Print the number e <URL:#tn=			8.4.15 Print the number e>
			8.4.16 Print UNIX time (seconds since January 1, 1970, 00:00:00 UTC) <URL:#tn=			8.4.16 Print UNIX time (seconds since January 1, 1970, 00:00:00 UTC)>
			8.4.17 Print Greenwich Mean Time and local computer time <URL:#tn=			8.4.17 Print Greenwich Mean Time and local computer time>
			8.4.18 Print yesterday’s date <URL:#tn=			8.4.18 Print yesterday’s date>
			8.4.19 Print the date 14 months, 9 days, and 7 seconds ago <URL:#tn=			8.4.19 Print the date 14 months, 9 days, and 7 seconds ago>
			8.4.20 Calculate the factorial <URL:#tn=			8.4.20 Calculate the factorial>
			8.4.21 Calculate the greatest common divisor <URL:#tn=			8.4.21 Calculate the greatest common divisor>
			8.4.22 Calculate the least common multiple <URL:#tn=			8.4.22 Calculate the least common multiple>
			8.4.23 Generate 10 random numbers between 5 and 15 (excluding 15) <URL:#tn=			8.4.23 Generate 10 random numbers between 5 and 15 (excluding 15)>
			8.4.24 Generate 10 random numbers between 5 and 15 (excluding 15) <URL:#tn=			8.4.24 Generate 10 random numbers between 5 and 15 (excluding 15)>
			8.4.25 Generate all permutations of a list <URL:#tn=			8.4.25 Generate all permutations of a list>
			8.4.26 Generate the powerset <URL:#tn=			8.4.26 Generate the powerset>
			8.4.27 Convert an IP address to an unsigned integer <URL:#tn=			8.4.27 Convert an IP address to an unsigned integer>
			8.4.28 Convert an unsigned integer to an IP address <URL:#tn=			8.4.28 Convert an unsigned integer to an IP address>
			8.4.29  <URL:#tn=			8.4.29 >
			8.4.30  <URL:#tn=			8.4.30 >
			8.4.31  <URL:#tn=			8.4.31 >
		8.5 Working With Arrays and Strings <URL:#tn=		8.5 Working With Arrays and Strings>
			8.5.1 Generate and print the alphabet <URL:#tn=			8.5.1 Generate and print the alphabet>
			8.5.2  Generate and print all the strings from “a” to “zz” <URL:#tn=			8.5.2  Generate and print all the strings from “a” to “zz”>
			8.5.3  Create a hex lookup table <URL:#tn=			8.5.3  Create a hex lookup table>
			8.5.4  Generate a random eight-character password <URL:#tn=			8.5.4  Generate a random eight-character password>
			8.5.5  Create a string of specific length <URL:#tn=			8.5.5  Create a string of specific length>
			8.5.6  Create an array from a string <URL:#tn=			8.5.6  Create an array from a string>
			8.5.7  Create a string from the command-line arguments <URL:#tn=			8.5.7  Create a string from the command-line arguments>
			8.5.8  Find the numeric values for characters in a string <URL:#tn=			8.5.8  Find the numeric values for characters in a string>
			8.5.9  Convert a list of numeric ASCII values into a string <URL:#tn=			8.5.9  Convert a list of numeric ASCII values into a string>
			8.5.10 Generate an array with odd numbers from 1 to 100 <URL:#tn=			8.5.10 Generate an array with odd numbers from 1 to 100>
			8.5.11 Generate an array with even numbers from 1 to 100 <URL:#tn=			8.5.11 Generate an array with even numbers from 1 to 100>
			8.5.12 Find the length of a string <URL:#tn=			8.5.12 Find the length of a string>
			8.5.13 Find the number of elements in an array <URL:#tn=			8.5.13 Find the number of elements in an array>
			8.5.14  <URL:#tn=			8.5.14 >
		8.6  Text Conversion and Substitution <URL:#tn=		8.6  Text Conversion and Substitution>
			8.6.1   ROT13 a string <URL:#tn=			8.6.1   ROT13 a string>
			8.6.2   Base64-encode a string <URL:#tn=			8.6.2   Base64-encode a string>
			8.6.3   Base64-decode a string <URL:#tn=			8.6.3   Base64-decode a string>
			8.6.4   URL-escape a string <URL:#tn=			8.6.4   URL-escape a string>
			8.6.5   URL-unescape a string <URL:#tn=			8.6.5   URL-unescape a string>
			8.6.6   HTML-encode a string <URL:#tn=			8.6.6   HTML-encode a string>
			8.6.7   HTML-decode a string <URL:#tn=			8.6.7   HTML-decode a string>
			8.6.8   HTML-decode a string <URL:#tn=			8.6.8   HTML-decode a string>
			8.6.9   Convert all text to uppercase <URL:#tn=			8.6.9   Convert all text to uppercase>
			8.6.10  Convert all text to lowercase <URL:#tn=			8.6.10  Convert all text to lowercase>
			8.6.11  Uppercase only the first letter of each line <URL:#tn=			8.6.11  Uppercase only the first letter of each line>
			8.6.12  Invert the letter case <URL:#tn=			8.6.12  Invert the letter case>
			8.6.13  Title-case each line <URL:#tn=			8.6.13  Title-case each line>
			8.6.14  Strip leading whitespace (spaces, tabs) from the beginning of each line <URL:#tn=			8.6.14  Strip leading whitespace (spaces, tabs) from the beginning of each line>
			8.6.15  Strip trailing whitespace (spaces, tabs) from the end of each line <URL:#tn=			8.6.15  Strip trailing whitespace (spaces, tabs) from the end of each line>
			8.6.16  Strip whitespace (spaces, tabs) from the beginning and end of each line <URL:#tn=			8.6.16  Strip whitespace (spaces, tabs) from the beginning and end of each line>
			8.6.17  Convert UNIX newlines to DOS/Windows newlines <URL:#tn=			8.6.17  Convert UNIX newlines to DOS/Windows newlines>
			8.6.18  Convert DOS/Windows newlines to UNIX newlines <URL:#tn=			8.6.18  Convert DOS/Windows newlines to UNIX newlines>
			8.6.19  Convert UNIX newlines to Mac newlines <URL:#tn=			8.6.19  Convert UNIX newlines to Mac newlines>
			8.6.20  Substitute (find and replace) “foo” with “bar” on each line <URL:#tn=			8.6.20  Substitute (find and replace) “foo” with “bar” on each line>
			8.6.21  Substitute (find and replace) “foo” with “bar” on lines that match “baz” <URL:#tn=			8.6.21  Substitute (find and replace) “foo” with “bar” on lines that match “baz”>
			8.6.22  Print paragraphs in reverse order <URL:#tn=			8.6.22  Print paragraphs in reverse order>
			8.6.23  Print all lines in reverse order <URL:#tn=			8.6.23  Print all lines in reverse order>
			8.6.24 Print columns in reverse order <URL:#tn=			8.6.24 Print columns in reverse order>
			8.6.25 <URL:#tn=			8.6.25>
		8.7  Selectively Printing and Deleting Lines <URL:#tn=		8.7  Selectively Printing and Deleting Lines>
			8.7.1   Print the first line of a file (emulate head -1) <URL:#tn=			8.7.1   Print the first line of a file (emulate head -1)>
			8.7.2    Print the first 10 lines of a file (emulate head -10) <URL:#tn=			8.7.2    Print the first 10 lines of a file (emulate head -10)>
			8.7.3   Print the last line of a file (emulate tail -1) <URL:#tn=			8.7.3   Print the last line of a file (emulate tail -1)>
			8.7.4   Print the last 10 lines of a file (emulate tail -10) <URL:#tn=			8.7.4   Print the last 10 lines of a file (emulate tail -10)>
			8.7.5   Print only lines that match a regular expression <URL:#tn=			8.7.5   Print only lines that match a regular expression>
			8.7.6    Print only lines that do not match a regular expression <URL:#tn=			8.7.6    Print only lines that do not match a regular expression>
			8.7.7   Print every line preceding a line that matches a regular expression <URL:#tn=			8.7.7   Print every line preceding a line that matches a regular expression>
			8.7.8 Print every line following a line that matches a regular expression <URL:#tn=			8.7.8 Print every line following a line that matches a regular expression>
			8.7.9   Print lines that match regular expressions AAA and BBB in any order <URL:#tn=			8.7.9   Print lines that match regular expressions AAA and BBB in any order>
			8.7.10  Print lines that match regular expression AAA followed by BBB followed by CCC <URL:#tn=			8.7.10  Print lines that match regular expression AAA followed by BBB followed by CCC>
			8.7.11   Print lines that are at least 80 characters long <URL:#tn=			8.7.11   Print lines that are at least 80 characters long>
			8.7.12  Print lines that are fewer than 80 characters long <URL:#tn=			8.7.12  Print lines that are fewer than 80 characters long>
			8.7.13  Print only line 13 <URL:#tn=			8.7.13  Print only line 13>
			8.7.14  Print all lines except line 27 <URL:#tn=			8.7.14  Print all lines except line 27>
			8.7.15  Print only lines 13, 19, and 67 <URL:#tn=			8.7.15  Print only lines 13, 19, and 67>
			8.7.16  Print all lines from 17 to 30 <URL:#tn=			8.7.16  Print all lines from 17 to 30>
			8.7.17  Print all lines between two regular expressions (including the lines that match) <URL:#tn=			8.7.17  Print all lines between two regular expressions (including the lines that match)>
			8.7.18  Print the longest line <URL:#tn=			8.7.18  Print the longest line>
			8.7.19  Print the shortest line <URL:#tn=			8.7.19  Print the shortest line>
			8.7.20  Print all lines containing digits <URL:#tn=			8.7.20  Print all lines containing digits>
			8.7.21  Print all lines containing only digits <URL:#tn=			8.7.21  Print all lines containing only digits>
			8.7.22  Print all lines containing only alphabetic characters <URL:#tn=			8.7.22  Print all lines containing only alphabetic characters>
			8.7.23  Print every second line <URL:#tn=			8.7.23  Print every second line>
			8.7.24  Print every second line, beginning with the second line <URL:#tn=			8.7.24  Print every second line, beginning with the second line>
			8.7.25  Print all repeated lines only once <URL:#tn=			8.7.25  Print all repeated lines only once>
			8.7.26  Print all unique lines <URL:#tn=			8.7.26  Print all unique lines>
			8.7.27   <URL:#tn=			8.7.27  >
			8.7.28   <URL:#tn=			8.7.28  >
		8.8  Useful Regular Expressions <URL:#tn=		8.8  Useful Regular Expressions>
			8.8.1 Match something that looks like an IP address <URL:#tn=			8.8.1 Match something that looks like an IP address>
			8.8.2   Test whether a number is in the range 0 to 255 <URL:#tn=			8.8.2   Test whether a number is in the range 0 to 255>
			8.8.3   Match an IP address <URL:#tn=			8.8.3   Match an IP address>
			8.8.4   Check whether a string looks like an email address <URL:#tn=			8.8.4   Check whether a string looks like an email address>
			8.8.5    Check whether a string is a number <URL:#tn=			8.8.5    Check whether a string is a number>
			8.8.6   Check whether a word appears in a string twice <URL:#tn=			8.8.6   Check whether a word appears in a string twice>
			8.8.7    Increase all integers in a string by one <URL:#tn=			8.8.7    Increase all integers in a string by one>
			8.8.8   Extract the HTTP User-Agent string from HTTP headers <URL:#tn=			8.8.8   Extract the HTTP User-Agent string from HTTP headers>
			8.8.9   Match printable ASCII characters <URL:#tn=			8.8.9   Match printable ASCII characters>
			8.8.10  Extract text between two HTML tags <URL:#tn=			8.8.10  Extract text between two HTML tags>
			8.8.11  Replace all <b> tags with <strong> <URL:#tn=			8.8.11  Replace all <b> tags with <strong>>
			8.8.12  Extract all matches from a regular expression <URL:#tn=			8.8.12  Extract all matches from a regular expression>
		8.9 Perl’s Special Variables <URL:#tn=		8.9 Perl’s Special Variables>
			8.9.1    <URL:#tn=			8.9.1   >
			8.9.2  A.2 Variable $. <URL:#tn=			8.9.2  A.2 Variable $.>
			8.9.3  Variable $/ <URL:#tn=			8.9.3  Variable $/>
			8.9.4  Variable $\ <URL:#tn=			8.9.4  Variable $\>
			8.9.5  ariables $1, $2, $3, and so on <URL:#tn=			8.9.5  ariables $1, $2, $3, and so on>
			8.9.6  Variable $, <URL:#tn=			8.9.6  Variable $,>
			8.9.7  Variable $” <URL:#tn=			8.9.7  Variable $”>
			8.9.8  Variable @F <URL:#tn=			8.9.8  Variable @F>
			8.9.9  Variable @ARGV <URL:#tn=			8.9.9  Variable @ARGV>
			8.9.10 Variable %ENV <URL:#tn=			8.9.10 Variable %ENV>
			8.9.11 $| flush operator <URL:#tn=			8.9.11 $| flush operator>
		8.10 All oneliners <URL:#tn=		8.10 All oneliners>
		8.11 <URL:#tn=		8.11>
		8.12 <URL:#tn=		8.12>
		8.13 <URL:#tn=		8.13>
		8.14 <URL:#tn=		8.14>
		8.15 <URL:#tn=		8.15>
		8.16 <URL:#tn=		8.16>
		8.17 My examples <URL:#tn=		8.17 My examples>
			8.17.1  Block range of IP addresses <URL:#tn=			8.17.1  Block range of IP addresses>
			8.17.2 If pattern1 is found and after it pattern2 is found then print pattern2 + n consecutive lines <URL:#tn=			8.17.2 If pattern1 is found and after it pattern2 is found then print pattern2 + n consecutive lines>
3.97 gb  	 + 	 16.02 mb  	 = 	 3.98 gb  	 jsvc(4) <URL:#tn=3.97 gb  	 + 	 16.02 mb  	 = 	 3.98 gb  	 jsvc(4)>
1.19 gb  	 + 	 14.09 mb  	 = 	 1.21 gb  	 java(2) <URL:#tn=1.19 gb  	 + 	 14.09 mb  	 = 	 1.21 gb  	 java(2)>
773.51 mb  	 + 	 444.11 mb  	 = 	 1.18 gb  	 oracle(41) <URL:#tn=773.51 mb  	 + 	 444.11 mb  	 = 	 1.18 gb  	 oracle(41)>
45.79 mb  	 + 	 2.63 mb  	 = 	 48.43 mb  	 timestensubd(4) <URL:#tn=45.79 mb  	 + 	 2.63 mb  	 = 	 48.43 mb  	 timestensubd(4)>
35.49 mb  	 + 	 275.00 kb  	 = 	 35.76 mb  	 Decap_main <URL:#tn=35.49 mb  	 + 	 275.00 kb  	 = 	 35.76 mb  	 Decap_main>
27.97 mb  	 + 	 805.00 kb  	 = 	 28.76 mb  	 lwsmd <URL:#tn=27.97 mb  	 + 	 805.00 kb  	 = 	 28.76 mb  	 lwsmd>
12.21 mb  	 + 	 50.00 kb  	 = 	 12.26 mb  	 tnslsnr <URL:#tn=12.21 mb  	 + 	 50.00 kb  	 = 	 12.26 mb  	 tnslsnr>
3.97 gb  	 + 	 16.02 mb  	 = 	 3.98 gb  	 jsvc(4) <URL:#tn=3.97 gb  	 + 	 16.02 mb  	 = 	 3.98 gb  	 jsvc(4)>
1.19 gb  	 + 	 14.09 mb  	 = 	 1.21 gb  	 java(2) <URL:#tn=1.19 gb  	 + 	 14.09 mb  	 = 	 1.21 gb  	 java(2)>
771.46 mb  	 + 	 444.11 mb  	 = 	 1.18 gb  	 oracle(40) <URL:#tn=771.46 mb  	 + 	 444.11 mb  	 = 	 1.18 gb  	 oracle(40)>
45.81 mb  	 + 	 2.63 mb  	 = 	 48.45 mb  	 timestensubd(4) <URL:#tn=45.81 mb  	 + 	 2.63 mb  	 = 	 48.45 mb  	 timestensubd(4)>
35.49 mb  	 + 	 270.00 kb  	 = 	 35.75 mb  	 Decap_main <URL:#tn=35.49 mb  	 + 	 270.00 kb  	 = 	 35.75 mb  	 Decap_main>
27.97 mb  	 + 	 805.00 kb  	 = 	 28.76 mb  	 lwsmd <URL:#tn=27.97 mb  	 + 	 805.00 kb  	 = 	 28.76 mb  	 lwsmd>
12.21 mb  	 + 	 51.00 kb  	 = 	 12.26 mb  	 tnslsnr <URL:#tn=12.21 mb  	 + 	 51.00 kb  	 = 	 12.26 mb  	 tnslsnr>
3.97 gb  	 + 	 16.02 mb  	 = 	 3.98 gb  	 jsvc(4) <URL:#tn=3.97 gb  	 + 	 16.02 mb  	 = 	 3.98 gb  	 jsvc(4)>
1.17 gb  	 + 	 14.09 mb  	 = 	 1.19 gb  	 java(2) <URL:#tn=1.17 gb  	 + 	 14.09 mb  	 = 	 1.19 gb  	 java(2)>
773.75 mb  	 + 	 444.53 mb  	 = 	 1.18 gb  	 oracle(41) <URL:#tn=773.75 mb  	 + 	 444.53 mb  	 = 	 1.18 gb  	 oracle(41)>
45.83 mb  	 + 	 2.63 mb  	 = 	 48.47 mb  	 timestensubd(4) <URL:#tn=45.83 mb  	 + 	 2.63 mb  	 = 	 48.47 mb  	 timestensubd(4)>
35.49 mb  	 + 	 270.00 kb  	 = 	 35.75 mb  	 Decap_main <URL:#tn=35.49 mb  	 + 	 270.00 kb  	 = 	 35.75 mb  	 Decap_main>
34.91 mb  	 + 	 805.00 kb  	 = 	 35.70 mb  	 lwsmd <URL:#tn=34.91 mb  	 + 	 805.00 kb  	 = 	 35.70 mb  	 lwsmd>
12.21 mb  	 + 	 50.00 kb  	 = 	 12.26 mb  	 tnslsnr <URL:#tn=12.21 mb  	 + 	 50.00 kb  	 = 	 12.26 mb  	 tnslsnr>
3.97 gb  	 + 	 16.02 mb  	 = 	 3.98 gb  	 jsvc(4) <URL:#tn=3.97 gb  	 + 	 16.02 mb  	 = 	 3.98 gb  	 jsvc(4)>
1.17 gb  	 + 	 14.09 mb  	 = 	 1.19 gb  	 java(2) <URL:#tn=1.17 gb  	 + 	 14.09 mb  	 = 	 1.19 gb  	 java(2)>
769.21 mb  	 + 	 444.12 mb  	 = 	 1.18 gb  	 oracle(39) <URL:#tn=769.21 mb  	 + 	 444.12 mb  	 = 	 1.18 gb  	 oracle(39)>
45.85 mb  	 + 	 2.63 mb  	 = 	 48.49 mb  	 timestensubd(4) <URL:#tn=45.85 mb  	 + 	 2.63 mb  	 = 	 48.49 mb  	 timestensubd(4)>
35.49 mb  	 + 	 275.00 kb  	 = 	 35.76 mb  	 Decap_main <URL:#tn=35.49 mb  	 + 	 275.00 kb  	 = 	 35.76 mb  	 Decap_main>
34.91 mb  	 + 	 805.00 kb  	 = 	 35.70 mb  	 lwsmd <URL:#tn=34.91 mb  	 + 	 805.00 kb  	 = 	 35.70 mb  	 lwsmd>
12.21 mb  	 + 	 52.00 kb  	 = 	 12.26 mb  	 tnslsnr <URL:#tn=12.21 mb  	 + 	 52.00 kb  	 = 	 12.26 mb  	 tnslsnr>
		8.18 <URL:#tn=		8.18>
		8.19 My one liners  <URL:#tn=		8.19 My one liners >
			8.19.1 Delete line n, like sed -ie '1d' <URL:#tn=			8.19.1 Delete line n, like sed -ie '1d'>
		8.20 nslookup hostnames in text file <URL:#tn=		8.20 nslookup hostnames in text file>
		8.21 <URL:#tn=		8.21>
9.  FAQ, troubleshooting <URL:#tn=9.  FAQ, troubleshooting>
	9.1  system <URL:#tn=	9.1  system>
		9.1.1  sh: line 1: ... Permission denied <URL:#tn=		9.1.1  sh: line 1: ... Permission denied>
	9.2 Files <URL:#tn=	9.2 Files>
		9.2.1 Get file last modification time <URL:#tn=		9.2.1 Get file last modification time>
		9.2.2 <URL:#tn=		9.2.2>
	9.3 <URL:#tn=	9.3>
10. My scripts <URL:#tn=10. My scripts>
	10.1 Check that build process is not stuck <URL:#tn=	10.1 Check that build process is not stuck>
	10.2 tail -f emulate <URL:#tn=	10.2 tail -f emulate>
	10.3 <URL:#tn=	10.3>
11. <URL:#tn=11.>
.................................................END TOC..............................................















































1. Debug perl script
	perl -d <script>
		in debugger press h to get list of commands.

	Here is a summary:
List/search source lines:               Control script execution:
l [ln|sub]  List source code            T           Stack trace
- or .      List previous/current line  s [expr]    Single step [in expr]
v [line]    View around line            n [expr]    Next, steps over subs
f filename  View source in file         <CR/Enter>  Repeat last n or s
/pattern/ ?patt?   Search forw/backw    r           Return from subroutine
M           Show module versions        c [ln|sub]  Continue until position
Debugger controls:                        L           List break/watch/actions
o [...]     Set debugger options        t [expr]    Toggle trace [trace expr]
<[<]|{[{]|>[>] [cmd] Do pre/post-prompt b [ln|event|sub] [cnd] Set breakpoint
! [N|pat]   Redo a previous command     B ln|*      Delete a/all breakpoints
H [-num]    Display last num commands   a [ln] cmd  Do cmd before line
= [a val]   Define/list an alias        A ln|*      Delete a/all actions
h [db_cmd]  Get help on command         w expr      Add a watch expression
h h         Complete help page          W expr|*    Delete a/all watch exprs
|[|]db_cmd  Send output to pager        ![!] syscmd Run cmd in a subprocess
q or ^D     Quit                        R           Attempt a restart
Data Examination:     expr     Execute perl code, also see: s,n,t expr
x|m expr       Evals expr in list context, dumps the result or lists methods.
p expr         Print expression (uses script's current package).
S [[!]pat]     List subroutine names [not] matching pattern
V [Pk [Vars]]  List Variables in Package.  Vars can be ~pattern or !pattern.
X [Vars]       Same as "V current_package [Vars]".  i class inheritance tree.
y [n [Vars]]   List lexicals in higher scope <n>.  Vars same as V.
e     Display thread id     E Display all thread ids.

2. Learning Perl, 5th Edition
	2.1 Chapter 1. Introduction

Welcome to the Llama book!

This is the fifth edition of a book that has been enjoyed by half a million readers since 1993. At least, we hope they've enjoyed it. It's a sure thing that we've enjoyed writing it.[4]

    [4] To be sure, the first edition was written by Randal L. Schwartz, the second by Randal and Tom Christiansen, then one by Randal and Tom Phoenix, and now by Randal, Tom Phoenix, and brian d foy. So, whenever we say "we" in this edition, we mean that last group. Now, if you're wondering how we can say that we've enjoyed writing it (in the past tense) when we're still on the first page, that's easy: we started at the end, and worked our way backward. It sounds like a strange way to do it, we know. But, honestly, once we finished writing the index, the rest was hardly any trouble at al

		2.1.1 Questions and Answers

You probably have some questions about Perl, and maybe even some about this book, especially if you've already flipped through it to see what's coming. So, we'll use this chapter to answer them.

Is This the Right Book for You?

If you're anything like us, you're probably standing in a bookstore right now,[5] wondering whether you should get this Llama book and learn Perl, or maybe that book over there and learn some language named after a snake, or a beverage, or a letter of the alphabet.[6] You've got about two minutes before the bookstore manager comes over to tell you that this isn't a library,[||] and you need to buy something or get out. Maybe you want to use these two minutes to see a quick Perl program, so you'll know something about how powerful Perl is and what it can do. In that case, you should check out Section 1.5," later in this chapter.

    [5] Actually, if you're like us, you're standing in a library, not a bookstore. But we're tightwads.

    [6] Before you write to tell us that it's a comedy troupe, not a snake, we should really explain that we're dyslexically thinking of CORBA.

    [||] Unless it is.

    "

			2.1.1.1 Why Are There So Many Footnotes?

Thank you for noticing. There are a lot of footnotes in this book. Ignore them. They're needed because Perl is chock-full of exceptions to its rules. This is a good thing, as real life is chock-full of exceptions to rules.

But it means that we can't honestly say, "The fizzbin operator frobnicates the hoozistatic variables" without a footnote giving the exceptions.[*] We're pretty honest, so we have to write the footnotes. But you can be honest without reading them. (It's funny how that works out.)

    [*] Except on Tuesdays, during a power outage, when you hold your elbow at a funny angle during the equinox, or when use integer is in effect inside a loop block being called by a prototyped subroutine prior to Perl version 5.6.

Many of the exceptions have to do with portability. Perl began on Unix systems, and it still has deep roots in Unix. But wherever possible, we've tried to show when something may behave unexpectedly, whether that's because it's running on a non-Unix system, or for another reason. We hope that readers who know nothing about Unix will nevertheless find this book a good introduction to Perl. (And they'll learn a little about Unix along the way, at no extra charge.)

And many of the other exceptions have to do with the old "80/20" rule. By that we mean that 80% of the behavior of Perl can be described in 20% of the documentation, and the other 20% of the behavior takes up the other 80% of the documentation. So to keep this book small, we'll talk about the most common, easy-to-talk-about behavior in the main text, and hint in the direction of the other stuff in the footnotes (which are in a smaller font, so we can say more in the same space).[dagger] Once you've read the book all the way through without reading the footnotes, you'll probably want to look back at some sections for reference. At that point, or if you become unbearably curious along the way, go ahead and read the notes. A lot of them are just computer jokes anyway.

    [dagger] We even discussed doing the entire book as a footnote to save the page count, but footnotes on footnotes started to get a bit crazy.


			2.1.1.2 What About the Exercises and Their Answers?

The exercises are at the end of each chapter because, between the three of us, we've presented this same course material to several thousand students.[double dagger] We have carefully crafted these exercises to give you the chance to make mistakes as well.

    [double dagger] Not all at once.

It's not that we want you to make mistakes, but you need to have the chance. That's because you are going to make most of these mistakes during your Perl programming career, and it may as well be now. Any mistake that you make while reading this book you won't make again when you're writing a program on a deadline. And we're always here to help you out if something goes wrong, in the form of Appendix A, which has our answers for each exercise and a little text to go with it, explaining the mistakes you made and a few you didn't. Check out the answers when you're done with the exercises.

Try not to peek at the answer until you've given the problem a good try, though. You'll learn better if you figure it out rather than read about it. Don't knock your head repeatedly against the wall if you don't figure out a solution: move onto the next chapter and don't worry too much about it.

Even if you never make any mistakes, you should look at the answers when you're done; the accompanying text will point out some details of the program that might not be obvious at first.

If you want additional exercises, check out Learning Perl Student Workbook (O'Reilly), which adds several exercises for each chapter.


			2.1.1.3 What Do Those Numbers at the Start of the Exercise Mean?

Each exercise has a number in square brackets in front of the exercise text, looking something like this:

   |1.

      [2] What does the number 2 inside square brackets mean when it appears at the start of an exercise's text?

That number is our (very rough) estimate of how many minutes you can expect to spend on that particular exercise. It's rough, so don't be too surprised if you're all done (with writing, testing, and debugging) in half that time, or not done in twice that long. On the other hand, if you're really stuck, we won't tell anyone that you peeked at Appendix A to see what our answer looked like.


			2.1.1.4 What If I'm a Perl Course Instructor?

If you're a Perl instructor who has decided to use this as your textbook (as many have over the years), you should know that we've tried to make each set of exercises short enough that most students could do the whole set in 45 minutes to an hour, with a little time left over for a break. Some chapters' exercises should be quicker and some longer. That's because once we had written all of those little numbers in square brackets, we discovered that we don't know how to add (luckily we know how to make computers do it for us).

As we mentioned, we also have a companion book, Learning Perl Student Workbook, which has additional exercises for each chapter. If you get the version of the workbook for the fourth edition, you will have to adjust the chapter order because we added a chapter and moved another chapter in this edition.


		2.1.2 What Does "Perl" Stand For?

			2.1.2.1 What Does "Perl" Stand For?

Perl is sometimes called the "Practical Extraction and Report Language," although it has also been called a "Pathologically Eclectic Rubbish Lister," among other expansions. It's actually a backronym, not an acronym, since Larry WallPerl's creatorcame up with the name first and the expansion later. That's why "Perl" isn't in all caps. There's no point in arguing which expansion is correct: Larry endorses both.

You may also see "perl" with a lowercase p in some writing. In general, "Perl" with a capital P refers to the language and "perl" with a lowercase p refers to the actual interpreter that compiles and runs your programs.



			2.1.2.2 Why Did Larry Create Perl?

Larry created Perl in the mid-1980s when he was trying to produce some reports from a Usenet newslike hierarchy of files for a bug-reporting system, and awk ran out of steam. Larry, being the lazy programmer that he is,[*] decided to overkill the problem with a general-purpose tool that he could use in at least one other place. The result was Perl version zero.

    [*] We're not insulting Larry by saying he's lazy; laziness is a virtue. The wheelbarrow was invented by someone who was too lazy to carry things; writing was invented by someone who was too lazy to memorize; Perl was invented by someone who was too lazy to get the job done without inventing a whole new computer language.



			2.1.2.3 Why Didn't Larry Just Use Some Other Language?

There's no shortage of computer languages, is there? But, at the time, Larry didn't see anything that really met his needs. If one of the other languages of today had been available back then, perhaps Larry would have used one of those. He needed something with the quickness of coding available in shell or awk programming, and with some of the power of more advanced tools like grep, cut, sort, and sed,[dagger] without having to resort to a language like C.

    [dagger] Don't worry if you don't know what these are. All that matters is that they were the programs Larry had in his Unix toolbox, but they weren't up to the tasks at hand.

Perl tries to fill the gap between low-level programming (such as in C or C++ or assembly) and high-level programming (such as "shell" programming). Low-level programming is usually hard to write and ugly, but fast and unlimited; it's hard to beat the speed of a well-written low-level program on a given machine. And there's not much you can't do there. High-level programming, at the other extreme, tends to be slow, hard, ugly, and limited; there are many things you can't do at all with the shell or batch programming if there's no command on your system that provides the needed functionality. Perl is easy, nearly unlimited, mostly fast, and kind of ugly.

Let's take another look at those four claims we just made about Perl:

First, Perl is easy. As you'll see, though, this means it's easy to use. It's not especially easy to learn. If you drive a car, you spent many weeks or months learning how, and then it's easy to drive. When you've been programming Perl for about as many hours as it took you to learn to drive, Perl will be easy for you.

Perl is nearly unlimited. There are very few things you can't do with Perl. You wouldn't want to write a interrupt-microkernel-level device driver in Perl (even though that's been done), but most things that ordinary folks need most of the time are good tasks for Perl, from quick little one-off programs to major industrial-strength applications.

Perl is mostly fast. That's because nobody is developing Perl who doesn't also use itso we all want it to be fast. If someone wants to add a feature that would be really cool, but that would slow down other programs, Larry is almost certain to refuse the new feature until we find a way to make it quick enough.

Perl is kind of ugly. This is true. The symbol of Perl has become the camel, from the cover of the venerable Camel book (also known as Programming Perl by Larry Wall, Tom Christiansen, and Jon Orwant [O'Reilly]), a cousin of this Llama (and her sister, the Alpaca). Camels are kind of ugly, too. But they work hard, even in tough conditions. Camels are there to get the job done despite all difficulties, even when they look bad and smell worse and sometimes spit at you. Perl is a little like that.


			2.1.2.4 Is Perl Easy or Hard?

Perl is easy to use, but sometimes hard to learn. This is a generalization, of course. In designing Perl, Larry made many tradeoffs. When he's had the chance to make something easier for the programmer at the expense of being more difficult for the student, he's decided in the programmer's favor nearly every time. That's because you'll learn Perl only once, but you'll use it again and again.[*] Perl has any number of conveniences that let the programmer save time. For example, most functions will have a default; frequently, the default is the way that you'll want to use the function. So you'll see lines of Perl code like these:[dagger]

    [*] If you're going to use a programming language for only a few minutes each week or month, you'd prefer one that is easier to learn, since you'll have forgotten nearly all of it from one use to the next. Perl is for people who are programmers for at least 20 minutes per day, and probably most of that in Perl.

    [dagger] We won't explain it all here, but this example pulls some data from an input file or files in one format and writes some of it out in another format. All of its features are covered in this book.

while (<>) {
  chomp;
  print join("\t", (split /:/)[0, 2, 1, 5] ), "\n";
}


Written out in full, without using Perl's defaults and shortcuts, that snippet would be roughly 10 or 12 times longer, so it would take much longer to read and write. It would be harder to maintain and debug, too, with more variables. If you already know some Perl, and you don't see the variables in that code, that's part of the point. They're all being used by default. But to have this ease at the programmer's tasks means paying the price when you're learning; you have to learn those defaults and shortcuts.

A good analogy is the proper and frequent use of contractions in English. Sure, "will not" means the same as "won't." But most people say "won't" rather than "will not" because it saves time, and because everybody knows it and it makes sense. Similarly, Perl's "contractions" abbreviate common "phrases" so that they can be "spoken" quicker and understood by the maintainer as a single idiom, rather than a series of unrelated steps.

Once you become familiar with Perl, you may find yourself spending less time trying to get shell quoting (or C declarations) right, and more time surfing the Web because Perl is a great tool for leverage. Perl's concise constructs allow you to create (with minimal fuss) some very cool one-up solutions or general tools. Also, you can drag those tools along to your next job because Perl is highly portable and readily available, so you'll have even more time to surf.

Perl is a very high-level language. That means that the code is quite dense; a Perl program may be around a quarter to three-quarters as long as the corresponding program in C. This makes Perl faster to write, faster to read, faster to debug, and faster to maintain. It doesn't take much programming before you realize that, when the entire subroutine is small enough to fit onscreen all at once, you don't have to keep scrolling back and forth to see what's going on. Also, since the number of bugs in a program is roughly proportional to the length of the source code[*] (rather than being proportional to the program's functionality), the shorter source in Perl will mean fewer bugs on average.

    [*] With a sharp jump when any one section of the program exceeds the size of your screen.

Like any language, Perl can be "write-only"it's possible to write programs that are impossible to read. But with proper care, you can avoid this common accusation. Yes, sometimes Perl looks like line noise to the uninitiated, but to the seasoned Perl programmer, it looks like the notes of a grand symphony. If you follow the guidelines of this book, your programs should be easy to read and easy to maintain, and they probably won't win The Obfuscated Perl Contest.


			2.1.2.5 How Did Perl Get to Be So Popular?

After playing with Perl a bit, adding stuff here and there, Larry released it to the community of Usenet readers, commonly known as "the Net." The users on this ragtag fugitive fleet of systems around the world (tens of thousands of them) gave him feedback, asking for ways to do this, that, or the other thing, many of which Larry had never envisioned his little Perl handling.

But as a result, Perl grew, and grew, and grew. It grew in features. It grew in portability. What was once a little language available on only a couple of Unix systems now has thousands of pages of free online documentation, dozens of books, several mainstream Usenet newsgroups (and a dozen newsgroups and mailing lists outside the mainstream)with an uncountable number of readers, and implementations on nearly every system in use todayand don't forget this Llama book as well.


			2.1.2.6 What's Happening with Perl Now?

Larry Wall doesn't write the code these days, but he still guides the development and makes the big decisions. Perl is mostly maintained by a hardy group of people called the Perl 5 Porters. You can subscribe to their mailing list at perl5-porters@perl.org to follow their work and discussions.

As we write this (March 2008), there is a lot happening with Perl. For the past couple of years, many people have been working on the next major version of Perl: Perl 6.

Don't throw away your Perl 5, which is still the current and stable version. We don't expect a stable version of Perl 6 for a while yet. Perl 5 does everything it always did, and always will. Perl 5 won't disappear when Perl 6 shows up, and people may end up using both for several years. The Perl 5 Porters maintain Perl 5 just like they always have and some of the good ideas from Perl 6 have made it into Perl 5. We're updating this book because Perl 5.10 just came out, and it looks like the Perl 5 Porters are already working on Perl 5.12.

In 2000, Larry first proposed the next major release of Perl as the Perl community's rewrite of Perl. In the years that followed, a new interpreter called Parrot came to life, but not much else happened for the users. In 2005, Autrijus Tang started playing with Pugs (Perl User Golfing System) as a featherweight implementation of Perl 6 in Haskell. Developers from the Perl and Haskell sides of the world rushed to help. Parrot, the virtual machine that will run Perl 6, is coming along nicely now, and that's where most of the work is happening. You can see more about Perl 6 at http://perlsix.org and http://www.pugscode.org. For this book, we're not going to worry about Perl 6, though.


			2.1.2.7 What's Perl Really Good For?

Perl is good for quick-and-dirty programs that you whip up in three minutes. Perl is also good for long-and-extensive programs that will take a dozen programmers three years to finish. Of course, you'll probably find yourself writing many programs that take you less than an hour to complete, from the initial plan to the fully tested code.

Perl is optimized for problems that are about 90% working with text and about 10% everything else. That description seems to fit most programming tasks that pop up these days. In a perfect world, every programmer could know every language; you'd always be able to choose the best language for each project. Most of the time, you'd choose Perl.[*] Although the Web wasn't even a twinkle in Tim Berners-Lee's eye when Larry created Perl, it was a marriage made on the Net. Some claim that the deployment of Perl in the early 1990s permitted people to move lots of content into HTML format very rapidly, and the Web couldn't exist without content. Of course, Perl is the darling language for small CGI scripting (programs run by a web server) as wellso much so that many of the uninformed still make statements like "Isn't CGI just Perl?" or "Why would you use Perl other than for CGI?" We find those statements amusing.

    [*] Don't just take our word for it, though. If you want to know whether Perl is better than language X, learn them both and try them both, then see which one you use most often. That's the one that's best for you. In the end, you'll understand Perl better because of your study of language X, and vice versa, so it will be time well spent.



			2.1.2.8 What Is Perl Not Good For?

So, if it's good for so many things, what is Perl not good for? Well, you shouldn't choose Perl if you're trying to make an opaque binary. That's a program that you could give away or sell to someone who then can't see your secret algorithms in the source, and thus can't help you maintain or debug your code either. When you give someone your Perl program, you'll normally be giving them the source, not an opaque binary.

If you're wishing for an opaque binary, though, we have to tell you that they don't exist. If someone can install and run your program, they can turn it back into source code. Granted, this won't necessarily be the same source that you started with, but it will be some kind of source code. The real way to keep your secret algorithm a secret is, alas, to apply the proper number of attorneys; they can write a license that says, "You can do this with the code, but you can't do that. And if you break our rules, we've got the proper number of attorneys to ensure that you'll regret it."

		2.1.3 How Can I Get Perl?
You probably already have it. At least, we find Perl wherever we go. It ships with many systems, and system administrators often install it on every machine at their site. But if you can't find it already on your system, you can still get it for free.

Perl is distributed under two different licenses. For most people, because you'll merely be using it, either license is as good as the other. If you'll be modifying Perl, however, you'll want to read the licenses more closely because they put some small restrictions on distributing the modified code. For people who won't modify Perl, the licenses essentially say, "It's freehave fun with it."

In fact, it's not only free, but it runs rather nicely on nearly everything that calls itself Unix and has a C compiler. You download it, type a command or two, and it starts configuring and building itself. Or, better yet, you get your system administrator to type those two commands and install it for you.[*] Besides Unix and Unix-like systems, people have also been addicted enough to Perl to port it to other systems, such as Mac OS X, VMS, OS/2, even MS/DOS, and every modern species of Windowsand probably even more by the time you read this.[dagger] Many of these ports of Perl come with an installation program that's even easier to use than the process for installing Perl on Unix. Check for links in the "ports" section on CPAN.

    [*] If system administrators can't install software, what good are they? If you have trouble convincing your admin to install Perl, offer to buy a pizza. We've never met a sys admin who could say no to a free pizza, or at least counter-offer with something just as easy to get.

    [dagger] And no, as we write this, it won't fit in your Blackberryit's just too darn big, even stripped down. We've heard rumors that it runs on WinCE though.

			2.1.3.1 What Is CPAN?

CPAN is the Comprehensive Perl Archive Network, your one-stop shop for Perl. It has the source code for Perl itself, ready-to-install ports of Perl to all sorts of non-Unix systems,[double dagger] examples, documentation, extensions to Perl, and archives of messages about Perl. In short, CPAN is comprehensive.

    [double dagger] It's nearly always better to compile Perl from the source on Unix systems. Other systems may not have a C compiler and other tools needed for compilation, so CPAN has binaries for these.

CPAN is replicated on hundreds of mirror machines around the world; start at http://search.cpan.org/ or http://kobesearch.cpan.org/ to browse or search the archive. If you don't have access to the Net, you might find a CD-ROM or DVD-ROM with all of the useful parts of CPAN on it; check with your local technical bookstore. Look for a recently minted archive, though. Because CPAN changes daily, an archive from two years ago is an antique. Better yet, get a kind friend with Net access to burn you one with today's CPAN.

			2.1.3.2 How Can I Get Support for Perl?

Well, you get the complete sourceso you get to fix the bugs yourself!

That doesn't sound so good, does it? But it really is a good thing. Since there's no "source code escrow" on Perl, anyone can fix a bugin fact, by the time you've found and verified a bug, someone else probably already has a fix for it. There are thousands of people around the world who help maintain Perl.

Now, we're not saying that Perl has a lot of bugs. But it's a program, and every program has at least one bug. To see why it's so useful to have the source to Perl, imagine that instead of using Perl, you licensed a programming language called Forehead from a giant, powerful corporation owned by a zillionaire with a bad haircut. (This is all hypothetical. Everyone knows there's no such programming language as Forehead.) Now think of what you can do when you find a bug in Forehead. First, you can report it; second, you can hopehope that they fix the bug, hope that they fix it soon, hope that they won't charge too much for the new version. You can hope that the new version doesn't add new features with new bugs, and hope that the giant company doesn't get broken up in an antitrust lawsuit.

But with Perl, you've got the source. In the rare and unlikely event that you can't get a bug fixed any other way, you can hire a programmer or 10 and get to work. For that matter, if you buy a new machine that Perl doesn't yet run on, you can port it yourself. Or if you need a feature that doesn't yet exist, well, you know what to do.

			2.1.3.3 Are There Any Other Kinds of Support?

Sure. One of our favorites is the Perl Mongers. This is a worldwide association of Perl users' groups; see http://www.pm.org/ for more information. There's probably a group near you with an expert or someone who knows an expert. If there's no group, you can easily start one.

Of course, for the first line of support, you shouldn't neglect the documentation. Besides the manpages,[*] you can also find the documentation on the CPAN (http://www.cpan.org) as well as other sites, such as http://perldoc.perl.org, which has HTML and PDF versions of the Perl documentation, or http://faq.perl.org/, which has the latest version of the perlfaq.

    [*] The term manpages is a Unix-ism meaning documentation. If you're not on a Unix system, the manpages for Perl should be available via your system's native documentation system.

Another authoritative source is the book Programming Perl, commonly called "the Camel book" because of its cover animal (just as this book is known as "the Llama book"). The Camel book contains the complete reference information, some tutorial stuff, and a bunch of miscellaneous information about Perl. There's also a separate pocket-size Perl 5 Pocket Reference (O'Reilly) by Johan Vromans that's convenient to keep at hand (or in your pocket).

If you need to ask a question of someone, there are newsgroups on Usenet and any number of mailing lists.[dagger] At any hour of the day or night, there's a Perl expert awake in some time zone, answering questions on Usenet's Perl newsgroupsthe sun never sets on the Perl empire. This means that if you ask a question, you'll often get an answer within minutes. If you didn't check the documentation and FAQ first, you'll get flamed within minutes.

    [dagger] Many mailing lists are listed at http://lists.perl.org.

The official Perl newsgroups on Usenet are located in the comp.lang.perl.* part of the hierarchy. As of this writing, there are five of them, but they change from time to time. You (or whoever is in charge of Perl at your site) should generally subscribe to comp.lang.perl.announce, which is a low-volume newsgroup just for important announcements about Perl, including especially any security-related announcements. Ask your local expert if you need help with Usenet.

Also, a few web communities have sprung up around Perl discussions. One very popular one, Perl Monastery (http://www.perlmonks.org), has seen quite a bit of participation from many Perl book and column authors, including at least two of the authors of this book. You can also check out http://learn.perl.org/ and its associated mailing list, beginners@perl.org. For Perl news, try http://use.perl.org/. Many well-known Perl programmers also have blogs that regularly feature Perl-related posts, most of which you can read through http://planet.perl.org.

If you find yourself needing a support contract for Perl, there are a number of firms that are willing to charge as much as you'd like. In most cases, these other support avenues will take care of you for free.

			2.1.3.4 What If I Find a Bug in Perl?

The first thing to do when you find a bug is to check the documentation[*] again.[dagger] Perl has so many special features and exceptions to rules that you may have discovered a feature, not a bug. Also, check that you don't have an older version of Perl; maybe you found something that's been fixed in a more recent version.

    [*] Even Larry admits to consulting the documentation from time to time.

    [dagger] Maybe even two or three times. Many times, we've gone into the documentation looking to explain a particular unexpected behavior and found some new little nuance that ends up on a slide or in a column.

Once you're 99% certain that you've found a real bug, ask around. Ask someone at work, at your local Perl Mongers' meeting, or at a Perl conference. Chances are, it's still a feature, not a bug.

Once you're 100% certain that you've found a real bug, cook up a test case. (What, you haven't done so already?) The ideal test case is a tiny self-contained program that any Perl user could run to see the same (mis)behavior you've found. Once you've got a test case that clearly shows the bug, use the perlbug utility (which comes with Perl) to report the bug. That will normally send email from you to the Perl developers, so don't use perlbug until you've got your test case ready.

Once you've sent off your bug report, if you've done everything right, it's not unusual to get a response within minutes. Typically, you can apply a simple patch and get right back to work. Of course, you may (at worst) get no response at all; the Perl developers are under no obligation to even read your bug reports. But all of us love Perl, so nobody likes to let a bug escape our notice.

		2.1.4 How Do I Make a Perl Program?
It's about time you asked (even if you didn't). Perl programs are text files; you can create and edit them with your favorite text editor. (You don't need any special development environment, although there are some commercial ones available from various vendors. We've never used any of these enough to recommend them.)

You should generally use a programmers' text editor, rather than an ordinary editor. What's the difference? Well, a programmers' text editor will let you do things that programmers need, like indenting or unindenting a block of code, or finding the matching closing curly brace for a given opening curly brace. On Unix systems, the two most popular programmers' editors are emacs and vi (and their variants and clones). BBEdit and TextMate are good editors for Mac OS X, and a lot of people have said nice things about UltraEdit and PFE (Programmer's Favorite Editor) on Windows. The perlfaq2 manpage lists several other editors, too. Ask your local expert about text editors on your system.

For the simple programs you'll write for the exercises in this book, none of which should be more than about 20 or 30 lines of code, any text editor will be fine.

Some beginners try to use a word processor instead of a text editor. We recommend against thisit's inconvenient at best and impossible at worst. But we won't try to stop you. Be sure to tell the word processor to save your file as "text only"; the word processor's own format will almost certainly be unusable. Most word processors will probably also tell you that your Perl program is spelled incorrectly and should use fewer semicolons.

In some cases, you may need to compose the program on one machine, then transfer it to another to run it. If you do this, be sure that the transfer uses "text" or "ASCII" mode, and not "binary" mode. This step is needed because of the different text formats on different machines. Without it, you may get inconsistent resultssome versions of Perl actually abort when they detect a mismatch in the line endings.

			2.1.4.1 A Simple Program

According to the oldest rule in the book, any book about a computer language that has Unix-like roots has to start with showing the "Hello, world" program. So, here it is in Perl:

#!/usr/bin/perl
print "Hello, world!\n";


Let's imagine that you've typed that into your text editor. (Don't worry yet about what the parts mean and how they work. We'll see about those in a moment.) You can generally save that program under any name you wish. Perl doesn't require any special kind of filename or extension, and it's better not to use an extension at all.[*] But some systems may require an extension like .plx (meaning PerL eXecutable); see your system's release notes for more information.

    [*] Why is it better to have no extension? Imagine that you've written a program to calculate bowling scores and you've told all of your friends that it's called bowling.plx. One day you decide to rewrite it in C. Do you still call it by the same name, implying that it's still written in Perl? Or do you tell everyone that it has a new name? (And don't call it bowling.c, please!) The answer is that it's none of their business what language it's written in, if they're merely using it. So, it should have simply been called bowling in the first place.

You may also need to do something so that your system knows it's an executable program (that is, a command). What you'll do depends upon your system; maybe you won't have to do anything more than save the program in a certain place. (Your current directory will generally be fine.) On Unix systems, you mark a program as being executable using the chmod command, perhaps like this:

$ chmod a+x my_program


The dollar sign (and space) at the start of the line represents the shell prompt, which will probably look different on your system. If you're used to using chmod with a number like 755 instead of a symbolic parameter like a+x, that's fine too, of course. Either way, it tells the system that this file is now a program.

Now you're ready to run it:

$ ./my_program


The dot and slash at the start of this command mean to find the program in the current working directory. That's not needed in all cases, but you should use it at the start of each command invocation until you fully understand what it's doing.[dagger] If everything worked, it's a miracle. More often, you'll find that your program has a bug. Edit and try againbut you don't need to use chmod each time, as that should "stick" to the file. (Of course, if the bug is that you didn't use chmod correctly, you'll probably get a "permission denied" message from your shell.)

    [dagger] In short, it's preventing your shell from running another program (or shell built-in) of the same name. A common mistake among beginners is to name their first program test. Many systems already have a program (or shell built-in) with that name; that's what the beginners run instead of their program.

There's another way to write this simple program in Perl 5.10, and we might as well get that out of the way right now. Instead of print, we use say, which does almost the same thing, but with less typing. Since it's a new feature and you might not be using Perl 5.10 yet, we include a use 5.010 statement that tells Perl that we used new features:

#!/usr/bin/perl

use 5.010;

say "Hello World!";


This program only runs under Perl 5.10. When we introduce Perl 5.10 features in this book, we'll explicitly say they are new features in the text and include that use 5.010 statement to remind you. Perl actually thinks about the minor version as a three-digit number, so make sure that you say use 5.010 and not use 5.10 (which Perl thinks is 5.100, a version we definitely don't have yet!)

			2.1.4.2 What's Inside That Program?

Like other "free-form" languages, Perl generally lets you use insignificant whitespace (like spaces, tabs, and newlines) at will to make your program easier to read. Most Perl programs use a fairly standard format, though, much like most of what we show here. We strongly encourage you to properly indent your programs, as that makes your program easier to read; a good text editor will do most of the work for you. Good comments also make a program easier to read. In perl, comments run from a pound sign (#) to the end of the line. (There are no "block comments" in Perl.[*]) We don't use many comments in the programs in this book because the surrounding text explains their workings, but you should use comments as needed in your own programs.

    [*] But there are a number of ways to fake them. See the FAQ (accessible with perldoc perlfaq on most installations).

So another way (a very strange way, it must be said) to write that same "Hello, world" program might be like this:

#!/usr/bin/perl
    print    # This is a comment
"Hello, world!\n"
  ;    # Don't write your Perl code like this!


That first line is actually a very special comment. On Unix systems,[dagger] if the very first two characters on the first line of a text file are #!, what follows is the name of the program that actually executes the rest of the file. In this case, the program is stored in the file /usr/bin/perl.

    [dagger] Most modern ones, anyway. The "shebang" mechanism[28] was introduced somewhere in the mid-1980s, and that's pretty ancient, even on the extensively long Unix timeline.

    [28] pronounced "shebang," as in "the whole shebang"

This #! line is actually the least portable part of a Perl program because you'll need to find out what goes there for each machine. Fortunately, it's almost always either /usr/bin/perl or /usr/local/bin/perl. If that's not it, you'll have to find where your system is hiding perl, then use that path. On Unix systems, you might use a shebang line that finds perl for you:

#!/usr/bin/env perl


If perl is not in any of the directories in your search path, you might have to ask your local system administrator or somebody using the same system as you.

On non-Unix systems, it's traditional (and even useful) to make the first line say #!perl. If nothing else, it tells your maintenance programmer as soon as he gets ready to fix it that it's a Perl program.

If that #! line is wrong, you'll generally get an error from your shell. This may be something unexpected, like "file not found." It's not your program that's not found, though; it's /usr/bin/perl that wasn't where it should have been. We'd make the message clearer, but it's not coming from Perl; it's the shell that's complaining. (By the way, you should be careful to spell it usr and not userthe folks who invented Unix were lazy typists, so they omitted a lot of letters.)

Another problem you could have is that your system doesn't support the #! line at all. In that case, your shell (or whatever your system uses) will probably try to run your program all by itself, with results that may disappoint or astonish you. If you can't figure out what some strange error message is telling you, search for it in the perldiag manpage.

The "main" program consists of all of the ordinary Perl statements (not including anything in subroutines, which you'll see later). There's no "main" routine, as there is in languages like C or Java. In fact, many programs don't even have routines (in the form of subroutines).

There's also no required variable declaration section, as there is in some other languages. If you've always had to declare your variables, you may be startled or unsettled by this at first. But it allows us to write "quick-and-dirty" Perl programs. If your program is only two lines long, you don't want to have to use one of those lines just to declare your variables. If you really want to declare your variables, that's a good thing; you'll see how to do that in Chapter 4.

Most statements are an expression followed by a semicolon. Here's the one you've seen a few times so far:

print "Hello, world!\n";


As you may have guessed by now, this line prints the message Hello, world!. At the end of that message is the shortcut \n, which is probably familiar to you if you've used another language like C, C++, or Java; it means a newline character. When that's printed after the message, the print position drops down to the start of the next line, allowing the following shell prompt to appear on a line of its own, rather than being attached to the message. Every line of output should end with a newline character. We'll see more about the newline shortcut and other so-called backslash escapes in the next chapter.

			2.1.4.3 How Do I Compile Perl?

Just run your Perl program. The perl interpreter compiles and then runs your program in one user step:

$ perl my_program


When you run your program, Perl's internal compiler first runs through your entire source, turning it into internal bytecode, which is an internal data structure representing the program. Perl's bytecode engine takes over and actually runs the bytecode. If there's a syntax error on line 200, you'll get that error message before you start running line 2.[*] If you have a loop that runs 5000 times, it's compiled just once; the actual loop can then run at top speed. And there's no runtime penalty for using as many comments and as much whitespace as you need to make your program easy to understand. You can even use calculations involving only constants, and the result is a constant computed once as the program is beginningnot each time through a loop.

    [*] Unless line two happens to be a compile-time operation, like a BEGIN block or a use invocation.

To be sure, this compilation does take timeit's inefficient to have a voluminous Perl program that does one small quick task (out of many potential tasks, say) and then exits because the runtime for the program will be dwarfed by the compile time. But the compiler is very fast; normally the compilation will be a tiny percentage of the runtime.

An exception might be if you were writing a program run as a CGI script, where it may be called hundreds or thousands of times every minute. (This is a very high usage rate. If it were called a few hundred or thousand times per day, like most programs on the Web, we probably wouldn't worry too much about it.) Many of these programs have very short runtimes, so the issue of recompilation may become significant. If this is an issue for you, you'll want to find a way to keep your program in memory between invocations. The mod_perl extension to the Apache web server (http://perl.apache.org) or Perl modules like CGI::Fast can help you.

What if you could save the compiled bytecode to avoid the overhead of compilation? Or, even better, what if you could turn the bytecode into another language, like C, and then compile that? Well, both of these things are possible in some cases, but they probably won't make most programs any easier to use, maintain, debug, or install, and they may even make your program slower. Perl 6 should do a lot better in this regard, although it is too soon to tell (as we write this).

		2.1.5 A Whirlwind Tour of Perl
So, you want to see a real Perl program with some meat? (If you don't, just play along for now.) Here you are:

#!/usr/bin/perl
@lines = `perldoc -u -f atan2`;
foreach (@lines) {
  s/\w<([^>]+)>/\U$1/g;
  print;
}


Now, the first time you see Perl code like this, it can seem pretty strange. (In fact, every time you see Perl code like this, it can seem pretty strange.) But let's take it line by line, and see what this example does. (These explanations are very brief; this is a whirlwind tour, after all. We'll see all of this program's features in more detail during the rest of this book. You're not really supposed to understand the whole thing until later.)

The first line is the #! line, as you saw before. You might need to change that line for your system, as we discussed earlier.

The second line runs an external command, named within backquotes (` `). (The backquote key is often found next to the number 1 on full-sized American keyboards. Be sure not to confuse the backquote with the single quote, '.) The command we used is perldoc -u -f atan2; try typing that at your command line to see what its output looks like. The perldoc command is used on most systems to read and display the documentation for Perl and its associated extensions and utilities, so it should normally be available.[*] This command tells you something about the trigonometric function atan2; we're using it here just as an example of an external command whose output we wish to process.

    [*] If perldoc is not available, that probably means that your system doesn't have a command-line interface, and your Perl can't run commands (like perldoc) in backquotes or via the piped open, which you'll see in Chapter 16. In that case, you should simply skip the exercises that use perldoc.

The output of that command in the backquotes is saved in an array variable called @lines. The next line of code starts a loop that will process each one of those lines. Inside the loop, the statements are indented. Although Perl doesn't require this, good programmers do.

The first line inside the loop body is the scariest one; it says s/\w<([^>]+)>/\U$1/g;. Without going into too much detail, we'll just say that this can change any line that has a special marker made with angle brackets (< >), and there should be at least one of those in the output of the perldoc command.

The next line, in a surprise move, prints out each (possibly modified) line. The resulting output should be similar to what perldoc -u -f atan2 would do on its own, but there will be a change where any of those markers appear.

Thus, in the span of a few lines, we've run another program, saved its output in memory, updated the memory items, and printed them out. This kind of program is a fairly common use of Perl, where one type of data is converted to another.


		2.1.6 Exercises
		Normally, each chapter will end with some exercises, with the answers in Appendix A. But you don't need to write the programs needed to complete this sectionthose are supplied within the chapter text.

If you can't get these exercises to work on your machine, double-check your work and then consult your local expert. Remember that you may need to tweak each program a little, as described in the text.

			2.1.6.1 
      [7] Type in the "Hello, world" program and get it to work! (You may name it anything you wish, but a good name might be ex1-1, for simplicity, since it's exercise 1 in Chapter 1.)

			2.1.6.2 
      [5] Type the command perldoc -u -f atan2 at a command prompt and note its output. If you can't get that to work, find out from a local administrator or the documentation for your version of Perl about how to invoke perldoc or its equivalent. (You'll need this for the next exercise anyway.)

      [6] Type in the second example program (from the previous section) and see what it prints. (Hint: be careful to type those punctuation marks exactly as shown!) Do you see how it changed the output of the command?

	2.2 Scalar Data
	In English, as in many other spoken languages, you're used to distinguishing between singular and plural. As a computer language designed by a human linguist, Perl is similar. As a general rule, when Perl has just one of something, that's a scalar.[*] A scalar is the simplest kind of data that Perl manipulates. Most scalars are either a number (like 255 or 3.25e20) or a string of characters (like hello[dagger] or the Gettysburg Address). Although you may think of numbers and strings as very different things, Perl uses them nearly interchangeably.

    [*] This has little to do with the similar term from mathematics or physics in that a scalar is a single thing; there are no "vectors" in Perl.

    [dagger] If you have been using other programming languages, you may think of hello as a collection of five characters, rather than as a single thing. But in Perl, a string is a single scalar value. Of course, you can access the individual characters when you need to; you'll see how to do that in later chapters.

A scalar value can be acted upon with operators (like addition or concatenation), generally yielding a scalar result. A scalar value can be stored into a scalar variable. Scalars can be read from files and devices, and can be written out as well.

		2.2.1  Numbers
Although a scalar is most often either a number or a string, it's useful to look at numbers and strings separately for the moment. We'll cover numbers first, and then move on to strings.
			2.2.1.1. All Numbers Have the Same Format Internally

As you'll see in the next few paragraphs, you can specify both integers (whole numbers, like 255 or 2001) and floating-point numbers (real numbers with decimal points, like 3.14159, or 1.35 x 1025). But internally, Perl computes with double-precision floating-point values.[*] This means that there are no integer values internal to Perlan integer constant in the program is treated as the equivalent floating-point value.[dagger] You probably won't notice the conversion (or care much), but you should stop looking for distinct integer operations (as opposed to floating-point operations) because there aren't any. [double dagger]

    [*] A double-precision floating-point value is whatever the C compiler that compiled Perl used for a double declaration. While the size may vary from machine to machine, most modern systems use the IEEE-754 format, which suggests 15 digits of precision and a range of at least 1e-100 to 1e100.

    [dagger] Well, Perl will sometimes use internal integers in ways that are not visible to the programmer. That is, the only difference you should generally be able to see is that your program runs faster. And who could complain about that?

    [double dagger] Okay, there is the integer pragma. But using that is beyond the scope of this book. And yes, some operations compute an integer from a given floating-point number, as you'll see later. But that's not what we're talking about here.

			2.2.1.2. Floating-Point Literals

A literal is the way a value is represented in the source code of the Perl program. A literal is not the result of a calculation or an I/O operation; it's data written directly into the source code.

Perl's floating-point literals should look familiar to you. Numbers with and without decimal points are allowed (including an optional plus or minus prefix), as well as tacking on a power-of-10 indicator (exponential notation) with E notation. For example:

|1.25
|255.000
|255.0
|7.25e45  # 7.25 times 10 to the 45th power (a big number)
|-6.5e24  # negative 6.5 times 10 to the 24th
|         # (a big negative number)
|-12e-24  # negative 12 times 10 to the -24th
|         # (a very small negative number)
|-1.2E-23 # another way to say that - the E may be uppercase


			2.2.1.3. Integer Literals

Integer literals are also straightforward, as in:

|0
|2001
|-40
|255
|61298040283768


That last one is a little hard to read. Perl allows underscores for clarity within integer literals, so you can also write that number like this:

|61_298_040_283_768


It's the same value; it merely looks different to us human beings. You might have thought that commas should be used for this purpose, but commas are already used for a more-important purpose in Perl (as you'll see in the next chapter).
			2.2.1.4. Nondecimal Integer Literals

Like many other programming languages, Perl allows you to specify numbers in other than base 10 (decimal). Octal (base 8) literals start with a leading 0, hexadecimal (base 16) literals start with a leading 0x, and binary (base 2) literals start with a leading 0b.[*] The hex digits A through F (or a through f) represent the conventional digit values of 10 through 15. For example:

    [*] The "leading zero" indicator works only for literalsnot for automatic string-to-number conversions, which you'll see later in this chapter. You can convert a data string that looks like an octal or hex value into a number with oct( ) or hex( ). Although there's no bin function for converting binary values, oct( ) can do that for strings beginning with 0b.

|0377       # 377 octal, same as 255 decimal
|0xff       # FF hex, also 255 decimal
|0b11111111 # also 255 decimal


Although these values look different to us humans, they're all three the same number to Perl. It makes no difference to Perl whether you write 0xFF or 255.000, so choose the representation that makes the most sense to you and your maintenance programmer (by which we mean the poor chap who gets stuck trying to figure out what you meant when you wrote your code; most often, this poor chap is you, and you can't recall why you did what you did three months ago).

When a nondecimal literal is more than about four characters long, it may be hard to read. For this reason, Perl allows underscores for clarity within these literals:

|0x1377_0B77
|0x50_65_72_7C


			2.2.1.5. Numeric Operators

Perl provides the typical ordinary addition, subtraction, multiplication, and division operators, and so on. For example:

|2 + 3      # 2 plus 3, or 5
|5.1 - 2.4  # 5.1 minus 2.4, or 2.7
|3 * 12     # 3 times 12 = 36
|14 / 2     # 14 divided by 2, or 7
|10.2 / 0.3 # 10.2 divided by 0.3, or 34
|10 / 3     # always floating-point divide, so 3.3333333...


Perl also supports a modulus operator (%). The value of the expression 10 % 3 is the remainder when 10 is divided by 3, which is one. Both values are first reduced to their integer values, so 10.5 % 3.2 is computed as 10 % 3.[37] Additionally, Perl provides the FORTRAN-like exponentiation operator, which many have yearned for in Pascal and C. The operator is represented by the double asterisk, such as 2**3, which is two to the third power, or eight.[38] In addition, there are other numeric operators, which we'll introduce as we need them.

    [37] The result of a modulus operator when a negative number (or two) is involved can vary between Perl implementations. Beware.

    [38] You can't normally raise a negative number to a noninteger exponent. Math geeks know that the result would be a complex number. To make that possible, you'll need the help of the Math::Complex module.

		2.2.2 Strings
Strings are sequences of characters (like hello). Strings may contain any combination of any characters.[39] The shortest possible string has no characters. The longest string fills all of your available memory (although you wouldn't be able to do much with that). This is in accordance with the principle of "no built-in limits" that Perl follows at every opportunity. Typical strings are printable sequences of letters and digits and punctuation in the ASCII 32 to ASCII 126 range. However, the ability to have any character in a string means you can create, scan, and manipulate raw binary data as stringssomething with which many other utilities would have great difficulty. For example, you could update a graphical image or compiled program by reading it into a Perl string, making the change, and writing the result back out.

    [39] Unlike C or C++, there's nothing special about the NUL character in Perl because Perl uses length counting, not a null byte, to determine the end of the string.

Like numbers, strings have a literal representation, which is the way you represent the string in a Perl program. Literal strings come in two different flavors: single-quoted string literals and double-quoted string literals.
			2.2.2.1. Single-Quoted String Literals

A single-quoted string literal is a sequence of characters enclosed in single quotes. The single quotes are not part of the string itselfthey're just there to let Perl identify the beginning and the ending of the string. Any character other than a single quote or a backslash between the quote marks (including newline characters, if the string continues onto successive lines) stands for itself inside a string. To get a backslash, put two backslashes in a row, and to get a single quote, put a backslash followed by a single quote. In other words:

'fred'    # those four characters: f, r, e, and d
'barney'  # those six characters
''        # the null string (no characters)
'Don\'t let an apostrophe end this string prematurely!'
'the last character of this string is a backslash: \\'
'hello\n' # hello followed by backslash followed by n
'hello
there'    # hello, newline, there (11 characters total)
'\'\\'    # single quote followed by backslash


Note that the \n within a single-quoted string is not interpreted as a newline, but as the two characters backslash and n. Only when the backslash is followed by another backslash or a single quote does it have special meaning.
			2.2.2.2. Double-Quoted String Literals

A double-quoted string literal is similar to the strings you may have seen in other languages. Once again, it's a sequence of characters, although this time enclosed in double quotes. But now the backslash takes on its full power to specify certain control characters, or even any character at all through octal and hex representations. Here are some double-quoted strings:

"barney"        # just the same as 'barney'
"hello world\n" # hello world, and a newline
"The last character of this string is a quote mark: \""
"coke\tsprite"  # coke, a tab, and sprite


Note that the double-quoted literal string "barney" means the same six-character string to Perl as does the single-quoted literal string 'barney'. It's like what you saw with numeric literals, where you saw that 0377 was another way to write 255.0. Perl lets you write the literal in the way that makes more sense to you. Of course, if you wish to use a backslash escape (like \n to mean a newline character), you'll need to use the double quotes.

The backslash can precede many different characters to mean different things (generally called a backslash escape). The nearly complete[*] list of double-quoted string escapes is given in Table 2-1.

    [*] Recent versions of Perl have introduced "Unicode" escapes, which we aren't going to show you here.

Table 2-1. Double-quoted string backslash escapes
Construct	Meaning
\n	Newline
\r	Return
\t	Tab
\f	Form-feed
\b	Backspace
\a	Bell
\e	Escape (ASCII escape character)
\007	Any octal ASCII value (here, 007 = bell)
\x7f	Any hex ASCII value (here, 7f = delete)
\cC	A "control" character (here, Control-C)
\\	Backslash
\"	Double quote
\l	Lowercase next letter
\L	Lowercase all following letters until \E
\u	Uppercase next letter
\U	Uppercase all following letters until \E
\Q	Quote nonword characters by adding a backslash until \E
\E	End \L, \U, or \Q

Another feature of double-quoted strings is that they are variable interpolated, meaning that some variable names within the string are replaced with their current values when the strings are used. You haven't formally been introduced to what a variable looks like yet, so we'll get back to that later in this chapter.
			2.2.2.3. String Operators

String values can be concatenated with the . operator. (Yes, that's a single period.) This does not alter either string, any more than 2+3 alters either 2 or 3. The resulting (longer) string is then available for further computation or assignment to a variable. For example:

"hello" . "world"       # same as "helloworld"
"hello" . ' ' . "world" # same as 'hello world'
'hello world' . "\n"    # same as "hello world\n"


Note that the concatenation must be explicitly requested with the . operator, unlike in some other languages where you merely have to stick the two values next to each other.

A special string operator is the string repetition operator, consisting of the single lowercase letter x. This operator takes its left operand (a string) and makes as many concatenated copies of that string as indicated by its right operand (a number). For example:

"fred" x 3       # is "fredfredfred"
"barney" x (4+1) # is "barney" x 5, or "barneybarneybarneybarneybarney"
5 x 4            # is really "5" x 4, which is "5555"


That last example is worth spelling out slowly. The string repetition operator wants a string for a left operand, so the number 5 is converted to the string "5" (using rules described in detail later), giving a one-character string. This new string is then copied four times, yielding the four-character string 5555. Note that if you had reversed the order of the operands, as 4 x 5, you would have made five copies of the string 4, yielding 44444. This shows that string repetition is not commutative.

The copy count (the right operand) is first truncated to an integer value (4.8 becomes 4) before being used. A copy count of less than one results in an empty (zero-length) string.
			2.2.2.4. Automatic Conversion Between Numbers and Strings

For the most part, Perl automatically converts between numbers and strings as needed. How does it know which is needed? It all depends upon the operator being used on the scalar value. If an operator expects a number (like + does), Perl will see the value as a number. If an operator expects a string (like . does), Perl will see the value as a string. So you don't need to worry about the difference between numbers and strings; just use the proper operators, and Perl will make it all work.

When a string value is used where an operator needs a number (say, for multiplication), Perl automatically converts the string to its equivalent numeric value, as if it had been entered as a decimal floating-point value.[*] So "12" * "3" gives the value 36. Trailing nonnumber stuff and leading whitespace are discarded, so "12fred34" * " 3" will also give 36 without any complaints.[dagger] At the extreme end of this, something that isn't a number at all converts to zero. This would happen if you used the string "fred" as a number.

    [*] The trick of using a leading zero to mean a nondecimal value works for literals, but never for automatic conversion. Use hex( ) or oct( ) to convert those kinds of strings.

    [dagger] Unless you request warnings, which we'll discuss in a moment.

Likewise, if a numeric value is given when a string value is needed (say, for string concatenation), the numeric value is expanded into whatever string would have been printed for that number. For example, if you want to concatenate the string Z followed by the result of 5 multiplied by 7,[double dagger] you can say this simply as:

    [double dagger] You'll see about precedence and parentheses shortly.

"Z" . 5 * 7 # same as "Z" . 35, or "Z35"


In other words, you don't really have to worry about whether you have a number or a string (most of the time). Perl performs all the conversions for you.[||]

    [||] And if you're worried about efficiency, don't be. Perl generally remembers the result of a conversion so that it's done only once.


		2.2.3  Perl's Built-in Warnings
Perl can be told to warn you when it sees something suspicious going on in your program. To run your program with warnings turned on, use the -w option on the command line:

$ perl -w my_program


Or, if you always want warnings, you may request them on the #! line:

#!/usr/bin/perl -w


That works even on non-Unix systems, where it's traditional to write something like this, since the path to Perl doesn't generally matter:

#!perl -w


With Perl 5.6 and later, you can turn on warnings with a pragma (but be careful because it won't work for people with earlier versions of Perl):[*]

    [*] The warnings pragma actually allows lexical warnings, but you'll have to see the perllexwarn manpage to find out about those.

#!/usr/bin/perl
use warnings;


Now, Perl will warn you if you use '12fred34' as if it were a number:

Argument "12fred34" isn't numeric


Of course, warnings are generally meant for programmers, not for end users. If the warning won't be seen by a programmer, it probably won't do any good. And warnings won't change the behavior of your program, except that now it will emit gripes once in a while. If you get a warning message you don't understand, you can get a longer description of the problem with the diagnostics pragma. The perldiag manpage has both the short warning and the longer diagnostic description:

#!/usr/bin/perl
use diagnostics;


When you add the use diagnostics pragma to your program, it may seem to you that your program now pauses for a moment whenever you launch it. That's because your program has to do a lot of work (and a chunk of memory to gobble) just in case you want to read the documentation as soon as Perl notices your mistakes, if any. This leads to a nifty optimization that can speed up your program's launch (and memory footprint) with no adverse impact on users; once you no longer need to read the documentation about the warning messages produced by your program, remove the use diagnostics pragma. (It's even better if you fix your program to avoid causing the warnings. But it's sufficient merely to finish reading the output.)

A further optimization can be had by using one of Perl's command-line options, -M, to load the pragma only when needed instead of editing the source code each time to enable and disable diagnostics:
Code View: Scroll / Show All

$ perl -Mdiagnostics ./my_program
Argument "12fred34" isn't numeric in addition (+) at ./my_program line 17 (#1)
    (W numeric) The indicated string was fed as an argument to
    an operator that expected a numeric value instead.  If you're
    fortunate the message will identify which operator was so unfortunate.

					  


As we run across situations in which Perl will usually be able to warn us about a mistake in your code, we'll point them out. But you shouldn't count on the text or behavior of any warning staying exactly the same in future Perl releases.

		2.2.4  Scalar Variables
A variable is a name for a container that holds one or more values.[*] The name of the variable stays the same throughout the program, but the value or values contained in that variable typically change over and over again throughout the execution of the program.

    [*] As you'll see, a scalar variable can hold only one value. But other types of variables, such as arrays and hashes, may hold many values.

A scalar variable holds a single scalar value, as you'd expect. Scalar variable names begin with a dollar sign followed by what we'll call a Perl identifier: a letter or underscore, and then possibly more letters, or digits, or underscores. Another way to think of it is that it's made up of alphanumerics and underscores, but can't start with a digit. Upper- and lowercase letters are distinct: the variable $Fred is a different variable from $fred. And all of the letters, digits, and underscores are significant, so:

$a_very_long_variable_that_ends_in_1


is different from:

$a_very_long_variable_that_ends_in_2


Scalar variables in Perl are always referenced with the leading $.[dagger] In the shell, you use $ to get the value, but leave the $ off to assign a new value. In awk or C, you leave the $ off entirely. If you bounce back and forth a lot, you'll find yourself typing the wrong things occasionally. This is expected. (Most Perl programmers would recommend that you stop writing shell, awk, and C programs, but that may not work for you.)

    [dagger] This is called a "sigil" in Perlspeak.

			2.2.4.1. Choosing Good Variable Names

You should generally select variable names that mean something regarding the purpose of the variable. For example, $r is probably not very descriptive but $line_length is. A variable used for only two or three lines close together may be called something simple, like $n, but a variable used throughout a program should probably have a more descriptive name.

Similarly, properly placed underscores can make a name easier to read and understand, especially if your maintenance programmer has a different spoken language background than you have. For example, $super_bowl is a better name than $superbowl, since that last one might look like $superb_owl. Does $stopid mean $sto_pid (storing a process ID of some kind?) or $s_to_pid (converting something to a process ID?) or $stop_id (the ID for some kind of "stop" object?) or is it just a stopid misspelling?

Most variable names in our Perl programs are all lowercase, like most of the ones you'll see in this book. In a few special cases, uppercase letters are used. Using all caps (like $ARGV) generally indicates that there's something special about that variable. When a variable's name has more than one word, some say $underscores_are_cool, while others say $giveMeInitialCaps. Just be consistent.

Of course, choosing good or poor names makes no difference to Perl. You could name your program's three most-important variables $OOO000OOO, $OO00OO00, and $O0O0O0O0O and Perl wouldn't be botheredbut in that case, please, don't ask us to maintain your code.
			2.2.4.2. Scalar Assignment

The most common operation on a scalar variable is assignment, which is the way to give a value to a variable. The Perl assignment operator is the equals sign (much like other languages), which takes a variable name on the left side, and gives it the value of the expression on the right. For example:
Code View: Scroll / Show All

$fred   = 17;          # give $fred the value of 17
$barney = 'hello';     # give $barney the five-character string 'hello'
$barney = $fred + 3;   # give $barney the current value of $fred plus 3 (20)
$barney = $barney * 2; # $barney is now $barney multiplied by 2 (40)

					  


Notice that last line uses the $barney variable twice: once to get its value (on the right side of the equals sign), and once to define where to put the computed expression (on the left side of the equals sign). This is legal, safe, and rather common. In fact, it's so common that you can write it using a convenient shorthand, as you'll see in the next section.
			2.2.4.3. Binary Assignment Operators

Expressions like $fred = $fred + 5 (where the same variable appears on both sides of an assignment) occur frequently enough that Perl (like C and Java) has a shorthand for the operation of altering a variablethe binary assignment operator. Nearly all binary operators that compute a value have a corresponding binary assignment form with an appended equals sign. For example, the following two lines are equivalent:

$fred  = $fred + 5; # without the binary assignment operator
$fred += 5;         # with the binary assignment operator


These are also equivalent:

$barney  = $barney * 3;
$barney *= 3;


In each case, the operator alters the existing value of the variable in some way, rather than simply overwriting the value with the result of some new expression.

Another common assignment operator is made with the string concatenate operator ( . ); this gives us an append operator ( .= ):

$str  = $str . " "; # append a space to $str
$str .= " ";        # same thing with assignment operator


Nearly all binary operators are valid this way. For example, a raise to the power of operator is written as **=. So, $fred **= 3 means "raise the number in $fred to the third power, placing the result back in $fred."

		2.2.5  Output with print
It's generally a good idea to have your program produce some output; otherwise, someone may think it didn't do anything. The print( ) operator makes that possible: it takes a scalar argument and puts it out without any embellishment onto standard output. Unless you've done something odd, this will be your terminal display. For example:

print "hello world\n"; # say hello world, followed by a newline

print "The answer is ";
print 6 * 7;
print ".\n";


You can give print a series of values, separated by commas:

print "The answer is ", 6 * 7, ".\n";


This is really a list, but we haven't talked about lists yet, so we'll put that off for later.
			2.2.5.1. Interpolation of Scalar Variables into Strings

When a string literal is double-quoted, it is subject to variable interpolation[*] (besides being checked for backslash escapes). This means that any scalar variable[dagger] name in the string is replaced with its current value. For example:

    [*] This has nothing to do with mathematical or statistical interpolation.

    [dagger] And some other variable types, but you won't see those until later.

$meal   = "brontosaurus steak";
$barney = "fred ate a $meal";    # $barney is now "fred ate a brontosaurus steak"
$barney = 'fred ate a ' . $meal; # another way to write that

					  


As you see on the last line above, you can get the same results without the double quotes, but the double-quoted string is often the more convenient way to write it.

If the scalar variable has never been given a value,[*] the empty string is used instead:

    [*] This is actually the special undefined value, undef, which you'll see a little later in this chapter. If warnings are turned on, Perl will complain about interpolating the undefined value.

$barney = "fred ate a $meat"; # $barney is now "fred ate a "


Don't bother with interpolating if you have just the one lone variable:

print "$fred"; # unneeded quote marks
print $fred;   # better style


There's nothing really wrong with putting quote marks around a lone variable, but the other programmers will laugh at you behind your back.[dagger] Variable interpolation is also known as double-quote interpolation because it happens when double-quote marks (but not single quotes) are used. It happens for some other strings in Perl, which we'll mention as we get to them.

    [dagger] Well, it may interpret the value as a string, rather than a number. In a few rare cases that may be needed, but nearly always it's just a waste of typing.

To put a real dollar sign into a double-quoted string, precede the dollar sign with a backslash, which turns off the dollar sign's special significance:

$fred = 'hello';
print "The name is \$fred.\n";    # prints a dollar sign
print 'The name is $fred' . "\n"; # so does this


The variable name will be the longest possible variable name that makes sense at that part of the string. This can be a problem if you want to follow the replaced value immediately with some constant text that begins with a letter, digit, or underscore.[double dagger] As Perl scans for variable names, it would consider those characters as additional name characters, which is not what you want. Perl provides a delimiter for the variable name in a manner similar to the shell. Simply enclose the name of the variable in a pair of curly braces. Or, you can end that part of the string and start another part of the string with a concatenation operator:

    [double dagger] There are some other characters that may be a problem as well. If you need a left square bracket or a left curly brace just after a scalar variable's name, precede it with a backslash. You may also do that if the variable's name is followed by an apostrophe or a pair of colons, or you could use the curly-brace method described in the main text.


$what = "brontosaurus steak";
$n = 3;
print "fred ate $n $whats.\n";          # not the steaks, but the value of $whats
print "fred ate $n ${what}s.\n";        # now uses $what
print "fred ate $n $what" . "s.\n";     # another way to do it
print 'fred ate ' . $n . ' ' . $what . "s.\n"; # an especially difficult way

					  


			2.2.5.2. Operator Precedence and Associativity

Operator precedence determines which operations in a complex group of operations happen first. For example, in the expression 2+3*4, do you perform the addition first or the multiplication first? If you did the addition first, you'd get 5*4, or 20. But if you did the multiplication first (as you were taught in math class), you'd get 2+12, or 14. Fortunately, Perl chooses the common mathematical definition, performing the multiplication first. Because of this, you say multiplication has a higher precedence than addition.

You can override the default precedence order by using parentheses. Anything in parentheses is completely computed before the operator outside of the parentheses is applied (just like you learned in math class). So if you really want the addition before the multiplication, you can say (2+3)*4, yielding 20. Also, if you wanted to demonstrate that multiplication is performed before addition, you could add a decorative but unnecessary set of parentheses, as in 2+(3*4).

While precedence is simple for addition and multiplication, you start running into problems when faced with, say, string concatenation compared with exponentiation. The proper way to resolve this is to consult the official, accept-no-substitutes Perl operator precedence chart, shown in Table 2-2.[*] (Note that some of the operators have not yet been described, and in fact, may not even appear anywhere in this book, but don't let that scare you from reading about them in the perlop manpage.)

    [*] C programmers: Rejoice! The operators that are available in both Perl and C have the same precedence and associativity in both.

Table 2-2. Associativity and precedence of operators (highest to lowest)
Associativity	Operators
left	parentheses and arguments to list operators
left	->
 	++ -- (autoincrement and autodecrement)
right	**
right	\ ! ~ + - (unary operators)
left	=~ !~
left	* / % x
left	+ - . (binary operators)
left	<< >>
 	named unary operators (-X filetests, rand)
 	< <= > >= lt le gt ge (the "unequal" ones)
 	== != <=> eq ne cmp (the "equal" ones)
left	&
left	| ^
left	&&
left	||
 	.. ...
right	?: (ternary)
right	= += -= .= (and similar assignment operators)
left	, =>
 	list operators (rightward)
right	not
left	and
left	or xor

In the chart, any given operator has higher precedence than all of the operators listed below it, and lower precedence than all of the operators listed above it. Operators at the same precedence level resolve according to rules of associativity instead.

Just like precedence, associativity resolves the order of operations when two operators of the same precedence compete for three operands:

4 ** 3 ** 2 # 4 ** (3 ** 2), or 4 ** 9 (right associative)
72 / 12 / 3 # (72 / 12) / 3, or 6/3, or 2 (left associative)
36 / 6 * 3  # (36/6)*3, or 18


In the first case, the ** operator has right associativity, so the parentheses are implied on the right. Comparatively, the * and / operators have left associativity, yielding a set of implied parentheses on the left.

So should you just memorize the precedence chart? No! Nobody actually does that. Instead, just use parentheses when you don't remember the order of operations, or when you're too busy to look in the chart. After all, if you can't remember it without the parentheses, your maintenance programmer is going to have the same trouble. So be nice to your maintenance programmer: you may be that person one day.
			2.2.5.3. Comparison Operators

For comparing numbers, Perl has the logical comparison operators that remind you of algebra: < <= == >= > !=. Each of these returns a true or false value. You'll find out more about those return values in the next section. Some of these may be different than you'd use in other languages. For example, == is used for equality, not a single = sign because that's used for assignment. And != is used for inequality testing because <> is used for another purpose in Perl. And you'll need >= and not => for "greater than or equal to" because the latter is used for another purpose in Perl. In fact, nearly every sequence of punctuation is used for something in Perl. So, if you get writer's block, just let the cat walk across the keyboard, and debug what results.

For comparing strings, Perl has an equivalent set of string comparison operators, which look like funny little words: lt le eq ge gt ne. These compare two strings character by character to see whether they're the same, or whether one comes first in standard string sorting order. (In ASCII, the capital letters come before the lowercase letters, so beware.)

The comparison operators (for both numbers and strings) are given in Table 2-3.

Table 2-3. Numeric and string comparison operators
Comparison			Numeric	String
Equal				== 	eq
Not equal			!= 	ne
Less than			< 	lt
Greater than			> 	gt
Less than or equal to		<= 	le
Greater than or equal to	>= 	ge

Here are some example expressions using these comparison operators:

35 != 30 + 5         # false
35 == 35.0           # true
'35' eq '35.0'       # false (comparing as strings)
'fred' lt 'barney'   # false
'fred' lt 'free'     # true
'fred' eq "fred"     # true
'fred' eq 'Fred'     # false
' ' gt ''            # true

		2.2.6  The if Control Structure
Once you can compare two values, you'll probably want your program to make decisions based upon that comparison. Like all similar languages, Perl has an if control structure:

if ($name gt 'fred') {
  print "'$name' comes after 'fred' in sorted order.\n";
}


If you need an alternative choice, the else keyword provides that as well:

if ($name gt 'fred') {
  print "'$name' comes after 'fred' in sorted order.\n";
} else {
  print "'$name' does not come after 'fred'.\n";
  print "Maybe it's the same string, in fact.\n";
}


Those block curly braces are required around the conditional code (unlike C, whether you know C or not). It's a good idea to indent the contents of the blocks of code as we show here; that makes it easier to see what's going on. If you're using a programmers' text editor (as discussed in Chapter 1), it'll do most of the work for you.
			2.2.6.1. Boolean Values

You may actually use any scalar value as the conditional of the if control structure. That's handy if you want to store a true or false value into a variable, like this:

$is_bigger = $name gt 'fred';
if ($is_bigger) { ... }


But how does Perl decide whether a given value is true or false? Perl doesn't have a separate Boolean data type, like some languages have. Instead, it uses a few simple rules:[*]

    [*] These aren't the rules that Perl uses, of course. These are some rules that you can use to get essentially the same result, though.

    * If the value is a number, 0 means false; all other numbers mean true.
    * Otherwise, if the value is a string, the empty string ('') means false; all other strings mean true.
    * Otherwise (that is, if the value is another kind of scalar than a number or a string), convert it to a number or a string and try again.[dagger]

          [dagger] This means that undef (which we'll see soon) means false, while all references (which are covered in the Alpaca book) are true.

There's one trick hidden in those rules. Because the string '0' is the exact same scalar value as the number 0, Perl has to treat them both the same. That means that the string '0' is the only nonempty string that is false.

If you need to get the opposite of any Boolean value, use the unary not operator, !. If what follows it is a true value, it returns false; if what follows is false, it returns true:

if (! $is_bigger) {
  # Do something when $is_bigger is not true
}

		2.2.7  Getting User Input
At this point, you're probably wondering how to get a value from the keyboard into a Perl program. Here's the simplest way: use the line-input operator, <STDIN>.[double dagger]

    [double dagger] This is actually a line-input operator working on the filehandle STDIN, but we can't tell you about that until we get to filehandles (in Chapter 5).

Each time you use <STDIN> in a place where a scalar value is expected, Perl reads the next complete text line from standard input (up to the first newline), and uses that string as the value of <STDIN>. Standard input can mean many things, but unless you do something uncommon, it means the keyboard of the user who invoked your program (probably you). If there's nothing waiting for <STDIN> to read (typically the case, unless you type ahead a complete line), the Perl program will stop and wait for you to enter some characters followed by a newline (return).[*]

    [*] To be honest, it's normally your system that waits for the input; Perl waits for your system. Although the details depend upon your system and its configuration, you can generally correct your mistyping with the backspace key before you press Returnyour system handles that, not Perl itself. If you need more control over the input, get the Term::ReadLine module from CPAN.

The string value of <STDIN> typically has a newline character on the end of it,[dagger] so you could do something like this:

    [dagger] The exception is if the standard input stream somehow runs out in the middle of a line. But that's not a proper text file, of course!

$line = <STDIN>;
if ($line eq "\n") {
  print "That was just a blank line!\n";
} else {
  print "That line of input was: $line";
}


But in practice, you don't often want to keep the newline, so you need the chomp operator.

		2.2.8  The chomp Operator
The first time you read about the chomp operator, it seems terribly overspecialized. It works on a variable. The variable has to hold a string. And if the string ends in a newline character, chomp can get rid of the newline. That's (nearly) all it does. For example:

$text = "a line of text\n"; # Or the same thing from <STDIN>
chomp($text);               # Gets rid of the newline character


But it turns out to be so useful, you'll put it into nearly every program you write. As you see, it's the best way to remove a trailing newline from a string in a variable. In fact, there's an easier way to use chomp because of a simple rule: any time that you need a variable in Perl, you can use an assignment instead. First, Perl does the assignment. Then it uses the variable in whatever way you requested. So the most common use of chomp looks like this:

chomp($text = <STDIN>); # Read the text, without the newline character

$text = <STDIN>;        # Do the same thing...
chomp($text);           # ...but in two steps


At first glance, the combined chomp may not seem to be the easy way, especially if it seems more complex! If you think of it as two operationsread a line, then chomp itthen it's more natural to write it as two statements. But if you think of it as one operationread just the text, not the newlineit's more natural to write the one statement. And since most other Perl programmers are going to write it that way, you may as well get used to it now.

chomp is actually a function. As a function, it has a return value, which is the number of characters removed. This number is hardly ever useful:

$food = <STDIN>;
$betty = chomp $food; # gets the value 1 - but you knew that!


As you see, you may write chomp with or without the parentheses. This is another general rule in Perl: except in cases where it changes the meaning to remove them, parentheses are always optional.

If a line ends with two or more newlines,[*] chomp removes only one. If there's no newline, it does nothing, and returns zero.

    [*] This situation can't arise if you're reading a line at a time, but it certainly can when you have set the input separator ($/) to something other than newline, or used the read function, or perhaps have glued some strings together yourself.

		2.2.9  The while Control Structure
Like most algorithmic programming languages, Perl has a number of looping structures.[dagger] The while loop repeats a block of code as long as a condition is true:

    [dagger] Every programmer eventually creates an infinite loop by accident. If your program keeps running and running, though, you can generally stop it in the same way you'd stop any other program on your system. Often, typing Control-C will stop a runaway program; check with your system's documentation to be sure.

$count = 0;
while ($count < 10) {
  $count += 2;
  print "count is now $count\n"; # Gives values 2 4 6 8 10
}


As always in Perl, the truth value here works like the truth value in the if test. Also like the if control structure, the block curly braces are required. The conditional expression is evaluated before the first iteration, so the loop may be skipped completely if the condition is initially false.

		2.2.10 The undef Value
What happens if you use a scalar variable before you give it a value? Nothing serious, and definitely nothing fatal. Variables have the special undef value before they are first assigned, which is just Perl's way of saying, "Nothing here to look atmove along, move along." If you try to use this "nothing" as a "numeric something," it acts like zero. If you try to use it as a "string something," it acts like the empty string. But undef is neither a number nor a string; it's an entirely separate kind of scalar value.

Because undef automatically acts like zero when used as a number, it's easy to make an numeric accumulator that starts out empty:

# Add up some odd numbers
$n = 1;
while ($n < 10) {
  $sum += $n;
  $n += 2; # On to the next odd number
}
print "The total was $sum.\n";


This works properly when $sum was undef before the loop started. The first time through the loop $n is one, so the first line inside the loop adds one to $sum. That's like adding one to a variable that already holds zero (because you're using undef as if it were a number). So now it has the value 1. After that, since it's been initialized, adding works in the traditional way.

Similarly, you could have a string accumulator that starts out empty:

$string .= "more text\n";


If $string is undef, this will act as if it already held the empty string, putting "more text\n" into that variable. But if it already holds a string, the new text is simply appended.

Perl programmers frequently use a new variable in this way, letting it act as either zero or the empty string as needed.

Many operators return undef when the arguments are out of range or don't make sense. If you don't do anything special, you'll get a zero or a null string without major consequences. In practice, this is hardly a problem. In fact, most programmers will rely upon this behavior. But you should know that when warnings are turned on, Perl will typically warn about unusual uses of the undefined value, since that may indicate a bug. For example, simply copying undef from one variable into another isn't a problem, but trying to print it would generally cause a warning.

		2.2.11 The defined Function
The line-input operator <STDIN>  is one operator that can return undef. Normally, it will return a line of text, but if there is no more input, such as at end-of-file, it returns undef to signal this.[*] To tell whether a value is undef and not the empty string, use the defined function, which returns false for undef, and true for everything else:

    [*] Normally, there's no "end-of-file" when the input comes from the keyboard, but input may have been redirected to come from a file. Or the user may have pressed the key that the system recognizes to indicate end-of-file.

$madonna = <STDIN>;
if ( defined($madonna) ) {
  print "The input was $madonna";
} else {
  print "No input available!\n";
}


If you'd like to make your own undef values, you can use the obscurely named undef operator:

$madonna = undef; # As if it had never been touched


		2.2.12 Exercises
# [5] Write a program that computes the circumference of a circle with a radius of 12.5. Circumference is 2¿ times the radius (approximately 2 times 3.141592654). The answer you get should be about 78.5.
#

[4] Modify the program from the previous exercise to prompt for and accept a radius from the person running the program. So, if the user enters 12.5 for the radius, she should get the same number as in the previous exercise.
#

[4] Modify the program from the previous exercise so that, if the user enters a number less than zero, the reported circumference will be zero, rather than negative.
#

[8] Write a program that prompts for and reads two numbers (on separate lines of input) and prints out the product of the two numbers multiplied together.
#

[8] Write a program that prompts for and reads a string and a number (on separate lines of input) and prints out the string the number of times indicated by the number on separate lines. (Hint: use the x operator.) If the user enters "fred" and "3", the output should be three lines, each saying "fred". If the user enters "fred" and "299792", there may be a lot of output.

My answers at: /cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic
ex_2_2_12.pl

	2.3 List and arrays
	If a scalar is the "singular" in Perl, as we described it at the beginning of Chapter 2, the "plural" in Perl is represented by lists and arrays.

A list is an ordered collection of scalars. An array is a variable that contains a list. In Perl, the two terms are often used as if they're interchangeable. But, to be accurate, the list is the data, and the array is the variable. You can have a list value that isn't in an array, but every array variable holds a list (although that list may be empty). 

Each element of an array or list is a separate scalar variable with an independent scalar value. These values are orderedthat is, they have a particular sequence from the first to the last element. The elements of an array or list are indexed by small integers starting at zero[62] and counting by ones, so the first element of any array or list is always element zero.

    [62] Array and list indices always start at zero in Perl, unlike in some other languages. In early Perl, it was possible to change the starting number of array and list indexing (not for just one array or list, but for all of them at once!). Larry later realized that this was a misfeature, and its (ab)use is now strongly discouraged. But, if you're terminally curious, look up the $[ variable in the perlvar manpage.

Since each element is an independent scalar value, a list or array may hold numbers, strings, undef values, or any mixture of different scalar values. Nevertheless, it's most common to have all elements of the same type, such as a list of book titles (all strings) or a list of cosines (all numbers).

Arrays and lists can have any number of elements. The smallest one has no elements, while the largest can fill all of the available memory. Once again, this is in keeping with Perl's philosophy of "no unnecessary limits."


		2.3.1 Accessing Elements of an Array
If you've used arrays in another language, you won't be surprised to find that Perl provides a way to subscript an array in order to refer to an element by a numeric index.

The array elements are numbered using sequential integers, beginning at zero and increasing by one for each element, like this:

$fred[0] = "yabba";
$fred[1] = "dabba";
$fred[2] = "doo";


The array name itself (in this case, "fred") is from a completely separate namespace than scalars use; you could have a scalar variable named $fred in the same program, and Perl will treat them as different things and wouldn't be confused.[*] (Your maintenance programmer might be confused, though, so don't capriciously make all of your variable names the same!)

    [*] The syntax is always unambiguoustricky perhaps, but unambiguous.

You can use an array element like $fred[2] in every place[dagger] where you could use any other scalar variable like $fred. For example, you can get the value from an array element or change that value by the same sorts of expressions we used in the previous chapter:

    [dagger] Well, almost. The most notable exception is that the control variable of a foreach loop, which you'll see later in this chapter, must be a simple scalar. And there are others, like the "indirect object slot" and "indirect filehandle slot" for print and printf.

print $fred[0];
$fred[2]  = "diddley";
$fred[1] .= "whatsis";


Of course, the subscript may be any expression that gives a numeric value. If it's not an integer already, it'll automatically be truncated to the next lower integer:

$number = 2.71828;
print $fred[$number - 1]; # Same as printing $fred[1]


If the subscript indicates an element that would be beyond the end of the array, the corresponding value will be undef. This is just as with ordinary scalars; if you've never stored a value into the variable, it's undef:

$blank = $fred[ 142_857 ]; # unused array element gives undef
$blanc = $mel;             # unused scalar $mel also gives undef

		2.3.2 Special Array Indices
If you store into an array element that is beyond the end of the array, the array is automatically extended as neededthere's no limit on its length, as long as there's available memory for Perl to use. If Perl needs to create the intervening elements, it creates them as undef values:

$rocks[0]  = 'bedrock';      # One element...
$rocks[1]  = 'slate';        # another...
$rocks[2]  = 'lava';         # and another...
$rocks[3]  = 'crushed rock'; # and another...
$rocks[99] = 'schist';       # now there are 95 undef elements


Sometimes, you need to find out the last element index in an array. For the array of rocks that we've just been using, the last element index is $#rocks.[*] That's not the same as the number of elements, though, because there's an element number zero:

    [*] Blame this ugly syntax on the C shell. Fortunately, you don't have to look at this very often in the real world.

$end = $#rocks;                  # 99, which is the last element's index
$number_of_rocks = $end + 1;     # okay, but you'll see a better way later
$rocks[ $#rocks ] = 'hard rock'; # the last rock


Using the $#name value as an index, like that last example, happens often enough that Larry has provided a shortcut: negative array indices count from the end of the array. But don't get the idea that these indices "wrap around." If you've got three elements in the array, the valid negative indices are -1 (the last element), -2 (the middle element), and -3 (the first element). In the real world, nobody seems to use any of these except -1, though.

$rocks[ -1 ]   = 'hard rock';   # easier way to do that last example
$dead_rock     = $rocks[-100];  # gets 'bedrock'
$rocks[ -200 ] = 'crystal';     # fatal error!

		2.3.3 List Literals
An array (the way you represent a list value within your program) is a list of comma-separated values enclosed in parentheses. These values form the elements of the list. For example:

(1, 2, 3)      # list of three values 1, 2, and 3
(1, 2, 3,)     # the same three values (the trailing comma is ignored)
("fred", 4.5)  # two values, "fred" and 4.5
( )            # empty list - zero elements
(1..100)       # list of 100 integers


That last one uses the .. range operator, which is seen here for the first time. That operator creates a list of values by counting from the left scalar up to the right scalar by ones. For example:

(1..5)            # same as (1, 2, 3, 4, 5)
(1.7..5.7)        # same thing - both values are truncated
(5..1)            # empty list - .. only counts "uphill"
(0, 2..6, 10, 12) # same as (0, 2, 3, 4, 5, 6, 10, 12)
($m..$n)          # range determined by current values of $m and $n
(0..$#rocks)      # the indices of the rocks array from the previous section

					  


As you can see from those last two items, the elements of a list literal are not necessarily constants, they can be expressions that will be newly evaluated each time the literal is used. For example:

($m, 17)       # two values: the current value of $m, and 17
($m+$o, $p+$q) # two values


Of course, a list may have any scalar values, like this typical list of strings:

("fred", "barney", "betty", "wilma", "dino")


			2.3.3.1 The qw Shortcut

It turns out that lists of simple words (like the previous example) are frequently needed in Perl programs. The qw shortcut makes it easy to generate them without typing a lot of extra quote marks:

qw( fred barney betty wilma dino ) # same as above, but less typing


qw stands for "quoted words" or "quoted by whitespace," depending upon whom you ask. Either way, Perl treats it like a single-quoted string (so, you can't use \n or $fred inside a qw list as you would in a double-quoted string). The whitespace (characters like spaces, tabs, and newlines) will be discarded, and whatever is left becomes the list of items. Since whitespace is discarded, here's another (but unusual) way to write that same list:

qw(fred
  barney     betty
wilma dino)  # same as above, but pretty strange whitespace


Since qw is a form of quoting, though, you can't put comments inside a qw list.

The previous two examples have used parentheses as the delimiter, but Perl actually lets you choose any punctuation character as the delimiter. Here are some of the common ones:

qw! fred barney betty wilma dino !
qw/ fred barney betty wilma dino /
qw# fred barney betty wilma dino #   # like in a comment!
qw( fred barney betty wilma dino )
qw{ fred barney betty wilma dino }
qw[ fred barney betty wilma dino ]
qw< fred barney betty wilma dino >


As those last four show, sometimes the two delimiters can be different. If the opening delimiter is one of those "left" characters, the corresponding "right" character is the proper closing delimiter. Other delimiters use the same character for start and finish.

If you need to include the closing delimiter within the string as one of the characters, you probably picked the wrong delimiter. But even if you can't or don't want to change the delimiter, you can still include the character using the backslash:

qw! yahoo\! google ask msn ! # include yahoo! as an element


As in single-quoted strings, two consecutive backslashes contribute one single backslash to the item.

Now, although the Perl motto is There's More Than One Way To Do It, you may well wonder why anyone would need all of those different ways! Well, you'll see later that there are other kinds of quoting where Perl uses this same rule, and it can come in handy in many of those. But even here, it could be useful if you were to need a list of Unix filenames:

qw{
  /usr/dict/words
  /home/rootbeer/.ispell_english
}


That list would be quite inconvenient to read, write, and maintain if the slash were the only delimiter available.

		2.3.4 List Assignment
		In much the same way as scalar values may be assigned to variables, list values may also be assigned to variables:

($fred, $barney, $dino) = ("flintstone", "rubble", undef);


All three variables in the list on the left get new values, just as if you did three separate assignments. Since the list is built up before the assignment starts, this makes it easy to swap two variables' values in Perl:[*]

    [*] As opposed to in languages like C, in which there is no easy way to do this in general. C programmers use an auxiliary swap variable to temporarily hold the value, possibly managed via a macro.

 ($fred, $barney) = ($barney, $fred); # swap those values
($betty[0], $betty[1]) = ($betty[1], $betty[0]);


But what happens if the number of variables (on the left side of the equals sign) isn't the same as the number of values (from the right side)? In a list assignment, extra values are silently ignored. Perl figures that if you wanted those values stored somewhere, you would have told it where to store them. Alternatively, if you have too many variables, the extras get the value undef:[*]

    [*] Well, that's true for scalar variables. Array variables get an empty list, as you'll see in a moment.


($fred, $barney) = qw< flintstone rubble slate granite >; # two ignored items
($wilma, $dino)  = qw[flintstone];                        # $dino gets undef

					  


Now that you can assign lists, you could build up an array of strings with a line of code like this:[dagger]

    [dagger] We're cheating by assuming that the rocks array is empty before this statement. If there were a value in $rocks[7], say, this assignment wouldn't affect that element.


($rocks[0], $rocks[1], $rocks[2], $rocks[3]) = qw/talc mica feldspar quartz/;

But when you wish to refer to an entire array, Perl has a simpler notation. Just use the at sign (@) before the name of the array (and no index brackets after it) to refer to the entire array at once. You can read this as "all of the," so @rocks is "all of the rocks."[double dagger] This works on either side of the assignment operator:

    [double dagger] Larry claims that he chose the dollar and at sign because they can be read as $calar (scalar) and @rray (array). If you don't get that, or remember it that way, no big deal.

@rocks  = qw/ bedrock slate lava /;
@tiny   = ( );                       # the empty list
@giant  = 1..1e5;                    # a list with 100,000 elements
@stuff  = (@giant, undef, @giant);   # a list with 200,001 elements
$dino   = "granite";
@quarry = (@rocks, "crushed rock", @tiny, $dino);


That last assignment gives @quarry the five-element list (bedrock, slate, lava, crushed rock, granite), since @tiny contributes zero elements to the list. (In particular, it doesn't put an undef item into the listbut you could do that explicitly, as we did with @stuff earlier.) It's also worth noting that an array name is replaced by the list it contains. An array doesn't become an element in the list because these arrays can contain only scalars, not other arrays.[||] The value of an array variable that has not yet been assigned is ( ), the empty list. Just as new, empty scalars start out with undef, new, empty arrays start out with the empty list.

    [||] But in the Alpaca book, we'll show you a special kind of scalar called a reference. That lets us make what are informally called "lists of lists," among other interesting and useful structures. But in that case, you're still not really storing a list into a list; you're storing a reference to an array.

It's worth noting that when an array is copied to another array, it's still a list assignment. The lists are simply stored in arrays. For example:

@copy = @quarry; # copy a list from one array to another

			2.3.4.1 The pop and push Operators

You could add new items to the end of an array by simply storing them as elements with new, larger indices. But real Perl programmers don't use indices.[*] So in the next few sections, we'll present some ways to work with an array without using indices.

    [*] Of course, we're joking. But there's a kernel of truth in this joke. Indexing into arrays is not using Perl's strengths. If you use the pop, push, and similar operators that avoid using indexing, your code will generally be faster than if you use many indices, as well as avoiding "off-by-one" errors, often called "fencepost" errors. Occasionally, a beginning Perl programmer (wanting to see how Perl's speed compares to C's) will take, say, a sorting algorithm optimized for C (with many array index operations), rewrite it straightforwardly in Perl (again, with many index operations) and wonder why it's so slow. The answer is that using a Stradivarius violin to pound nails should not be considered a sound construction technique.

One common use of an array is as a stack of information, where new values are added to and removed from the right side of the list. (This is the end with the "last" items in the array, the end with the highest index values.) These operations occur often enough to have their own special functions.

The pop operator takes the last element off of an array and returns it:

@array  = 5..9;
$fred   = pop(@array);  # $fred gets 9, @array now has (5, 6, 7, 8)
$barney = pop @array;   # $barney gets 8, @array now has (5, 6, 7)
pop @array;             # @array now has (5, 6). (The 7 is discarded.)


That last example uses pop "in a void context," which is merely a fancy way of saying the return value isn't going anywhere. There's nothing wrong with using pop in this way, if that's what you want.

If the array is empty, pop will leave it alone (since there is no element to remove), and it will return undef.

You may have noticed that pop may be used with or without parentheses. This is a general rule in Perl: as long as you don't change the meaning by removing the parentheses, they're optional.[dagger] The converse operation is push, which adds an element (or a list of elements) to the end of an array:

    [dagger] A reader from the educated class will recognize that this is a tautology.

push(@array, 0);      # @array now has (5, 6, 0)
push @array, 8;       # @array now has (5, 6, 0, 8)
push @array, 1..10;   # @array now has those ten new elements
@others = qw/ 9 0 2 1 0 /;
push @array, @others; # @array now has those five new elements (19 total)


Note that the first argument to push or the only argument for pop must be an array variable. pushing and popping would not make sense on a literal list.

			2.3.4.2 The shift and unshift Operators

The push and pop operators do things to the end of an array (or the right side of an array, or the portion with the highest subscripts, depending upon how you like to think of it). Similarly, the unshift and shift operators perform the corresponding actions on the "start" of the array (or the "left" side of an array, or the portion with the lowest subscripts). Here are a few examples:
Code View: Scroll / Show All

@array = qw# dino fred barney #;
$m = shift(@array);      # $m gets "dino", @array now has ("fred", "barney")
$n = shift @array;       # $n gets "fred", @array now has ("barney")
shift @array;            # @array is now empty
$o = shift @array;       # $o gets undef, @array is still empty
unshift(@array, 5);      # @array now has the one-element list (5)
unshift @array, 4;       # @array now has (4, 5)
@others = 1..3;
unshift @array, @others; # @array now has (1, 2, 3, 4, 5)

					  


Analogous to pop, shift returns undef if given an empty array variable.

		2.3.5 Interpolating Arrays into Strings
		Like scalars, array values may be interpolated into a double-quoted string. Elements of an array are automatically separated by spaces[*] upon interpolation:

    [*] Actually, the separator is the value of the special $" variable, which is a space by default.

@rocks = qw{ flintstone slate rubble };
print "quartz @rocks limestone\n";  # prints five rocks separated by spaces


There are no extra spaces added before or after an interpolated array; if you want those, you'll have to put them in yourself:

print "Three rocks are: @rocks.\n";
print "There's nothing in the parens (@empty) here.\n";


If you forget that arrays interpolate like this, you'll be surprised when you put an email address into a double-quoted string:

$email = "fred@bedrock.edu";  # WRONG! Tries to interpolate @bedrock


Although we intended to have an email address, Perl sees the array named @bedrock and tries to interpolate it. Depending on our version of Perl, we'll probably just get a warning:[dagger]

    [dagger] Some Perl versions before 5.6 actually made this a fatal error, but it was changed to a warning because that was too annoying.

Possible unintended interpolation of @bedrock


To get around this problem, we either escape the @ in a double-quoted string or use a single-quoted string:

$email = "fred\@bedrock.edu"; # Correct
$email = 'fred@bedrock.edu';  # Another way to do that


A single element of an array will be replaced by its value, just as you'd expect:

@fred = qw(hello dolly);
$y = 2;
$x = "This is $fred[1]'s place";    # "This is dolly's place"
$x = "This is $fred[$y-1]'s place"; # same thing


Note that the index expression is evaluated as an ordinary expression, as if it were outside a string. It is not variable-interpolated first. In other words, if $y contains the string "2*4", we're still talking about element 1, not element 7, because "2*4" as a number (the value of $y used in a numeric expression) is just plain 2.[*] If you want to follow a simple scalar variable with a left square bracket, you need to delimit the square bracket so that it isn't considered part of an array reference, as follows:

    [*] Of course, if you've got warnings turned on, Perl is likely to remind you that "2*4" is a pretty funny looking number.

@fred = qw(eating rocks is wrong);
$fred = "right";               # we are trying to say "this is right[3]"
print "this is $fred[3]\n";    # prints "wrong" using $fred[3]
print "this is ${fred}[3]\n";  # prints "right" (protected by braces)
print "this is $fred"."[3]\n"; # right again (different string)
print "this is $fred\[3]\n";   # right again (backslash hides it)

"
		2.3.6 The foreach Control Structure
		It's handy to be able to process an entire array or list, so Perl provides a control structure to do just that. The foreach loop steps through a list of values, executing one iteration (time through the loop) for each value:

foreach $rock (qw/ bedrock slate lava /) {
  print "One rock is $rock.\n";  # Prints names of three rocks
}


The control variable ($rock in that example) takes on a new value from the list for each iteration. The first time through the loop, it's "bedrock"; the third time, it's "lava".

The control variable is not a copy of the list element, it actually is the list element. That is, if you modify the control variable inside the loop, you'll be modifying the element itself, as shown in the following code snippet. This is useful, and supported, but it would surprise you if you weren't expecting it.

@rocks = qw/ bedrock slate lava /;
foreach $rock (@rocks) {
  $rock = "\t$rock";       # put a tab in front of each element of @rocks
  $rock .= "\n";           # put a newline on the end of each
}
print "The rocks are:\n", @rocks; # Each one is indented, on its own line


What is the value of the control variable after the loop has finished? It's the same as it was before the loop started. Perl automatically saves and restores the value of the control variable of a foreach loop. While the loop is running, there's no way to access or alter that saved value. So after the loop is done, the variable has the value it had before the loop, or undef if it hadn't had a value. That means that if you want to name your loop control variable $rock, you don't have to worry that maybe you've already used that name for another variable.

			2.3.6.1 Perl's Favorite Default: $_

If you omit the control variable from the beginning of the foreach loop, Perl uses its favorite default variable, $_. This is (mostly) just like any other scalar variable, except for its unusual name. For example:

foreach (1..10) {  # Uses $_ by default
  print "I can count to $_!\n";
}


Although this isn't Perl's only default by a long shot, it's Perl's most common default. You'll see many other cases in which Perl will automatically use $_ when you don't tell it to use some other variable or value, thereby saving the programmer from the heavy labor of having to think up and type a new variable name. So as not to keep you in suspense, one of those cases is print, which will print $_ if given no other argument:

$_ = "Yabba dabba doo\n";
print;  # prints $_ by default


			2.3.6.2 The reverse Operator

The reverse operator takes a list of values (which may come from an array) and returns the list in the opposite order. So if you were disappointed that the range operator, .., only counts upward, this is the way to fix it:

@fred   = 6..10;
@barney = reverse(@fred);  # gets 10, 9, 8, 7, 6
@wilma  = reverse 6..10;   # gets the same thing, without the other array
@fred   = reverse @fred;   # puts the result back into the original array


The last line is noteworthy because it uses @fred twice. Perl always calculates the value being assigned (on the right) before it begins the actual assignment.

Remember that reverse returns the reversed list; it doesn't affect its arguments. If the return value isn't assigned anywhere, it's useless:

reverse @fred;         # WRONG - doesn't change @fred
@fred = reverse @fred; # that's better


			2.3.6.3 The sort Operator

The sort operator takes a list of values (which may come from an array) and sorts them in the internal character ordering. For ASCII strings, that would be ASCIIbetical order. Of course, ASCII is a strange place where all of the capital letters come before all of the lowercase letters, where the numbers come before the letters, and the punctuation markswell, those are here, there, and everywhere. But sorting in ASCII order is just the default behavior (you'll see in Chapter 14 how to sort in whatever order you'd like):

@rocks   = qw/ bedrock slate rubble granite /;
@sorted  = sort(@rocks);        # gets bedrock, granite, rubble, slate
@back    = reverse sort @rocks; # these go from slate to bedrock
@rocks   = sort @rocks;         # puts sorted result back into @rocks
@numbers = sort 97..102;        # gets 100, 101, 102, 97, 98, 99


As you can see from that last example, sorting numbers as if they were strings may not give useful results. But, of course, any string that starts with 1 has to sort before any string that starts with 9, according to the default sorting rules. And like what happened with reverse, the arguments themselves aren't affected. If you want to sort an array, you must store the result back into that array:

sort @rocks;          # WRONG, doesn't modify @rocks
@rocks = sort @rocks; # Now the rock collection is in order


		2.3.7 Scalar and List Context
This is the most important section in this chapter. In fact, it's the most important section in the entire book. It wouldn't be an exaggeration to say that your entire career in using Perl will depend upon understanding this section. So if you've gotten away with skimming the text up to this point, this is where you should really pay attention.

That's not to say that this section is in any way difficult to understand. It's actually a simple idea: a given expression may mean different things depending upon where it appears. This is nothing new to you; it happens all the time in natural languages. For example, in English,[*] suppose someone asked you what the word "read"[dagger] means. It has different meanings depending on how it's used. You can't identify the meaning until you know the context.

    [*] If you aren't a native speaker of English, this analogy may not be obvious to you. But context sensitivity happens in every spoken language, so you may be able to think of an example in your own language.

    [dagger] Or maybe they were asking what the word "red" means, if they were speaking rather than writing a book. It's ambiguous either way. As Douglas Hofstadter said, no language can express every thought unambiguously, especially this one.

The context refers to where an expression is found. As Perl is parsing your expressions, it always expects either a scalar value or a list value.[*] What Perl expects is called the context of the expression.[dagger]

    [*] Unless, of course, Perl is expecting something else entirely. There are other contexts that aren't covered here. In fact, nobody knows how many contexts Perl uses; the biggest brains in all of Perl haven't agreed on an answer to that yet.

    [dagger] This is no different than what you're used to in human languages. If I make a grammatical mistake, you notice it right away because you expect certain words in places certain. Eventually, you'll read Perl this way, too, but at first you have to think about it.

42 + something # The something must be a scalar
sort something # The something must be a list


Even if something is the exact same sequence of characters, in one case it may give a single, scalar value, while in the other, it may give a list.[double dagger] Expressions in Perl always return the appropriate value for their context. For example, take the "name"[||] of an array. In a list context, it gives the list of elements. But in a scalar context, it returns the number of elements in the array:

    [double dagger] The list may be just one element long, of course. It could also be empty, or it could have any number of elements.

    [||] Well, the true name of the array @people is just people. The @-sign is just a qualifier.

@people = qw( fred barney betty );
@sorted = sort @people; # list context: barney, betty, fred
$number = 42 + @people;  # scalar context: 42 + 3 gives 45


Even ordinary assignment (to a scalar or a list) causes different contexts:

@list = @people; # a list of three people
$n = @people;    # the number 3


But please don't jump to the conclusion that scalar context always gives the number of elements that would have been returned in list context. Most list-producing expressions[§] return something much more interesting than that.

    [§] But with regard to the point of this section, there's no difference between a "list-producing" expression and a "scalar-producing" one; any expression can produce a list or a scalar, depending upon context. So when we say "list-producing expressions," we mean expressions that are typically used in a list context and therefore might surprise you when they're used unexpectedly in a scalar context (like reverse or @fred).

			2.3.7.1 Using List-Producing Expressions in Scalar Context

There are many expressions that would typically be used to produce a list. If you use one in a scalar context, what do you get? See what the author of that operation says about it. Usually, that person is Larry, and usually the documentation gives the whole story. In fact, a big part of learning Perl is actually learning how Larry thinks.[**] Therefore, once you can think like Larry does, you know what Perl should do. But while you're learning, you'll probably need to look into the documentation.

    [**] This is only fair, since while writing Perl he tried to think like you do to predict what you would want!

Some expressions don't have a scalar-context value at all. For example, what should sort return in a scalar context? You wouldn't need to sort a list to count its elements, so until someone implements something else, sort in a scalar context always returns undef.

Another example is reverse. In a list context, it gives a reversed list. In a scalar context, it returns a reversed string (or reversing the result of concatenating all the strings of a list, if given one):

@backwards = reverse qw/ yabba dabba doo /;
   # gives doo, dabba, yabba
$backwards = reverse qw/ yabba dabba doo /;
   # gives oodabbadabbay


At first, it's not always obvious whether an expression is being used in a scalar or a list context. But, trust us, it will become second nature for you eventually.

Here are some common contexts to start you off:

$fred = something;            # scalar context
@pebbles = something;         # list context
($wilma, $betty) = something; # list context
($dino) = something;          # still list context!


Don't be fooled by the one-element list; that last one is a list context, not a scalar one. The parentheses are significant here, making the fourth of those different than the first. If you're assigning to a list (no matter the number of elements), it's a list context. If you're assigning to an array, it's a list context.

Here are some other expressions you've seen, and the contexts they provide. First, some that provide scalar context to something:

$fred = something;
$fred[3] = something;
123 + something
something + 654
if (something) { ... }
while (something) { ... }
$fred[something] = something;


And here are some that provide a list context:

@fred = something;
($fred, $barney) = something;
($fred) = something;
push @fred, something;
foreach $fred (something) { ... }
sort something
reverse something
print something


			2.3.7.2 Using Scalar-Producing Expressions in List Context

Going this direction is straightforward: if an expression doesn't normally have a list value, the scalar value is automatically promoted to make a one-element list:

@fred = 6 * 7; # gets the one-element list (42)
@barney = "hello" . ' ' . "world";


Well, there's one possible catch:

@wilma = undef; # OOPS! Gets the one-element list (undef)
  # which is not the same as this:
@betty = ( );    # A correct way to empty an array


Since undef is a scalar value, assigning undef to an array doesn't clear the array. The better way to do that is to assign an empty list.[*]

    [*] Well, in most real-world algorithms, if the variable is declared in the proper scope, you will not need to explicitly empty it. So this type of assignment is rare in well-written Perl programs. You'll learn about scoping in the next chapter.

			2.3.7.3 Forcing Scalar Context

On occasion, you may need to force scalar context where Perl is expecting a list. In that case, you can use the fake function scalar. It's not a true function because it just tells Perl to provide a scalar context:

@rocks = qw( talc quartz jade obsidian );
print "How many rocks do you have?\n";
print "I have ", @rocks, " rocks!\n";        # WRONG, prints names of rocks
print "I have ", scalar @rocks, " rocks!\n"; # Correct, gives a number


Oddly enough, there's no corresponding function to force list context. It turns out you never need it. Trust us on this, too.


		2.3.8 <STDIN> in List Context
One previously seen operator that returns a different value in an array context is the line-input operator, <STDIN>. As described earlier, <STDIN> returns the next line of input in a scalar context. Now, in list context, this operator returns all of the remaining lines up to the end of file. Each line is returned as a separate element of the list. For example:

@lines = <STDIN>; # read standard input in list context


When the input is coming from a file, this will read the rest of the file. But how can there be an end-of-file when the input comes from the keyboard? On Unix and similar systems, including Linux and Mac OS X, you'll normally type a Control-D[dagger] to indicate to the system that there's no more input; the special character itself is never seen by Perl,[*] even though it may be echoed to the screen. On DOS/Windows systems, use Control-Z instead.[dagger] You'll need to check the documentation for your system or ask your local expert if it's different from these.

    [dagger] This is merely the default; it can be changed by the stty command. But it's pretty dependablewe've never seen a Unix system where a different character was used to mean end-of-file from the keyboard.

    [*] It's the OS that "sees" the Control key and reports "end of file" to the application.

    [dagger] There's a bug affecting some ports of Perl for DOS/Windows where the first line of output to the terminal following the use of Control-Z is obscured. On these systems, you can work around this problem by simply printing a blank line ("\n") after reading the input.

If the person running the program types three lines, then presses the proper keys needed to indicate end-of-file, the array ends up with three elements. Each element will be a string that ends in a newline, corresponding to the three newline-terminated lines entered.

Wouldn't it be nice if, having read those lines, you could chomp the newlines all at once? It turns out that if you give chomp an array holding a list of lines, it will remove the newlines from each item in the list. For example:

@lines = <STDIN>; # Read all the lines
chomp(@lines);    # discard all the newline characters


But the more common way to write that is with code similar to what we used earlier:

chomp(@lines = <STDIN>); # Read the lines, not the newlines


Although you're welcome to write your code either way in the privacy of your own cubicle, most Perl programmers will expect the second, more compact, notation.

It may be obvious to you (but it's not obvious to everyone) that once these lines of input have been read, they can't be re-read.[double dagger] Once you've reached end-of-file, there's no more input out there to read.

    [double dagger] Well, yes, if the input is from a source upon which you can seek, you'll be able to go back and read again. But that's not what we're talking about here.

And what happens if the input is coming from a 400 MB logfile? The line input operator reads all of the lines, gobbling up lots of memory.[||] Perl tries not to limit you in what you can do, but the other users of your system (not to mention your system administrator) are likely to object. If the input data is large, you should generally find a way to deal with it without reading it all into memory at once.

    [||] Typically, that's much more memory than the size of the file, too. That is, a 400 MB file will typically take up at least a full gigabyte of memory when read into an array. This is because Perl will generally waste memory to save time. This is a good tradeoff: if you're short of memory, you can buy more; if you're short on time, you're hosed.

		2.3.9 Exercises
#

[6] Write a program that reads a list of strings on separate lines until end-of-input and prints out the list in reverse order. If the input comes from the keyboard, you'll probably need to signal the end of the input by pressing Control-D on Unix, or Control-Z on Windows.
#

[12] Write a program that reads a list of numbers (on separate lines) until end-of-input and then prints for each number the corresponding person's name from the list shown below. (Hardcode this list of names into your program. That is, it should appear in your program's source code.) For example, if the input numbers were 1, 2, 4, and 2, the output names would be fred, betty, dino, and betty:

fred betty barney dino wilma pebbles bamm-bamm


#

[8] Write a program that reads a list of strings (on separate lines) until end-of-input. Then it should print the strings in ASCIIbetical order. That is, if you enter the strings fred, barney, wilma, betty, the output should show barney betty fred wilma. Are all of the strings on one line in the output or on separate lines? Could you make the output appear in either style?

My answers at: /cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic
ex_2_3_9_1.pl

	2.4 Subroutines
You've already seen and used some of the built-in system functions, such as chomp, reverse, print, and so on. But, as other languages do, Perl has the ability to make subroutines, which are user-defined functions.[90] These let us recycle one chunk of code many times in one program.[91] The name of a subroutine is another Perl identifier (letters, digits, and underscores, but it can't start with a digit) with a sometimes-optional ampersand (&) in front. There's a rule about when you can omit the ampersand and when you cannot; you'll see that rule by the end of the chapter. For now, we'll just use it every time that it's not forbidden, which is always a safe rule. We'll tell you every place where it's forbidden, of course.

    [90] In Perl, we don't generally make the distinction that Pascal programmers are used to, between functions, which return a value, and procedures, which don't. But a subroutine is always user-defined, while a function may or may not be. That is, the word function may be used as a synonym for subroutine, or it may mean one of Perl's built-in functions. That's why this chapter is titled Subroutines, because it's about the ones you can define, not the built-ins. Mostly.

        [91] The code examples used in this book are recycled from at least 40% post-consumer programming and are at least 75% recyclable into your programs when properly decomposed.

	The subroutine name comes from a separate namespace, so Perl won't be confused if you have a subroutine called &fred and a scalar called $fred in the same programal, though there's no reason to do that under normal circumstances.

		2.4.1  Defining a Subroutine
To define your own subroutine, use the keyword sub, the name of the subroutine (without the ampersand), then the indented block of code (in curly braces),[92] which makes up the body of the subroutine, something like this:

    [92] Okay, purists, we admit it: the curly braces are part of the block, properly speaking. And Perl doesn't require the indentation of the block, but your maintenance programmer will. So please be stylish.

    sub marine {
	      $n += 1;  # Global variable $n
		        print "Hello, sailor number $n!\n";
    }


Subroutine definitions can be anywhere in your program text, but programmers who come from a background of languages like C or Pascal like to put them at the start of the file. Others may prefer to put them at the end of the file so that the main part of the program appears at the beginning. It's up to you. In any case, you don't normally need any kind of forward declaration.[*] Subroutine definitions are global; without some powerful trickiness, there are no private subroutines.[dagger] If you have two subroutine definitions with the same name, the later one overwrites the earlier one.[double dagger] That's generally considered bad form, or the sign of a confused maintenance programmer.

    [*] Unless your subroutine is being particularly tricky and declares a "prototype," which dictates how a compiler will parse and interpret its invocation arguments. This is rare, see the perlsub manpage for more information.

        [dagger] If you wish to be powerfully tricky, read the Perl documentation about coderefs stored in private (lexical) variables.

	    [double dagger] A warnable offense, however.

	    As you may have noticed in the previous example, you may use any global variables within the subroutine body. In fact, all of the variables you've seen so far are globals; that is, they are accessible from every part of your program. This horrifies linguistic purists, but the Perl development team formed an angry mob with torches and ran them out of town years ago. You'll see how to make private variables in Section 4.5," later in this chapter.

	    "
		2.4.2  Invoking a Subroutine
Invoke a subroutine from within any expression by using the subroutine name (with the ampersand):[||]

	    [||] And frequently a pair of parentheses, even if empty. As written, the subroutine inherits the caller's @_ value, which we'll be discussing shortly. So don't stop reading here, or you'll be writing code with unintended effects!

	    &marine;  # says Hello, sailor number 1!
	    &marine;  # says Hello, sailor number 2!
	    &marine;  # says Hello, sailor number 3!
	    &marine;  # says Hello, sailor number 4!

		2.4.3  Return Values
The subroutine is always invoked as part of an expression, even if the result of the expression isn't being used. When we invoked &marine earlier, we were calculating the value of the expression containing the invocation, but then throwing away the result.

Many times, you'll call a subroutine and actually do something with the result. This means that you'll be paying attention to the return value of the subroutine. All Perl subroutines have a return valuethere's no distinction between those that return values and those that don't. Not all Perl subroutines have a useful return value, however.

Since all Perl subroutines can be called in a way that needs a return value, it'd be a bit wasteful to have to declare special syntax to "return" a particular value for the majority of the cases. So Larry made it simple. As Perl is chugging along in a subroutine, it is calculating values as part of its series of actions. Whatever calculation is last performed in a subroutine is automatically also the return value.

For example, let's define this subroutine:

sub sum_of_fred_and_barney {
	  print "Hey, you called the sum_of_fred_and_barney subroutine!\n";
	    $fred + $barney;  # That's the return value
}


The last expression evaluated in the body of this subroutine is the sum of $fred and $barney, so the sum of $fred and $barney will be the return value. Here's that in action:

$fred = 3;
$barney = 4;
$wilma = &sum_of_fred_and_barney;      # $wilma gets 7
print "\$wilma is $wilma.\n";
$betty = 3 * &sum_of_fred_and_barney;  # $betty gets 21
print "\$betty is $betty.\n";


That code will produce this output:

Hey, you called the sum_of_fred_and_barney subroutine!
$wilma is 7.
Hey, you called the sum_of_fred_and_barney subroutine!
$betty is 21.


That print statement is just a debugging aid, so that you can see that you called the subroutine. You'd take it out when the program is finished. But suppose you added another line to the end of the code, like this:

sub sum_of_fred_and_barney {
	  print "Hey, you called the sum_of_fred_and_barney subroutine!\n";
	    $fred + $barney;  # That's not really the return value!
		      print "Hey, I'm returning a value now!\n";      # Oops!
}


In this example, the last expression evaluated is not the addition; it's the print statement. Its return value will normally be 1, meaning "printing was successful,"[*] but that's not the return value you actually wanted. So be careful when adding additional code to a subroutine, since the last expression evaluated will be the return value.

    [*] The return value of print is true for a successful operation and false for a failure. You'll see how to determine the kind of failure later in the next chapter.

    So, what happened to the sum of $fred and $barney in that second (faulty) subroutine? We didn't put it anywhere, so Perl discarded it. If you had requested warnings, Perl (noticing that there's nothing useful about adding two variables and discarding the result) would likely warn you about something like "a useless use of addition in a void context." The term void context is just a fancy way of saying that the answer isn't being stored in a variable or used in any other way.

    "The last expression evaluated" really means the last expression evaluated, rather than the last line of text. For example, this subroutine returns the larger value of $fred or $barney:

    sub larger_of_fred_or_barney {
	      if ($fred > $barney) {
		          $fred;
			    } else {
				        $barney;
					  }
    }


The last expression evaluated is either $fred or $barney, so the value of one of those variables becomes the return value. You won't know whether the return value will be $fred or $barney until you see what those variables hold at runtime.

These are all rather trivial examples. It gets better when you can pass values that are different for each invocation into a subroutine instead of relying on global variables. In fact, that's coming right up.

		2.4.4  Arguments
That subroutine called larger_of_fred_or_barney would be much more useful if it didn't force you to use the global variables $fred and $barney. If you wanted to get the larger value from $wilma and $betty, you currently have to copy those into $fred and $barney before you can use larger_of_fred_or_barney. And if you had something useful in those variables, you'd have to first copy those to other variables, say $save_fred and $save_barney. And then, when you're done with the subroutine, you'd have to copy those back to $fred and $barney again.

Luckily, Perl has subroutine arguments. To pass an argument list to the subroutine, simply place the list expression, in parentheses, after the subroutine invocation, like this:

$n = &max(10, 15);  # This sub call has two parameters


The list is passed to the subroutine; that is, it's made available for the subroutine to use however it needs to. Of course, you have to store this list somewhere, so Perl automatically stores the parameter list (another name for the argument list) in the special array variable named @_ for the duration of the subroutine. The subroutine can access this variable to determine both the number of arguments and the value of those arguments.

This means that the first subroutine parameter is stored in $_[0], the second one is stored in $_[1], and so on. But, and here's an important note: these variables have nothing whatsoever to do with the $_ variable, any more than $dino[3] (an element of the @dino array) has to do with $dino (a completely distinct scalar variable). It's just that the parameter list must be stored into some array variable for the subroutine to use it, and Perl uses the array @_ for this purpose.

Now, you could write the subroutine &max to look a little like the subroutine &larger_of_fred_or_barney, but instead of using $fred you could use the first subroutine parameter ($_[0]), and instead of using $barney, you could use the second subroutine parameter ($_[1]). And so you could end up with code something like this:

sub max {
	  # Compare this to &larger_of_fred_or_barney
	  if ($_[0] > $_[1]) {
		      $_[0];
		        } else {
				    $_[1];
				      }
}


Well, as we said, you could do that. But it's pretty ugly with all of those subscripts, and hard to read, write, check, and debug, too. You'll see a better way in a moment.

There's another problem with this subroutine. The name &max is nice and short, but it doesn't remind us that this subroutine works properly only if called with exactly two parameters:

$n = &max(10, 15, 27);  # Oops!


Excess parameters are ignored, since the subroutine never looks at $_[2], Perl doesn't care whether there's something in there or not. And insufficient parameters are also ignored. you simply get undef if you look beyond the end of the @_ array, as with any other array. You'll see how to make a better &max, which works with any number of parameters, later in this chapter.

The @_ variable is private to the subroutine;[*] if there's a global value in @_, it is saved away before the subroutine is invoked and restored to its previous value upon return from the subroutine.[dagger] This also means that a subroutine can pass arguments to another subroutine without fear of losing its own @_ variable. the nested subroutine invocation gets its own @_ in the same way. Even if the subroutine calls itself recursively, each invocation gets a new @_, so @_ is always the parameter list for the current subroutine invocation.

    [*] Unless there's an ampersand in front of the name for the invocation, and no parentheses (or arguments) afterward, in which case the @_ array is inherited from the caller's context. That's generally a bad idea, but is occasionally useful.

        [dagger] You might recognize that this is the same mechanism as used with the control variable of the foreach loop, as seen in the previous chapter. In either case, the variable's value is saved and automatically restored by Perl.

		2.4.5  Private Variables in Subroutines
But if Perl can give us a new @_ for every invocation, can't it give us variables for our own use as well? Of course it can.

By default, all variables in Perl are global variables; that is, they are accessible from every part of the program. But you can create private variables called lexical variables at any time with the my operator:

sub max {
	  my($m, $n);       # new, private variables for this block
		    ($m, $n) = @_;    # give names to the parameters
		      if ($m > $n) { $m } else { $n }
}


These variables are private (or scoped) to the enclosing block; any other $m or $n is totally unaffected by these two. And that goes the other way, too--no other code can access or modify these private variables, by accident or design.[*] So, you could drop this subroutine into any Perl program in the world and know that you wouldn't mess up that program's $m and $n (if any).[dagger] It's also worth pointing out that, inside the if's blocks, there's no semicolon needed after the return value expression. Although Perl allows you to omit the last semicolon in a block, in practice you omit it only when the code is so simple that you can write the block in a single line.

    [*] Advanced programmers will realize that a lexical variable may be accessible by reference from outside its scope, but never by name.

        [dagger] Of course, if that program already had a subroutine called &max, you'd mess that up.

	The subroutine in the previous example could be made even simpler. Did you notice that the list ($m, $n) was written twice? That my operator can also be applied to a list of variables enclosed in parentheses, so it's customary to combine those first two statements in the subroutine:

	my($m, $n) = @_;  # Name the subroutine parameters


	That one statement creates the private variables and sets their values, so the first parameter now has the easier-to-use name $m and the second has $n. Nearly every subroutine will start with a line much like that one, naming its parameters. When you see that line, you'll know that the subroutine expects two scalar parameters, which you'll call $m and $n inside the subroutine.

		2.4.6  Variable-Length Parameter Lists
In real-world Perl code, subroutines are often given parameter lists of arbitrary length. That's because of Perl's "no unnecessary limits" philosophy that you've already seen. Of course, this is unlike many traditional programming languages, which require every subroutine to be strictly typed (that is, to permit only a certain, predefined number of parameters of predefined types). It's nice that Perl is so flexible, but (as you saw with the &max routine earlier) that may cause problems when a subroutine is called with a different number of arguments than the author expected.

Of course, the subroutine can easily check that it has the right number of arguments by examining the @_ array. For example, we could have written &max to check its argument list like this:[*]

    [*] As soon as you learn about warn in the next chapter, you'll see that you can use it to turn improper usage like this into a proper warning. Or perhaps you'll decide that this case is severe enough to warrant using die, described in the same chapter.

    sub max {
	      if (@_ != 2) {
		          print "WARNING! &max should get exactly two arguments!\n";
			    }
	        # continue as before...
	        .
			  .
			    .
    }


That if test uses the "name" of the array in a scalar context to find out the number of array elements, as you saw in Chapter 3.

But in real-world Perl programming, this sort of check is hardly ever used; it's better to make the subroutine adapt to the parameters.

			2.4.6.1  A Better &max Routine

So let's rewrite &max to allow for any number of arguments:

$maximum = &max(3, 5, 10, 4, 6);

sub max {
	  my($max_so_far) = shift @_;  # the first one is the largest yet seen
		    foreach (@_) {               # look at the remaining arguments
			        if ($_ > $max_so_far) {    # could this one be bigger yet?
					      $max_so_far = $_;
					          }
				  }
	    $max_so_far;
}


This code uses what has often been called the "high-water mark" algorithm; after a flood, when the waters have surged and receded for the last time, the high-water mark shows where the highest water was seen. In this routine, $max_so_far keeps track of our high-water mark, the largest number yet seen.

The first line sets $max_so_far to 3 (the first parameter in the example code) by shifting that parameter from the parameter array, @_. So @_ now holds (5, 10, 4, 6), since the 3 has been shifted off. And the largest number yet seen is the only one yet seen: 3, the first parameter.

Now, the foreach loop will step through the remaining values in the parameter list, from @_. The control variable of the loop is, by default, $_. (But, remember, there's no automatic connection between @_ and $_; it's just a coincidence that they have such similar names.) The first time through the loop, $_ is 5. The if test sees that it is larger than $max_so_far, so $max_so_far is set to 5the new high-water mark.

The next time through the loop, $_ is 10. That's a new record high, so it's stored in $max_so_far as well.

The next time, $_ is 4. The if test fails, since that's no larger than $max_so_far, which is 10, so the body of the if is skipped.

The next time, $_ is 6, and the body of the if is skipped again. And that was the last time through the loop, so the loop is done.

Now, $max_so_far becomes the return value. It's the largest number we've seen, and we've seen them all, so it must be the largest from the list: 10.

			2.4.6.2 Empty Parameter Lists

That improved &max algorithm works fine now, even if there are more than two parameters. But what happens if there is none?

At first, it may seem too esoteric to worry about. After all, why would someone call &max without giving it any parameters? But maybe someone wrote a line like this one:

$maximum = &max(@numbers);


And the array @numbers might sometimes be an empty list; perhaps it was read in from a file that turned out to be empty, for example. So you need to know: what does &max do in that case?

The first line of the subroutine sets $max_so_far by using shift on @_, the (now empty) parameter array. That's harmless; the array is left empty, and shift returns undef to $max_so_far.

Now the foreach loop wants to iterate over @_, but since that's empty, the loop body is executed zero times.

So in short order, Perl returns the value of $max_so_far- undef- as the return value of the subroutine. In some sense, that's the right answer because there is no largest value in an empty list.

Of course, whoever is calling this subroutine should be aware that the return value may be undefor they could simply ensure that the parameter list is never empty.

		2.4.7  Notes on Lexical (my) Variables
Those lexical variables can actually be used in any block, not merely in a subroutine's block. For example, they can be used in the block of an if, while, or foreach:

foreach (1..10) {
	  my($square) = $_ * $_;  # private variable in this loop
		    print "$_ squared is $square.\n";
}


The variable $square is private to the enclosing block; in this case, that's the block of the foreach loop. If there's no enclosing block, the variable is private to the entire source file. For now, your programs aren't going to use more than one source file, so this isn't an issue. But the important concept is that the scope of a lexical variable's name is limited to the smallest enclosing block or file. The only code that can say $square and mean that variable is the code inside that textual scope. This is a big win for maintainability - if the wrong value is found in $square, the culprit will be found within a limited amount of source code. As experienced programmers have learned (often the hard way), limiting the scope of a variable to a page of code, or even to a few lines of code, really speeds along the development and testing cycle.

Note also that the my operator doesn't change the context of an assignment:

my($num) = @_;  # list context, same as ($num) = @_;
my $num  = @_;  # scalar context, same as $num = @_;


In the first one, $num gets the first parameter, as a list-context assignment; in the second, it gets the number of parameters, in a scalar context. Either line of code could be what the programmer wanted; you can't tell from that one line alone, and so Perl can't warn you if you use the wrong one. (Of course, you wouldn't have both of those lines in the same subroutine, since you can't have two lexical variables with the same name declared in the same scope; this is just an example.) So, when reading code like this, you can always tell the context of the assignment by seeing what the context would be without the word my.

So long as we're discussing using my() with parentheses, it's worth remembering that without the parentheses, my only declares a single lexical variable:[*]

    [*] As usual, turning on warnings will generally report this abuse of my, or you can call 1-800-LEXICAL-ABUSE and report it yourself. Using the strict pragma, which we'll see in a moment, should forbid it outright.

    my $fred, $barney;        # WRONG! Fails to declare $barney
    my($fred, $barney);       # declares both


    Of course, you can use my to create new, private arrays as well:[dagger]

        [dagger] Or hashes, which you'll see in Chapter 6.

	my @phone_number;


	Any new variable will start out empty - undef for scalars, or the empty list for arrays.


		2.4.8  The use strict Pragma
Perl tends to be a pretty permissive language.[*] But maybe you want Perl to impose a little discipline; that can be arranged with the use strict pragma.

    [*] Bet you hadn't noticed.

    A pragma is a hint to a compiler, telling it something about the code. In this case, the use strict pragma tells Perl's internal compiler that it should enforce some good programming rules for the rest of this block or source file.

    Why would this be important? Well, imagine that you're composing your program, and you type a line like this one:

    $bamm_bamm = 3;  # Perl creates that variable automatically


    Now, you keep typing for a while. After that line has scrolled off the top of the screen, you type this line to increment the variable:

    $bammbamm += 1;  # Oops!


    Since Perl sees a new variable name (the underscore is significant in a variable name), it creates a new variable and increments that one. If you're lucky and smart, you've turned on warnings, and Perl can tell you that you used one or both of those global variable names only a single time in your program. But if you're merely smart, you used each name more than once, and Perl won't be able to warn you.

    To tell Perl that you're ready to be more restrictive, put the use strict pragma at the top of your program (or in any block or file where you want to enforce these rules):

	    use strict;  # Enforce some good programming rules


	    Now, among other restrictions,[dagger] Perl will insist that you declare every new variable, usually done with my:[double dagger]

	        [dagger] To learn about the other restrictions, see the documentation for strict. The documentation for any pragma is filed under that pragma's name, so the command perldoc strict (or your system's native documentation method) should find it for you. In brief, the other restrictions require that strings be quoted in most cases, and that references be true (hard) references. Neither of these restrictions should affect beginners in Perl.

		    [double dagger] There are some other ways to declare variables, too.

		    my $bamm_bamm = 3;  # New lexical variable


		    Now if you try to spell it the other way, Perl can complain that you haven't declared any variable called $bammbamm, so your mistake is automatically caught at compile time.

		    $bammbamm += 1;  # No such variable: Compile time fatal error


		    Of course, this applies only to new variables; you don't need to declare Perl's built-in variables, such as $_ and @_.[||] If you add use strict to a program that is already written, you'll generally get a flood of warning messages, so it's better to use it from the start, when it's needed.

		        [||] And, at least in some circumstances, you don't want to declare $a and $b because they're used internally by sort. So, if you're testing this feature, use other variable names than those two. The fact that use strict doesn't forbid these two is one of the most frequently reported nonbugs in Perl.

			Most people recommend that programs that are longer than a screenful of text generally need use strict. And we agree.

			From here on, most (but not all) of our examples will be written as if use strict is in effect, even where we don't show it. That is, we'll generally declare variables with my where it's appropriate. But, even though we don't always do so here, we encourage you to include use strict in your programs as often as possible.

		2.4.9  The return Operator
The return operator immediately returns a value from a subroutine:

my @names = qw/ fred barney betty dino wilma pebbles bamm-bamm /;
my $result = &which_element_is("dino", @names);

sub which_element_is {
	  my($what, @array) = @_;
	    foreach (0..$#array) {  # indices of @array's elements
		        if ($what eq $array[$_]) {
				      return $_;         # return early once found
					          }
			  }
	      -1;                    # element not found (return is optional here)
}


	This subroutine is being used to find the index of "dino" in the array @names. First, the my declaration names the parameters: there's $what, which is what we're searching for, and @array, an array of values to search within. That's a copy of the array @names, in this case. The foreach loop steps through the indices of @array (the first index is 0, and the last one is $#array, as you saw in Chapter 3).

	Each time through the foreach loop, we check to see whether the string in $what is equal[*] to the element from @array at the current index. If it's equal, we return that index at once. This is the most common use of the keyword return in Perl--to return a value immediately, without executing the rest of the subroutine.

	    [*] You noticed that we used the string equality test, eq, instead of the numeric equality test, ==, didn't you?

	    But what if we never found that element? In that case, the author of this subroutine has chosen to return -1 as a "value not found" code. It would be more Perlish, perhaps, to return undef in that case, but this programmer used -1. Saying return -1 on that last line would be correct, but the word return isn't really needed.

	    Some programmers like to use return every time there's a return value, as a means of documenting that it is a return value. For example, you might use return when the return value is not the last line of the subroutine, such as in the subroutine &larger_of_fred_or_barney, earlier in this chapter. It's not really needed, but it doesn't hurt anything. However, many Perl programmers believe it's just an extra seven characters of typing.

				2.4.9.1  Omitting the Ampersand

	    As promised, now we'll tell you the rule for when a subroutine call can omit the ampersand. If the compiler sees the subroutine definition before invocation, or if Perl can tell from the syntax that it's a subroutine call, the subroutine can be called without an ampersand, just like a built-in function. (But there's a catch hidden in that rule, as you'll see in a moment.)

	    This means that if Perl can see that it's a subroutine call without the ampersand, from the syntax alone, that's generally fine. That is, if you've got the parameter list in parentheses, it's got to be a function[*] call:

		[*] In this case, the function is the subroutine &shuffle. But it may be a built-in function, as you'll see in a moment.

		my @cards = shuffle(@deck_of_cards);  # No & necessary on &shuffle


		Or if Perl's internal compiler has already seen the subroutine definition, that's generally okay, too; in that case, you can even omit the parentheses around the argument list:

		sub division {
			  $_[0] / $_[1];                   # Divide first param by second
		}

	my $quotient = division 355, 113;  # Uses &division


	This works because of the rule that parentheses may always be omitted, except when doing so would change the meaning of the code.

	But don't put that subroutine declaration after the invocation, or the compiler won't know what the attempted invocation of division is all about. The compiler has to see the definition before the invocation in order to use the subroutine call as if it were a built-in.

	That's not the catch, though. The catch is this: if the subroutine has the same name as a Perl built-in, you must use the ampersand to call it. With an ampersand, you're sure to call the subroutine; without it, you can get the subroutine only if there's no built-in with the same name:

	sub chomp {
		  print "Munch, munch!\n";
	}

	&chomp;  # That ampersand is not optional!


	Without the ampersand, we'd be calling the built-in chomp, even though we've defined the subroutine &chomp. So, the real rule to use is this one: until you know the names of all of Perl's built-in functions, always use the ampersand on function calls. That means that you will use it for your first hundred programs or so. But when you see someone else has omitted the ampersand in his own code, it's not necessarily a mistake; perhaps he simply knows that Perl has no built-in with that name.[*] When programmers plan to call their subroutines as if they were calling Perl's built-ins, usually when writing modules, they often use prototypes to tell Perl about the parameters to expect. Making modules is an advanced topic, though; when you're ready for that, see Perl's documentation (in particular, the perlmod and perlsub documents) for more information about subroutine prototypes and making modules.

	    [*] Then again, maybe it is a mistake; you can search the perlfunc and perlop manpages for that name, though, to see whether it's the same as a built-in. And Perl will usually be able to warn you about this when you have warnings turned on.

			2.4.10 Nonscalar Return Values
	A scalar isn't the only kind of return value a subroutine may have. If you call your subroutine in a list context,[dagger] it can return a list of values.

	    [dagger] You can detect whether a subroutine is being evaluated in a scalar or list context using the wantarray function, which lets you easily write subroutines with specific list or scalar context values.

	    Suppose you wanted to get a range of numbers (as from the range operator, ..), except that you want to be able to count down as well as up. The range operator only counts upward, but that's easily fixed:

	    sub list_from_fred_to_barney {
		      if ($fred < $barney) {
				  # Count upwards from $fred to $barney
				  $fred..$barney;
				    } else {
						# Count downwards from $fred to $barney
						reverse $barney..$fred;
						  }
	    }
	$fred = 11;
	$barney = 6;
	@c = &list_from_fred_to_barney; # @c gets (11, 10, 9, 8, 7, 6)


	In this case, the range operator gives us the list from 6 to 11, then reverse reverses the list so that it goes from $fred (11) to $barney (6), just as we wanted.

	The least you can return is nothing at all. A return with no arguments will return undef in a scalar context or an empty list in a list context. This can be useful for an error return from a subroutine, signaling to the caller that a more meaningful return value is unavailable.

			2.4.11 Persistent, Private Variables
	With my we were able to make variables private to a subroutine, although each time we called the subroutine we had to define them again. With state, we can still have private variables scoped to the subroutine but Perl will keep their values between calls.

	Going back to our first example in this chapter, we had a subroutine named marine that incremented a variable:

	sub marine {
		  $n += 1;  # Global variable $n
			    print "Hello, sailor number $n!\n";
	}


	Now that we know about strict, we add that to our program and realize that our use of the global variable $n isn't allowed anymore. We can't make $n a lexical variable with my because it wouldn't retain its value.

	Declaring our variable with state tells Perl to retain the variable's value between calls to the subroutine and to make the variable private to the subroutine:

	use 5.010;

	sub marine {
		  state $n = 0;  # private, persistent variable $n
			    $n += 1;
		    print "Hello, sailor number $n!\n";
	}


	Now we can get the same output while being strict-clean and not using a global variable. The first time we call the subroutine, Perl declares and initializes $n. Perl ignores the statement on all subsequent calls. Between calls, Perl retains the value of $n for the next call to the subroutine.

	We can make any variable type a state variable; it's not just for scalars. Here's a subroutine that remembers its arguments and provides a running sum by using a state array:

	use 5.010;

	running_sum( 5, 6 );
	running_sum( 1..3 );
	running_sum( 4 );

	sub running_sum {
		  state $sum = 0;
		    state @numbers;

		      foreach my $number ( @_ ) {
				  push @numbers, $number;
				      $sum += $number;
					  }

			say "The sum of (@numbers) is $sum";
			  }


	This outputs a new sum each time we call it, adding the new arguments to all of the previous ones:

	The sum of (5 6) is 11
	The sum of (5 6 1 2 3) is 17
	The sum of (5 6 1 2 3 4) is 21


	There's a slight restriction on arrays and hashes as state variables, though. We can't initialize them in list context as of Perl 5.10:

	state @array = qw(a b c); # Error!


	This gives us an error that hints that we might be able to do it in a future version of Perl:

	Initialization of state variables in list context currently forbidden ...

			2.4.12 Exercises
#

	[12] Write a subroutine, named total, that returns the total of a list of numbers. (Hint: the subroutine should not perform any I/O; it should simply process its parameters and return a value to its caller.) Try it out in this sample program, which merely exercises the subroutine to see that it works. The first group of numbers should add up to 25.

	my @fred = qw{ 1 3 5 7 9 };
	my $fred_total = total(@fred);
	print "The total of \@fred is $fred_total.\n";
	print "Enter some numbers on separate lines: ";
	my $user_total = total(<STDIN>);
	print "The total of those numbers is $user_total.\n";


#

	[5] Using the subroutine from the previous problem, make a program to calculate the sum of the numbers from 1 to 1000.
#

	[18] Extra credit exercise: write a subroutine, called &above_average, that takes a list of numbers and returns the ones that are above the average (mean). (Hint: make another subroutine that calculates the average by dividing the total by the number of items.) Try your subroutine in this test program.

my @fred = above_average(1..10);
print "\@fred is @fred\n";
print "(Should be 6 7 8 9 10)\n";
my @barney = above_average(100, 1..10);
print "\@barney is @barney\n";
print "(Should be just 100)\n";


#

[10] Write a subroutine, named greet, that welcomes the person you name by telling them the name of the last person it greeted:

greet( "Fred" );
greet( "Barney" );


This sequence of statements should print:

Hi Fred! You are the first one here!
Hi Barney! Fred is also here!


#

[10] Modify the previous program to tell each new person the names of all of the people it has previously greeted:

greet( "Fred" );
greet( "Barney" );
greet( "Wilma" );
greet( "Betty" );


This sequence of statements should print:

Hi Fred! You are the first one here!
Hi Barney! I've seen: Fred
Hi Wilma! I've seen: Fred Barney
Hi Betty! I've seen: Fred Barney Wilma

My answers at: /cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic
ex_2_4_12.pl

	2.5 Input and output
We've already seen how to do some input/output (I/O) in order to make some of the earlier exercises possible. But now we'll learn more about those operations by covering the 80% of the I/O you'll need for most programs. If you're already familiar with the workings of standard input, output, and error streams, you're ahead of the game. If not, we'll get you caught up by the end of this chapter. For now, just think of "standard input" as being "the keyboard," and "standard output" as being "the display screen."

		2.5.1  Input from Standard Input
Reading from the standard input stream is easy. We've been doing it already with the <STDIN>  operator.[113] Evaluating this operator in a scalar context gives you the next line of input:

    [113] What we're calling the line-input operator here, <STDIN>, is actually a line-input operator (represented by the angle brackets) around a filehandle. You'll learn about filehandles later in this chapter.

    $line = <STDIN>;                # read the next line
    chomp($line);                   # and chomp it

    chomp($line = <STDIN>);         # same thing, more idiomatically


    Since the line-input operator will return undef when you reach end-of-file, this is handy for dropping out of loops:

    while (defined($line = <STDIN>)) {
	      print "I saw $line";
    }


There's a lot going on in that first line: we're reading the input into a variable, checking that it's defined, and if it is (meaning that we haven't reached the end of the input) we're running the body of the while loop. So, inside the body of the loop, we'll see each line, one after another, in $line.[*] This is something you'll want to do fairly often, so naturally Perl has a shortcut for it. The shortcut looks like this:

    [*] You probably noticed that we never chomped that input. In this kind of a loop, you can't really put chomp into the conditional expression, so it's often the first item in the loop body, when it's needed. We'll see examples of that in the next section.

    while (<STDIN>) {
	      print "I saw $_";
    }


Now, to make this shortcut, Larry chose some useless syntax. That is, this is literally saying, "Read a line of input, and see if it's true. (Normally it is.) And if it is true, enter the while loop, but throw away that line of input!" Larry knew that it was a useless thing to do; nobody should ever need to do that in a real Perl program. So, Larry took this useless syntax and made it useful.

What this is actually saying is that Perl should do the same thing as we saw in our earlier loop: it tells Perl to read the input into a variable, and (as long as the result was defined, so we haven't reached end-of-file) then enter the while loop. However, instead of storing the input into $line, Perl will use its favorite default variable, $_, just as if you had written this:

while (defined($_ = <STDIN>)) {
	  print "I saw $_";
}


Now, before we go any further, we must be very clear about something: this shortcut works only if you write it just as we did. If you put a line-input operator anywhere else (in particular, as a statement all on its own), it won't read a line into $_ by default. It works only if there's nothing but the line-input operator in the conditional of a while loop.[dagger] If you put anything else into the conditional expression, this shortcut won't apply.

    [dagger] Well, okay, the conditional of a for loop is just a while conditional in disguise, so it works there, too.

    There's otherwise no connection between the line-input operator (<STDIN>) and Perl's favorite default variable ($_). In this case, though, it just happens that the input is being stored in that variable.

    On the other hand, evaluating the line-input operator in a list context gives you all of the (remaining) lines of input as a listeach element of the list is one line:

    foreach (<STDIN>) {
	      print "I saw $_";
    }


Once again, there's no connection between the line-input operator and Perl's favorite default variable. In this case, though, the default control variable for foreach is $_. So in this loop, we'll see each line of input in $_, one after the other.

That may sound familiar, and for good reason: that's the same behavior the while loop would do. Isn't it?

The difference is under the hood. In the while loop, Perl reads a line of input, puts it into a variable, and runs the body of the loop. Then, it goes back to find another line of input. But in the foreach loop, the line-input operator is being used in a list context (since foreach needs a list to iterate through). So it has to read all of the input before the loop can start running. That difference will become apparent when the input is coming from your 400 MB web server logfile! It's generally best to use code like the while loop's shortcut, which will process input a line at a time, whenever possible.

		2.5.2  Input from the Diamond Operator
Another way to read input is with the diamond[*] operator: <>. This is useful for making programs that work like standard Unix[dagger] utilities, with respect to the invocation arguments (which we'll see in a moment). If you want to make a Perl program that can be used like the utilities cat, sed, awk, sort, grep, lpr, and many others, the diamond operator will be your friend. If you want to make anything else, the diamond operator probably won't help.

    [*] The diamond operator was named by Larry's daughter, Heidi, when Randal went over to Larry's house one day to show off the new training materials he'd been writing and complained that there was no spoken name for "that thing." Larry didn't have a name for it, either. Heidi (eight years old at the time) quickly chimed in, "That's a diamond, Daddy." So the name stuck. Thanks, Heidi!

        [dagger] But not just on Unix systems. Many other systems have adopted this way of using invocation arguments.

	The invocation arguments to a program are normally a number of "words" on the command line after the name of the program.[double dagger] In this case, they give the names of the files your program will process in sequence:

	    [double dagger] Whenever a program is started, it has a list of zero or more invocation arguments, supplied by whatever program is starting it. Often this is the shell, which makes up the list depending upon what you type on the command line. But we'll see later that you can invoke a program with pretty much any strings as the invocation arguments. Because they often come from the shell's command line, they are sometimes called "command-line arguments" as well.

	    $ ./my_program fred barney betty


	    That command means to run the command my_program (which will be found in the current directory), and that the program should process file fred, followed by file barney, followed by file betty.

	    If you give no invocation arguments, the program should process the standard input stream. Or, as a special case, if you give just a hyphen as one of the arguments, that means standard input as well.[*] So, if the invocation arguments had been fred - betty, that would have meant that the program should process file fred, followed by the standard input stream, followed by file betty.

	        [*] Here's a possibly unfamiliar Unix fact: most of those standard utilities, like cat and sed, use this same convention, where a hyphen stands for the standard input stream.

		The benefit of making your programs work like this is that you may choose where the program gets its input at runtime; for example, you won't have to rewrite the program to use it in a pipeline (which we'll discuss more later). Larry put this feature into Perl because he wanted to make it easy for you to write your own programs that work like standard Unix utilities - even on non-Unix machines. Actually, he did it so he could make his own programs work like standard Unix utilities; since some vendors' utilities don't work just like others', Larry could make his own utilities, deploy them on a number of machines, and know that they'd all have the same behavior. Of course, this meant porting Perl to every machine he could find.

		The diamond operator is actually a special kind of line-input operator. But instead of getting the input from the keyboard, it comes from the user's choice of input:[dagger]

		    [dagger] Which may or may not include getting input from the keyboard.

		    while (defined($line = <>)) {
			      chomp($line);
			        print "It was $line that I saw!\n";
		    }


So, if we run this program with the invocation arguments fred, barney, and betty, it will say something like: "It was [a line from file fred] that I saw!", "It was [another line from file fred] that I saw!", on and on until it reaches the end of file fred. Then, it will automatically go on to file barney, printing out one line after another, and then on through file betty. Note that there's no break when we go from one file to another; when you use the diamond, it's as if the input files have been merged into one big file.[double dagger] The diamond will return undef (and we'll drop out of the while loop) only at the end of all of the input.

    [double dagger] If it matters to you, or even if it doesn't, the current file's name is kept in Perl's special variable $ARGV. This name may be "-" instead of a real filename if the input is coming from the standard input stream, though.

    In fact, since this is just a special kind of line-input operator, we may use the same shortcut we saw earlier to read the input into $_ by default:

    while (<>) {
	      chomp;
	        print "It was $_ that I saw!\n";
    }


This works like the loop above, but with less typing. And you may have noticed that we're using the default for chomp; without an argument, chomp will work on $_. Every little bit of saved typing helps!

Since the diamond operator is generally being used to process all of the input, it's typically a mistake to use it in more than one place in your program. If you find yourself putting two diamonds into the same program, especially using the second diamond inside the while loop that is reading from the first one, it's almost certainly not going to do what you would like.[*] In our experience, when beginners put a second diamond into a program, they meant to use $_ instead. Remember, the diamond operator reads the input, but the input itself is (generally, by default) found in $_.

    [*] If you reinitialize @ARGV before using the second diamond, then you're on solid ground. We'll see @ARGV in the next section.

    If the diamond operator can't open one of the files and read from it, it'll print an allegedly helpful diagnostic message, such as:

    can't open wimla: No such file or directory


    The diamond operator will then go on to the next file automatically, much like what you'd expect from cat or another standard utility.

		2.5.3  The Invocation Arguments
Technically, the invocation diamond operator isn't literally looking at the invocation arguments-it works from the @ARGV array. This array is a special array that is preset by the Perl interpreter as the list of the invocation arguments. In other words, this is just like any other array, (except for its funny, all-caps name), but when your program starts, @ARGV is already stuffed full of the list of invocation arguments.[dagger]

    [dagger] C programmers may be wondering about argc (there isn't one in Perl), and what happened to the program's own name (that's found in Perl's special variable $0, not @ARGV). Also, depending upon how you've invoked your program, there may be a little more happening than we say here. See the perlrun manpage for the full details.

    You can use @ARGV just like any other array; you could shift items off of it, perhaps, or use foreach to iterate over it. You could even check to see if any arguments start with a hyphen, so that you could process them as invocation options (like Perl does with its own -w option).[double dagger]

        [double dagger] If you need more than just one or two such options, you should almost certainly use a module to process them in a standard way. See the documentation for the Getopt::Long and Getopt::Std modules, which are part of the standard distribution.

	The diamond operator looks in @ARGV to determine what filenames it should use. If it finds an empty list, it uses the standard input stream; otherwise it uses the list of files that it finds. This means that after your program starts and before you start using the diamond, you've got a chance to tinker with @ARGV. For example, here we can process three specific files, regardless of what the user chose on the command line:

	@ARGV = qw# larry moe curly #;  # force these three files to be read
	while (<>) {
		  chomp;
		    print "It was $_ that I saw in some stooge-like file!\n";
	}

		2.5.4  Output to Standard Output
The print operator takes a list of values and sends each item (as a string, of course) to standard output in turn, one after another. It doesn't add any extra characters before, after, or in between the items;[*] if you want spaces between items and a newline at the end, you have to say so:

    [*] Well, it doesn't add anything extra by default, but this default (like so many others in Perl) may be changed. Changing these defaults will likely confuse your maintenance programmer, though, so avoid doing so except in small, quick-and-dirty programs, or (rarely) in a small section of a normal program. See the perlvar manpage to learn about changing the defaults.

    $name = "Larry Wall";
    print "Hello there, $name, did you know that 3+4 is ", 3+4, "?\n";


    Of course, that means that there's a difference between printing an array and interpolating an array:

    print @array;     # print a list of items
    print "@array";   # print a string (containing an interpolated array)


    That first print statement will print a list of items, one after another, with no spaces in between. The second one will print exactly one item, which is the string you get by interpolating @array into the empty string-that is, it prints the contents of @array, separated by spaces.[dagger] So, if @array holds qw/ fred barney betty /,[double dagger] the first one prints fredbarneybetty, while the second prints fred barney betty separated by spaces.

        [dagger] Yes, the spaces are another default; see the perlvar manpage again.

	    [double dagger] You know that we mean a three-element list here, right? This is just Perl notation.

	    But before you decide to always use the second form, imagine that @array is a list of unchomped lines of input. That is, imagine that each of its strings has a trailing newline character. Now, the first print statement prints fred, barney, and betty on three separate lines. But the second one prints this:

	     fred
	       barney
	         betty


		 Do you see where the spaces come from? Perl is interpolating an array, so it puts spaces between the elements. So, we get the first element of the array (fred and a newline character), then a space, then the next element of the array (barney and a newline character), then a space, then the last element of the array (betty and a newline character). The result is that the lines seem to have become indented, except for the first one. Every week or two, a mailing list or forum has a message with a subject line something like:

		     Perl indents everything after the first line

		     Without even reading the message, we can immediately see that the program used double quotes around an array containing unchomped strings. "Did you perhaps put an array of unchomped strings inside double quotes?" we ask, and the answer is always yes.

		     Generally, if your strings contain newlines, you simply want to print them, after all:

		     print @array;


		     But if they don't contain newlines, you'll generally want to add one at the end:

		     print "@array\n";


		     So, if you're using the quote marks, you'll be (generally) adding the \n at the end of the string anyway; this should help you to remember which is which.

		     It's normal for your program's output to be buffered. That is, instead of sending out every little bit of output at once, it'll be saved until there's enough to bother with. If (for example) you're going to save the output to disk, it's (relatively) slow and inefficient to spin the disk every time we add one or two characters to the file. Generally, then, the output will go into a buffer that is flushed (that is, actually written to disk or wherever) only when the buffer gets full or when the output is otherwise finished (such as at the end of runtime). Usually, that's what you want.

		     But if you (or a program) may be waiting impatiently for the output, you may wish to take that performance hit and flush the output buffer each time you print. See the Perl manpages for more information on controlling buffering in that case.

		     Since print is looking for a list of strings to print, its arguments are evaluated in list context. Since the diamond operator (as a special kind of line-input operator) will return a list of lines in a list context, these can work well together:

		     print <>;          # source code for 'cat'

		     print sort <>;     # source code for 'sort'


		     Well, to be fair, the standard Unix commands cat and sort do have some additional functionality that these replacements lack. But you can't beat them for the price! You can now reimplement all of your standard Unix utilities in Perl and painlessly port them to any machine that has Perl, whether that machine is running Unix or not. And you can be sure that the programs on every different type of machine will nevertheless have the same behavior.[*]

		         [*] In fact, the PPT (Perl Power Tools) project, whose goal was to implement all of the classic Unix utilities in Perl, completed nearly all the utilities (and most of the games!) but got bogged down when they got to reimplementing the shell. The PPT project has been helpful because it has made these standard utilities available on many non-Unix machines.

			 What might not be obvious is that print has optional parentheses, which can sometimes cause confusion. Remember the rule that parentheses in Perl may always be omitted, except when doing so would change the meaning of a statement. So, here are two ways to print the same thing:

			 print("Hello, world!\n");
			 print "Hello, world!\n";


			 So far, so good. But another rule in Perl is that if the invocation of print looks like a function call, then it is a function call. It's a simple rule, but what does it mean for something to look like a function call?

			 In a function call, there's a function name immediately[dagger] followed by parentheses around the function's arguments, like this:

			     [dagger] We say "immediately" here because Perl won't permit a newline character between the function name and the opening parenthesis in this kind of function call. If there is a newline there, Perl sees your code as making a list operator, rather than a function call. This is the kind of piddling technical detail that we mention only for completeness. If you're terminally curious, see the full story in the manpages.

			     print (2+3);


			     That looks like a function call, so it is a function call. It prints 5, but then it returns a value like any other function. The return value of print is a true or false value, indicating the success of the print. It nearly always succeeds, unless you get some I/O error, so the $result in the following statement will normally be 1:

			     $result = print("hello world!\n");


			     But what if you used the result in some other way? Let's suppose you decide to multiply the return value times four:

			     print (2+3)*4;  # Oops!


			     When Perl sees this line of code, it prints 5, just as you asked. Then it takes the return value from print, which is 1, and multiplies that times 4. It then throws away the product, wondering why you didn't tell it to do something else with it. And at this point, someone looking over your shoulder says, "Hey, Perl can't do math! That should have printed 20, rather than 5!"

			     This is the problem with the optional parentheses; sometimes we humans forget where the parentheses really belong. When there are no parentheses, print is a list operator, printing all of the items in the following list; that's generally what you'd expect. But when the first thing after print is a left parenthesis, print is a function call, and it will print only what's found inside the parentheses. Since that line had parentheses, it's the same to Perl as if you'd said this:

			     ( print(2+3) ) * 4;  # Oops!


			     Fortunately, Perl itself can almost always help you with this, if you ask for warningsso use -w, or use warnings, at least during program development and debugging.

			     Actually, this rule"If it looks like a function call, it is a function call"applies to all list functions[*] in Perl, not just to print. It's just that you're most likely to notice it with print. If print (or another function name) is followed by an opening parenthesis, make sure that the corresponding closing parenthesis comes after all of the arguments to that function.

			         [*] Functions that take zero or one arguments don't suffer from this problem.

		2.5.5  Formatted Output with printf
You may wish to have a little more control with your output than print provides. In fact, you may be accustomed to the formatted output of C's printf function. Fear not-Perl provides a comparable operation with the same name.

The printf operator takes a format string followed by a list of things to print. The format[dagger] string is a fill-in-the-blanks template showing the desired form of the output:

    [dagger] Here, we're using "format" in the generic sense. Perl has a report-generating feature called "formats" that we won't even be mentioning (except in this footnote) until Appendix B, and then only to say that we really aren't going to talk about it. So, you're on your own there. Just wanted to keep you from getting lost.

    printf "Hello, %s; your password expires in %d days!\n",
      $user, $days_to_die;


The format string holds a number of so-called conversions; each conversion begins with a percent sign (%) and ends with a letter. (As we'll see in a moment, there may be significant extra characters between these two symbols.) There should be the same number of items in the following list as there are conversions; if these don't match up, it won't work correctly. In the example above, there are two items and two conversions, so the output might look something like this:

Hello, merlyn; your password expires in 3 days!


There are many possible printf conversions, so we'll take time here to describe just the most common ones. Of course, the full details are available in the perlfunc manpage.

To print a number in what's generally a good way, use %g,[*] which automatically chooses floating-point, integer, or even exponential notation as needed:

    [*] "General" numeric conversion. Or maybe a "Good conversion for this number" or "Guess what I want the output to look like."

    printf "%g %g %g\n", 5/2, 51/17, 51 ** 17;  # 2.5 3 1.0683e+29


    The %d format means a decimal[dagger] integer, truncated as needed:

        [dagger] There's also %x for hexadecimal and %o for octal if you need those. But we really say "decimal" here as a memory aid: %d for decimal integer.

	printf "in %d days!\n", 17.85;  # in 17 days!


	Note that this is truncated, not rounded; we'll see how to round off a number in a moment.

	In Perl, printf is most often used for columnar data, since most formats accept a field width. If the data won't fit, the field will generally be expanded as needed:

	printf "%6d\n", 42;  # output like ````42 (the ` symbol stands for a space)
	printf "%2d\n", 2e3 + 1.95;  # 2001


	The %s conversion means a string, so it effectively interpolates the given value as a string, but with a given field width:

	printf "%10s\n", "wilma";  # looks like `````wilma


	A negative field width is left-justified (in any of these conversions):

		printf "%-15s\n", "flintstone";  # looks like flintstone`````


		The %f conversion (floating-point) rounds off its output as needed, and even lets you request a certain number of digits after the decimal point:

		printf "%12f\n", 6 * 7 + 2/3;    # looks like ```42.666667
		printf "%12.3f\n", 6 * 7 + 2/3;  # looks like ``````42.667
		printf "%12.0f\n", 6 * 7 + 2/3;  # looks like ``````````43


		To print a real percent sign, use %%, which is special in that it uses no element from the list:[double dagger]

		    [double dagger] Maybe you thought you could simply put a backslash in front of the percent sign. Nice try, but no. The reason that won't work is that the format is an expression, and the expression "\%" means the one-character string '%'. Even if we got a backslash into the format string, printf wouldn't know what to do with it. Besides, C programmers are used to printf working like this.

		    printf "Monthly interest rate: %.2f%%\n",
		      5.25/12;  # the value looks like "0.44%"


		      5.5.1. Arrays and printf

		      Generally, you won't use an array as an argument to printf. That's because an array may hold any number of items, and a given format string will work with only a certain fixed number of items: if there are three conversions in the format, there must be exactly three items.

		      But there's no reason you can't whip up a format string on the fly, since it may be any expression. This can be tricky to get right, though, so it may be handy (especially when debugging) to store the format into a variable:

		      my @items = qw( wilma dino pebbles );
		      my $format = "The items are:\n" . ("%10s\n" x @items);
## print "the format is >>$format<<\n"; # for debugging
		      printf $format, @items;


		      This uses the x operator (which we learned about in Chapter 2) to replicate the given string a number of times given by @items (which is being used in a scalar context). In this case, that's 3, since there are three items, so the resulting format string is the same as if we had written it as The items are:\n%10s\n%10s\n%10s\n. And the output prints each item on its own line, right-justified in a 10-character column, under a heading line. Pretty cool, huh? But not cool enough because you can even combine these:

		      printf "The items are:\n".("%10s\n" x @items), @items;


		      Note that here we have @items being used once in a scalar context, to get its length, and once in a list context, to get its contents. Context is important.

		2.5.6  Filehandles
		A filehandle is the name in a Perl program for an I/O connection between your Perl process and the outside world. That is, it's the name of a connection, not necessarily the name of a file.

		Filehandles are named like other Perl identifiers (with letters, digits, and underscores, but they can't start with a digit), though since they don't have any prefix character they might be confused with present or future reserved words, or with labels, which we cover in Chapter 10. Once again, as with labels, the recommendation from Larry is that you use all uppercase letters in the name of your filehandlenot only will it stand out better, but it will also guarantee that your program won't fail when a future (lowercase) reserved word is introduced.

		But there are also six special filehandle names that Perl already uses for its own purposes: STDIN, STDOUT, STDERR, DATA, ARGV, and ARGVOUT.[*] Although you may choose any filehandle name you'd like, you shouldn't choose one of those six unless you intend to use that one's special properties.[dagger]

		    [*] Some people hate typing in all caps, even for a moment, and will try spelling these in lowercase, like stdin. Perl may even let you get away with that from time to time, but not always. The details of when these work and when they fail are beyond the scope of this book. But the important thing is that programs that rely upon this kindness will one day break, so it is best to avoid lowercase here.

		        [dagger] In some cases, you could (re)use these names without a problem. But your maintenance programmer may think that you're using the name for its built-in features, and thus may be confused.

			Maybe you recognized some of those names already. When your program starts, STDIN is the filehandle naming the connection between the Perl process and wherever the program should get its input, known as the standard input stream. This is generally the user's keyboard unless the user asked for something else to be the source of input, such as a file or the output of another program through a pipe.[double dagger] There's also the standard output stream, which is STDOUT. By default, this one goes to the user's display screen, but the user may send the output to a file or to another program, as we'll see shortly. These standard streams come to us from the Unix "standard I/O" library, but they work in much the same way on most modern operating systems.[||] The general idea is that your program should blindly read from STDIN and blindly write to STDOUT, trusting in the user (or generally whichever program is starting your program) to have set those up. In that way, the user can type a command like this one at the shell prompt:

			    [double dagger] The defaults we speak of in this chapter for the three main I/O streams are what the Unix shells do by default. But it's not just shells that launch programs, of course. We'll see in Chapter 16 what happens when you launch another program from Perl.

			        [||] If you're not already familiar with how your non-Unix system provides standard input and output, see the perlport manpage and the documentation for that system's equivalent to the Unix shell (the program that runs programs based upon your keyboard input).

				$ ./your_program <dino >wilma


				That command tells the shell that the program's input should be read from the file dino, and the output should go to the file wilma. As long as the program blindly reads its input from STDIN, processes it (in whatever way we need), and blindly writes its output to STDOUT, this will work just fine.

				And at no extra charge, the program will work in a pipeline. This is another concept from Unix, which lets us write command lines like this one:

				$ cat fred barney | sort | ./your_program | grep something | lpr


				Now, if you're not familiar with these Unix commands, that's okay. This line says that the cat command should print out all of the lines of file fred followed by all of the lines of file barney. Then that output should be the input of the sort command, which sorts those lines and passes them on to your_program. After it has done its processing, your_program will send the data on to grep, which discards certain lines in the data, sending the others on to the lpr command, which should print everything that it gets on a printer. Whew!

				Pipelines like that are common in Unix and many other systems today because they let you build powerful, complex commands out of simple, standard building blocks. Each building block does one thing very well, and it's your job to use them together in the right way.

				There's one more standard I/O stream. If (in the previous example) your_program had to emit any warnings or other diagnostic messages, those shouldn't go down the pipeline. The grep command is set to discard anything that it hasn't specifically been told to look for, and so it will most likely discard the warnings. Even if it did keep the warnings, you probably don't want to pass them downstream to the other programs in the pipeline. So that's why there's also the standard error stream: STDERR. Even if the standard output is going to another program or file, the errors will go to wherever the user desires. By default, the errors will generally go to the user's display screen,[*] but the user may send the errors to a file with a shell command like this one:

				    [*] Also, generally, errors aren't buffered. That means that if the standard error and standard output streams are both going to the same place (such as the monitor), the errors may appear earlier than the normal output. For example, if your program prints a line of ordinary text, then tries to divide by zero, the output may show the message about dividing by zero first, and the ordinary text second.

				    $ netstat | ./your_program 2>/tmp/my_errors


		2.5.7  Opening a Filehandle
So you've seen that Perl provides three filehandles- STDIN, STDOUT, and STDERR -which are automatically open to files or devices established by the program's parent process (probably the shell). When you need other filehandles, use the open operator to tell Perl to ask the operating system to open the connection between your program and the outside world. Here are some examples:

open CONFIG, "dino";
open CONFIG, "<dino";
open BEDROCK, ">fred";
open LOG, ">>logfile";


The first one opens a filehandle called CONFIG to a file called dino. That is, the (existing) file dino will be opened and whatever it holds will come into our program through the filehandle named CONFIG. This is similar to the way that data from a file could come in through STDIN if the command line had a shell redirection like <dino. In fact, the second example uses exactly that sequence. The second does the same as the first, but the less-than sign explicitly says "use this filename for input," even though that's the default.[*]

    [*] This may be important for security reasons. As we'll see in a moment (and in further detail in Chapter 14), there are a number of magical characters that may be used in filenames. If $name holds a user-chosen filename, simply opening $name will allow any of these magical characters to come into play. This could be a convenience to the user, or it could be a security hole. But opening "< $name" is much safer, since it explicitly says to open the given name for input. Still, this doesn't prevent all possible mischief. For more information on different ways of opening files, especially when security may be a concern, see the perlopentut manpage.

    Although you don't have to use the less-than sign to open a file for input, we include that because, as you can see in the third example, a greater-than sign means to create a new file for output. This opens the filehandle BEDROCK for output to the new file fred. Just as when the greater-than sign is used in shell redirection, we're sending the output to a new file called fred. If there's already a file of that name, we're asking to wipe it out and replace it with this new one.

    The fourth example shows how two greater-than signs may be used (again, as the shell does) to open a file for appending. That is, if the file already exists, we will add new data at the end. If it doesn't exist, it will be created in much the same way as if we had used just one greater-than sign. This is handy for logfiles; your program could write a few lines to the end of a logfile each time it's run. So that's why the fourth example names the filehandle LOG and the file logfile.

    You can use any scalar expression in place of the filename specifier, although typically you'll want to be explicit about the direction specification:

    my $selected_output = "my_output";
    open LOG, "> $selected_output";


    Note the space after the greater-than. Perl ignores this,[dagger] but it keeps unexpected things from happening if $selected_output were ">passwd" for example (which would make an append instead of a write).

        [dagger] Yes, this means that if your filename were to have leading whitespace, that would also be ignored by Perl. See perlfunc and perlopentut if you're worried about this.

	In modern versions of Perl (starting with Perl 5.6), you can use a "three-argument" open:

	open CONFIG, "<", "dino";
	open BEDROCK, ">", $file_name;
	open LOG, ">>", &logfile_name();


	The advantage here is that Perl never confuses the mode (the second argument) with some part of the filename (the third argument), which has nice advantages for security.[*] However, if you need your Perl to be backward compatible with older Perl versions (such as when you are contributing to the CPAN), either avoid these forms, or mark your Perl sources as being compatible only with newer Perls.[dagger]

	    [*] The disadvantage for security is that, presumably, you're letting a possibly-malicious user inject possibly-malicious characters into the delicate workings of your innocent program. Once we learn about regular expressions (starting in Chapter 7) you'll be able to use those to enforce some sanity checks on user input. And if your program will have possibly-malicious users, read up on Perl's helpful security features in the Alpaca book, in the perlsec manpage, or both.

	        [dagger] Via use 5.6, for example.

		We'll see how to use these filehandles later in this chapter. But first¿

			2.5.7.1  Bad Filehandles

		Perl can't actually open a file all by itself. Like any other programming language, Perl can merely ask the operating system to let us open a file. Of course, the operating system may refuse because of permission settings, an incorrect filename, or other reasons.

		If you try to read from a bad filehandle (that is, a filehandle that isn't properly open), you'll see an immediate end-of-file. (With the I/O methods we'll see in this chapter, end-of-file will be indicated by undef in a scalar context or an empty list in a list context.) If you try to write to a bad filehandle, the data is silently discarded.

		Fortunately, these dire consequences are easy to avoid. First of all, if we ask for warnings with -w or the warnings pragma, Perl will generally be able to tell us with a warning when it sees that we're using a bad filehandle. But even before that, open always tells us if it succeeded or failed, by returning true for success or false for failure. So you could write code like this:

		my $success = open LOG, ">>logfile";  # capture the return value
		if ( ! $success) {
			  # The open failed
			  ...
		}


Well, you could do it like that, but there's another way that we'll see in the next section.

			2.5.7.2 Closing a Filehandle

When you are finished with a filehandle, you may close it with the close operator like this:

close BEDROCK;


Closing a filehandle tells Perl to inform the operating system that we're all done with the given data stream, so any last output data should be written to disk in case someone is waiting for it.[*] Perl will automatically close a filehandle if you reopen it (that is, if you reuse the filehandle name in a new open) or if you exit the program.[dagger]

    [*] If you know much about I/O systems, you'll know there's more to the story. Generally, though, when a filehandle is closed, here's what happens. If there's input remaining in a file, it's ignored. If there's input remaining in a pipeline, the writing program may get a signal that the pipeline is closed. If there's output going to a file or pipeline, the buffer is flushed (that is, pending output is sent on its way). If the filehandle had a lock, the lock is released. See your system's I/O documentation for further details.

        [dagger] Any exit from the program will close all filehandles, but if Perl itself breaks, pending output buffers won't get flushed. That is to say, if you accidentally crash your program by dividing by zero, for example, Perl itself is still running. Perl will ensure that data you've written actually gets output in that case. But if Perl itself can't run (because you ran out of memory or caught an unexpected signal), the last few pieces of output may not be written to disk. Usually, this isn't a big issue.

	Because of this, many simple Perl programs don't bother with close. But it's there if you want to be tidy, with one close for every open. In general, it's best to close each filehandle soon after you're done with it, though the end of the program often arrives soon enough.[double dagger]

	    [double dagger] Closing a filehandle will flush any output buffers and release any locks on the file. Since someone else may be waiting for those things, a long-running program should generally close each filehandle as soon as possible. But many of our programs will take only one or two seconds to run to completion, so this may not matter. Closing a filehandle also releases possibly limited resources, so it's more than just being tidy.
		2.5.8  Fatal Errors with die
Let's step aside for a moment. We need some stuff that isn't directly related to (or limited to) I/O, but is more about getting out of a program earlier than normal.

When a fatal error happens inside Perl (for example, if you divide by zero, use an invalid regular expression, or call a subroutine that hasn't been declared), your program stops with an error message telling why.[||] But this functionality is available to us with the die function, so we can make our own fatal errors.

    [||] Well, it does this by default, but errors may be trapped with an eval block, as we'll see in Chapter 17.

The die function prints out the message you give it (to the standard error stream, where such messages should go) and makes sure that your program exits with a nonzero exit status.

You may not have known it, but every program that runs on Unix (and many other modern operating systems) has an exit status, telling whether it was successful or not. Programs that run other programs (like the make utility program) look at that exit status to see that everything happened correctly. The exit status is just a single byte, so it can't say much; traditionally, it is 0 for success and a nonzero value for failure. Perhaps 1 means a syntax error in the command arguments, while 2 means that something went wrong during processing, and 3 means the configuration file couldn't be found; the details differ from one command to the next. But 0 always means that everything worked. When the exit status shows failure, a program like make knows not to go on to the next step.

So we could rewrite the previous example, perhaps like this:

if ( ! open LOG, ">>logfile") {
  die "Cannot create logfile: $!";
}


If the open fails, die will terminate the program and tell you that it cannot create the logfile. But what's that $! in the message? That's the human-readable complaint from the system. In general, when the system refuses to do something we've requested (like opening a file), $! will give you a reason (perhaps "permission denied" or "file not found," in this case). This is the string that you may have obtained with perror in C or a similar language. This human-readable complaint message will be available in Perl's special variable $!.[*] It's a good idea to include $! in the message when it could help the user to figure out what he or she did wrong. But if you use die to indicate an error that is not the failure of a system request, don't include $!, since it will generally hold an unrelated message left over from something Perl did internally. It will hold a useful value only immediately after a failed system request. A successful request won't leave anything useful there.

    [*] On some non-Unix operating systems, $! may say something like error number 7, leaving it up to the user to look that one up in the documentation. On Windows and VMS, the variable $^E may have additional diagnostic information.

There's one more thing that die will do for you: it will automatically append the Perl program name and line number[dagger] to the end of the message, so you can easily identify which die in your program is responsible for the untimely exit. The error message from the previous code might look like this, if $! contained the message permission denied:

    [dagger] If the error happened while reading from a file, the error message will include the "chunk number" (usually the line number) from the file and the name of the filehandle as well, since those are often useful in tracking down a bug.

Cannot create logfile: permission denied at your_program line 1234.


That's pretty helpful--in fact, we always seem to want more information in our error messages than we included the first time around. If you don't want the line number and file revealed, make sure that the dying words have a newline on the end. That is, another way you could use die is with a trailing newline on the message:

if (@ARGV < 2) {
  die "Not enough arguments\n";
}


If there aren't at least two command-line arguments, the program will say so and quit. It won't include the program name and line number, as the line number is of no use to the user (this is the user's error, after all). As a rule of thumb, put the newline on messages that indicate a usage error and leave it off when it the error might be something you want to track down during debugging.[*]

    [*] The program's name is in Perl's special variable $0, so you may wish to include that in the string: $0:Not enough arguments\n. This is useful if the program may be used in a pipeline or shell script, for example, where it's not obvious which command is complaining. $0 can be changed during the execution of the program, however. You might also want to look into the special __FILE__ and __LINE__ tokens (or the caller function) to get the information that is being left out by adding the newline, so you can print it in your own choice of format.

You should always check the return value of open, since the rest of the program is relying upon its success.

			2.5.8.1  Warning Messages with warn

Just as die can indicate a fatal error that acts like one of Perl's built-in errors (like dividing by zero), you can use the warn function to cause a warning that acts like one of Perl's built-in warnings (like using an undef value as if it were defined, when warnings are enabled).

The warn function works just like die does, except for that last step--it doesn't actually quit the program. But it adds the program name and line number if needed, and it prints the message to standard error, just as die would.[dagger]

    [dagger] Warnings can't be trapped with an eval block, like fatal errors can be. But see the documentation for the __WARN__ pseudosignal (in the perlvar manpage) if you need to trap a warning.

And having talked about death and dire warnings, we now return you to your regularly scheduled I/O instructional material. Read on.

		2.5.9  Using Filehandles
Once a filehandle is open for reading, you can read lines from it just like you can read from standard input with STDIN. So, for example, to read lines from the Unix password file:

if ( ! open PASSWD, "/etc/passwd") {
  die "How did you get logged in? ($!)";
}

while (<PASSWD>) {
  chomp;
  ...
}


In this example, the die message uses parentheses around $!. Those are merely parentheses around the message in the output. (Sometimes a punctuation mark is just a punctuation mark.) As you can see, what we've been calling the "line-input operator" is really made of two components; the angle brackets (the real line-input operator) are around an input filehandle.

A filehandle open for writing or appending may be used with print or printf, appearing immediately after the keyword but before the list of arguments:

print LOG "Captain's log, stardate 3.14159\n";  # output goes to LOG
printf STDERR "%d percent complete.\n", $done/$total * 100;


Did you notice that there's no comma between the filehandle and the items to be printed?[*] This looks especially weird if you use parentheses. Either of these forms is correct:

    [*] If you got straight A's in freshman English or Linguistics, when we say that this is called "indirect object syntax," you may say "Ah, of course! I see why there's no comma after the filehandle name--it's an indirect object!" We didn't get straight A's. We don't understand why there's no comma; we merely omit it because Larry told us that we should omit the comma.

printf (STDERR "%d percent complete.\n", $done/$total * 100);
printf STDERR ("%d percent complete.\n", $done/$total * 100);


			2.5.9.1  Changing the Default Output Filehandle

By default, if you don't give a filehandle to print (or to printf, as everything we say here about one applies equally well to the other), the output will go to STDOUT. But that default may be changed with the select operator. Here we'll send some output lines to BEDROCK:

select BEDROCK;
print "I hope Mr. Slate doesn't find out about this.\n";
print "Wilma!\n";


Once you've selected a filehandle as the default for output, it will stay that way. But it's usually a bad idea to confuse the rest of the program, so you should generally set it back to STDOUT when you're done.[dagger] Also by default, the output to each filehandle is buffered. Setting the special $| variable to 1 will set the currently selected filehandle (that is, the one selected at the time that the variable is modified) to always flush the buffer after each output operation. So if you wanted to be sure that the logfile gets its entries at once, in case you might be reading the log to monitor progress of your long-running program, you could use something like this:

    [dagger] In the unlikely case that STDOUT might not be the selected filehandle, you could save and restore the filehandle, using the technique shown in the documentation for select in the perlfunc manpage. And as long as we're sending you to that manpage, we may as well tell you that there are actually two built-in functions in Perl named select, and both are covered in the perlfunc manpage. The other select always has four arguments, so it's sometimes called "four-argument select."

select LOG;
$| = 1;  # don't keep LOG entries sitting in the buffer
select STDOUT;
# ... time passes, babies learn to walk, tectonic plates shift, and then...
print LOG "This gets written to the LOG at once!\n";

		2.5.10 Reopening a Standard Filehandle
We mentioned earlier that if you were to reopen a filehandle (that is, if you were to open a filehandle FRED when you've already got an open filehandle named FRED, say), the old one would be closed for you automatically. And we said that you shouldn't reuse one of the six standard filehandle names unless you intended to get that one's special features. And we also said that the messages from die and warn, along with Perl's internally generated complaints, go automatically to STDERR. If you put those three pieces of information together, you now have an idea about how you could send error messages to a file, rather than to your program's standard error stream:[*]

    [*] Don't do this without a reason. It's nearly always better to let the user set up redirection when launching your program, rather than have redirection hardcoded. But this is handy in cases where your program is being run automatically by another program (say, by a web server or a scheduling utility like cron or at). Another reason might be that your program is going to start another process (probably with system or exec, which we'll see in ) Chapter 16, and you need that process to have different I/O connections.

# Send errors to my private error log
if ( ! open STDERR, ">>/home/barney/.error_log") {
  die "Can't open error log for append: $!";
}


After reopening STDERR, any error messages from Perl will go into the new file. But what happens if the die is executed--where will that message go, if the new file couldn't be opened to accept the messages?

The answer is that if one of the three system filehandles--STDIN, STDOUT, or STDERR--fails to reopen, Perl kindly restores the original one.[dagger] That is, Perl closes the original one (of those three) only when it sees that opening the new connection is successful. Thus, this technique could be used to redirect any (or all) of those three system filehandles from inside your program,[double dagger] almost as if the program had been run with that I/O redirection from the shell in the first place.

    [dagger] At least, this is true if you haven't changed Perl's special $^F variable, which tells Perl that only those three are special like this. But you'd never change that.

    [double dagger] But don't open STDIN for output or the others for input. Just thinking about that makes our heads hurt.

		2.5.11 Output with say
Perl 5.10 borrows the say  built-in from the ongoing development of Perl 6 (which may have borrowed its say from Pascal's println). It's the same as print, although it adds a newline to the end. These forms all output the same thing:

use 5.010;

print "Hello!\n";
print "Hello!", "\n";
say "Hello!";


To just print a variable's value followed by a newline, you don't need to create an extra string or print a list. You just say the variable. This is especially handy in the common case of simply wanting to put a newline after whatever you want to output:

use 5.010;

my $name = 'Fred';
print "$name\n";
print $name, "\n";
say $name;


To interpolate an array, you still need to quote it though. It's the quoting that puts the spaces between the elements:

use 5.010;

my @array = qw( a b c d );

say @array;   # "abcd\n"

say "@array"; # "a b c d\n";


Just like with print, you can specify a filehandle with say:

use 5.010;

say BEDROCK "Hello!";


Since this is a Perl 5.10 feature though, we'll only use it when we are otherwise using a Perl 5.10 feature. The old, trusty print is still as good as it ever was, but we suspect that there are some Perl programmers out there who will want the immediate savings of not typing the four extra characters (two in the name and the \n).

		2.5.12 Exercises
# [7] Write a program that acts like cat, but reverses the order of the output lines. (Some systems have a utility like this named tac.) If you run yours as ./tac fred barney betty, the output should be all of file betty from last line to first, then barney and then fred, also from last line to first. (Be sure to use the ./ in your program's invocation if you call it tac so that you don't get the system's utility instead!)
# [8] Write a program that asks the user to enter a list of strings on separate lines, printing each string in a right-justified, 20-character column. To be certain that the output is in the proper columns, print a "ruler line" of digits as well. (This is simply a debugging aid.) Make sure that you're not using a 19-character column by mistake! For example, entering hello, good-bye should give output something like this:

123456789012345678901234567890123456789012345678901234567890
               hello
            good-bye


# [8] Modify the previous program to let the user choose the column width so that entering 30, hello, good-bye (on separate lines) would put the strings at the 30th column. (Hint: see the section in Chapter 2 about controlling variable interpolation.) For extra credit, make the ruler line longer when the selected width is larger.	
	
My answers at: /cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic
tac.pl
right_justify.pl
right_justify_enhanced.pl

	2.6 Hashes
In this chapter, you will see a feature that makes Perl one of the world's truly great programming languages: hashes.[157] Although hashes are a powerful and useful feature, you may have used other powerful languages for years without ever hearing of hashes. But you'll use hashes in nearly every Perl program you'll write from now on; they're that important.

    [157] In the olden days, we called these "associative arrays." But the Perl community decided in about 1995 this was too many letters to type and too many syllables to say, so we changed the name to "hashes."

		2.6.1 What Is a Hash?
A hash is a data structure, not unlike an array in that it can hold any number of values and retrieve them at will. But instead of indexing the values by number, as we did with arrays, we'll look up the values by name. That is, the indices (here, we'll call them keys) aren't numbers, but instead they are arbitrary unique strings.

The keys are strings, first of all, so instead of getting element number 3 from an array, we'll be accessing the hash element named wilma.

These keys are arbitrary strings -- you can use any string expression for a hash key. And they are unique strings -- just as there's only one array element numbered 3, there's only one hash element named wilma.

Another way to think of a hash is that it's like a barrel of data, where each piece of data has a tag attached. You can reach into the barrel and pull out any tag and see what piece of data is attached. But there's no "first" item in the barrel; it's just a jumble. In an array, we'd start with element 0, then element 1, then element 2, and so on. But in a hash, there's no fixed order, no first element. It's just a collection of key-value pairs.

The keys and values are both arbitrary scalars, but the keys are always converted to strings. So, if you used the numeric expression 50/20 as the key,[*] it would be turned into the three-character string "2.5", which is one of the keys shown in the diagram above.

    [*] That's a numeric expression, not the five-character string "50/20". If we used that five-character string as a hash key, it would stay the same five-character string, of course.

As usual, Perl's "no unnecessary limits philosophy" applies: a hash may be of any size, from an empty hash with zero key-value pairs, up to whatever fills up your memory.

Some implementations of hashes (such as in the original awk language, from which Larry borrowed the idea) slow down as the hashes get larger and larger. This is not the case in Perl -- it has a good, efficient, scalable algorithm.[dagger] So, if a hash has only three key-value pairs, it's very quick to "reach into the barrel" and pull out any one of those. If the hash has three million key-value pairs, it should be just about as quick to pull out any one of those. A big hash is nothing to fear.

    [dagger] Technically, Perl rebuilds the hash table as needed for larger hashes. In fact, the term "hashes" comes from the fact that a hash table is used for implementing them.

It's worth mentioning again that the keys are always unique, although the values may be duplicated. The values of a hash may be all numbers, all strings, undef values, or a mixture.[double dagger] But the keys are all arbitrary, unique strings.

    [double dagger] Or, in fact, any scalar values, including other scalar types than the ones we'll see in this book.

			2.6.1.1 Why Use a Hash?

When you first hear about hashes, especially if you've lived a long and productive life as a programmer using languages that don't have hashes, you may wonder why anyone would want one of these strange beasts. Well, the general idea is that you'll have one set of data "related to" another set of data. For example, here are some hashes you might find in typical applications of Perl:


Given name, family name

    The given name (first name) is the key, and the family name is the value. This requires unique given names, of course; if there were two people named randal, this wouldn't work. With this hash, you can look up anyone's given name, and find the corresponding family name. If you use the key tom, you get the value phoenix.

Hostname, IP address

    You may know that each computer on the Internet has both a hostname (like http://www.stonehenge.com) and an IP address number (like 123.45.67.89). That's because machines like working with the numbers, but we humans have an easier time remembering the names. The hostnames are unique strings, so they can be used to make this hash. With this hash, you could look up a hostname and find the corresponding IP address.

IP address, hostname

    Or you could go in the opposite direction. We generally think of the IP address as a number, but it can also be a unique string, so it's suitable for use as a hash key. In this hash, we can use the IP address to look up the corresponding hostname. Note that this is not the same hash as the previous example: hashes are a one-way street, running from key to value; there's no way to look up a value in a hash and find the corresponding key! So these two are a pair of hashes, one for storing IP addresses, one for hostnames. It's easy enough to create one of these given the other, though, as we'll see below.

Word, count of number of times that word appears

    This is a very common use of a hash. It's so common, in fact, that it just might turn up in the exercises at the end of the chapter!

    The idea here is that you want to know how often each word appears in a given document. Perhaps you're building an index to a number of documents so that when a user searches for fred, you'll know that a certain document mentions fred five times, another mentions fred seven times, and yet another doesn't mention fred at allso you'll know which documents the user is likely to want. As the index-making program reads through a given document, each time it sees a mention of fred, it adds one to the value filed under the key of fred. That is, if we had seen fred twice already in this document, the value would be 2, but now we'll increment it to 3. If we had never seen fred before, we'd change the value from undef (the implicit, default value) to 1.

Username, number of disk blocks they are using [wasting]

    System administrators like this one: the usernames on a given system are all unique strings, so they can be used as keys in a hash to look up information about that user.

Driver's license number, name

    There may be many, many people named John Smith, but we hope that each one has a different driver's license number. That number makes for a unique key, and the person's name is the value.

Yet another way to think of a hash is as a very simple database, in which just one piece of data may be filed under each key. In fact, if your task description includes phrases like "finding duplicates," "unique," "cross-reference," or "lookup table," it's likely that a hash will be useful in the implementation.
		2.6.2 Hash Element Access
To access an element of a hash, use syntax that looks like this:

$hash{$some_key}


This is similar to what we used for array access, but here we use curly braces instead of square brackets around the subscript (key).[*] And that key expression is now a string, rather than a number:

    [*] Here's a peek into the mind of Larry Wall: Larry says that we use curly braces instead of square brackets because we're doing something fancier than ordinary array access, so we should use fancier punctuation.

$family_name{"fred"} = "flintstone";
$family_name{"barney"} = "rubble";


This lets us use code like this:

foreach $person (qw< barney fred >) {
  print "I've heard of $person $family_name{$person}.\n";
}


The name of the hash is like any other Perl identifier (letters, digits, and underscores, but can't start with a digit). And it's from a separate namespace; that is, there's no connection between the hash element $family_name{"fred"} and a subroutine &family_name, for example. Of course, there's no reason to confuse everyone by giving everything the same name. But Perl won't mind if you also have a scalar called $family_name and array elements like $family_name[5]. We humans will have to do as Perl does; that is, we'll have to look to see what punctuation appears before and after the identifier to see what it means. When there is a dollar sign in front of the name and curly braces afterward, it's a hash element that's being accessed.

When choosing the name of a hash, it's often nice to think of the word "for" between the name of the hash and the key. As in, "the family_name for fred is flintstone". So the hash is named family_name. Then the relationship between the keys and their values becomes clear.

Of course, the hash key may be any expression, not just the literal strings and simple scalar variables that we're showing here:

$foo = "bar";
print $family_name{ $foo . "ney" };  # prints "rubble"


When you store something into an existing hash element, it overwrites the previous value:

$family_name{"fred"} = "astaire";  # gives new value to existing element
$bedrock = $family_name{"fred"};   # gets "astaire"; old value is lost


That's analogous to what happens with arrays and scalars; if you store something new into $pebbles[17] or $dino, the old value is replaced. If you store something new into $family_name{"fred"}, the old value is replaced as well.

Hash elements will spring into existence by assignment:
$family_name{"wilma"} = "flintstone";             # adds a new key (and value)
$family_name{"betty"} .= $family_name{"barney"};  # creates the element if needed

That's also just like what happens with arrays and scalars; if you didn't have $pebbles[17] or $dino before, you will have it after you assign to it. If you didn't have $family_name{"betty"} before, you do now.

And accessing outside the hash gives undef:

$granite = $family_name{"larry"};  # No larry here: undef

Once again, this is just like what happens with arrays and scalars; if there's nothing yet stored in $pebbles[17] or $dino, accessing them will yield undef. If there's nothing yet stored in $family_name{"larry"}, accessing it will yield undef.

			2.6.2.1 The Hash As a Whole

To refer to the entire hash, use the percent sign (%) as a prefix. So, the hash we've been using for the last few pages is actually called %family_name.

For convenience, a hash may be converted into a list, and back again. Assigning to a hash is a list-context assignment, where the list is made of key-value pairs:[*]

    [*] Although any list expression may be used, it must have an even number of elements because the hash is made of key-value pairs. An odd element will likely do something unreliable, although it's a warnable offense.

%some_hash = ("foo", 35, "bar", 12.4, 2.5, "hello",
      "wilma", 1.72e30, "betty", "bye\n");


The value of the hash (in a list context) is a simple list of key-value pairs:

@any_array = %some_hash;


We call this unwinding the hash -- turning it back into a list of key-value pairs. Of course, the pairs won't necessarily be in the same order as the original list:

print "@any_array\n";
  # might give something like this:
  #  betty bye (and a newline) wilma 1.72e+30 foo 35 2.5 hello bar 12.4


The order is jumbled because Perl keeps the key-value pairs in an order that's convenient for Perl so that it can look up any item quickly. You use a hash either when you don't care what order the items are in, or when you have an easy way to put them into the order you want.

Of course, even though the order of the key-value pairs is jumbled, each key "sticks" with its corresponding value in the resulting list. So, even though we don't know where the key foo will appear in the list, we know that its value, 35, will be right after it.

			2.6.2.2 Hash Assignment

It's rare to do so, but a hash may be copied using the obvious syntax:

%new_hash = %old_hash;


This is actually more work for Perl than meets the eye. Unlike what happens in languages like Pascal or C, where such an operation would be a simple matter of copying a block of memory, Perl's data structures are more complex. So, that line of code tells Perl to unwind the %old_hash into a list of key-value pairs, then assign those to %new_hash, building it up one key-value pair at a time.

It's more common to transform the hash in some way, though. For example, we could make an inverse hash:

%inverse_hash = reverse %any_hash;


This takes %any_hash and unwinds it into a list of key-value pairs, making a list like (key, value, key, value, key, value, ...). Then reverse turns that list end-for-end, making a list like (value, key, value, key, value, key, ...). Now the keys are where the values used to be, and the values are where the keys used to be. When that's stored into %inverse_hash, we'll be able to look up a string that was a value in %any_hashit's now a key of %inverse_hash. And the value we'll find is one that was one of the keys from %any_hash. So, we have a way to look up a "value" (now a key), and find a "key" (now a value).

Of course, you might guess (or determine from scientific principles if you're clever) that this will work properly only if the values in the original hash were unique -- otherwise, we'd have duplicate keys in the new hash, and keys are always unique. Here's the rule that Perl uses: the last one in wins. That is, the later items in the list overwrite any earlier ones. Of course, we don't know what order the key-value pairs will have in this list, so there's no telling which ones would win. You'd use this technique only if you know there are no duplicates among the original values.[*] But that's the case for the IP address and hostname examples given earlier:

    [*] Or if you don't care that there are duplicates. For example, we could invert the %family_name hash (in which the keys are people's given names and values are their family names) to make it easy to determine whether there is or is not anyone with a given family name in the group. Thus, in the inverted hash, if there's no key of slate, we'd know that there's no one with that name in the original hash.

%ip_address = reverse %host_name;


Now we can look up a hostname or IP address with equal ease to find the corresponding IP address or hostname.

			2.6.2.3 The Big Arrow

When assigning a list to a hash, sometimes it's not obvious which elements are keys and which are values. For example, in this assignment (which we saw earlier), we humans have to count through the list, saying, "key, value, key, value¿", in order to determine whether 2.5 is a key or a value:

%some_hash = ("foo", 35, "bar", 12.4, 2.5, "hello",
      "wilma", 1.72e30, "betty", "bye\n");


Wouldn't it be nice if Perl gave us a way to pair up keys and values in that kind of a list, so that it would be easy to see which ones were which? Larry thought so, too, which is why he invented the big arrow (=>).[*] To Perl, it's just a different way to "spell" a comma, so it's also sometimes called the "fat comma." That is, in the Perl grammar, any time that you need a comma ( , ), you can use the big arrow instead; it's all the same to Perl.[dagger] So here's another way to set up the hash of last names:

    [*] Yes, there's also a little arrow (->). It's used with references, which is an advanced topic; see the perlreftut and perlref manpages when you're ready for that.

    [dagger] Well, there's one technical difference: any bareword (a sequence of nothing but letters, digits, and underscores not starting with a digit, but optionally prefixed with plus or minus) to the left of the big arrow is implicitly quoted. So you can leave off the quote marks on a bareword to the left of the big arrow. You may also omit the quote marks if there's nothing but a bareword as a key inside the curly braces of a hash.

my %last_name = (  # a hash may be a lexical variable
  "fred"   => "flintstone",
  "dino"   => undef,
  "barney" => "rubble",
  "betty"  => "rubble",
);


Here, it's easy (or perhaps at least easier) to see whose name pairs with which value, even if we end up putting many pairs on one line. And notice that there's an extra comma at the end of the list. As we saw earlier, this is harmless, but convenient; if we need to add additional people to this hash, we'll simply make sure that each line has a key-value pair and a trailing comma. Perl will see that there is a comma between each item and the next, and one extra (harmless) comma at the end of the list.

		2.6.3 Hash Functions
Naturally, there are some useful functions that can work on an entire hash at once.


			2.6.3.1 The keys and values Functions

The keys function yields a list of all the keys in a hash, while the values function gives the corresponding values. If there are no elements to the hash, then either function returns an empty list:

my %hash = ("a" => 1, "b" => 2, "c" => 3);
my @k = keys %hash;
my @v = values %hash;


So, @k will contain "a", "b", and "c", and @v will contain 1, 2, and 3in some order. Remember, Perl doesn't maintain the order of elements in a hash. But, whatever order the keys are in, the values will be in the corresponding order: if "b" is last in the keys, 2 will be last in the values; if "c" is the first key, 3 will be the first value. That's true as long as you don't modify the hash between the request for the keys and the one for the values. If you add elements to the hash, Perl reserves the right to rearrange it as needed, to keep the access quick.[*] In a scalar context, these functions give the number of elements (key-value pairs) in the hash. They do this quite efficiently, without having to visit each element of the hash:

    [*] Of course, if you started adding elements to the hash between keys and values, your list of values (or keys, whichever you did second) would have additional items, which would be tough to match up with the first list. So no normal programmer would do that.

my $count = keys %hash;  # gets 3, meaning three key-value pairs


Once in a long while, you'll see that someone has used a hash as a Boolean (true/false) expression, something like this:

if (%hash) {
  print "That was a true value!\n";
}


That will be true if (and only if) the hash has at least one key-value pair.[dagger] So, it's just saying, "If the hash is not empty" But this is a pretty rare construct, as such things go.

    [dagger] The actual result is an internal debugging string useful to the people who maintain Perl. It looks something like "4/16," but the value is guaranteed to be true when the hash is nonempty, and false when it's empty, so the rest of us can still use it for that.

			2.6.3.2 The each Function

If you wish to iterate over (that is, examine every element of) an entire hash, one of the usual ways is to use the each function, which returns a key-value pair as a two-element list.[double dagger] On each evaluation of this function for the same hash, the next successive key-value pair is returned, until all the elements have been accessed. When there are no more pairs, each returns an empty list.

    [double dagger] The other usual way to iterate over an entire hash is to use foreach on a list of keys from the hash; we'll see that by the end of this section.

In practice, the only way to use each is in a while loop, something like this:

while ( ($key, $value) = each %hash ) {
  print "$key => $value\n";
}


There's a lot going on here. First, each %hash returns a key-value pair from the hash, as a two-element list; let's say that the key is "c" and the value is 3, so the list is ("c", 3). That list is assigned to the list ($key, $value), so $key becomes "c", and $value becomes 3.

But that list assignment is happening in the conditional expression of the while loop, which is a scalar context. (Specifically, it's a Boolean context, looking for a true/false value, and a Boolean context is a particular kind of scalar context.) The value of a list assignment in a scalar context is the number of elements in the source list2, in this case. Since 2 is a true value, we enter the body of the loop and print the message c => 3.

The next time through the loop, each %hash gives a new key-value pair; let's say it's ("a", 1) this time. (It knows to return a different pair than previously because it keeps track of where it is; in technical jargon, there's an iterator stored in with each hash.[*]) Those two items are stored into ($key, $value). Since the number of elements in the source list was again 2a true valuethe while condition is true, and the loop body runs again, telling us a => 1.

    [*] Since each hash has its own private iterator, loops using each may be nested, as long as they are iterating over different hashes. And, as long as we're already in a footnote, we may as well tell you: it's unlikely you'll ever need to do so, but you may reset the iterator of a hash by using the keys or values function on the hash. The iterator is also automatically reset if a new list is stored into the entire hash, or if each has iterated through all of the items to the "end" of the hash. On the other hand, adding new key-value pairs to the hash while iterating over it is generally a bad idea, since that won't necessarily reset the iterator. That's likely to confuse you, your maintenance programmer, and each as well.

We go one more time through the loop, and by now we know what to expect, so it's no surprise to see b => 2 appear in the output.

But we knew it couldn't go on forever. Now, when Perl evaluates each %hash, there are no more key-value pairs available, so each has to return an empty list.[dagger] The empty list is assigned to ($key, $value), so $key gets undef, and $value also gets undef.

    [dagger] It's being used in list context, so it can't return undef to signal failure; that would be the one-element list (undef) instead of the empty (zero-element) list ( ).

But that hardly matters because the whole thing is being evaluated in the conditional expression of the while loop. The value of a list assignment in a scalar context is the number of elements in the source listin this case, that's 0. Since 0 is a false value, the while loop is done, and execution continues with the rest of the program.

Of course, each returns the key-value pairs in a jumbled order. (It's the same order as keys and values would give, incidentally; the "natural" order of the hash.) If you need to go through the hash in order, simply sort the keys, perhaps something like this:

foreach $key (sort keys %hash) {
  $value = $hash{$key};
  print "$key => $value\n";
  # Or, we could have avoided the extra $value variable:
  #  print "$key => $hash{$key}\n";
}


We'll see more about sorting hashes in Chapter 14.


		2.6.4 Typical Use of a Hash
At this point, you may find it helpful to see a more concrete example.

The Bedrock library uses a Perl program in which a hash keeps track of how many books each person has checked out, among other information:

$books{"fred"} = 3;
$books{"wilma"} = 1;


It's easy to see whether an element of the hash is true or false; do this:

if ($books{$someone}) {
  print "$someone has at least one book checked out.\n";
}


But there are some elements of the hash that aren't true:

$books{"barney"} = 0;       # no books currently checked out
$books{"pebbles"} = undef;  # no books EVER checked out - a new library card

Since Pebbles has never checked out any books, her entry has the value of undef, rather than 0.

There's a key in the hash for everyone who has a library card. For each key (that is, for each library patron), there's a value that is either a number of books checked out, or undef if that person's library card has never been used.

			2.6.4.1 The exists Function

To see whether a key exists in the hash, (that is, whether someone has a library card or not), use the exists function, which returns a true value if the given key exists in the hash, whether the corresponding value is true or not:

if (exists $books{"dino"}) {
  print "Hey, there's a library card for dino!\n";
}


That is to say, exists $books{"dino"} will return a true value if (and only if) dino is found in the list of keys from keys %books.
<F5>
			2.6.4.2 The delete Function

The delete function removes the given key (and its corresponding value) from the hash. (If there's no such key, its work is done; there's no warning or error in that case.)

my $person = "betty";
delete $books{$person};  # Revoke the library card for $person


Note that this is not the same as storing undef into that hash elementin fact, it's precisely the opposite! Checking exists($books{"betty"}) will give opposite results in these two cases; after a delete, the key can't exist in the hash, but after storing undef, the key must exist.

In the example, delete versus storing undef is the difference between taking away Betty's library card versus giving her a card that has never been used.

			2.6.4.3 Hash Element Interpolation

You can interpolate a single hash element into a double-quoted string just as you'd expect:

foreach $person (sort keys %books) {               # each patron, in order
  if ($books{$person}) {
    print "$person has $books{$person} items\n";   # fred has 3 items
  }
}


But there's no support for entire hash interpolation; "%books" is just the six characters of (literally) %books.[*] So you've seen all of the magical characters that need backslashing in double quotes: $ and @, because they introduce a variable that Perl will try to interpolate; ", since that's the quoting character that would otherwise end the double-quoted string; and \, the backslash itself. Any other characters in a double-quoted string are nonmagical and should simply stand for themselves.[dagger]

    [*] Well, it couldn't really be anything else; if we tried to print out the entire hash, as a series of key-value pairs, that would be nearly useless. And, as you saw in the last chapter, the percent sign is frequently used in printf format strings; giving it another meaning here would be terribly inconvenient.

    [dagger] But do beware of the apostrophe ('), left square bracket ([), left curly brace ({), the small arrow (->), or double colon (::) following a variable name in a double-quoted string, as they could perhaps mean something you didn't intend.

"
		2.6.5 The %ENV hash
 The %ENV hash

Your Perl program, like any other program, runs in a certain environment, and your program can look at the environment to get information about its surroundings. Perl stores this information in the %ENV hash. For instance, you'll probably see a PATH key in %ENV:

print "PATH is $ENV{PATH}\n";


Depending on your particular setup and operating system, you'll see something like this:

PATH is /usr/local/bin:/usr/bin:/sbin:/usr/sbin


Most of these are set for you automatically, but you can add to the environment yourself. How you do this depends on your operating system and shell:

Bourne shell

  $ CHARACTER=Fred; export CHARACTER
  $ export CHARACTER=Fred

csh

  % setenv CHARACTER Fred

DOS or Windows command

  C:> set CHARACTER=Fred


Once you set these environment variables outside of your Perl program, you can access them inside your Perl program:

print "CHARACTER is $ENV{CHARACTER}\n";

		2.6.6 Exercises
# Write a program that will ask the user for a given name and report the corresponding family name. Use the names of people you know, or (if you spend so much time on the computer that you don't know any actual people) use the following table:

Input	Output
fred	flintstone
barney	rubble
wilma	flintstone

#

[15] Write a program that reads a series of words (with one word per line[*]) until end-of-input, then prints a summary of how many times each word was seen. (Hint: remember that when an undefined value is used as if it were a number, Perl automatically converts it to 0. It may help to look back at the earlier exercise that kept a running total.) So, if the input words were fred, barney, fred, dino, wilma, fred (all on separate lines), the output should tell us that fred was seen 3 times. For extra credit, sort the summary words in ASCII order in the output.

    [*] It has to be one word per line because we still haven't shown you how to extract individual words from a line of input.

#

[15] Write a program to list all of the keys and values in %ENV. Print the results in two columns in ASCIIbetical order. For extra credit, arrange the output to vertically align both columns. The length function can help you figure out how wide to make the first column. Once you get the program running, try setting some new environment variables and ensuring that they show up in your output.
	
My answers at: /cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic
names_hash.pl
words_count.pl

	2.7 In the World of Regular Expressions
Perl has many features that set it apart from other languages. Of all those features, one of the most important is its strong support for regular expressions. These allow fast, flexible, and reliable string handling.

But that power comes at a price. Regular expressions are actually tiny programs in their own special language, built inside Perl. (Yes, you're about to learn another programming language![174] Fortunately it's a simple one.) So in this chapter, you'll visit the world of regular expressions, where (mostly) you can forget about the world of Perl. Then, in the next chapter, we'll show you where this world fits into Perl's world.

    [174] Some might argue that regular expressions are not a complete programming language. We won't argue.

Regular expressions aren't merely part of Perl; they're also found in sed and awk, procmail, grep, most programmers' text editors such as vi and emacs, and even in more esoteric places. If you've seen some of these already, you're ahead of the game. Keep watching, and you'll see many more tools that use or support regular expressions, such as search engines on the Web (often written in Perl), email clients, and others. The bad news is that everybody's regular expressions have slightly different syntax, so you may need to learn to include or omit an occasional backslash.

		2.7.1 What Are Regular Expressions?
A regular expression, often called a pattern in Perl, is a template that either matches or doesn't match a given string.[175] That is, there are an infinite number of possible text strings; a given pattern divides that infinite set into two groups: the ones that match, and the ones that don't. There's never any kinda-sorta-almost-up-to-here wishy-washy matching: either it matches or it doesn't.

    [175] Purists would ask for a more rigorous definition. But then again, purists say that Perl's patterns aren't really regular expressions. If you're serious about regular expressions, we highly recommend the book Mastering Regular Expressions by Jeffrey Friedl (O'Reilly).

A pattern may match just one possible string, or just two or three, or a dozen, or a hundred, or an infinite number. Or it may match all strings except for one, or except for some, or except for an infinite number.[*] We already referred to regular expressions as being little programs in their own simple programming language. It's a simple language because the programs have just one task: to look at a string and say "it matches" or "it doesn't match."[dagger] That's all they do.

    [*] And as you'll see, you could have a pattern that always matches or that never does. In rare cases, even these may be useful. Generally, though, they're mistakes.

    [dagger] The programs also pass back some information that Perl can use later. One such piece of information is the "regular expressions memories" that you'll learn about a little later.

One of the places you're likely to have seen regular expressions is in the Unix grep command, which prints out text lines matching a given pattern. For example, if you wanted to see which lines in a given file mention flint and, somewhere later on the same line, stone, you might do something like this, with the Unix grep command:

$ grep 'flint.*stone' chapter*.txt
chapter3.txt:a piece of flint, a stone which may be used to start a fire by striking
chapter3.txt:found obsidian, flint, granite, and small stones of basaltic rock,
 which
chapter9.txt:a flintlock rifle in poor condition. The sandstone mantle held several


Don't confuse regular expressions with shell filename-matching patterns, called globs. A typical glob is what you use when you type *.pm to the Unix shell to match all filenames that end in .pm. The previous example uses a glob of chapter*.txt. (You may have noticed that you had to quote the pattern to prevent the shell from treating it like a glob.) Although globs use a lot of the same characters that you use in regular expressions, those characters are used in totally different ways.[double dagger] We'll visit globs later, in Chapter 13, but for now try to put them totally out of your mind.

    [double dagger] Globs are also (alas) sometimes called patterns. What's worse, though, is that some bad Unix books for beginners (and possibly written by beginners) have taken to calling globs "regular expressions," which they certainly are not. This confuses many folks at the start of their work with Unix.


		2.7.2 Using Simple Patterns
To match a pattern (regular expression) against the contents of $_, simply put the pattern between a pair of forward slashes (/), like we do here:

$_ = "yabba dabba doo";
if (/abba/) {
  print "It matched!\n";
}


The expression /abba/ looks for that four-letter string in $_; if it finds it, it returns a true value. In this case, it's found more than once, but that doesn't make any difference. If it's found at all, it's a match; if it's not in there at all, it fails.

Because the pattern match is generally being used to return a true or false value, it is almost always found in the conditional expression of if or while.

All of the usual backslash escapes that you can put into double-quoted strings are available in patterns, so you could use the pattern /coke\tsprite/ to match the 11 characters of coke, a tab, and sprite.

			2.7.2.1 About Metacharacters

Of course, if patterns matched only simple literal strings, they wouldn't be very useful. That's why there are a number of special characters, called metacharacters, that have special meanings in regular expressions.

For example, the dot (.) is a wildcard characterit matches any single character except a newline (which is represented by "\n"). So, the pattern /bet.y/ would match betty. Or it would match betsy, or bet=y, or bet.y, or any other string that has bet, followed by any one character (except a newline), followed by y. It wouldn't match bety or betsey, though, since those don't have exactly one character between the t and the y. The dot always matches exactly one character.

So, if you wanted to match a period in the string, you could use the dot. But that would match any possible character (except a newline), which might be more than you wanted. If you wanted the dot to match just a period, you can simply backslash it. In fact, that rule goes for all of Perl's regular expression metacharacters: a backslash in front of any metacharacter makes it nonspecial. So, the pattern /3\.14159/ doesn't have a wildcard character.

So the backslash is our second metacharacter. If you mean a real backslash, just use a pair of thema rule that applies just as well everywhere else in Perl.

			2.7.2.2 Simple Quantifiers

It often happens that you'll need to repeat something in a pattern. The star (*) means to match the preceding item zero or more times. So, /fred\t*barney/ matches any number of tab characters between fred and barney. That is, it matches "fred\tbarney" with one tab, or "fred\t\tbarney" with two tabs, or "fred\t\t\tbarney" with three tabs, or even "fredbarney" with nothing in between at all. That's because the star means "zero or more"so you could even have hundreds of tab characters in between, but nothing other than tabs. You may find it helpful to think of the star as saying, "That previous thing, any number of times, even zero times" (because * is the "times" operator in multiplication).

What if you wanted to allow something besides tab characters? The dot matches any character,[*] so .* will match any character, any number of times. That means that the pattern /fred.*barney/ matches "any old junk" between fred and barney. Any line that mentions fred and (somewhere later) barney will match that pattern. We often call .* the "any old junk" pattern because it can match any old junk in your strings.

    [*] Except newline. But we're going to stop reminding you of that so often because you know it by now. Most of the time it doesn't matter, anyway, because your strings will most often not have newlines. But don't forget this detail because someday a newline will sneak into your string and you'll need to remember that the dot doesn't match a newline.

The star is formally called a quantifier, meaning that it specifies a quantity of the preceding item. But it's not the only quantifier; the plus (+) is another. The plus means to match the preceding item one or more times: /fred +barney/ matches if fred and barney are separated by spaces and only spaces. (The space is not a metacharacter.) This won't match fredbarney, since the plus means that there must be one or more spaces between the two names, so at least one space is required. It may be helpful to think of the plus as saying, "that last thing, plus (optionally) more of the same thing."

There's a third quantifier like the star and plus, but more limited. It's the question mark (?), which means that the preceding item is optional. That is, the preceding item may occur once or not at all. Like the other two quantifiers, the question mark means that the preceding item appears a certain number of times. It's just that in this case the item may match one time (if it's there) or zero times (if it's not). There aren't any other possibilities. So, /bamm-?bamm/ matches either spelling: bamm-bamm or bammbamm. This is easy to remember, since it's saying, "That last thing, maybe? Or maybe not?"

All three of these quantifiers must follow something, since they tell how many times the previous item may repeat.

			2.7.2.3 Grouping in Patterns

As in mathematics, parentheses (( )) may be used for grouping. So, parentheses are also metacharacters. As an example, the pattern /fred+/ matches strings like freddddddddd, but strings like that don't show up often in real life. But the pattern /(fred)+/ matches strings like fredfredfred, which is more likely to be what you wanted. And what about the pattern /(fred)*/? That matches strings like hello, world.[*]

    [*] The star means to match zero or more repetitions of fred. When you're willing to settle for zero, it's hard to be disappointed! That pattern will match any string, even the empty string.

The parentheses also give us a way to reuse part of the string directly in the match. We can use back references to refer to text that we matched in the parentheses. We denote a back reference as a backslash followed by a number, like \1, \2, and so on. The number denotes the parentheses group.

When we use the parentheses around the dot, we match any nonnewline character. We can match again whichever character we matched in those parentheses by using the back reference \1:

$_ = "abba";
if (/(.)\1/) {  # matches 'bb'
  print "It matched same character next to itself!\n";
}


The (.)\1 says that we have to match a character right next to itself. At first try, the (.) matches an a, but when it looks at the back referencewhich says the next thing it must match is athat trial fails. Perl starts over, using the (.) to match the next character, a b. The back reference \1 now says that the next character in the pattern is b, which Perl can match.

The back reference doesn't have to be right next to the parentheses group. The next pattern matches any four nonnewline characters after a literal y, and we use the \1 back reference to denote that we want to match the same four characters after the d:

$_ = "yabba dabba doo";
if (/y(....) d\1/) {
  print "It matched the same after y and d!\n";
}


We can use multiple groups of parentheses, and each group gets its own back reference. We want to match a nonnewline character in a parentheses group, followed by another nonnewline character in a parentheses group. After those two groups, we use the back reference \2 followed by the back reference \1. In effect, we're matching a palindrome such as abba:

$_ = "yabba dabba doo";
if (/y(.)(.)\2\1/) { # matches 'abba'
  print "It matched the same after y and d!\n";
}


Now, this brings up the question "How do I know which group gets which number?" Fortunately, Larry did the easiest thing for humans to understand: just count the order of the opening parenthesis and ignore nesting:

$_ = "yabba dabba doo";
if (/y((.)(.)\3\2) d\1/) {
  print "It matched!\n";
}


You might be able to see this if you write out the regular expression to see the different parts (although this isn't a valid regular expression[*]):

    [*] You can expand regular expressions like this by using the /x flag, but we're not showing that to you until the next chapter.

(        # first open parenthesis
    (.)  # second open parenthesis
    (.)  # third open parenthesis
    \3
    \2
)


Perl 5.10 has a new way to denote back references. Instead of using the backslash and a number, it uses \g{N}, where N is the number of the back reference that you want to use. This notation can make it easier for us to show what we intend in the pattern.

Consider the problem where you want to use a back reference next to a part of the pattern that is a number. In this regular expression, we want to use \1 to repeat the character we matched in the parentheses and follow that with the literal string 11:

$_ = "aa11bb";
if (/(.)\111/) {
  print "It matched!\n";
}


Perl has to guess what we mean there. Is that \1, \11, or \111? Perl will create as many back references as we need, so it assumes that we mean \111. Since we don't have 111 (or 11) parentheses groups, Perl complains when it tries to compile the program.

By using \g{1}, we disambiguate the back reference and the literal parts of the pattern:[*]

    [*] In general, we could leave the curly braces off the \g{1} and just use \g1, but in this case we need the braces. Instead of thinking about it, we just use them all the time.

use 5.010;

$_ = "aa11bb";
if (/(.)\g{1}11/) {
  print "It matched!\n";
}


With the \g{N} notation, we can also use negative numbers. Instead of specifying the absolute number of the parentheses group, we can specify a relative back reference. We can rewrite the last example to use -1 as the number to do the same thing:

use 5.010;

$_ = "aa11bb";
if (/(.)\g{-1}11/) {
  print "It matched!\n";
}


If I decide to add more to that pattern later, I don't have to remember to change the back reference. If I add another parentheses group, I change the absolute numbering of all the back references. The relative back reference, however, just counts from its own position and refers to the group right before it no matter its absolute number, so it stays the same:

use 5.010;

$_ = "aa11bb";
if (/(.)(.)\g{-1}11/) {
  print "It matched!\n";
}


			2.7.2.4 Alternatives

The vertical bar (|), often pronounced "or" in this usage, means that either the left side may match, or the right side. That is, if the part of the pattern on the left of the bar fails, the part on the right gets a chance to match. So, /fred|barney|betty/ will match any string that mentions fred, or barney, or betty.

Now you can make patterns like /fred( |\t)+barney/, which matches if fred and barney are separated by spaces, tabs, or a mixture of the two. The plus means to repeat one or more times; each time it repeats, the ( |\t) has the chance to match either a space or a tab.[*] There must be at least one of those characters between the two names.

    [*] This particular match would normally be done more efficiently with a character class, as you'll see later in this chapter.

If you wanted the characters between fred and barney to all be the same, you could rewrite that pattern as /fred( +|\t+)barney/. In this case, the separators must be all spaces or all tabs.

The pattern /fred (and|or) barney/ matches any string containing either of the two possible strings: fred and barney, or fred or barney.[dagger] You could match the same two strings with the pattern /fred and barney|fred or barney/, but that would be too much typing. It would probably also be less efficient, depending upon what optimizations are built into the regular expression engine.

    [dagger] Note that the words and and or are not operators in regular expressions! They are shown here in a fixed-width typeface because they're part of the strings.

		2.7.3 Character Classes
A character class, a list of possible characters inside square brackets ([]), matches any single character from within the class. It matches just one single character, but that one character may be any of the ones listed.

For example, the character class [abcwxyz] may match any one of those seven characters. For convenience, you may specify a range of characters with a hyphen (-) so that class may also be written as [a-cw-z]. That didn't save much typing, but it's more usual to make a character class like [a-zA-Z] to match any one letter out of that set of 52.[double dagger] You may use the same character shortcuts as in any double-quoted string to define a character, so the class [\000-\177] matches any seven-bit ASCII character.[||] Of course, a character class will be just part of a full pattern; it will never stand on its own in Perl. For example, you might see code that says something like this:

    [double dagger] Notice that those 52 don't include letters like Å, É, Î, Ø, and Ü. But when Unicode processing is available, that particular character range is noticed and enhanced to automatically do the right thing.

    [||] At least, if you use ASCII and not EBCDIC.

$_ = "The HAL-9000 requires authorization to continue.";
if (/HAL-[0-9]+/) {
  print "The string mentions some model of HAL computer.\n";
}


Sometimes, it's easier to specify the characters left out, rather than the ones within the character class. A caret (^) at the start of the character class negates it. That is, [^def] will match any single character except one of those three. And [^n\-z] matches any character except for n, hyphen, or z. (Note that the hyphen is backslashed because it's special inside a character class. But the first hyphen in /HAL-[0-9]+/ doesn't need a backslash because hyphens aren't special outside a character class.)


			2.7.3.1 Character Class Shortcuts

Some character classes appear so frequently that they have shortcuts. For example, the character class for any digit, [0-9], may be abbreviated as \d. Thus, the pattern from the example about HAL could be written /HAL-\d+/ instead.

The shortcut \w is a so-called word character: [A-Za-z0-9_]. If your "words" are made up of ordinary letters, digits, and underscores, you'll be happy with this. Most of the rest of us have words made up of ordinary letters, hyphens, and apostrophes,[*] and so we'd like to change this definition of "word." As of this writing, the Perl developers are working on it, but it's not available yet.[dagger] So use this one only when you want ordinary letters, digits, and underscores.

    [*] At least, in usual English you do. In other languages, you may have different components of words. And when looking at ASCII-encoded English text, you have the problem that the single quote and the apostrophe are the same character, so it's not possible in isolation to tell whether cats' is a word with an apostrophe or a word at the end of a quotation. This is probably one reason that computers haven't been able to take over the world yet.

    [dagger] Except to a limited (but nevertheless useful) extent in connection with locales; see the perllocale manpage.

Of course, \w doesn't match a "word"; it merely matches a single "word" character. To match an entire word, though, the plus modifier is handy. A pattern like /fred \w+ barney/ will match fred and a space, then a "word," then a space and barney. That is, it'll match if there's one word[double dagger] between fred and barney, set off by single spaces.

    [double dagger] We're going to stop saying "word" in quotes so much; you know by now that these letter-digit-underscore words are the ones we mean.

As you may have noticed in that previous example, it might be handy to be able to match spaces more flexibly. The \s shortcut is good for whitespace; it's the same as [\f\t\n\r ]. That is, it's the same as a class containing the five whitespace characters: form-feed, tab, newline, carriage return, and the space character itself. These are the characters that merely move the printing position around; they don't use any ink. Still, like the other shortcuts you've just seen, \s matches just a single character from the class, so it's usual to use either \s* for any amount of whitespace (including none at all), or \s+ for one or more whitespace characters. (In fact, it's rare to see \s without one of those quantifiers.) Since all of those whitespace characters look about the same to us humans, you can treat them all in the same way with this shortcut.

Perl 5.10 adds more character classes for whitespace. The \h shortcut only matches horizontal whitespace, which you can write as the character class [\t ] to match a tab and a space. The \v shortcut only matches vertical whitespace, or [\f\n\r]. The \R shortcut matches any sort of linebreak, meaning that you don't have to think about which operating system you're using and what it thinks a linebreak is since \R will figure it out.
7.3.2. Negating the Shortcuts

Sometimes you may want the opposite of one of these three shortcuts. That is, you may want [^\d], [^\w], or [^\s], meaning a nondigit character, a nonword character, or a nonwhitespace character. That's easy enough to accomplish by using their uppercase counterparts: \D, \W, or \S. These match any character that their counterpart would not match.

Any of these shortcuts will work either in place of a character class (standing on their own in a pattern), or inside the square brackets of a larger character class. That means that you could now use /[\dA-Fa-f]+/ to match hexadecimal (base 16) numbers, which use letters ABCDEF (or the same letters in lowercase) as additional digits.

Another compound character class is [\d\D], which means any digit, or any nondigit. That is to say, any character at all! This is a common way to match any character, even a newline. (As opposed to ., which matches any character except a newline.) And then there's the totally useless [^\d\D], which matches anything that's not either a digit or a nondigit. Rightnothing!

		2.7.4 Exercises
#

[10] Make a program that prints each line of its input that mentions fred. (It shouldn't do anything for other lines of input.) Does it match if your input string is Fred, frederick, or Alfred? Make a small text file with a few lines mentioning "fred flintstone" and his friends, then use that file as input to this program and the ones later in this section.
#

[6] Modify the previous program to allow Fred to match as well. Does it match now if your input string is Fred, frederick, or Alfred? (Add lines with these names to the text file.)
#

[6] Make a program that prints each line of its input that contains a period (.), ignoring other lines of input. Try it on the small text file from the previous exercise: does it notice Mr. Slate?
#

[8] Make a program that prints each line that has a word that is capitalized but not ALL capitalized. Does it match Fred but neither fred nor FRED?
#

[8] Make a program that prints each line that has a two of the same nonwhitespace characters next to each other. It should match lines that contain words such as Mississippi, Bamm-Bamm, or llama.
#

[8] Extra credit exercise: write a program that prints out any input line that mentions both wilma and fred.
	
My answers at: /cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic
reg_exp1.pl*  reg_exp2.pl*  reg_exp3.pl*  reg_exp4.pl*  reg_exp5.pl*

	2.8 Matching with Regular Expressions
	
	
		2.8.1  Matches with m//
We've been writing patterns in pairs of forward slashes, like /fred/. But this is actually a shortcut for the m// (pattern match) operator. As you saw with the qw// operator, you may choose any pair of delimiters to quote the contents. So you could write that same expression as m(fred), m<fred>, m{fred}, or m[fred] using those paired delimiters, or as m,fred,, m!fred!, m^fred^, or many other ways using nonpaired delimiters.[190]

    [190] Nonpaired delimiters are the ones that don't have a different "left" and "right" variety; the same punctuation mark is used for both ends.

The shortcut is that if you choose the forward slash as the delimiter, you may omit the initial m. Since Perl folks love to avoid typing extra characters, you'll see most pattern matches written using slashes, as in /fred/.

Of course, you should wisely choose a delimiter that doesn't appear in your pattern.[191] If you wanted to make a pattern to match the beginning of an ordinary web URL, you might start to write /http:\/\// to match the initial "http://". But that's easier to read, write, maintain, and debug if you use a better choice of delimiter: m%http://%.[192] It's common to use curly braces as the delimiter. If you use a programmer's text editor, it probably has the ability to jump from an opening curly brace to the corresponding closing one, which can be handy in maintaining code.

    [191] If you're using paired delimiters, you shouldn't generally have to worry about using the delimiter inside the pattern, since that delimiter will generally be paired inside your pattern. That is, m(fred(.*)barney) and m{\w{2,}} and m[wilma[\n\t]+betty] are all fine, even though the pattern contains the quoting character, since each "left" has a corresponding "right." But the angle brackets (< and >) aren't regular expression metacharacters, so they may not be paired; if the pattern were m{(\d+)\s*>=?\s*(\d+)}, quoting it with angle brackets would mean having to backslash the greater-than sign so that it wouldn't prematurely end the pattern.

    [192] Remember, the forward slash is not a metacharacter, so you don't need to escape it when it's not the delimiter.

		2.8.2  Option Modifiers
There are several option modifier letters, sometimes called flags, which may be appended as a group right after the ending delimiter of a regular expression to change its behavior from the default.

			2.8.2.1  Case-Insensitive Matching with /i

To make a case-insensitive pattern match, so you can match FRED as easily as fred or Fred, use the /i modifier:

print "Would you like to play a game? ";
chomp($_ = <STDIN>);
if (/yes/i) {  # case-insensitive match
  print "In that case, I recommend that you go bowling.\n";
}


			2.8.2.2 Matching Any Character with /s

By default, the dot (.) doesn't match newline, and this makes sense for most "look within a single line" patterns. If you might have newlines in your strings, and you want the dot to be able to match them, the /s modifier will do the job. It changes every dot[*] in the pattern to act like the character class [\d\D] does, which is to match any character, even if it is a newline. Of course, you have to have a string with newlines for this to make a difference:

    [*] If you wish to change just some of them, and not all, you'll probably want to replace just those few with [\d\D].

$_ = "I saw Barney\ndown at the bowling alley\nwith Fred\nlast night.\n";
if (/Barney.*Fred/s) {
  print "That string mentions Fred after Barney!\n";
}


Without the /s modifier, that match would fail, since the two names aren't on the same line.

			2.8.2.3 Adding Whitespace with /x

The third modifier you'll see allows you to add arbitrary whitespace to a pattern to make it easier to read:

/-?\d+\.?\d*/         # what is this doing?
/ -? \d+ \.? \d* /x   # a little better


Since the /x allows whitespace inside the pattern, a literal space or tab character within the pattern is ignored. You could use a backslashed space or \t (among many other ways) to match these, but it's more common to use \s (or \s* or \s+) when you want to match whitespace anyway.

Remember that in Perl, comments may be included as part of the whitespace. Now we can put comments into that pattern to tell what it's really doing:

/
  -?      # an optional minus sign
  \d+     # one or more digits before the decimal point
  \.?     # an optional decimal point
  \d*     # some optional digits after the decimal point
/x        # end of string


Since the pound sign indicates the start of a comment, use \# or [#] in the rare case that you need to match a pound sign. And be careful not to include the closing delimiter inside the comments, or it will prematurely terminate the pattern.

			2.8.2.4 Combining Option Modifiers

If you have more than one option modifier to use on the same pattern, they may be used one after the other (their order isn't significant):

if (/barney.*fred/is) {  # both /i and /s
  print "That string mentions Fred after Barney!\n";
}


Or as a more expanded version with comments:

if (m{
  barney # the little guy
  .*     # anything in between
  fred   # the loud guy
}six) {  # all three of /s and /i and /x
  print "That string mentions Fred after Barney!\n";
}


Note the shift to curly braces here for the delimiters as well, allowing programmer-style editors to easily bounce from the beginning to the end of the regular expression.

			2.8.2.5 Other Options

There are many other option modifiers available. We'll cover those as we get to them, or you can read about them in the perlop manpage and in the descriptions of m// and the other regular expression operators that you'll see later in this chapter.

		2.8.3  Anchors
By default, if a pattern doesn't match at the start of the string, it can "float" on down the string, trying to match somewhere else. But there are a number of anchors that may be used to hold the pattern at a particular point in a string.

The caret[*] anchor (^) marks the beginning of the string, while the dollar sign ($) marks the end.[dagger] So the pattern /^fred/ will match fred only at the start of the string; it wouldn't match manfred mann. And /rock$/ will match rock only at the end of the string; it wouldn't match knute rockne.

    [*] Yes, you've seen the caret used in another way in patterns. As the first character of a character class, it negates the class. But outside of a character class, it's a metacharacter in a different way, being the start-of-string anchor. There are only so many characters, so you have to use some of them twice.

    [dagger] Actually, it matches either the end of the string or at a newline at the end of the string. That's so you can match the end of the string whether it has a trailing newline or not. Most folks don't worry about this distinction much, but once in a long while it's important to remember that /^fred$/ will match either "fred" or "fred\n" with equal ease.

Sometimes you'll want to use both of these anchors to ensure that the pattern matches an entire string. A common example is /^\s*$/, which matches a blank line. But this "blank" line may include some whitespace characters, like tabs and spaces, which are invisible to you and me. Any line that matches that pattern looks just like any other one on paper, so this pattern treats all blank lines as equivalent. Without the anchors, it would match nonblank lines as well.

			2.8.3.1  Word Anchors

Anchors aren't just at the ends of the string. The word-boundary anchor, \b, matches at either end of a word.[double dagger] So you can use /\bfred\b/ to match the word fred but not frederick or alfred or manfred mann. This is similar to the feature often called something like "match whole words only" in a word processor's search command.

    [double dagger] Some regular expression implementations have one anchor for start-of-word and another for end-of-word, but Perl uses \b for both.
    [Yosi I] VIM uses \< for start word boundary and \> for end word.

Alas, these aren't words as you and I are likely to think of them; they're those \w-type words made up of ordinary letters, digits, and underscores. The \b anchor matches at the start or end of a group of \w characters.


The word-boundary anchor is useful to ensure that we don't accidentally find cat in delicatessen, dog in boondoggle, or fish in selfishness. Sometimes you'll want just one word-boundary anchor, as when using /\bhunt/ to match words like hunt or hunting or hunter, but not shunt, or when using /stone\b/ to match words like sandstone or flintstone but not capstones.

The nonword-boundary anchor is \B; it matches at any point where \b would not match. So the pattern /\bsearch\B/ will match searches, searching, and searched, but not search or researching.

		2.8.4  The Binding Operator, =~
Matching against $_ is merely the default; the binding operator, =~, tells Perl to match the pattern on the right against the string on the left, instead of matching against $_.[dagger] For example:

    [dagger] The binding operator is also used with some other operations besides the pattern match, as you'll see later.

my $some_other = "I dream of betty rubble.";
if ($some_other =~ /\brub/) {
  print "Aye, there's the rub.\n";
}


The first time you see it, the binding operator looks like some kind of assignment operator. But it's no such thing! It is simply saying, "This pattern match, which would attach to $_ by default--make it work with this string on the left instead." If there's no binding operator, the expression is using $_ by default.

In the (somewhat unusual) example that follows, $likes_perl is set to a Boolean value according to what the user typed at the prompt. This is a little on the quick-and-dirty side because the line of input itself is discarded. This code reads the line of input, tests that string against the pattern, then discards the line of input.[*] It doesn't use or change $_ at all.

    [*] Remember, the line of input is not automatically stored into $_ unless the line-input operator (<STDIN>) is all alone in the conditional expression of a while loop.

print "Do you like Perl? ";
my $likes_perl = (<STDIN> =~ /\byes\b/i);
...  # Time passes...
if ($likes_perl) {
  print "You said earlier that you like Perl, so...\n";
  ...
}


Because the binding operator has fairly high precedence, the parentheses around the pattern-test expression aren't required, so the following line does the same thing as the one above--it stores the result of the test (and not the line of input) into the variable:

my $likes_perl = <STDIN> =~ /\byes\b/i;

		2.8.5  Interpolating into Patterns
The regular expression is double-quote interpolated, just as if it were a double-quoted string. This allows us to write a quick grep-like program like this:

#!/usr/bin/perl -w
my $what = "larry";

while (<>) {
  if (/^($what)/) {  # pattern is anchored at beginning of string
    print "We saw $what in beginning of $_";
  }
}


The pattern will be built up out of whatever's in $what when we run the pattern match. In this case, it's the same as if we had written /^(larry)/, looking for larry at the start of each line.

But we didn't have to get the value of $what from a literal string; we could have gotten it instead from the command-line arguments in @ARGV:

my $what = shift @ARGV;


Now, if the first command-line argument were fred|barney, the pattern becomes /^(fred|barney)/, looking for fred or barney at the start of each line.[dagger] The parentheses (which weren't really necessary when searching for larry) are important now because without them we'd be matching fred at the start or barney anywhere in the string.

    [dagger] The astute reader will know that you can't generally type fred|barney as an argument at the command line because the vertical bar is a shell metacharacter. See the documentation to your shell to learn about how to quote command-line arguments.

With that line changed to get the pattern from @ARGV, this program resembles the Unix grep command. But we have to watch out for metacharacters in the string. If $what contains 'fred(barney', the pattern would look like /^(fred(barney)/, and you know that can't work right--it'll crash your program with an invalid regular expression error. With some advanced techniques,[*] you can trap this kind of error (or prevent the magic of the metacharacters in the first place) so that it won't crash your program. But for now, just know that if you give your users the power of regular expressions, they'll also need the responsibility to use them correctly.

    [*] In this case, you would use an eval block to trap the error, or you would quote the interpolated text using quotemeta (or its \Q equivalent form) so that it's no longer treated as a regular expression.

		2.8.6  The Match Variables
So far, when we've put parentheses into patterns, they've been used only for their ability to group parts of a pattern together. But parentheses also trigger the regular expression engine's memory. The memory holds the part of the string matched by the part of the pattern inside parentheses. If there is more than one pair of parentheses, there will be more than one memory. Each regular expression memory holds part of the original string, not part of the pattern.

Since these variables hold strings, they are scalar variables; in Perl, they have names like $1 and $2. There are as many of these variables as there are pairs of memory parentheses in the pattern. As you'd expect, $4 means the string matched by the fourth set of parentheses.[dagger]

    [dagger] This is the same string that the back reference \4 would refer to during the pattern match. But these aren't two different names for the same thing; \4 refers back to the memory during the pattern while it is trying to match, while $4 refers to the memory of an already completed pattern match. For more information on back references, see the perlre manpage.

These match variables are a big part of the power of regular expressions because they let us pull out the parts of a string:

$_ = "Hello there, neighbor";
if (/\s(\w+),/) {             # memorize the word between space and comma
  print "the word was $1\n";  # the word was there
}


Or you could use more than one memory at once:

$_ = "Hello there, neighbor";
if (/(\S+) (\S+), (\S+)/) {
  print "words were $1 $2 $3\n";
}


That tells us that the words were Hello there neighbor. Notice that there's no comma in the output. Because the comma is outside of the memory parentheses in the pattern, there is no comma in memory two. Using this technique, we can choose exactly what we want in the memories, as well as what we want to leave out.

You could even have an empty match variable[*] if that part of the pattern might be empty. That is, a match variable may contain the empty string:

    [*] As opposed to an undefined one. If you have three or fewer sets of parentheses in the pattern, $4 will be undef.

my $dino = "I fear that I'll be extinct after 1000 years.";
if ($dino =~ /(\d*) years/) {
  print "That said '$1' years.\n";  # 1000
}

$dino = "I fear that I'll be extinct after a few million years.";
if ($dino =~ /(\d*) years/) {
  print "That said '$1' years.\n";  # empty string
}


			2.8.6.1  The Persistence of Memory

These match variables generally stay around until the next successful pattern match.[dagger] That is, an unsuccessful match leaves the previous memories intact, but a successful one resets them all. This correctly implies that you shouldn't use these match variables unless the match succeeded; otherwise, you could be seeing a memory from some previous pattern. The following (bad) example is supposed to print a word matched from $wilma. But if the match fails, it will use whatever leftover string happens to be found in $1.

    [dagger] The actual scoping rule is much more complex (see the documentation if you need it), but as long as you don't expect the match variables to be untouched many lines after a pattern match, you shouldn't have problems.

$wilma =~ /(\w+)/;  # BAD! Untested match result
print "Wilma's word was $1... or was it?\n";


This is another reason that a pattern match is almost always found in the conditional expression of an if or while:

if ($wilma =~ /(\w+)/) {
  print "Wilma's word was $1.\n";
} else {
  print "Wilma doesn't have a word.\n";
}


Since these memories don't stay around forever, you shouldn't use a match variable like $1 more than a few lines after its pattern match. If your maintenance programmer adds a new regular expression between your regular expression and your use of $1, you'll be getting the value of $1 for the second match, rather than the first. For this reason, if you need a memory for more than a few lines, it's generally best to copy it into an ordinary variable. Doing this helps make the code more readable at the same time:

if ($wilma =~ /(\w+)/) {
  my $wilma_word = $1;
  ...
}


Later, in Chapter 9, you'll see how to get the memory value directly into the variable at the same time the pattern match happens, without having to use $1 explicitly.


			2.8.6.2 Noncapturing Parentheses

So far you've seen parentheses that capture parts of a matched string and store them in the memory variables, but what if you just want to use the parentheses to group things? Consider a regular expression where we want to make part of it optional, but capture only another part of it. In this example, we want "bronto" to be optional, but to make it optional, we have to group that sequence of characters with parentheses. Later in the pattern, we use an alternation to get either "steak" or "burger", and we want to know which one we found.

if (/(bronto)?saurus (steak|burger)/) {
    print "Fred wants a $2\n";
}


Even if bronto is not there, its part of the pattern goes into $1. Perl just counts the order of the opening parentheses to decide what the memory variables will be. The part that we want to remember ends up in $2. In more complicated patterns, this situation can get quite confusing.

Fortunately, Perl's regular expressions have a way to use parentheses to group things but not trigger the memory variables. We call these noncapturing parentheses, and we write them with a special sequence. We add a question mark and a colon after the opening parenthesis, (?:),[*] and that tells Perl we use these parentheses only for grouping.

    [*] This is the fourth type of ? you'll see in regular expressions: a literal question mark (escaped), the 0 or 1 quantifier, the nongreedy modifier (next chapter), and now the start of an extended pattern.

We change our regular expression to use noncapturing parentheses around "bronto", and the part that we want to remember now shows up in $1:

if (/(?:bronto)?saurus (steak|burger)/) {
    print "Fred wants a $1\n";
}


Later, when we change our regular expression, perhaps to include a possible bar-be-que version of the brontosaurus burger, we can make the added "BBQ " (with a space!) optional and noncapturing, so the part we want to remember still shows up in $1. Otherwise, we'd potentially have to shift all of our memory variable names every time we add grouping parentheses to our regular expression:

if (/(?:bronto)?saurus (?:BBQ )?(steak|burger)/) {
    print "Fred wants a $1\n";
}


Perl's regular expressions have several other special parentheses sequences that do fancy and complicated things like look-ahead, look-behind, embedded comments, or even run code right in the middle of a pattern. You'll have to check out the perlre manpage for the details though.

		2.8.7 Named Captures

You can capture parts of the string with parentheses and then look in the number variables $1, $2, and so on to get the parts of the string that matched. Keeping track of those number variables and what should be in them can be confusing even for simple patterns. Consider this regular expression that tries to match the two names in $names:

use 5.010;

my $names = 'Fred or Barney';
if( $names =~ m/(\w+) and (\w+)/ ) { # won't match
    say "I saw $1 and $2";
    }


We don't see the message from say because the string has an or where you were expecting an and. Maybe we were supposed to have it both ways, so we change the regular expression to have an alternation to handle both and and or, adding another set of parentheses to group the alternation:

use 5.010;

my $names = 'Fred or Barney';
if( $names =~ m/(\w+) (and|or) (\w+)/ ) { # matches now
    say "I saw $1 and $2";
    }


Oops! We see a message this time, but it doesn't have the second name in it because we added another set of memory parentheses. The value in $2 is from the alternation and the second name was now in $3 (which we don't output):

I saw Fred and or


We could have used the noncapturing parentheses to get around this, but the real problem is that we have to remember which numbered parentheses belong to which data we are trying to capture. Imagine how much tougher this gets with many captures.

Instead of remembering numbers such as $1, Perl 5.10 lets us name the captures directly in the regular expression. It saves the text it matches in the hash named %+: the key is the label we used and the value is the part of the string that it matched. To label a match variable, we use (?<LABEL>PATTERN) where we replace LABEL with our own names.[*] We label the first capture name1 and the second one name2, and look in $+{name1} and $+{name2} to find their values:

    [*] Perl also lets us use the Python syntax (?P<LABEL>...) to do the same thing.

use 5.010;

my $names = 'Fred or Barney';
if( $names =~ m/(?<name1>\w+) (?:and|or) (?<name2>\w+)/ ) {
    say "I saw $+{name1} and $+{name2}";
    }


Now we see the right message:

I saw Fred and Barney


Once we label our captures, we can move them around and add additional capturing parentheses without disturbing the order of the captures:

use 5.010;

my $names = 'Fred or Barney';
if( $names =~ m/((?<name2>\w+) (and|or) (?<name1>\w+))/ ) {
    say "I saw $+{name1} and $+{name2}";
    }


Now that we have a way to label matches, we also need a way to refer to them for back references. Previously, we used either \1 or \g{1} for this. With a labeled group, we can use the label in \g{label}:

use 5.010;

my $names = 'Fred Flinstone and Wilma Flinstone';

if( $names =~ m/(?<last_name>\w+) and \w+ \g{last_name}/ ) {
    say "I saw $+{last_name}";
    }


We can do the same thing with another syntax. Instead of using \g{label}, we use \k<label>:[dagger]

    [dagger] \k<label> is slightly different than \g{label}. In patterns that have two or more labeled groups with the same label, \k<label> and \g{label} always refers to the leftmost group, but \g{N} can be a relative back reference. If you're a fan of Python, you can also use the (?P=label) syntax.

use 5.010;

my $names = 'Fred Flinstone and Wilma Flinstone';

if( $names =~ m/(?<last_name>\w+) and \w+ \k<last_name>/ ) {
    say "I saw $+{last_name}";
    }


		2.8.8 The Automatic Match Variables

There are three more match variables that you get for free,[*] whether the pattern has memory parentheses or not. That's the good news; the bad news is that these variables have weird names.

    [*] Yeah, right. There's no such thing as a free match. These are "free" only in the sense that they don't require match parentheses. Don't worry; we'll mention their real cost a little later, though.

Now, Larry probably would have been happy enough to call these by slightly-less-weird names, like perhaps $gazoo or $ozmodiar. But those are names that you just might want to use in your own code. To keep ordinary Perl programmers from having to memorize the names of all of Perl's special variables before choosing their first variable names in their first programs,[dagger] Larry has given strange names to many of Perl's built-in variables, names that "break the rules." In this case, the names are punctuation marks: $&, $`, and $'. They're strange, ugly, and weird, but those are their names.[double dagger] The part of the string that actually matched the pattern is automatically stored in $&:

    [dagger] You should still avoid a few classical variable names like $ARGV, but these few are all in all caps. All of Perl's built-in variables are documented in the perlvar manpage.

    [double dagger] If you really can't stand these names, check out the English module, which attempts to give all of Perl's strangest variables nearly normal names. But the use of this module has never really caught on; instead, Perl programmers have grown to love the punctuation-mark variable names, strange as they are.

if ("Hello there, neighbor" =~ /\s(\w+),/) {
  print "That actually matched '$&'.\n";
}


That tells us that the part that matched was " there," (with a space, a word, and a comma). Memory one, in $1, has just the five-letter word there, but $& has the entire matched section.

Whatever came before the matched section is in $`, and whatever was after it is in $'. Another way to say that is that $` holds whatever the regular expression engine had to skip over before it found the match, and $' has the remainder of the string that the pattern never got to. If you glue these three strings together in order, you'll always get back the original string:

if ("Hello there, neighbor" =~ /\s(\w+),/) {
  print "That was ($`)($&)($').\n";
}


The message shows the string as (Hello)( there,)( neighbor), showing the three automatic match variables in action. This may seem familiar, and for good reason: these automatic memory variables are what the pattern test program (from Chapter 7) was using in its line of "mystery" code, to show what part of the string was being matched by the pattern:

print "Matched: |$`<$&>$'|\n";  # The three automatic match variables


Any or all of these three automatic match variables may be empty, of course, just like the numbered match variables. And they have the same scope as the numbered match variables. Generally, that means that they'll stay around until the next successful pattern match.

Now, we said earlier that these three are "free." Well, freedom has its price. In this case, the price is that once you use any one of these automatic match variables anywhere in your entire program, other regular expressions will run a little more slowly.[*] Now, this isn't a giant slowdown, but it's enough of a worry that many Perl programmers will simply never use these automatic match variables.[dagger] Instead, they'll use a workaround. For example, if the only one you need is $&, just put parentheses around the whole pattern and use $1 instead (you may need to renumber the pattern's memories, of course).

    [*] For every block entry and exit, which is practically everywhere.

    [dagger] Most of these folks haven't benchmarked their programs to see whether their workarounds actually save time, though; it's as though these variables were poisonous or something. But we can't blame them for not benchmarkingmany programs that could benefit from these three variables take up only a few minutes of CPU time in a week, so benchmarking and optimizing would be a waste of time. But in that case, why fear a possible extra millisecond? By the way, the Perl developers are working on this problem, but there will probably be no solution before Perl 6.

Match variables (both the automatic ones and the numbered ones) are most often used in substitutions, which you'll see in the next chapter.

		2.8.7  General Quantifiers
A quantifier in a pattern means to repeat the preceding item a certain number of times. You've already seen three quantifiers: *, +, and ?. But if none of those three suits your needs, just use a comma-separated pair of numbers inside curly braces ({}) to specify exactly how few and how many repetitions are allowed.

So the pattern /a{5,15}/ will match from 5 to 15 repetitions of the letter a. If the a appears three times, that's too few, so it won't match. If it appears five times, it's a match. If it appears 10 times, that's still a match. If it appears 20 times, just the first 15 will match, since that's the upper limit.

If you omit the second number (but include the comma), there's no upper limit to the number of times the item will match. So, /(fred){3,}/ will match if there are three or more instances of fred in a row (with no extra characters, like spaces, allowed between each fred and the next). There's no upper limit so that would match 88 instances of fred if you had a string with that many.

If you omit the comma as well as the upper bound, the number given is an exact count: /\w{8}/ will match exactly eight word characters (occurring as part of a larger string, perhaps). And /,{5}chameleon/ matches "comma comma comma comma comma chameleon". By George, that is nice.

In fact, the three quantifier characters that you saw earlier are just common shortcuts. The star is the same as the quantifier {0,}, meaning zero or more. The plus is the same as {1,}, meaning one or more. And the question mark could be written as {0,1}. In practice, it's unusual to need any curly-brace quantifiers, since the three shortcut characters are nearly always the only ones needed.

		2.8.8  Precedence
With all of these metacharacters in regular expressions, you may feel that you can't keep track of the players without a scorecard. That's the precedence chart, which shows us which parts of the pattern "stick together" the most tightly. Unlike the precedence chart for operators, the regular expression precedence chart is simple, with only four levels. As a bonus, this section will review all of the metacharacters that Perl uses in patterns. Table 8-1 shows the precedence.

Table 8-1. Regular expression precedence
Regular expression feature		Example
Parentheses (grouping or memory)	(...), (?:...), (?<LABEL>...)
Quantifiers				a* a+ a? a{n,m}
Anchors and sequence			abc ^a a$
Alternation				a|b|c
Atoms					a [abc] \d \1

   a.  At the top of the precedence chart are the parentheses, (( )), used for grouping and memory. Anything in parentheses will "stick together" more tightly than anything else.
   b.  The second level is the quantifiers. These are the repeat operatorsstar (*), plus (+), and question mark (?)as well as the quantifiers made with curly braces, like {5,15}, {3,}, and {5}. These always stick to the item they're following.
   c.  The third level of the precedence chart holds anchors and sequence. The anchors are the caret (^) start-of-string anchor, the dollar-sign ($) end-of-string anchor, the \b word-boundary anchor, and the \B nonword-boundary anchor. Sequence (putting one item after another) is actually an operator, even though it doesn't use a metacharacter. That means that letters in a word will stick together just as tightly as the anchors stick to the letters.
   d.  The lowest level of precedence is the vertical bar (|) of alternation. Since this is at the bottom of the chart, it effectively cuts the pattern into pieces. It's at the bottom of the chart because we want the letters in the words in /fred|barney/ to stick together more tightly than the alternation. If alternation were of higher priority than sequence, that pattern would mean to match fre, followed by a choice of d or b, followed by arney. So, alternation is at the bottom of the chart, and the letters within the names stick together.
   e.  At the lowest level, there are the so-called atoms that make up the most basic pieces of the pattern. These are the individual characters, character classes, and back references.

			2.8.8.1  Examples of Precedence

When you need to decipher a complex regular expression, you'll need to do as Perl does and use the precedence chart to see what's really going on.

For example, /^fred|barney$/ is probably not what the programmer intended. That's because the vertical bar of alternation is very low precedence; it cuts the pattern in two. That pattern matches either fred at the beginning of the string or barney at the end. It's much more likely that the programmer wanted /^(fred|barney)$/, which will match if the whole line has nothing but fred or nothing but barney.[*] And what will /(wilma|pebbles?)/ match? The question mark applies to the previous character[dagger] so that will match either wilma or pebbles or pebble, perhaps as part of a larger string (since there are no anchors).

    [*] And, perhaps, a newline at the end of the string, as we mentioned earlier in connection with the $ anchor.

    [dagger] Because a quantifier sticks to the letter s more tightly than the s sticks to the other letters in pebbles.

The pattern /^(\w+)\s+(\w+)$/ matches lines that have a "word," some required whitespace, and another "word," with nothing else before or after. That might be used to match lines like fred flintstone, for example. The parentheses around the words aren't needed for grouping, so they may be intended to save those substrings into the regular expression memories.

When you're trying to understand a complex pattern, it may be helpful to add parentheses to clarify the precedence. That's okay, but remember that grouping parentheses are also automatically memory parentheses; use the noncapturing parentheses if you just want to group things.

			2.8.8.2 And There's More

Although we've covered all of the regular expression features that most people are likely to need for everyday programming, there are still even more features. A few are covered in the Alpaca book, but also check the perlre, perlrequick, and perlretut manpages for more information about what patterns in Perl can do.[double dagger]

    [double dagger] And check out YAPE::Regexp::Explain in CPAN as a regular-expression-to-English translator.

		2.8.9  A Pattern Test Program
When in the course of Perl events it becomes necessary for a programmer to write a regular expression, it may be difficult to tell just what the pattern will do. It's normal to find that a pattern matches more than you expected, or less. Or it may match earlier in the string than you expected, or later, or not at all.

This program is useful to test out a pattern on some strings and see just what it matches, and where:

#!/usr/bin/perl
while (<>) {                        # take one input line at a time
  chomp;
  if (/YOUR_PATTERN_GOES_HERE/) {
    print "Matched: |$`<$&>$'|\n";  # the special match vars
  } else {
    print "No match: |$_|\n";
  }
}


This pattern test program is written for programmers to use, not end users; you can tell because it doesn't have any prompts or usage information. It will take any number of input lines and check each one against the pattern that you'll put in place of the string saying YOUR_PATTERN_GOES_HERE. For each line that matches, it uses the three special match variables ($`, $&, and $') to make a picture of where the match happened. What you'll see is this: if the pattern is /match/ and the input is beforematchafter, the output will say "|before<match>after|" , using angle brackets to show you just what part of the string was matched by your pattern. If your pattern matches something you didn't expect, you'll be able to see that right away.

		2.8.10 Exercises
Several of these exercises ask you to use the test program from this chapter. You could manually type up this program, taking great care to get all of the odd punctuation marks correct.[*] But you'll probably find it faster and easier to simply download the program and some other goodies from the O'Reilly web site, as we mentioned in the Preface. You'll find this program under the name pattern_test.[dagger]

    [*] If you do type it up on your own, remember that the backquote character (`) is not the same as the apostrophe ('). On most full-sized computer keyboards these days (in the U.S., at least), the backquote is found on a key immediately to the left of the 1 key.

    [dagger] Don't be surprised if the program you download is a slightly different version than what we have in the book.

See Appendix A for answers to the following exercises:

   a.  [8] Using the pattern test program, make a pattern to match the string match. Try the program with the input string beforematchafter. Does the output show the three parts of the match in the right order?
   b.  [7] Using the pattern test program, make a pattern that matches if any word (in the \w sense of word) ends with the letter a. Does it match wilma but not barney? Does it match Mrs. Wilma Flintstone? What about wilma&fred? Try it on the sample text file from the previous chapter's exercises (and add these test strings if they weren't already in there).
   c.  [5] Modify the program from the previous exercise so that the word ending with the letter a is captured into memory $1. Update the code to display that variable's contents in single quotes, something like $1 contains 'Wilma'.
   d.  [5] Modify the program from the previous exercise to use named captures instead of relying on $1. Update the code to display that label name, something like 'word' contains 'Wilma'.
   e.  [5] Extra credit exercise: modify the program from the previous exercise so that immediately following the word ending in a it will also capture up to five characters (if there are that many characters, of course) in a separate memory variable. Update the code to display both memory variables. For example, if the input string says I saw Wilma yesterday, the up-to-five characters are yest. If the input is I, Wilma!, the extra memory should have just one character. Does your pattern still match just plain wilma?
   f.  [5] Write a new program (not the test program!) that prints out any input line ending with whitespace (other than just a newline). Put a marker character at the end of the output line so as to make the whitespace visible.

My answers at: /cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic
pattern_tester.pl
filter_lines_ending_with_space.pl

	2.9 Processing Text with Regular Expressions
	You can use regular expressions to change text too. So far we've only shown you how to match a pattern, and now we'll show you how to use patterns to locate the parts of strings that you want to change.
	
		2.9.1 Substitutions with s///
If you think of the m// pattern match as being like your word processor's "search" feature, the "search and replace" feature would be Perl's s/// substitution operator.  This simply replaces whatever part of a variable[218] matches a pattern with a replacement string:

    [218] Unlike m//, which can match against any string expression, s/// is modifying data that must therefore be contained in what's known as an lvalue. This is nearly always a variable, although it could actually be anything that could be used on the left side of an assignment operator.

$_ = "He's out bowling with Barney tonight.";
s/Barney/Fred/;  # Replace Barney with Fred
print "$_\n";


If the match fails, nothing happens, and the variable is untouched:

# Continuing from above; $_ has "He's out bowling with Fred tonight."
s/Wilma/Betty/;  # Replace Wilma with Betty (fails)


Of course, both the pattern and the replacement string could be more complex. Here, the replacement string uses the first memory variable, $1, which is set by the pattern match:

s/with (\w+)/against $1's team/;
print "$_\n";  # says "He's out bowling against Fred's team tonight."


Here are some other possible substitutions. (These are here only as samples; in the real world, it would not be typical to do so many unrelated substitutions in a row.)

$_ = "green scaly dinosaur";
s/(\w+) (\w+)/$2, $1/;  # Now it's "scaly, green dinosaur"
s/^/huge, /;            # Now it's "huge, scaly, green dinosaur"
s/,.*een//;             # Empty replacement: Now it's "huge dinosaur"
s/green/red/;           # Failed match: still "huge dinosaur"
s/\w+$/($`!)$&/;        # Now it's "huge (huge !)dinosaur"
s/\s+(!\W+)/$1 /;       # Now it's "huge (huge!) dinosaur"
s/huge/gigantic/;       # Now it's "gigantic (huge!) dinosaur"


There's a useful Boolean value from s///; it's true if a substitution was successful; otherwise, it's false:

$_ = "fred flintstone";
if (s/fred/wilma/) {
  print "Successfully replaced fred with wilma!\n";
}


			2.9.1.1 Global Replacements with /g

As you may have noticed in a previous example, s/// will make just one replacement, even if others are possible. Of course, that's just the default. The /g modifier tells s/// to make all possible nonoverlapping[*] replacements:

    [*] It's nonoverlapping because each new match starts looking just beyond the latest replacement.

$_ = "home, sweet home!";
s/home/cave/g;
print "$_\n";  # "cave, sweet cave!"


A fairly common use of a global replacement is to collapse whitespace; that is, to turn any arbitrary whitespace into a single space:

$_ = "Input  data\t may have    extra whitespace.";
s/\s+/ /g;  # Now it says "Input data may have extra whitespace."


Once we show collapsing whitespace, everyone wants to know about stripping leading and trailing whitespace. That's easy enough, in two steps:

s/^\s+//;  # Replace leading whitespace with nothing
s/\s+$//;  # Replace trailing whitespace with nothing


We could do that in one step with an alternation and the /g flag, but that turns out to be a bit slower, at least when we wrote this. The regular expression engine is always being tuned, but to learn more about that, you can get Jeffrey Friedl's Mastering Regular Expressions (O'Reilly) and find out what makes regular expressions fast (or slow).

s/^\s+|\s+$//g;  # Strip leading, trailing whitespace


			2.9.1.2 Different Delimiters

Just as we did with m// and qw//, we can change the delimiters for s///. But the substitution uses three delimiter characters, so things are a little different.

With ordinary (nonpaired) characters, which don't have a left and right variety, just use three of them, as we did with the forward slash. Here, we've chosen the pound sign[*] as the delimiter:

    [*] With apologies to our British friends, to whom the pound sign is something else! Although the pound sign is generally the start of a comment in Perl, it won't start a comment when the parser knows to expect a delimiterin this case, immediately after the s that starts the substitution.

s#^https://#http://#;


But if you use paired characters, which have a left and right variety, you have to use two pairs: one to hold the pattern and one to hold the replacement string. In this case, the delimiters don't have to be the same kind around the string as they are around the pattern. In fact, the delimiters of the string could even be nonpaired. These are all the same:

s{fred}{barney};
s[fred](barney);
s<fred>#barney#;


			2.9.1.3 Option Modifiers

In addition to the /g modifier,[dagger] substitutions may use the /i, /x, and /s modifiers that you saw in ordinary pattern matching (the order of modifiers isn't significant):

    [dagger] We still speak of the modifiers with names like /i, even if the delimiter is something other than a slash.

s#wilma#Wilma#gi;  # replace every WiLmA or WILMA with Wilma
s{__END__.*}{}s;   # chop off the end marker and all following lines


			2.9.1.4 The Binding Operator

Just as you saw with m//, we can choose a different target for s/// by using the binding operator:

$file_name =~ s#^.*/##s;  # In $file_name, remove any Unix-style path


			2.9.1.5 Case Shifting

It often happens in a substitution that you'll want to make sure that a replacement word is properly capitalized (or not, as the case may be). That's easy to accomplish with Perl, by using some backslash escapes. The \U escape forces what follows to all uppercase:

$_ = "I saw Barney with Fred.";
s/(fred|barney)/\U$1/gi;  # $_ is now "I saw BARNEY with FRED."


Similarly, the \L escape forces lowercase. Continuing from the previous code:

s/(fred|barney)/\L$1/gi;  # $_ is now "I saw barney with fred."


By default, these affect the rest of the (replacement) string, or you can turn off case shifting with \E:

s/(\w+) with (\w+)/\U$2\E with $1/i;  # $_ is now "I saw FRED with barney."


When written in lowercase (\l and \u ), they affect only the next character:

s/(fred|barney)/\u$1/ig;  # $_ is now "I saw FRED with Barney."


You can even stack them up. Using \u with \L means "all lowercase, but capitalize the first letter":[*]

    [*] The \L and \u may appear together in either order. Larry realized that people would sometimes get those two backward, so he made Perl figure out that you want just the first letter capitalized and the rest lowercase. Larry is a pretty nice guy.

s/(fred|barney)/\u\L$1/ig;  # $_ is now "I saw Fred with Barney."


As it happens, although we're covering case shifting in relation to substitutions, these escape sequences are available in any double-quotish string:

print "Hello, \L\u$name\E, would you like to play a game?\n";

		2.9.2 The split Operator
Another operator that uses regular expressions is split, which breaks up a string according to a pattern. This is useful for tab-separated data, or colon-separated, whitespace-separated, or anything-separated data, really.[dagger] So long as you can specify the separator with a regular expression (and generally, it's a simple regular expression), you can use split. It looks like this:

    [dagger] Except "comma-separated values," normally called CSV files. Those are a pain to do with split; you're better off getting the Text::CSV module from CPAN.

@fields = split /separator/, $string;


The split operator[double dagger] drags the pattern through a string and returns a list of fields (substrings) that were separated by the separators. Whenever the pattern matches, that's the end of one field and the start of the next. So, anything that matches the pattern will never show up in the returned fields. Here's a typical split pattern, splitting on colons:

    [double dagger] It's an operator, even though it acts a lot like a function, and everyone generally calls it a function. But the technical details of the difference are beyond the scope of this book.

@fields = split /:/, "abc:def:g:h";  # gives ("abc", "def", "g", "h")


You could even have an empty field, if there were two delimiters together:

@fields = split /:/, "abc:def::g:h";  # gives ("abc", "def", "", "g", "h")


Here's a rule that seems odd at first, but it rarely causes problems: leading empty fields are always returned, but trailing empty fields are discarded. For example:[||]

    [||] This is merely the default. It's this way for efficiency. If you worry about losing trailing empty fields, use -1 as a third argument to split and they'll be kept; see the perlfunc manpage.

@fields = split /:/, ":::a:b:c:::";  # gives ("", "", "", "a", "b", "c")


It's also common to split on whitespace, using /\s+/ as the pattern. Under that pattern, all whitespace runs are equivalent to a single space:

my $some_input = "This  is a \t        test.\n";
my @args = split /\s+/, $some_input;  # ("This", "is", "a", "test.")


The default for split is to break up $_ on whitespace:

my @fields = split;  # like split /\s+/, $_;


This is almost the same as using /\s+/ as the pattern, except that in this special case a leading empty field is suppressed--so, if the line starts with whitespace, you won't see an empty field at the start of the list. (If you'd like to get the same behavior when splitting another string on whitespace, just use a single space in place of the pattern: split ' ', $other_string. Using a space instead of the pattern is a special kind of split.)

Generally, the patterns used for split are as simple as the ones you see here. But if the pattern becomes more complex, be sure to avoid using memory parentheses in the pattern since these trigger the (usually) wanted "separator retention mode" (see the perlfunc manpage for details). Use the noncapturing parentheses, (?:), in split if you need to group things.

		2.9.3 The join Function
The join function doesn't use patterns, but performs the opposite function of split: split breaks up a string into a number of pieces, and join glues together a bunch of pieces to make a single string. The join function looks like this:

my $result = join $glue, @pieces;


The first argument to join is the glue, which may be any string. The remaining arguments are a list of pieces. join puts the glue string between the pieces and returns the resulting string:

my $x = join ":", 4, 6, 8, 10, 12;  # $x is "4:6:8:10:12"


In that example, we had five items, so there are only four colons. That is, there are four pieces of glue. The glue shows up only between the pieces, never before or after them. So, there will be one fewer piece of glue than the number of items in the list.

This means that there may be no glue at all if the list doesn't have at least two elements:

my $y = join "foo", "bar";       # gives just "bar", since no foo glue is needed
my @empty;                       # empty array
my $empty = join "baz", @empty;  # no items, so it's an empty string

					  


Using $x from above, we can break up a string and put it back together with a different delimiter:

my @values = split /:/, $x;  # @values is (4, 6, 8, 10, 12)
my $z = join "-", @values;   # $z is "4-6-8-10-12"


Although split and join work well together, don't forget that the first argument to join is always a string, not a pattern.

		2.9.4 m// in List Context
When you use split, the pattern specifies the separator: the part that isn't the useful data. Sometimes it's easier to specify what you want to keep.

When a pattern match (m//) is used in a list context, the return value is a list of the memory variables created in the match, or an empty list if the match failed:

$_ = "Hello there, neighbor!";
my($first, $second, $third) = /(\S+) (\S+), (\S+)/;
print "$second is my $third\n";


This makes it easy to give the match variables easy-to-use names, and these names may persist past the next pattern match. (Note also that because there's no =~ in that code, the pattern matches against $_ by default.)

The /g modifier that you first saw on s/// also works with m//, which lets it match at more than one place in a string. In this case, a pattern with a pair of parentheses will return a memory from each time it matches:

my $text = "Fred dropped a 5 ton granite block on Mr. Slate";
my @words = ($text =~ /([a-z]+)/ig);
print "Result: @words\n";
# Result: Fred dropped a ton granite block on Mr Slate


This is like using split "inside out": instead of specifying what we want to remove, we specify what we want to keep.

In fact, if there is more than one pair of parentheses, each match may return more than one string. Let's say that we have a string that we want to read into a hash, something like this:

my $data = "Barney Rubble Fred Flintstone Wilma Flintstone";
my %last_name = ($data =~ /(\w+)\s+(\w+)/g);


Each time the pattern matches, it returns a pair of memories. Those pairs of values then become the key-value pairs in the newly created hash.

		2.9.5 More Powerful Regular Expressions
After already reading three (almost!) chapters about regular expressions, you know that they're a powerful feature in the core of Perl. But there are even more features that the Perl developers have added; you'll see some of the most important ones in this section. At the same time, you'll see a little more about the internal operation of the regular expression engine.

			2.9.5.1 Nongreedy Quantifiers

The four quantifiers you've already seen (in Chapters Chapter 7 and Chapter 8) are all greedy. That means that they match as much as they can, only to reluctantly give some back if that's necessary to allow the overall pattern to succeed. Here's an example: Suppose you're using the pattern /fred.+barney/ on the string fred and barney went bowling last night. Of course, we know that the regular expression will match that string, but let's see how it goes about it.[*] First, of course, the subpattern fred matches the identical literal string. The next part of the pattern is the .+, which matches any character except newline, at least one time. But the plus quantifier is greedy; it prefers to match as much as possible. So it immediately matches all of the rest of the string, including the word night. (This may surprise you, but the story isn't over yet.)

    [*] The regular expression engine makes a few optimizations that make the true story different than we tell it here, and those optimizations change from one release of Perl to the next. You shouldn't be able to tell from the functionality that it's not doing as we say, though. If you want to know how it really works, you should read the latest source code. Be sure to submit patches for any bugs you find.

Now the subpattern barney would like to match, but it can'twe're at the end of the string. But since the .+ could still be successful even if it matched one fewer character, it reluctantly gives back the letter t at the end of the string. (It's greedy, but it wants the whole pattern to succeed even more than it wants to match everything all by itself.)

The subpattern barney tries again to match, and still can't. So the .+ gives back the letter h and lets it try again. One character after another, the .+ gives back what it matched until finally it gives up all of the letters of barney. Now, finally, the subpattern barney can match, and the overall match succeeds.

Regular expression engines do a lot of backtracking like that, trying every different way of fitting the pattern to the string until one of them succeeds, or until none of them has.[dagger] But as you could see from this example, that can involve a lot of backtracking, as the quantifier gobbles up too much of the string and the regular expression engine forces it to return some of it.

    [dagger] In fact, some regular expression engines try every different way, even continuing on after they find one that fits. But Perl's regular expression engine is primarily interested in whether the pattern can or cannot match, so finding even one match means that the engine's work is done. Again, see Mastering Regular Expressions.

For each of the greedy quantifiers, though, there's also a nongreedy quantifier available. Instead of the plus (+), we can use the nongreedy quantifier +?, which matches one or more times (just as the plus does), except that it prefers to match as few times as possible, rather than as many as possible. Let's see how that new quantifier works when the pattern is rewritten as /fred.+?barney/.

Once again, fred matches right at the start. But this time the next part of the pattern is .+?, which would prefer to match no more than one character, so it matches just the space after fred. The next subpattern is barney, but that can't match here (since the string at the current position begins with and barney...). So the .+? reluctantly matches the a and lets the rest of the pattern try again. Once again, barney can't match, so the .+? accepts the letter n and so on. Once the .+? has matched five characters, barney can match, and the pattern is a success.

[Yosi, Note that the eqiuvalent in VIM is \{-1,} for example:
though.\{-1,}
see :h non-greedy
]

There was still some backtracking, but since the engine had to go back and try again just a few times, it should be a big improvement in speed. Well, it's an improvement if you'll generally find barney near fred. If your data often had fred near the start of the string and barney only at the end, the greedy quantifier might be a faster choice. In the end, the speed of the regular expression depends upon the data.

But the nongreedy quantifiers aren't just about efficiency. Although they'll always match (or fail to match) the same strings as their greedy counterparts, they may match different amounts of the strings. For example, suppose you had some HTML-like[*] text, and you want to remove all of the tags <BOLD> and </BOLD>, leaving their contents intact. Here's the text:

    [*] Once again, we aren't using real HTML because you can't correctly parse HTML with simple regular expressions. If you really need to work with HTML or a similar markup language, use a module that's made to handle the complexities.

    I'm talking about the cartoon with Fred and <BOLD>Wilma</BOLD>! 

And here's a substitution to remove those tags. But what's wrong with it?

s#(.*)#$1#g;


The problem is that the star is greedy.[dagger] What if the text had said this instead?

    [dagger] There's another possible problem: we should have used the /s modifier as well, since the end tag may be on a different line than the start tag. It's a good thing that this is just an example; if we were writing something like this for real, we would have taken our own advice and used a well-written module.

    I thought you said Fred and <BOLD>Velma</BOLD>, not <BOLD>Wilma</BOLD>

In that case, the pattern would match from the first <BOLD> to the last </BOLD>, leaving intact the ones in the middle of the line. Oops! Instead, we want a nongreedy quantifier. The nongreedy form of star is *?, so the substitution now looks like this:

    s#<BOLD>(.*?)</BOLD>#$1#g;

And it does the right thing.

Since the nongreedy form of the plus was +? and the nongreedy form of the star was *?, you've probably realized that the other two quantifiers look similar. The nongreedy form of any curly-brace quantifier looks the same, but with a question mark after the closing brace, like {5,10}? or {8,}?.[double dagger] And even the question-mark quantifier has a nongreedy form: ??. That matches either once or not at all, but it prefers not to match anything.

    [double dagger] In theory, there's also a nongreedy quantifier form that specifies an exact number, like {3}?. But since that says to match exactly three of the preceding item, it has no flexibility to be either greedy or nongreedy.

			2.9.5.2 Matching Multiple-Line Text

Classic regular expressions were used to match just single lines of text. But since Perl can work with strings of any length, Perl's patterns can match multiple lines of text as easily as single lines. Of course, you have to include an expression that holds more than one line of text. Here's a string that's four lines long:

$_ = "I'm much better\nthan Barney is\nat bowling,\nWilma.\n";


Now, the anchors ^ and $ are normally anchors for the start and end of the whole string (see Chapter 8). But the /m regular expression option lets them match at internal newlines as well (think m for multiple lines). This makes them anchors for the start and end of each line, rather than the whole string. So this pattern can match:

print "Found 'wilma' at start of line\n" if /^wilma\b/im;


Similarly, you could do a substitution on each line in a multiline string. Here, we read an entire file into one variable,[*] then add the file's name as a prefix at the start of each line:

    [*] Hope it's a small one. The file, that is, not the variable.

open FILE, $filename
  or die "Can't open '$filename': $!";
my $lines = join '', <FILE>;
$lines =~ s/^/$filename: /gm;


			2.9.5.3 Updating Many Files

The most common way of programmatically updating a text file is by writing an entirely new file that looks similar to the old one, but making whatever changes we need as we go along. As you'll see, this technique gives nearly the same result as updating the file itself, but it has some beneficial side effects as well.

In this example, we've got hundreds of files with a similar format. One of them is fred03.dat, and it's full of lines like these:

Program name: granite
Author: Gilbert Bates
Company: RockSoft
Department: R&D
Phone: +1 503 555-0095
Date: Tues March 9, 2004
Version: 2.1
Size: 21k
Status: Final beta


We need to fix this file so that it has some different information. Here's roughly what this one should look like when we're done:

Program name: granite
Author: Randal L. Schwartz
Company: RockSoft
Department: R&D
Date: June 12, 2008 6:38 pm
Version: 2.1
Size: 21k
Status: Final beta


In short, we need to make three changes. The name of the Author should be changed; the Date should be updated to today's date, and the Phone should be removed completely. And we have to make these changes in hundreds of similar files as well.

Perl supports a way of in-place editing of files with a little extra help from the diamond operator (<>). Here's a program to do what we want, although it may not be obvious how it works at first. This program's only new feature is the special variable $^I; ignore that for now, and we'll come back to it:

#!/usr/bin/perl -w

use strict;

chomp(my $date = `date`);
$^I = ".bak";

while (<>) {
  s/^Author:.*/Author: Randal L. Schwartz/;
  s/^Phone:.*\n//;
  s/^Date:.*/Date: $date/;
  print;
}


Since we need today's date, the program starts by using the system date command. A better way to get the date (in a slightly different format) would almost surely be to use Perl's own localtime function in a scalar context:

my $date = localtime;


The next line sets $^I, but keep ignoring that for the moment.

The list of files for the diamond operator here are coming from the command line. The main loop reads, updates, and prints one line at a time. (With what you know so far, that means that all of the files' newly modified contents will be dumped to your terminal, scrolling furiously past your eyes, without the files being changed at all. But stick with us.) Note that the second substitution can replace the entire line containing the phone number with an empty string--leaving not even a newline--so when that's printed, nothing comes out, and it's as if the Phone never existed. Most input lines won't match any of the three patterns, and those will be unchanged in the output.

So this result is close to what we want, except that we haven't shown you how the updated information gets back out on to the disk. The answer is in the variable $^I. By default it's undef, and everything is normal. But when it's set to some string, it makes the diamond operator (<>) even more magical than usual.

We already know about much of the diamond's magic--it will automatically open and close a series of files for you, or read from the standard-input stream if there aren't any filenames given. But when there's a string in $^I, that string is used as a backup filename's extension. Let's see that in action.

Let's say it's time for the diamond to open our file fred03.dat. It opens it like before, but now it renames it, calling it fred03.dat.bak.[*] We've still got the same file open, but now it has a different name on the disk. Next, the diamond creates a new file and gives it the name fred03.dat. That's okay; we weren't using that name any more. And now the diamond selects the new file as the default for output, so that anything that we print will go into that file.[dagger] So now the while loop will read a line from the old file, update that, and print it out to the new file. This program can update thousands of files in a few seconds on a typical machine. Pretty powerful, huh?

    [*] Some of the details of this procedure will vary on non-Unix systems, but the end result should be nearly the same. See the release notes for your port of Perl.

    [dagger] The diamond also tries to duplicate the original file's permission and ownership settings as much as possible; for example, if the old one was world-readable, the new one should be as well.

Once the program has finished, what does the user see? The user says, "Ah, I see what happened! Perl edited my file fred03.dat, making the changes I needed, and saved me a copy of the original in the backup file fred03.dat.bak just to be helpful!" But we now know the truth: Perl didn't really edit any file. It made a modified copy, said "Abracadabra!" and switched the files around while we were watching sparks come out of the magic wand. Tricky.

Some folks use a tilde (~) as the value for $^I since that resembles what emacs does for backup files. Another possible value for $^I is the empty string. This enables in-place editing, but doesn't save the original data in a backup file. But since a small typo in your pattern could wipe out all of the old data, using the empty string is recommended only if you want to find out how good your backup tapes are. It's easy enough to delete the backup files when you're done. And when something goes wrong and you need to rename the backup files to their original names, you'll be glad that you know how to use Perl to do that (see the multiple-file rename example in Chapter 14).

			2.9.5.4 In-Place Editing from the Command Line

A program like the example from the previous section is fairly easy to write. But Larry decided it wasn't easy enough.

Imagine that you need to update hundreds of files that have the misspelling Randall instead of the one-l name Randal. You could write a program like the one in the previous section. Or you could do it all with a one-line program, right on the command line:

$ perl -p -i.bak -w -e 's/Randall/Randal/g' fred*.dat


Perl has a whole slew of command-line options that can be used to build a complete program in a few keystrokes.[*] Let's see what these few do.

    [*] See the perlrun manpage for the complete list.

Starting the command with perl does something like putting #!/usr/bin/perl at the top of a file does: it says to use the program perl to process what follows.

The -p option tells Perl to write a program for you. It's not much of a program, though; it looks something like this:[dagger]

    [dagger] Actually, the print occurs in a continue block. See the perlsyn and perlrun manpages for more information.

while (<>) {
  print;
}


If you want even less, you could use -n instead; that leaves out the automatic print statement, so you can print only what you wish. (Fans of awk will recognize -p and -n.) Again, it's not much of a program, but it's pretty good for the price of a few keystrokes.

[Yosi: 
The following is the perl equivalent of grep -i yosi *
 cat * | perl  -n -e 'if (/yosi/i) {print;}'
 and 
 perl  -n -e 'if (/yosi/i) {print;}' *
 ]
The next option is -i.bak, which you might have guessed sets $^I to ".bak" before the program starts. If you don't want a backup file, you can use -i alone, with no extension. If you don't want a spare parachute, you can leave the airplane with just one.

We've seen -w beforeit turns on warnings.

The -e option says "executable code follows." That means the s/Randall/Randal/g string is treated as Perl code. Since we've already got a while loop (from the -p option), this code is put inside the loop, before the print. For technical reasons, the last semicolon in the -e code is optional. But if you have more than one -e, and thus more than one chunk of code, only the semicolon at the end of the last one may safely be omitted.

The last command-line parameter is fred*.dat, which says that @ARGV should hold the list of filenames that match that filename pattern. Put the pieces all together, and it's as if we had written a program like this, and put it to work on all of those fred*.dat files:

#!/usr/bin/perl -w

$^I = ".bak";

while (<>) {
  s/Randall/Randal/g;
  print;
}


Compare this program to the one we used in the previous section. It's pretty similar. These command-line options are pretty handy, aren't they?

		2.9.6 Exercises	
# [7] Make a pattern that will match three consecutive copies of whatever is currently contained in $what. That is, if $what is fred, your pattern should match fredfredfred. If $what is fred|barney, your pattern should match fredfredbarney or barneyfredfred or barneybarneybarney or many other variations. (Hint: you should set $what at the top of the pattern test program with a statement like my $what = 'fred|barney';.)
# [12] Write a program that makes a modified copy of a text file. In the copy, every string Fred (case-insensitive) should be replaced with Larry. (So, Manfred Mann should become ManLarry Mann.) The input filename should be given on the command line (don't ask the user!), and the output filename should be the corresponding filename ending with .out.
# [8] Modify the previous program to change every Fred to Wilma and every Wilma to Fred. Now input like fred&wilma should look like Wilma&Fred in the output.
# [10] Extra credit exercise: write a program to add a copyright line to all of your exercise answers so far, by placing a line like:

 ## Copyright (C) 20XX by Yours Truly


in the file immediately after the "shebang" line. You should edit the files "in place," keeping a backup. Presume that the program will be invoked with the filenames to edit already on the command line.
# [15] Extra extra credit exercise: modify the previous program so that it doesn't edit the files that already contain the copyright line. (Hint: you might need to know that the name of the file being read by the diamond operator is in $ARGV.)


My answers at: /cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic
match_user_pattern.pl
Example: [yizaq@yytzhak-wxp:Sun Jan 11:/cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic:]$ ./match_user_pattern.pl 'aa|xx' *
Matched: |#<aaxxaa>|

modify_file_reg_exp.pl  
[yizaq@yytzhak-wxp:Sun Jan 11:/cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic:]$ cat inp
Fred
Manfred
fredasds
sdfasdFrEdasd
[yizaq@yytzhak-wxp:Sun Jan 11:/cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic:]$ ./modify_file_reg_exp.pl  inp 
[yizaq@yytzhak-wxp:Sun Jan 11:/cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic:]$ cat inp.out 
Larry
ManLarry
Larryasds
sdfasdLarryasd

replace fred with wilma and vice versa
[yizaq@yytzhak-wxp:Sun Jan 11:/cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic:]$ cat inp
Fred
Manfred
fredasds
sdfasdFrEdasd
[yizaq@yytzhak-wxp:Sun Jan 11:/cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic:]$ ./modify_file_reg_exp.pl  inp 
[yizaq@yytzhak-wxp:Sun Jan 11:/cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic:]$ cat inp.out 
Wilma
ManWilma
Wilmaasds
sdfasdWilmaasd
Fred Wilma Fred Wilma Wilma Fred Fred

[yizaq@yytzhak-wxp:Mon Jan 12:/cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic:]$ ./add_copyrights.pl *.pl
[yizaq@yytzhak-wxp:Mon Jan 12:/cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic:]$ diff add_copyrights.pl  add_copyrights.pl.bac 
2d1
< ## Copyright (C) Mon Jan 12 11:38:48 2009 Yosi Izaq, Cisco Systems


	2.10 More Control Structures
In this chapter, you'll see some alternative ways to write Perl code. For the most part, these techniques don't make the language more powerful, but they make it easier or more convenient to get the job done. You don't have to use these techniques in your own code, but don't be tempted to skip this chapteryou're certain to see these control structures in other people's code, sooner or later (in fact, you're absolutely certain to see these things in use by the time you finish reading this book).

		2.10.1  The unless Control Structure
In an if control structure, the block of code is executed only when the conditional expression is true. If you want to execute a block of code only when the conditional is false, change if to unless:

unless ($fred =~ /^[A-Z_]\w*$/i) {
  print "The value of \$fred doesn't look like a Perl identifier name.\n";
}


Using unless says to run the block of code unless this condition is true. It's just like using an if test with the opposite condition. Another way to say it is that it's like having the else clause on its own. That is, whenever you see an unless that you don't understand, you can rewrite it (either in your head or in reality) as an if test:

if ($fred =~ /^[A-Z_]\w*$/i) {
  # Do nothing
} else {
  print "The value of \$fred doesn't look like a Perl identifier name.\n";
}


It's no more or less efficient, and it should compile to the same internal byte codes. Or, another way to rewrite it would be to negate the conditional expression by using the negation operator (!):

if ( ! ($fred =~ /^[A-Z_]\w*$/i) ) {
  print "The value of \$fred doesn't look like a Perl identifier name.\n";
}


Generally, you should pick the way of writing code that makes the most sense to you, since that will probably make the most sense to your maintenance programmer. If it makes the most sense to write if with a negation, do that. More often, however, you'll probably find it natural to use unless.

			2.10.1.1  The else Clause with unless

You could even have an else clause with an unless. While this syntax is supported, it's potentially confusing:

unless ($mon =~ /^Feb/) {
  print "This month has at least thirty days.\n";
} else {
  print "Do you see what's going on here?\n";
}


Some people may wish to use this, especially when the first clause is very short (perhaps only one line) and the second is several lines of code. But we'd make this one a negated if, or maybe simply swap the clauses to make a normal if:

if ($mon =~ /^Feb/) {
  print "Do you see what's going on here?\n";
} else {
  print "This month has at least thirty days.\n";
}


It's important to remember that you're always writing code for two readers: the computer that will run the code and the human being who has to keep the code working. If the human can't understand what you've written, pretty soon the computer won't be doing the right thing either.

		2.10.2  The until Control Structure
Sometimes you'll want to reverse the condition of a while loop. To do that, just use until:

until ($j > $i) {
  $j *= 2;
}


This loop runs until the conditional expression returns true. But it's really just a while loop in disguise, except that this one repeats as long as the conditional is false, rather than true. The conditional expression is evaluated before the first iteration, so this is still a zero-or-more-times loop, just like the while loop.[236] As with if and unless, you could rewrite any until loop to become a while loop by negating the condition. But generally, you'll find it simple and natural to use until from time to time.

    [236] Pascal programmers, take note: in Pascal, the repeat-until always runs at least one iteration, but an until loop in Perl may not run at all, if the conditional expression is true before the loop starts.

		2.10.3  Expression Modifiers
In order to have a more compact notation, an expression may be followed by a modifier that controls it. For example, the if modifier works in a way analogous to an if block:

print "$n is a negative number.\n" if $n < 0;


That gives exactly the same result as if we had used this code, except that we saved some typing by leaving out the parentheses and curly braces:[*]

    [*] We also left out the linebreaks. But we should mention that the curly-brace form does create a new scope. In the rare case that you need the full details, check the documentation.

if ($n < 0) {
  print "$n is a negative number.\n";
}


As we've said, Perl folks generally like to avoid typing. And the shorter form reads in English: print this message if $n is less than zero.

Notice that the conditional expression is still evaluated first, even though it's written at the end. This is backward from the usual left-to-right ordering; in understanding Perl code, you'll have to do as Perl's internal compiler does, and read to the end of the statement before you can tell what it's really doing.

There are other modifiers as well:

&error("Invalid input") unless &valid($input);
$i *= 2 until $i > $j;
print " ", ($n += 2) while $n < 10;
&greet($_) foreach @person;


These all work just as (we hope) you would expect. That is, each one could be rewritten in a similar way to rewriting the if-modifier example earlier. Here is one:

while ($n < 10) {
  print " ", ($n += 2);
}


The expression in parentheses inside the print argument list is noteworthy because it adds two to $n, storing the result back into $n. Then it returns that new value, which will be printed.

These shorter forms read almost like a natural language: call the &greet subroutine for each @person in the list. Double $i until it's larger than $j.[dagger] One of the common uses of these modifiers is in a statement like this one:

    [dagger] Well, it helps us to think of them like that.

print "fred is '$fred', barney is '$barney'\n"           if $I_am_curious;


By writing the code "in reverse" like this, you can put the important part of the statement at the beginning. The point of that statement is to monitor some variables; the point is not to check whether you're curious.[*] Some people prefer to write the whole statement on one line, perhaps with some tab characters before the if, to move it over toward the right margin, as we showed in the previous example, while others put the if modifier indented on a new line:

    [*] Of course, we made up the name $I_am_curious; it's not a built-in Perl variable. Generally, folks who use this technique will either call their variable $TRACING or use a constant declared with the constant pragma.

print "fred is '$fred', barney is '$barney'\n"
    if $I_am_curious;


Although you can rewrite any of these expressions with modifiers as a block (the "old-fashioned" way), the converse isn't necessarily true. Only a single expression is allowed on either side of the modifier. So you can't write something if something while something until something unless something foreach something, which would just be too confusing. And you can't put multiple statements on the left of the modifier. If you need more than just a simple expression on each side, just write the code the old-fashioned way, with the parentheses and curly braces.

As we mentioned in relation to the if modifier, the control expression (on the right) is always evaluated first, just as it would be in the old-fashioned form.

With the foreach modifier, there's no way to choose a different control variableit's always $_. Usually, that's no problem, but if you want to use a different variable, you'll need to rewrite it as a traditional foreach loop.
	

		2.10.4  The Naked Block Control Structure
The so-called naked block is one without a keyword or condition. That is, suppose you start with a while loop, which looks something like this:

while (condition) {
  body;
  body;
  body;
}


Now, take away the while keyword and the conditional expression, and you'll have a naked block:

{
  body;
  body;
  body;
}


The naked block is like a while or foreach loop, except that it doesn't loop; it just executes the body of the loop once, and it's done. It's an un-loop!

You'll see in a while that there are other uses for the naked block, but one of its features is that it provides a scope for temporary lexical variables:

{
  print "Please enter a number: ";
  chomp(my $n = <STDIN>);
  my $root = sqrt $n;  # calculate the square root
  print "The square root of $n is $root.\n";
}


In this block, $n and $root are temporary variables scoped to the block. As a general guideline, all variables should be declared in the smallest scope available. If you need a variable for just a few lines of code, you can put those lines into a naked block and declare the variable inside that block. Of course, if you would need the value of either $n or $root later, you would need to declare them in a larger scope.

You may have noticed the sqrt function in that code and wondered about ityes, it's a function we haven't shown before. Perl has many built-in functions that are beyond the scope of this book. When you're ready, check the perlfunc manpage to learn about more of them.

		2.10.5  The elsif Clause
Every so often, you may need to check a number of conditional expressions, one after another, to see which one of them is true. This can be done with the if control structure's elsif clause, as in this example:

if ( ! defined $dino) {
  print "The value is undef.\n";
} elsif ($dino =~ /^-?\d+\.?$/) {
  print "The value is an integer.\n";
} elsif ($dino =~ /^-?\d*\.\d+$/) {
  print "The value is a _simple_ floating-point number.\n";
} elsif ($dino eq '') {
  print "The value is the empty string.\n";
} else {
  print "The value is the string '$dino'.\n";
}


Perl will test the conditional expressions one after another. When one succeeds, the corresponding block of code is executed, and then the whole control structure is done,[*] and execution goes on to the rest of the program. If none has succeeded, the else block at the end is executed. (Of course, the else clause is still optional, but, in this case, it's often a good idea to include it.)

    [*] There's no "fall-through" to the next block, as in the "switch" structure of languages like C.

There's no limit to the number of elsif clauses, but remember that Perl has to evaluate the first 99 tests before it can get to the 100th. If you'll have more than half a dozen elsifs, you should consider whether there's a more efficient way to write it. The Perl FAQ (see the perlfaq manpage) has a number of suggestions for emulating the "case" or "switch" statements of other languages, and users of Perl 5.10 or later can use given-when, described in Chapter 15, as an alternative.

You may have noticed by this point that the keyword is spelled elsif, with only one e. If you write it as "elseif", with a second e, Perl will tell you that it is not the correct spelling. Why not? Because Larry says so.[*]

    [*] In fact, he resists any suggestion that it even be permitted as a valid alternative spelling. "If you want to spell it with a second e, it's simple. Step 1make up your own language. Step 2make it popular." When you make your own programming language, you can spell the keywords in any way you'd like. We hope that you will decide that yours shouldn't be the first to have an "elseunless."

		2.10.6  Autoincrement and Autodecrement
You'll often want a scalar variable to count up or down by one. Since these are frequent constructs, there are shortcuts for them, like nearly everything else we do frequently.

The autoincrement operator (++) adds one to a scalar variable, like the same operator in C and similar languages:

my $bedrock = 42;
$bedrock++;  # add one to $bedrock; it's now 43


Just like other ways of adding one to a variable, the scalar will be created if necessary:

my @people = qw{ fred barney fred wilma dino barney fred pebbles };
my %count;                     # new empty hash
$count{$_}++ foreach @people;  # creates new keys and values as needed


The first time through that foreach loop, $count{$_} is incremented. That's $count{"fred"}, which thus goes from undef (since it didn't previously exist in the hash) up to 1. The next time through the loop, $count{"barney"} becomes 1; after that, $count{"fred"} becomes 2. Each time through the loop, one element in %count is incremented, and possibly created as well. After that loop is done, $count{"fred"} is 3. This provides a quick and easy way to see which items are in a list and how many times each one appears.

Similarly, the autodecrement operator (--) subtracts one from a scalar variable:

$bedrock--;  # subtract one from $bedrock; it's 42 again


			2.10.6.1  The Value of Autoincrement

You can fetch the value of a variable and change that value at the same time. Put the ++ operator in front of the variable name to increment the variable first and then fetch its value. This is a preincrement:

my $m = 5;
my $n = ++$m;  # increment $m to 6, and put that value into $n


Or put the -- operator in front to decrement the variable first and then fetch its value. This is a predecrement:

my $c = --$m;  # decrement $m to 5, and put that value into $c


Here's the tricky part. Put the variable name first to fetch the value first, and then do the increment or decrement. This is called a postincrement or postdecrement:

my $d = $m++;  # $d gets the old value (5), then increment $m to 6
my $e = $m--;  # $e gets the old value (6), then decrement $m to 5


It's tricky because we're doing two things at once. We're fetching the value, and we're changing it in the same expression. If the operator is first, we increment (or decrement) first, then use the new value. If the variable is first, we return its (old) value first, then do the increment or decrement. Another way to say it is that these operators return a value, but they also have the side effect of modifying the variable's value.

If you write these in an expression of their own,[*] not using the value but only the side effect, there's no difference[dagger] if you put the operator before or after the variable:

    [*] That is, in a void context.

    [dagger] Programmers who get inside the implementations of languages may expect that postincrement and postdecrement would be less efficient than their counterparts, but Perl's not like that. Perl automatically optimizes the post- forms when they're used in a void context.

$bedrock++;  # adds one to $bedrock
++$bedrock;  # just the same; adds one to $bedrock


A common use of these operators is in connection with a hash, to identify when an item has been seen before:

my @people = qw{ fred barney bamm-bamm wilma dino barney betty pebbles };
my %seen;

foreach (@people) {
  print "I've seen you somewhere before, $_!\n"
    if $seen{$_}++;
}


When barney shows up for the first time, the value of $seen{$_}++ is false, since it's the value of $seen{$_}, which is $seen{"barney"}, which is undef. But that expression has the side effect of incrementing $seen{"barney"}. When barney shows up again, $seen{"barney"} is now a true value, so the message is printed.

		2.10.7  The for Control Structure
Perl's for control structure is like the common for control structure you may have seen in other languages, such as C. It looks like this:

for (initialization; test; increment) {
  body;
  body;
}


To Perl, though, this kind of loop is really a while loop in disguise, something like this:[*]

    [*] Actually, the increment happens in a continue block, which is beyond the scope of this book. See the perlsyn manpage for the truth.

initialization;
while (test) {
  body;
  body;
  increment;
}


The most common use of the for loop, by far, is for making computed iterations:

for ($i = 1; $i <= 10; $i++) {  # count from 1 to 10
  print "I can count to $i!\n";
}


When you've seen these before, you'll know what the first line is saying even before you read the comment. Before the loop starts, the control variable, $i, is set to 1. Then, the loop is really a while loop in disguise, looping while $i is less than or equal to 10. Between each iteration and the next is the increment, which here is a literal increment, adding one to the control variable, which is $i.

So, the first time through this loop, $i is 1. Because that's less than or equal to 10, we see the message. Although the increment is written at the top of the loop, it logically happens at the bottom of the loop, after printing the message. So, $i becomes 2, which is less than or equal to 10, so we print the message again, and $i is incremented to 3, which is less than or equal to 10, and so on.

Eventually, we print the message that our program can count to 9. Then $i is incremented to 10, which is less than or equal to 10, so we run the loop one last time and print that our program can count to 10. Finally, $i is incremented for the last time, to 11, which is not less than or equal to 10. So control drops out of the loop, and we're on to the rest of the program.

All three parts are together at the top of the loop so that it's easy for an experienced programmer to read that first line and say, "Ah, it's a loop that counts $i from one to ten."

Note that after the loop is done, the control variable has a value "after" the loop. That is, in this case, the control variable has gone all the way to 11.[dagger] This loop is a very versatile loop; you can make it count in all sorts of ways. For example, we can count down from 10 to 1:

    [dagger] Obligatory This is Spinal Tap outdated pop-culture reference.

for ($i = 10; $i >= 1; $i--) {
  print "I can count down to $i\n";
}


And this loop counts from -150 to 1000 by threes:[*]

    [*] Of course, it never gets to 1000 exactly. The last iteration uses 999, since each value of $i is a multiple of three.

for ($i = -150; $i <= 1000; $i += 3) {
  print "$i\n";
}


In fact, you could make any of the three control parts (initialization, test, or increment) empty, if you wish, but you still need the two semicolons. In this (quite unusual) example, the test is a substitution, and the increment is empty:

for ($_ = "bedrock"; s/(.)//; ) {  # loops while the s/// is successful
  print "One character is: $1\n";
}


The test expression (in the implied while loop) is the substitution, which will return a true value if it succeeded. In this case, the first time through the loop, the substitution will remove the b from bedrock. Each iteration will remove another letter. When the string is empty, the substitution will fail, and the loop is done.

If the test expression (the one between the two semicolons) is empty, it's automatically true, making an infinite loop. But don't make an infinite loop like this until you see how to break out of such a loop, which we'll discuss later in this chapter:

for (;;) {
  print "It's an infinite loop!\n";
}


A more Perl-like way to write an intentional infinite loop, when you really want one,[dagger] is with while:

    [dagger] If you somehow made an infinite loop that's gotten away from you, see whether Control-C will halt it. It's possible that you'll get a lot of output even after typing Control-C, depending upon your system's I/O and other factors. Hey, we warned you.

while (1) {
  print "It's another infinite loop!\n";
}


Although C programmers are familiar with the first way, even a beginning Perl programmer should recognize that 1 is always true, making an intentional infinite loop, so the second is generally a better way to write it. Perl is smart enough to recognize a constant expression like that and optimize it away, so there's no difference in efficiency.

			2.10.7.1  The Secret Connection Between foreach and for

It turns out that, inside the Perl parser, the keyword foreach is exactly equivalent to the keyword for. That is, any time Perl sees one of them, it's the same as if you had typed the other. Perl can tell which you meant by looking inside the parentheses. If you've got the two semicolons, it's a computed for loop (like we've just been talking about). If you don't have the semicolons, it's really a foreach loop:

for (1..10) {  # Really a foreach loop from 1 to 10
  print "I can count to $_!\n";
}


That's really a foreach loop, but it's written for. Except for that one example, all through this book, we'll spell out foreach wherever it appears. But in the real world, do you think that Perl folks will type those extra four letters?[*] Excepting only beginners' code, it's always written for, and you'll have to do as Perl does and look for the semicolons to tell which kind of loop it is.

    [*] If you think that, you haven't been paying attention. Among programmers, especially Perl programmers, laziness is one of the classic virtues. If you don't believe us, ask someone at the next Perl Mongers' meeting.

In Perl, the true foreach loop is almost always a better choice. In the foreach loop (written for) in that previous example, it's easy to see at a glance that the loop will go from 1 to 10. But do you see what's wrong with this computed loop that's trying to do the same thing? Don't peek at the answer in the footnote until you think you've found what's wrong:[dagger]

    [dagger] There are two and one-half bugs. First, the conditional uses a less-than sign, so the loop will run 9 times, instead of 10. It's easy to get a so-called fencepost bug with this kind of loop, like what happened when the rancher needed enough fenceposts to make a 30-meter-long fence with a post every 3 meters. (The answer is not 10 fenceposts.) Second, the control variable is $i, but the loop body is using $_. And second and a half, it's a lot more work to read, write, maintain, and debug this type of loop, which is why we say that the true foreach is generally a better choice in Perl.

for ($i = 1; $i < 10; $i++) {  # Oops! Something is wrong here!
  print "I can count to $_!\n";
}
		2.10.8  Loop Controls
As you've surely noticed by now, Perl is one of the so-called structured programming languages. In particular, there's just one entrance to any block of code, at the top of that block. But there are times when you may need more control or versatility than what we've shown so far. For example, you may need to make a loop like a while loop, but one that always runs at least once. Or maybe you need to occasionally exit a block of code early. Perl has three loop-control operators you can use in loop blocks to make the loop do all sorts of tricks.

			2.10.8.1  The last Operator (C's break)

The last operator immediately ends execution of the loop. (If you've used the "break" operator in C or a similar language, it's like that.) It's the "emergency exit" for loop blocks. When you hit last, the loop is done. For example:

# Print all input lines mentioning fred, until the __END__ marker
while (<STDIN>) {
  if (/__END__/) {
    # No more input on or after this marker line
    last;
  } elsif (/fred/) {
    print;
  }
}
## last comes here #


Once an input line has the __END__ marker, that loop is done. Of course, that comment line at the end is merely a comment--it's not required in any way. We just threw that in to make it clearer what's happening.

There are five kinds of loop blocks in Perl. These are the blocks of for, foreach, while, until, or the naked block.[*] The curly braces of an if block or subroutine[dagger] don't qualify. As you may have noticed in the example above, the last operator applied to the entire loop block.

    [*] Yes, you can use last to jump out of a naked block. That's not exactly the same as jumping naked out into your block.

    [dagger] It's probably not a good idea, but you could use these loop control operators from inside a subroutine to control a loop that is outside the subroutine. That is, if a subroutine is called in a loop block, and the subroutine executes last when there's no loop block running inside the subroutine, the flow of control will jump to just after the loop block in the main code. This ability to use loop control from within a subroutine may go away in a future version of Perl, and no one is likely to miss it.

The last operator will apply to the innermost currently running loop block. To jump out of outer blocks, stay tuned; that's coming up in a little bit.

			2.10.8.2 The next Operator (C's continue)

Sometimes you're not ready for the loop to finish, but you're done with the current iteration. That's what the next operator is good for. It jumps to the inside of the bottom of the current loop block.[double dagger] After next, control continues with the next iteration of the loop (much like the "continue" operator in C or a similar language):

    [double dagger] This is another of our many lies. In truth, next jumps to the start of the (usually omitted) continue block for the loop. See the perlsyn manpage for the full details.

# Analyze words in the input file or files
while (<>) {
  foreach (split) {  # break $_ into words, assign each to $_ in turn
    $total++;
    next if /\W/;    # strange words skip the remainder of the loop
    $valid++;
    $count{$_}++;    # count each separate word
    ## next comes here ##
  }
}

print "total things = $total, valid words = $valid\n";
foreach $word (sort keys %count) {
  print "$word was seen $count{$word} times.\n";
}


This one is a little more complex than most of our examples up to this point, so let's take it step by step. The while loop is reading lines of input from the diamond operator, one after another, into $_; you've seen that before. Each time through that loop, another line of input will be in $_.

Inside that loop, the foreach loop is iterating over the return value split. Do you remember the default for split with no arguments?[*] That splits $_ on whitespace, in effect breaking $_ into a list of words. Since the foreach loop doesn't mention some other control variable, the control variable will be $_. So, we'll see one word after another in $_.

    [*] If you don't remember it, don't worry too much. Don't waste any brain cells remembering things that you can look up with perldoc.
(Yosi, $ perldoc -f split)

But didn't we just say that $_ holds one line of input after another? Well, in the outer loop, that's what it is. But inside the foreach loop, it holds one word after another. It's no problem for Perl to reuse $_ for a new purpose; this happens all the time.

Now, inside the foreach loop, we're seeing one word at a time in $_. $total is incremented, so it must be the total number of words. But the next line (which is the point of this example) checks to see whether the word has any nonword characters--anything but letters, digits, and underscores. So, if the word is Tom's, or if it is full-sized, or if it has an adjoining comma, quote mark, or any other strange character, it will match that pattern and we'll skip the rest of the loop, going on to the next word.

But let's say that it's an ordinary word, like fred. In that case, we count $valid up by one, and also $count{$_}, keeping a count for each different word. So, when we finish the two loops, we've counted every word in every line of input from every file the user wanted us to use.

We're not going to explain the last few lines. By now, we hope you've got stuff like that down already.

Like last, next may be used in any of the five kinds of loop blocks: for, foreach, while, until, or the naked block. Also, if loop blocks are nested, next works with the innermost one. You'll see how to change that at the end of this section.

			2.10.8.3 The redo Operator

The third member of the loop control triad is redo. It says to go back to the top of the current loop block, without testing any conditional expression or advancing to the next iteration. (If you've used C or a similar language, you've never seen this one before. Those languages don't have this kind of operator.) Here's an example:

# Typing test
my @words = qw{ fred barney pebbles dino wilma betty };
my $errors = 0;

foreach (@words) {
  ## redo comes here ##
  print "Type the word '$_': ";
  chomp(my $try = <STDIN>);
  if ($try ne $_) {
    print "Sorry - That's not right.\n\n";
    $errors++;
    redo;  # jump back up to the top of the loop
  }
}
print "You've completed the test, with $errors errors.\n";


Like the other two operators, redo will work with any of the five kinds of loop blocks, and it will work with the innermost loop block when they're nested.

The big difference between next and redo is that next will advance to the next iteration, but redo will redo the current iteration. Here's an example program that you can play with to get a feel for how these three operators work:[*]

    [*] If you've downloaded the example files from the O'Reilly web site (as described in the Preface), you'll find this program, called lnr-example.

foreach (1..10) {
  print "Iteration number $_.\n\n";
  print "Please choose: last, next, redo, or none of the above? ";
  chomp(my $choice = <STDIN>);
  print "\n";
  last if $choice =~ /last/i;
  next if $choice =~ /next/i;
  redo if $choice =~ /redo/i;
  print "That wasn't any of the choices... onward!\n\n";
}
print "That's all, folks!\n";


If you just press Return without typing anything (try it two or three times), the loop counts along from one number to the next. If you choose last when you get to number four, the loop is done, and you won't go on to number five. If you choose next when you're on four, you're on to number five without printing the "onward" message. And if you choose redo when you're on four, you're back to doing number four all over again.

			2.10.8.4 Labeled Blocks

When you need to work with a loop block that's not the innermost one, use a label. Labels in Perl are like other identifiers--made of letters, digits, and underscores, but they can't start with a digit--however, since they have no prefix character, labels could be confused with the names of built-in function names, or even with your own subroutines' names. So, it would be a poor choice to make a label called print or if. Because of that, Larry recommends that they be all uppercase. That not only ensures that the label won't conflict with another identifier but it also makes it easy to spot the label in the code. In any case, labels are rare, only showing up in a small percentage of Perl programs.

To label a loop block, just put the label and a colon in front of the loop. Then, inside the loop, you may use the label after last, next, or redo as needed:

LINE: while (<>) {
  foreach (split) {
    last LINE if /__END__/;  # bail out of the LINE loop
    ...
  }
}


For readability, it's generally nice to put the label at the left margin, even if the current code is at a higher indentation. Notice that the label names the entire block; it's not marking a target point in the code.[*] In that previous snippet of sample code, the special __END__ token marks the end of all input. Once that token shows up, the program will ignore any remaining lines (even from other files).

    [*] This isn't goto, after all.

It often makes sense to choose a noun as the name of the loop.[dagger] That is, the outer loop is processing a line at a time, so we called it LINE. If we had to name the inner loop, we would have called it WORD, since it processes a word at a time. That makes it convenient to say things like "(move on to the) next WORD"or "redo (the current) LINE".

    [dagger] That is, it makes more sense to do that than not to do that. Perl doesn't care if you call your loop labels things like XYZZY or PLUGH. However, unless you were friendly with the Colossal Cave in the '70s, you might not get the reference.
    
    '
		2.10.9  The Ternary Operator, ?:
When Larry was deciding which operators to make available in Perl, he didn't want former C programmers to miss something that C had and Perl didn't, so he brought all of C's operators over to Perl.[double dagger] That meant bringing over C's most confusing operator: the ternary ?: operator. While it may be confusing, it can also be quite useful.

    [double dagger] Well, to be sure, he did leave out the ones that have no use in Perl, such as the operator that turns a number into the memory address of a variable. And he added several operators (like the string concatenation operator) that make C folks jealous of Perl.

The ternary operator is like an if-then-else test, all rolled into an expression. It is called a "ternary" operator because it takes three operands. It looks like this:

expression ? if_true_expr : if_false_expr


First, the expression is evaluated to see whether it's true or false. If it's true, the second expression is used; otherwise, the third expression is used. Every time, one of the two expressions on the right is evaluated, and one is ignored. That is, if the first expression is true, then the second expression is evaluated, and the third is ignored. If the first expression is false, then the second is ignored, and the third is evaluated as the value of the whole thing.

In this example, the result of the subroutine &is_weekend determines which string expression will be assigned to the variable:

my $location = &is_weekend($day) ? "home" : "work";


And here, we calculate and print out an averageor just a placeholder line of hyphens, if there's no average available:

my $average = $n ? ($total/$n) : "-----";
print "Average: $average\n";


You could always rewrite any use of the ?: operator as an if structure, often much less conveniently and less concisely:

my $average;
if ($n) {
  $average = $total / $n;
} else {
  $average = "-----";
}
print "Average: $average\n";


Here's a trick you might see used to code up a nice multiway branch:

my $size =
  ($width < 10) ? "small"  :
  ($width < 20) ? "medium" :
  ($width < 50) ? "large"  :
                  "extra-large"; # default


That is really just three nested ?: operators, and it works quite well, once you get the hang of it.

Of course, you're not obliged to use this operator. Beginners may wish to avoid it. But you'll see it in others' code, sooner or later, and we hope that one day you'll find a good reason to use it in your own programs.

		2.10.10 Logical Operators
As you might expect, Perl has all of the necessary logical operators needed to work with Boolean (true/false) values. For example, it's often useful to combine logical tests by using the logical AND operator (&&) and the logical OR operator (||):

if ($dessert{'cake'} && $dessert{'ice cream'}) {
  # Both are true
  print "Hooray! Cake and ice cream!\n";
} elsif ($dessert{'cake'} || $dessert{'ice cream'}) {
  # At least one is true
  print "That's still good...\n";
} else {
  # Neither is true - do nothing (we're sad)
}


There may be a shortcut. If the left side of a logical AND operation is false, the whole thing is false, since logical AND needs both sides to be true in order to return true. In that case, there's no reason to check the right side, so it will not even be evaluated. Consider what happens in this example if $hour is 3:

if ( (9 <= $hour) && ($hour < 17) ) {
  print "Aren't you supposed to be at work...?\n";
}


Similarly, if the left side of a logical OR operation is true, the right side will not be evaluated. Consider what happens here if $name is fred:

if ( ($name eq 'fred') || ($name eq 'barney') ) {
  print "You're my kind of guy!\n";
}


Because of this behavior, these operators are called "short-circuit" logical operators. They take a short circuit to the result whenever they can. In fact, it's fairly common to rely upon this short-circuit behavior. Suppose you need to calculate an average:

if ( ($n != 0) && ($total/$n < 5) ) {
  print "The average is below five.\n";
}


In that example, the right side will be evaluated only if the left side is true, so we can't accidentally divide by zero and crash the program.

			2.10.10.1 The Value of a Short-Circuit Operator

Unlike what happens in C (and similar languages), the value of a short-circuit logical operator is the last part evaluated, not just a Boolean value. This provides the same result, in that the last part evaluated is always true when the whole thing should be true, and it's always false when the whole thing should be false.

But it's a much more useful return value. Among other things, the logical OR operator is quite handy for selecting a default value:

my $last_name = $last_name{$someone} || '(No last name)';


If $someone is not listed in the hash, the left side will be undef, which is false. So, the logical OR will have to look to the right side for the value, making the right side the default. In this idiom, the default value won't merely replace undef; it would replace any false value equally well. You could fix that with the ternary operator:

my $last_name = defined $last_name{$someone} ?
    $last_name{$someone} : '(No last name)';


That's too much work, and you had to say $last_name{$someone} twice. Perl 5.10 added a better way to do this, and it's the next section.

			2.10.10.2 The defined-or Operator

In the previous section, you saw us use the || operator to give a default value. That ignored the special case; there the defined value was false but perfectly acceptable as a value. You then saw the uglier version using the ternary operator.

Perl 5.10 gets around this sort of bug with the defined-or operator, //, which short-circuits when it finds a defined value, no matter if that value on the lefthand side is true or false. Even if someone's last name is 0, this version still works:

use 5.010;

my $last_name = $last_name{$someone} // '(No last name)';


Sometimes you just want to give a variable a value if it doesn't already have one, and leave it alone if it does. Suppose you want to print messages only if you set the VERBOSE environment variable. You check the value for the VERBOSE key in the %ENV hash. If it doesn't have a value, you want to give it one:

use 5.010;

my $Verbose = $ENV{VERBOSE} // 1;
print "I can talk to you!\n" if $Verbose;


You can see this in action by trying several values with // to see which ones pass through to the default value:

use 5.010;

foreach my $try ( 0, undef, '0', 1, 25 ) {
    print "Trying [$try] ---> ";
    my $value = $try // 'default';
    say "\tgot [$value]";
    }


The output shows that you only get the default string when $try is undef:

Trying [0] --->     got [0]
Trying [] --->      got [default]
Trying [0] --->     got [0]
Trying [1] --->     got [1]
Trying [25] --->    got [25]


Sometimes you want to set a value when there isn't one already. For instance, when you have warnings enabled and try to print an undefined value, you get an annoying error:

use warnings;

my $name;  # no value, so undefined!
printf "%s", $name; # Use of uninitialized value in printf ...


Sometimes that error is harmless. You could just ignore it, but if you expect that you might try to print an undefined value, you can use the empty string instead:

use 5.010;
use warnings;

my $name;  # no value, so undefined!
printf "%s", $name // '';


			2.10.10.3 Control Structures Using Partial-Evaluation Operators

The four operators that you've just seen&&, ||, //, and ?:all share a peculiar property: depending upon the value on the left side, they may or may not evaluate an expression. Sometimes the expression is evaluated, and sometimes it isn't. For that reason, these are sometimes called partial-evaluation operators, since they may not evaluate all of the expressions around them. And partial-evaluation operators are automatically control structures.[*] It's not as if Larry felt a burning need to add more control structures to Perl. But once he had decided to put these partial-evaluation operators into Perl, they automatically became control structures as well. After all, anything that can activate and deactivate a chunk of code is, by that very fact, a control structure.

    [*] Some of you were wondering why these logical operators are being covered in this chapter, weren't you?

Fortunately, you'll notice this only when the controlled expression has side effects, like altering a variable's value or causing some output. For example, suppose you ran across this line of code:

($m < $n) && ($m = $n);


Right away, you should notice that the result of the logical AND isn't being assigned anywhere.[dagger] Why not?

    [dagger] But don't forget to consider that it might be a return value, as the last expression in a subroutine.

If $m is really less than $n, the left side is true, so the right side will be evaluated, thereby doing the assignment. But if $m is not less than $n, the left side will be false, and thus the right side would be skipped. So that line of code would do essentially the same thing as this one, which is easier to understand:

if ($m < $n) { $m = $n }


Or maybe you'll be maintaining a program, and you'll see a line like this one:

($m > 10) || print "why is it not greater?\n";


If $m is really greater than 10, the left side is true, and the logical OR is done. But if it's not, the left side is false, and this will go on to print the message. Once again, this could (and probably should) be written in the traditional way, probably with if or unless.

If you have a particularly twisted brain, you might even learn to read these lines as if they were written in English. For example: check that $m is less than $n, and if it is, then do the assignment. Check that $m is more than 10, or if it's not, then print the message.

It's generally former C programmers or old-time Perl programmers who most often use these ways of writing control structures. Why do they do it? Some have the mistaken idea that these are more efficient. Some think these tricks make their code cooler. Some are merely copying what they saw someone else do.

In the same way, the ternary operator may be used for control. In this case, we want to assign $x to the smaller of two variables:

($m < $n) ? ($m = $x) : ($n = $x);


If $m is smaller, it gets $x. Otherwise, $n does.

There is another way to write the logical AND and logical OR operators. You may wish to write them out as words: and and or.[*] These word operators have the same behaviors as the ones written with punctuation, but the words are down at the bottom of the precedence chart. Since the words don't "stick" so tightly to the nearby parts of the expression, they may need fewer parentheses:

    [*] There are also the low-precedence not (like the logical-negation operator, !) and the rare xor.

$m < $n and $m = $n;  # but better written as the corresponding if


Then again, you may need more parentheses. Precedence is a bugaboo. Be sure to use parentheses to say what you mean, unless you're sure of the precedence. Nevertheless, since the word forms are very low precedence, you can generally understand that they cut the expression into big pieces, doing everything on the left first, and then (if needed) everything on the right.

Despite the fact that using logical operators as control structures can be confusing, sometimes they're the accepted way to write code. The idiomatic way of opening a file in Perl looks like this:

open CHAPTER, $filename
  or die "Can't open '$filename': $!";


By using the low-precedence short-circuit or operator, we're telling Perl that it should "open this file¿ or die!" If the open succeeds, returning a true value, the or is complete. But if it fails, the false value causes the or to evaluate the part on the right, which will die with a message.

So, using these operators as control structures is part of idiomatic PerlPerl as she is spoken. Used properly, they can make your code more powerful; otherwise, they can make your code unmaintainable. Don't overuse them.[*]

    [*] Using these weird forms (anything but or die) more than once per month counts as overuse.

		2.10.11 Exercises	
# [25] Make a program that will repeatedly ask the user to guess a secret number from 1 to 100 until the user guesses the secret number. Your program should pick the number at random by using the magical formula int(1 + rand 100).[dagger] When the user guesses wrong, the program should respond "Too high" or "Too low." If the user enters the word quit or exit, or if the user enters a blank line, the program should quit. Of course, if the user guesses correctly, the program should quit then as well!

    [dagger] See what the perlfunc manpage says about int and rand if you're curious about these functions.

# [10] Modify the program from the previous exercise to print extra debugging information as it goes along, such as the secret number it chose. Make your change such that you can turn it off, but your program emits no warnings if you turn it off. If you are using Perl 5.10, use the // operator. Otherwise, use the ternary operator.
# [10] Modify the program from Exercise 3 in Chapter 6 (the environment lister) to print (undefined value) for environment variables without a value. You can set the new environment variables in the program. Ensure that your program reports the right thing for variables with a false value. If you are using Perl 5.10, use the // operator. Otherwise, use the ternary operator.


My answers at: /cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic
guess_number.pl
print_env.pl

	2.11 Perl Modules
	
There is a lot more to Perl than what we're able to show you in this book, and there are a lot of people doing a lot of interesting things with Perl. If there is a problem to solve, then somebody has probably already solved it and made their solution available on the Comprehensive Perl Archive Network (CPAN), which is a worldwide collection of servers and mirrors containing thousands of modules of reusable Perl code.

		2.11.1 Finding Modules

We're not going to teach you how to write modules here: you'll have to get that from the Alpaca book. In this chapter, we'll show you how to use modules that already exist.

			2.11.1.1 Finding Modules

Modules come in two types: those that come with Perl and that you should have available to you, and those that you can get from CPAN to install yourself. Unless we say otherwise, the modules that we discuss come with Perl.

To find modules that don't come with Perl, start at either CPAN Search (http://search.cpan.org) or Kobes' Search (http://kobesearch.cpan.org/).[263] You can browse through the categories or search directly.

    [263] Yes, there should be two s's in that URL, but there aren't and nobody ever fixed it.

Either of those resources is great since you can read the module before you download the entire package. You can also browse the distribution and have a peek at the files without the bother of installing the modules.

Before you go looking for a module, you should check whether it is already installed. One way is to just try to read the documentation with perldoc. The CGI.pm module comes with Perl (and we'll discuss it later in this chapter), so you should be able to read its documentation:

$ perldoc CGI


Try it with a module that does not exist and you'll get an error message.

$ perldoc Llamas
$ No documentation found for "Llamas".


The documentation may be available in other formats, such as HTML, on your system, too. If the documentation is there.[*]

    [*] We cover Perl documentation in Intermediate Perl (O'Reilly), but for now, just believe us that most module documentation is in the same file as the actual code.

		2.11.2 Installing Modules
When you want to install a module that you don't already have, sometimes you can simply download the distribution, unpack it, and run a series of commands from the shell. Check for a README or INSTALL file that gives you more information. If the module uses MakeMaker,[dagger] the sequence will be something like this:

    [dagger] That's really the Perl module ExtUtils::MakeMaker, which comes with Perl. It handles all of the stuff to create the file that will have the installation instructions appropriate for your system and installation of Perl.

$ perl Makefile.PL
$ make install


If you can't install modules in the system-wide directories, you can specify another directory with a PREFIX argument to Makefile.PL:

$ perl Makefile.PL PREFIX=/Users/fred/lib


Some Perl module authors use another module, Module::Build, to build and install their creations. That sequence will be something like this:

$ perl Build.PL
$ ./Build install


Some modules depend on other modules though, and they won't work unless you install yet more modules. Instead of doing all that work ourselves, we can use one of the modules that comes with Perl, CPAN.pm.[double dagger] From the command line, you can start up the CPAN.pm, from which you can issue commands:

    [double dagger] The ".pm" file extension stands for "Perl Module," and some popular modules are pronounced with the ".pm" to distinguish them from something else. In this case, CPAN the archive is different than CPAN the module, so the latter is said "CPAN.pm."

$ perl -MCPAN -e shell


Even this can be a little complicated, so a while ago one of our authors wrote a little script called "cpan," which also comes with Perl and is usually installed with perl and its tools. Just call the script with a list of the modules you want to install:

$ cpan Module::CoreList LWP CGI::Prototype


You might be saying, "But I don't have a command line!" If you are using the ActiveState port of Perl (for Windows, Linux, or Solaris), you can use the Perl Package Manager (PPM),[*] which installs modules for you. You can even get the ActiveState ports on CD or DVD.[dagger] Besides what you've seen so far, your particular operating system may have ways to install software, including Perl modules.

    [*] http://aspn.activestate.com/ASPN/docs/ActivePerl/faq/ActivePerl-faq2.html

    [dagger] You can make your own CDs or DVDs too by creating a local repository. Even though CPAN is almost 4 GB by now, a "minicpan" (again, by one of the authors) pares it down to just the latest versions of everything, which is about 800 MB. See the CPAN::Mini module.

		2.11.3 Using Simple Modules
Suppose that you've got a long filename like /usr/local/bin/perl in your program, and you need to find out the basename. That's easy enough, since the basename is everything after the last slash (it's just perl in this case):

my $name = "/usr/local/bin/perl";
(my $basename = $name) =~ s#.*/##;  # Oops!


As you saw earlier, first Perl will do the assignment inside the parentheses, then it will do the substitution. The substitution is supposed to replace any string ending with a slash (that is, the directory name portion) with an empty string, leaving just the basename.

And if you try this, it seems to work. Well, it seems to, but actually, there are three problems.

First, a Unix file or directory name could contain a newline character. (It's not something that's likely to happen by accident, but it's permitted.) So, since the regular expression dot (.) can't match a newline, a filename like the string "/home/fred/flintstone\n/brontosaurus" won't work rightthat code would think the basename is "flintstone\n/brontosaurus". You could fix that with the /s option to the pattern (if you remembered about this subtle and infrequent case), making the substitution look like this: s#.*/##s. The second problem is that this is Unix-specific. It assumes that the forward slash will always be the directory separator, as it is on Unix, and not the backslash or colon that some systems use.

And the third (and biggest) problem with this is that we're trying to solve a problem that someone else has already solved. Perl comes with a number of modules, which are smart extensions to Perl that add to its functionality. And if those aren't enough, there are many other useful modules available on CPAN, with new ones being added every week. You (or, better yet, your system administrator) can install them if you need their functionality.

In the rest of this section, we'll show you how to use some of the features of a couple of simple modules that come with Perl. (There's more that these modules can do; this is just an overview to illustrate the general principles of how to use a simple module.)

Alas, we can't show you everything you'd need to know about using modules in general, since you'd have to understand advanced topics like references and objects in order to use some modules.[*] Those topics, including how to create a module, are covered in great detail in the Alpaca. But this section should prepare you for using many simple modules. Further information on some interesting and useful modules is included in Appendix B.

    [*] As we'll see in the next few pages, though, you may be able to use a module that uses objects and references without having to understand those advanced topics.

			2.11.3.1 The File::Basename Module

In the previous example, we found the basename of a filename in a way that's not portable. We showed that something that seemed straightforward was susceptible to subtle mistaken assumptions (here, the assumption was that newlines would never appear in file or directory names). And we were reinventing the wheel, solving a problem that others have solved (and debugged) many times before us.

Here's a better way to extract the basename of a filename. Perl comes with a module called File::Basename. With the command perldoc File::Basename, or with your system's documentation system, you can read about what it does. That's the first step when using a new module. (It's often the third and fifth steps, as well.)

Soon you're ready to use it, so you declare it with a use directive near the top of your program:[dagger]

 use File::Basename


    [dagger] It's traditional to declare modules near the top of the file, since that makes it easy for the maintenance programmer to see which modules you'll be using. That greatly simplifies matters when it's time to install your program on a new machine, for example.

During compilation, Perl sees that line and loads up the module. Now, it's as if Perl has some new functions that you may use in the remainder of your program.[double dagger] The one we wanted in the earlier example is the basename function itself:

    [double dagger] You guessed it: there's more to the story, having to do with packages and fully qualified names. When your programs are growing beyond a few hundred lines in the main program (not counting code in modules), which is quite large in Perl, you should probably read up about these advanced features. Start with the perlmod manpage.

my $name = "/usr/local/bin/perl";
my $basename = basename $name;  # gives 'perl'


Well, that worked for Unix. What if our program were running on MacPerl or Windows or VMS, to name a few? There's no problemthis module can tell which kind of machine you're using, and it uses that machine's filename rules by default. (Of course, you'd have that machine's kind of filename string in $name, in that case.)

There are some related functions also provided by this module. One is the dirname function, which pulls the directory name from a full filename. The module also lets you separate a filename from its extension, or change the default set of filename rules.[*]

    [*] You might need to change the filename rules if you were trying to work with a Unix machine's filenames from a Windows machineperhaps while sending commands over an FTP connection, for example.

			2.11.3.2 Using Only Some Functions from a Module

Suppose you discovered that when you went to add the File::Basename module to your existing program, you already have a subroutine called &dirnamethat is, you already have a subroutine with the same name as one of the module's functions.[dagger] Now there's trouble because the new dirname is also implemented as a Perl subroutine (inside the module). What do you do?

    [dagger] Well, it's not likely that you would already have a &dirname subroutine that you use for another purpose, but this is just an example. Some modules offer hundreds (really!) of new functions, making a name collision that much more frequent.

Simply give File::Basename, in your use declaration, an import list showing exactly which function names it should give you, and it'll supply those and no others. Here, we'll get nothing but basename:

use File::Basename qw/ basename /;


And here, we'll ask for no new functions at all:

use File::Basename qw/ /;


This is also frequently written as:

use File::Basename ();


Why would you want to do that? Well, this directive tells Perl to load File::Basename, just as before, but not to import any function names. Importing lets us use the short, simple function names like basename and dirname. But even if we don't import those names, we can still use the functions. When they're not imported, though, we have to call them by their full names:

use File::Basename qw/ /;                     # import no function names

my $betty = &dirname($wilma);                 # uses our own subroutine &dirname
                                                   #(not shown)

my $name = "/usr/local/bin/perl";
my $dirname = File::Basename::dirname $name;  # dirname from the module

					  


As you can see, the full name of the dirname function from the module is File::Basename::dirname. We can always use the function's full name (once we've loaded the module) whether we've imported the short name dirname or not.

Most of the time, you'll want to use a module's default import list. But you can always override that with a list of your own if you want to leave out some of the default items. Another reason to supply your own list would be if you wanted to import some function not on the default list, since most modules include some (infrequently needed) functions that are not on the default import list.

As you'd guess, some modules will, by default, import more symbols than others. Each module's documentation should make it clear which symbols it imports, if any, but you are always free to override the default import list by specifying one of your own, just as we did with File::Basename. Supplying an empty list imports no symbols.

			2.11.3.3 The File::Spec Module

Now you can find out a file's basename. That's useful, but you'll often want to put that together with a directory name to get a full filename. For example, here we want to take a filename like /home/rootbeer/ice-2.1.txt and add a prefix to the basename:

use File::Basename;

print "Please enter a filename: ";
chomp(my $old_name = <STDIN>);

my $dirname = dirname $old_name;
my $basename = basename $old_name;

$basename =~ s/^/not/;  # Add a prefix to the basename
my $new_name = "$dirname/$basename";

rename($old_name, $new_name)
  or warn "Can't rename '$old_name' to '$new_name': $!";


Do you see the problem here? Once again, we're making the assumption that filenames will follow the Unix conventions and use a forward slash between the directory name and the basename. Fortunately, Perl comes with a module to help with this problem, too.

The File::Spec module is used for manipulating file specifications, which are the names of files, directories, and the other things that are stored on filesystems. Like File::Basename, it understands what kind of system it's running on, and it chooses the right set of rules every time. But unlike File::Basename, File::Spec is an object-oriented (often abbreviated OO) module.

If you've never caught the fever of OO, don't let that bother you. If you understand objects, that's great; you can use this OO module. If you don't understand objects, that's okay, too. You just type the symbols as we show you, and it works just as if you knew what you were doing.

In this case, we learn from reading the documentation for File::Spec that we want to use a method called catfile. What's a method? It's just a different kind of function, as far as we're concerned here. The difference is that you'll always call the methods from File::Spec with their full names, like this:

use File::Spec;

.
.  # Get the values for $dirname and $basename as above
.

my $new_name = File::Spec->catfile($dirname, $basename);

rename($old_name, $new_name)
  or warn "Can't rename '$old_name' to '$new_name': $!";


As you can see, the full name of a method is the name of the module (called a class here), a small arrow (->) and the short name of the method. It is important to use the small arrow, rather than the double colon we used with moreinfo="none">File::Basename.

Since we're calling the method by its full name, though, what symbols does the module import? None of them. That's normal for OO modules. So you don't have to worry about having a subroutine with the same name as one of the many methods of File::Spec.

Should you bother using modules like these? It's up to you, as always. If you're sure your program will never be run anywhere but on a Unix machine, say, and you're sure you completely understand the rules for filenames on Unix,[*] then you may prefer to hardcode your assumptions into your programs. But these modules give you an easy way to make your programs more robust in less timeand more portable at no extra charge.

    [*] If you didn't know that filenames and directory names could contain newline characters, as we mentioned earlier in this section, then you don't know all the rules, do you?

			2.11.3.4 CGI.pm

If you need to create CGI programs (which we don't cover in this book), use the CGI.pm module.[dagger] Unless you really know what you are doing (and sometimes even then), you don't need to handle the actual interface and input parsing portion of the script, which gets so many other people into trouble. The CGI.pm author, Lincoln Stein, spent a lot of time ensuring that the module would work with most servers and operating systems. Just use the module and focus on the interesting parts of your script.

    [dagger] As with the CPAN.pm module, we pronounce the ".pm" in CGI.pm to distinguish it from the protocol itself.

The CGI module has two flavors: the plain old functional interface and the object-oriented interface. We'll use the first one. As before, you can follow the examples in the CGI.pm documentation. Our simple CGI script parses the CGI input and displays the input names and values as a plain-text document. In the import list, we use :all, which is an export tag that specifies a group of functions rather than a single function like you saw with the previous modules:[*]

    [*] The module has several other export tags to select different groups of functions. For instance, if you want the ones that deal with just the CGI, you can use :cgi, or if you just want the HTML generation functions, you can use :html4. See the CGI.pm documentation for more details.

#!/usr/bin/perl

use CGI qw(:all);

print header("text/plain");

foreach my $param ( param() )
    {
    print "$param: " . param($param) . "\n";
    }


We can get fancier though because we want to output HTML, and CGI.pm has many, many convenience functions to do that. It handles the CGI header, the beginning parts of HTML with start_html(), and many of the HTML tags with functions of the same name, like h1() for the H1 tag:

#!/usr/bin/perl

use CGI qw(:all);

print header(),
    start_html("This is the page title"),
    h1( "Input parameters" );

my $list_items;
foreach my $param ( param() )
    {
    $list_items .= li( "$param: " . param($param) );
    }

print ul( $list_items );

print end_html();


Wasn't that easy? You don't have to know how CGI.pm is doing all this stuff; you just have to trust that it does it correctly. Once you let CGI.pm do all the hard work, you get to focus on the interesting parts of your program.

The CGI.pm module does a lot more: it can handle cookies, redirection, multipage forms, and a lot more. We don't have room to cover it here, but you'll learn more from the examples in the module documentation.

			2.11.3.5 Databases and DBI

The DBI (Database Interface) module doesn't come with Perl, but it's one of the most popular modules since most people have to connect to a database of some sort. The beauty of DBI is that it allows you to use the same interface for just about any common database, from simple comma-separated value files to big database servers like Oracle. It has ODBC drivers, and some of its drivers are even vendor supported. To get the full details, get Programming the Perl DBI by Alligator Descartes and Tim Bunce (O'Reilly). You can also check out the DBI web site at http://dbi.perl.org/.

Once you install DBI, you also have to install a DBD (Database Driver). You can get a long list of DBDs from CPAN Search. Install the right one for your database server, and ensure that you get the version that goes with the version of your server.

The DBI is an object-oriented module, but you don't have to know everything about OO programming to use it. You just have to follow the examples in the documentation. To connect to a database, you use the DBI module, then call its connect method:

use DBI;

$dbh = DBI->connect($data_source, $username, $password);


The $data_source contains information particular to the DBD that you want to use, so you'll get that from the DBD. For PostgreSQL, the driver is DBD::Pg, and the $data_source is something like:

my $data_source = "dbi:Pg:dbname=name_of_database";


Once you connect to the database, you go through a cycle of preparing, executing, and reading queries.

$sth = $dbh->prepare("SELECT * FROM foo WHERE bla");
$sth->execute();
@row_ary  = $sth->fetchrow_array;
$sth->finish;


When you are finished, you disconnect from the database.

$dbh->disconnect();


There are all sorts of other things that the DBI can do too. See its documentation for more details.

		2.11.4 Exercise	
[15] Install the Module::CoreList module from CPAN. Print a list of all of the modules that came with Perl 5.008. To build a hash whose keys are the names of the modules that came with a given version of Perl, use this line:

my %modules = %{ $Module::CoreList::version{5.008} };

Install:
-> DL from CPAN
-> Then:
[yizaq@yytzhak-wxp:Tue Jan 20:/cygdrive/c/TEMP/Module-CoreList-2.17:]$ perl Makefile.PL 
Checking if your kit is complete...
Looks good
Writing Makefile for Module::CoreList
[yizaq@yytzhak-wxp:Tue Jan 20:/cygdrive/c/TEMP/Module-CoreList-2.17:]$ make install
cp lib/Module/CoreList.pm blib/lib/Module/CoreList.pm
cp corelist blib/script/corelist
/usr/bin/perl.exe "-MExtUtils::MY" -e "MY->fixin(shift)" blib/script/corelist
Installing /usr/lib/perl5/5.10/Module/CoreList.pm
Installing /usr/bin/corelist
Writing /usr/lib/perl5/5.10/i686-cygwin/auto/Module/CoreList/.packlist
Appending installation info to /usr/lib/perl5/5.10/i686-cygwin/perllocal.pod

-> Solution in print_modules.pl

	2.12 File Tests
Earlier, we showed how to open a filehandle for output. Normally, that will create a new file, wiping out any existing file with the same name. Perhaps you want to check that there isn't a file by that name. Perhaps you need to know how old a given file is. Or perhaps you want to go through a list of files to find which ones are larger than a certain number of bytes and not accessed for a certain amount of time. Perl has a complete set of tests you can use to find out information about files.	

		2.12.1 File Test Operators
Before we start a program that creates a new file, let's make sure that the file doesn't already exist so that we don't accidentally overwrite a vital spreadsheet datafile or that important birthday calendar. For this, we use the -e  file test, testing a filename for existence:

die "Oops! A file called '$filename' already exists.\n"
  if -e $filename;


Notice that we don't include $! in this die message, since we're not reporting that the system refused a request in this case. Here's an example of checking whether a file is being kept up-to-date. In this case, we're testing an already opened filehandle, instead of a string filename. Let's say that our program's configuration file should be updated every week or two. (Maybe it's checking for computer viruses, say.) If the file hasn't been modified in the past 28 days, then something is wrong:

warn "Config file is looking pretty old!\n"
  if -M CONFIG > 28;


The third example is more complex. Here, let's say that disk space is filling up and rather than buy more disks, we've decided to move any large, useless files to the backup tapes. So let's go through our list of files[277] to see which of them are larger than 100 KB. But even if a file is large, we shouldn't move it to the backup tapes unless it hasn't been accessed in the last 90 days (so we know that it's not used too often):[278]

    [277] It's more likely that, instead of having the list of files in an array, as our example shows, you'll read it directly from the filesystem using a glob or directory handle, as we'll show in Chapter 13. Since you haven't seen that yet, we'll just start with the list and go from there.

    [278] There's a way to make this example more efficient, as you'll see by the end of the chapter.

my @original_files = qw/ fred barney betty wilma pebbles dino bamm-bamm /;
my @big_old_files;  # The ones we want to put on backup tapes
foreach my $filename (@original_files) {
  push @big_old_files, $filename
    if -s $filename > 100_000 and -A $filename > 90;
}


This is the first time that you've seen it, so maybe you noticed that the control variable of the foreach loop is a my variable. That declares it to have the scope of the loop itself, so this example should work under use strict. Without the my keyword, this would be using the global $filename.

The file tests all look like a hyphen and a letter, which is the name of the test, followed by either a filename or a filehandle to test. Many of them return a true/false value, but several give something more interesting. See Table 12-1 for the complete list, and then read the following discussion to learn more about the special cases.

			2.12.1.1 Table 12-1. File tests and their meanings
File test	Meaning
-r	File or directory is readable by this (effective) user or group
-w	File or directory is writable by this (effective) user or group
-x	File or directory is executable by this (effective) user or group
-o	File or directory is owned by this (effective) user
-R	File or directory is readable by this real user or group
-W	File or directory is writable by this real user or group
-X	File or directory is executable by this real user or group
-O	File or directory is owned by this real user
-e	File or directory name exists
-z	File exists and has zero size (always false for directories)
-s	File or directory exists and has nonzero size (the value is the size in bytes)
-f	Entry is a plain file
-d	Entry is a directory
-l	Entry is a symbolic link
-S	Entry is a socket
-p	Entry is a named pipe (a "fifo")
-b	Entry is a block-special file (like a mountable disk)
-c	Entry is a character-special file (like an I/O device)
-u	File or directory is setuid
-g	File or directory is setgid
-k	File or directory has the sticky bit set
-t	The filehandle is a TTY (as reported by the isatty() system function; filenames can't be tested by this test)
-T	File looks like a "text" file
-B	File looks like a "binary" file
-M	Modification age (measured in days)
-A	Access age (measured in days)
-C	Inode-modification age (measured in days)

The tests -r, -w, -x, and -o tell whether the given attribute is true for the effective user or group ID,[*] which essentially refers to the person who is "in charge of" running the program.[dagger] These tests look at the "permission bits" on the file to see what is permitted. If your system uses Access Control Lists (ACLs), the tests will use those as well. These tests generally tell whether the system would try to permit something, but it doesn't mean that it really would be possible. For example, -w may be true for a file on a CD-ROM, even though you can't write to it, or -x may be true on an empty file, which can't truly be executed.

    [*] The -o and -O tests relate only to the user ID and not to the group ID.

    [dagger] Note for advanced students: the corresponding -R, -W, -X, and -O tests use the real user or group ID, which becomes important if your program may be running set-ID; in that case, it's generally the ID of the person who requested running it. See any good book about advanced Unix programming for a discussion of set-ID programs.

The -s test does return true if the file is nonempty, but it's a special kind of true. It's the length of the file, measured in bytes, which evaluates as true for a nonzero number.

On a Unix filesystem,[double dagger] there are just seven types of items, represented by the seven file tests: -f, -d, -l, -S, -p, -b, and -c. Any item should be one of those. But if you have a symbolic link pointing to a file, that will report true for both -f and -l. So, if you want to know whether something is a symbolic link, you should generally test that first. (You'll learn more about symbolic links in Chapter 13.)

    [double dagger] This is also the case on many non-Unix filesystems, but not all of the file tests are meaningful everywhere. For example, you aren't likely to have block-special files on your non-Unix system.

The age tests, -M, -A, and -C (yes, they're uppercase), return the number of days since the file was last modified, accessed, or had its inode changed.[*] (The inode contains all of the information about the file except for its contentssee the stat system call manpage or a good book on Unix internals for details.) This age value is a full floating-point number, so you might get a value of 2.00001 if a file were modified two days and one second ago. (These "days" aren't necessarily the same as a human would count; for example, if it's 1:30 in the morning when you check a file modified at about an hour before midnight, the value of -M for this file would be around 0.1, even though it was modified "yesterday.")

    [*] This information will be somewhat different on non-Unix systems, since not all keep track of the same times that Unix does. For example, on some systems, the ctime field (which the -C test looks at) is the file creation time (which Unix doesn't keep track of), rather than the inode change time; see the perlport manpage.

When checking the age of a file, you might even get a negative value like -1.2, which means that the file's last-access timestamp is set at about 30 hours in the future! The zero point on this timescale is the moment your program started running,[dagger] so that value might mean that a long-running program was looking at a file that had just been accessed. Or a timestamp could be set (accidentally or intentionally) to a time in the future.

    [dagger] As recorded in the $^T variable, which you could update (with a statement like $^T = time;) if you needed to get the ages relative to a different starting time.

The tests -T and -B take a try at telling whether a file is text or binary. But people who know a lot about filesystems know that there's no bit (at least in Unix-like operating systems) to indicate that a file is a binary or text fileso how can Perl tell? The answer is that Perl cheats: it opens the file, looks at the first few thousand bytes, and makes an educated guess. If it sees a lot of null bytes, unusual control characters, and bytes with the high bit set, then that looks like a binary file. If there's not much weird stuff then it looks like text. As you might guess, it sometimes guesses wrong. If a text file has a lot of Swedish or French words (which may have characters represented with the high bit set, as some ISO-8859-something variant, or perhaps even a Unicode version), it may fool Perl into declaring it binary. So it's not perfect, but if you just need to separate your source code from compiled files, or HTML files from PNGs, these tests should do the trick.

You'd think that -T and -B would always disagree, since a text file isn't a binary and vice versa, but there are two special cases where they're in complete agreement. If the file doesn't exist, or can't be read, both are false, since it's neither a text file nor a binary. Alternatively, if the file is empty, it's an empty text file and an empty binary file at the same time, so they're both true.

The -t file test returns true if the given filehandle is a TTYin short, if it's interactive because it's not a simple file or pipe. When -t STDIN returns true, it generally means that you can interactively ask the user questions. If it's false, your program is probably getting input from a file or pipe, rather than a keyboard.

Don't worry if you don't know what some of the other file tests meanif you've never heard of them, you won't be needing them. But if you're curious, get a good book about programming for Unix. (On non-Unix systems, these tests all try to give results analogous to what they do on Unix, or undef for an unavailable feature. Usually you'll be able to guess correctly what they'll do.)

If you omit the filename or filehandle parameter to a file test (that is, if you have just -r or just -s, say), the default operand is the file named in $_.[*] So, to test a list of filenames to see which ones are readable, you simply type:

    [*] The -t file test is an exception since that test isn't useful with filenames (they're never TTYs). By default it tests STDIN.

foreach (@lots_of_filenames) {
  print "$_ is readable\n" if -r;  # same as -r $_
}


But if you omit the parameter, be careful that whatever follows the file test doesn't look like it could be a parameter. For example, if you wanted to find out the size of a file in KB rather than in bytes, you might be tempted to divide the result of -s by 1000 (or 1024), like this:

# The filename is in $_
my $size_in_K = -s / 1000;  # Oops!


When the Perl parser sees the slash, it doesn't think about division; since it's looking for the optional operand for -s, it sees what looks like the start of a regular expression in forward slashes. One simple way to prevent this kind of confusion is to put parentheses around the file test:

my $size_in_k = (-s) / 1024;  # Uses $_ by default


Of course, it's always safe to explicitly give a file test a parameter.

			2.12.1.2 Testing Several Attributes of the Same File

			We can use more than one file test on the same file to create a complex logical condition. Suppose we want to operate on only files that are both readable and writable. We check each attribute and combine them with and:

			if( -r $file and -w $file ) {
				    ... }


This is an expensive operation, though. Each time you perform a file test, Perl asks the filesystem for all of the information about the file (Perl's actually doing a stat each time, which we talk about in the next section). Although we already got that information when we tested -r, Perl asks for the same information again so it can test -w. What a waste! This can be a significant performance problem if you're testing many attributes on many files.

Perl has a special shortcut to help us not do so much work. The virtual filehandle _ (just the underscore) uses the information from the last file lookup that a file test operator performed. Perl only has to look up the file information once now:

				    if( -r $file and -w _ ) {
					        ... }


We don't have to use the file tests next to each other to use _. Here we have them in separate if conditions:

						if( -r $file ) {
							    print "The file is readable!\n";
							        }

if( -w _ ) {
	    print "The file is writable!\n";
	        }


We have to watch out that we know what the last file lookup really was, though. If we do something else between the file tests, such as call a subroutine, the last file we looked up might be different. For instance, this example calls the lookup subroutine, which has a file test in it. When we return from that subroutine and do another file test, the _ filehandle isn't for $file like we expect, but for $other_file:

if( -r $file ) {
	    print "The file is readable!\n";
	        }

lookup( $other_file );

if( -w _ ) {
	    print "The file is writable!\n";
	        }

sub lookup {
	    return -w $_[0];
	        }


			2.12.1.3 Stacked File Test Operators

Previous to Perl 5.10, if we wanted to test several file attributes at the same time, we had to test them individually, even if using the _ filehandle to save ourselves some work. Suppose we wanted to test whether a file was readable and writable at the same time. We'd have to test whether it's readable and then also test whether it's writable:

if( -r $file and -w _ ) {
    print "The file is both readable and writable!\n";
    }


It's much easier to do this all at once. Perl 5.10 lets us "stack" our file test operators by lining them all up before the filename:

use 5.010;

if( -w -r $file ) {
    print "The file is both readable and writable!\n";
    }


This stacked example is the same as the previous example with just a change in syntax, although, it looks like the file tests are reversed, Perl does the file test nearest the filename first. Normally this isn't going to matter.

Stacked file tests are especially handy for complex situations. Suppose we want to list all of the directories that are readable, writable, executable, and owned by our user. We just need the right set of file tests:

use 5.010;

if( -r -w -x -o -d $file ) {
    print "My directory is readable, writable, and executable!\n";
    }


Stacked file tests aren't good for those that return values other than true or false that we would want to use in a comparison. We might think that this next bit of code first tests that it's a directory and then tests that it is less than 512 bytes, but it doesn't:

use 5.010;

if( -s -d $file < 512) { # WRONG! DON'T DO THIS
    print "The directory is less than 512 bytes!\n";
    }


Rewriting the stacked file tests as the previous notation shows us what is going on. The result of the combination of the file tests becomes the argument for the comparison:

if( ( -d $file and -s _ ) < 512 ) {
    print "The directory is less than 512 bytes!\n";
    }


When the -d returns false, Perl compares that false value to 512. That turns out to be true since false will be 0, which just happens to be less than 512. Instead of worrying about that sort of confusion, we just write it as separate file tests to be nice to the maintenance programmers who come after us:

if( -d $file and -s _ < 512 ) {
    print "The directory is less than 512 bytes!\n";
    }

		2.12.2 The stat and lstat Functions
The stat and lstat Functions

While these file tests are fine for testing various attributes regarding a particular file or filehandle, they don't tell the whole story. For example, there's no file test that returns the number of links to a file or the owner's user ID (uid). To get at the remaining information about a file, merely call the stat function, which returns pretty much everything that the stat Unix system call returns (hopefully more than you want to know).[*] The operand to stat is a filehandle (including the _ virtual filehandle), or an expression that evaluates to a filename. The return value is either the empty list, indicating that the stat failed (usually because the file doesn't exist), or a 13-element list of numbers, most easily described using the following list of scalar variables:

    [*] On a non-Unix system, both stat and lstat, as well as the file tests, should return "the closest thing available." For example, a system that doesn't have user IDs (that is, a system that has just one "user," in the Unix sense) might return zero for the user and group IDs, as if the one and only user is the system administrator. If stat or lstat fails, it will return an empty list. If the system call underlying a file test fails (or isn't available on the given system), that test will generally return undef. See the perlport manpage for the latest about what to expect on different systems.

my($dev, $ino, $mode, $nlink, $uid, $gid, $rdev,
  $size, $atime, $mtime, $ctime, $blksize, $blocks)
    = stat($filename);


The names here refer to the parts of the stat structure, described in detail in the stat(2) manpage. You should probably look there for the detailed descriptions. But in short, here's a quick summary of the important ones:


$dev and $ino

    The device number and inode number of the file. Together they make up a "license plate" for the file. Even if it has more than one name (hard link), the combination of device and inode numbers should always be unique.

$mode

    The set of permission bits for the file, and some other bits. If you've ever used the Unix command ls -l to get a detailed (long) file listing, you'll see that each line of output starts with something like -rwxr-xr-x. The nine letters and hyphens of file permissions[dagger] correspond to the nine least-significant bits of $mode, which would, in this case, give the octal number 0755. The other bits, beyond the lowest nine, indicate other details about the file. So, if you need to work with the mode, you'll generally want to use the bitwise operators covered later in this chapter.

        [dagger] The first character in that string isn't a permission bit; it indicates the type of entry: a hyphen for an ordinary file, d for directory, or l for symbolic link, among others. The ls command determines this from the other bits past the least-significant nine.


$nlink

    The number of (hard) links to the file or directory. This is the number of true names that the item has. This number is always 2 or more for directories and (usually) 1 for files. You'll see more about this when we talk about creating links to files in Chapter 13. In the listing from ls -l, this is the number just after the permission-bits string.

$uid and $gid

    The numeric user ID and group ID showing the file's ownership.

$size

    The size in bytes, as returned by the -s file test.

$atime, $mtime, and $ctime

    The three timestamps, but here they're represented in the system's timestamp format: a 32-bit number telling how many seconds have passed since the Epoch, an arbitrary starting point for measuring system time. On Unix systems and some others, the Epoch is the beginning of 1970 at midnight Universal Time, but the Epoch is different on some machines. There's more information later in this chapter on turning that timestamp number into something useful.

Invoking stat on the name of a symbolic link returns information on what the symbolic link points at, not information about the symbolic link itself (unless the link just happens to be pointing at nothing currently accessible). If you need the (mostly useless) information about the symbolic link itself, use lstat rather than stat (which returns the same information in the same order). If the operand isn't a symbolic link, lstat returns the same things that stat would.

Like the file tests, the operand of stat or lstat defaults to $_, meaning that the underlying stat system call will be performed on the file named by the scalar variable $_.

		2.12.3 The localtime Function
When you have a timestamp number (such as the ones from stat), it will typically look something like 1180630098. That's not very useful for most humans, unless you need to compare two timestamps by subtracting. You may need to convert it to something human-readable, such as a string like Thu May 31 09:48:18 2007. Perl can do that with the localtime function in a scalar context:

my $timestamp = 1180630098;
my $date = localtime $timestamp;


In a list context, localtime returns a list of numbers, several of which may not be quite what you'd expect:

my($sec, $min, $hour, $day, $mon, $year, $wday, $yday, $isdst)
  = localtime $timestamp;


The $mon is a month number, ranging from 0 to 11, which is handy as an index into an array of month names. The $year is the number of years since 1900, oddly enough, so add 1900 to get the real year number. The $wday ranges from 0 (for Sunday) through 6 (for Saturday), and the $yday is the day-of-the-year (ranging from 0 for January 1, through 364 or 365 for December 31).

There are two related functions that you'll also find useful. The gmtime function is just the same as localtime, except that it returns the time in Universal Time (what we once called Greenwich Mean Time). If you need the current timestamp number from the system clock, just use the time function. Both localtime and gmtime default to using the current time value if you don't supply a parameter:

my $now = gmtime;  # Get the current universal timestamp as a string


For more on manipulating dates and times, see the information in Appendix B about useful modules.

		2.12.4 Bitwise Operators
When you need to work with numbers bit by bit, as when working with the mode bits returned by stat, you'll need to use the bitwise operators. These are the operators that perform binary math operations on values. The bitwise operators perform binary math operations on values. The bitwise-and operator (&) reports which bits are set in the left argument and in the right argument. For example, the expression 10 & 12 has the value 8. The bitwise-and needs to have a 1-bit in both operands to produce a one-bit in the result. That means that the logical-and operation on 10 (which is 1010 in binary) and 12 (which is 1100) gives 8 (which is 1000, with a 1-bit only where the left operand has a 1-bit and the right operand also has a 1-bit). See Figure 12-1.



Examples of the bit operators are shown inTable 12-2.

Table 12-2. Bitwise operators
Expression	Meaning
10 & 12 	Bitwise-andwhich bits are true in both operands (this gives 8)
10 | 12 	Bitwise-orwhich bits are true in one operand or the other (this gives 14)
10 ^ 12 	Bitwise-xorwhich bits are true in one operand or the other but not both (this gives 6)
6 << 2 	Bitwise shift leftshift the left operand the number of bits shown by the right operand, adding zero-bits at the least-significant places (this gives 24)
25 >> 2 	Bitwise shift rightshift the left operand the number of bits shown by the right operand, discarding the least-significant bits (this gives 6)
~ 10 	Bitwise negation, also called unary bit complementreturn the number with the opposite bit for each bit in the operand (this gives 0xFFFFFFF5, but see the text)

So, here's an example of some things you could do with the $mode returned by stat. The results of these bit manipulations could be useful with chmod (which you'll see in Chapter 13):
Code View: Scroll / Show All

# $mode is the mode value returned from a stat of CONFIG
warn "Hey, the configuration file is world-writable!\n"
  if $mode & 0002;                                # configuration security problem
my $classical_mode = 0777 & $mode;                # mask off extra high-bits
my $u_plus_x = $classical_mode | 0100;            # turn one bit on
my $go_minus_r = $classical_mode & (~ 0044);      # turn two bits off

					  
			2.12.4.1 Using Bitstrings

All of the bitwise operators can work with bitstrings, as well as with integers. If the operands are integers, the result will be an integer. (The integer will be at least a 32-bit integer, but may be larger if your machine supports that. That is, if you have a 64-bit machine, ~10 may give the 64-bit result 0xFFFFFFFFFFFFFFF5, rather than the 32-bit result 0xFFFFFFF5.)

But if any operand of a bitwise operator is a string, Perl will perform the operation on that bitstring. That is, "\xAA" | "\x55" will give the string "\xFF". Note that these values are single-byte strings; the result is a byte with all eight bits set. Bitstrings may be arbitrarily long.

This is one of the very few places where Perl distinguishes between strings and numbers. See the perlop manpage for more information on using bitwise operators on strings.

		2.12.5 Exercises
# [15] Make a program that takes a list of files named on the command line and reports for each one whether it's readable, writable, executable, or doesn't exist. (Hint: it may be helpful to have a function that will do all of the file tests for one file at a time.) What does it report about a file that has been chmod'ed to 0? (That is, if you're on a Unix system, use the command chmod 0 some_file to mark that file as not being readable, writable, nor executable.) In most shells, use a star as the argument to mean all of the normal files in the current directory. That is, you could type something like ./ex12-2 * to ask the program for the attributes of many files at once.

[yizaq@yytzhak-wxp:Sun Feb 01:/cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic:]$ ./file_info.pl  *

# [10] Make a program to identify the oldest file named on the command line and report its age in days. What does it do if the list is empty (that is, if no files are mentioned on the command line)?
[yizaq@yytzhak-wxp:Tue Feb 03:/cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic:]$ ./find_oldest_file.pl *.pl
Oldest file is add_copyrights.pl, age 22.0152662037037 

# [10] Make a program that uses stacked file test operators to list all files named on the command line that are owned by you, readable, and writable.
[yizaq@yytzhak-wxp:Tue Feb 03:/cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic:]$ ./list_myRW_files.pl *
	2.13 Directory Operations

	The files we created in the previous chapter were generally in the same place as our program. But modern operating systems let us organize files into directories, allowing us to keep our Beatles MP3s away from our important Llama book chapter sources so that we don't accidentally send an MP3 file to the publisher. Perl lets you manipulate these directories directly, in ways that are even fairly portable from one operating system to another.

		2.13.1  Moving Around the Directory Tree
Your program runs with a "working directory," which is the starting point for relative pathnames. That is, if you refer to the file fred, that means fred in the current working directory.

The chdir operator changes the working directory. It's just like the Unix shell's cd command:

chdir "/etc" or die "cannot chdir to /etc: $!";


Because this is a system request, the value of $! will be set if an error occurs. You should normally check $! when a false value is returned from chdir, since that indicates that something has not gone as requested.

The working directory is inherited by all processes that Perl starts (we'll talk more about that in Chapter 16). However, the change in working directory cannot affect the process that invoked Perl, such as the shell.[287] So you can't make a Perl program to replace your shell's cd command.

    [287] This isn't a limitation on Perl's part; it's actually a feature of Unix, Windows, and other systems. If you really need to change the shell's working directory, see the documentation of your shell.

If you omit the parameter, Perl determines your home directory as best as it can and attempts to set the working directory to your home directory, similar to using the cd command at the shell without a parameter. This is one of the few places where omitting the parameter doesn't use $_.

Some shells permit you to use a tilde-prefixed path with cd to use another user's home directory as a starting point (like cd ~merlyn). This is a function of the shell, not the operating system, and Perl is calling the operating system directly. Thus, a tilde prefix will not work with chdir.

		2.13.2  Globbing
Normally, the shell expands any filename patterns on each command line into the matching filenames. This is called globbing. For example, if you give a filename pattern of *.pm to the echo command, the shell expands this list to a list of names that match:

$ echo *.pm
barney.pm dino.pm fred.pm wilma.pm
$


The echo command doesn't have to know anything about expanding *.pm because the shell has already expanded it. This works even for your Perl programs:

$ cat >show-args
foreach $arg (@ARGV) {
  print "one arg is $arg\n";
}
^D
$ perl show-args *.pm
one arg is barney.pm
one arg is dino.pm
one arg is fred.pm
one arg is wilma.pm
$


Note that show-args didn't need to know anything about globbingthe names were already expanded in @ARGV.

But sometimes we end up with a pattern like *.pm inside our Perl program. Can we expand this pattern into the matching filenames without working very hard? Surejust use the glob operator:

my @all_files = glob "*";
my @pm_files = glob "*.pm";


Here, @all_files gets all the files in the current directory, alphabetically sorted, and not including the files beginning with a period, just like the shell. And @pm_files gets the same list that we got before by using *.pm on the command line.

In fact, anything you can say on the command line, you can also put as the (single) argument to glob, including multiple patterns separated by spaces:

my @all_files_including_dot = glob ".* *";


Here, we've included an additional "dot star" parameter to get the filenames that begin with a dot as well as the ones that don't. Please note that the space between these two items inside the quoted string is significant, as it separates two different items you want to glob.[*] The reason this works exactly as the shell works is that prior to Perl version 5.6, the glob operator simply called /bin/csh[dagger] behind the scenes to perform the expansion. Because of this, globs were time-consuming and could break in large directories, or in some other cases. Conscientious Perl hackers avoided globbing in favor of directory handles, which we will discuss later in this chapter. However, if you're using a modern version of Perl, you should no longer be concerned about such things.

    [*] Windows users may be accustomed to using a glob of *.* to mean "all files." But that actually means "all files with a dot in their names," even in Perl on Windows.

    [dagger] Or it will call a valid substitute if a C shell wasn't available.

		2.13.3  An Alternate Syntax for Globbing
Although we use the term globbing freely, and we talk about the glob operator, you might not see the word glob in very many of the programs that use globbing. Why not? Well, most legacy code was written before the glob operator was given a name. Instead, it was called up by the angle-bracket syntax, similar to reading from a filehandle:

my @all_files = <*>; ## exactly the same as my @all_files = glob "*";


The value between the angle brackets is interpolated similarly to a double-quoted string, which means that Perl variables are expanded to their current Perl values before being globbed:

my $dir = "/etc";
my @dir_files = <$dir/* $dir/.*>;


Here, we've fetched all the nondot and dot files from the designated directory because $dir has been expanded to its current value.

So, if using angle brackets means both filehandle reading and globbing, how does Perl decide which of the two operators to use? Well, a filehandle has to be a Perl identifier. So, if the item between the angle brackets is strictly a Perl identifier, it's a filehandle read; otherwise, it's a globbing operation. For example:

my @files = <FRED/*>;  ## a glob
my @lines = <FRED>;    ## a filehandle read
my $name = "FRED";
my @files = <$name/*>; ## a glob


The one exception is if the contents are a simple scalar variable (not an element of a hash or array); then it's an indirect filehandle read,[double dagger] where the variable contents give the name of the filehandle you want to read:

    [double dagger] If the indirect handle is a text string, then it's subject to the "symbolic reference" test that is forbidden under use strict. However, the indirect handle might also be a typeglob or reference to an I/O object, and then it would work even under use strict.

my $name = "FRED";
my @lines = <$name>; ## an indirect filehandle read of FRED handle


Determining whether it's a glob or a filehandle read is done at compile time, and thus it is independent of the content of the variables.

If you want, you can get the operation of an indirect filehandle read using the readline operator,[*] which also makes it clearer:

    [*] If you're using Perl 5.005 or later.

my $name = "FRED";
my @lines = readline FRED;  ## read from FRED
my @lines = readline $name; ## read from FRED


But the readline operator is rarely used, as indirect filehandle reads are uncommon and are generally performed against a simple scalar variable anyway.

		2.13.4  Directory Handles
Another way to get a list of names from a given directory is with a directory handle. A directory handle looks and acts like a filehandle. You open it (with opendir instead of open), you read from it (with readdir instead of readline), and you close it (with closedir instead of close). But instead of reading the contents of a file, you're reading the names of files (and other things) in a directory. For example:

my $dir_to_process = "/etc";
opendir DH, $dir_to_process or die "Cannot open $dir_to_process: $!";
foreach $file (readdir DH) {
  print "one file in $dir_to_process is $file\n";
}
closedir DH;


Like filehandles, directory handles are automatically closed at the end of the program or if the directory handle is reopened onto another directory.

Unlike globbing, which in older versions of Perl fired off a separate process, a directory handle never fires off another process. So it makes them more efficient for applications that demand every ounce of power from the machine. However, it's also a lower-level operation, meaning that we have to do more of the work ourselves.

For example, the names are returned in no particular order.[dagger] And the list includes all files, not just those matching a particular pattern (like *.pm from our globbing examples). It is also includes the dot files, and particularly the dot and dot-dot entries.[double dagger] So, if we wanted only the pm-ending files, we could use a skip-over function inside the loop:

    [dagger] It's actually the unsorted order of the directory entries, similar to the order you get from ls -f or find.

    [double dagger] Do not make the mistake of many old Unix programs and presume that dot and dot-dot are always returned as the first two entries (sorted or not). If that hadn't even occurred to you, pretend we never said it because it's a false presumption. In fact, we're now sorry for even bringing it up.

while ($name = readdir DIR) {
  next unless $name =~ /\.pm$/;
  ... more processing ...
}


Note here that the syntax is that of a regular expression, not a glob. And if we wanted all the nondot files, we could say that:

next if $name =~ /^\./;


Or if we wanted everything but the common dot (current directory) and dot-dot (parent directory) entries, we could explicitly say that:

next if $name eq "." or $name eq "..";


Now we'll look at the part that gets most people mixed up, so pay close attention. The filenames returned by the readdir operator have no pathname component. It's just the name within the directory. So, we're not looking at /etc/passwd, we're just looking at passwd. (And because this is another difference from the globbing operation, it's easy to see how people get confused.)

So you'll need to patch up the name to get the full name:

opendir SOMEDIR, $dirname or die "Cannot open $dirname: $!";
while (my $name = readdir SOMEDIR) {
  next if $name =~ /^\./; # skip over dot files
  $name = "$dirname/$name"; # patch up the path
  next unless -f $name and -r $name; # only readable files
  ...
}


Without the patch, the file tests would have been checking files in the current directory, rather than in the directory named in $dirname. This is the single most common mistake when using directory handles.

		2.13.5  Recursive Directory Listing
You probably won't need recursive directory access for the first few dozen hours of your Perl programming career. So rather than distract you with the possibility of replacing all those ugly find scripts with Perl right now, we'll simply entice you by saying that Perl comes with a nice library called File::Find, which you can use for nifty recursive directory processing. We're also saying this to keep you from writing your own routineswhich everyone seems to want to do after those first few dozen hours of programmingand then getting puzzled about things like "local directory handles" and "how do I change my directory back?"

		2.13.6  Manipulating Files and Directories
Perl is commonly used to wrangle files and directories. Because Perl grew up in a Unix environment and still spends most of its time there, most of the description in this chapter may seem Unix-centric. But the nice thing is that to whatever degree possible, Perl works exactly the same way on non-Unix systems.

		2.13.7  Removing Files
Most of the time, we make files so that the data can stay around for a while. But when the data has outlived its life, it's time to make the file go away. At the Unix shell level, we'd type an rm command to remove a file or files:

$ rm slate bedrock lava


In Perl, we use the unlink operator:

unlink "slate", "bedrock", "lava";


This sends the three named files away to bit heaven, never to be seen again.

Now, since unlink takes a list, and the glob function returns a list, we can combine the two to delete many files at once:

unlink glob "*.o";


This is similar to rm *.o at the shell, except that we didn't have to fire off a separate rm process. So we can make those important files go away that much faster!

The return value from unlink tells us how many files have been successfully deleted. So, going back to the first example, we can check its success:

my $successful = unlink "slate", "bedrock", "lava";
print "I deleted $successful file(s) just now\n";


Sure, if this number is 3, we know it removed all of the files, and if it's 0, then we removed none of them. But what if it's 1 or 2? Well, there's no clue as to which ones were removed. If you need to know, do them one at a time in a loop:

foreach my $file (qw(slate bedrock lava)) {
  unlink $file or warn "failed on $file: $!\n";
}


Here, each file being deleted one at a time means the return value will be 0 (failed) or 1 (succeeded), which happens to look like a nice Boolean value, controlling the execution of warn. Using or warn is similar to or die, except that it's not fatal, of course (as we said back in Chapter 5). In this case, we put the newline on the end of the message to warn because it's not a bug in our program that causes the message.

When a particular unlink fails, the $! variable is set to something related to the operating system error, which we've included in the message. This makes sense to use only when doing one filename at a time because the next operating system failed request resets the variable. You can't remove a directory with unlink (just like you can't remove a directory with the simple rm invocation either). Look for the rmdir function coming up shortly for that.

Now, here's a little-known Unix fact. It turns out that you can have a file that you can't read, you can't write, you can't execute, maybe you don't even own the filethat is, it's somebody else's file altogetherbut you can still delete it. That's because the permission to unlink a file doesn't depend upon the permission bits on the file itself; it's the permission bits on the directory that contains the file that matters.

We mention this because it's normal for a beginning Perl programmer, in the course of trying out unlink, to make a file, to chmod it to 0 (so that it's not readable or writable), and then to see whether this makes unlink fail. But instead it vanishes without so much as a whimper.[*] If you really want to see a failed unlink, though, just try to remove /etc/passwd or a similar system file. Since that's a file controlled by the system administrator, you won't be able to remove it.[dagger]

    [*] Some of these folks know that rm would generally ask before deleting such a file. But rm is a command, and unlink is a system call. System calls never ask permission, and they never say they're sorry.

    [dagger] Of course, if you're silly enough to try this kind of thing when you are logged in as the system administrator, you deserve what you get.

		2.13.8  Renaming Files
Giving an existing file a new name is simple with the rename  function:

rename "old", "new";


This is similar to the Unix mv command, taking a file named old and giving it the name new in the same directory. You can even move things around:

rename "over_there/some/place/some_file", "some_file";


This moves a file called some_file from another directory into the current directory, provided the user running the program has the appropriate permissions.[double dagger] Like most functions that request something of the operating system, rename returns false if it fails, and sets $! with the operating system error, so you can (and often should) use or die (or or warn) to report this to the user.

    [double dagger] And the files must reside on the same filesystem. You'll see why this rule exists a little later in this chapter.

One frequent[||] question in the Unix shell-usage newsgroups concerns how to rename everything that ends with .old to the same name with .new. Here's how to do it in Perl nicely:

    [||] This isn't just any old frequent question; the question of renaming a batch of files at once is the most frequent question asked in these newsgroups. And that's why it's the first question answered in the FAQs for those newsgroups. And yet, it stays in first place. Hmmm.

foreach my $file (glob "*.old") {
  my $newfile = $file;
  $newfile =~ s/\.old$/.new/;
  if (-e $newfile) {
    warn "can't rename $file to $newfile: $newfile exists\n";
  } elsif (rename $file, $newfile) {
    ## success, do nothing
  } else {
    warn "rename $file to $newfile failed: $!\n";
  }
}


The check for the existence of $newfile is needed because rename will happily rename a file right over the top of an existing file, presuming the user has permission to remove the destination filename. We put the check in so that it's less likely that we'll lose information this way. Of course, if you wanted to replace existing files like wilma.new, you wouldn't bother testing with -e first.

Those first two lines inside the loop can be combined (and often are) to simply:

(my $newfile = $file) =~ s/\.old$/.new/;


This works to declare $newfile, copy its initial value from $file, then modify $newfile with the substitution. You can read this as "transform $file to $newfile using this replacement on the right." And yes, because of precedence, those parentheses are required.

Also, some programmers seeing this substitution for the first time wonder why the backslash is needed on the left, but not on the right. The two sides aren't symmetrical: the left part of a substitution is a regular expression, and the right part is a double-quoted string. So we use the pattern /\.old$/ to mean ".old anchored at the end of the string" (anchored at the end because we don't want to rename the first occurrence of .old in a file called betty.old.old), but on the right we can simply write .new to make the replacement.

		2.13.9  Links and Files
To understand more about what's going on with files and directories, it helps to understand the Unix model of files and directories, even if your non-Unix system doesn't work in exactly this way. As usual, there's more to the story than we're able to explain here, so check any good book on Unix internal details if you need the full story.

A mounted volume is a hard disk drive (or something else that works more or less like that, such as a disk partition, a floppy disk, a CD-ROM, or a DVD-ROM). It may contain any number of files and directories. Each file is stored in a numbered inode, which we can think of as a particular piece of disk real estate. One file might be stored in inode 613, while another is in inode 7033.

To locate a particular file, though, we'll have to look it up in a directory. A directory is a special kind of file, maintained by the system. Essentially, it is a table of filenames and their inode numbers.[*] Along with the other things in the directory, there are always two special directory entries. One is . (called "dot"), which is the name of that very directory; the other is .. ("dot-dot"), which is the directory one step higher in the hierarchy (i.e., the directory's parent directory).[dagger] 

    [*] On Unix systems (others don't generally have inodes, hard links, and such), you can use the ls command's -i option to see files' inode numbers. Try a command like ls -ail. When two or more inode numbers are the same for multiple items on a given filesystem, there's really just one file involved, one piece of the disk.

    [dagger] The Unix system root directory has no parent. In that directory, .. is the same directory as ., which is the system root directory itself.


When it's time to make a new file in a given directory, the system adds an entry with the file's name and the number of a new inode. How can the system tell that a particular inode is available though? Each inode holds a number called its link count. The link count is always zero if the inode isn't listed in any directory, so any inode with a link count of zero is available for new file storage. When the inode is added to a directory, the link count is incremented; when the listing is removed, the link count is decremented. For the file chicken as illustrated above, the inode count of 1 is shown in the box above the inode's data.

But some inodes have more than one listing. For example, we've already seen that each directory entry includes ., which points back to that directory's own inode. So the link count for a directory should always be at least two: its listing in its parent directory and its listing in itself. In addition, if it has subdirectories, each of those will add a link, since each will contain ...[*] In Figure 13-1, the directory's inode count of 2 is shown in the box above its data. A link count is the number of true names for the inode.[dagger] Could an ordinary file inode have more than one listing in the directory? It certainly could. Suppose that, working in the directory shown above, Barney uses the Perl link function to create a new link:

    [*] This implies that the link count of a directory is always equal to two plus the number of directories it contains. On some systems that's true, in fact, but some other systems work differently.

    [dagger] In the traditional output of ls -l, the number of hard links to the item appears just to the right of the permission flags (like -rwxr-xr-x). Now you know why this number is more than one for directories and nearly always 1 for ordinary files.

link "chicken", "egg"
  or warn "can't link chicken to egg: $!";


This is similar to typing "ln chicken egg" at the Unix shell prompt. If link succeeds, it returns true. If it fails, it returns false and sets $!, which Barney is checking in the error message. After this runs, the name egg is another name for the file chicken, and vice versa; neither name is "more real" than the other, and (as you may have guessed) it would take some detective work to find out which came first. 



These two filenames are thus talking about the same place on the disk. If the file chicken holds 200 bytes of data, egg holds the same 200 bytes, for a total of 200 bytes (since it's really just one file with two names). If Barney appends a new line of text to file egg, that line will also appear at the end of chicken.[double dagger] Now, if Barney were to accidentally (or intentionally) delete chicken, that data will not be lostit's still available under the name egg. And vice versa: if he were to delete egg, he'd still have chicken. Of course, if he deletes both of them, the data will be lost.[*] There's another rule about the links in directory listings: the inode numbers in a given directory listing all refer to inodes on that same mounted volume.[dagger] This rule ensures that if the physical medium (the diskette, perhaps) is moved to another machine, all of the directories stick together with their files. That's why you can use rename to move a file from one directory to another, but only if both directories are on the same filesystem (mounted volume). If they were on different disks, the system would have to relocate the inode's data, which is too complex an operation for a simple system call.

    [double dagger] If you experiment with making links and changing text files, be aware that most text editors don't edit the file "in place" but instead save a modified copy. If Barney were to edit egg with a text editor, he'd most likely end up with a new file called egg and the old file called chickentwo separate files, rather than two links to the same file.

    [*] Although the system won't necessarily overwrite this inode right away, there's no easy way in general to get the data back once the link count has gone to zero. Have you made a backup recently?

    [dagger] The one exception is the special .. entry in the volume's root directory, which refers to the directory in which that volume is mounted.

And yet another restriction on links is that they can't make new names for directories. That's because the directories are arranged in a hierarchy. If you were able to change that, utility programs like find and pwd could easily become lost trying to find their way around the filesystem.

So, links can't be added to directories, and they can't cross from one mounted volume to another. Fortunately, there's a way to get around these restrictions on links, by using a new and different kind of link: a symbolic link.[double dagger] A symbolic link (also called a soft link to distinguish it from the true or hard links that we've been talking about up to now) is a special entry in a directory that tells the system to look elsewhere. Let's say that Barney (working in the same directory of poems as before) creates a symbolic link with Perl's symlink function, like this:

    [double dagger] Some very old Unix systems don't support symlinks, but those are pretty rare nowadays.

symlink "dodgson", "carroll"
  or warn "can't symlink dodgson to carroll: $!";


This is similar to what would happen if Barney used the command ln -s dodgson carroll from the shell. 


Now if Barney chooses to read /home/barney/poems/carroll, he gets the same data as if he had opened /home/barney/poems/dodgson because the system follows the symbolic link automatically. But that new name isn't the "real" name of the file because (as you can see in the diagram) the link count on inode 7033 is still just one. That's because the symbolic link simply tells the system, "If you got here looking for carroll, now you want to go off to find something called dodgson instead."

A symbolic link can freely cross mounted filesystems or provide a new name for a directory, unlike a hard link. In fact, a symbolic link could point to any filename, one in this directory or in another oneor even to a file that doesn't exist! But that also means that a soft link can't keep data from being lost as a hard link can, since the symlink doesn't contribute to the link count. If Barney were to delete dodgson, the system would no longer be able to follow the soft link.[*] Even though there would still be an entry called carroll, trying to read from it would give an error like file not found. The file test -l 'carroll' would report true, but -e 'carroll' would be false: it's a symlink, but it doesn't exist.

    [*] Deleting carroll would merely remove the symlink, of course.

Since a soft link could point to a file that doesn't yet exist, it could be used when creating a file as well. Barney has most of his files in his home directory, /home/barney, but he also needs frequent access to a directory with a long name that is difficult to type: /usr/local/opt/system/httpd/root-dev/users/staging/barney/cgi-bin. So he sets up a symlink named /home/barney/my_stuff, which points to that long name, and now it's easy for him to get to it. If he creates a file (from his home directory) called my_stuff/bowling, that file's real name is /usr/local/opt/system/httpd/root-dev/users/staging/barney/cgi-bin/bowling. Next week, when the system administrator moves these files of Barney's to /usr/local/opt/internal/httpd/www-dev/users/staging/barney/cgi-bin, Barney just repoints the one symlink, and now he and all of his programs can still find his files with ease.

It's normal for either /usr/bin/perl or /usr/local/bin/perl (or both) to be symbolic links to the true Perl binary on your system. This makes it easy to switch to a new version of Perl. Say you're the system administrator, and you've built the new Perl. Of course, your older version is still running, and you don't want to disrupt anything. When you're ready for the switch, you simply move a symlink or two, and now every program that begins with #!/usr/bin/perl will automatically use the new version. In the unlikely case that there's some problem, it's a simple thing to replace the old symlinks and have the older Perl running the show again. (But, like any good admin, you notified your users to test their code with the new /usr/bin/perl-7.2 well in advance of the switch, and you told them that they can keep using the older one during the next month's grace period by changing their programs' first lines to #!/usr/bin/perl-6.1, if they need to.)

Perhaps surprisingly, both hard and soft links are very useful. Many non-Unix operating systems have neither, and the lack is sorely felt. On some non-Unix systems, symbolic links may be implemented as a "shortcut" or an "alias"check the perlport manpage for the latest details.

To find out where a symbolic link is pointing, use the readlink function. This will tell you where the symlink leads, or it will return undef if its argument wasn't a symlink:

my $where = readlink "carroll";             # Gives "dodgson"

my $perl = readlink "/usr/local/bin/perl";  # Maybe tells where perl is


You can remove either kind of link with unlink and now you see where that operation gets its name. unlink simply removes the directory entry associated with the given filename, decrementing the link count and thus possibly freeing the inode.
		2.13.10 Making and Removing Directories
Making a directory inside an existing directory is easy. Just invoke the mkdir function:

mkdir "fred", 0755 or warn "Cannot make fred directory: $!";


Again, true means success, and $! is set on failure.

But what's that second parameter, 0755? That's the initial permission setting[*] on the newly created directory (you can always change it later). The value here is specified as an octal value because the value will be interpreted as a Unix permission value, which has a meaning based on groups of three bits each, and octal values represent that nicely. Yes, even on Windows or MacPerl, you still need to know a little about Unix permissions values to use the mkdir function. Mode 0755 is a good one to use because it gives you full permission, but lets everyone else have read access but no permission to change anything.

    [*] The permission value is modified by the umask value in the usual way. See umask(2) for further information.

The mkdir function doesn't require you to specify this value in octalit's just looking for a numeric value (either a literal or a calculation). But unless you can quickly can figure that 0755 octal is 493 decimal in your head, it's probably easier to let Perl calculate that. And if you accidentally leave off the leading zero, you get 755 decimal, which is 1363 octal, a strange permission combination indeed.

As you saw earlier (in Chapter 2), a string value being used as a number is never interpreted as octal, even if it starts with a leading 0. So this doesn't work:

my $name = "fred";
my $permissions = "0755";  # danger... this isn't working
mkdir $name, $permissions;


Oops, we just created a directory with that bizarre 01363 permissions because 0755 was treated as decimal. To fix that, use the oct function, which forces octal interpretation of a string whether or not there's a leading zero:

mkdir $name, oct($permissions);


Of course, if you are specifying the permission value directly within the program, just use a number instead of a string. The need for the extra oct function shows up most often when the value comes from user input. For example, suppose we take the arguments from the command line:

my ($name, $perm) = @ARGV;  # first two args are name, permissions
mkdir $name, oct($perm) or die "cannot create $name: $!";


The value here for $perm is interpreted as a string initially, and thus the oct function interprets the common octal representation properly.

To remove empty directories, use the rmdir function in a manner similar to the unlink function, although it can only remove one directory per call:

foreach my $dir (qw(fred barney betty)) {
  rmdir $dir or warn "cannot rmdir $dir: $!\n";
}


The rmdir operator fails for nonempty directories. As a first pass, you can attempt to delete the contents of the directory with unlink, then try to remove what should now be an empty directory. For example, suppose we need a place to write many temporary files during the execution of a program:

my $temp_dir = "/tmp/scratch_$$";       # based on process ID; see the text
mkdir $temp_dir, 0700 or die "cannot create $temp_dir: $!";
...
# use $temp_dir as location of all temporary files
...
unlink glob "$temp_dir/* $temp_dir/.*"; # delete contents of $temp_dir
rmdir $temp_dir;                        # delete now-empty directory


The initial temporary directory name includes the current process ID, which is unique for every running process and is accessed with the $$ variable (similar to the shell). We do this to avoid colliding with any other processes, as long as they also include their process ID as part of their pathname as well. (In fact, it's common to use the program's name as well as the process ID, so if the program is called quarry, the directory would probably be something like /tmp/quarry_$$.)

At the end of the program, that last unlink should remove all the files in this temporary directory, and then the rmdir function can delete the then-empty directory. However, if we've created subdirectories under that directory, the unlink operator fails on those, and the rmdir also fails. For a more robust solution, check out the rmtree function provided by the File::Path module of the standard distribution.

		2.13.11 Modifying Permissions
The Unix chmod command changes the permissions on a file or directory. Similarly, Perl has the chmod function to perform this task:

chmod 0755, "fred", "barney";


As with many of the operating system interface functions, chmod returns the number of items successfully altered, and when used with a single argument, sets $! in a sensible way for error messages when it fails. The first parameter is the Unix permission value (even for non-Unix versions of Perl). For the same reasons we presented earlier when describing mkdir, this value is usually specified in octal.

Symbolic permissions (like +x or go=u-w) accepted by the Unix chmod command are not valid for the chmod function.[*]

    [*] Unless you've installed and invoked the File::chmod module from CPAN, which can apparently upgrade the chmod operator to understand symbolic mode values.

		2.13.12 Changing Ownership
If the operating system permits it, you may change the ownership and group membership of a list of files (or filehandles) with the chown function. The user and group are both changed at once, and both have to be the numeric user-ID and group-ID values. For example:

my $user = 1004;
my $group = 100;
chown $user, $group, glob "*.o";


What if you have a username like merlyn instead of the number? Simple. Just call the getpwnam function to translate the name into a number, and the corresponding getgrnam[dagger] to translate the group name into its number:

    [dagger] These two are among the ugliest function names known to mankind. But don't blame Larry for them; he's just giving them the same names that the folks at Berkeley did.

defined(my $user = getpwnam "merlyn") or die "bad user";
defined(my $group = getgrnam "users") or die "bad group";
chown $user, $group, glob "/home/merlyn/*";


The defined function verifies that the return value is not undef, which will be returned if the requested user or group is not valid.

The chown function returns the number of files affected, and it sets $! on error.

		2.13.13 Changing Timestamps
In those rare  cases when you want to lie to other programs about when a file was most recently modified or accessed, you can use the utime function to fudge the books a bit. The first two arguments give the new access time and modification time, while the remaining arguments are the list of filenames to alter to those timestamps. The times are specified in internal timestamp format (the same type of values returned from the stat function that we mentioned in Chapter 12).

One convenient value to use for the timestamps is "right now," returned in the proper format by the time function. So to update all the files in the current directory to look like they were modified a day ago, but accessed just now, we could simply do this:

my $now = time;
my $ago = $now - 24 * 60 * 60;  # seconds per day
utime $now, $ago, glob "*";     # set access to now, mod to a day ago


Of course, nothing stops you from creating a file that is arbitrarily stamped far in the future or past (within the limits of the Unix timestamp values of 1970 to 2038, or whatever your non-Unix system uses, unless you have 64-bit timestamps). Maybe you could use this to create a directory where you keep your notes for that time travel novel you're writing.

The third timestamp (the ctime value) is always set to "now" whenever anything alters a file, so there's no way to set it (it would have to be reset to "now" after you set it) with the utime function. That's because its primary purpose is for incremental backups: if the file's ctime is newer than the date on the backup tape, it's time to back it up again.

		2.13.14 Exercises	
The programs here are potentially dangerous! Be careful to test them in a mostly empty directory to make it difficult to accidentally delete something useful.

See Appendix A for answers to the following exercises:

   |1.  [12] Write a program to ask the user for a directory name, then change to that directory. If the user enters a line with nothing but whitespace, change to his or her home directory as a default. After changing, list the ordinary directory contents (not the items whose names begin with a dot) in alphabetical order. (Hint: will that be easier to do with a directory handle or with a glob?) If the directory change doesn't succeed, just alert the userbut don't try to show the contents.

[yizaq@yytzhak-wxp:Wed Feb 04:/cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic:]$ ./chdir.pl

   |2.  [4] Modify the program to include all files, not just the ones that don't begin with a dot.
   chdir.pl
   |3.  [5] If you used a directory handle for the previous exercise, rewrite it to use a glob. Or if you used a glob, try it now with a directory handle.
   chdir.pl
   |4.  [6] Write a program that works like rm, deleting any files named on the command line. (You don't need to handle any of the options of rm.)
   rm.pl
   |5.  [10] Write a program that works like mv, renaming the first command-line argument to the second command-line argument. (You don't need to handle any of the options of mv or additional arguments.) Remember to allow for the destination to be a directory; if it is, use the same original basename in the new directory.
   mv.pl
   |6.  [7] If your operating system supports it, write a program that works like ln, making a hard link from the first command-line argument to the second. (You don't need to handle options of ln or more arguments.) If your system doesn't have hard links, just print out a message telling what operation you would perform if it were available. (Hint: this program has something in common with the previous onerecognizing that could save you time in coding.)
   ln.pl
   |7.  [7] If your operating system supports it, fix up the program from the previous exercise to allow an optional -s switch before the other arguments to indicate that you want to make a soft link instead of a hard link. (Even if you don't have hard links, see whether you can at least make soft links with this program.)
   ln.pl
   |8.  [7] If your operating system supports it, write a program to find any symbolic links in the current directory and print out their values (like ls -l would: name -> value).
   find_sym_link.pl

	2.14 Strings and Sorting

	As  we mentioned near the beginning of this book, Perl is designed to be good at solving programming problems that are about 90% working with text and 10% everything else. So it's no surprise that Perl has strong text-processing abilities, including all that we've done with regular expressions. But sometimes the regular expression engine is too fancy, and you'll need a simpler way of working with a string, as you'll see in this chapter.	
		2.14.1 Finding a Substring with index

Finding a substring depends on where you have lost it. If you happen to have lost it within a bigger string, you're in luck because the index function can help you out. Here's how it looks:

$where = index($big, $small);


Perl locates the first occurrence of the small string within the big string, returning an integer location of the first character. The character position returned is a zero-based value--if the substring is found at the very beginning of the string, index returns 0. If it's one character later, the return value is 1, and so on. If the substring can't be found at all, the return value is -1 to indicate that.[310] In this example, $where gets 6:

    [310] Former C programmers will recognize this as being like C's index function. Current C programmers ought to recognize it as wellbut by this point in the book, you should really be a former C programmer.

my $stuff = "Howdy world!";
my $where = index($stuff, "wor");


Another way you could think of the position number is the number of characters to skip over before getting to the substring. Since $where is 6, we know that we have to skip over the first six characters of $stuff before we find wor.

The index function will always report the location of the first found occurrence of the substring. But you can tell it to start searching at a later point than the start of the string by using the optional third parameter, which tells index to start at that position:

my $stuff  = "Howdy world!";
my $where1 = index($stuff, "w");               # $where1 gets 2
my $where2 = index($stuff, "w", $where1 + 1);  # $where2 gets 6
my $where3 = index($stuff, "w", $where2 + 1);  # $where3 gets -1 (not found)

					  


(Of course, you wouldn't normally search repeatedly for a substring without using a loop.) That third parameter is effectively giving a minimum value for the return value; if the substring can't be found at that position or later, the return value will be -1.

Once in a while, you might prefer to have the last found occurrence of the substring.[*] You can get that with the rindex function. In this example, we can find the last slash, which turns out to be at position 4 in a string:

    [*] Well, it's not really the last one found--Perl cleverly starts searching from the other end of the string, and then returns the first location it finds, which amounts to the same result. Of course, the return value is the same zero-based number as we always use for describing locations of substrings.

my $last_slash = rindex("/etc/passwd", "/");  # value is 4


The rindex function also has an optional third parameter, but, in this case, it effectively gives the maximum permitted return value:

my $fred = "Yabba dabba doo!";
my $where1 = rindex($fred, "abba");  # $where1 gets 7
my $where2 = rindex($fred, "abba", $where1 - 1);  # $where2 gets 1
my $where3 = rindex($fred, "abba", $where2 - 1);  # $where3 gets -1

		2.14.2 Manipulating a Substring with substr
The substr operator works with only a part of a larger string. It looks like this:

$part = substr($string, $initial_position, $length);


It takes three arguments: a string value, a zero-based initial position (like the return value of index), and a length for the substring. The return value is the substring:

my $mineral = substr("Fred J. Flintstone", 8, 5);  # gets "Flint"
my $rock = substr "Fred J. Flintstone", 13, 1000;  # gets "stone"


As you may have noticed in the previous example, if the requested length (1000 characters, in this case) would go past the end of the string, there's no complaint from Perl, but you simply get a shorter string than you might have. But if you want to be sure to go to the end of the string, however long or short it may be, just omit that third parameter (the length), like this:

my $pebble = substr "Fred J. Flintstone", 13;  # gets "stone"


The initial position of the substring in the larger string can be negative, counting from the end of the string (that is, position -1 is the last character).[*] In this example, position -3 is three characters from the end of the string, which is the location of the letter i:

    [*] This is analogous to what you saw with array indices in Chapter 3. Just as arrays may be indexed either from 0 (the first element) upward or from -1 (the last element) downward, substring locations may be indexed from position 0 (at the first character) upward or from position -1 (at the last character) downward.

my $out = substr("some very long string", -3, 2);  # $out gets "in"


As you might expect, index and substr work well together. In this example, we can extract a substring that starts at the location of the letter l:

my $long = "some very very long string";
my $right = substr($long, index($long, "l") );


Now here's something really cool: The selected portion of the string can be changed if the string is a variable:[dagger]

    [dagger] Well, technically, it can be any lvalue. What that term means precisely is beyond the scope of this book, but you can think of it as anything that can be put on the left side of the equals sign (=) in a scalar assignment. That's usually a variable, but it can (as you see here) even be an invocation of the substr operator.

my $string = "Hello, world!";
substr($string, 0, 5) = "Goodbye";  # $string is now "Goodbye, world!"


As you see, the assigned (sub)string doesn't have to be the same length as the substring it's replacing. The string's length is adjusted to fit. Or if that wasn't cool enough to impress you, you could use the binding operator (=~) to restrict an operation to work with just part of a string. This example replaces fred with barney wherever possible within just the last 20 characters of a string:

substr($string, -20) =~ s/fred/barney/g;


To be completely honest, we've never actually needed that functionality in any of our own code, and chances are that you'll never need it either. But it's nice to know that Perl can do more than you'll ever need, isn't it?

Much of the work that substr and index do could be done with regular expressions. Use those where they're appropriate. But substr and index can often be faster, since they don't have the overhead of the regular expression engine: they're never case-insensitive, they have no metacharacters to worry about, and they don't set any of the memory variables.

Besides assigning to the substr function (which looks a little weird at first glance, perhaps), you can also use substr in a slightly more traditional manner[double dagger] with the four-argument version, in which the fourth argument is the replacement substring:

    [double dagger] By traditional we mean in the "function invocation" sense, but not the "Perl" sense, since this feature was introduced to Perl relatively recently.

my $previous_value = substr($string, 0, 5, "Goodbye");


The previous value comes back as the return value, although, as always, you can use this function in a void context to simply discard it.

		2.14.3 Formatting Data with sprintf

The sprintf function takes the same arguments as printf (except for the optional filehandle, of course), but it returns the requested string instead of printing it. This is handy if you want to store a formatted string into a variable for later use, or if you want more control over the result than printf alone would provide:

my $date_tag = sprintf
  "%4d/%02d/%02d %2d:%02d:%02d",
  $yr, $mo, $da, $h, $m, $s;


In that example, $date_tag gets something like "2038/01/19 3:00:08". The format string (the first argument to sprintf) used a leading zero on some of the format number, which we didn't mention when we talked about printf formats in Chapter 5. The leading zero on the format number means to use leading zeros as needed to make the number as wide as requested. Without a leading zero in the formats, the resulting date-and-time string would have unwanted leading spaces instead of zeros, like "2038/ 1/19 3: 0: 8".

			2.14.3.1 Using sprintf with "Money Numbers"

One popular use for sprintf is when you want to format a number with a certain number of places after the decimal point, such as when you want to show an amount of money as 2.50 and not 2.5--and certainly not as 2.49997! That's easy to accomplish with the "%.2f" format:

my $money = sprintf "%.2f", 2.49997;


The full implications of rounding are numerous and subtle, but, in most cases, you should keep numbers in memory with all of the available accuracy, rounding off only for output.

If you have a "money number" that may be large enough to need commas to show its size, you might find it handy to use a subroutine like this one:[*]

    [*] Yes, we know that not everywhere in the world are commas used to separate groups of digits, not everywhere are the digits grouped by threes, and not everywhere does the currency symbol appears as it does for U.S. dollars. But this is a good example anyway, so there!

 sub big_money {
  my $number = sprintf "%.2f", shift @_;
  # Add one comma each time through the do-nothing loop
  1 while $number =~ s/^(-?\d+)(\d\d\d)/$1,$2/;
  # Put the dollar sign in the right place
  $number =~ s/^(-?)/$1\$/;
  $number;
}


This subroutine uses some techniques you haven't seen yet, but they logically follow from what we've shown you. The first line of the subroutine formats the first (and only) parameter to have exactly two digits after the decimal point. That is, if the parameter were the number 12345678.9, now our $number is the string "12345678.90".

The next line of code uses a while modifier. As we mentioned when we covered that modifier in Chapter 10, that can always be rewritten as a traditional while loop:

while ($number =~ s/^(-?\d+)(\d\d\d)/$1,$2/) {
  1;
}


What does that say to do? It says that as long as the substitution returns a true value (signifying success), the loop body should run. But the loop body does nothing! That's okay with Perl, but it tells us that the purpose of that statement is to do the conditional expression (the substitution), rather than the useless loop body. The value 1 is traditionally used as this kind of a placeholder, although any other value would be equally useful.[*] This works just as well as the loop above:

    [*] Which is to say, useless. By the way, in case you're wondering, Perl optimizes away the constant expression, so it doesn't even take up any runtime.

'keep looping' while $number =~ s/^(-?\d+)(\d\d\d)/$1,$2/;


So, now we know that the substitution is the real purpose of the loop. But what is the substitution doing? Remember that $number will be some string like "12345678.90" at this point. The pattern will match the first part of the string, but it can't get past the decimal point. (Do you see why it can't?) Memory $1 will get "12345", and $2 will get "678", so the substitution will make $number into "12345,678.90" (remember, it couldn't match the decimal point, so the last part of the string is left untouched).

Do you see what the dash is doing near the start of that pattern? (Hint: the dash is allowed at only one place in the string.) We'll tell you at the end of this section, in case you haven't figured it out.

We're not done with that substitution statement yet. Since the substitution succeeded, the do-nothing loop goes back to try again. This time, the pattern can't match anything from the comma onward, so $number becomes "12,345,678.90". The substitution thus adds a comma to the number each time through the loop.

Speaking of the loop, it's still not done. Since the previous substitution was a success, we're back around the loop to try again. But this time, the pattern can't match at all, since it has to match at least four digits at the start of the string, so now that is the end of the loop.

Why couldn't we have simply used the /g modifier to do a "global" search-and-replace, to save the trouble and confusion of the 1 while? We couldn't use that because we're working backward from the decimal point, rather than forward from the start of the string. Putting the commas in a number like this can't be done simply with the s///g substitution alone.[*] So, did you figure out the dash? It's allowing for a possible minus sign at the start of the string. The next line of code makes the same allowance, putting the dollar sign in the right place so that $number is something like "$12,345,678.90", or perhaps "-$12,345,678.90" if it's negative. Note that the dollar sign isn't necessarily the first character in the string, or that line would be a lot simpler. Finally, the last line of code returns our nicely formatted "money number," which you can print in the annual report.

    [*] At least, it can't be done without some more advanced regular expression techniques than we've shown you so far. Those darn Perl developers keep making it harder and harder to write Perl books that use the word "can't."

		2.14.4 Advanced Sorting

Earlier, in Chapter 3, we showed that you could sort a list in ascending ASCIIbetical order by using the built-in sort operator. What if you want a numeric sort? Or a case-insensitive sort? Or maybe you want to sort items according to information stored in a hash. Well, Perl lets you sort a list in whatever order you'd need; you'll see all of those examples by the end of the chapter.

You'll tell Perl what order you want by making a sort-definition subroutine, or sort subroutine for short. Now, when you first hear the term "sort subroutine," if you've been through any computer science courses, visions of bubble sort and shell sort and quick sort race through your head, and you say, "No, never again!" Don't worry; it's not that bad. In fact, it's pretty simple. Perl already knows how to sort a list of items; it merely doesn't know which order you want. So, the sort-definition subroutine simply tells it the order.

Why is this necessary? Well, if you think about it, sorting is putting a bunch of things in order by comparing them all. Since you can't compare them all at once, you need to compare two at a time, eventually using what you find out about each pair's order to put the whole kit and caboodle in line. Perl already understands all of those steps except for the part about how you'd like to compare the items, so that's all you have to write.

This means that the sort subroutine doesn't need to sort many items after all. It merely has to be able to compare two items. If it can put two items in the proper order, Perl will be able to tell (by repeatedly consulting the sort subroutine) what order you want for your data.

The sort subroutine is defined like an ordinary subroutine (well, almost). This routine will be called repeatedly, each time checking on a pair of elements from the list you're sorting.

Now, if you were writing a subroutine that's expecting to get two parameters that need sorting, you might write something like this to start:

sub any_sort_sub {  # It doesn't really work this way
  my($a, $b) = @_;  # Get and name the two parameters
  # start comparing $a and $b here
  ...
}


But the sort subroutine will be called again and again, often hundreds or thousands of times. Declaring the variables $a and $b and assigning them values at the top of the subroutine will take just a little time, but multiply that by the thousands of times that the routine will be called, and you can see that it contributes significantly to the overall execution speed.

We don't do it like that. (In fact, if you did it that way, it wouldn't work.) Instead, it is as if Perl has done this for us, before our subroutine's code has even started. You'll really write a sort subroutine without that first line; both $a and $b have been assigned for you. When the sort subroutine starts running, $a and $b are two elements from the original list.

The subroutine returns a coded value describing how the elements compare (like C's qsort(3) does, but it's Perl's own internal sort implementation). If $a should appear before $b in the final list, the sort subroutine returns -1 to say so. If $b should appear before $a, it returns 1.

If the order of $a and $b doesn't matter, the subroutine returns 0. Why would it not matter? Perhaps you're doing a case-insensitive sort and the two strings are fred and Fred. Or perhaps you're doing a numeric sort and the two numbers are equal.

You could now write a numeric sort subroutine like this:

sub by_number {
  # a sort subroutine, expect $a and $b
  if ($a < $b) { -1 } elsif ($a > $b) { 1 } else { 0 }
}


To use the sort subroutine, just put its name (without an ampersand) between the keyword sort and the list you're sorting. This example puts a numerically sorted list of numbers into @result:

my @result = sort by_number @some_numbers;


We called the subroutine by_number because that describes how it's sorting. But more importantly, you can read the line of code that uses it with sort as saying "sort by number," as you would in English. Many sort-subroutine names begin with by_ to describe how they sort. Or we could have called this one numerically, for a similar reason, but that's more typing and more chance to mess up something.

Notice that we don't have to do anything in the sort subroutine to declare $a and $b, and to set their values--and if we did, the subroutine wouldn't work right. We just let Perl set up $a and $b for us, and so all we need to write is the comparison.

In fact, we can make it even simpler (and more efficient). Since this kind of three-way comparison is frequent, Perl has a convenient shortcut to use to write it. In this case, we use the spaceship operator (<=>).[*] This operator compares two numbers and returns -1, 0, or 1 as needed to sort them numerically. So we could have written that sort subroutine better, like this:

    [*] We call it that because it looks like one of the TIE fighters from Star Wars. Well, it looks like that to us, anyway.

sub by_number { $a <=> $b }


Since the spaceship compares numbers, you may have guessed that there's a corresponding three-way string-comparison operator: cmp. These two are easy to remember and keep straight. The spaceship has a family resemblance to the numeric comparison operators like >=, but it's three characters long instead of two because it has three possible return values instead of two. And cmp has a family resemblance to the string comparison operators like ge, but it's three characters long instead of two because it also has three possible return values instead of two.[dagger] Of course, cmp by itself provides the same order as the default sort. You'd never need to write this subroutine, which yields merely the default sort order:[double dagger]

    [dagger] This is no accident. Larry does things like this on purpose, to make Perl easier to learn and remember. Remember, he's a linguist at heart, so he's studied how people think of languages.

    [double dagger] You'd never need to write this unless, of course, you were writing an introductory Perl book and needed it for an example.

sub ASCIIbetically { $a cmp $b }

my @strings = sort ASCIIbetically @any_strings;


But you can use cmp to build a more complex sort order, like a case-insensitive sort:

sub case_insensitive { "\L$a" cmp "\L$b" }


In this case, we're comparing the string from $a (forced to lowercase) against the string from $b (forced to lowercase), giving a case-insensitive sort order.

Note that we're not modifying the elements themselves; we're merely using their values. That's actually important: for efficiency reasons, $a and $b aren't copies of the data items. They're actually new, temporary aliases for elements of the original list, so if we changed them, we'd be mangling the original data. Don't do thatit's neither supported nor recommended.

When your sort subroutine is as simple as the ones we show here (and most of the time, it is), you can make the code even simpler yet, by replacing the name of the sort routine with the entire sort routine "inline," like so:

my @numbers = sort { $a <=> $b } @some_numbers;


In fact, in modern Perl, you'll hardly ever see a separate sort subroutine; you'll frequently find sort routines written inline as we've done here.

Suppose you want to sort in descending numeric order. That's easy enough to do with the help of reverse:

my @descending = reverse sort { $a <=> $b } @some_numbers;


But here's a neat trick. The comparison operators (<=> and cmp) are very nearsighted; that is, they can't see which operand is $a and which is $b, but only which value is on the left and which is on the right. So if $a and $b were to swap places, the comparison operator would get the results backward every time. That means that this is another way to get a reversed numeric sort:

my @descending = sort { $b <=> $a } @some_numbers;


You can (with a little practice) read this at a glance. It's a descending-order comparison (because $b comes before $a, which is descending order), and it's a numeric comparison (because it uses the spaceship instead of cmp). So, it's sorting numbers in reverse order. (In modern Perl versions, it doesn't matter much which one of those you do because reverse is recognized as a modifier to sort, and special shortcuts are taken to avoid sorting it one way just to have to turn it around the other way.)

			2.14.4.1 Sorting a Hash by Value

Once you've been sorting lists happily for a while you'll run into a situation where you want to sort a hash by value. For example, three of our characters went out bowling last night, and we've got their bowling scores in the following hash. We want to be able to print out the list in the proper order, with the game winner at the top, so we want to sort the hash by score:

my %score = ("barney" => 195, "fred" => 205, "dino" => 30);
my @winners = sort by_score keys %score;


Of course, you aren't really going to be able to sort the hash by score; that's just a verbal shortcut. You can't sort a hash! But when we've used sort with hashes before now, we've been sorting the keys of the hash (in ASCIIbetical order). Now, you're still going to sort the keys of the hash, but the order is defined by their corresponding values from the hash. In this case, the result should be a list of our three characters' names, in order according to their bowling scores.

Writing this sort subroutine is fairly easy. What we want is to use a numeric comparison on the scores, rather than the names. That is, instead of comparing $a and $b (the players' names), we want to compare $score{$a} and $score{$b} (their scores). If you think of it that way, it almost writes itself, as in:

sub by_score { $score{$b} <=> $score{$a} }


Let's step through this and see how it works. Let's imagine that the first time it's called, Perl has set $a to barney and $b to fred. So the comparison is $score{"fred"} <=> $score{"barney"}, which (as we can see by consulting the hash) is 205 <=> 195. Remember, now, the spaceship is nearsighted, so when it sees 205 before 195, it says, in effect: "No, that's not the right numeric order; $b should come before $a." So it tells Perl that fred should come before barney.

Maybe the next time the routine is called, $a is barney again but $b is now dino. The nearsighted numeric comparison sees 30 <=> 195 this time, so it reports that that they're in the right order; $a does indeed sort in front of $b. That is, barney comes before dino. At this point, Perl has enough information to put the list in order: fred is the winner, then barney in second place, then dino.

Why did the comparison use the $score{$b} before the $score{$a}, instead of the other way around? That's because we wanted bowling scores arranged in descending order, from the highest score down. So you can (again, after a little practice) read this one at sight as well: $score{$b} <=> $score{$a} means to sort according to the scores, in reversed numeric order.

			2.14.4.2 Sorting by Multiple Keys

We forgot to mention that there was a fourth player bowling last night with the other three, so the hash really looked like this:

my %score = (
  "barney" => 195, "fred" => 205,
  "dino" => 30, "bamm-bamm" => 195,
);


Now, as you can see, bamm-bamm has the same score as barney. So which one will be first in the sorted list of players? There's no telling because the comparison operator (seeing the same score on both sides) will have to return zero when checking those two.

Maybe that doesn't matter, but we generally prefer to have a well defined sort. If several players have the same score, we want them to be together in the list, of course. But within that group, the names should be in ASCIIbetical order. But how can we write the sort subroutine to say that? Again, this turns out to be pretty easy:

my @winners = sort by_score_and_name keys %score;

sub by_score_and_name {
  $score{$b} <=> $score{$a}  # by descending numeric score
    or
  $a cmp $b                  # ASCIIbetically by name
}


How does this work? Well, if the spaceship sees two different scores, that's the comparison we want to use. It returns -1 or 1, a true value, so the low-precedence short-circuit or will mean that the rest of the expression will be skipped, and the comparison we want is returned. (Remember, the short-circuit or returns the last expression evaluated.) But if the spaceship sees two identical scores, it returns 0, a false value, and thus the cmp operator gets its turn at bat, returning an appropriate ordering value considering the keys as strings. That is, if the scores are the same, the string-order comparison breaks the tie.

We know that when we use the by_score_and_name sort subroutine like this, it will never return 0. (Do you see why it won't? The answer is in the footnote.[*]) So we know that the sort order is always well defined; that is, we know that the result today will be identical to the result with the same data tomorrow.

    [*] The only way it could return 0 would be if the two strings were identical, and (since the strings are keys of a hash) we already know that they're different. Of course, if you passed a list with duplicate (identical) strings to sort, it would return 0 when comparing those, but we're passing a list of hash keys.

There's no reason that your sort subroutine has to be limited to two levels of sorting, of course. Here the Bedrock library program puts a list of patron ID numbers in order according to a five-level sort.[dagger] This example sorts according to the amount of each patron's outstanding fines (as calculated by a subroutine &fines, not shown here), the number of items they currently have checked out (from %items), their name (in order by family names, then by personal name, both from hashes), and finally by the patron's ID number, in case everything else is the same:

    [dagger] It's not unusual in the modern world to need a five-level sort like this, although it was quite infrequent in prehistoric times.

@patron_IDs = sort {
  &fines($b) <=> &fines($a) or
  $items{$b} <=> $items{$a} or
  $family_name{$a} cmp $family_name{$a} or
  $personal_name{$a} cmp $family_name{$b} or
  $a <=> $b
} @patron_IDs;

		2.14.5 Exercises
# [10] Write a program to read in a list of numbers and sort them numerically, printing out the resulting list in a right-justified column. Try it out on this sample data or use the file numbers from the O'Reilly web site (see the Preface):

17 1000 04 1.50 3.14159 -10 1.5 4 2001 90210 666

# [15] Make a program that will print the following hash's data sorted in case-insensitive alphabetical order by last name. When the last names are the same, sort those by first name (again, without regard for case). That is, the first name in the output should be Fred's, while the last one should be Betty's. All of the people with the same family name should be grouped together. Don't alter the data. The names should be printed with the same capitalization as shown here. (You can find the source code to create a hash like this in the file sortable_hash with the other downloaded files.)

my %last_name = qw{
  fred flintstone Wilma Flintstone Barney Rubble
  betty rubble Bamm-Bamm Rubble PEBBLES FLINTSTONE
};


# [15] Make a program that looks through a given string for every occurrence of a given substring, printing out the positions where the substring is found. For example, given the input string "This is a test." and the substring "is", it should report positions 2 and 5. If the substring were "a", it should report 8. What does it report if the substring is "t"?

My answers at: /cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic
simple_number_sorter.pl
hash_sorter.pl


	2.15 Smart Matching and given-when
	
	Wouldn't it be great if computers could just figure out what you wanted and do it? Perl already does its best to use numbers when you want numbers, strings when you want strings, single values where you mean a single value, and lists when you mean lists. With Perl 5.10's smart match operator and given-when control structure, it gets even better.

The smart match operator, ~~, looks at both of its operands and decides on its own how it should compare them. If the operands look like numbers, it does a numeric comparison. If they look like strings, it does a string comparison. If one of the operands is a regular expression, it does a pattern match. It can also do some complex tasks that would otherwise take a lot of code, so it keeps you from doing too much typing.

The ~~ looks almost like the binding operator, =~, which you saw in Chapter 8, but ~~ can do much more. It can even stand in for the binding operator. Up to now, you'd match a pattern by using the binding operator to associate $name with the regular expression operator:

print "I found Fred in the name!\n" if $name =~ /Fred/;


Now, you can change that binding operator to the smart match operator and do exactly the same thing:

use 5.010;

say "I found Fred in the name!" if $name ~~ /Fred/;


The smart match operator sees that it has a scalar on the lefthand side and the regular expression operator on the righthand side, and figures out on its own to do the pattern match. That's not impressive, though. It gets much, much better.

The smart match operator starts to show its power with more complex operations. Suppose you wanted to print a message if one of the keys in the hash %names matches Fred. You can't use exists because it only checks for the exact key. You could do it with a foreach that tests each key with the regular expression operator, skipping those that don't match. When you find one that does match, you can change the value of $flag and skip the rest of the iterations with last:

my $flag = 0;
foreach my $key ( keys %names ) {
    next unless $key =~ /Fred/;
    $flag = $key;
    last;
    }

print "I found a key matching 'Fred'. It was $flag\n" if $flag;


Whew! That was a lot of work just to explain it, but it works in any version of Perl 5. With the smart match operator, you just need the hash on the lefthand side and the regular expression operator on the righthand side:

use 5.010;

say "I found a key matching 'Fred'" if %names ~~ /Fred/;


The smart match operator knows what to do because it sees a hash and a regular expression. With those two operands, the smart match operator knows to look through the keys in %names and apply the regular expression to each one. If it finds one that matches, it already knows to stop and return true. It's not the same sort of match as the scalar and regular expression. It's smart; it does what's right for the situation. It's just that the operator is the same, even though the operation isn't.

If you want to compare two arrays (limiting them to the same size just to make things simpler), you could go through the indices of one of the arrays and compare the corresponding elements in each of the arrays. Each time the corresponding elements are the same, you increment the $equal counter. After the loop, if $equal is the same as the number of elements in @names1, then the arrays must be the same:

my $equal = 0;
foreach my $index ( 0 .. $#names1 ) {
    last unless $names1[$index] eq $names2[$index];
    $equal++;
    }

print "The arrays have the same elements!\n"
    if $equal == @names1;


Again, that's too much work. Wouldn't it be great if there was an easy way to do that? Wait! How about the smart match operator? Just put the arrays on either side of the ~~. This little bit of code does the same things as the last example, but with almost no code:

use 5.010;

say "The arrays have the same elements!"
    if @names1 ~~ @names2;


Okay, one more example. Suppose you call a function and want to check that its return value is one of a set of possible or expected values. Going back to the max() subroutine in Chapter 4, you know that max() should return one of the values you passed it. You could check that by comparing the return value of max to its argument list using the same techniques as the previous hard ways:

my @nums   = qw( 1 2 3 27 42 );
my $result = max( @nums );

my $flag = 0;
foreach my $num ( @nums ) {
    next unless $result == $num;
    $flag = 1;
    last;
    }

print "The result is one of the input values\n" if $flag;


You already know what we are going to say: that's too much work! You can get rid of all of the code in the middle by using ~~. This is much easier than the previous example:

use 5.010;

my @nums   = qw( 1 2 3 27 42 );
my $result = max( @nums );

say "The result [$result] is one of the input values (@nums)"
    if @nums ~~ $result;


You can also write that smart match with the operands in the other order and get the same answer. The smart match operator doesn't care which operands are on which side:

use 5.010;

my @nums   = qw( 1 2 3 27 42 );
my $result = max( @nums );

say "The result [$result] is one of the input values (@nums)"
    if $result ~~ @nums;


The smart match operator is commutative, which you may remember from high school algebra as the fancy way to say that the order of the operands doesn't matter. The smart match operator is just like addition or multiplication; you get the same answer both ways. It doesn't matter what sort of matching it's doing either. These two are the same:

use 5.010;

say "I found a name matching 'Fred'" if $name ~~ /Fred/;
say "I found a name matching 'Fred'" if /Fred/ ~~ $name;

		2.15.2. Smart Match Precedence
Now that you've seen how the smart match operator can save you a lot of work, you just need to know how to tell which sort of match it will do. For that you have to check the table in the perlsyn documentation under "Smart matching in detail." Table 15-1  shows some of the things the smart match operator can do.

Table 15-1. Smart match operations for pairs of operands
Example	Type of match
%a ~~ %b 	Hash keys identical
%a ~~ @b 	At least one key in %a is in @b
%a ~~ /Fred/ 	At least one key matches pattern
%a ~~ 'Fred' 	Hash key existence exists $a{Fred}
 	 
@a ~~ @b 	Arrays are the same
@a ~~ /Fred/ 	At least one element matches pattern
@a ~~ 123 	At least one element is 123, numerically
@a ~~ 'Fred' 	At least one element is 'Fred', stringwise
 	 
$name ~~ undef 	$name is not defined
$name ~~ /Fred/ 	Pattern match
123 ~~ '123.0' 	Numeric equality with "numish" string
'Fred' ~~ 'Fred' 	String equality
123 ~~ 456 	Numeric equality

When you use the smart match operator, Perl goes to the top of the chart and starts looking for a type of match that corresponds to its two operands. It then does the first type of match it finds. The order of the operands doesn't matter. For instance, you have an array and a hash with the smart match:

use 5.010;

if( @array ~~ %hash ) { ... }


Perl first finds the match type for a hash and an array, which checks that at least one of the elements of @array is a key in %hash. That one is easy because there is only one type of match for those two operands. What if you have two scalars?

use 5.010;

if( $fred ~~ $barney ) { ... }


So far you can't tell what sort of match it is going to do because Perl needs to look inside $scalar1 and $scalar2 to see what would happen. Perl can't decide that until it sees the actual data inside the scalars. Is the smart match going to do a numeric or string comparison?

To figure out how Perl will compare $fred and $barney, Perl looks at the values and follows the same rules we just told you. It goes down the precedence chart until it finds a situation that matches, then uses the right comparison for that situation. There's a bit of a trick: Perl can recognize some strings as numbers, which it calls numish strings. Those are strings such as '123', '3.14149', and so on. We've quoted each one, so they are really strings, which are just sequences of characters. However, Perl can convert them to numbers without warnings. If Perl sees numbers or numish strings on both sides of the smart match operator, it does a numeric comparison. Otherwise, it does a string comparison.

		2.15.3 The given Statement

he given-when control structure allows you to run a block of code when the argument to given satisfies a condition. It's Perl's equivalent to C's switch statement, but as with most things Perly, it's a bit more fancy, so it gets a fancier name.

Here's a bit of code that takes the first argument from the command line, $ARGV[0], and goes through the when conditions to see if it can find Fred. Each when block reports a different way that it found Fred, starting with the least restrictive to the most:

use 5.010;

given( $ARGV[0] ) {
    when( /fred/i ) { say 'Name has fred in it' }
    when( /^Fred/ ) { say 'Name starts with Fred' }
    when( 'Fred'  ) { say 'Name is Fred' }
    default         { say "I don't see a Fred" }
    }


The given aliases its argument to $_,[323] and each of the when conditions tries an implicit smart match against $_. You could rewrite the previous example with explicit smart matching to see exactly what's happening:

    [323] In Perl parlance, given is a topicalizer because it makes its argument the topic, the fancy new name for $_ in Perl 6.

use 5.010;

given( $ARGV[0] ) {
    when( $_ ~~ /fred/i ) { say 'Name has fred in it' }
    when( $_ ~~ /^Fred/ ) { say 'Name starts with Fred' }
    when( $_ ~~ 'Fred'  ) { say 'Name is Fred' }
    default               { say "I don't see a Fred" }
    }


If $_ does not satisfy any of the when conditions, Perl executes the default block. Here's the output from several trial runs:

$ perl5.10.0 switch.pl Fred
Name has fred in it
$ perl5.10.0 switch.pl Frederick
Name has fred in it
$ perl5.10.0 switch.pl Barney
I don't see a Fred
$ perl5.10.0 switch.pl Alfred
Name has fred in it


"Big deal," you say, "I could write this example with if-elsif-else." The next example does just that using a $_ declared with my and with all the scoping rules of my, another new feature of Perl 5.10:

use 5.010;

{
my $_ = $ARGV[0]; # lexical $_ as of 5.10!

   if( $_ ~~ /fred/i ) { say 'Name has fred in it' }
elsif( $_ ~~ /^Fred/ ) { say 'Name starts with Fred' }
elsif( $_ ~~ 'Fred'  ) { say 'Name is Fred' }
else                   { say "I don't see a Fred" }
}


If given were just the same thing as if-elsif-else, it wouldn't be that interesting. Unlike an if-elsif-else construct, however, a given-when can satisfy one condition and then try the others too. Once an if-elsif-else satisfies a condition, it will only ever execute one block of code.

Before we go on, let's make a couple more things explicit so that you can see everything that's happening. Unless you say otherwise, there is an implicit break at the end of each when block, and that tells Perl to stop the given-when construct and move on with the rest of the program. The previous example really has breaks in it, although you don't have to type them yourself:

use 5.010;

given( $ARGV[0] ) {
    when( $_ ~~ /fred/i ) { say 'Name has fred in it'; break }
    when( $_ ~~ /^Fred/ ) { say 'Name starts with Fred'; break }
    when( $_ ~~ 'Fred'  ) { say 'Name is Fred'; break }
    default               { say "I don't see a Fred"; break }
    }


This doesn't work very well for the problem, though. Since our example goes from general to specific, if the argument matches /fred/i, Perl doesn't test any of the when conditions. We don't get to check whether the argument is exactly Fred because the first when block stops the entire control structure.

If you use continue at the end of a when instead, Perl tries the succeeding when statements too, repeating the process it started before. That's something that if-elsif-else can't do. When another when satisfies its condition, Perl executes its block (again, implicitly breaking at the end of the block unless you say otherwise). Putting a continue at the end of each when block means Perl will try every condition:

use 5.010;

given( $ARGV[0] ) {
    when( $_ ~~ /fred/i ) { say 'Name has fred in it'; continue }
    when( $_ ~~ /^Fred/ ) { say 'Name starts with Fred'; continue }
    when( $_ ~~ 'Fred'  ) { say 'Name is Fred'; continue } # OOPS!
    default               { say "I don't see a Fred" }
    }


There's a slight problem with that code, though. When we run it, we see that the default block runs too:

$ perl5.10.0 switch.pl Alfred
Name has fred in it
I don't see a Fred


That default block is really a when with a condition that is always true. If the when before the default has a continue, Perl goes on to the default too. It's as if the default were really another when:

use 5.010;

given( $ARGV[0] ) {
    when( $_ ~~ /fred/i ) { say 'Name has fred in it'; continue }
    when( $_ ~~ /^Fred/ ) { say 'Name starts with Fred'; continue }
    when( $_ ~~ 'Fred'  ) { say 'Name is Fred'; continue } # OOPS!
    when( 1 == 1        ) { say "I don't see a Fred" } # default
    }


To get around this, we leave off that last continue, so the last when stops the process:

use 5.010;

given( $ARGV[0] ) {
    when( $_ ~~ /fred/i ) { say 'Name has fred in it'; continue }
    when( $_ ~~ /^Fred/ ) { say 'Name starts with Fred'; continue }
    when( $_ ~~ 'Fred'  ) { say 'Name is Fred'; break } # OK now!
    when( 1 == 1        ) { say "I don't see a Fred" }
    }


Now that we've shown you everything that's going on, we rewrite it in the idiomatic form, which is how you should use it in your programs:

use 5.010;

given( $ARGV[0] ) {
    when( /fred/i ) { say 'Name has fred in it'; continue }
    when( /^Fred/ ) { say 'Name starts with Fred'; continue }
    when( 'Fred'  ) { say 'Name is Fred'; }
    default         { say "I don't see a Fred" }
    }


			2.15.3.1 Dumb Matching

Although the given-when can use smart matching, you can use the "dumb" comparisons that you already know. It's not really dumb, it's just the regular matching that you already know. When Perl sees an explicit comparison operator (of any type) or the binding operator, it does only what those operators do:

use 5.010;

given( $ARGV[0] ) {
    when( $_ =~ /fred/i ) { say 'Name has fred in it'; continue }
    when( $_ =~ /^Fred/ ) { say 'Name starts with Fred'; continue }
    when( $_ eq 'Fred'  ) { say 'Name is Fred' }
    default               { say "I don't see a Fred" }
    }


You can even mix and match dumb and smart matching; the individual when expressions figure out their comparisons on their own:

use 5.010;

given( $ARGV[0] ) {
    when( /fred/i )       { #smart
        say 'Name has fred in it'; continue }
    when( $_ =~ /^Fred/ ) { #dumb
        say 'Name starts with Fred'; continue }
    when( 'Fred'  )       { #smart
        say 'Name is Fred' }
    default               { say "I don't see a Fred" }
    }


Note that the dumb and smart match for a pattern match are indistinguishable since the regular expression operator already binds to $_ by default.

The smart match operator finds things that are the same (or mostly the same), so it doesn't work with comparisons for greater than or less than. In those cases, you have to use the right comparison operators:

use 5.010;

given( $ARGV[0] ) {
    when( /^-?\d+\.\d+$/ ) { #smart
        say 'Not a number!' }
    when( $_ > 10 )        { #dumb
        say 'Number is greater than 10'  }
    when( $_ < 10 )        { #dumb
        say 'Number is less than 10' }
    default                { say 'Number is 10' }
    }


There are certain situations in which Perl will automatically use dumb matching. You can use the result of a subroutine[*] inside the when, in which case, Perl uses the truth or falseness of the return value:

    [*] Perl doesn't use smart matching for method calls either, but we don't cover object-oriented programming until Intermediate Perl (O'Reilly).

use 5.010;

given( $ARGV[0] ) {
    when( name_has_fred( $_ ) ) { #dumb
        say 'Name has fred in it'; continue }
    }


The subroutine call rule also applies to the Perl built-ins defined, exists, and eof too, since those are designed to return true or false.

Negated expressions, including negated regular expressions, don't use a smart match either. These cases are just like the control structure conditions you saw in previous chapters:

use 5.010;

given( $ARGV[0] ) {
    when( ! $boolean )  { #dumb
        say 'Name has fred in it' }
    when( ! /fred/i   } { #dumb
        say 'Does not match Fred' }
    }
    
		2.15.4. when with Many Items

Sometimes you'll want to go through many items, but given takes only one thing at a time. In this case, you could wrap given in a foreach loop. If you wanted to go through @names, you could assign the current element to $name, then use that for given:

use 5.010;

foreach my $name ( @names ) {
    given( $name ) {
        ...
        }
    }


Guess what? Yep, that's too much work. (Are you tired of all of this extra work yet?) This time, let's alias the current element of @names just so given can alias it also. Perl should be smarter than that! Don't worry, it is.

To go through many elements, you don't need the given. Let foreach put the current element in $_ on its own. If you want to use smart matching, the current element has to be in $_.

use 5.010;

foreach ( @names ) { # don't use a named variable!
    when( /fred/i ) { say 'Name has fred in it'; continue }
    when( /^Fred/ ) { say 'Name starts with Fred'; continue }
    when( 'Fred'  ) { say 'Name is Fred'; }
    default         { say "I don't see a Fred" }
    }


If you are going to go through several names though, you probably want to see which name you're working on. You can put other statements in the foreach block, such as a say statement:

use 5.010;

foreach ( @names ) { # don't use a named variable!
    say "\nProcessing $_";

    when( /fred/i ) { say 'Name has fred in it'; continue }
    when( /^Fred/ ) { say 'Name starts with Fred'; continue }
    when( 'Fred'  ) { say 'Name is Fred'; }
    default         { say "I don't see a Fred" }
    }


You can even put extra statements between the whens, such as putting a debugging statement right before the default (which you can also do with given):

use 5.010;

foreach ( @names ) { # don't use a named variable!
    say "\nProcessing $_";

    when( /fred/i ) { say 'Name has fred in it'; continue }
    when( /^Fred/ ) { say 'Name starts with Fred'; continue }
    when( 'Fred'  ) { say 'Name is Fred'; }
    say "Moving on to default...";
    default         { say "I don't see a Fred" }
    }

		2.15.5. Exercises
# [15] Rewrite your number guessing program from Exercise 1 in Chapter 10 to use given. How would you handle nonnumeric input? You don't need to use smart matching.
# [15] Write a program using given-when that takes a number as its input, then prints "Fizz" if it is divisible by three, "Bin" if it is divisible by five, and "Sausage" if it is divisible by seven. For a number like 15, it should print "Fizz" and "Bin" since 15 is divisible by both 3 and 5. What's the first number for which your program prints "Fizz Bin Sausage"?
# [15] Using for-when, write a program that goes through a list of files on the command line and reports if each file is readable, writable, or executable. You don't need to use smart matching.
# [20] Using given and smart matching, write a program that reports all the divisors (except 1 and the number itself) of a number you specify on the command line. For instance, for the number 99, your program should report that it is divisible by 3, 9, 11, and 33. If the number is prime (it has no divisors), it should report that the number is prime instead. If the command-line argument is not a number, it should report the error and not try to compute the divisors. Although you could do this with if constructs and with dumb matching, use only smart matching.

To get you started, here's a subroutine to return a list of divisors. It tries all of the numbers up to one-half of $number:

sub divisors {
    my $number = shift;

    my @divisors = ();
    foreach my $divisor ( 2 .. $number/2 ) ) {
        push @divisors, $divisor unless $_ % $divisor;
        }

    return @divisors;
    }


# [20] Modify the program from the previous exercise to also report if the number is odd or even, if the number is prime (you find no divisors other than 1 and the number itself), and if it is divisible by your favorite number. Again, use only smart matching.


Answers in: /cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic
guess_number_use_given.pl
simple_given_when_example.pl
for_when_example.pl
[yizaq@yytzhak-wxp:Thu May 28:/cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic:]$ ./smart_match_find_divisors.pl 91
Checking number 91
number is divisable by: 7 13


	2.16 Process Management

		One of the best parts of being a programmer is launching someone else's code so that you don't have to write it yourself. It's time to learn how to manage your children[325] by launching other programs directly from Perl.

    [325] Child processes, that is.

And like everything else in Perl, There's More Than One Way To Do It, with lots of overlap, variations, and special features. So, if you don't like the first way, just read on for another page or two for a solution more to your liking.

Perl is very portable; most of the rest of this book doesn't need many notes saying that it works this way on Unix systems and that way on Windows and the other way on VMS. But when you're starting other programs on your machine, different programs are available on a Macintosh than you'll likely find on a Cray. The examples in this chapter are primarily Unix-based; if you have a non-Unix system, you can expect to see some differences.

		2.16.1 The system Function
The simplest way to launch a child process in Perl to run a program is the system function. For example, to invoke the Unix date command from within Perl, it looks like:

system "date";


The child process runs the date command, which inherits Perl's standard input, standard output, and standard error. This mean that the normal short date-and-time string generated by date ends up wherever Perl's STDOUT was already going.

The parameter to the system function is generally whatever you'd normally type at the shell. So, if it were a more complicated command, like ls -l $HOME, we'd just have to put all that into the parameter:

system 'ls -l $HOME';


Note that we had to switch here from double quotes to single quotes, since $HOME is the shell's variable. Otherwise, the shell would never have seen the dollar sign, since that's also an indicator for Perl to interpolate. Alternatively, we could write:

system "ls -l \$HOME";


But that can quickly become unwieldy.

Now, the date command is output-only, but let's say it had been a chatty command, asking first "for which time zone do you want the time?"[*] That'll end up on standard output, and then the program will listen on standard input (inherited from Perl's STDIN) for the response. You'll see the question, and type in the answer (like "Zimbabwe time"), and then date will finish its duty.

    [*] As far as we know, no one has made a date command that works like this.

While the child process is running, Perl is patiently waiting for it to finish. So, if the date command took 37 seconds, then Perl is paused for those 37 seconds. You can use the shell's facility to launch a background process,[dagger] however:

    [dagger] See what we mean about this depending upon your system? The Unix shell (/bin/sh) lets you use the ampersand on this kind of command to make a background process. If your non-Unix system doesn't support this way to launch a background process, then you can't do it this way, that's all.

system "long_running_command with parameters &";


Here, the shell launches, then notices the ampersand at the end of the command line, which causes it to put long_running_command into the background. And then the shell exits rather quickly, which Perl notices and moves on. In this case, the long_running_command is really a grandchild of the Perl process, to which Perl really has no direct access or knowledge.

When the command is "simple enough," no shell gets involved, so for the date and ls commands earlier, the requested command is launched directly by Perl, which searches the inherited PATH[double dagger] to find the command, if necessary. But if there's anything weird in the string (such as shell metacharacters like the dollar sign, semicolon, or vertical bar), then the standard Bourne Shell (/bin/sh[||]) gets invoked to work through the complicated stuff. In that case, the shell is the child process, and the requested commands are grandchildren (or further offspring). For example, you can write an entire little shell script in the argument:

    [double dagger] The PATH can be changed by adjusting $ENV{'PATH'} at any time. Initially, this is the environment variable inherited from the parent process (usually the shell). Changing this value affects new child processes, but cannot affect any preceding parent processes. The PATH is the list of directories where executable programs (commands) are found, even on some non-Unix systems.

    [||] Or whatever was determined when Perl was built. Practically always, this is just /bin/sh on Unix-like systems.

system 'for i in *; do echo == $i ==; cat $i; done';


Here again, we're using single quotes because the dollar signs here are meant for the shell and not for Perl. Double quotes would have permitted Perl to expand $i to its current Perl value and not let the shell expand it to its own value.[*] By the way, that little shell script goes through all of the normal files in the current directory, printing out each one's name and contents; you can try it out yourself if you don't believe us.

    [*] Of course, if you set $i = '$i', then it would work anyway, until a maintenance programmer came along and "fixed" that line out of existence.

			2.16.1.1 Avoiding the Shell

The system operator may also be invoked with more than one argument,[dagger] in which case, a shell doesn't get involved, no matter how complicated the text:

    [dagger] Or with a parameter in the indirect-object slot, like system { 'fred' } 'barney';, which runs the program barney, but lies to it so it thinks that it's called 'fred'. See the perlfunc manpage.

my $tarfile = "something*wicked.tar";
my @dirs = qw(fred|flintstone <barney&rubble> betty );
system "tar", "cvf", $tarfile, @dirs;


In this case, the first parameter ("tar" here) gives the name of a command found in the normal PATH-searching way, while the remaining arguments are passed, one-by-one, directly to that command. Even if the arguments have shell-significant characters, such as the name in $tarfile or the directory names in @dirs, the shell never gets a chance to mangle the string. So that tar command will get precisely five parameters. Compare this with:

system "tar cvf $tarfile @dirs";  # Oops!


Here, we've now piped a bunch of stuff into a flintstone command and put it into the background, and opened betty for output.

And that's a bit scary,[double dagger] especially if those variables are from user inputsuch as from a web form or something. So, if you can arrange things so that you can use the multiple-argument version of system, you probably should use that way to launch your subprocess. (You'll have to give up the ability to have the shell do the work for you to set up I/O redirection, background processes, and the like, though. There's no such thing as a free launch.)

    [double dagger] Unless you're using taint checking and have done all the right things to prescan your data to ensure that the user isn't trying to pull a fast one on you.

Note that redundantly, a single argument invocation of system is nearly equivalent to the proper multiple-argument version of system:

system $command_line;
system "/bin/sh", "-c", $command_line;


But nobody writes the latter, unless you want things processed by a different shell, like the C shell:

system "/bin/csh", "-fc", $command_line;


Even this is pretty rare, since the One True Shell[*] seems to have a lot more flexibility, especially for scripted items.

    [*] That's /bin/sh, or whatever your Unix system has installed as the most Bourne-like shell. If you don't have a One True Shell, Perl figures out how to invoke some other command-line interpreter, with notable consequencesnoted, that is, in the documentation for that Perl port.

The return value of the system operator is based upon the exit status of the child command.[dagger] In Unix, an exit value of 0 means that everything is okay, and a nonzero exit value usually indicates that something went wrong:

    [dagger] It's actually the "wait" status, which is the child exit code times 256, plus 128 if core was dumped, plus the signal number triggering termination, if any. But we rarely check the specifics of that, and a simple true/false value suffices for nearly all applications.

unless (system "date") {
  # Return was zero - meaning success
  print "We gave you a date, OK!\n";
}


Note that this is backward from the normal "true is goodfalse is bad" strategy for most of the operators, so to write a typical "do this or die" style, we'll need to flip false and true. The easiest way is simply to prefix the system operator with a bang (the logical-not operator):

!system "rm -rf files_to_delete" or die "something went wrong";


In this case, including $! in the error message would not be appropriate because the failure is most likely somewhere within the experience of the rm command, and it's not a system callrelated error within Perl that $! can reveal.


		2.16.2 The exec Function

Everything we've just said about system syntax and semantics is also true about the exec function, except for one (very important) thing. The system function creates a child process, which then scurries off to perform the requested action while Perl naps. The exec function causes the Perl process itself to perform the requested action. Think of it as more like a "goto" than a subroutine call.

For example, suppose we wanted to run the bedrock command in the /tmp directory, passing it arguments of -o args1 followed by whatever arguments our own program was invoked with. That'd look like this:

chdir "/tmp" or die "Cannot chdir /tmp: $!";
exec "bedrock", "-o", "args1", @ARGV;


When we reach the exec operation, Perl locates bedrock, and "jumps into it." At that point, there is no Perl process anymore,[double dagger] just the process running the bedrock command. When bedrock is finished, there's no Perl to come back to, so we'd get a prompt back if we invoked this program from the command line.

    [double dagger] Actually, it's the same process, having performed the Unix exec(2) system call (or equivalent). The process ID remains the same.

Why is this useful? Well, if the purpose of this Perl program were to set up a particular environment to run another program, the purpose is fulfilled as soon as the other program has started. If we'd used system instead of exec, we'd have a Perl program just standing around tapping its toes waiting for the other program to complete, just so Perl could finally immediately exit as well, and that's a wasted resource.

Having said that, it's actually quite rare to use exec, except in combination with fork (which you'll see later). If you are puzzling over system versus exec, just pick system, and nearly all of the time, you'll be just fine.

Because Perl is no longer in control once the requested command has started, it doesn't make any sense to have any Perl code following the exec, except for handling the error when the requested command cannot be started:

exec "date";
die "date couldn't run: $!";


In fact, if you have warnings turned on, and if you have any code after the exec other than a die,[*] you'll get notified.

    [*] Or exit. Or if it's at the end of a block. This may change in a new release of Perl, too.

		2.16.3 The Environment Variables

When you're starting another process (with any of the methods discussed here), you may need to set up its environment in one way or another. As we mentioned earlier, you could start the process with a certain working directory, which it inherits from your process. Another common configuration detail is the environment variables.

One of the best-known environment variables is PATH. (If you've never heard of it, you probably haven't used a system that has environment variables.) On Unix and similar systems, PATH is a colon-separated list of directories that may hold programs. When you type a command like rm fred, the system will look for the rm command in that list of directories, in order. Perl (or your system) will use PATH whenever it needs to find the program to run. If the program in turn runs other programs, those may also be found along the PATH. (Of course, if you give a complete name for a command, such as /bin/echo, there's no need to search PATH. But that's generally much less convenient.)

In Perl, the environment variables are available via the special %ENV hash; each key in this hash represents one environment variable. At the start of your program's execution, %ENV holds values it has inherited from its parent process (generally the shell). Modifying this hash changes the environment variables, which will then be inherited by new processes and possibly used by Perl as well. For example, suppose you wished to run the system's make utility (which typically runs other programs), and you want to use a private directory as the first place to look for commands (including make itself). And let's say that you don't want the IFS environment variable to be set when you run the command because that might cause make or some subcommand do the wrong thing. Here we go:

$ENV{'PATH'} = "/home/rootbeer/bin:$ENV{'PATH'}";
delete $ENV{'IFS'};
my $make_result = system "make";


Newly created processes will generally inherit from their parent the environment variables; the current working directory; the standard input, output, and error streams; and a few more esoteric items. See the documentation about programming on your system for more details. (But your program can't change the environment for the shell or other parent process that started it, on most systems.)

		2.16.4 Using Backquotes to Capture Output

With both system and exec, the output of the launched command ends up wherever Perl's standard output is going. Sometimes it's interesting to capture that output as a string value to perform further processing. And that's done simply by creating a string using backquotes instead of single or double quotes:

my $now = `date`;             # grab the output of date
print "The time is now $now"; # newline already present


Normally, this date command spits out a string approximately 30 characters long to its standard output, giving the current date and time followed by a newline. When we've placed date between backquotes, Perl executes the date command, arranging to capture its standard output as a string value and, in this case, assign it to the $now variable.

This is very similar to the Unix shell's meaning for backquotes. However, the shell also performs the additional job of ripping off the final end-of-line to make it easier to use the value as part of other things. Perl is honest; it gives the real output. To get the same result in Perl, we can simply add an additional chomp operation on the result:

chomp(my $no_newline_now = `date`);
print "A moment ago, it was $no_newline_now, I think.\n";


The value between backquotes is just like the single-argument form of system[*] and is interpreted as a double-quoted string, meaning that backslash-escapes and variables are expanded appropriately.[dagger] For example, to fetch the Perl documentation on a list of Perl functions, we might invoke the perldoc command repeatedly, each time with a different argument:

    [*] That is, it's also always interpreted by the One True Shell (/bin/sh) or alternative, as with system.

    [dagger] So, if you want to pass a real backslash to the shell, you'll need to use two. If you need to pass two (which happens frequently on Windows systems), you'll need to use four.

my @functions = qw{ int rand sleep length hex eof not exit sqrt umask };
my %about;

foreach (@functions) {
  $about{$_} = `perldoc -t -f $_`;
}


Note that $_ will be a different value for each invocation, letting us grab the output of a different command varying only in one of its parameters. Also note that if you haven't seen some of these functions yet, it might be useful to look them up in the documentation to see what they do!

There's no easy equivalent of single quotes for backquotes;[*] variable references and backslash items are always expanded. Also, there's no easy equivalent of the multiple-argument version of system (where a shell is never involved). If the command inside the backquotes is complex enough, a Unix Bourne Shell (or whatever your system uses instead) is invoked to interpret the command automatically.

    [*] For a couple of harder ways, you can place your string inside qx'...' delimiters, or you can put it all in a variable using a single-quoted string, then interpolate that string into a backquoted string, since the interpolation will be only one level.

At the risk of actually introducing the behavior by demonstrating how not to do it, we'd also like to suggest that you avoid using backquotes in a place where the value isn't being captured.[dagger] For example:

    [dagger] This is called a "void" context.

print "Starting the frobnitzigator:\n";
`frobnitz -enable`; # please don't do this!
print "Done!\n";


The problem is that Perl has to work a bit harder to capture the output of this command, even when you're just throwing it away, and then you also lose the option to use multiple arguments to system to precisely control the argument list. So from both a security standpoint and an efficiency viewpoint, just use system instead, please.

Standard error of a backquoted command is inherited from Perl's current standard error output. If the command spits out error messages to standard error, you'll probably see them on the terminal, which could be confusing to the user who hasn't personally invoked the frobnitz command. If you want to capture error messages with standard output, you can use the shell's normal "merge standard error to the current standard output," which is spelled 2>&1 in the normal Unix shell:

my $output_with_errors = `frobnitz -enable 2>&1`;


Note that this will make the standard error output intermingled with the standard output, much as it appears on the terminal (although possibly in a slightly different sequence because of buffering). If you need the output and the error output separated, there are many harder-to-type solutions.[double dagger] Similarly, standard input is inherited from Perl's current standard input. Most commands we typically use with backquotes do not read standard input, so that's rarely a problem. However, let's say the date command asked which time zone you want (as we imagined earlier). That'll be a problem because the prompt for "which time zone" will be sent to standard output, which is being captured as part of the value, and then the date command will start trying to read from standard input. But since the user has never seen the prompt, he doesn't know he should be typing anything! Pretty soon, the user calls you up and tells you that your program is stuck.

    [double dagger] Such as IPC::Open3 in the standard Perl library, or writing your own forking code, as you will see later.

So, stay away from commands that read standard input. If you're not sure whether something reads from standard input, then add a redirection from /dev/null for input, like this:

my $result = `some_questionable_command arg arg argh </dev/null`;


Then the child shell will redirect input from /dev/null, and the grandchild questionable command will at worst try to read and immediately get an end-of-file.

			2.16.4.1  Using Backquotes in a List Context

If the output from a command has multiple lines, the scalar use of backquotes returns it as a single long string containing newline characters. However, using the same backquoted string in a list context yields a list containing one line of output per element.

For example, the Unix who command normally spits out a line of text for each current login on the system as follows:

merlyn     tty/42     Dec 7  19:41
rootbeer   console    Dec 2  14:15
rootbeer   tty/12     Dec 6  23:00


The left column is the username, the middle column is the tty name (that is, the name of the user's connection to the machine), and the rest of the line is the date and time of login (and possibly remote login information, but not in this example). In a scalar context, we get all that at once, which we would then need to split up:

my $who_text = `who`;


But in a list context, we automatically get the data broken up by lines:

my @who_lines = `who`;


We'll have a number of separate elements in @who_lines, each one terminated by a newline. Of course, adding a chomp around the outside of that will rip off those newlines, but let's go in a different direction. If we put that as part of the value for a foreach, we'll iterate over the lines automatically, placing each one in $_:

foreach (`who`) {
  my($user, $tty, $date) = /(\S+)\s+(\S+)\s+(.*)/;
  $ttys{$user} .= "$tty at $date\n";
}


This loop will iterate three times for the data above. (Your system will probably have more than three active logins at any given time.) Notice that we've got a regular expression match, and in the absence of the binding operator (=~), that's matching against $_, which is good because that's where the data is.

Also notice the regular expression is looking for a nonblank word, some whitespace, a nonblank word, some whitespace, and then the rest of the line up to, but not including, the newline (since dot doesn't match newline by default).[*] That's also good because that's what the data looks like each time in $_. That'll make $1 be "merlyn", $2 be "tty/42", and $3 be "Dec 7 19:41", as a successful match on the first time through the loop.

    [*] Now you can see why dot doesn't match newline by default. It makes it easy to write patterns like this one, in which we don't have to worry about a newline at the end of the string.

However, this regular expression match is in a list context, so we'll get the list of memories instead of the true/false "did it match" value, as described in Chapter 8. So, $user ends up being "merlyn", and so on.

The second statement inside the loop simply stores away the tty and date information, appending to a (possibly undef) value in the hash because a user might be logged in more than once, as user "rootbeer" was in our example.


		2.16.5 Processes as Filehandles

So far, we've been looking at ways to deal with synchronous processes, where Perl stays in charge, launches a command, (usually) waits for it to finish, then possibly grabs its output. But Perl can also launch a child process that stays alive, communicating[dagger] to Perl on an ongoing basis until the task is complete.

    [dagger] Via pipes, or whatever your operating system provides for simple interprocess communication.

The syntax for launching a concurrent (parallel) child process is to put the command as the "filename" for an open call, and either precede or follow the command with a vertical bar, which is the "pipe" character. For that reason, this is often called a piped open.

open DATE, "date|" or die "cannot pipe from date: $!";
open MAIL, "|mail merlyn" or die "cannot pipe to mail: $!";


In the first example, with the vertical bar on the right, the command is launched with its standard output connected to the DATE filehandle opened for reading, similar to the way that the command date | your_program would work from the shell. In the second example, with the vertical bar on the left, the command's standard input is connected to the MAIL filehandle opened for writing, similar to what happens with the command your_program | mail merlyn. In either case, the command is now launched and continues independently of the Perl process.[double dagger] The open fails if the child process cannot be created. If the command itself does not exist or exits erroneously, this will (generally) not be seen as an error when opening, but as an error when closing. We'll get to that in a moment.

    [double dagger] If the Perl process exits before the command is complete, a command that's been reading will see end-of-file, while a command that's been writing will get a "broken pipe" error signal on the next write, by default.

For all intents and purposes, the rest of the program doesn't know, doesn't care, and would have to work pretty hard to figure out that this is a filehandle opened on a process rather than on a file. So, to get data from a filehandle opened for reading, we'll just do the normal read:

my $now = <DATE>;


And to send data to the mail process (waiting for the body of a message to deliver to merlyn on standard input), a simple print-with-a-filehandle will do:

print MAIL "The time is now $now"; # presume $now ends in newline


In short, you can pretend that these filehandles are hooked up to magical files, one that contains the output of the date command, and one that will automatically be mailed by the mail command.

If a process is connected to a filehandle that is open for reading, and then exits, the filehandle returns end-of-file, just like reading up to the end of a normal file. When you close a filehandle open for writing to a process, the process will see end-of-file. So, to finish sending the email, close the handle:

close MAIL;
die "mail: non-zero exit of $?" if $?;


Closing a filehandle attached to a process waits for the process to complete so that Perl can get the process's exit status. The exit status is then available in the $? variable (reminiscent of the same variable in the Bourne Shell) and is the same kind of number as the value returned by the system function: zero for success, nonzero for failure. Each new exited process overwrites the previous value though, so save it quickly if you want it. (The $? variable also holds the exit status of the most recent system or backquoted command, if you're curious.)

The processes are synchronized just like a pipelined command. If you try to read and no data is available, the process is suspended (without consuming additional CPU time) until the sending program has started speaking again. Similarly, if a writing process gets ahead of the reading process, the writing process is slowed down until the reader starts to catch up. There's a buffer (usually 8 KB or so) in between, so they don't have to stay precisely in lock step.

Why use processes as filehandles? Well, it's the only easy way to write to a process based on the results of a computation. But if you're just reading, backquotes are often much easier to manage, unless you want to have the results as they come in.

For example, the Unix find command locates files based on their attributes, and it can take quite a while if used on a fairly large number of files (such as starting from the root directory). You can put a find command inside backquotes, but it's often nicer to see the results as they are found:

open F, "find / -atime +90 -size +1000 -print|" or die "fork: $!";
while (<F>) {
  chomp;
  printf "%s size %dK last accessed on %s\n",
    $_, (1023 + -s $_)/1024, -A $_;
}


The find command here is looking for all the files that were not accessed within the past 90 days and that are larger than 1000 blocks. (These are good candidates to move to longer-term storage.) While find is searching and searching, Perl can wait. As each file is found, Perl responds to the incoming name and displays some information about that file for further research. Had this been written with backquotes, we'd not see any output until the find command had finished, and it's comforting to see that it's actually doing the job even before it's done.


		2.16.6 Getting Down and Dirty with Fork

In addition to the high-level interfaces already described, Perl provides nearly direct access to the low-level process management system calls of Unix and some other systems. If you've never done this before,[*] you will probably want to skip this section. While it's a bit much to cover all that stuff in a chapter like this, let's at least look at a quick reimplementation of this:

    [*] Or you're not running on a system that has support for forking. But the Perl developers are working hard to add forking even on systems whose underlying process model is very different than the one in Unix.

system "date";


Let's look at how that would be done using the low-level system calls:

defined(my $pid = fork) or die "Cannot fork: $!";
unless ($pid) {
  # Child process is here
  exec "date";
  die "cannot exec date: $!";
}
# Parent process is here
waitpid($pid, 0);


Here, we've checked the return value from fork, which will be undef if it failed. Usually it will succeed, causing two separate processes to continue to the next line, but here only the parent process has a nonzero value in $pid, so only the child process executes the exec function. The parent process skips over that and executes the waitpid function, waiting for that particular child to finish (if others finish in the meantime, they are ignored). If that all sounds like gobbledygook, just remember that you can continue to use the system function without being laughed at by your friends.

When you go to this extra trouble, you also have full control over arbitrary pipe creation, rearranging filehandles, and noticing your process ID and your parent's process ID (if knowable). But again, that's all a bit complicated for this chapter, so see the details in the perlipc manpage (and in any good book on application programming on your system) for further information.

		2.16.7 Sending and Receiving Signals

A Unix signal is a tiny message sent to a process. It can't say much; it's like a car horn honkingdoes that honk you hear mean "look outthe bridge collapsed" or "the light has changedget going" or "stop drivingyou've got a baby on the roof" or "hello, world"? Well, fortunately, Unix signals are a little easier to interpret than that because there's a different one for each of these situations.[*] Different signals are identified by a name (such as SIGINT, meaning "interrupt signal") and a corresponding small integer (in the range from 1 to 16, 1 to 32, or 1 to 63, depending on your Unix flavor). Signals are typically sent when a significant event happens, such as pressing the interrupt character (typically Control-C) on the terminal, which sends a SIGINT to all the processes attached to that terminal.[dagger] Some signals are sent automatically by the system, but they can also come from another process.

    [*] Well, not exactly these situations, but analogous Unix-like ones. For these, the signals are SIGHUP, SIGCONT, SIGINT, and the fake SIGZERO (signal number zero).

    [dagger] And you thought that pressing Control-C stopped your program. Actually, it simply sends the SIGINT signal, and that stops the program by default. As you'll see later in this chapter, you can make a program that does something different when SIGINT comes in, rather than stopping at once.

You can send signals from your Perl process to another process, but you have to know the target's process ID number. How to figure that out is a bit complicated,[double dagger] but let's say you know that you want to send a SIGINT to process 4201. That's easy enough:

    [double dagger] Usually you have the process ID because it's a child process you produced with fork, or you found it in a file or got it from an external program. Using an external program can be difficult and problematic, which is why many long-running programs save their own current process ID into a file, usually described in the program's documentation.

kill 2, 4201 or die "Cannot signal 4201 with SIGINT: $!";


It's named "kill" because one of the primary purposes of signals is to stop a process that's gone on long enough. You can also use the string 'INT' in place of the 2 there because signal number 2 is SIGINT. If the process no longer exists,[||] you'll get a false return value, so you can also use this technique to see whether a process is still alive. A special signal number of 0 says "just check to see whether I could send a signal if I wanted to, but I don't want to, so don't actually send anything." So a process probe might look like:

    [||] Sending a signal will also fail if you're not the superuser and it's someone else's process. It would be rude to send SIGINT to someone else's programs, anyway.

unless (kill 0, $pid) {
  warn "$pid has gone away!";
}


Perhaps a little more interesting than sending signals is catching signals. Why might you want to do this? Well, suppose you have a program that creates files in /tmp, and you normally delete those files at the end of the program. If someone presses Control-C during the execution, that leaves trash in /tmp, a very unpolite thing to do. To fix this, create a signal handler that takes care of the cleanup:

my $temp_directory = "/tmp/myprog.$$"; # create files below here
mkdir $temp_directory, 0700 or die "Cannot create $temp_directory: $!";

sub clean_up {
  unlink glob "$temp_directory/*";
  rmdir $temp_directory;
}

sub my_int_handler {
  &clean_up;
  die "interrupted, exiting...\n";
}

$SIG{'INT'} = 'my_int_handler';
.
.   # Time passes, the program runs, creates some temporary
.   # files in the temp directory, maybe someone presses Control-C
.
# Now it's the end of normal execution
&clean_up;


The assignment into the special %SIG hash activates the handler (until revoked). The key is the name of the signal (without the constant SIG prefix), and the value is a string[*] naming the subroutine, without the ampersand. From then on, if a SIGINT comes along, Perl stops whatever it's doing and jumps immediately to the subroutine. Our subroutine cleans up the temp files and then exits. (And if nobody presses Control-C, we'll still call &clean_up at the end of normal execution.)

    [*] The value can also be a subroutine reference, but we're not doing those here.

If the subroutine returns rather than exits, execution resumes right where it was interrupted. This can be useful if the interrupt actually needs to interrupt something rather than cause it to stop. For example, suppose processing each line of a file takes a few seconds, which is pretty slow, and you want to abort the overall processing when an interrupt is processed, but not in the middle of processing a line. Just set a flag in the interrupt procedure, and check it at the end of each line's processing:

my $int_count;
sub my_int_handler { $int_count++ }
$SIG{'INT'} = 'my_int_handler';
...
$int_count = 0;
while (<SOMEFILE>) {
  ... some processing that takes a few seconds ...
  if ($int_count) {
    # interrupt was seen!
    print "[processing interrupted...]\n";
    last;
  }
}


Now as each line is processed, the value of $int_count will be 0 if no one has pressed Control-C, and so the loop will continue to the next item. However, if an interrupt comes in, the interrupt handler increments the $int_count flag, breaking out of the loop when checked at the end.

So, you can either set a flag or break out of the program, and that covers most of what you'll need from catching signals. The current implementation of signal handlers is not entirely without faults,[*] however, so keep the stuff you're doing in there to an absolute minimum, or your program may end up blowing up sometime when you least expect it.

    [*] This is one of the top items on the Perl developers' list of things to fix, so we expect reliable signal handling to be one of the first items on the new feature list for Perl 6. The problem is that a signal may come in at any time, even when Perl isn't ready for one. If Perl is (for example) in the middle of allocating some memory when a signal comes in, the signal handler can accidentally try to allocate some memoryand your program is dead. You can't control when your Perl code will allocate memory, but XSUB code (usually written in C) can safely handle signals. See the Perl documentation for more information about this advanced topic.
 
		2.16.8 Exercises
# [6] Write a program that changes to some particular (hardcoded) directory, like the system's root directory, then executes the ls -l command to get a long-format directory listing in that directory. (If you use a non-Unix system, use your own system's command to get a detailed directory listing.)
# [10] Modify the previous program to send the output of the command to a file called ls.out in the current directory. The error output should go to a file called ls.err. (You don't need to do anything special about the fact that either of these files may end up being empty.)
# [8] Write a program to parse the output of the date command to determine the current day of the week. If the day of the week is a weekday, print get to work, otherwise print go play. The output of the date command begins with Mon on a Monday.[dagger] If you don't have a date command on your non-Unix system, make a fake little program that simply prints a string like date might print. We'll even give you this two-line program if you promise not to ask us how it works:

    [dagger] At least when the days of the week are being given in English. You might have to adjust accordingly if that's not the case on your system.

#!/usr/bin/perl
print localtime( ) . "\n";

Solutions
[yizaq@yytzhak-wxp:Mon Jun 01:/cygdrive/c/work/KB/perl/learning_perl_5_edition_examples/basic:]$ ./invoke_process_example.pl 

./parse_date_output.pl 

	2.17 Some Advanced Perl Techniques
	
		2.17.1 Trapping Errors with eval

What we've put in this book so far is the core of Perl, the part that every Perl user should understand. But there are a few other techniques that, while not obligatory, are still valuable tools to have in your toolbox. We've gathered the most important of those for this chapter.

Don't be misled by the title of the chapter, though; the techniques here aren't necessarily more difficult to understand than what we have elsewhere. They are "advanced" merely in the sense that they aren't necessary for beginners. The first time you read this book, you may want to skip (or skim) this chapter, so you can get right to using Perl. Come back to it a month or two later, when you're ready to get even more out of Perl. Consider this entire chapter a huge footnote.[353]

    [353] We contemplated doing that in one of the drafts but got firmly rejected by O'Reilly's editors.

			2.17.1.1 Trapping Errors with eval

Sometimes, your ordinary, everyday code can cause a fatal error in your program. Each of these typical statements could crash a program:

$barney = $fred / $dino;         # divide-by-zero error?

print "match\n" if /^($wilma)/;  # illegal regular expression error?

open CAVEMAN, $fred              # user-generated error from die?
  or die "Can't open file '$fred' for input: $!";


You could go to some trouble to catch some of these, but it's hard to get them all. (How could you check the string $wilma from that example to ensure that it makes a valid regular expression?) Fortunately, Perl provides a simple way to catch fatal errorswrap the code in an eval block:

eval { $barney = $fred / $dino } ;


Now, even if $dino is zero, that line won't crash the program. The eval is actually an expression (not a control structure, like while or foreach), so that semicolon is required at the end of the block.

When a normally fatal error happens during the execution of an eval block, the block is done running, but the program doesn't crash. So that means that right after an eval finishes, you'll want to know whether it exited normally or whether it caught a fatal error for you. The answer is in the special $@ variable. If the eval caught a fatal error, $@ will hold what would have been the program's dying words, perhaps something like: Illegal division by zero at my_program line 12. If there was no error, $@ will be empty. Of course, that means that $@ is a useful Boolean (true/false) value (true if there was an error), so you'll sometimes see code like this after an eval block:

print "An error occurred: $@" if $@;


The eval block is a true block, so it makes a new scope for lexical (my) variables. This piece of a program shows an eval block hard at work:

foreach my $person (qw/ fred wilma betty barney dino pebbles /) {
  eval {
    open FILE, "<$person"
      or die "Can't open file '$person': $!";

    my($total, $count);

    while (<FILE>) {
      $total += $_;
      $count++;
    }

    my $average = $total/$count;
    print "Average for file $person was $average\n";

    &do_something($person, $average);
  };

  if ($@) {
    print "An error occurred ($@), continuing\n";
  }
}


How many possible fatal errors are being trapped here? If there is an error in opening the file, that error is trapped. Calculating the average may divide by zero so that error is trapped. Even the call to the mysteriously named &do_something subroutine will be protected against fatal errors because an eval block traps any otherwise fatal errors that occur during the time that it's active. (This feature is handy if you have to call a subroutine written by someone else, and you don't know whether they've coded defensively enough to avoid crashing your program.)

If an error occurs during the processing of one of the files, we'll get an error message, but the program will go on to the next file without further complaint.

You can nest eval blocks inside other eval blocks. The inner one traps errors while it runs, keeping them from reaching the outer blocks. (Of course, after the inner eval finishes, if it caught an error, you may wish to repost the error by using die, thereby letting the outer eval catch it.) An eval block traps any errors that occur during its execution, including errors that happen during subroutine calls (as you saw in the example earlier).

We mentioned earlier that the eval is an expression, which is why the trailing semicolon is needed after the closing curly brace. But since it's an expression, it has a return value. If there's no error, it's like a subroutine: the return value is the last expression evaluated, or it's returned early with an optional return keyword. Here's another way to do the math without having to worry about divide-by-zero:

my $barney = eval { $fred / $dino };


If the eval traps a fatal error, the return value is either undef or an empty list, depending upon the context. So in the previous example, $barney is either the correct result from dividing, or it's undef; we don't really need to check $@ (although it's probably a good idea to check defined($barney) before we use it further).

There are four kinds of problems that eval can't trap. The first group are the very serious errors that crash Perl itself, such as running out of memory or getting an untrapped signal. Since Perl itself isn't running, there's no way it can trap these errors.[*] Of course, syntax errors inside the eval block are caught at compile timethey're never returned in $@.

    [*] Some of these errors are listed with an (X) code on the perldiag manpage, if you're curious.

The exit operator terminates the program at once, even if it's called from a subroutine inside an eval block. (This correctly implies that when writing a subroutine, you should use die rather than exit to signal when something goes wrong.)

The fourth and final kind of problem that an eval block can't trap are warnings, either user-generated ones (from warn) or Perl's internally generated warnings (requested with the -w command-line option or the use warnings pragma). There's a separate mechanism from eval for trapping warnings; see the discussion of the__WARN__ pseudosignal in the Perl documentation for the details.

We should also mention that there's another form of eval that can be dangerous if it's mishandled. In fact, you'll sometimes run across someone who will say that you shouldn't use eval in your code for security reasons. They're (mostly) right that eval should be used only with great care, but they're talking about the other form of eval, sometimes called "eval of a string." If the keyword eval is followed directly by a block of code in curly braces, as we're doing here, there's no need to worrythat's the safe kind of eval.

		2.17.2 Picking Items from a List with grep
	
Sometimes you'll want only certain items from a list. Maybe you'll want only the odd numbers selected from a list of numbers, or maybe only the lines mentioning Fred from a file of text. As you'll see in this section, picking some items from a list can be done simply with the grep  operator.

Let's try that first one and get the odd numbers from a large list of numbers. We don't need anything new to do that:

my @odd_numbers;

foreach (1..1000) {
  push @odd_numbers, $_ if $_ % 2;
}


That code uses the modulus operator (%), which you saw in Chapter 2. If a number is even, that number "mod two" gives zero, which is false. But an odd number will give one; since that's true, only the odd numbers will be pushed onto the array.

Now, there's nothing wrong with that code as it standsexcept that it's a little longer to write and slower to run than it might be, since Perl provides the grep operator:

my @odd_numbers = grep { $_ % 2 } 1..1000;


That line gets a list of 500 odd numbers in one quick line of code. How does it work? The first argument to grep is a block that uses $_ as a placeholder for each item in the list, and returns a Boolean (true/false) value. The remaining arguments are the list of items to search through. The grep operator will evaluate the expression once for each item in the list, much as our original foreach loop did. For the ones where the last expression of the block returns a true value, that element is included in the list that results from grep.

While the grep is running, $_ is aliased to one element of the list after another. You've seen this behavior before, in the foreach loop. It's generally a bad idea to modify $_ inside the grep expression because this will damage the original data.

The grep operator shares its name with a classic Unix utility that picks matching lines from a file by using regular expressions. We can do that with Perl's grep, which is much more powerful. Here we pull only the lines mentioning fred from a file:

my @matching_lines = grep { /\bfred\b/i } <FILE>;


There's a simpler syntax for grep, too. If all you need for the selector is a simple expression (rather than a whole block), you can just use that expression, followed by a comma, in place of the block. Here's the simpler way to write that latest example:

my @matching_lines = grep /\bfred\b/i, <FILE>;

		2.17.3 Transforming Items from a List with map

Another common task is transforming items from a list. For example, suppose we have a list of numbers that should be formatted as "money numbers" for output, as with the subroutine &big_money (from Chapter 14). But we don't want to modify the original data; we need a modified copy of the list just for output. Here's one way to do that:

my @data = (4.75, 1.5, 2, 1234, 6.9456, 12345678.9, 29.95);
my @formatted_data;

foreach (@data) {
  push @formatted_data, &big_money($_);
}


That looks similar in form to the example code used at the beginning of the section on grep, doesn't it? So it may not surprise you that the replacement code resembles the first grep example:

my @data = (4.75, 1.5, 2, 1234, 6.9456, 12345678.9, 29.95);

my @formatted_data = map { &big_money($_) } @data;


The map operator looks much like grep because it has the same kind of arguments: a block that uses $_, and a list of items to process. And it operates in a similar way, evaluating the block once for each item in the list, with $_ aliased to a different original list element each time. But the last expression of the block is used differently; instead of giving a Boolean value, the final value actually becomes part of the resulting list.[*] Any grep or map statement could be rewritten as a foreach loop pushing items onto a temporary array. But the shorter way is typically more efficient and more convenient. Since the result of map or grep is a list, it can be passed directly to another function. Here we can print that list of formatted "money numbers" as an indented list under a heading:

    [*] One other important difference is that the expression used by map is evaluated in a list context and may return any number of items, not necessarily one each time.

print "The money numbers are:\n",
  map { sprintf("%25s\n", $_) } @formatted_data;


Of course, we could have done that processing all at once, without even the temporary array @formatted_data:

my @data = (4.75, 1.5, 2, 1234, 6.9456, 12345678.9, 29.95);
print "The money numbers are:\n",
  map { sprintf("%25s\n", &big_money($_) ) } @data;


As we saw with grep, there's also a simpler syntax for map. If all you need for the selector is a simple expression (rather than a whole block), you can just use that expression, followed by a comma, in place of the block:

print "Some powers of two are:\n",
  map "\t" . ( 2 ** $_ ) . "\n", 0..15;
  
		2.17.4 Unquoted Hash Keys

Perl offers many shortcuts that can help programmers. Here's a handy one: you may omit the quote marks on some hash keys.

Of course, you can't omit the quote marks on just any key, since a hash key may be any arbitrary string. But keys are often simple. If the hash key is made up of nothing but letters, digits, and underscores without starting with a digit, you may be able to omit the quote marks. This kind of simple string without quote marks is called a bareword, since it stands alone without quotes.

One place you are permitted to use this shortcut is the most common place a hash key appears: in the curly braces of a hash element reference. For example, instead of $score{"fred"}, you could write simply $score{fred}. Since many hash keys are simple like this, not using quotes is a real convenience. But beware: if there's anything inside the curly braces besides a bareword, Perl will interpret it as an expression.

Another place where hash keys appear is when assigning an entire hash using a list of key-value pairs. The big arrow (=>) is especially useful between a key and a value because (again, only if the key is a bareword) the big arrow quotes it for you:

# Hash containing bowling scores
my %score = (
  barney   => 195,
  fred     => 205,
  dino     => 30,
);


This is the one important difference between the big arrow and a comma; a bareword to the left of the big arrow is implicitly quoted. (Whatever is on the right is left alone, though.) You don't have to use this feature of the big arrow only for hashes, although that's the most frequent use.

		2.17.5 Slices

It often happens that we need to work with only a few elements from a given list. For example, the Bedrock Library keeps information about their patrons in a large file.[*] Each line in the file describes one patron with six colon-separated fields: a person's name, library card number, home address, home phone number, work phone number, and number of items currently checked out. A little bit of the file looks something like this:

    [*] It should really be a full-featured database rather than a flat file. They plan to upgrade their system, right after the next Ice Age.

fred flintstone:2168:301 Cobblestone Way:555-1212:555-2121:3
barney rubble:709918:3128 Granite Blvd:555-3333:555-3438:0


One of the library's applications needs only the card numbers and number of items checked out; it doesn't use any of the other data. It could use code something like this to get only the fields it needs:

while (<FILE>) {
  chomp;
  my @items = split /:/;
  my($card_num, $count) = ($items[1], $items[5]);
  ...  # now work with those two variables
}


But the array @items isn't needed for anything else; it seems like a waste.[*] Maybe it would be better to assign the result of split to a list of scalars, like this:

    [*] It's not much of a waste, really. But stay with us. All of these techniques are used by programmers who don't understand slices, so it's worthwhile to see all of them here.

my($name, $card_num, $addr, $home, $work, $count) = split /:/;


Well, that avoids the unneeded array @itemsbut now we have four scalar variables that we didn't really need. For this situation, some people used to make up a number of dummy variable names, like $dummy_1, that showed that they really didn't care about that element from the split. But Larry thought that that was too much trouble, so he added a special use of undef. If an item in a list being assigned to is undef, that means simply to ignore the corresponding element of the source list:

my(undef, $card_num, undef, undef, undef, $count) = split /:/;


Is this any better? Well, it has the advantage that there aren't any unneeded variables. But it has the disadvantage that you have to count undefs to tell which element is $count. And this becomes quite unwieldy if there are more elements in the list. For example, some people who wanted just the mtime value from stat were writing code like this:

my(undef, undef, undef, undef, undef, undef, undef,
  undef, undef, $mtime) = stat $some_file;


If you use the wrong number of undefs, you'll get the atime or ctime by mistake, and that's a tough one to debug. There's a better way: Perl can index into a list as if it were an array. This is a list slice. Here, since the mtime is item 9 in the list returned by stat,[dagger] we can get it with a subscript:

    [dagger] It's the tenth item, but the index number is 9, since the first item is at index 0. This is the same kind of zero-based indexing that we've used already with arrays.

my $mtime = (stat $some_file)[9];


Those parentheses are required around the list of items (in this case, the return value from stat). If you wrote it like this, it wouldn't work:

my $mtime = stat($some_file)[9];  # Syntax error!


A list slice has to have a subscript expression in square brackets after a list in parentheses. The parentheses holding the arguments to a function call don't count.

Going back to the Bedrock Library, the list we're working with is the return value from split. We can now use a slice to pull out item 1 and item 5 with subscripts:

my $card_num = (split /:/)[1];
my $count = (split /:/)[5];


Using a scalar-context slice like this (pulling just a single element from the list) isn't bad, but it would be more efficient and simpler if we didn't have to do the split twice. So let's not do it twice; let's get both values at once by using a list slice in list context:

my($card_num, $count) = (split /:/)[1, 5];


The indices pull out element 1 and element 5 from the list, returning those as a two-element list. When that's assigned to the two my variables, we get exactly what we wanted. We do the slice just once, and we set the two variables with a simple notation.

A slice is often the simplest way to pull a few items from a list. Here, we can pull just the first and last items from a list, using the fact that index -1 means the last element:[*]

    [*] Sorting a list merely to find the extreme elements isn't likely to be the most efficient way. But Perl's sort is fast enough that this is generally acceptable, as long as the list doesn't have more than a few hundred elements.

my($first, $last) = (sort @names)[0, -1];


The subscripts of a slice may be in any order and may even repeat values. This example pulls 5 items from a list of 10:

my @names = qw{ zero one two three four five six seven eight nine };
my @numbers = ( @names )[ 9, 0, 2, 1, 0 ];
print "Bedrock @numbers\n";  # says Bedrock nine zero two one zero

			2.17.5.1 Array Slice

That previous example could be made even simpler. When slicing elements from an array (as opposed to a list), the parentheses aren't needed. So we could have done the slice like this:

my @numbers = @names[ 9, 0, 2, 1, 0 ];


This isn't merely a matter of omitting the parentheses; this is actually a different notation for accessing array elements: an array slice. Earlier (in Chapter 3), we said that the at sign on @names meant "all of the elements." Actually, in a linguistic sense, it's more like a plural marker, much like the letter "s" in words like "cats" and "dogs." In Perl, the dollar sign means there's just one of something, but the at sign means there's a list of items.

A slice is always a list, so the array slice notation uses an at sign to indicate that. When you see something like @names[ ... ] in a Perl program, you'll need to do just as Perl does and look at the at sign at the beginning as well as the square brackets at the end. The square brackets mean that you're indexing into an array, and the at sign means that you're getting a whole list[*] of elements, not just a single one (which is what the dollar sign would mean). See Figure 17-1.

    [*] Of course, when we say "a whole list," that doesn't necessarily mean more elements than onethe list could be empty, after all.

Figure 17-1. Array slices versus single elements


The punctuation mark at the front of the variable reference (either the dollar sign or at sign) determines the context of the subscript expression. If there's a dollar sign in front, the subscript expression is evaluated in a scalar context to get an index. But if there's an at sign in front, the subscript expression is evaluated in a list context to get a list of indices.

So we see that @names[ 2, 5 ] means the same list as ($names[2], $names[5]) does. If you want that list of values, you can simply use the array slice notation. Any place you might want to write the list, you can instead use the simpler array slice.

But the slice can be used in one place where the list can'ta slice may be interpolated directly into a string:

my @names = qw{ zero one two three four five six seven eight nine };
print "Bedrock @names[ 9, 0, 2, 1, 0 ]\n";


If we were to interpolate @names, that would give all of the items from the array, separated by spaces. If instead we interpolate @names[ 9, 0, 2, 1, 0 ], that gives just those items from the array, separated by spaces.[dagger] Let's go back to the Bedrock Library for a moment. Maybe now our program is updating Mr. Slate's address and phone number in the patron file because he just moved into a large new place in the Hollyrock Hills. If we've got a list of information about him in @items, we could do something like this to update just those two elements of the array:

    [dagger] More accurately, the items of the list are separated by the contents of Perl's $" variable, whose default is a space. This should not normally be changed. When interpolating a list of values, Perl internally does join $", @list, where @list stands in for the list expression.

my $new_home_phone = "555-6099";
my $new_address = "99380 Red Rock West";
@items[2, 3] = ($new_address, $new_home_phone);


Once again, the array slice makes a more compact notation for a list of elements. In this case, that last line is the same as an assignment to ($items[2], $items[3]), but more compact and efficient.

			2.17.5.2 Hash Slice

In a way exactly analogous to an array slice, we can also slice some elements from a hash in a hash slice. Remember when three of our characters went bowling, and we kept their bowling scores in the %score hash? We could pull those scores with a list of hash elements or with a slice. These two techniques are equivalent (although the second is more concise and efficient):

my @three_scores = ($score{"barney"}, $score{"fred"}, $score{"dino"});

my @three_scores = @score{ qw/ barney fred dino/ };


A slice is always a list, so the hash slice notation uses an at sign to indicate that.[*] When you see something like @score{ ... } in a Perl program, you'll need to do just as Perl does and look at the at sign at the beginning as well as the curly braces at the end. The curly braces mean that you're indexing into a hash; the at sign means that you're getting a whole list of elements, not just a single one (which is what the dollar sign would mean). See Figure 17-2.

    [*] If it sounds as if we're repeating ourselves here, it's because we want to emphasize that hash slices are analogous to array slices. If it sounds as if we're not repeating ourselves here, it's because we want to emphasize that hash slices are analogous to array slices.

Figure 17-2. Hash slices versus single elements


As you saw with the array slice, the punctuation mark at the front of the variable reference (either the dollar sign or at sign) determines the context of the subscript expression. If there's a dollar sign in front, the subscript expression is evaluated in a scalar context to get a single key.[*] But if there's an at sign in front, the subscript expression is evaluated in a list context to get a list of keys.

    [*] There's an exception you're not likely to run across, since it isn't used much in modern Perl code. See the entry for $; in the perlvar manpage.

It's normal at this point to wonder why there's no percent sign (%) here, when we're talking about a hash. That's the marker that means there's a whole hash; a hash slice (like any other slice) is always a list, not a hash.[dagger] In Perl, the dollar sign means there's just one of something, but the at sign means there's a list of items, and the percent sign means there's an entire hash.

    [dagger] A hash slice is a slice (not a hash) in the same way that a house fire is a fire (not a house), while a fire house is a house (not a fire). More or less.

As you saw with array slices, a hash slice may be used instead of the corresponding list of elements from the hash, anywhere within Perl. So we can set our friends' bowling scores in the hash (without disturbing any other elements in the hash) like this:

my @players = qw/ barney fred dino /;
my @bowling_scores = (195, 205, 30);
@score{ @players } = @bowling_scores;


That last line does the same thing as if we had assigned to the three-element list ($score{"barney"}, $score{"fred"}, $score{"dino"}).

A hash slice may be interpolated, too. Here, we print out the scores for our favorite bowlers:

print "Tonight's players were: @players\n";
print "Their scores were: @score{@players}\n";

		2.17.6 Exercise
See Appendix A for an answer to the following exercise:

   a.  [30] Make a program that reads a list of strings from a file, one string per line, and then lets the user interactively enter patterns that may match some of the strings. For each pattern, the program should tell how many strings from the file matched, then which ones those were. Don't reread the file for each new pattern; keep the strings in memory. The filename may be hardcoded in the file. If a pattern is invalid (for example, if it has unmatched parentheses), the program should simply report that error and let the user continue trying patterns. When the user enters a blank line instead of a pattern, the program should quit. (If you need a file full of interesting strings to try matching, try the file sample_text in the files you've surely downloaded by now from the O'Reilly web site; see the Preface.)
	2.18 Exercise Answers
	
	2.19 Beyond the Llama


3. Intermediate Perl, 1st Edition

4. Mastering Perl

5. Command line flags, parameters processing

	5.1 getopts

		5.1.1 Perl Getopt and GetOptions
Perl Getopt and GetOptions

Two Perl modules (Getopt and Getoptions::Long) work to extract program flags
and arguments much like Getopt and Getopts do for shell programming. The Perl
modules, especially GetOptions::Long, are much more powerful and flexible.

Simple scripts show the power of these:
#!/usr/bin/perl
# script is "./g"
http://aplawrence.com/Unix/perlgetopts.html (1 of 13)10/4/2005 3:14:04 PM
Perl Getopt and GetOptions
use Getopt::Std;
%options=();
getopts("od:fF",\%options);
# like the shell getopt, "d:" means d takes
an argument
print "-o $options{o}\n" if defined $options
{o};
print "-d $options{d}\n" if defined $options
{d};
print "-f $options{f}\n" if defined $options
{f};
print "-F $options{F}\n" if defined $options
{F};
print "Unprocessed by Getopt::Std:\n" if
$ARGV[0];
foreach (@ARGV) {
print "$_\n";
}

Trying it out:
bash-2.05a$ ./g -f -d F -o -F
-o 1
-d F
-f 1
-F 1
bash-2.05a$ ./g -o -d foo
-o 1
-d foo
bash-2.05a$ ./g -o rough -d foo
-o 1
Unprocessed by Getopt::Std:
rough
http://aplawrence.com/Unix/perlgetopts.html (2 of 13)10/4/2005 3:14:04 PM
Perl Getopt and GetOptions
-d
foo
Processing of arguments stops when it saw "rough".
If you leave off a required argument, it just gets swallowed:
bash-2.05a$ ./g -d
bash-2.05a$ ./g -d foo
-d foo
But it's easily confused:
bash-2.05a$ ./g -d -o -f
-d -o
-f 1
It thinks that -o is the argument of -d.
bash-2.05a$ ./g -k
Unknown option: k
Like the simple shell "getopt", this complains when it gets an option that it doesn't
know about. Unlike the shell "getopt", prefacing the option string with a ":" doesn't
help. Instead, use "getopt":
#!/usr/bin/perl
# we'll call this one ./gg
use Getopt::Std;
%options=();
getopt("odfF",\%options);
print "-o $options{o}\n" if defined $options
{o};
print "-d $options{d}\n" if defined $options
{d};
print "-f $options{f}\n" if defined $options
http://aplawrence.com/Unix/perlgetopts.html (3 of 13)10/4/2005 3:14:04 PM
Perl Getopt and GetOptions
{f};
print "-F $options{F}\n" if defined $options
{F};
Note the lack of any ":". This module doesn't care which flags take values and
which don't: it assumes ALL of them take arguments.
The "getopt" isn't very bright:
bash-2.05a$ ./gg -f -o -d foo
-d foo
-f -o
bash-2.05a$ ./g -f -o -d foo
-o 1
-d foo
-f 1
But it doesn't complain:
bash-2.05a$ ./gg -l
bash-2.05a$ ./g -l
Unknown option: l
Unlike their shell cousins, neither of these have any issues with arguments
containing spaces:
bash-2.05a$ ./g -o -d "foo bar"
-o 1
-d foo bar
bash-2.05a$ ./gg -o "foo" -d "foo bar"
-o foo
-d foo bar
Far better than either of these is the Getopt::Long module. Here's a script to play
with it:
http://aplawrence.com/Unix/perlgetopts.html (4 of 13)10/4/2005 3:14:04 PM
Perl Getopt and GetOptions
#!/usr/bin/perl
use Getopt::Long;
GetOptions("o"=>\$oflag,
"verbose!"=>\
$verboseornoverbose,
"string=s"=>\$stringmandatory,
"optional:s",\$optionalstring,
"int=i"=> \$mandatoryinteger,
"optint:i"=> \$optionalinteger,
"float=f"=> \$mandatoryfloat,
"optfloat:f"=> \$optionalfloat);
print "oflag $oflag\n" if $oflag;
print "verboseornoverbose
$verboseornoverbose\n" if
$verboseornoverbose;
print "stringmandatory $stringmandatory\n"
if $stringmandatory;
print "optionalstring $optionalstring\n" if
$optionalstring;
print "mandatoryinteger $mandatoryinteger
\n" if $mandatoryinteger;
print "optionalinteger $optionalinteger\n"
if $optionalinteger;
print "mandatoryfloat $mandatoryfloat\n" if
$mandatoryfloat;
print "optionalfloat $optionalfloat\n" if
$optionalfloat;
print "Unprocessed by Getopt::Long\n" if
$ARGV[0];
foreach (@ARGV) {
print "$_\n";
}
http://aplawrence.com/Unix/perlgetopts.html (5 of 13)10/4/2005 3:14:04 PM
Perl Getopt and GetOptions
The hash array that this uses holds the argument name and the type of argument;
what that points to is where it will store values for options processed.
Playing with it:
#
# doesn't care if it's -o or --o
bash-2.05a$ ./ggg -o
oflag 1
bash-2.05a$ ./ggg --o
oflag 1
#
# abbreviating is ok too
bash-2.05a$ ./ggg -verbose
verboseornoverbose 1
bash-2.05a$ ./ggg -verb
verboseornoverbose 1
#
# but not this
bash-2.05a$ ./ggg -verbosity
Unknown option: verbosity
#
# $verboseonoverbose will be 0 here
bash-2.05a$ ./ggg -noverb
#
# strings
bash-2.05a$ ./gggg -s
Option string requires an argument
bash-2.05a$ ./ggg -s=foo
stringmandatory foo
bash-2.05a$ ./ggg -optional
bash-2.05a$ ./ggg -optional=foo
optionalstring foo
http://aplawrence.com/Unix/perlgetopts.html (6 of 13)10/4/2005 3:14:04 PM
Perl Getopt and GetOptions
#
# ambiguity
bash-2.05a$ ./ggg --opt
Option opt is ambiguous (optfloat, optint,
optional)
#
# floats and integers
bash-2.05a$ ./ggg --optfloat=75.6
optionalfloat 75.6
bash-2.05a$ ./ggg --optint=75.6
Value "75.6" invalid for option optint
(number expected)
bash-2.05a$ ./ggg --optint=75
optionalinteger 75
bash-2.05a$ ./ggg -f --optfloat=75.6 -o
Value "--optfloat=75.6" invalid for option
float (real number expected)
oflag 1
# once it runs out of options, it leaves
@ARGV alone:
bash-2.05a$ ./ggg -o foo bar
oflag 1
Unprocessed by Getopt::Long
foo
bar
GetOpt::Long is obviously much more flexible. The hash you pass is a little clumsy,
but if you think about it, there's no better way to do it. In some places, you might
use something like this:
#!/usr/bin/perl
use Getopt::Long;
http://aplawrence.com/Unix/perlgetopts.html (7 of 13)10/4/2005 3:14:04 PM
Perl Getopt and GetOptions
my %moo=();
GetOptions("o"=>\$moo{$oflag},
"verbose!"=>\$moo{verbose},
"string=s"=>\$moo
{stringmandatory},
"optional:s"=>\$moo
{optionalstring},
"int=i"=> \$moo
{mandatoryinteger},
"optint:i"=> \$moo
{optionalinteger},
"float=f"=> \$moo
{mandatoryfloat},
"optfloat:f"=> \$moo
{optionalfloat});
foreach (keys %moo) {
print "$_ = $moo{$_}\n";
}
print "Unprocessed by Getopt::Long\n" if
$ARGV[0];
foreach (@ARGV) {
print "$_\n";
}
but if you have so many flags that you are thinking that is helpful, your program is
surely trying much too hard to be all things to all people.
Comments /Unix/perlgetopts.html
(older comments)
http://aplawrence.com/Unix/perlgetopts.html (8 of 13)10/4/2005 3:14:04 PM
Perl Getopt and GetOptions
PerlGetOpts :
" but if you have so many flags that you are
thinking that is helpful, your program is
surely trying much too hard to be all things
to all people."
Isn't that the philosophy behind Windows
development? <Grin>
After reading through all this, I said to
myself, "One of these days I have to become
an expert in Perl." <Smile>
I have to admit that I'm much more likely to
turn to a shell script or C to do a lot of
the things that Perl would probably be
better suited to doing. In many cases, a
Perl program would certainly involve less
work than writing and compiling a C program,
and would undoubtably be more elegant and
efficient than a typical shell script.
However, as with using greenbar paper, old
habits are hard to shake. I grok C and the
shell, whereas I'm a rank amateur when it
comes to Perl. One of these days...
optionalstring = test
Program
**********************************************
#!/usr/bin/perl -w
http://aplawrence.com/Unix/perlgetopts.html (11 of 13)10/4/2005 3:14:04 PM
Perl Getopt and GetOptions
# Option test dm
use strict;
use Getopt::Long;
my moo=();
my $oflag;
GetOptions("o"=>\$moo{$oflag},
"verbose!"=>\$moo{verbose},
"string=s"=>\$moo{stringmandatory},
"optional:s"=>\$moo{optionalstring},
"int=i"=> \$moo{mandatoryinteger},
"optint:i"=> \$moo{optionalinteger},
"float=f"=> \$moo{mandatoryfloat},
"optfloat:f"=> \$moo{optionalfloat});
foreach (keys moo) {
if ( defined $moo{$_} && exists $moo{$_}) {
print "$_ = $moo{$_}\n";
}
}
print "Unprocessed by Getopt::Long\n" if $ARGV[0];
foreach (@ARGV) {
print "$_\n";
}
Wed May 4 10:28:54 2005 TonyLawrence ( key /jwW0kwdn)
Don't use -w or define your variables. Simple as that.
Mon Sep 12 18:51:10 2005 anonymous ( key EXEDABwU8)
-optional is the same as -o -p -t -i -o -n -a -l. You should use --optional.
Add your comments
Printer Friendly Version
http://aplawrence.com/Unix/perlgetopts.html (12 of 13)10/4/2005 3:14:04 PM
Perl Getopt and GetOptions
Views for this page
Today This Week This Month This Year Overall
77 160 184 19,552 50,069
/Unix/perlgetopts.html copyright September 2003 Tony Lawrence All Rights
Reserved
Site map | Disclaimer
/Unix/perlgetopts.html copyright and reprint notice
Except where otherwise noted, this content is
licensed under a Creative Commons License.
Publish yourarticles, comments, book reviews or opinions here!
Related Articles
Have you tried Searching this site?
Please read this disclaimer
Unix/Linux/Mac OS X support by phone, email or on-site: Support Rates
This is a Unix/Linux resource website. It contains technical articles about Unix,
Linux and general computing related subjects, opinion, news, help files, how-to's,
tutorials and more. We appreciate comments and article submissions.
Printer Friendly Version
http://aplawrence.com/Unix/perlgetopts.html (13 of 13)10/4/2005 3:14:04 PM

		5.1.2 Process options passed to a program using getopts().

Make a global hash to store the options. Use the standard Getopt module. Make a string of one-character options. A character preceeding a colon takes an argument. The getopts function takes two arguments: a string of options, and a hash reference. For each command line option (aka switch) found, getopts sets $opt{x} (where x is the switch name) to the value of the argument, or 1 if no argument was provided.

Example

    #
    # Globals
    #
    use vars qw/ %opt /;
    #
    # Command line options processing
    #
    sub init()
    {
        use Getopt::Std;
        my $opt_string = 'hvdf:';
        getopts( "$opt_string", \%opt ) or usage();
        usage() if $opt{h};
    }
    #
    # Message about this program and how to use it
    #
    sub usage()
    {
        print STDERR << "EOF";
    This program does...
    usage: $0 [-hvd] [-f file]
     -h        : this (help) message
     -v        : verbose output
     -d        : print debugging messages to stderr
     -f file   : file containing usersnames, one per line
    example: $0 -v -d -f file
    EOF
        exit;
    }
    init();
    print STDERR "Verbose mode ON.\n" if $opt{v};
    print STDERR "Debugging mode ON.\n" if $opt{d};

		5.1.3
	5.2

6.  cookbook Recipes

	6.1  sort

		6.1.1  "sort" a hash 

			6.1.1.1  "sort" a hash by key 
Question: How do I sort a Perl hash by the hash key?

Answer: Sorting the output of a Perl hash by the hash key is fairly straightforward. It involves two Perl functions, keys and sort, along with the good old foreach statement.

This is easiest to demonstrate by example. Suppose we have a class of five students. Their names are kim, al, rocky, chrisy, and jane.

Creating a Perl hash
Suppose these students just took a test, and we stored their grades in a hash named grades (note that hashes were called associative arrays prior to the release of Perl 5).

The hash definition might look like this:

%grades = (
	kim       => 96,
	al        => 63,
	rocky     => 87,
	chrisy    => 96,
	jane      => 79,
);
If you're familiar with a Perl hash, you know that the student names are the hash keys, and the test scores are the hash values.

Printing a Perl hash
If you want to print out the student names and scores, sorted in alphabetical order by student name, you can use this following Perl code snippet:

print "\n\tGRADES SORTED BY STUDENT NAME:\n";
foreach $key (sort (keys(%grades))) {
   print "\t\t$key \t\t$grades{$key}\n";
}
The Perl keys function returns a normal array of the keys of the hash. Our sample hash is named grades, so the keys function returns the names of the students. One attribute of the keys function, however, is that the keys are returned in what appears to be a random order. Therefore, you need to use sort to sort the keys in alphabetical order to get the desired printout.

			6.1.1.2  "sort" a hash by value 
Sorting a Perl hash by the hash value
Sorting a Perl hash by the hash value is a bit more difficult than sorting the hash by the key, but it's not too bad. It just requires a small "helper" function. This is easiest to demonstrate by example.

Suppose we have a class of five students. Rather than give them names, we'll call them student1, student2, etc. Suppose these students just took a test, and we stored their grades in a hash (called associative arrays prior to the release of Perl 5) named grades.

The hash definition might look like this:

%grades = (
	student1 => 90,
	student2 => 75,
	student3 => 96,
	student4 => 55,
	student5 => 76,
);
If you're familiar with hashes, you know that the student names are the keys, and the test scores are the hash values.

The key to sorting a hash by value is the function you create to help the sort command perform it's function. Following the format defined by the creators of Perl, you create a function I call a helper function that tells Perl how to sort the list it's about to receive. In the case of the program you're about to see, I've created two helper functions named hashValueDescendingNum (sort by hash value in descending numeric order) and hashValueAscendingNum (sort by hash value in ascending numeric order).


 
A complete Perl hash sort sample program
Here's a complete Perl hash sort sample program that prints the contents of the grades hash, sorted numerically by the hash value:

#!/usr/bin/perl -w

#----------------------------------------------------------------------#
#  printHashByValue.pl                                                 #
#----------------------------------------------------------------------#

#----------------------------------------------------------------------#
#  FUNCTION:  hashValueAscendingNum                                    #
#                                                                      #
#  PURPOSE:   Help sort a hash by the hash 'value', not the 'key'.     #
#             Values are returned in ascending numeric order (lowest   #
#             to highest).                                             #
#----------------------------------------------------------------------#

sub hashValueAscendingNum {
   $grades{$a} <=> $grades{$b};
}


#----------------------------------------------------------------------#
#  FUNCTION:  hashValueDescendingNum                                   #
#                                                                      #
#  PURPOSE:   Help sort a hash by the hash 'value', not the 'key'.     #
#             Values are returned in descending numeric order          #
#             (highest to lowest).                                     #
#----------------------------------------------------------------------#

sub hashValueDescendingNum {
   $grades{$b} <=> $grades{$a};
}


%grades = (
	student1 => 90,
	student2 => 75,
	student3 => 96,
	student4 => 55,
	student5 => 76,
);

print "\nGRADES IN ASCENDING NUMERIC ORDER:\n";
foreach $key (sort hashValueAscendingNum (keys(%grades))) {
   print "\t$grades{$key} \t\t $key\n";
}

print "\nGRADES IN DESCENDING NUMERIC ORDER:\n";
foreach $key (sort hashValueDescendingNum (keys(%grades))) {
   print "\t$grades{$key} \t\t $key\n";
}
Although this "Perl hash sort by value" program is fairly lengthy, you can see at the bottom of the code where the student grades are printed in ascending and descending numeric value.
			6.1.1.3

		6.1.2

	6.2 Perl Cookbook, 2nd Edition

		6.2.1 Chapter 1, Strings

			6.2.1.1 substr

Problem

You want to access or modify just a portion of a string, not the whole thing. For instance, you’ve read a fixed-width record and want to extract individual fields.
Solution

The substr function lets you read from and write to specific portions of the string.

$value = substr($string, $offset, $count);
$value = substr($string, $offset);

substr($string, $offset, $count) = $newstring;
substr($string, $offset, $count, $newstring);  # same as previous
substr($string, $offset)         = $newtail;

The unpack function gives only read access, but is faster when you have many substrings to extract.

# get a 5-byte string, skip 3 bytes,
# then grab two 8-byte strings, then the rest;
# (NB: only works on ASCII data, not Unicode)
($leading, $s1, $s2, $trailing) =
    unpack("A5 x3 A8 A8 A*", $data);

# split at 5-byte boundaries
@fivers = unpack("A5" x (length($string)/5), $string);

# chop string into individual single-byte characters
@chars  = unpack("A1" x length($string), $string);

Discussion

Strings are a basic data type; they aren’t arrays of a basic data type. Instead of using array subscripting to access individual characters as you sometimes do in other programming languages, in Perl you use functions like unpack or substr to access individual characters or a portion of the string.

The offset argument to substr indicates the start of the substring you’re interested in, counting from the front if positive and from the end if negative. If the offset is 0, the substring starts at the beginning. The count argument is the length of the substring.

$string = "This is what you have";
#         +012345678901234567890  Indexing forwards  (left to right)
#          109876543210987654321- Indexing backwards (right to left)
#           note that 0 means 10 or 20, etc. above

$first  = substr($string, 0, 1);  # "T"
$start  = substr($string, 5, 2);  # "is"
$rest   = substr($string, 13);    # "you have"
$last   = substr($string, -1);    # "e"
$end    = substr($string, -4);    # "have"
$piece  = substr($string, -8, 3); # "you"

You can do more than just look at parts of the string with substr; you can actually change them. That’s because substr is a particularly odd kind of function—an lvaluable one, that is, a function whose return value may be itself assigned a value. (For the record, the others are vec, pos, and keys. If you squint, local, my, and our can also be viewed as lvaluable functions.)

$string = "This is what you have";
print $string;
This is what you have
substr($string, 5, 2) = "wasn't"; # change "is" to "wasn't"
This wasn't what you have
substr($string, -12)  = "ondrous";# "This wasn't wondrous"
This wasn't wondrous
substr($string, 0, 1) = "";       # delete first character
his wasn't wondrous
substr($string, -10)  = "";       # delete last 10 characters
his wasn

Use the =~ operator and the s///, m//, or tr/// operators in conjunction with substr to make them affect only that portion of the string.

# you can test substrings with =~
if (substr($string, -10) =~ /pattern/) {
            print "Pattern matches in last 10 characters\n";
}

# substitute "at" for "is", restricted to first five characters
substr($string, 0, 5) =~ s/is/at/g;

You can even swap values by using several substrs on each side of an assignment:

# exchange the first and last letters in a string
$a = "make a hat";
(substr($a,0,1), substr($a,-1)) = 
(substr($a,-1),  substr($a,0,1));
print $a;
take a ham

Although unpack is not lvaluable, it is considerably faster than substr when you extract numerous values all at once. Specify a format describing the layout of the record to unpack. For positioning, use lowercase "x" with a count to skip forward some number of bytes, an uppercase "X" with a count to skip backward some number of bytes, and an "@" to skip to an absolute byte offset within the record. (If the data contains Unicode strings, be careful with those three: they’re strictly byte-oriented, and moving around by bytes within multibyte data is perilous at best.)

# extract column with unpack
$a = "To be or not to be";
$b = unpack("x6 A6", $a);  # skip 6, grab 6
print $b;
or not

($b, $c) = unpack("x6 A2 X5 A2", $a); # forward 6, grab 2; backward 5, grab 2
print "$b\n$c\n";
or
               be

Sometimes you prefer to think of your data as being cut up at specific columns. For example, you might want to place cuts right before positions 8, 14, 20, 26, and 30. Those are the column numbers where each field begins. Although you could calculate that the proper unpack format is "A7 A6 A6 A6 A4 A*“, this is too much mental strain for the virtuously lazy Perl programmer. Let Perl figure it out for you. Use the cut2fmt function:

sub cut2fmt {
    my(@positions) = @_;
    my $template   = '';
    my $lastpos    = 1;
    foreach $place (@positions) {
        $template .= "A" . ($place - $lastpos) . " ";
        $lastpos   = $place;
    }
    $template .= "A*";
    return $template;
}

$fmt = cut2fmt(8, 14, 20, 26, 30);
print "$fmt\n";
A7 A6 A6 A6 A4 A*

The powerful unpack function goes far beyond mere text processing. It’s the gateway between text and binary data.

In this recipe, we’ve assumed that all character data is 7- or 8-bit data so that pack’s byte operations work as expected.
See Also

The pack, unpack, and substr functions in perlfunc(1) and in Chapter 29 of Programming Perl; use of the cut2fmt subroutine in Recipe 1.24; the binary use of unpack in Recipe 8.24

Accessing Substrings

-> My example
r /Users/yizaq/Desktop/Work/scripts/perl/learn/cookbook/substr.pl
#!/usr/bin/perl 
#===============================================================================
#
#         FILE: substr.pl
#
#        USAGE: ./substr.pl  
#
#  DESCRIPTION: 
#
#      OPTIONS: ---
# REQUIREMENTS: ---
#         BUGS: ---
#        NOTES: ---
#       AUTHOR: Yosi Izaq
# ORGANIZATION: 
#      VERSION: 1.0
#      CREATED: 04/06/15 12:25:56
#     REVISION: ---
#===============================================================================

use strict;
use warnings;

my $str = "This is a test string";

print "Extract substring\n";
print "String prefix ", substr($str, 0, 8), "\n";
print "String suffix ", substr($str, 8, length($str) -1), "\n";

print "Change substring\n";
substr($str, 0, 4) = "THIS";
print "Modified string ", $str, "\n";

print "Change substring 2nd time\n";
substr($str, 0, 4,  "thhiis") ;
print "Modified string ", $str, "\n";

print "Change substring 3rd time\n";
substr($str,  -6) =  "str" ;
print "Modified string ", $str, "\n";

		6.2.2 Establishing a Default Value
Problem

You would like to supply a default value to a scalar variable, but only if it doesn’t already have one. It often happens that you want a hardcoded default value for a variable that can be overridden from the command line or through an environment variable.
Solution

Use the || or ||= operator, which work on both strings and numbers:

# use $b if $b is true, else $c
$a = $b || $c;

# set $x to $y unless $x is already true
$x ||= $y;

If 0, "0“, and “” are valid values for your variables, use defined instead:

# use $b if $b is defined, else $c
$a = defined($b) ? $b : $c;

# the "new" defined-or operator from future perl
use v5.9;
$a = $b // $c;

Discussion

The big difference between the two techniques (defined and ||) is what they test: definedness versus truth. Three defined values are still false in the world of Perl: 0, "0“, and “”. If your variable already held one of those, and you wanted to keep that value, a || wouldn’t work. You’d have to use the more elaborate three-way test with defined instead. It’s often convenient to arrange for your program to care about only true or false values, not defined or undefined ones.

Rather than being restricted in its return values to a mere 1 or 0 as in most other languages, Perl’s || operator has a much more interesting property: it returns its first operand (the lefthand side) if that operand is true; otherwise it returns its second operand. The && operator also returns the last evaluated expression, but is less often used for this property. These operators don’t care whether their operands are strings, numbers, or references—any scalar will do. They just return the first one that makes the whole expression true or false. This doesn’t affect the Boolean sense of the return value, but it does make the operators’ return values more useful.

This property lets you provide a default value to a variable, function, or longer expression in case the first part doesn’t pan out. Here’s an example of ||, which would set $foo to be the contents of either $bar or, if $bar were false, "DEFAULT VALUE“:

$foo = $bar || "DEFAULT VALUE";

Here’s another example, which sets $dir to be either the first argument to the program or "/tmp" if no argument were given.

$dir = shift(@ARGV) || "/tmp";

We can do this without altering @ARGV:

$dir = $ARGV[0] || "/tmp";

If 0 is a valid value for $ARGV[0], we can’t use ||, because it evaluates as false even though it’s a value we want to accept. We must resort to Perl’s only ternary operator, the ?: (“hook colon,” or just “hook”):

$dir = defined($ARGV[0]) ? shift(@ARGV) : "/tmp";

We can also write this as follows, although with slightly different semantics:

$dir = @ARGV ? $ARGV[0] : "/tmp";

This checks the number of elements in @ARGV, because the first operand (here, @ARGV) is evaluated in scalar context. It’s only false when there are 0 elements, in which case we use "/tmp“. In all other cases (when the user gives an argument), we use the first argument.

The following line increments a value in %count, using as the key either $shell or, if $shell is false, "/bin/sh“.

$count{ $shell || "/bin/sh" }++;

You may chain several alternatives together as we have in the following example. The first expression that returns a true value will be used.

# find the user name on Unix systems
$user = $ENV{USER}
     || $ENV{LOGNAME}
     || getlogin( )
     || (getpwuid($<))[0]
     || "Unknown uid number $<";

The && operator works analogously: it returns its first operand if that operand is false; otherwise, it returns the second one. Because there aren’t as many interesting false values as there are true ones, this property isn’t used much. One use is demonstrated in Recipe 13.12 and Recipe 14.19.

The ||= assignment operator looks odd, but it works exactly like the other binary assignment operators. For nearly all of Perl’s binary operators, $VAR OP= VALUE means $VAR = $VAR OP VALUE; for example, $a += $b is the same as $a = $a + $b. So ||= is used to set a variable when that variable is itself still false. Since the || check is a simple Boolean one—testing for truth—it doesn’t care about undefined values, even when warnings are enabled.

Here’s an example of ||= that sets $starting_point to "Greenwich" unless it is already set. Again, we assume $starting_point won’t have the value 0 or "0“, or that if it does, it’s okay to change it.

$starting_point ||= "Greenwich";

You can’t use or in place of || in assignments, because or’s precedence is too low. $a = $b or $c is equivalent to ($a = $b) or $c. This will always assign $b to $a, which is not the behavior you want.

Don’t extend this curious use of || and ||= from scalars to arrays and hashes. It doesn’t work, because the operators put their left operand into scalar context. Instead, you must do something like this:

@a = @b unless @a;          # copy only if empty
@a = @b ? @b : @c;          # assign @b if nonempty, else @c

Perl is someday expected to support new operators: //, //=, and err. It may already do so by the time you read this text. These defined-or operators will work just like the logical-or operators, ||, except that they will test definedness, not mere truth. That will make the following pairs equivalent:

$a = defined($b) ? $b : $c;
$a = $b // $c;

$x = defined($x) ? $x : $y;
$x //= $y;

defined(read(FH, $buf, $count))  or  die "read failed: $!";
read(FH, $buf, $count)          err die "read failed: $!";

These three operators are already present in Perl release v5.9, which being an odd-numbered release, is an experimental version and not what you want in a production environment. It is expected to be in v5.10, which will be a stable release, and will most certainly be in Perl v6, whose release date has not yet been determined.
See Also

The || operator in perlop(1) and Chapter 3 of Programming Perl; the defined and exists functions in perlfunc(1) and Chapter 29 of Programming Perl

		6.2.3 Exchanging Values Without Using Temporary Variables
Problem

You want to exchange the values of two scalar variables, but don’t want to use a temporary variable.
Solution

Use list assignment to reorder the variables.

($VAR1, $VAR2) = ($VAR2, $VAR1);

Discussion

Most programming languages require an intermediate step when swapping two variables’ values:

$temp    = $a;
$a       = $b;
$b       = $temp;

Not so in Perl. It tracks both sides of the assignment, guaranteeing that you don’t accidentally clobber any of your values. This eliminates the temporary variable:

$a       = "alpha";
$b       = "omega";
($a, $b) = ($b, $a);        # the first shall be last -- and versa vice

You can even exchange more than two variables at once:

($alpha, $beta, $production) = qw(January March August);
# move beta       to alpha,
# move production to beta,
# move alpha      to production
($alpha, $beta, $production) = ($beta, $production, $alpha);

When this code finishes, $alpha, $beta, and $production have the values "March“, "August“, and "January“.
See Also

The section on “List value constructors” in perldata(1) and on “List Values and Arrays” in Chapter 2 of Programming Perl

		6.2.4 Converting Between Characters and Values
Problem

You want to print the number represented by a given character, or you want to print a character given a number.
Solution

Use ord to convert a character to a number, or use chr to convert a number to its corresponding character:

$num  = ord($char);
$char = chr($num);

The %c format used in printf and sprintf also converts a number to a character:

$char = sprintf("%c", $num);                # slower than chr($num)
printf("Number %d is character %c\n", $num, $num);
Number 101 is character e

A C* template used with pack and unpack can quickly convert many 8-bit bytes; similarly, use U* for Unicode characters.

@bytes = unpack("C*", $string);
$string = pack("C*", @bytes);

$unistr = pack("U4",0x24b6,0x24b7,0x24b8,0x24b9);
@unichars = unpack("U*", $unistr);

Discussion

Unlike low-level, typeless languages such as assembler, Perl doesn’t treat characters and numbers interchangeably; it treats strings and numbers interchangeably. That means you can’t just assign characters and numbers back and forth. Perl provides Pascal’s chr and ord to convert between a character and its corresponding ordinal value:

$value     = ord("e");    # now 101
$character = chr(101);    # now "e"

If you already have a character, it’s really represented as a string of length one, so just print it out directly using print or the %s format in printf and sprintf. The %c format forces printf or sprintf to convert a number into a character; it’s not used for printing a character that’s already in character format (that is, a string).

printf("Number %d is character %c\n", 101, 101);

The pack, unpack, chr, and ord functions are all faster than sprintf. Here are pack and unpack in action:

@ascii_character_numbers = unpack("C*", "sample");
print "@ascii_character_numbers\n";
115 97 109 112 108 101

$word = pack("C*", @ascii_character_numbers);
$word = pack("C*", 115, 97, 109, 112, 108, 101);   # same
print "$word\n";
sample

Here’s how to convert from HAL to IBM:

$hal = "HAL";
@byte = unpack("C*", $hal);
foreach $val (@byte) {
    $val++;                 # add one to each byte value
}
$ibm = pack("C*", @byte);
print "$ibm\n";             # prints "IBM"

On single-byte character data, such as plain old ASCII or any of the various ISO 8859 charsets, the ord function returns numbers from 0 to 255. These correspond to C’s unsigned char data type.

However, Perl understands more than that: it also has integrated support for Unicode, the universal character encoding. If you pass chr, sprintf "%c“, or pack "U*" numeric values greater than 255, the return result will be a Unicode string.

Here are similar operations with Unicode:

@unicode_points = unpack("U*", "fac\x{0327}ade");
print "@unicode_points\n";
102 97 99 807 97 100 101

$word = pack("U*", @unicode_points);
print "$word\n";
façade

If all you’re doing is printing out the characters’ values, you probably don’t even need to use unpack. Perl’s printf and sprintf functions understand a v modifier that works like this:

printf "%vd\n", "fac\x{0327}ade";
102.97.99.807.97.100.101

printf "%vx\n", "fac\x{0327}ade";
66.61.63.327.61.64.65

The numeric value of each character (that is, its “code point” in Unicode parlance) in the string is emitted with a dot separator.
See Also

The chr, ord, printf, sprintf, pack, and unpack functions in perlfunc(1) and Chapter 29 of Programming Perl

r /Users/yizaq/Desktop/Work/scripts/perl/learn/cookbook/str_conversions.pl
#!/usr/bin/perl  
#===============================================================================
#
#         FILE: str_conversions.pl
#
#        USAGE: ./str_conversions.pl  
#
#  DESCRIPTION: 
#
#      OPTIONS: ---
# REQUIREMENTS: ---
#         BUGS: ---
#        NOTES: ---
#       AUTHOR: Yosi Izaq
# ORGANIZATION: 
#      VERSION: 1.0
#      CREATED: 04/08/15 10:22:02
#     REVISION: ---
#===============================================================================

#use strict;
use warnings;

print "EstablishingY a Default Value...\n";
my $str ||= "Default Value";
print "Str value: $str\n";


print "Establishing a Default Value using defined...\n";
my $str1 = defined($str1)? $str1 :  "Default Value1" ;
print "Str value: $str1\n";

print "find the user name on Unix systems\n";
$user = $ENV{USER} || $ENV{LOGNAME} || getlogin( ) || (getpwuid($<))[0] || "Unknown uid number $<";
print "User $user\n";

print "EstablishingY a Default Value for arrays...\n";
@a = ( "a", "b", "c");
@b = @a unless @b ; #can also do @b = @b? @b: @a;
print "array b:  @b \n";

print "Exchanging Values Without Using Temporary Variables\n";
($str, $str1) = ($str1, $str);
print "Str values after swap: $str, $str1 \n";

print "Converting Between Characters and Values\n";
my $c = "a";
print "ASCII value of $c ", ord($c), " character from ASCII value: ", chr(ord($c)), "\n" ;

$i = 0;
for (a..z, A..Z,0..9) 
{
	$i++;  
	print "[$_ , ",ord($_),"] ";
	if ( ($i % 10 ) == 0 ) {print "\n"; $i=0;};
}
print "\n";


print "Unpack and pack...\n";
@int_val_arr = unpack("C*", "My name is yosi");
print  pack("C*", @int_val_arr ), " unpacked:  @int_val_arr \n";

		6.2.5 Using Named Unicode Characters
Problem

You want to use Unicode names for fancy characters in your code without worrying about their code points.
Solution

Place a use charnames at the top of your file, then freely insert "\N{ CHARSPEC}” escapes into your string literals.
Discussion

The use charnames pragma lets you use symbolic names for Unicode characters. These are compile-time constants that you access with the \N{ CHARSPEC} double-quoted string sequence. Several subpragmas are supported. The :full subpragma grants access to the full range of character names, but you have to write them out in full, exactly as they occur in the Unicode character database, including the loud, all-capitals notation. The :short subpragma gives convenient shortcuts. Any import without a colon tag is taken to be a script name, giving case-sensitive shortcuts for those scripts.

use charnames ':full';
print "\N{GREEK CAPITAL LETTER DELTA} is called delta.\n";

Δ is called delta

use charnames ':short';
print "\N{greek:Delta} is an upper-case delta.\n";

Δ is an upper-case delta

use charnames qw(cyrillic greek);
print "\N{Sigma} and \N{sigma} are Greek sigmas.\n";
print "\N{Be} and \N{be} are Cyrillic bes.\n";

Σ
               and
               σ
               are Greek sigmas
               Б 
               and 
               б 
               are Cyrillic bes

Two functions, charnames::viacode and charnames::vianame, can translate between numeric code points and the long names. The Unicode documents use the notation U+XXXX to indicate the Unicode character whose code point is XXXX, so we’ll use that here in our output.

use charnames qw(:full);
for $code (0xC4, 0x394) { 
    printf "Character U+%04X (%s) is named %s\n",
        $code, chr($code), charnames::viacode($code);
}

Character U+00C4 (Ä) is named LATIN CAPITAL LETTER A WITH DIAERESIS
               Character U+0394 (Δ) is named GREEK CAPITAL LETTER DELTA

use charnames qw(:full);
$name = "MUSIC SHARP SIGN";
$code = charnames::vianame($name);
printf "%s is character U+%04X (%s)\n",
    $name, $code, chr($code); 

MUSIC SHARP SIGN is character U+266F (#)

Here’s how to find the path to Perl’s copy of the Unicode character database:

% perl -MConfig -le 'print "$Config{privlib}/unicore/NamesList.txt"'
/usr/local/lib/perl5/5.8.1/unicore/NamesList.txt

Read this file to learn the character names available to you.
See Also

The charnames(3) manpage and Chapter 31 of Programming Perl; the Unicode Character Database at http://www.unicode.org/

-> Full list
http://perl5.git.perl.org/perl.git/blame?f=lib/unicore/NamesList.txt
-> My example 
r /Users/yizaq/Desktop/Work/scripts/perl/learn/cookbook/unicode.pl
#!/usr/bin/perl 
#===============================================================================
#
#         FILE: unicode.pl
#
#        USAGE: ./unicode.pl  
#
#  DESCRIPTION: :
#
#      OPTIONS: ---
# REQUIREMENTS: ---
#         BUGS: ---
#        NOTES: ---
#       AUTHOR: Yosi Izaq
# ORGANIZATION: 
#      VERSION: 1.0
#      CREATED: 04/08/15 15:28:18
#     REVISION: ---
#===============================================================================

use strict;
use warnings;
use charnames ':full';

print "\N{HEBREW LETTER ALEF} \n";
print "\N{HEBREW LETTER YOD}\N{HEBREW LETTER VAV}\N{HEBREW LETTER SAMEKH}\N{HEBREW LETTER YOD}\n";

		6.2.6 Reversing a String by Word or Character
Problem

You want to reverse the words or characters of a string.
Solution

Use the reverse function in scalar context for flipping characters:

$revchars = reverse($string);

To flip words, use reverse in list context with split and join:

$revwords = join(" ", reverse split(" ", $string));

Discussion

The reverse function is two different functions in one. Called in scalar context, it joins together its arguments and returns that string in reverse order. Called in list context, it returns its arguments in the opposite order. When using reverse for its character-flipping behavior, use scalar to force scalar context unless it’s entirely obvious.

$gnirts   = reverse($string);       # reverse letters in $string

@sdrow    = reverse(@words);        # reverse elements in @words

$confused = reverse(@words);        # reverse letters in join("", @words)

Here’s an example of reversing words in a string. Using a single space, " “, as the pattern to split is a special case. It causes split to use contiguous whitespace as the separator and also discard leading null fields, just like awk. Normally, split discards only trailing null fields.

# reverse word order
$string = 'Yoda said, "can you see this?"';
@allwords    = split(" ", $string);
$revwords    = join(" ", reverse @allwords);
print $revwords, "\n";
this?" see you "can said, Yoda

We could remove the temporary array @allwords and do it on one line:

$revwords = join(" ", reverse split(" ", $string));

Multiple whitespace in $string becomes a single space in $revwords. If you want to preserve whitespace, use this:

$revwords = join("", reverse split(/(\s+)/, $string));

One use of reverse is to test whether a word is a palindrome (a word that reads the same backward or forward):

$word = "reviver";
$is_palindrome = ($word eq reverse($word));

We can turn this into a one-liner that finds big palindromes in /usr/dict/words:

% perl -nle 'print if $_ eq reverse && length > 5' /usr/dict/words
deedeed

-> My example , find palindromes 
[yizaq@YIZAQ-M-D1BW:Wed Apr 08:~/Desktop/Work/scripts/perl/learn/cookbook:]$ perl -lne 'print if $_ eq reverse  && length > 3' /usr/share/dict/words 
acca
adda
affa
ajaja
alala
alula
amma
anana
anna
arara
atta
boob
civic
deed
deedeed
degged
elle
hallah
immi
kakkak
kayak
keek
kelek
lemel
level
maam
madam
mesem
minim
murdrum
noon
otto
peep
poop
radar
redder
refer
repaper
retter
rever
reviver
rotator
rotor
siris
sooloos
tebbet
teet
tenet
terret
toot
ululu
yaray

-> r /Users/yizaq/Desktop/Work/scripts/perl/learn/cookbook/reverse.pl
#!/usr/bin/perl 
#===============================================================================
#
#         FILE: reverse.pl
#
#        USAGE: ./reverse.pl  
#
#  DESCRIPTION: 
#
#      OPTIONS: ---
# REQUIREMENTS: ---
#         BUGS: ---
#        NOTES: ---
#       AUTHOR: Yosi Izaq
# ORGANIZATION: 
#      VERSION: 1.0
#      CREATED: 04/08/15 18:15:55
#     REVISION: ---
#===============================================================================

use strict;
use warnings;


my $str = "This is a test string";
print "Str is: $str \n";
my $rstr = reverse($str);
print "Reverse Str is: ", $rstr," \n";
my $rwstr = join (" ", reverse( split(" ", $str)));
print "Reverse words Str is: ", $rwstr," \n";



		6.2.7 Processing a String One Character at a Time
Problem

You want to process a string one character at a time.
Solution

Use split with a null pattern to break up the string into individual characters, or use unpack if you just want the characters’ values:

@array = split(//, $string);      # each element a single character
@array = unpack("U*", $string);   # each element a code point (number)

Or extract each character in turn with a loop:

while (/(.)/g) {         # . is never a newline here
        # $1 has character, ord($1) its number
    }

Discussion

As we said before, Perl’s fundamental unit is the string, not the character. Needing to process anything a character at a time is rare. Usually some kind of higher-level Perl operation, like pattern matching, solves the problem more handily. See, for example, Recipe 7.14, where a set of substitutions is used to find command-line arguments.

Splitting on a pattern that matches the empty string returns a list of individual characters in the string. This is a convenient feature when done intentionally, but it’s easy to do unintentionally. For instance, /X*/ matches all possible strings, including the empty string. Odds are you will find others when you don’t mean to.

Here’s an example that prints the characters used in the string "an apple a day“, sorted in ascending order:

%seen = ( );
$string = "an apple a day";
foreach $char (split //, $string) {
    $seen{$char}++;
}
print "unique chars are: ", sort(keys %seen), "\n";
unique chars are:  adelnpy

These split and unpack solutions give an array of characters to work with. If you don’t want an array, use a pattern match with the /g flag in a while loop, extracting one character at a time:

%seen = ( );
$string = "an apple a day";
while ($string =~ /(.)/g) {
    $seen{$1}++;
}
print "unique chars are: ", sort(keys %seen), "\n";
unique chars are:  adelnpy

In general, whenever you find yourself doing character-by-character processing, there’s probably a better way to go about it. Instead of using index and substr or split and unpack, it might be easier to use a pattern. Instead of computing a 32-bit checksum by hand, as in the next example, the unpack function can compute it far more efficiently.

The following example calculates the checksum of $string with a foreach loop. There are better checksums; this just happens to be the basis of a traditional and computationally easy checksum. You can use the standard[1] Digest::MD5 module if you want a more robust checksum.

$sum = 0;
foreach $byteval (unpack("C*", $string)) {
    $sum += $byteval;
}
print "sum is $sum\n";
# prints "1248" if $string was "an apple a day"

This does the same thing, but much faster:

$sum = unpack("%32C*", $string);

This emulates the SysV checksum program:

#!/usr/bin/perl
# sum - compute 16-bit checksum of all input files
$checksum = 0;
while (<>) { $checksum += unpack("%16C*", $_) }
$checksum %= (2 ** 16) - 1;
print "$checksum\n";

Here’s an example of its use:

% perl sum /etc/termcap
1510

If you have the GNU version of sum, you’ll need to call it with the —sysv option to get the same answer on the same file.

% sum --sysv /etc/termcap
1510 851 /etc/termcap

Another tiny program that processes its input one character at a time is slowcat, shown in Example 1-1. The idea here is to pause after each character is printed so you can scroll text before an audience slowly enough that they can read it.
Example 1-1. slowcat

  #!/usr/bin/perl
  # slowcat - emulate a   s l o w   line printer
  # usage: slowcat [-DELAY] [files ...]
  $DELAY = ($ARGV[0] =~ /^-([.\d]+)/) ? (shift, $1) : 1;
  $| = 1;
  while (<>) {
      for (split(//)) {
          print;
          select(undef,undef,undef, 0.005 * $DELAY);
      }
  }

See Also

The split and unpack functions in perlfunc(1) and Chapter 29 of Programming Perl; the use of expanding select for timing is explained in Recipe 3.10

-> My example 
[yizaq@YIZAQ-M-D1BW:Thu Apr 09:~/Desktop/Work/scripts/perl/learn/cookbook:]$ perl slowcat.pl  -4 slowcat.pl 
#!/usr/bin/perl 
#===============================================================================
#
#         FILE: slowcat.pl
#
#        USAGE: ./slowcat.pl  
#
#  DESCRIPTION: :
## slowcat - emulate a   s l o w   line printer
#  # usage: slowcat [-DELAY] [files ...]
#      OPTIONS: ---
# REQUIREMENTS: ---
#         BUGS: ---
#        NOTES: ---
#       AUTHOR: Yosi Izaq
# ORGANIZATION: 
#      VERSION: 1.0
#      CREATED: 04/09/15 11:33:21
#     REVISION: ---
#===============================================================================

use strict;
use warnings;

my $delay = ($ARGV[0] =~ /^-((\d\.)?\d+)/ ) ? (shift, $1) : 1;
#print "delay is $delay \n";
while (<>)
{
	for (split(//,$_))
	{
		print;
		select(undef,undef,undef,0.005*$delay);
	}
}


		6.2.8 Treating Unicode Combined Characters as Single Characters
Problem

You have a Unicode string that contains combining characters, and you’d like to treat each of these sequences as a single logical character.
Solution

Process them using \X in a regular expression.

$string = "fac\x{0327}ade";         # "façade"
$string =~ /fa.ade/;                # fails
$string =~ /fa\Xade/;               # succeeds

@chars = split(//, $string);        # 7 letters in @chars
@chars = $string =~ /(.)/g;         # same thing
@chars = $string =~ /(\X)/g;        # 6 "letters" in @chars

Discussion

In Unicode, you can combine a base character with one or more non-spacing characters following it; these are usually diacritics, such as accent marks, cedillas, and tildas. Due to the presence of precombined characters, for the most part to accommodate legacy character systems, there can be two or more ways of writing the same thing.

For example, the word “façade” can be written with one character between the two a’s, "\x{E7}“, a character right out of Latin1 (ISO 8859-1). These characters might be encoded into a two-byte sequence under the UTF-8 encoding that Perl uses internally, but those two bytes still only count as one single character. That works just fine.

There’s a thornier issue. Another way to write U+00E7 is with two different code points: a regular “c” followed by "\x{0327}“. Code point U+0327 is a non-spacing combining character that means to go back and put a cedilla underneath the preceding base character.

There are times when you want Perl to treat each combined character sequence as one logical character. But because they’re distinct code points, Perl’s character-related operations treat non-spacing combining characters as separate characters, including substr, length, and regular expression metacharacters, such as in /./ or /[^abc]/.

In a regular expression, the \X metacharacter matches an extended Unicode combining character sequence, and is exactly equivalent to (?:\PM\pM*) or, in long-hand:

(?x:                # begin non-capturing group
        \PM         # one character without the M (mark) property,
                    #   such as a letter
        \pM         # one character that does have the M (mark) property,
                    #   such as an accent mark
        *           # and you can have as many marks as you want
)

Otherwise simple operations become tricky if these beasties are in your string. Consider the approaches for reversing a word by character from the previous recipe. Written with combining characters, "année" and "niño" can be expressed in Perl as "anne\x{301}e" and "nin\x{303}o“.

for $word ("anne\x{301}e", "nin\x{303}o") {
    printf "%s simple reversed to %s\n", $word, 
        scalar reverse $word;
    printf "%s better reversed to %s\n", $word, 
        join("", reverse $word =~ /\X/g);
}

That produces:

               année simple reversed to éenna
               année better reversed to eénna
               niño simple reversed to õnin
               niño better reversed to oñin

In the reversals marked as simply reversed, the diacritical marking jumped from one base character to the other one. That’s because a combining character always follows its base character, and you’ve reversed the whole string. By grabbing entire sequences of a base character plus any combining characters that follow, then reversing that list, this problem is avoided.
See Also

The perlre(1) and perluniintro(1) manpages; Chapter 15 of Programming Perl; Recipe 1.9

		6.2.9 Canonicalizing Strings with Unicode Combined Characters
Problem

You have two strings that look the same when you print them out, but they don’t test as string equal and sometimes even have different lengths. How can you get Perl to consider them the same strings?
Solution

When you have otherwise equivalent strings, at least some of which contain Unicode combining character sequences, instead of comparing them directly, compare the results of running them through the NFD( ) function from the Unicode::Normalize module.

use Unicode::Normalize;
$s1 = "fa\x{E7}ade";                
$s2 = "fac\x{0327}ade";                
if (NFD($s1) eq NFD($s2)) { print "Yup!\n" }

Discussion

The same character sequence can sometimes be specified in multiple ways. Sometimes this is because of legacy encodings, such as the letters from Latin1 that contain diacritical marks. These can be specified directly with a single character (like U+00E7, LATIN SMALL LETTER C WITH CEDILLA) or indirectly via the base character (like U+0063, LATIN SMALL LETTER C) followed by a combining character (U+0327, COMBINING CEDILLA).

Another possibility is that you have two or more marks following a base character, but the order of those marks varies in your data. Imagine you wanted the letter “c” to have both a cedilla and a caron on top of it in order to print a ̌. That could be specified in any of these ways:

$string = v231.780;
#   LATIN SMALL LETTER C WITH CEDILLA
#   COMBINING CARON

$string = v99.807.780;
#         LATIN SMALL LETTER C
#         COMBINING CARON
#         COMBINING CEDILLA

$string = v99.780.807
#         LATIN SMALL LETTER C
#         COMBINING CEDILLA
#         COMBINING CARON

The normalization functions rearrange those into a reliable ordering. Several are provided, including NFD( ) for canonical decomposition and NFC( ) for canonical decomposition followed by canonical composition. No matter which of these three ways you used to specify your ̌, the NFD version is v99.807.780, whereas the NFC version is v231.780.

Sometimes you may prefer NFKD( ) and NFKC( ), which are like the previous two functions except that they perform compatible decomposition, which for NFKC( ) is then followed by canonical composition. For example, \x{FB00} is the double-f ligature. Its NFD and NFC forms are the same thing, "\x{FB00}“, but its NFKD and NFKC forms return a two-character string, "\x{66}\x{66}“.
See Also

The Universal Character Code section at the beginning of this chapter; the documentation for the Unicode::Normalize module; Recipe 8.20

		6.2.10 Treating a Unicode String as Octets
Problem

You have a Unicode string but want Perl to treat it as octets (e.g., to calculate its length or for purposes of I/O).
Solution

The use bytes pragma makes all Perl operations in its lexical scope treat the string as a group of octets. Use it when your code is calling Perl’s character-aware functions directly:

$ff = "\x{FB00}";             # ff ligature
$chars = length($ff);         # length is one character
{
  use bytes;                  # force byte semantics
  $octets = length($ff);      # length is two octets
}
$chars = length($ff);         # back to character semantics

Alternatively, the Encode module lets you convert a Unicode string to a string of octets, and back again. Use it when the character-aware code isn’t in your lexical scope:

use Encode qw(encode_utf8);

sub somefunc;                 # defined elsewhere

$ff = "\x{FB00}";             # ff ligature
$ff_oct = encode_utf8($ff);   # convert to octets

$chars = somefunc($ff);       # work with character string
$octets = somefunc($ff_oct);  # work with octet string

Discussion

As explained in this chapter’s Introduction, Perl knows about two types of string: those made of simple uninterpreted octets, and those made of Unicode characters whose UTF-8 representation may require more than one octet. Each individual string has a flag associated with it, identifying the string as either UTF-8 or octets. Perl’s I/O and string operations (such as length) check this flag and give character or octet semantics accordingly.

Sometimes you need to work with bytes and not characters. For example, many protocols have a Content-Length header that specifies the size of the body of a message in octets. You can’t simply use Perl’s length function to calculate the size, because if the string you’re calling length on is marked as UTF-8, you’ll get the size in characters.

The use bytes pragma makes all Perl functions in its lexical scope use octet semantics for strings instead of character semantics. Under this pragma, length always returns the number of octets, and read always reports the number of octets read. However, because the use bytes pragma is lexically scoped, you can’t use it to change the behavior of code in another scope (e.g., someone else’s function).

For this you need to create an octet-encoded copy of the UTF-8 string. In memory, of course, the same byte sequence is used for both strings. The difference is that the copy of your UTF-8 string has the UTF-8 flag cleared. Functions acting on the octet copy will give octet semantics, regardless of the scope they’re in.

There is also a no bytes pragma, which forces character semantics, and a decode_utf8 function, which turns octet-encoded strings into UTF-8 encoded strings. However, these functions are less useful because not all octet strings are valid UTF-8 strings, whereas all UTF-8 strings are valid octet strings.
See Also

The documentation for the bytes pragma; the documentation for the standard Encode module

		6.2.11 Expanding and Compressing Tabs
Problem

You want to convert tabs in a string to the appropriate number of spaces, or vice versa. Converting spaces into tabs can be used to reduce file size when the file has many consecutive spaces. Converting tabs into spaces may be required when producing output for devices that don’t understand tabs or think them at different positions than you do.
Solution

Either use a rather funny looking substitution:

while ($string =~ s/\t+/' ' x (length($&) * 8 - length($`) % 8)/e) {
    # spin in empty loop until substitution finally fails
}

or use the standard Text::Tabs module:

use Text::Tabs;
@expanded_lines  = expand(@lines_with_tabs);
@tabulated_lines = unexpand(@lines_without_tabs);

Discussion

Assuming tab stops are set every N positions (where N is customarily eight), it’s easy to convert them into spaces. The standard textbook method does not use the Text::Tabs module but suffers slightly from being difficult to understand. Also, it uses the $` variable, whose very mention currently slows down every pattern match in the program. This is explained in Special Variables in Chapter 6. You could use this algorithm to make a filter to expand its input’s tabstops to eight spaces each:

while (<>) {
    1 while s/\t+/' ' x (length($&) * 8 - length($`) % 8)/e;
    print;
}

To avoid $`, you could use a slightly more complicated alternative that uses the numbered variables for explicit capture; this one expands tabstops to four each instead of eight:

1 while s/^(.*?)(\t+)/$1 . ' ' x (length($2) * 4 - length($1) % 4)/e;

Another approach is to use the offsets directly from the @+ and @- arrays. This also expands to four-space positions:

1 while s/\t+/' ' x (($+[0] - $-[0]) * 4 - $-[0] % 4)/e;

If you’re looking at all of these 1 while loops and wondering why they couldn’t have been written as part of a simple s///g instead, it’s because you need to recalculate the length from the start of the line again each time rather than merely from where the last match occurred.

The convention 1 while CONDITION is the same as while (CONDITION) { }, but shorter. Its origins date to when Perl ran the first incredibly faster than the second. While the second is now almost as fast, it remains convenient, and the habit has stuck.

The standard Text::Tabs module provides conversion functions to convert both directions, exports a $tabstop variable to control the number of spaces per tab, and does not incur the performance hit because it uses $1 and $2 rather than $& and $`.

use Text::Tabs;
$tabstop = 4;
while (<>) { print expand($_) }

We can also use Text::Tabs to “unexpand” the tabs. This example uses the default $tabstop value of 8:

use Text::Tabs;
while (<>) { print unexpand($_) }

See Also

The manpage for the Text::Tabs module; the s/// operator in perlre(1) and perlop(1); the @- and @+ variables (@LAST_MATCH_START and @LAST_MATCH_END) in Chapter 28 of Programming Perl; the section on “When a global substitution just isn’t global enough” in Chapter 5 of Programming Perl

-> special regexp match variables
[yizaq@YIZAQ-M-D1BW:Thu Apr 09:~/Desktop/Work/scripts/perl/learn/cookbook:]$ echo "My name is Yosi Izaq" | perl -ne '$_ =~ /Yosi/ && print "prematch: $`, match: $&, postmatch:  \n";' 
prematch: My name is , match: Yosi, postmatch:  
[yizaq@YIZAQ-M-D1BW:Thu Apr 09:~/Desktop/Work/scripts/perl/learn/cookbook:]$ echo "My name is Yosi Izaq" | perl -ne '$_ =~ /Yosi/ && print "prematch: $`, match: $&, postmatch:  $' \n";' 
> 
		6.2.12 Expanding Variables in User Input
Problem

You’ve read a string with an embedded variable reference, such as:

You owe $debt to me.

Now you want to replace $debt in the string with its value.
Solution

Use a substitution with symbolic references if the variables are all globals:

$text =~ s/\$(\w+)/${$1}/g;

But use a double /ee if they might be lexical (my) variables:

$text =~ s/(\$\w+)/$1/gee;

Discussion

The first technique is basically to find what looks like a variable name, then use symbolic dereferencing to interpolate its contents. If $1 contains the string somevar, ${$1} will be whatever $somevar contains. This won’t work if the use strict 'refs' pragma is in effect because that bans symbolic dereferencing.

Here’s an example:

our ($rows, $cols);
no strict 'refs';                   # for ${$1}/g below
my $text;

($rows, $cols) = (24, 80);
$text = q(I am $rows high and $cols long);  # like single quotes!
$text =~ s/\$(\w+)/${$1}/g;
print $text;
I am 24 high and 80 long

You may have seen the /e substitution modifier used to evaluate the replacement as code rather than as a string. It’s designed for situations where you don’t know the exact replacement value, but you do know how to calculate it. For example, doubling every whole number in a string:

$text = "I am 17 years old";
$text =~ s/(\d+)/2 * $1/eg;

When Perl is compiling your program and sees a /e on a substitute, it compiles the code in the replacement block along with the rest of your program, long before the substitution actually happens. When a substitution is made, $1 is replaced with the string that matched. The code to evaluate would then be something like:

2 * 17

If we tried saying:

$text = 'I am $AGE years old';      # note single quotes
$text =~ s/(\$\w+)/$1/eg;           # WRONG

assuming $text held a mention of the variable $AGE, Perl would dutifully replace $1 with $AGE and then evaluate code that looked like:

'$AGE'

which just yields us our original string back again. We need to evaluate the result again to get the value of the variable. To do that, just add another /e:

$text =~ s/(\$\w+)/$1/eeg;          # finds my( ) variables

Yes, you can have as many /e modifiers as you’d like. Only the first one is compiled and syntax-checked with the rest of your program. This makes it work like the eval {BLOCK} construct, except that it doesn’t trap exceptions. Think of it more as a do {BLOCK} instead.

Subsequent /e modifiers are quite different. They’re more like the eval "STRING" construct. They don’t get compiled until runtime. A small advantage of this scheme is that it doesn’t require a no strict 'refs' pragma for the block. A tremendous advantage is that unlike symbolic dereferencing, this mechanism finds lexical variables created with my, something symbolic references can never do.

The following example uses the /x modifier to enable whitespace and comments in the pattern part of the substitute and /e to evaluate the righthand side as code. The /e modifier gives more control over what happens in case of error or other extenuating circumstances, as we have here:

# expand variables in $text, but put an error message in
# if the variable isn't defined
$text =~ s{
     \$                         # find a literal dollar sign
    (\w+)                       # find a "word" and store it in $1
}{
    no strict 'refs';           # for $$1 below
    if (defined ${$1}) {
        ${$1};                    # expand global variables only
    } else {
        "[NO VARIABLE: \$$1]";  # error msg
    }
}egx;

Once upon a time, long ago and far away, $$1 used to mean ${$}1 when it occurred within a string; that is, the $$ variable followed by a 1. This was grandfathered to work that way so you could more readily expand the $$ variable as your process ID to compose temporary filenames. It now always means ${$1}, i.e., dereference the contents of the $1 variable. We have written it the more explicit way for clarity, not correctness.
See Also

The s/// operator in perlre(1) and perlop(1) and Chapter 5 of Programming Perl; the eval function in perlfunc(1) and Chapter 29 of Programming Perl; the similar use of substitutions in Recipe 20.9

		6.2.13 Controlling Case
Problem

A string in uppercase needs converting to lowercase, or vice versa.
Solution

Use the lc and uc functions or the \L and \U string escapes.

$big = uc($little);             # "bo peep" -> "BO PEEP"
$little = lc($big);             # "JOHN"    -> "john"
$big = "\U$little";             # "bo peep" -> "BO PEEP"
$little = "\L$big";             # "JOHN"    -> "john"

To alter just one character, use the lcfirst and ucfirst functions or the \l and \u string escapes.

$big = "\u$little";             # "bo"      -> "Bo"
$little = "\l$big";             # "BoPeep"  -> "boPeep"

Discussion

The functions and string escapes look different, but both do the same thing. You can set the case of either just the first character or the whole string. You can even do both at once to force uppercase (actually, titlecase; see later explanation) on initial characters and lowercase on the rest.

$beast   = "dromedary";
# capitalize various parts of $beast
$capit   = ucfirst($beast);         # Dromedary
$capit   = "\u\L$beast";            # (same)
$capall  = uc($beast);              # DROMEDARY
$capall  = "\U$beast";              # (same)
$caprest = lcfirst(uc($beast));     # dROMEDARY
$caprest = "\l\U$beast";            # (same)

These capitalization-changing escapes are commonly used to make a string’s case consistent:

# titlecase each word's first character, lowercase the rest
$text = "thIS is a loNG liNE";
$text =~ s/(\w+)/\u\L$1/g;
print $text;
This Is A Long Line

You can also use these for case-insensitive comparison:

if (uc($a) eq uc($b)) { # or "\U$a" eq "\U$b"
    print "a and b are the same\n";
}

The randcap program, shown in Example 1-2, randomly titlecases 20 percent of the letters of its input. This lets you converse with 14-year-old WaREz d00Dz.
Example 1-2. randcap

  #!/usr/bin/perl -p
  # randcap: filter to randomly capitalize 20% of the letters
  # call to srand( ) is unnecessary as of v5.4
  BEGIN { srand(time( ) ^ ($$ + ($$<<15))) }
  sub randcase { rand(100) < 20 ? "\u$_[0]" : "\l$_[0]" }
  s/(\w)/randcase($1)/ge;
  % randcap < genesis | head -9
boOk 01 genesis
                  001:001 in the BEginning goD created the heaven and tHe earTh
                        
                  001:002 and the earth wAS without ForM, aND void; AnD darkneSS was
                  upon The Face of the dEEp. and the spIrit of GOd movEd upOn
                  tHe face of the Waters
                  001:003 and god Said, let there be ligHt: and therE wAs LigHt

In languages whose writing systems distinguish between uppercase and titlecase, the ucfirst( ) function (and \u, its string escape alias) converts to titlecase. For example, in Hungarian the “dz” sequence occurs. In uppercase, it’s written as “DZ”, in titlecase as “Dz”, and in lowercase as “dz”. Unicode consequently has three different characters defined for these three situations:

Code point  Written   Meaning
01F1        DZ        LATIN CAPITAL LETTER DZ
01F2        Dz        LATIN CAPITAL LETTER D WITH SMALL LETTER Z
01F3        dz        LATIN SMALL LETTER DZ

It is tempting but ill-advised to just use tr[a-z][A-Z] or the like to convert case. This is a mistake because it omits all characters with diacritical markings—such as diaereses, cedillas, and accent marks—which are used in dozens of languages, including English. However, correctly handling case mappings on data with diacritical markings can be far trickier than it seems. There is no simple answer, although if everything is in Unicode, it’s not all that bad, because Perl’s case-mapping functions do work perfectly fine on Unicode data. See the section on The Universal Character Code in the Introduction to this chapter for more information.
See Also

The uc, lc, ucfirst, and lcfirst functions in perlfunc(1) and Chapter 29 of Programming Perl; \L, \U, \l, and \u string escapes in the “Quote and Quote-like Operators” section of perlop(1) and Chapter 5 of Programming Perl

		6.2.14 Properly Capitalizing a Title or Headline
Problem

You have a string representing a headline, the title of book, or some other work that needs proper capitalization.
Solution

Use a variant of this tc( ) titlecasing function:

INIT {
    our %nocap;
    for (qw(
            a an the
            and but or
            as at but by for from in into of off on onto per to with
        ))
    {
        $nocap{$_}++;
    }
}

sub tc {
    local $_ = shift;

    # put into lowercase if on stop list, else titlecase
    s/(\pL[\pL']*)/$nocap{$1} ? lc($1) : ucfirst(lc($1))/ge;

    s/^(\pL[\pL']*) /\u\L$1/x;  # first  word guaranteed to cap
    s/ (\pL[\pL']*)$/\u\L$1/x;  # last word guaranteed to cap

    # treat parenthesized portion as a complete title
    s/\( (\pL[\pL']*) /(\u\L$1/x;
    s/(\pL[\pL']*) \) /\u\L$1)/x;

    # capitalize first word following colon or semi-colon
    s/ ( [:;] \s+ ) (\pL[\pL']* ) /$1\u\L$2/x;

    return $_;
}

Discussion

The rules for correctly capitalizing a headline or title in English are more complex than simply capitalizing the first letter of each word. If that’s all you need to do, something like this should suffice:

s/(\w+\S*\w*)/\u\L$1/g;

Most style guides tell you that the first and last words in the title should always be capitalized, along with every other word that’s not an article, the particle “to” in an infinitive construct, a coordinating conjunction, or a preposition.

Here’s a demo, this time demonstrating the distinguishing property of titlecase. Assume the tc function is as defined in the Solution.

# with apologies (or kudos) to Stephen Brust, PJF,
# and to JRRT, as always.
@data = (
            "the enchantress of \x{01F3}ur mountain",
    "meeting the enchantress of \x{01F3}ur mountain",
    "the lord of the rings: the fellowship of the ring",
);

$mask = "%-20s: %s\n";

sub tc_lame {
    local $_ = shift;
    s/(\w+\S*\w*)/\u\L$1/g;
    return $_;
}

for $datum (@data) { 
    printf $mask, "ALL CAPITALS",       uc($datum);
    printf $mask, "no capitals",        lc($datum);
    printf $mask, "simple titlecase",   tc_lame($datum);
    printf $mask, "better titlecase",   tc($datum);
    print "\n";
}

ALL CAPITALS        : THE ENCHANTRESS OF DZUR MOUNTAIN
               no capitals         : the enchantress of dzur mountain
               simple titlecase    : The Enchantress Of Dzur Mountain
               better titlecase    : The Enchantress of Dzur Mountain

               ALL CAPITALS        : MEETING THE ENCHANTRESS OF DZUR MOUNTAIN
               no capitals         : meeting the enchantress of dzur mountain
               simple titlecase    : Meeting The Enchantress Of Dzur Mountain
               better titlecase    : Meeting the Enchantress of Dzur Mountain

               ALL CAPITALS        : THE LORD OF THE RINGS: THE FELLOWSHIP OF THE RING
               no capitals         : the lord of the rings: the fellowship of the ring
               simple titlecase    : The Lord Of The Rings: The Fellowship Of The Ring
               better titlecase    : The Lord of the Rings: The Fellowship of the Ring

One thing to consider is that some style guides prefer capitalizing only prepositions that are longer than three, four, or sometimes five letters. O’Reilly & Associates, for example, keeps prepositions of four or fewer letters in lowercase. Here’s a longer list of prepositions if you prefer, which you can modify to your needs:

@all_prepositions = qw{
    about above absent across after against along amid amidst
    among amongst around as at athwart before behind below
    beneath beside besides between betwixt beyond but by circa
    down during ere except for from in into near of off on onto
    out over past per since than through till to toward towards 
    under until unto up upon versus via with within without
};

This kind of approach can take you only so far, though, because it doesn’t distinguish between words that can be several parts of speech. Some prepositions on the list might also double as words that should always be capitalized, such as subordinating conjunctions, adverbs, or even adjectives. For example, it’s “Down by the Riverside” but “Getting By on Just $30 a Day”, or “A Ringing in My Ears” but “Bringing In the Sheaves”.

Another consideration is that you might prefer to apply the \u or ucfirst conversion by itself without also putting the whole string into lowercase. That way a word that’s already in all capital letters, such as an acronym, doesn’t lose that trait. You probably wouldn’t want to convert “FBI” and “LBJ” into “Fbi” and “Lbj”.
See Also

The uc, lc, ucfirst, and lcfirst functions in perlfunc(1) and Chapter 29 of Programming Perl; the \L, \U, \l, and \u string escapes in the “Quote and Quote-like Operators” section of perlop(1) and Chapter 5 of Programming Perl

		6.2.15
Interpolating Functions and Expressions Within Strings
Problem

You want a function call or expression to expand within a string. This lets you construct more complex templates than with simple scalar variable interpolation.
Solution

Break up your expression into distinct concatenated pieces:

$answer = $var1 . func( ) . $var2;   # scalar only

Or use the slightly sneaky @{[ LIST EXPR ]} or ${ \(SCALAR EXPR ) } expansions:

$answer = "STRING @{[ LIST EXPR ]} MORE STRING";
$answer = "STRING ${\( SCALAR EXPR )} MORE STRING";

Discussion

This code shows both techniques. The first line shows concatenation; the second shows the expansion trick:

$phrase = "I have " . ($n + 1) . " guanacos.";
$phrase = "I have ${\($n + 1)} guanacos.";

The first technique builds the final string by concatenating smaller strings, avoiding interpolation but achieving the same end. Because print effectively concatenates its entire argument list, if we were going to print $phrase, we could have just said:

print "I have ",  $n + 1, " guanacos.\n";

When you absolutely must have interpolation, you need the punctuation-riddled interpolation from the Solution. Only @, $, and \ are special within double quotes and most backquotes. (As with m// and s///, the qx( ) synonym is not subject to double-quote expansion if its delimiter is single quotes! $home = qx'echo home is $HOME'; would get the shell $HOME variable, not one in Perl.) So, the only way to force arbitrary expressions to expand is by expanding a ${ } or @{ } whose block contains a reference.

In the example:

$phrase = "I have ${\( count_em( ) )} guanacos.";

the function call within the parentheses is not in scalar context; it is still in list context. The following overrules that:

$phrase = "I have ${\( scalar count_em( ) )} guanacos.";

You can do more than simply assign to a variable after interpolation. It’s a general mechanism that can be used in any double-quoted string. For instance, this example builds a string with an interpolated expression and passes the result to a function:

some_func("What you want is @{[ split /:/, $rec ]} items");

You can interpolate into a here document, as by:

die "Couldn't send mail" unless send_mail(<<"EOTEXT", $target);
To: $naughty
From: Your Bank
Cc: @{ get_manager_list($naughty) }
Date: @{[ do { my $now = `date`; chomp $now; $now } ]} (today)

Dear $naughty,

Today, you bounced check number @{[ 500 + int rand(100) ]} to us.
Your account is now closed.

Sincerely,
the management
EOTEXT

Expanding backquotes (``) is particularly challenging because you would normally end up with spurious newlines. By creating a braced block following the @ within the @{[ ]} anonymous array dereference, as in the last example, you can create private variables.

Although these techniques work, simply breaking your work up into several steps or storing everything in temporary variables is almost always clearer to the reader.

The Interpolation module from CPAN provides a more syntactically palatable covering. For example, to make elements of the hash %E evaluate and return its subscript:

use Interpolation E     => 'eval';
print "You bounced check number $E{500 + int rand(100)}\n";

Or to make a hash named %money call a suitably defined function of your choice:

use Interpolation money => \&currency_commify;

print "That will be $money{ 4 * $payment }, right now.\n";

expect to get something like:

               That will be $3,232.421.04, right now

See Also

perlref(1) and the “Other Tricks You Can Do with Hard References” section in Chapter 8 of Programming Perl; the Interpolation CPAN module 

		6.2.16 Indenting Here Documents
Problem

When using the multiline quoting mechanism called a here document, the text must be flush against the margin, which looks out of place in the code. You would like to indent the here document text in the code, but not have the indentation appear in the final string value.
Solution

Use a s/// operator to strip out leading whitespace.

# all in one
($var = << HERE_TARGET) =~ s/^\s+//gm;
    your text
    goes here
HERE_TARGET

# or with two steps
$var = << HERE_TARGET;
    your text
    goes here
HERE_TARGET
$var =~ s/^\s+//gm;

Discussion

The substitution is straightforward. It removes leading whitespace from the text of the here document. The /m modifier lets the ^ character match at the start of each line in the string, and the /g modifier makes the pattern-matching engine repeat the substitution as often as it can (i.e., for every line in the here document).

($definition = << 'FINIS') =~ s/^\s+//gm;
    The five varieties of camelids
    are the familiar camel, his friends
    the llama and the alpaca, and the
    rather less well-known guanaco
    and vicuña.
FINIS

Be warned: all patterns in this recipe use \s, meaning one whitespace character, which will also match newlines. This means they will remove any blank lines in your here document. If you don’t want this, replace \s with [^\S\n] in the patterns.

The substitution uses the property that the result of an assignment can be used as the lefthand side of =~. This lets us do it all in one line, but works only when assigning to a variable. When you’re using the here document directly, it would be considered a constant value, and you wouldn’t be able to modify it. In fact, you can’t change a here document’s value unless you first put it into a variable.

Not to worry, though, because there’s an easy way around this, particularly if you’re going to do this a lot in the program. Just write a subroutine:

sub fix {
    my $string = shift;
    $string =~ s/^\s+//gm;
    return $string;
}

print fix( << "END");
    My stuff goes here
END

# With function predeclaration, you can omit the parens:
print fix << "END";
    My stuff goes here
END

As with all here documents, you have to place this here document’s target (the token that marks its end, END in this case) flush against the lefthand margin. To have the target indented also, you’ll have to put the same amount of whitespace in the quoted string as you use to indent the token.

($quote = << '    FINIS') =~ s/^\s+//gm;
        ...we will have peace, when you and all your works have
        perished--and the works of your dark master to whom you would
        deliver us. You are a liar, Saruman, and a corrupter of men's
        hearts.  --Theoden in /usr/src/perl/taint.c
    FINIS
$quote =~ s/\s+--/\n--/;      #move attribution to line of its own

If you’re doing this to strings that contain code you’re building up for an eval, or just text to print out, you might not want to blindly strip all leading whitespace, because that would destroy your indentation. Although eval wouldn’t care, your reader might.

Another embellishment is to use a special leading string for code that stands out. For example, here we’ll prepend each line with @@@, properly indented:

if ($REMEMBER_THE_MAIN) {
    $perl_main_C = dequote << '    MAIN_INTERPRETER_LOOP';
        @@@ int
        @@@ runops( ) {
        @@@     SAVEI32(runlevel);
        @@@     runlevel++;
        @@@     while ( op = (*op->op_ppaddr)( ) ) ;
        @@@     TAINT_NOT;
        @@@     return 0;
        @@@ }
    MAIN_INTERPRETER_LOOP
    # add more code here if you want
}

Destroying indentation also gets you in trouble with poets.

sub dequote;
$poem = dequote << EVER_ON_AND_ON;
       Now far ahead the Road has gone,
          And I must follow, if I can,
       Pursuing it with eager feet,
          Until it joins some larger way
       Where many paths and errands meet.
          And whither then? I cannot say.
                --Bilbo in /usr/src/perl/pp_ctl.c
EVER_ON_AND_ON
print "Here's your poem:\n\n$poem\n";

Here is its sample output:

               Here's your poem

               Now far ahead the Road has gone
               And I must follow, if I can
               Pursuing it with eager feet
               Until it joins some larger way
               Where many paths and errands meet
               And whither then? I cannot say
               --Bilbo in /usr/src/perl/pp_ctl.c

The following dequote function handles all these cases. It expects to be called with a here document as its argument. It checks whether each line begins with a common substring, and if so, strips that off. Otherwise, it takes the amount of leading whitespace found on the first line and removes that much from each subsequent line.

sub dequote {
    local $_ = shift;
    my ($white, $leader);  # common whitespace and common leading string
    if (/^\s*(?:([^\w\s]+)(\s*).*\n)(?:\s*\1\2?.*\n)+$/) {
        ($white, $leader) = ($2, quotemeta($1));
    } else {
        ($white, $leader) = (/^(\s+)/, '');
    }
    s/^\s*?$leader(?:$white)?//gm;
    return $_;
}

If that pattern makes your eyes glaze over, you could always break it up and add comments by adding /x:

if (m{
            ^                       # start of line
            \s *                    # 0 or more whitespace chars
            (?:                     # begin first non-remembered grouping
                 (                  #   begin save buffer $1
                    [^\w\s]         #     one character neither space nor word
                    +               #     1 or more of such
                 )                  #   end save buffer $1
                 ( \s* )            #   put 0 or more white in buffer $2
                 .* \n              #   match through the end of first line
             )                      # end of first grouping
             (?:                    # begin second non-remembered grouping
                \s *                #   0 or more whitespace chars
                \1                  #   whatever string is destined for $1
                \2 ?                #   what'll be in $2, but optionally
                .* \n               #   match through the end of the line
             ) +                    # now repeat that group idea 1 or more
             $                      # until the end of the line
          }x
       )
    {
        ($white, $leader) = ($2, quotemeta($1));
    } else {
        ($white, $leader) = (/^(\s+)/, '');
    }
    s{
         ^                          # start of each line (due to /m)
         \s *                       # any amount of leading whitespace
            ?                       #   but minimally matched
         $leader                    # our quoted, saved per-line leader
         (?:                        # begin unremembered grouping
            $white                  #    the same amount
         ) ?                        # optionalize in case EOL after leader
    }{  }xgm;

There, isn’t that much easier to read? Well, maybe not; sometimes it doesn’t help to pepper your code with insipid comments that mirror the code. This may be one of those cases.
See Also

The “Scalar Value Constructors” section of perldata(1) and the section on “Here Documents” in Chapter 2 of Programming Perl; the s/// operator in perlre(1) and perlop(1), and the “Pattern Matching” section in Chapter 5 of Programming Perl

		6.2.17 Reformatting Paragraphs
Problem

Your string is too big to fit the screen, and you want to break it up into lines of words, without splitting a word between lines. For instance, a style correction script might read a text file a paragraph at a time, replacing bad phrases with good ones. Replacing a phrase like utilizes the inherent functionality of with uses will change the length of lines, so it must somehow reformat the paragraphs when they’re output.
Solution

Use the standard Text::Wrap module to put line breaks at the right place:

use Text::Wrap;
@output = wrap($leadtab, $nexttab, @para);

Or use the more discerning CPAN module, Text::Autoformat, instead:

use Text::Autoformat;
$formatted = autoformat $rawtext;

Discussion

The Text::Wrap module provides the wrap function, shown in Example 1-3, which takes a list of lines and reformats them into a paragraph with no line more than $Text::Wrap::columns characters long. We set $columns to 20, ensuring that no line will be longer than 20 characters. We pass wrap two arguments before the list of lines: the first is the indent for the first line of output, the second the indent for every subsequent line.
Example 1-3. wrapdemo

  #!/usr/bin/perl -w
  # wrapdemo - show how Text::Wrap works
  @input = ("Folding and splicing is the work of an editor,",
            "not a mere collection of silicon",
            "and",
            "mobile electrons!");
  use Text::Wrap qw($columns &wrap);
  $columns = 20;
  print "0123456789" x 2, "\n";
  print wrap("    ", "  ", @input), "\n";

The result of this program is:

               01234567890123456789
               Folding and
               splicing is the
               work of an
               editor, not a
               mere collection
               of silicon and
               mobile electrons!

We get back a single string, with newlines ending each line but the last:

# merge multiple lines into one, then wrap one long line
use Text::Wrap;
undef $/;
print wrap('', '', split(/\s*\n\s*/, <>));

If you have the Term::ReadKey module (available from CPAN) on your system, you can determine your window size so you can wrap lines to fit the current screen size. If you don’t have the module, sometimes the screen size can be found in $ENV{COLUMNS} or by parsing the output of the stty(1) command.

The following program tries to reformat both short and long lines within a paragraph, similar to the fmt(1) program, by setting the input record separator $/ to the empty string (causing <> to read paragraphs) and the output record separator $\ to two newlines. Then the paragraph is converted into one long line by changing all newlines and any surrounding whitespace to single spaces. Finally, we call the wrap function with leading and subsequent tab strings set to the empty string so we can have block paragraphs.

use Text::Wrap      qw(&wrap $columns);
use Term::ReadKey   qw(GetTerminalSize);
($columns) = GetTerminalSize( );
($/, $\)  = ('', "\n\n");   # read by paragraph, output 2 newlines
while (<>) {                # grab a full paragraph
    s/\s*\n\s*/ /g;         # convert intervening newlines to spaces
    print wrap('', '', $_); # and format
}

The CPAN module Text::Autoformat is much more clever. For one thing, it tries to avoid “widows,” that is, very short lines at the end. More remarkably, it correctly copes with reformatting paragraphs that have multiple, deeply nested citations. An example from that module’s manpage shows how the module can painlessly convert:

In comp.lang.perl.misc you wrote:
: > <CN = Clooless Noobie> writes:
: > CN> PERL sux because:
: > CN>    * It doesn't have a switch statement and you have to put $
: > CN>signs in front of everything
: > CN>    * There are too many OR operators: having |, || and 'or'
: > CN>operators is confusing
: > CN>    * VB rools, yeah!!!!!!!!!
: > CN> So anyway, how can I stop reloads on a web page?
: > CN> Email replies only, thanks - I don't read this newsgroup.
: >
: > Begone, sirrah! You are a pathetic, Bill-loving, microcephalic
: > script-infant.
: Sheesh, what's with this group - ask a question, get toasted! And how
: *dare* you accuse me of Ianuphilia!

into:

In comp.lang.perl.misc you wrote:
: > <CN = Clooless Noobie> writes:
: > CN> PERL sux because:
: > CN>    * It doesn't have a switch statement and you
: > CN>      have to put $ signs in front of everything
: > CN>    * There are too many OR operators: having |, ||
: > CN>      and 'or' operators is confusing
: > CN>    * VB rools, yeah!!!!!!!!! So anyway, how can I
: > CN>      stop reloads on a web page? Email replies
: > CN>      only, thanks - I don't read this newsgroup.
: >
: > Begone, sirrah! You are a pathetic, Bill-loving,
: > microcephalic script-infant.
: Sheesh, what's with this group - ask a question, get toasted!
: And how *dare* you accuse me of Ianuphilia!

simply via print autoformat($badparagraph). Pretty impressive, eh?

Here’s a miniprogram that uses that module to reformat each paragraph of its input stream:

use Text::Autoformat;
$/ = '';
while (<>) {
    print autoformat($_, {squeeze => 0, all => 1}), "\n";
}

See Also

The split and join functions in perlfunc(1) and Chapter 29 of Programming Perl; the manpage for the standard Text::Wrap module; the CPAN module Term::ReadKey, and its use in Recipe 15.6 and the CPAN module Text::Autoformat 

		6.2.18 Escaping Characters
Problem

You need to output a string with certain characters (quotes, commas, etc.) escaped. For instance, you’re producing a format string for sprintf and want to convert literal % signs into %%.
Solution

Use a substitution to backslash or double each character to be escaped:

# backslash
$var =~ s/([CHARLIST])/\\$1/g;

# double
$var =~ s/([CHARLIST])/$1$1/g;

Discussion

$var is the variable to be altered. The CHARLIST is a list of characters to escape and can contain backslash escapes like \t and \n. If you just have one character to escape, omit the brackets:

$string =~ s/%/%%/g;

The following code lets you do escaping when preparing strings to submit to the shell. (In practice, you would need to escape more than just ' and " to make any arbitrary string safe for the shell. Getting the list of characters right is so hard, and the risks if you get it wrong are so great, that you’re better off using the list form of system and exec to run programs, shown in Recipe 16.2. They avoid the shell altogether.)

$string = q(Mom said, "Don't do that.");
$string =~ s/(['"])/\\$1/g;

We had to use two backslashes in the replacement because the replacement section of a substitution is read as a double-quoted string, and to get one backslash, you need to write two. Here’s a similar example for VMS DCL, where you need to double every quote to get one through:

$string = q(Mom said, "Don't do that.");
$string =~ s/(['"])/$1$1/g;

Microsoft command interpreters are harder to work with. In Windows, COMMAND.COM recognizes double quotes but not single ones, disregards backquotes for running commands, and requires a backslash to make a double quote into a literal. Any of the many free or commercial Unix-like shell environments available for Windows will work just fine, though.

Because we’re using character classes in the regular expressions, we can use - to define a range and ^ at the start to negate. This escapes all characters that aren’t in the range A through Z.

$string =~ s/([^A-Z])/\\$1/g;

In practice, you wouldn’t want to do that, since it would pick up a lowercase "a" and turn it into "\a“, for example, which is ASCII BEL character. (Usually when you mean non-alphabetic characters, \PL works better.)

If you want to escape all non-word characters, use the \Q and \E string metacharacters or the quotemeta function. For example, these are equivalent:

$string = "this \Qis a test!\E";
$string = "this is\\ a\\ test\\!";
$string = "this " . quotemeta("is a test!");

See Also

The s/// operator in perlre(1) and perlop(1) and Chapter 5 of Programming Perl; the quotemeta function in perlfunc(1) and Chapter 29 of Programming Perl; the discussion of HTML escaping in Recipe 19.1; Recipe 19.5 for how to avoid having to escape strings to give the shell

		6.2.19 Trimming Blanks from the Ends of a String
Problem

You have read a string that may have leading or trailing whitespace, and you want to remove it.
Solution

Use a pair of pattern substitutions to get rid of them:

$string =~ s/^\s+//;
$string =~ s/\s+$//;

Or write a function that returns the new value:

$string = trim($string);
@many   = trim(@many);

sub trim {
    my @out = @_;
    for (@out) {
        s/^\s+//;          # trim left
        s/\s+$//;          # trim right
    }
    return @out =  = 1 
              ? $out[0]   # only one to return
              : @out;     # or many
}

Discussion

This problem has various solutions, but this one is the most efficient for the common case. This function returns new versions of the strings passed in to it with their leading and trailing whitespace removed. It works on both single strings and lists.

To remove the last character from the string, use the chop function. Be careful not to confuse this with the similar but different chomp function, which removes the last part of the string contained within that variable if and only if it is contained in the $/ variable, "\n" by default. These are often used to remove the trailing newline from input:

# print what's typed, but surrounded by > < symbols
while (<STDIN>) {
    chomp;
    print ">$_<\n";
}

This function can be embellished in any of several ways.

First, what should you do if several strings are passed in, but the return context demands a single scalar? As written, the function given in the Solution does a somewhat silly thing: it (inadvertently) returns a scalar representing the number of strings passed in. This isn’t very useful. You could issue a warning or raise an exception. You could also squash the list of return values together.

For strings with spans of extra whitespace at points other than their ends, you could have your function collapse any remaining stretch of whitespace characters in the interior of the string down to a single space each by adding this line as the new last line of the loop:

s/\s+/ /g;                # finally, collapse middle

That way a string like " but\t\tnot here\n" would become "but not here“. A more efficient alternative to the three substitution lines:

s/^\s+//;          
s/\s+$//;          
s/\s+/ /g;

would be:

$_ = join(' ', split(' '));

If the function isn’t passed any arguments at all, it could act like chop and chomp by defaulting to $_. Incorporating all of these embellishments produces this function:

# 1. trim leading and trailing white space
# 2. collapse internal whitespace to single space each
# 3. take input from $_ if no arguments given
# 4. join return list into single scalar with intervening spaces 
#     if return is scalar context

sub trim {
    my @out = @_ ? @_ : $_;
    $_ = join(' ', split(' ')) for @out;
    return wantarray ? @out : "@out";
}

See Also

The s/// operator in perlre(1) and perlop(1) and Chapter 5 of Programming Perl; the chomp and chop functions in perlfunc(1) and Chapter 29 of Programming Perl; we trim leading and trailing whitespace in the getnum function in Recipe 2.1

		6.2.20 Parsing Comma-Separated Data
Problem

You have a data file containing comma-separated values that you need to read, but these data fields may have quoted commas or escaped quotes in them. Most spreadsheets and database programs use comma-separated values as a common interchange format.
Solution

If your data file follows normal Unix quoting and escaping conventions, where quotes within a field are backslash-escaped "like \"this\"“, use the standard Text::ParseWords and this simple code:

use Text::ParseWords;
sub parse_csv0 {
    return quotewords("," => 0, $_[0]);
}

However, if quotes within a field are doubled "like ""this""“, you could use the following procedure from Mastering Regular Expressions, Second Edition:

sub parse_csv1 {
    my $text = shift;      # record containing comma-separated values
    my @fields  = ( );

    while ($text =~ m{
        # Either some non-quote/non-comma text:
        ( [^"',] + )

         # ...or...
         | 

        # ...a double-quoted field: (with "" allowed inside)

        " # field's opening quote; don't save this
         (   now a field is either
          (?:     [^"]    # non-quotes or
              |
                  ""      # adjacent quote pairs
           ) *  # any number
         )
        " # field's closing quote; unsaved

    }gx)
    {
      if (defined $1) {
          $field = $1;
      } else {
          ($field = $2) =~ s/""/"/g;
      }
      push @fields, $field;
    }
    return @fields;
}

Or use the CPAN Text:CSV module:

use Text::CSV;
sub parse_csv1 {
    my $line = shift;
    my $csv = Text::CSV->new( );              
    return $csv->parse($line) && $csv->fields( );           
}

Or use the CPAN Tie::CSV_File module:

tie @data, "Tie::CSV_File", "data.csv";

for ($i = 0; $i < @data; $i++) {
    printf "Row %d (Line %d) is %s\n", $i, $i+1, "@{$data[$i]}";
    for ($j = 0; $j < @{$data[$i]}; $j++) {
        print "Column $j is <$data[$i][$j]>\n";
    } 
}

Discussion

Comma-separated input is a deceptive and complex format. It sounds simple, but involves a fairly complex escaping system because the fields themselves can contain commas. This makes the pattern-matching solution complex and rules out a simple split /,/. Still worse, quoting and escaping conventions vary between Unix-style files and legacy systems. This incompatibility renders impossible any single algorithm for all CSV data files.

The standard Text::ParseWords module is designed to handle data whose quoting and escaping conventions follow those found in most Unix data files. This makes it eminently suitable for parsing the numerous colon-separated data files found on Unix systems, including disktab(5), gettytab(5), printcap(5), and termcap(5). Pass that module’s quotewords function two arguments and the CSV string. The first argument is the separator (here a comma, but often a colon), and the second is a true or false value controlling whether the strings are returned with quotes around them.

In this style of data file, you represent quotation marks inside a field delimited by quotation marks by escaping them with backslashes "like\"this\"“. Quotation marks and backslashes are the only characters that have meaning when backslashed. Any other use of a backslash will be left in the output string. The standard Text::ParseWords module’s quotewords( ) function can handle such data.

However, it’s of no use on data files from legacy systems that represent quotation marks inside such a field by doubling them "like""this""“. For those, you’ll need one of the other solutions. The first of these is based on the regular expression from Mastering Regular Expressions, Second Edition, by Jeffrey E. F. Friedl (O’Reilly). It enjoys the advantage of working on any system without requiring installation of modules not found in the standard distribution. In fact, it doesn’t use any modules at all. Its slight disadvantage is the risk of sending the unseasoned reader into punctuation shock, despite its copious commenting.

The object-oriented CPAN module Text::CSV demonstrated in the next solution hides that parsing complexity in more easily digestible wrappers. An even more elegant solution is offered by the Tie::CSV_File module from CPAN, in which you are given what appears to be a two-dimensional array. The first dimension represents each line of the file, and the second dimension each column on each row.

Here’s how you’d use our two kinds of parse_csv subroutines. The q( ) is just a fancy quote so we didn’t have to backslash everything.

$line = q(XYZZY,"","O'Reilly, Inc","Wall, Larry","a \"glug\" bit,",5,"Error, Core 
Dumped");
@fields = parse_csv0($line);
for ($i = 0; $i < @fields; $i++) {
    print "$i : $fields[$i]\n";
}

0 : XYZZY
               1 
               2 : O'Reilly, Inc
               3 : Wall, Larry
               4 : a "glug" bit
               5 : 5
               6 : Error, Core Dumped

If the second argument to quotewords had been 1 instead of 0, the quotes would have been retained, producing this output instead:

               0 : XYZZY
               1 : "
               2 : "O'Reilly, Inc
               3 : "Wall, Larry
               4 : "a \"glug\" bit,
               5 : 5
               6 : "Error, Core Dumped

The other sort of data file is manipulated the same way, but using our parse_csv1 function instead of parse_csv0. Notice how the embedded quotes are doubled, not escaped.

$line = q(Ten Thousand,10000, 2710 ,,"10,000","It's ""10 Grand"", baby",10K);
@fields = parse_csv1($line);
for ($i = 0; $i < @fields; $i++) {
    print "$i : $fields[$i]\n";
}

0 : Ten Thousand
               1 : 10000
               2 :  2710
               3 
               4 : 10,000
               5 : It's "10 Grand", baby
               6 : 10K

See Also

The explanation of regular expression syntax in perlre(1) and Chapter 5 of Programming Perl; the documentation for the standard Text::ParseWords module; the section on “Parsing CSV Files” in Chapter 5 of Mastering Regular Expressions, Second Edition

		6.2.21 Constant Variables
Problem

You want a variable whose value cannot be modified once set.
Solution

If you don’t need it to be a scalar variable that can interpolate, the use constant pragma will work:

use constant AVOGADRO => 6.02252e23;

printf "You need %g of those for guac\n", AVOGADRO;

If it does have to be a variable, assign to the typeglob a reference to a literal string or number, then use the scalar variable:

*AVOGADRO = \6.02252e23;
print "You need $AVOGADRO of those for guac\n";

But the most foolproof way is via a small tie class whose STORE method raises an exception:

package Tie::Constvar;
use Carp;
sub TIESCALAR {
    my ($class, $initval) = @_;
    my $var = $initval;
    return bless \$var => $class;
}
sub FETCH {
    my $selfref = shift;
    return $$selfref;
}
sub STORE {
    confess "Meddle not with the constants of the universe";
}

Discussion

The use constant pragma is the easiest to use, but has a few drawbacks. The biggest one is that it doesn’t give you a variable that you can expand in double-quoted strings. Another is that it isn’t scoped; it puts a subroutine of that name into the package namespace.

The way the pragma really works is to create a subroutine of that name that takes no arguments and always returns the same value (or values if a list is provided). That means it goes into the current package’s namespace and isn’t scoped. You could do the same thing yourself this way:

sub AVOGADRO( ) { 6.02252e23 }

If you wanted it scoped to the current block, you could make a temporary subroutine by assigning an anonymous subroutine to the typeglob of that name:

use subs qw(AVOGADRO);
local *AVOGADRO = sub ( ) { 6.02252e23 };

But that’s pretty magical, so you should comment the code if you don’t plan to use the pragma.

If instead of assigning to the typeglob a reference to a subroutine, you assign to it a reference to a constant scalar, then you’ll be able to use the variable of that name. That’s the second technique given in the Solution. Its disadvantage is that typeglobs are available only for package variables, not for lexicals created via my. Under the recommended use strict pragma, an undeclared package variable will get you into trouble, too, but you can declare the variable using our:

our $AVOGADRO;
local *AVOGADRO = \6.02252e23;

The third solution provided, that of creating your own little tie class, might appear the most complicated, but it provides the most flexibility. Plus you get to declare it as a lexical if you want.

tie my $AVOGADRO, Tie::Constvar, 6.02252e23;

After which this is okay:

print "You need $AVOGADRO of those for guac\n";

But this will get you in trouble:

$AVOGADRO = 6.6256e-34;   # sorry, Max

See Also

Recipe 1.15; Recipe 5.3; the discussion on folding constant subroutines toward the end of the section on “Compiling Your Code” in Chapter 18 of Programming Perl; the CPAN module Tie::Scalar::RestrictUpdates might give you some other ideas

		6.2.22 Soundex Matching
Problem

You have two English surnames and want to know whether they sound somewhat similar, regardless of spelling. This would let you offer users a “fuzzy search” of names in a telephone book to catch “Smith” and “Smythe” and others within the set, such as “Smite” and “Smote”.
Solution

Use the standard Text::Soundex module:

use Text::Soundex;
$CODE  = soundex($STRING);
@CODES = soundex(@LIST);

Or use the CPAN module Text::Metaphone:

use Text::Metaphone;
$phoned_words = Metaphone('Schwern');

Discussion

The soundex algorithm hashes words (particularly English surnames) into a small space using a simple model that approximates an English speaker’s pronunciation of the words. Roughly speaking, each word is reduced to a four-character string. The first character is an uppercase letter; the remaining three are digits. By comparing the soundex values of two strings, we can guess whether they sound similar.

The following program prompts for a name and looks for similarly sounding names from the password file. This same approach works on any database with names, so you could key the database on the soundex values if you wanted to. Such a key wouldn’t be unique, of course.

use Text::Soundex;
use User::pwent;

print "Lookup user: ";
chomp($user =<STDIN>);
exit unless defined $user;
$name_code = soundex($user);

while ($uent = getpwent( )) {
    ($firstname, $lastname) = $uent->gecos =~ /(\w+)[^,]*\b(\w+)/;

    if ($name_code eq soundex($uent->name) ||
        $name_code eq soundex($lastname)   ||
        $name_code eq soundex($firstname)  )
    {
        printf "%s: %s %s\n", $uent->name, $firstname, $lastname;
    }
}

The Text::Metaphone module from CPAN addresses the same problem in a different and better way. The soundex function returns a letter and a three-digit code that maps just the beginning of the input string, whereas Metaphone returns a code as letters of variable length. For example:

                            soundex  metaphone  

    Christiansen            C623     KRSXNSN
    Kris Jenson             K625     KRSJNSN

    Kyrie Eleison           K642     KRLSN
    Curious Liaison         C624     KRSLSN

To get the most of Metaphone, you should also use the String::Approx module from CPAN, described more fully in Recipe 6.13. It allows for there to be errors in the match and still be successful. The edit distance is the number of changes needed to go from one string to the next. This matches a pair of strings with an edit distance of two:

if (amatch("string1", [2], "string2") {  }

There’s also an adist function that reports the edit distance. The edit distance between “Kris Jenson” “Christiansen” is 6, but between their Metaphone encodings is only 1. Likewise, the distance between the other pair is 8 originally, but down to 1 again if you compare Metaphone encodings.

use Text::Metaphone qw(Metaphone);
use String::Approx  qw(amatch);

if (amatch(Metaphone($s1), [1], Metaphone($s1)) {
    print "Close enough!\n";
}

This would successfully match both of our example pairs.
See Also

The documentation for the standard Text::Soundex and User::pwent modules; the Text::Metaphone and String::Approx modules from CPAN; your system’s passwd(5) manpage; Volume 3, Chapter 6 of The Art of Computer Programming, by Donald E. Knuth (Addison-Wesley)

		6.2.23 Program: fixstyle

Imagine you have a table with both old and new strings, such as the following:

Old words
	

New words

bonnet
	

hood

rubber
	

eraser

lorry
	

truck

trousers
	

pants

The program in Example 1-4 is a filter that changes all occurrences of each element in the first set to the corresponding element in the second set.

When called without filename arguments, the program is a simple filter. If filenames are supplied on the command line, an in-place edit writes the changes to the files, with the original versions saved in a file with a ".orig" extension. See Recipe 7.16 for a description. A -v command-line option writes notification of each change to standard error.

The table of original strings and their replacements is stored below _ _END_ _ in the main program, as described in Recipe 7.12. Each pair of strings is converted into carefully escaped substitutions and accumulated into the $code variable like the popgrep2 program in Recipe 6.10.

A -t check to test for an interactive run check tells whether we’re expecting to read from the keyboard if no arguments are supplied. That way if users forget to give an argument, they aren’t wondering why the program appears to be hung.
Example 1-4. fixstyle

    #!/usr/bin/perl -w
    # fixstyle - switch first set of <DATA> strings to second set
    #   usage: $0 [-v] [files ...]
    use strict;
    my $verbose = (@ARGV && $ARGV[0] eq '-v' && shift);
    if (@ARGV) {
      $^I = ".orig";          # preserve old files
    } else {
      warn "$0: Reading from stdin\n" if -t STDIN;
    }
    my $code = "while (<>) {\n";
    # read in config, build up code to eval
    while (<DATA>) {
      chomp;
      my ($in, $out) = split /\s*=>\s*/;
      next unless $in && $out;
      $code .= "s{\\Q$in\\E}{$out}g";
      $code .= "&& printf STDERR qq($in => $out at \$ARGV line \$.\\n)"
                                                          if $verbose;
      $code .= ";\n";
    }
    $code .= "print;\n}\n";
    eval "{ $code } 1" || die;
    _ _END_ _
    analysed        => analyzed
    built-in        => builtin
    chastized       => chastised
    commandline     => command-line
    de-allocate     => deallocate
    dropin          => drop-in
    hardcode        => hard-code
    meta-data       => metadata
    multicharacter  => multi-character
    multiway        => multi-way
    non-empty       => nonempty
    non-profit      => nonprofit
    non-trappable   => nontrappable
    pre-define      => predefine
    preextend       => pre-extend
    re-compiling    => recompiling
    reenter         => re-enter
    turnkey         => turn-key

One caution: this program is fast, but it doesn’t scale if you need to make hundreds of changes. The larger the DATA section, the longer it takes. A few dozen changes won’t slow it down, and in fact, the version given in Example 1-4 is faster for that case. But if you run the program on hundreds of changes, it will bog down.

Example 1-5 is a version that’s slower for few changes but faster when there are many changes.
Example 1-5. fixstyle2

    #!/usr/bin/perl -w
    # fixstyle2 - like fixstyle but faster for many many changes
    use strict;
    my $verbose = (@ARGV && $ARGV[0] eq '-v' && shift);
    my %change = ( );
    while (<DATA>) {
      chomp;
      my ($in, $out) = split /\s*=>\s*/;
      next unless $in && $out;
      $change{$in} = $out;
    }
    if (@ARGV) {
      $^I = ".orig";
    } else {
      warn "$0: Reading from stdin\n" if -t STDIN;
    }
    while (<>) {
      my $i = 0;
      s/^(\s+)// && print $1;         # emit leading whitespace
      for (split /(\s+)/, $_, -1) {   # preserve trailing whitespace
          print( ($i++ & 1) ? $_ : ($change{$_} || $_));
      }
    }
    _ _END_ _
    analysed        => analyzed
    built-in        => builtin
    chastized       => chastised
    commandline     => command-line
    de-allocate     => deallocate
    dropin          => drop-in
    hardcode        => hard-code
    meta-data       => metadata
    multicharacter  => multi-character
    multiway        => multi-way
    non-empty       => nonempty
    non-profit      => nonprofit
    non-trappable   => nontrappable
    pre-define      => predefine
    preextend       => pre-extend
    re-compiling    => recompiling
    reenter         => re-enter
    turnkey         => turn-key

This version breaks each line into chunks of whitespace and words, which isn’t a fast operation. It then uses those words to look up their replacements in a hash, which is much faster than a substitution. So the first part is slower, the second faster. The difference in speed depends on the number of matches.

If you don’t care about keeping the whitespace separating each word constant, the second version can run as fast as the first, even for a few changes. If you know a lot about your input, collapse whitespace into single blanks by plugging in this loop:

# very fast, but whitespace collapse
while (<>) {
  for (split) {
      print $change{$_} || $_, " ";
  }
  print "\n";
}

That leaves an extra blank at the end of each line. If that’s a problem, you could use the technique from Recipe 16.5 to install an output filter. Place the following code in front of the while loop that’s collapsing whitespace:

my $pid= open(STDOUT, "|-");
die "cannot fork: $!" unless defined $pid;
unless ($pid) {             # child
      while (<STDIN>) {
      s/ $//;
      print;
  }
  exit;
}
		6.2.24 Program: psgrep

Many programs, including ps, netstat, lsof, ls -l, find -ls, and tcpdump, can produce more output than can be conveniently summarized. Logfiles also often grow too long to be easily viewed. You could send these through a filter like grep to pick out only certain lines, but regular expressions and complex logic don’t mix well; just look at the hoops we jump through in Recipe 6.18.

What we’d really like is to make full queries on the program output or logfile. For example, to ask ps something like, “Show me all processes that exceed 10K in size but which aren’t running as the superuser” or “Which commands are running on pseudo-ttys?”

The psgrep program does this—and infinitely more—because the specified selection criteria are not mere regular expressions; they’re full Perl code. Each criterion is applied in turn to every line of output. Only lines matching all arguments are output. The following is a list of things to find and how to find them.

Lines containing “sh” at the end of a word:

% psgrep '/sh\b/'

Processes whose command names end in “sh”:

% psgrep 'command =~ /sh$/'

Processes running with a user ID below 10:

% psgrep 'uid < 10'

Login shells with active ttys:

% psgrep 'command =~ /^-/' 'tty ne "?"'

Processes running on pseudo-ttys:

% psgrep 'tty =~ /^[p-t]/'

Non-superuser processes running detached:

% psgrep 'uid && tty eq "?"'

Huge processes that aren’t owned by the superuser:

% psgrep 'size > 10 * 2**10' 'uid != 0'

The last call to psgrep produced the following output when run on our system. As one might expect, only netscape and its spawn qualified.

            FLAGS   UID   PID  PPID PRI  NI   SIZE   RSS WCHAN     STA TTY TIME COMMAND
            0   101  9751     1   0   0  14932  9652 do_select S   p1  0:25 netscape
            100000   101  9752  9751   0   0  10636   812 do_select S   p1  0:00 (dns helper)

Example 1-6 shows the psgrep program.
Example 1-6. psgrep

    #!/usr/bin/perl -w
    # psgrep - print selected lines of ps output by
    #          compiling user queries into code
    use strict;
    # each field from the PS header
    my @fieldnames = qw(FLAGS UID PID PPID PRI NICE SIZE
                      RSS WCHAN STAT TTY TIME COMMAND);
    # determine the unpack format needed (hard-coded for Linux ps)
    my $fmt = cut2fmt(8, 14, 20, 26, 30, 34, 41, 47, 59, 63, 67, 72);
    my %fields;                         # where the data will store
    die << Thanatos unless @ARGV;
    usage: $0 criterion ...
      Each criterion is a Perl expression involving:
       @fieldnames
      All criteria must be met for a line to be printed.
    Thanatos
    # Create function aliases for uid, size, UID, SIZE, etc.
    # Empty parens on closure args needed for void prototyping.
    for my $name (@fieldnames) {
      no strict 'refs';
      *$name = *{lc $name} = sub ( ) { $fields{$name} };
    }
    my $code = "sub is_desirable { " . join(" and ", @ARGV) . " } ";
    unless (eval $code.1) {
      die "Error in code: $@\n\t$code\n";
    }
    open(PS, "ps wwaxl |")              || die "cannot fork: $!";
    print scalar <PS>;                  # emit header line
    while (<PS>) {
      @fields{@fieldnames} = trim(unpack($fmt, $_));
      print if is_desirable( );        # line matches their criteria
    }
    close(PS)                           || die "ps failed!";
    # convert cut positions to unpack format
    sub cut2fmt {
      my(@positions) = @_;
      my $template  = '';
      my $lastpos   = 1;
      for my $place (@positions) {
          $template .= "A" . ($place - $lastpos) . " ";
          $lastpos   = $place;
      }
      $template .= "A*";
      return $template;
    }
    sub trim {
      my @strings = @_;
      for (@strings) {
          s/^\s+//;
          s/\s+$//;
      }
      return wantarray ? @strings : $strings[0];
    }
    # the following was used to determine column cut points.
    # sample input data follows
    #123456789012345678901234567890123456789012345678901234567890123456789012345
    #         1         2         3         4         5         6         7
    # Positioning:
    #       8     14    20    26  30  34     41    47          59  63  67   72
    #       |     |     |     |   |   |      |     |           |   |   |    |
    _ _END_ _
FLAGS   UID   PID  PPID PRI  NI   SIZE   RSS WCHAN       STA TTY TIME COMMAND
               100     0     1     0   0   0    760   432 do_select   S   ?   0:02 init
               140     0   187     1   0   0    784   452 do_select   S   ?   0:02 syslogd
               100100   101   428     1   0   0   1436   944 do_exit     S    1  0:00 /bin/login
               100140    99 30217   402   0   0   1552  1008 posix_lock_ S   ?   0:00 httpd
               0   101   593   428   0   0   1780  1260 copy_thread S    1  0:00 -tcsh
               100000   101 30639  9562  17   0    924   496             R   p1  0:00 ps axl
               0   101 25145  9563   0   0   2964  2360 idetape_rea S   p2  0:06 trn
               100100     0 10116  9564   0   0   1412   928 setup_frame T   p3  0:00 ssh -C www
               100100     0 26560 26554   0   0   1076   572 setup_frame T   p2  0:00 less
               100000   101 19058  9562   0   0   1396   900 setup_frame T   p1  0:02 nvi /tmp/a

The psgrep program integrates many techniques presented throughout this book. Stripping strings of leading and trailing whitespace is found in Recipe 1.19. Converting cut marks into an unpack format to extract fixed fields is in Recipe 1.1. Matching strings with regular expressions is the entire topic of Chapter 6.

The multiline string in the here document passed to die is discussed in Recipe 1.15 and Recipe 1.16. The assignment to @fields{@fieldnames} sets many values at once in the hash named %fields. Hash slices are discussed in Recipe 4.8 and Recipe 5.11.

The sample program input contained beneath _ _END_ _ is described in Recipe 7.12. During development, we used canned input from the DATA filehandle for testing purposes. Once the program worked properly, we changed it to read from a piped-in ps command but left a remnant of the original filter input to aid in future porting and maintenance. Launching other programs over a pipe is covered in Chapter 16, including Recipe 16.10 and Recipe 16.13.

The real power and expressiveness in psgrep derive from Perl’s use of string arguments not as mere strings but directly as Perl code. This is similar to the technique in Recipe 9.9, except that in psgrep, the user’s arguments are wrapped with a routine called is_desirable. That way, the cost of compiling strings into Perl code happens only once, before the program whose output we’ll process is even begun. For example, asking for UIDs under 10 creates this string to eval:

eval "sub is_desirable { uid < 10 } " . 1;

The mysterious ".1" at the end is so that if the user code compiles, the whole eval returns true. That way we don’t even have to check $@ for compilation errors as we do in Recipe 10.12.

Specifying arbitrary Perl code in a filter to select records is a breathtakingly powerful approach, but it’s not entirely original. Perl owes much to the awk programming language, which is often used for such filtering. One problem with awk is that it can’t easily treat input as fixed-size fields instead of fields separated by something. Another is that the fields are not mnemonically named: awk uses $1, $2, etc. Plus, Perl can do much that awk cannot.

The user criteria don’t even have to be simple expressions. For example, this call initializes a variable $id to user nobody’s number to use later in its expression:

% psgrep 'no strict "vars";
        BEGIN { $id= getpwnam("nobody") }
        uid=  = $id '

How can we use unquoted words without even a dollar sign, like uid, command, and size, to represent those respective fields in each input record? We directly manipulate the symbol table by assigning closures to indirect typeglobs, which creates functions with those names. The function names are created using both uppercase and lowercase names, allowing both "UID < 10" and "uid > 10“. Closures are described in Recipe 11.4, and assigning them to typeglobs to create function aliases is shown in Recipe 10.14.

One twist here not seen in those recipes is empty parentheses on the closure. These allowed us to use the function in an expression anywhere we’d use a single term, like a string or a numeric constant. It creates a void prototype so the field-accessing function named uid accepts no arguments, just like the built-in function time. If these functions weren’t prototyped void, expressions like "uid < 10" or "size/2 > rss" would confuse the parser because it would see the unterminated start of a wildcard glob and of a pattern match, respectively. Prototypes are discussed in Recipe 10.11.

The version of psgrep demonstrated here expects the output from Red Hat Linux’s ps. To port to other systems, look at which columns the headers begin at. This approach isn’t relevant only to ps or only to Unix systems; it’s a generic technique for filtering input records using Perl expressions, easily adapted to other record layouts. The input format could be in columns, space separated, comma separated, or the result of a pattern match with capturing parentheses.

The program could even be modified to handle a user-defined database with a small change to the selection functions. If you had an array of records as described in Recipe 11.9, you could let users specify arbitrary selection criteria, such as:

sub id( )         { $_->{ID}   }
sub title( )      { $_->{TITLE} }
sub executive( )  { title =~ /(?:vice-)?president/i }

# user search criteria go in the grep clause
@slowburners = grep { id<10 && !executive } @employees;

For reasons of security and performance, this kind of power is seldom found in database engines like those described in Chapter 14. SQL doesn’t support this, but given Perl and small bit of ingenuity, it’s easy to roll it up on your own.

	6.3 Numbers

		6.3.1 Introduction

Numbers, the most basic data type of almost any programming language, can be surprisingly tricky. Random numbers, numbers with decimal points, series of numbers, and conversion between strings and numbers all pose trouble.

Perl works hard to make life easy for you, and the facilities it provides for manipulating numbers are no exception to that rule. If you treat a scalar value as a number, Perl converts it to one. This means that when you read ages from a file, extract digits from a string, or acquire numbers from any of the other myriad textual sources that Real Life pushes your way, you don’t need to jump through the hoops created by other languages’ cumbersome requirements to turn an ASCII string into a number.

Perl tries its best to interpret a string as a number when you use it as one (such as in a mathematical expression), but it has no direct way of reporting that a string doesn’t represent a valid number. Perl quietly converts non-numeric strings to zero, and it will stop converting the string once it reaches a non-numeric character—so "A7" is still 0, and "7A" is just 7. (Note, however, that the -w flag will warn of such improper conversions.) Sometimes, such as when validating input, you need to know whether a string represents a valid number. We show you how in Recipe 2.1.

Recipe 2.15 shows how to get a number from strings containing hexadecimal, octal, or binary representations of numbers such as "0xff“, "0377“, and "0b10110“. Perl automatically converts numeric literals of these non-decimal bases that occur in your program code (so $a = 3 + 0xff will set $a to 258) but not data read by that program (you can’t read "ff" or even "0xff" into $b and then say $a = 3 + $b to make $a become 258).

As if integers weren’t giving us enough grief, floating-point numbers can cause even more headaches. Internally, a computer represents numbers with decimal points as floating-point numbers in binary format. Floating-point numbers are not the same as real numbers; they are an approximation of real numbers, with limited precision. Although infinitely many real numbers exist, you only have finite space to represent them, usually about 64 bits or so. You have to cut corners to fit them all in.

When numbers are read from a file or appear as literals in your program, they are converted from their textual representation—which is always in base 10 for numbers with decimal points in them—into an internal, base-2 representation. The only fractional numbers that can be exactly represented using a finite number of digits in a particular numeric base are those that can be written as the sum of a finite number of fractions whose denominators are integral powers of that base.

For example, 0.13 is one tenth plus three one-hundredths. But that’s in base-10 notation. In binary, something like 0.75 is exactly representable because it’s the sum of one half plus one quarter, and 2 and 4 are both powers of two. But even so simple a number as one tenth, written as 0.1 in base-10 notation, cannot be rewritten as the sum of some set of halves, quarters, eighths, sixteenths, etc. That means that, just as one third can’t be exactly represented as a non-repeating decimal number, one tenth can’t be exactly represented as a non-repeating binary number. Your computer’s internal binary representation of 0.1 isn’t exactly 0.1; it’s just an approximation!

| $ perl -e 'printf "%.60f\n", 0.1'
| 0.100000000000000005551115123125782702118158340454101562500000

Recipe 2.2 and Recipe 2.3 demonstrate how to make your computer’s floating-point representations behave more like real numbers.

Recipe 2.4 gives three ways to perform one operation on each element of a set of consecutive integers. We show how to convert to and from Roman numerals in Recipe 2.5.

Random numbers are the topic of several recipes. Perl’s rand function returns a floating-point value between 0 and 1, or between 0 and its argument. We show how to get random numbers in a given range, how to make random numbers more random, and how to make rand give a different sequence of random numbers each time you run your program.

We round out the chapter with recipes on trigonometry, logarithms, matrix multiplication, complex numbers, and the often-asked question: “How do you put commas in numbers?”

		6.3.2 Checking Whether a String Is a Valid Number
Problem

You want to check whether a string represents a valid number. This is a common problem when validating input, as in CGI scripts, configuration files, and command-line arguments.
Solution

Compare it against a regular expression that matches the kinds of numbers you’re interested in:

if ($string =~ /PATTERN/) {
    # is a number
} else {
    # is not
}

Or use the patterns provided by the CPAN module Regexp::Common:

if ($string =~ m{^$RE{num}{real}$}) {
    # is a real number
} else {
    # is not
}

Discussion

This problem gets to the heart of what we mean by a number. Even things that sound simple, like integer, make you think hard about what you will accept; for example, “Is a leading + for positive numbers optional, mandatory, or forbidden?” The many ways that floating-point numbers can be represented could overheat your brain.

Decide what you will and will not accept. Then, construct a regular expression to match those things alone. Here are some precooked solutions (the Cookbook’s equivalent of just-add-water meals) for most common cases:

warn "has nondigits"        if     /\D/;
warn "not a natural number" unless /^\d+$/;             # rejects -3
warn "not an integer"       unless /^-?\d+$/;           # rejects +3
warn "not an integer"       unless /^[+-]?\d+$/;
warn "not a decimal number" unless /^-?\d+\.?\d*$/;     # rejects .2
warn "not a decimal number" unless /^-?(?:\d+(?:\.\d*)?|\.\d+)$/;
warn "not a C float"
       unless /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;

These lines do not catch the IEEE notations of “Infinity” and “NaN”, but unless you’re worried that IEEE committee members will stop by your workplace and beat you over the head with copies of the relevant standards documents, you can probably forget about these strange forms.

If your number has leading or trailing whitespace, those patterns won’t work. Either add the appropriate logic directly, or call the trim function from Recipe 1.19.

The CPAN module Regexp::Common provides a wealth of canned patterns that test whether a string looks like a number. Besides saving you from having to figure out the patterns on your own, it also makes your code more legible. By default, this module exports a hash called %RE that you index into, according to which kind of regular expression you’re looking for. Be careful to use anchors as needed; otherwise, it will search for that pattern anywhere in the string. For example:

use Regexp::Common;
$string = "Gandalf departed from the Havens in 3021 TA.";
print "Is an integer\n"           if $string =~ / ^   $RE{num}{int}  $ /x;
print "Contains the integer $1\n" if $string =~ /   ( $RE{num}{int} )  /x;

The following examples are other patterns that the module can use to match numbers:

$RE{num}{int}{-sep=>',?'}              # match 1234567 or 1,234,567
$RE{num}{int}{-sep=>'.'}{-group=>4}    # match 1.2345.6789
$RE{num}{int}{-base => 8}              # match 014 but not 99
$RE{num}{int}{-sep=>','}{-group=3}     # match 1,234,594
$RE{num}{int}{-sep=>',?'}{-group=3}    # match 1,234 or 1234
$RE{num}{real}                         # match 123.456 or -0.123456
$RE{num}{roman}                        # match xvii or MCMXCVIII
$RE{num}{square}                       # match 9 or 256 or 12321

Some of these patterns, such as square, were not available in early module versions. General documentation for the module can be found in the Regexp::Common manpage, but more detailed documentation for just the numeric patterns is in the Regexp::Common::number manpage.

Some techniques for identifying numbers don’t involve regular expressions. Instead, these techniques use functions from system libraries or Perl to determine whether a string contains an acceptable number. Of course, these functions limit you to the definition of “number” offered by your libraries and Perl.

If you’re on a POSIX system, Perl supports the POSIX::strtod function. Its semantics are cumbersome, so the following is a getnum wrapper function for more convenient access. This function takes a string and returns either the number it found or undef for input that isn’t a C float. The is_numeric function is a frontend to getnum for when you just want to ask, “Is this a float?”

sub getnum {
    use POSIX qw(strtod);
    my $str = shift;
    $str =~ s/^\s+//;           # remove leading whitespace
    $str =~ s/\s+$//;           # remove trailing whitespace
    $! = 0;
    my($num, $unparsed) = strtod($str);
    if (($str eq '') || ($unparsed != 0) || $!) {
        return;
    } else {
        return $num;
    } 
} 

sub is_numeric { defined scalar &getnum }

The Scalar::Util module, newly standard as of Perl v5.8.1, exports a function called looks_like_number( ) that uses the Perl compiler’s own internal function of the same name (see perlapi(1)). It returns true for any base-10 number that is acceptable to Perl itself, such as 0, 0.8, 14.98, and 6.02e23—but not 0xb1010, 077, 0x392, or numbers with underscores in them. This means that you must check for alternate bases and decode them yourself if you want to permit users to enter such numbers, as in Example 2-1.
Example 2-1. Decode numbers

    #!/usr/bin/perl -w
    use Scalar::Util qw(looks_like_number);
    print "$0: hit ^D (your eof character) to exit\n";
    for (;;) {
        my ($on, $n);      # original string and its numeric value 
        print "Pick a number, any number: ";
        $on = $n = <STDIN>;
        last if !defined $n;
        chomp($on,$n);
        $n =~ s/_//g;                      # allow 186_282.398_280_685
        $n = oct($n) if $n =~ /^0/;  # allow 0xFF, 037, 0b1010
        if (looks_like_number($n)) {
            printf "Decimal double of $on is %g\n", 2*$n;
        } else {
            print "That doesn't look like a number to Perl.\n";
        }
    }
    print "\nBye.\n";

See Also

The regular expression syntax in perlre(1) and Chapter 5 of Programming Perl; your system’s strtod(3) manpage; the perlapi(1) manpage; the documentation for the CPAN module Regexp::Common, including the Regexp::Common::number manpage; the documentation for the standard POSIX and Scalar::Util modules (also in Chapter 32 of Programming Perl)

		6.3.3 Rounding Floating-Point Numbers
Problem

You want to round a floating-point value to a certain number of decimal places. This problem arises from the same inaccuracies in representation that make testing for equality difficult (see Recipe 2.3), as well as in situations where you must reduce the precision of your answers for readability.
Solution

Use the Perl function sprintf, or printf if you’re just trying to produce output:

# round off to two places
$rounded = sprintf("%.2f", $unrounded);

Or you can use other rounding functions described in the Discussion.
Discussion

Whether visible or not, rounding of some sort is virtually unavoidable when working with floating-point numbers. Carefully defined standards (namely, IEEE 754, the standard for binary floating-point arithmetic) coupled with reasonable defaults within Perl often manage to eliminate or at least hide these round-off errors.

In fact, Perl’s implicit rounding on output is usually good enough so that it rarely surprises. It’s almost always best to leave the numbers unrounded until output, and then, if you don’t like Perl’s default rounding, use printf or sprintf yourself with a format that makes the rounding explicit. The %f, %e, and %g formats all let you specify how many decimal places to round their argument to. Here’s an example showing how all three behave; in each case, we’re asking for a field that’s 12 spaces wide, but with a precision of no more than four digits to the right of the decimal place.

for $n ( 0.0000001, 10.1, 10.00001, 100000.1 ) {
    printf "%12.4e %12.4f %12.4g\n", $n, $n, $n;
}

This produces the following output:

1.0000e-07       0.0000        1e-07
1.0100e+01      10.1000         10.1
1.0000e+01      10.0000           10
1.0000e+05  100000.1000        1e+05

If that were all there were to the matter, rounding would be pretty easy. You’d just pick your favorite output format and be done with it.

However, it’s not that easy: sometimes you need to think more about what you really want and what’s really happening. As we explained in the Introduction, even a simple number like 10.1 or 0.1 can only be approximated in binary floating-point. The only decimal numbers that can be exactly represented as floating-point numbers are those that can be rewritten as a finite sum of one or more fractions whose denominators are all powers of two. For example:

$a = 0.625;                # 1/2 + 1/8
$b = 0.725;                # 725/1000, or 29/40
printf "$_ is %.30g\n", $_ for $a, $b;

prints out:

0.625 is 0.625
0.725 is 0.724999999999999977795539507497

The number in $a is exactly representable in binary, but the one in $b is not. When Perl is told to print a floating-point number but not told the precision, as occurs for the interpolated value of $_ in the string, it automatically rounds that number to however many decimal digits of precision that your machine supports. Typically, this is like using an output format of "%.15g“, which, when printed, produces the same number as you assigned to $b.

Usually the round-off error is so small you never even notice it, and if you do, you can always specify how much precision you’d like in your output. But because the underlying approximation is still a little bit off from what a simple print might show, this can produce unexpected results. For example, while numbers such as 0.125 and 0.625 are exactly representable, numbers such as 0.325 and 0.725 are not. So let’s suppose you’d like to round to two decimal places. Will 0.325 become 0.32 or 0.33? Will 0.725 become 0.72 or 0.73?

$a = 0.325;                # 1/2 + 1/8
$b = 0.725;                # 725/1000, or 29/40
printf "%s is %.2f or %.30g\n", ($_) x 3 for $a, $b;

This produces:

0.325 is 0.33 or 0.325000000000000011102230246252
0.725 is 0.72 or 0.724999999999999977795539507497

Since 0.325’s approximation is a bit above that, it rounds up to 0.33. On the other hand, 0.725’s approximation is really a little under that, so it rounds down, giving 0.72 instead.

But what about if the number is exactly representable, such 1.5 or 7.5, since those are just whole numbers plus one-half? The rounding rule used in that case is probably not the one you learned in grade school. Watch:

for $n (-4 .. +4) {
    $n += 0.5;
    printf "%4.1f %2.0f\n", $n, $n;
}

That produces this:

-3.5 -4
-2.5 -2
-1.5 -2
-0.5 -0
 0.5  0
 1.5  2
 2.5  2
 3.5  4
 4.5  4

What’s happening is that the rounding rule preferred by numerical analysts isn’t “round up on a five,” but instead “round toward even.” This way the bias in the round-off error tends to cancel itself out.

Three useful functions for rounding floating-point values to integral ones are int, ceil, and floor. Built into Perl, int returns the integral portion of the floating-point number passed to it. This is called “rounding toward zero.” This is also known as integer truncation because it ignores the fractional part: it rounds down for positive numbers and up for negative ones. The POSIX module’s floor and ceil functions also ignore the fractional part, but they always round down and up to the next integer, respectively, no matter the sign.

use POSIX qw(floor ceil);
printf "%8s %8s %8s %8s %8s\n", 
    qw(number even zero down up);
for $n (-6 .. +6) {
    $n += 0.5;
    printf "%8g %8.0f %8s %8s %8s\n", 
            $n, $n, int($n), floor($n), ceil($n);
}

This produces the following illustrative table; each column heading shows what happens when you round the number in the specified direction.

number     even     zero     down       up
  -5.5       -6       -5       -6       -5
  -4.5       -4       -4       -5       -4
  -3.5       -4       -3       -4       -3
  -2.5       -2       -2       -3       -2
  -1.5       -2       -1       -2       -1
  -0.5       -0        0       -1        0
   0.5        0        0        0        1
   1.5        2        1        1        2
   2.5        2        2        2        3
   3.5        4        3        3        4
   4.5        4        4        4        5
   5.5        6        5        5        6
   6.5        6        6        6        7

If you add up each column, you’ll see that you arrive at rather different totals:

   6.5        6        6        0       13

What this tells you is that your choice of rounding style—in effect, your choice of round-off error—can have tremendous impact on the final outcome. That’s one reason why you’re strongly advised to wait until final output for any rounding. Even still, some algorithms are more sensitive than others to accumulation of round-off error. In particularly delicate applications, such as financial computations and thermonuclear missiles, prudent programmers will implement their own rounding functions instead of relying on their computers’ built-in logic, or lack thereof. (A good textbook on numerical analysis is also recommended.)
See Also

The sprintf and int functions in perlfunc(1) and Chapter 29 of Programming Perl; the floor and ceil entries in the documentation for the standard POSIX module (also in Chapter 32 of Programming Perl); we introduce the sprintf technique in Recipe 2.3

		6.3.4 Comparing Floating-Point Numbers
Problem

Floating-point arithmetic isn’t exact. You want to compare two floating-point numbers and know whether they’re equal when carried out to a certain number of decimal places. Most of the time, this is the way you should compare floating-point numbers for equality.
Solution

Use sprintf to format the numbers to a certain number of decimal places, then compare the resulting strings:

# equal(NUM1, NUM2, PRECISION) : returns true if NUM1 and NUM2 are
# equal to PRECISION number of decimal places
sub equal {
    my ($A, $B, $dp) = @_;
    return sprintf("%.${dp}g", $A) eq sprintf("%.${dp}g", $B);
  }

Alternatively, store the numbers as integers by assuming the decimal place.
Discussion

You need the equal routine because computers’ floating-point representations are just approximations of most real numbers, as we discussed in the Introduction to this chapter. Perl’s normal printing routines display numbers rounded to 15 decimal places or so, but its numeric tests don’t round. So sometimes you can print out numbers that look the same (after rounding) but do not test the same (without rounding).

This problem is especially noticeable in a loop, where round-off error can silently accumulate. For example, you’d think that you could start a variable out at zero, add one-tenth to it ten times, and end up with one. Well, you can’t, because a base-2 computer can’t exactly represent one-tenth. For example:

for ($num = $i = 0; $i < 10; $i++) { $num += 0.1 }
if ($num != 1) {
    printf "Strange, $num is not 1; it's %.45f\n", $num;
}

prints out:

               Strange, 1 is not 1; it's 0.999999999999999888977697537484345957636833191

The $num is interpolated into the double-quoted string using a default conversion format of "%.15g" (on most systems), so it looks like 1. But internally, it really isn’t. If you had checked only to a few decimal places, for example, five:

!equal($num, 1, 5)

then you’d have been okay.

If you have a fixed number of decimal places, as with currency, you can often sidestep the problem by storing your values as integers. Storing $3.50 as 350 instead of 3.5 removes the need for floating-point values. Reintroduce the decimal point on output:

$wage = 536;                # $5.36/hour
$week = 40 * $wage;         # $214.40
printf("One week's wage is: \$%.2f\n", $week/100);

One week's wage is: $214.40

It rarely makes sense to compare more than 15 decimal places, because you probably only have that many digits of precision in your computer’s hardware.
See Also

The sprintf function in perlfunc(1) and Chapter 29 of Programming Perl; the entry on $OFMT in the perlvar(1) manpage and Chapter 28 of Programming Perl; the documentation for the standard Math::BigFloat module (also in Chapter 32 of Programming Perl); we use sprintf in Recipe 2.2; Volume 2, Section 4.2.2 of The Art of Computer Programming

		6.3.5 Operating on a Series of Integers
Problem

You want to perform an operation on all integers between X and Y, such as when you’re working on a contiguous section of an array or wherever you want to process all numbers[1] within a range.
Solution

Use a for loop, or .. in conjunction with a foreach loop:

foreach ($X .. $Y) {
    # $_ is set to every integer from X to Y, inclusive
}

foreach $i ($X .. $Y) {
    # $i is set to every integer from X to Y, inclusive
}

for ($i = $X; $i <= $Y; $i++) {
    # $i is set to every integer from X to Y, inclusive
}

for ($i = $X; $i <= $Y; $i += 7) {
    # $i is set to every integer from X to Y, stepsize = 7
}

Discussion

The first two approaches use a foreach loop in conjunction with the $X .. $Y construct, which creates a list of integers between $X and $Y. Now, if you were just assigning that range to an array, this would use up a lot of memory whenever $X and $Y were far apart. But in a foreach loop, Perl notices this and doesn’t waste time or memory allocating a temporary list. When iterating over consecutive integers, the foreach loop will run faster than the equivalent for loop.

Another difference between the two constructs is that the foreach loop implicitly localizes the loop variable to the body of the loop, but the for loop does not. That means that after the for loop finishes, the loop variable will contain the value it held upon the final iteration. But in the case of the foreach loop, that value will be inaccessible, and the variable will hold whatever it held—if anything—prior to entering the loop. You can, however, use a lexically scoped variable as the loop variable:

foreach my $i ($X .. $Y)       { ... }
for (my $i=$X; $i <= $Y; $i++) { ... }

The following code shows each technique. Here we just print the numbers we generate:

print "Infancy is: ";
foreach (0 .. 2) {
    print "$_ ";
}
print "\n";

print "Toddling is: ";
foreach $i (3 .. 4) {
    print "$i ";
}
print "\n";

print "Childhood is: ";
for ($i = 5; $i <= 12; $i++) {
    print "$i ";
}
print "\n";

Infancy is: 0 1 2
               Toddling is: 3 4
               Childhood is: 5 6 7 8 9 10 11 12

See Also

The for and foreach operators in perlsyn(1) and the “For Loops” and “Foreach Loops” sections of Chapter 4 of Programming Perl

-> My example
[yizaq@YIZAQ-M-D1BW:Wed Apr 15:~/Desktop/Work/tools/ditaa:]$ perl -e 'foreach (1..10) {print "$_\n"};'
1
2
3
4
5
6
7
8
9
10
[yizaq@YIZAQ-M-D1BW:Wed Apr 15:~/Desktop/Work/tools/ditaa:]$ perl -e 'foreach $i (1..10) {print "$i\n"};'
1
2
3
4
5
6
7
8
9
10
[yizaq@YIZAQ-M-D1BW:Wed Apr 15:~/Desktop/Work/tools/ditaa:]$ perl -e 'for ($i=0; $i<10; $i++) {print "$i\n"};'
0
1
2
3
4
5
6
7
8
9

->
		6.3.6 Working with Roman Numerals
Problem

You want to convert between regular numbers and Roman numerals. You need to do this with items in outlines, page numbers on a preface, and copyrights for movie credits.
Solution

Use the Roman module from CPAN:

use Roman;
$roman = roman($arabic);                        # convert to roman numerals
$arabic = arabic($roman) if isroman($roman);    # convert from roman numerals

Discussion

The Roman module provides both Roman and roman for converting Arabic (“normal”) numbers to their Roman equivalents. Roman produces uppercase letters, whereas roman gives lowercase ones.

The module only deals with Roman numbers from 1 to 3999, inclusive. The Romans didn’t represent negative numbers or zero, and 5000 (which 4000 is represented in terms of) uses a symbol outside the ASCII character set.

use Roman;
$roman_fifteen = roman(15);                         # "xv"
print "Roman for fifteen is $roman_fifteen\n";
$arabic_fifteen = arabic($roman_fifteen);
print "Converted back, $roman_fifteen is $arabic_fifteen\n";

Roman for fifteen is xv
               Converted back, xv is 15

Or to print the current year:

use Time::localtime;
use Roman;
printf "The year is now %s\n", Roman(1900 + localtime->year);

The year is now MMIII

Now, if you happen to have Unicode fonts available, you’ll find that code points U+2160 through U+2183 represent Roman numerals, including those beyond the typical ASCII values.

use charnames ":full";
print "2003 is", "\N{ROMAN NUMERAL ONE THOUSAND}" x 2, "\N{ROMAN NUMERAL THREE}\n";

2003 is Ⅿ Ⅿ Ⅲ

However, the Roman module doesn’t yet have an option to use those characters.

Believe it or not, there’s even a CPAN module that lets you use Roman numerals in arithmetic.

use Math::Roman qw(roman);
print $a  = roman('I'); #  I
print $a += 2000;       #  MMI
print $a -= "III";      #  MCMXCVIII
print $a -= "MCM";      #  XCVIII

See Also

The Encyclopaedia Britannica article on “Mathematics, History Of”; the documentation with the CPAN modules Roman and Math::Roman; Recipe 6.23

		6.3.7 Generating Random Numbers
Problem

You want to make random numbers in a given range, inclusive, such as when you randomly pick an array index, simulate rolling a die in a game of chance, or generate a random password.
Solution

Use Perl’s rand function:

$random = int( rand( $Y-$X+1 ) ) + $X;

Discussion

This code generates and prints a random integer between 25 and 75, inclusive:

$random = int( rand(51)) + 25;
print "$random\n";

The rand function returns a fractional number, from (and including) 0 up to (but not including) its argument. We give it an argument of 51 to get a number that can be 0 or more, but never 51 or more. We take the integer portion of this to get a number from 0 to 50, inclusive (50.99999.... will be turned into 50 by int). We then add 25 to it to get a number from 25 to 75, inclusive.

A common application of this is the random selection of an element from an array:

$elt = $array[ rand @array ];

That’s just like saying:

$elt = $array[ int( rand(0+@array) ) ];

Because rand is prototyped to take just one argument, it implicitly imposes scalar context on that argument, which, on a named array, is the number of elements in that array. The function then returns a floating-point number smaller than its argument and greater than or equal to zero. A floating-point number used as an array subscript implicitly undergoes integer truncation (rounding toward zero), producing in the end an evenly distributed, randomly selected array element to assign to $elt.

Generating a random password from a sequence of characters is similarly easy:

@chars = ( "A" .. "Z", "a" .. "z", 0 .. 9, qw(! @ $ % ^ & *) );
$password = join("", @chars[ map { rand @chars } ( 1 .. 8 ) ]);

We use map to generate eight random indices into @chars, extract the corresponding characters with a slice, and join them together to form the random password. This isn’t a good random number, though, as its security relies on the choice of seed, which (in older versions of Perl) is based on the time the program started. See Recipe 2.7 for a way to better seed your random number generator.
See Also

The int, rand, map, and join functions in perlfunc(1) and Chapter 29 of Programming Perl; we explore random numbers further in Recipe 2.7, Recipe 2.8, and Recipe 2.9; we use random numbers in Recipe 1.13

		6.3.8 Generating Repeatable Random Number Sequences
Problem

Every time you run your program, you get a different sequence of (pseudo-)random numbers. But you want a reproducible sequence, useful when running a simulation, so you need Perl to produce the same set of random numbers each time.
Solution

Use Perl’s srand function:

srand EXPR;   # use a constant here for repeated sequences

Discussion

Making random numbers is hard. The best that computers can do, without special hardware, is generate “pseudo-random” numbers, which are evenly distributed in their range of values. These are generated using a mathematical formula, which means that given the same seed (starting point), two programs will produce identical pseudo-random numbers.

The srand function creates a new seed for the pseudo-random number generator. If given an argument, it uses that number as the seed. If no argument is given, srand uses a value that’s reasonably difficult to guess as the seed.

If you call rand without first calling srand yourself, Perl calls srand for you, choosing a “good” seed. This way, every time you run your program you’ll get a different set of random numbers. Ancient versions of Perl did not call srand, so the same program always produced the same sequence of pseudo-random numbers every time the program was run. Certain sorts of programs don’t want a different set of random numbers each time; they want the same set. When you need that behavior, call srand yourself, supplying it with a particular seed:

srand( 42 );  # pick any fixed starting point

Don’t call srand more than once in a program, because if you do, you’ll start the sequence again from that point. Unless, of course, that’s what you want.

Just because Perl tries to use a good default seed does not necessarily guarantee that the numbers generated are cryptographically secure against the most intrepid crackers. Textbooks on cryptography are usually good sources of cryptographically secure random number generators.
See Also

The srand function in perlfunc(1) and Chapter 29 of Programming Perl; Recipe 2.6 and Recipe 2.8; Bruce Schneier’s excellent Applied Cryptography (John Wiley & Sons)

		6.3.9 Making Numbers Even More Random
Problem

You want to generate numbers that are more random than Perl’s random numbers. Limitations of your C library’s random number generator seeds can sometimes cause problems. The sequence of pseudo-random numbers may repeat too soon for some applications.
Solution

Use a different random number generator, such as those provided by the Math::Random and Math::TrulyRandom modules from CPAN:

use Math::TrulyRandom;
$random = truly_random_value( );

use Math::Random;
$random = random_uniform( );

Discussion

The Perl build process tries to find the best C-library routine to use for generating pseudo-random numbers, looking at rand(3), random(3), and drand48(3). (This can be changed manually at build time, however.) The standard library functions are getting pretty good, but some ancient implementations of the rand function return only 16-bit random numbers or have other algorithmic weaknesses, and may therefore not be sufficiently random for your purposes.

The Math::TrulyRandom module uses inadequacies of your system’s timers to generate the random numbers. This takes a while, so it isn’t useful for generating a lot of random numbers.

The Math::Random module uses the randlib library to generate random numbers. It also includes a wide range of related functions for generating random numbers according to specific distributions, such as binomial, poisson, and exponential.
See Also

The srand and rand functions in perlfunc(1) and Chapter 29 of Programming Perl; Recipe 2.6 and Recipe 2.7; the documentation for the CPAN modules Math::Random and Math::TrulyRandom 

		6.3.10 Generating Biased Random Numbers
Problem

You want to pick a random value where the probabilities of the values are not equal (the distribution is not even). You might be trying to randomly select a banner to display on a web page, given a set of relative weights saying how often each banner is to be displayed. Alternatively, you might want to simulate behavior according to a normal distribution (the bell curve).
Solution

If you want a random value distributed according to a specific function—e.g., the Gaussian (Normal) distribution—consult a statistics textbook to find the appropriate function or algorithm. This subroutine generates random numbers that are normally distributed, with a standard deviation of 1 and a mean of 0:

sub gaussian_rand {
    my ($u1, $u2);  # uniformly distributed random numbers
    my $w;          # variance, then a weight
    my ($g1, $g2);  # gaussian-distributed numbers

    do {
        $u1 = 2 * rand( ) - 1;
        $u2 = 2 * rand( ) - 1;
        $w = $u1*$u1 + $u2*$u2;
    } while ($w >= 1 || $w =  = 0);

    $w = sqrt( (-2 * log($w))  / $w );
    $g2 = $u1 * $w;
    $g1 = $u2 * $w;
    # return both if wanted, else just one
    return wantarray ? ($g1, $g2) : $g1;
}

If you have a list of weights and values you want to randomly pick from, follow this two-step process: first, turn the weights into a probability distribution with weight_to_dist, and then use the distribution to randomly pick a value with weighted_rand:

# weight_to_dist: takes a hash mapping key to weight and returns
# a hash mapping key to probability
sub weight_to_dist {
    my %weights = @_;
    my %dist    = ( );
    my $total   = 0;
    my ($key, $weight);
    local $_;

    foreach (values %weights) {
        $total += $_;
    }

    while ( ($key, $weight) = each %weights ) {
        $dist{$key} = $weight/$total;
    }

    return %dist;
}

# weighted_rand: takes a hash mapping key to probability, and
# returns the corresponding element
sub weighted_rand {
    my %dist = @_;
    my ($key, $weight);

    while (1) {                     # to avoid floating point inaccuracies
        my $rand = rand;
        while ( ($key, $weight) = each %dist ) {
            return $key if ($rand -= $weight) < 0;
        }
    }
}

Discussion

The gaussian_rand function implements the polar Box Muller method for turning two independent, uniformly distributed random numbers between 0 and 1 (such as rand returns) into two numbers with a mean of 0 and a standard deviation of 1 (i.e., a Gaussian distribution). To generate numbers with a different mean and standard deviation, multiply the output of gaussian_rand by the new standard deviation, and then add the new mean:

# gaussian_rand as shown earlier
$mean = 25;
$sdev = 2;
$salary = gaussian_rand( ) * $sdev + $mean;
printf("You have been hired at \$%.2f\n", $salary);

The Math::Random module implements this and other distributions for you:

use Math::Random qw(random_normal);
$salary = random_normal(1, $mean, $sdev);

The weighted_rand function picks a random number between 0 and 1. It then uses the probabilities generated by weight_to_dist to see which element the random number corresponds to. Because of the vagaries of floating-point representation, accumulated errors in representation might mean we don’t find an element to return. This is why we wrap the code in a while to pick a new random number and try again.

Also, the CPAN module Math::Random has functions to return random numbers from a variety of distributions.
See Also

The rand function in perlfunc(1) and Chapter 29 of Programming Perl; Recipe 2.6; the documentation for the CPAN module Math::Random 

		6.3.11 Doing Trigonometry in Degrees, Not Radians
Problem

You want your trigonometry routines to operate in degrees instead of Perl’s native radians.
Solution

Convert between radians and degrees (2π radians equals 360 degrees):

use constant PI => (4 * atan2 (1, 1));

sub deg2rad {
    my $degrees = shift;
    return ($degrees / 180) * PI;
}

sub rad2deg {
    my $radians = shift;
    return ($radians / PI) * 180;
}

Alternatively, use the standard Math::Trig module:

use Math::Trig;

$radians = deg2rad($degrees);
$degrees = rad2deg($radians);

Discussion

If you’re doing a lot of trigonometry, look into using either the standard Math::Trig or POSIX modules. They provide many more trigonometric functions than are defined in the Perl core. Otherwise, the first solution will define the rad2deg and deg2rad functions. The value of π isn’t built directly into Perl, but you can calculate it to as much precision as your floating-point hardware provides. In the Solution, the PI function is a constant created with use constant. Instead of having to remember that π is 3.14159265358979 or so, we use the built-in function call, resolved at compile time, which, besides sparing us from memorizing a long string of digits, is also guaranteed to provide as much accuracy as the platform supports.

If you’re looking for the sine in degrees, use this:

# deg2rad and rad2deg defined either as above or from Math::Trig
sub degree_sine {
    my $degrees = shift;
    my $radians = deg2rad($degrees);
    my $result = sin($radians);

    return $result;
}

See Also

The sin, cos, and atan2 functions in perlfunc(1) and Chapter 29 of Programming Perl; the documentation for the standard POSIX and Math::Trig modules (also in Chapter 32 of Programming Perl)

		6.3.12 Calculating More Trigonometric Functions
Problem

You want to calculate values for trigonometric functions like sine, tangent, or arc-cosine.
Solution

Perl provides only sin, cos, and atan2 as standard functions. From these, you can derive tan and all other trig functions (if you’re intimately familiar with esoteric trig identities):

sub tan {
    my $theta = shift;

    return sin($theta)/cos($theta);
}

The POSIX module provides a wider range of trig functions:

use POSIX;

$y = acos(3.7);

The standard Math::Trig module provides a complete set of functions and supports operations on or resulting in complex numbers:

use Math::Trig;

$y = acos(3.7);

Discussion

The tan function will cause a division-by-zero exception when $theta is π/2, 3π/2, and so on, because the cosine is 0 for these values. Similarly, tan and many other functions from Math::Trig may generate the same error. To trap these, use eval:

eval {
    $y = tan($pi/2);
} or return undef;

See Also

The sin, cos, and atan2 functions in perlfunc(1) and Chapter 29 of Programming Perl; the documentation for the standard Math::Trig module; we talk about trigonometry in the context of imaginary numbers in Recipe 2.14; we talk about the use of eval to catch exceptions in Recipe 10.12

		6.3.13 Taking Logarithms
Problem

You want to take a logarithm in various bases.
Solution

For logarithms to base e, use the built-in log :

$log_e = log(VALUE);

For logarithms to base 10, use the POSIX module’s log10 function:

use POSIX qw(log10);
$log_10 = log10(VALUE);

For other bases, use the mathematical identity:
Equation 2-1. 
Solution

where x is the number whose logarithm you want, n is the desired base, and e is the natural logarithm base.

sub log_base {
    my ($base, $value) = @_;
    return log($value)/log($base);
}

Discussion

The log_base function lets you take logarithms to any base. If you know the base you’ll want in advance, it’s more efficient to cache the log of the base instead of recalculating it every time.

# log_base as defined earlier
$answer = log_base(10, 10_000);
print "log10(10,000) = $answer\n";
log10(10,000) = 4

The Math::Complex module does the caching for you via its logn( ) routine, so you can write:

use Math::Complex;
printf "log2(1024) = %lf\n", logn(1024, 2); # watch out for argument order!
log2(1024) = 10.000000

even though no complex number is involved here. This is not very efficient, but there are plans to rewrite Math::Complex in C for speed.
See Also

The log function in perlfunc(1) and Chapter 29 of Programming Perl; the documentation for the standard POSIX and Math::Complex modules (also in Chapter 32 of Programming Perl)

		6.3.14 Multiplying Matrices
Problem

You want to multiply a pair of two-dimensional arrays. Mathematicians and engineers often need this.
Solution

Use the PDL modules, available from CPAN. PDL is the Perl Data Language—modules that give fast access to compact matrix and mathematical functions:

use PDL;
# $a and $b are both pdl objects
$c = $a x $b;

Alternatively, apply the matrix multiplication algorithm to your two-dimensional array:

sub mmult {
    my ($m1,$m2) = @_;
    my ($m1rows,$m1cols) = matdim($m1);
    my ($m2rows,$m2cols) = matdim($m2);

    unless ($m1cols =  = $m2rows) {  # raise exception
        die "IndexError: matrices don't match: $m1cols != $m2rows";
    }

    my $result = [  ];
    my ($i, $j, $k);

    for $i (range($m1rows)) {
        for $j (range($m2cols)) {
            for $k (range($m1cols)) {
                $result->[$i][$j] += $m1->[$i][$k] * $m2->[$k][$j];
            }
        }
    }
    return $result;
}

sub range { 0 .. ($_[0] - 1) }

sub veclen {
    my $ary_ref = $_[0];
    my $type = ref $ary_ref;
    if ($type ne "ARRAY") { die "$type is bad array ref for $ary_ref" }
    return scalar(@$ary_ref);
}

sub matdim {
    my $matrix = $_[0];
    my $rows = veclen($matrix);
    my $cols = veclen($matrix->[0]);
    return ($rows, $cols);
}

Discussion

If you have the PDL library installed, you can use its lightning-fast manipulation of numbers. This requires far less memory and CPU than Perl’s array manipulation. When using PDL objects, many numeric operators (such as + and *) are overloaded and work on an element-by-element basis (e.g., * is the so-called scalar multiplication operator). To get true matrix multiplication, use the overloaded x operator.

use PDL;

$a = pdl [
    [ 3, 2, 3 ],
    [ 5, 9, 8 ],
];

$b = pdl [
    [ 4, 7 ],
    [ 9, 3 ],
    [ 8, 1 ],
];

$c = $a x $b;  # x overload

If you don’t have the PDL library, or don’t feel like pulling it in for a small problem, you can always do the work yourself the good old-fashioned way.

# mmult( ) and other subroutines as shown earlier

$x = [
       [ 3, 2, 3 ],
       [ 5, 9, 8 ],
];

$y = [
       [ 4, 7 ],
       [ 9, 3 ],
       [ 8, 1 ],
];

$z = mmult($x, $y);

See Also

The documentation with the CPAN module PDL

		6.3.15 Using Complex Numbers
Problem

Your application must manipulate complex numbers, as are often needed in engineering, science, and mathematics.
Solution

Either keep track of the real and imaginary components yourself:

# $c = $a * $b manually
$c_real = ( $a_real * $b_real ) - ( $a_imaginary * $b_imaginary );
$c_imaginary = ( $a_real * $b_imaginary ) + ( $b_real * $a_imaginary );

or use the Math::Complex module (part of the standard Perl distribution):

# $c = $a * $b using Math::Complex
use Math::Complex;
$c = $a * $b;

Discussion

Here’s how you’d manually multiply 3+5i and 2-2i:

$a_real = 3; $a_imaginary = 5;              # 3 + 5i;
$b_real = 2; $b_imaginary = -2;             # 2 - 2i;
$c_real = ( $a_real * $b_real ) - ( $a_imaginary * $b_imaginary );
$c_imaginary = ( $a_real * $b_imaginary ) + ( $b_real * $a_imaginary );
print "c = ${c_real}+${c_imaginary}i\n";

c = 16+4i

and with Math::Complex:

use Math::Complex;
$a = Math::Complex->new(3,5);               # or Math::Complex->new(3,5);
$b = Math::Complex->new(2,-2);
$c = $a * $b;
print "c = $c\n";

c = 16+4i

You may create complex numbers via the cplx constructor or via the exported constant i:

use Math::Complex;
$c = cplx(3,5) * cplx(2,-2);                # easier on the eye
$d = 3 + 4*i;                               # 3 + 4i
printf "sqrt($d) = %s\n", sqrt($d);

sqrt(3+4i) = 2+i

The Math::Trig module uses the Math::Complex module internally because some functions can break out from the real axis into the complex plane—for example, the inverse sine of 2.
See Also

The documentation for the standard Math::Complex module (also in Chapter 32 of Programming Perl)

		6.3.16 Converting Binary, Octal, and Hexadecimal Numbers
Problem

You want to convert a string (e.g., "0b10110“, "0x55“, or "0755“) containing a binary, octal, or hexadecimal number to the correct number.

Perl understands numbers specified in binary (base-2), octal (base-8), and hexadecimal (base-16) notation only when they occur as literals in your programs. If they come in as data—such as by reading from files or environment variables, or when supplied as command-line arguments—no automatic conversion takes place.
Solution

Use Perl’s hex function if you have a hexadecimal string like "2e" or "0x2e“:

$number = hex($hexadecimal);         # hexadecimal only ("2e" becomes 47)

Use the oct function if you have a hexadecimal string like "0x2e“, an octal string like "047“, or a binary string like "0b101110“:

$number = oct($hexadecimal);         # "0x2e" becomes 47
$number = oct($octal);               # "057"  becomes 47
$number = oct($binary);              # "0b101110" becomes 47

Discussion

The oct function converts octal numbers with or without the leading "0“; for example, "0350" or "350“. Despite its name, oct does more than convert octal numbers: it also converts hexadecimal (”0x350“) numbers if they have a leading "0x" and binary (”0b101010“) numbers if they have a leading "0b“. The hex function converts only hexadecimal numbers, with or without a leading "0x“: "0x255“, "3A“, "ff“, or "deadbeef“. (Letters may be in upper- or lowercase.)

Here’s an example that accepts an integer in decimal, binary, octal, or hex, and prints that integer in all four bases. It uses the oct function to convert the data from binary, octal, and hexadecimal if the input begins with a 0. It then uses printf to convert into all four bases as needed.

print "Gimme an integer in decimal, binary, octal, or hex: ";
$num = <STDIN>;
chomp $num;
exit unless defined $num;
$num = oct($num) if $num =~ /^0/; # catches 077 0b10 0x20
printf "%d %#x %#o %#b\n", ($num) x 4;

The # symbol between the percent and the three non-decimal bases makes printf produce output that indicates which base the integer is in. For example, if you enter the number 255, the output would be:

255 0xff 0377 0b11111111

But without the # sign, you would only get:

255 ff 377 11111111

The following code converts Unix file permissions. They’re always given in octal, so we use oct instead of hex.

print "Enter file permission in octal: ";
$permissions = <STDIN>;
die "Exiting ...\n" unless defined $permissions;
chomp $permissions;
$permissions = oct($permissions);   # permissions always octal
print "The decimal value is $permissions\n";

See Also

The “Scalar Value Constructors” section in perldata(1) and the “Numeric Literals” section of Chapter 2 of Programming Perl; the oct and hex functions in perlfunc(1) and Chapter 29 of Programming Perl

		6.3.17 Putting Commas in Numbers
Problem

You want to output a number with commas in the right places. People like to see long numbers broken up in this way, especially in reports.
Solution

Reverse the string so you can use backtracking to avoid substitution in the fractional part of the number. Then use a regular expression to find where you need commas, and substitute them in. Finally, reverse the string back.

sub commify {
    my $text = reverse $_[0];
    $text =~ s/(\d\d\d)(?=\d)(?!\d*\.)/$1,/g;
    return scalar reverse $text;
}

Discussion

It’s a lot easier in regular expressions to work from the front than from the back. With this in mind, we reverse the string and make a minor change to the algorithm that repeatedly inserts commas three digits from the end. When all insertions are done, we reverse the final string and return it. Because reverse is sensitive to its implicit return context, we force it to scalar context.

This function can easily be adjusted to accommodate the use of periods instead of commas, as are used in many countries.

Here’s an example of commify in action:

# more reasonable web counter :-)
use Math::TrulyRandom;
$hits = truly_random_value( );       # negative hits!
$output = "Your web page received $hits accesses last month.\n";
print commify($output);
Your web page received -1,740,525,205 accesses last month

See Also

perllocale(1); the reverse function in perlfunc(1) and Chapter 29 of Programming Perl; the section “Adding Commas to a Number with Lookaround” in Chapter 2 of Mastering Regular Expressions, Second Edition

		6.3.18 Printing Correct Plurals
Problem

You’re printing something like "It took $time hours“, but "It took 1 hours" is ungrammatical. You would like to get it right.
Solution

Use printf and the conditional operator (X ? Y : Z) to alter the noun or verb:

printf "It took %d hour%s\n", $time, $time =  = 1 ? "" : "s";

printf "%d hour%s %s enough.\n", $time, 
        $time =  = 1 ? ""   : "s",
        $time =  = 1 ? "is" : "are";

Or use the Lingua::EN::Inflect module from CPAN, as described in the following Discussion.
Discussion

The only reason inane messages like "1 file(s) updated" appear is because their authors are too lazy to bother checking whether the count is 1 or not.

If your noun changes by more than an "-s“, you’ll need to change the printf accordingly:

printf "It took %d centur%s", $time, $time =  = 1 ? "y" : "ies";

This is good for simple cases, but you’ll tire of writing it. This leads you to write funny functions like this:

sub noun_plural {
    local $_ = shift;
    # order really matters here!
    s/ss$/sses/                             ||
    s/([psc]h)$/${1}es/                     ||
    s/z$/zes/                               ||
    s/ff$/ffs/                              ||
    s/f$/ves/                               ||
    s/ey$/eys/                              ||
    s/y$/ies/                               ||
    s/ix$/ices/                             ||
    s/([sx])$/$1es/                         ||
    s/$/s/                                  ||
                die "can't get here";
    return $_;
}
*verb_singular = \&noun_plural;   # make function alias

As you find more exceptions, your function will become increasingly convoluted. When you need to handle such morphological changes, turn to the flexible solution provided by the Lingua::EN::Inflect module from CPAN.

use Lingua::EN::Inflect qw(PL classical);
classical(1);               # why isn't this the default?
while (<DATA>) {            # each line in the data
    for (split) {           # each word on the line
        print "One $_, two ", PL($_), ".\n";
    }
} 
# plus one more
$_ = 'secretary general';
print "One $_, two ", PL($_), ".\n";

_ _END_ _
fish fly ox 
species genus phylum 
cherub radius jockey 
index matrix mythos
phenomenon formula

That produces the following:

               One fish, two fish
               One fly, two flies
               One ox, two oxen
               One species, two species
               One genus, two genera
               One phylum, two phyla
               One cherub, two cherubim
               One radius, two radii
               One jockey, two jockeys
               One index, two indices
               One matrix, two matrices
               One mythos, two mythoi
               One phenomenon, two phenomena
               One formula, two formulae
               One secretary general, two secretaries general

Without calling classical, these lines would have come out different than in the previous output:

               One phylum, two phylums
               One cherub, two cherubs
               One radius, two radiuses
               One index, two indexes
               One matrix, two matrixes
               One formula, two formulas

This is just one of the many things the module can do. It also handles inflections or conjugations for other parts of speech, provides number-insensitive comparison functions, figures out whether to use a or an, and plenty more.
See Also

The “Conditional Operator” in perlop(1) and Chapter 3 of Programming Perl; the documentation with the CPAN module Lingua::EN::Inflect 
		6.3.19 Program: Calculating Prime Factors

The following program takes one or more integer arguments and determines the prime factors. It uses Perl’s native numeric representation, unless those numbers use floating-point representation and thus lose accuracy. Otherwise (or if the program’s -b switch is used), it uses the standard Math::BigInt library, thus allowing for huge numbers. However, it only loads this library if necessary. That’s why we use require and import instead of use, which would unconditionally load the library at compile time instead of conditionally at runtime. This is not an efficient way to crack the huge integers used for cryptographic purposes.

Call the program with a list of numbers, and it will show you the prime factors of those numbers:

% bigfact 8 9 96 2178
8          2**3
            9          3**2
            96         2**5 3
            2178       2 3**2 11**2

You can give it very large numbers:

% bigfact 239322000000000000000000
+239322000000000000000000 2**19 3 5**18 +39887

% bigfact 25000000000000000000000000
+25000000000000000000000000 2**24 5**26

The program is shown in Example 2-2.
Example 2-2. bigfact

  #!/usr/bin/perl
  # bigfact - calculate prime factors
  use strict;
  use integer;
  
  our ($opt_b, $opt_d);
  use Getopt::Std;
  
  @ARGV && getopts('bd')        or die "usage: $0 [-b] number ...";
  
  load_biglib( ) if $opt_b;
  
  ARG: foreach my $orig ( @ARGV ) {
      my ($n, %factors, $factor);
      $n = $opt_b ? Math::BigInt->new($orig) : $orig;
      if ($n + 0 ne $n) { # don't use -w for this
          printf STDERR "bigfact: %s would become %s\n", $n, $n+0 if $opt_d;
          load_biglib( );
          $n = Math::BigInt->new($orig);
      }
      printf "%-10s ", $n;
  
      # Here $sqi will be the square of $i. We will take advantage
      # of the fact that ($i + 1) ** 2 =  = $i ** 2 + 2 * $i + 1.
      for (my ($i, $sqi) = (2, 4); $sqi <= $n; $sqi += 2 * $i ++ + 1) {
          while ($n % $i =  = 0) {
              $n /= $i;
              print STDERR "<$i>" if $opt_d;
              $factors {$i} ++;
          }
      }
  
      if ($n != 1 && $n != $orig) { $factors{$n}++ }
      if (! %factors) {
          print "PRIME\n";
          next ARG;
      }
      for $factor ( sort { $a <=> $b } keys %factors ) {
          print "$factor";
          if ($factors{$factor} > 1) {
              print "**$factors{$factor}";
          }
          print " ";
      }
      print "\n";
  }
  
  # this simulates a use, but at runtime
  sub load_biglib {
      require Math::BigInt;
      Math::BigInt->import( );          #immaterial?
  }

-> My example
[yizaq@YIZAQ-M-D1BW:Thu Apr 16:~/Desktop/Work/scripts/perl/learn/cookbook:]$ perl bigfact.pl  5
5          PRIME
[yizaq@YIZAQ-M-D1BW:Thu Apr 16:~/Desktop/Work/scripts/perl/learn/cookbook:]$ perl bigfact.pl  500
500        2**2 5**3 
[yizaq@YIZAQ-M-D1BW:Thu Apr 16:~/Desktop/Work/scripts/perl/learn/cookbook:]$ perl bigfact.pl  1024
1024       2**10 
[yizaq@YIZAQ-M-D1BW:Thu Apr 16:~/Desktop/Work/scripts/perl/learn/cookbook:]$ perl bigfact.pl  888888883492938471
888888883492938471 3 11**2 13 7561 24912554369 
[yizaq@YIZAQ-M-D1BW:Thu Apr 16:~/Desktop/Work/scripts/perl/learn/cookbook:]$ perl bigfact.pl  3
3          PRIME
[yizaq@YIZAQ-M-D1BW:Thu Apr 16:~/Desktop/Work/scripts/perl/learn/cookbook:]$ perl bigfact.pl  3 5 9 
3          PRIME
5          PRIME
9          3**2 
[yizaq@YIZAQ-M-D1BW:Thu Apr 16:~/Desktop/Work/scripts/perl/learn/cookbook:]$ perl bigfact.pl  3 5 9  231234
3          PRIME
5          PRIME
9          3**2 
231234     2 3 17 2267 
[yizaq@YIZAQ-M-D1BW:Thu Apr 16:~/Desktop/Work/scripts/perl/learn/cookbook:]$ perl bigfact.pl  3 5 9  23.0
3          PRIME
5          PRIME
9          3**2 
23         PRIME
[yizaq@YIZAQ-M-D1BW:Thu Apr 16:~/Desktop/Work/scripts/perl/learn/cookbook:]$ perl bigfact.pl  3 5 9  23.04
3          PRIME
5          PRIME
9          3**2 
NaN        NaN 
[yizaq@YIZAQ-M-D1BW:Thu Apr 16:~/Desktop/Work/scripts/perl/learn/cookbook:]$ perl bigfact.pl  3 5 9  23.99
3          PRIME
5          PRIME
9          3**2 
NaN        NaN 
[yizaq@YIZAQ-M-D1BW:Thu Apr 16:~/Desktop/Work/scripts/perl/learn/cookbook:]$ perl bigfact.pl  3 5 9  23.0
3          PRIME
5          PRIME
9          3**2 
23         PRIME


		6.3.20  Dates and Times

		It is inappropriate to require that a time represented as seconds since the Epoch precisely represent the number of seconds between the referenced time and the Epoch.
		—IEEE Std 1003.1b-1993 (POSIX) Section B.2.2.2

Introduction

Times and dates are important things to be able to manipulate. “How many users logged in last month?”, “How many seconds should I sleep if I want to wake up at midday?”, and “Has this user’s password expired yet?” are common questions whose answers involve surprisingly non-obvious manipulations.

Perl represents points in time as intervals, measuring seconds past a point in time called the Epoch. On Unix and many other systems, the Epoch was 00:00 Jan 1, 1970, UTC (Universal Corrected Time).[1]

When we talk about dates and times, we often interchange two different concepts: points in time (dates and times) and intervals between points in time (weeks, months, days, etc.). Epoch seconds represent intervals and points in the same units, so you can do basic arithmetic on them.

However, people are not used to working with Epoch seconds. We are more used to dealing with individual year, month, day, hour, minute, and second values. Furthermore, the month can be represented by its full name or its abbreviation. The day can precede or follow the month. Because of the difficulty of performing calculations with a variety of formats, we typically convert human-supplied strings or lists to Epoch seconds, calculate, and then convert back to strings or lists for output.

Epoch seconds are an absolute number of seconds, so they don’t take into account time zones or daylight saving times. When converting to or from distinct values, always consider whether the time represented is UTC or local. Use different conversion functions depending on whether you need to convert from UTC to local time or vice versa.

Perl’s time function returns the number of seconds that have passed since the Epoch—more or less.[2] POSIX requires that time not include leap seconds, a peculiar practice of adjusting the world’s clock by a second here and there to account for the slowing down of the Earth’s rotation due to tidal angular-momentum dissipation. (See the sci.astro FAQ, section 3, at http://sciastro.astronomy.net/sci.astro.3.FAQ.) To convert Epoch seconds into distinct values for days, months, years, hours, minutes, and seconds, use the localtime and gmtime functions. In list context, these functions return a nine-element list, as shown in Table 3-1.
Table 3-1. Values (and their ranges) returned from localtime and gmtime

Variable
	

Values
	

Range

$sec
	

seconds
	

0-60

$min
	

minutes
	

0-59

$hours
	

hours
	

0-23

$mday
	

day of month
	

1-31

$mon
	

month of year
	

0-11, 0 = = January

$year
	

years since 1900
	

1-138 (or more)

$wday
	

day of week
	

0-6, 0 = = Sunday

$yday
	

day of year
	

0-365

$isdst
	

0 or 1
	

true if daylight saving is in effect

The values for seconds range from 0-60 to account for leap seconds; you never know when a spare second will leap into existence at the urging of various standards bodies.

From now on, we’ll refer to a list of day, month, year, hour, minute, and seconds as DMYHMS, for no better reason than that writing and reading “distinct day, month, year, hour, minute, and seconds values” is wearisome. The abbreviation is not meant to suggest an order of return values.

Perl does not return a two-digit year value. It returns the year minus 1900, which just happens to be a two-digit number through 1999. Perl doesn’t intrinsically have a Year 2000 problem, unless you make one yourself. (Your computer, and Perl, may have a 2038 problem, though, if we’re still using 32 bits by that time.) Add 1900 to get the full year value instead of using the construct "20$year“, or your programs will refer to the year as something like "20103“. We can’t pin down the year value’s range, because it depends on how big an integer your operating system uses for Epoch seconds. Small integers mean a small range; big (64-bit) integers mean a very big range.

In scalar context, localtime and gmtime return the date and time formatted as an ASCII string:

            Fri Apr 11 09:27:08 1997

The standard Time::tm module provides a named interface to these values. The standard Time::localtime and Time::gmtime modules override the list-returning localtime and gmtime functions, replacing them with versions that return Time::tm objects. Compare these two pieces of code:

# using arrays
print "Today is day ", (localtime)[7], " of the current year.\n";
Today is day 117 of the current year

# using Time::tm objects
use Time::localtime;
$tm = localtime;
print "Today is day ", $tm->yday, " of the current year.\n";
Today is day 117 of the current year

To go from a list to Epoch seconds, use the standard Time::Local module. It provides the functions timelocal and timegm, both of which take a nine-element list and return an integer. The list’s values have the same meaning and ranges as those returned by localtime and gmtime.

Epoch seconds values are limited by the size of an integer. If you have a 32-bit signed integer holding your Epoch seconds, you can only represent dates (in UTC) from Fri Dec 13 20:45:52 1901 to Tue Jan 19 03:14:07 2038 (inclusive). By 2038, it is assumed, computers will change to use larger integers for Epoch seconds. We hope. For operations on dates outside this range, you must use another representation or work from distinct year, month, and day values.

The Date::Calc and Date::Manip modules on CPAN both work from these distinct values, but be warned: years don’t necessarily have 1900 subtracted from them the way the year value returned by localtime does, nor do months and weeks always start at 0. As always, consult the manpage of the appropriate module to make sure you’re giving it what it expects and getting back from it what you expect. There’s little more embarrassing than realizing you’ve calculated your company payroll based on a calendar that’s 1,900 years in the past.

			6.3.20.1   Finding Today’s Date
Problem

You need to find the year, month, and day values for today’s date.
Solution

Use localtime, which returns values for the current date and time if given no arguments. You can either use localtime and extract the information you want from the list it returns:

($DAY, $MONTH, $YEAR) = (localtime)[3,4,5];

or use Time::localtime, which overrides localtime to return a Time::tm object:

use Time::localtime;
$tm = localtime;
($DAY, $MONTH, $YEAR) = ($tm->mday, $tm->mon, $tm->year);

Discussion

Here’s how you’d print the current date as “YYYY MM DD”, using the non-overridden localtime:

($day, $month, $year) = (localtime)[3,4,5];
printf("The current date is %04d %02d %02d\n", $year+1900, $month+1, $day);
The current date is 2003 03 06

To extract the fields we want from the list returned by localtime, we take a list slice. We could also have written it as:

($day, $month, $year) = (localtime)[3..5];

This is how we’d print the current date as “YYYY-MM-DD” (in approved ISO 8601 fashion), using Time::localtime:

use Time::localtime;
$tm = localtime;
printf("The current date is %04d-%02d-%02d\n", $tm->year+1900, 
    ($tm->mon)+1, $tm->mday);
The current date is 2003-03-06

The object interface might look out of place in a short program. However, when you do a lot of work with the distinct values, accessing them by name makes code much easier to understand.

A more obfuscated way that does not involve temporary variables is:

printf("The current date is %04d-%02d-%02d\n",
       sub {($_[5]+1900, $_[4]+1, $_[3])}->(localtime));

There is also strftime from the POSIX module discussed in Recipe 3.8:

use POSIX qw(strftime);
print strftime "%Y-%m-%d\n", localtime;

The gmtime function works just as localtime does, but gives the answer in UTC instead of your local time zone.
See Also

The localtime and gmtime functions in perlfunc(1) and Chapter 29 of Programming Perl; the documentation for the standard Time::localtime module
-> My example 
[yizaq@YIZAQ-M-D1BW:Thu Apr 16:~/Desktop/Work/scripts/perl/learn/cookbook:]$ perl -e '
@tm = localtime;
foreach (@tm) {print}; 
print "\ndate: ",$tm[3]."/",$tm[4],"/",$tm[5],"\n";
'
56131816311541051
date: 16/3/115

			6.3.20.2   Converting DMYHMS to Epoch Seconds
Problem

You want to convert a date, a time, or both with distinct values for day, month, year, etc. to Epoch seconds.
Solution

Use the timelocal or timegm functions in the standard Time::Local module, depending on whether the date and time is in the current time zone or in UTC.

use Time::Local;
$TIME = timelocal($sec, $min, $hours, $mday, $mon, $year);
$TIME = timegm($sec, $min, $hours, $mday, $mon, $year);

Discussion

The built-in function localtime converts an Epoch seconds value to distinct DMYHMS values; the timelocal subroutine from the standard Time::Local module converts distinct DMYHMS values to an Epoch seconds value. Here’s an example that shows how to find Epoch seconds for a time in the current day. It gets the day, month, and year values from localtime:

# $hours, $minutes, and $seconds represent a time today,
# in the current time zone
use Time::Local;
$time = timelocal($seconds, $minutes, $hours, (localtime)[3,4,5]);

If you’re passing month and year values to timelocal, it expects values with the same range as those which localtime returns. Namely, months start at 0, and years have 1900 subtracted from them.

The timelocal function assumes the DMYHMS values represent a time in the current time zone. Time::Local also exports a timegm subroutine that assumes the DMYHMS values represent a time in the UTC time zone. Unfortunately, there is no convenient way to convert from a time zone other than the current local time zone or UTC. The best you can do is convert to UTC and add or subtract the time zone offset in seconds.

This code illustrates both the use of timegm and how to adjust the ranges of months and years:

# $day is day in month (1-31)
# $month is month in year (1-12)
# $year is four-digit year e.g., 1967
# $hours, $minutes and $seconds represent UTC (GMT) time 
use Time::Local;
$time = timegm($seconds, $minutes, $hours, $day, $month-1, $year-1900);

As explained in the introduction, Epoch seconds cannot hold values before Fri Dec 13 20:45:52 1901 or after Tue Jan 19 03:14:07 2038. Don’t convert such dates to Epoch seconds—use a Date:: module from CPAN, and do your calculations with that instead.
See Also

The documentation for the standard Time::Local module (also in Chapter 32 of Programming Perl); convert in the other direction using Recipe 3.3

			6.3.20.3   Converting Epoch Seconds to DMYHMS
Problem

You have a date and time in Epoch seconds, and you want to calculate individual DMYHMS values from it.
Solution

Use the localtime or gmtime functions, depending on whether you want the date and time in UTC or your local time zone.

($seconds, $minutes, $hours, $day_of_month, $month, $year,
    $wday, $yday, $isdst) = localtime($time);

The standard Time::timelocal and Time::gmtime modules override the localtime and gmtime functions to provide named access to the individual values.

use Time::localtime;        # or Time::gmtime
$tm = localtime($TIME);     # or gmtime($TIME)
$seconds = $tm->sec;
# ...

Discussion

The localtime and gmtime functions return strange year and month values; the year has 1900 subtracted from it, and 0 is the month value for January. Be sure to correct the base values for year and month, as this example does:

($seconds, $minutes, $hours, $day_of_month, $month, $year,
    $wday, $yday, $isdst) = localtime($time);
printf("Dateline: %02d:%02d:%02d-%04d/%02d/%02d\n",
    $hours, $minutes, $seconds, $year+1900, $month+1,
    $day_of_month);

We could have used the Time::localtime module to avoid the temporary variables:

use Time::localtime;
$tm = localtime($time);
printf("Dateline: %02d:%02d:%02d-%04d/%02d/%02d\n",
    $tm->hour, $tm->min, $tm->sec, $tm->year+1900,
    $tm->mon+1, $tm->mday);

See Also

The localtime function in perlfunc(1) and Chapter 29 of Programming Perl; the documentation for the standard Time::localtime and Time::gmtime modules; convert in the other direction using Recipe 3.3

			6.3.20.4   Adding to or Subtracting from a Date
Problem

You have a date and time and want to find the date and time of some period in the future or past.
Solution

Simply add or subtract Epoch seconds:

$when = $now + $difference;
$then = $now - $difference;

If you have distinct DMYHMS values, use the CPAN Date::Calc module. If you’re doing arithmetic with days only, use Add_Delta_Days ($offset is a positive or negative integral number of days):

use Date::Calc qw(Add_Delta_Days);
($y2, $m2, $d2) = Add_Delta_Days($y, $m, $d, $offset);

If you are concerned with hours, minutes, and seconds (in other words, times as well as dates), use Add_Delta_DHMS:

use Date::Calc qw(Add_Delta_DHMS);
($year2, $month2, $day2, $h2, $m2, $s2) = 
    Add_Delta_DHMS( $year, $month, $day, $hour, $minute, $second,
                $days_offset, $hour_offset, $minute_offset, $second_offset );

Discussion

Calculating with Epoch seconds is easiest, disregarding the effort to get dates and times into and out of Epoch seconds. This code shows how to calculate an offset (55 days, 2 hours, 17 minutes, and 5 seconds, in this case) from a given base date and time:

$birthtime = 96176750;                  # 18/Jan/1973, 3:45:50 am
$interval = 5 +                         # 5 seconds
            17 * 60 +                   # 17 minutes
            2  * 60 * 60 +              # 2 hours
            55 * 60 * 60 * 24;          # and 55 days
$then = $birthtime + $interval;
print "Then is ", scalar(localtime($then)), "\n";
Then is Wed Mar 14 06:02:55 1973

We could have used Date::Calc’s Add_Delta_DHMS function and avoided the conversion to and from Epoch seconds:

use Date::Calc qw(Add_Delta_DHMS);
($year, $month, $day, $hh, $mm, $ss) = Add_Delta_DHMS(
    1973, 1, 18, 3, 45, 50, # 18/Jan/1973, 3:45:50 am
             55, 2, 17, 5); # 55 days, 2 hrs, 17 min, 5 sec
print "To be precise: $hh:$mm:$ss, $month/$day/$year\n";
To be precise: 6:2:55, 3/14/1973

As usual, we need to know the range of values the function expects. Add_Delta_DHMS takes a full year value—that is, one that hasn’t had 1900 subtracted from it. The month value for January is 1, not 0. Date::Calc’s Add_Delta_Days function expects the same kind of values:

use Date::Calc qw(Add_Delta_Days);
($year, $month, $day) = Add_Delta_Days(1973, 1, 18, 55);
print "Nat was 55 days old on: $month/$day/$year\n";
Nat was 55 days old on: 3/14/1973

See Also

The documentation for the CPAN module Date::Calc

			6.3.20.5   Difference of Two Dates
Problem

You need to find the number of days between two dates or times.
Solution

If your dates are in Epoch seconds and fall in the range Fri Dec 13 20:45:52 1901 to Tue Jan 19 03:14:07 2038 (inclusive), subtract one from the other and convert the seconds to days:

$seconds = $recent - $earlier;

If you have distinct DMYMHS values or are worried about the range limitations of Epoch seconds, use the Date::Calc module from CPAN. It can calculate the difference between dates:

use Date::Calc qw(Delta_Days);
$days = Delta_Days( $year1, $month1, $day1, $year2, $month2, $day2);

It also calculates the difference between a pair of dates and times:

use Date::Calc qw(Delta_DHMS);
($days, $hours, $minutes, $seconds) =
  Delta_DHMS( $year1, $month1, $day1, $hour1, $minute1, $seconds1,  # earlier
              $year2, $month2, $day2, $hour2, $minute2, $seconds2); # later

Discussion

One problem with Epoch seconds is how to convert the large integers back to forms that people can read. The following example shows one way of converting an Epoch seconds value back to its component numbers of weeks, days, hours, minutes, and seconds:

$bree = 361535725;          # 16 Jun 1981, 4:35:25
$nat  =  96201950;          # 18 Jan 1973, 3:45:50

$difference = $bree - $nat;
print "There were $difference seconds between Nat and Bree\n";
There were 265333775 seconds between Nat and Bree

$seconds    =  $difference % 60;
$difference = ($difference - $seconds) / 60;
$minutes    =  $difference % 60;
$difference = ($difference - $minutes) / 60;
$hours      =  $difference % 24;
$difference = ($difference - $hours)   / 24;
$days       =  $difference % 7;
$weeks      = ($difference - $days)    /  7;

print "($weeks weeks, $days days, $hours:$minutes:$seconds)\n";
(438 weeks, 4 days, 23:49:35)

Date::Calc’s functions can ease these calculations. The Delta_Days function returns the number of days between two dates. It takes the two dates as a list: year, month, day. The dates are given chronologically—earliest first.

use Date::Calc qw(Delta_Days);
@bree = (1981, 6, 16);      # 16 Jun 1981
@nat  = (1973, 1, 18);      # 18 Jan 1973
$difference = Delta_Days(@nat, @bree);
print "There were $difference days between Nat and Bree\n";
There were 3071 days between Nat and Bree

The Delta_DHMS function returns a four-element list corresponding to the number of days, hours, minutes, and seconds between the two dates you give it.

use Date::Calc qw(Delta_DHMS);
@bree = (1981, 6, 16, 4, 35, 25);   # 16 Jun 1981, 4:35:25
@nat  = (1973, 1, 18, 3, 45, 50);   # 18 Jan 1973, 3:45:50
@diff = Delta_DHMS(@nat, @bree);
print "Bree came $diff[0] days, $diff[1]:$diff[2]:$diff[3] after Nat\n";
Bree came 3071 days, 0:49:35 after Nat

See Also

The documentation for the CPAN module Date::Calc

			6.3.20.6   Day in a Week/Month/Year or Week Number
Problem

You have a date, either in Epoch seconds or as distinct year, month, etc. values. You want to find out what week of the year, day of the week, day of the month, or day of the year that the date falls on.
Solution

If you have Epoch seconds, the day of the year, day of the month, and day of the week are returned by localtime. The week of the year is easily calculated from the day of the year (but see the following discussion, as standards differ).

($MONTHDAY, $WEEKDAY, $YEARDAY) = (localtime $DATE)[3,6,7];
$WEEKNUM = int($YEARDAY / 7) + 1;

If you have distinct DMYHMS values, you can either convert them to Epoch seconds values as in Recipe 3.2 and then use the previous solution, or else use the Day_of_Week, Week_Number, and Day_of_Year functions from the CPAN module Date::Calc:

use Date::Calc qw(Day_of_Week Week_Number Day_of_Year);
# you have $year, $month, and $day
# $day is day of month, by definition.
$wday = Day_of_Week($year, $month, $day);
$wnum = Week_Number($year, $month, $day);
$dnum = Day_of_Year($year, $month, $day);

Discussion

The Day_of_Week, Week_Number, and Day_of_Year functions all expect years that haven’t had 1900 subtracted from them and months where January is 1, not 0. The return value from Day_of_Week can be 1 through 7 (corresponding to Monday through Sunday) or 0 in case of an error (an invalid date, for example).

use Date::Calc qw(Day_of_Week Week_Number Day_of_Week_to_Text);

$year  = 1981;
$month = 6;         # (June)
$day   = 16;

$wday = Day_of_Week($year, $month, $day);
print "$month/$day/$year was a ", Day_of_Week_to_Text($wday), "\n";
## see comment above

$wnum = Week_Number($year, $month, $day);
print "in the $wnum week.\n";
6/16/1981 was a Tuesday
               in week number 25

The governing standard bodies of particular countries may have rules about when the first week of the year starts. For example, in Norway the first week must have at least 4 days in it (and weeks start on Mondays). If January 1 falls on a week with 3 or fewer days, it is counted as week 52 (or 53) of the previous year. In America, the first Monday of the year is usually the start of the first workweek. Given such rules, you may have to write your own algorithm, or at least look at the %G, %L, %W, and %U formats to the UnixDate function in Date::Manip.
See Also

The localtime function in perlfunc(1) and Chapter 29 of Programming Perl; the documentation for the CPAN module Date::Calc

			6.3.20.7   arsing Dates and Times from Strings
Problem

You read in a date or time specification in an arbitrary format but need to parse that string into distinct year, month, etc. values.
Solution

If your date is already numeric, or in a rigid and easily parsed format, use a regular expression (and possibly a hash mapping month names to numbers) to extract individual day, month, and year values, and then use the standard Time::Local module’s timelocal and timegm functions to turn that into an Epoch seconds value.

use Time::Local;
# $date is "2003-02-13" (YYYY-MM-DD form).
($yyyy, $mm, $dd) = ($date =~ /(\d+)-(\d+)-(\d+)/);
# calculate epoch seconds at midnight on that day in this timezone
$epoch_seconds = timelocal(0, 0, 0, $dd, $mm-1, $yyyy);

For a more flexible solution, use the ParseDate function provided by the CPAN module Date::Manip, and then use UnixDate to extract the individual values.

use Date::Manip qw(ParseDate UnixDate);
$date = ParseDate($STRING);
if (!$date) {
    # bad date
} else {
    @VALUES = UnixDate($date, @FORMATS);
}

Discussion

The flexible ParseDate function accepts many formats. It even converts strings such as “today”, “2 weeks ago Friday”, “2nd Sunday in 1996”, and “last Sunday in December”, plus it understands the date and time format used in mail and news headers. It returns the decoded date in its own format: a string of the form “YYYYMMDDHH:MM:SS”. You could compare two such strings to compare the dates they represent, but arithmetic is difficult. We therefore use the UnixDate function to extract the year, month, and day values in a preferred format.

UnixDate takes a date (as returned by ParseDate) and a list of formats. It applies each format to the string and returns the result. A format is a string describing one or more elements of the date and time and the way that the elements are to be formatted. For example, %Y is the format for the year in four-digit form. Here’s an example:

use Date::Manip qw(ParseDate UnixDate);

while (<>) {
    $date = ParseDate($_);
    if (!$date) {
        warn "Bad date string: $_\n";
        next;
    } else {
        ($year, $month, $day) = UnixDate($date, "%Y", "%m", "%d");
        print "Date was $month/$day/$year\n";
    }
}

See Also

The documentation for the CPAN module Date::Manip; we use this in Recipe 3.11

			6.3.20.8   Printing a Date
Problem

You need to print a date and time shown in Epoch seconds format in human-readable form.
Solution

Call localtime or gmtime in scalar context, which takes an Epoch seconds value and returns a string of the form Tue July 22 05:15:20 2003:

$STRING = localtime($EPOCH_SECONDS);

Alternatively, the strftime function in the standard POSIX module supports a more customizable output format and takes individual DMYHMS values:

use POSIX qw(strftime);
$STRING = strftime($FORMAT, $SECONDS, $MINUTES, $HOUR,
                   $DAY_OF_MONTH, $MONTH, $YEAR, $WEEKDAY,
                   $YEARDAY, $DST);

The CPAN module Date::Manip has a UnixDate routine that works like a specialized form sprintf designed to handle dates. Pass it a Date::Manip date value. Using Date::Manip in lieu of POSIX::strftime has the advantage of not requiring a POSIX-compliant system.

use Date::Manip qw(UnixDate);
$STRING = UnixDate($DATE, $FORMAT);

Discussion

The simplest solution is built into Perl already: the localtime function. In scalar context, it returns the string formatted in a particular way:

               Wed July 16 23:58:36 2003

This makes for simple code, although it restricts the format of the string:

use Time::Local;
$time = timelocal(50, 45, 3, 18, 0, 73);
print "Scalar localtime gives: ", scalar(localtime($time)), "\n";
Scalar localtime gives: Thu Jan 18 03:45:50 1973

Of course, localtime requires the date and time in Epoch seconds. The POSIX::strftime function takes individual DMYMHS values plus a format and returns a string. The format is similar to a printf format: % directives specify fields in the output string. A full list of these directives is available in your system’s documentation for strftime. The strftime function expects the individual values representing the date and time to be in the same range as those returned by localtime:

use POSIX qw(strftime);
use Time::Local;
$time = timelocal(50, 45, 3, 18, 0, 73);
print "strftime gives: ", strftime("%A %D", localtime($time)), "\n";
strftime gives: Thursday 01/18/73

All values are shown in their national representation when using POSIX::strftime. So, if you run it in France, your program would print "Sunday" as "Dimanche“. Be warned: Perl’s interface to the POSIX function strftime assumes the date falls in the current time zone.

If you don’t have access to POSIX’s strftime function, there’s always the trusty Date::Manip CPAN module, described in Recipe 3.6.

use Date::Manip qw(ParseDate UnixDate);
$date = ParseDate("18 Jan 1973, 3:45:50");
$datestr = UnixDate($date, "%a %b %e %H:%M:%S %z %Y");    # as scalar
print "Date::Manip gives: $datestr\n";
Date::Manip gives: Thu Jan 18 03:45:50 GMT 1973

See Also

The gmtime and localtime functions in perlfunc(1) and Chapter 29 of Programming Perl; perllocale(1); your system’s strftime(3) manpage; the documentation for the POSIX module (also in Chapter 32 of Programming Perl); the documentation for the CPAN module Date::Manip

			6.3.20.9   High-Resolution Timers
Problem

You need to measure time with a finer granularity than the full seconds that time returns.
Solution

The Time::HiRes module, which is included standard starting with the v5.8 release of Perl, encapsulates this functionality for most systems:

use Time::HiRes qw(gettimeofday);
$t0 = gettimeofday( );    
## do your operation here
$t1 = gettimeofday( );
$elapsed = $t1 - $t0;
# $elapsed is a floating point value, representing number
# of seconds between $t0 and $t1

Discussion

Here’s some code that uses Time::HiRes to time how long the user takes to press the Return key:

use Time::HiRes qw(gettimeofday);
print "Press return when ready: ";
$before = gettimeofday( );
$line = <STDIN>;
$elapsed = gettimeofday( ) - $before;
print "You took $elapsed seconds.\n";

Press return when ready
               You took 0.228149 seconds

The module’s gettimeofday function returns a two-element list representing seconds and microseconds when called in list context, or a single floating-point number combining the two when called in scalar context. You can also import its time function to replace the standard core version by that name; this always acts like scalar gettimeofday.

The module also provides usleep and ualarm functions, which are alternate versions of the standard Perl sleep and alarm functions that understand granularities of microseconds instead of just seconds. They take arguments in microseconds; alternatively, you can import the module’s sleep and alarm functions, which take floating-point arguments in seconds, to replace the standard versions, which take integer arguments in seconds. For access to your system’s low-level itimer routines (if you have them), setitimer and getitimer are also provided.

If your system doesn’t support that module, you might try to poke around by hand using syscall. Compare Time::HiRes to the equivalent syscall code. (This example is included principally so that you can see an example of Perl’s abstruse and archaic syscall function.)

require 'sys/syscall.ph';

# initialize the structures returned by gettimeofday
$TIMEVAL_T = "LL";
$done = $start = pack($TIMEVAL_T, (0,0));

# prompt
print "Press return when ready: ";

# read the time into $start
syscall(&SYS_gettimeofday, $start, 0) != -1
           || die "gettimeofday: $!";

# read a line
$line = <>;

# read the time into $done
syscall(&SYS_gettimeofday, $done, 0) != -1
       || die "gettimeofday: $!";

# expand the structure
@start = unpack($TIMEVAL_T, $start);
@done  = unpack($TIMEVAL_T, $done);

# fix microseconds
for ($done[1], $start[1]) { $_ /= 1_000_000 }

# calculate time difference
$delta_time = sprintf "%.4f", ($done[0]  + $done[1]  )
                                         -
                              ($start[0] + $start[1] );

print "That took $delta_time seconds\n";
Press return when ready
               That took 0.3037 seconds

It’s longer because it’s doing system calls in Perl, whereas Time::HiRes does them in C providing a single function. It’s complex because directly accessing system calls peculiar to your operating system requires understanding the underlying C structures that the system call takes and returns. Some programs that come with the Perl distribution try to automatically calculate the formats to pack and unpack for you, if fed the appropriate C header file. In the example, sys/syscall.ph is a Perl library file generated with h2ph, which converts the sys/syscall.h header file into sys/syscall.ph, defining (among other things) &SYS_gettimeofday as a subroutine that returns the system call number of gettimeofday.

Here’s another example of Time::HiRes, showing how you could use it to benchmark a sort (if you didn’t care to use the standard Benchmark module):

use Time::HiRes qw(gettimeofday);
# take mean sorting time
$size = 2000;
$number_of_times = 100;
$total_time = 0;

for ($i = 0; $i < $number_of_times; $i++) {
    my (@array, $j, $begin, $time);
    # populate array
    @array = ( );
    for ($j=0; $j < $size; $j++) { push(@array, rand) }

    # sort it
    $begin = gettimeofday;
    @array = sort { $a <=> $b } @array;
    $time = gettimeofday-$begin;
    $total_time += $time;
}

printf "On average, sorting %d random numbers takes %.5f seconds\n",
    $size, ($total_time/$number_of_times);
On average, sorting 2000 random numbers takes 0.01033 seconds

See Also

The documentation for the Time::HiRes and Benchmark modules; the syscall function in perlfunc(1) and Chapter 29 of Programming Perl; your system’s syscall(2) manpage

			6.3.20.10  Short Sleeps
Problem

You need to sleep for less than a second.
Solution

Use the select( ) function, if your system supports it:

select(undef, undef, undef, $time_to_sleep);

Some systems don’t support a four-argument select. The Time::HiRes module provides a sleep function that takes a floating-point number of seconds:

use Time::HiRes qw(sleep);
sleep($time_to_sleep);

Discussion

Here’s an example of select. It’s a simpler version of the program in Recipe 1.6. Think of it as your very own 300-baud terminal.

while (<>) {
    select(undef, undef, undef, 0.25);
    print;
}

Using Time::HiRes, we’d write it as:

use Time::HiRes qw(sleep);
while (<>) {
    sleep(0.25);
    print;
}

See Also

The documentation for the CPAN modules Time::HiRes and Benchmark; the sleep and select functions in perlfunc(1) and Chapter 29 of Programming Perl; we use the select function for short sleeps in the slowcat program in Recipe 1.6

			6.3.20.11  Program: hopdelta

Have you ever wondered why it took so long for someone’s mail to get to you? With postal mail, you can’t trace how long each intervening post office let your letter gather dust in their back office. But with electronic mail, you can. The message carries in its header Received: lines showing when each intervening mail transport agent along the way got the message.

The dates in the headers are hard to read. You have to read them backwards, bottom to top. They are written in many varied formats, depending on the whim of each transport agent. Worst of all, each date is written in its own local time zone. It’s hard to eyeball "Tue, 26 May 1998 23:57:38 -0400" and "Wed, 27 May 1998 05:04:03 +0100" and realize these two dates are only 6 minutes and 25 seconds apart.

The ParseDate and DateCalc functions in the Date::Manip module from CPAN can help this:

use Date::Manip qw(ParseDate DateCalc);
$d1 = ParseDate("Sun, 09 Mar 2003 23:57:38 -0400");
$d2 = ParseDate("Mon, 10 Mar 2003 05:04:03 +0100");
print DateCalc($d1, $d2);
+0:0:0:0:0:6:25

That’s a nice format for a program to read, but it’s still not what the casual reader wants to see. The hopdelta program, shown in Example 3-1, takes a mailer header and tries to analyze the deltas (difference) between each hop (mail stop). Its output is shown in the local time zone.
Example 3-1. hopdelta

  #!/usr/bin/perl
  # hopdelta - feed mail header, produce lines
  #            showing delay at each hop.
  use strict;
  use Date::Manip qw (ParseDate UnixDate);
  
  # print header; this should really use format/write due to
  # printf complexities
  printf "%-20.20s %-20.20s %-20.20s   %s\n", 
          "Sender", "Recipient", "Time", "Delta";
  
  $/ = '';                # paragraph mode
  $_ = <>;                # read header
  s/\n\s+/ /g;            # join continuation lines
  
  # calculate when and where this started
  my($start_from) = /^From.*\@([^\s>]*)/m;
  my($start_date) = /^Date:\s+(.*)/m;
  my $then = getdate($start_date);
  printf "%-20.20s %-20.20s %s\n", 'Start', $start_from, fmtdate($then);
  
  my $prevfrom = $start_from;
  
  # now process the headers lines from the bottom up
  for (reverse split(/\n/)) {
      my ($delta, $now, $from, $by, $when);
      next unless /^Received:/;
      s/\bon (.*?) (id.*)/; $1/s;         # qmail header, I think
      unless (($when) = /;\s+(.*)$/) {    # where the date falls
          warn "bad received line: $_";
          next;
      }
      ($from) = /from\s+(\S+)/;           
      ($from) = /\((.*?)\)/ unless $from; # some put it here
      $from =~ s/\)$//;                   # someone was too greedy
      ($by)   = /by\s+(\S+\.\S+)/;        # who sent it on this hop
  
      # now random mungings to get their string parsable
      for ($when) {
          s/ (for|via) .*$//;
          s/([+-]\d\d\d\d) \(\S+\)/$1/;
          s/id \S+;\s*//;
      }
      next unless $now = getdate($when);          # convert to Epoch
      $delta = $now - $then;
  
      printf "%-20.20s %-20.20s %s  ", $from, $by, fmtdate($now);
      $prevfrom = $by;
      puttime($delta);
      $then = $now;               
  }
  
  exit;
  
  # convert random date strings into Epoch seconds
  sub getdate {
      my $string     =  shift;
      $string        =~ s/\s+\(.*\)\s*$//;        # remove nonstd tz
      my $date       =  ParseDate($string);
      my $epoch_secs =  UnixDate($date,"%s");
      return $epoch_secs;
  }
  
  # convert Epoch seconds into a particular date string
  sub fmtdate {
      my $epoch = shift;
      my($sec,$min,$hour,$mday,$mon,$year) = localtime($epoch);
      return sprintf "%02d:%02d:%02d %04d/%02d/%02d",
                      $hour, $min, $sec,
                      $year + 1900, $mon + 1, $mday,
  }
  
  # take seconds and print in pleasant-to-read format
  sub puttime {
      my($seconds) = shift;
      my($days, $hours, $minutes);
  
      $days    = pull_count($seconds, 24 * 60 * 60);
      $hours   = pull_count($seconds, 60 * 60);
      $minutes = pull_count($seconds, 60);
  
      put_field('s', $seconds);
      put_field('m', $minutes);
      put_field('h', $hours);
      put_field('d', $days);
  
      print "\n";
  }
  
  # usage: $count = pull_count(seconds, amount)
  # remove from seconds the amount quantity, altering caller's version.
  # return the integral number of those amounts so removed.
  sub pull_count {
      my($answer) = int($_[0] / $_[1]);
      $_[0] -= $answer * $_[1];
      return $answer;
  }
  
  # usage: put_field(char, number)
  # output number field in 3-place decimal format, with trailing char
  # suppress output unless char is 's' for seconds
  sub put_field {
      my ($char, $number) = @_;
      printf " %3d%s", $number, $char if $number || $char eq 's';
  }
  
  =end
  
Sender               Recipient            Time                   Delta
               Start                wall.org             09:17:12 1998/05/23
               wall.org             mail.brainstorm.net  09:20:56 1998/05/23    44s   3m
               mail.brainstorm.net  jhereg.perl.com      09:20:58 1998/05/23     2s


[1] UTC is the preferred way to specify what used to be called GMT, or Greenwich Mean Time.

[2] Well, less actually. To be precise, 22 seconds less as of this writing.

			6.3.20.12  


		6.3.21

	6.4 Arrays

	Works of art, in my opinion, are the only objects in the material universe to possess internal order, and that is why, though I don’t believe that only art matters, I do believe in Art for Art’s sake.
	—E.M. Forster
Introduction

If you are asked about the contents of your pockets, or the names of the first three Greek letters, or how to get to the highway, you recite a list: you name one thing after another in a particular order. Lists are part of your conception of the world. With Perl’s powerful list- and array-handling primitives, you can translate this world view directly into code.

In this chapter, we’ll use the terms list and array as the Perl language thinks of them. Take ("alpha", "beta", "gamma"); that’s a list of the names of the first three Greek letters, in order. To store that list into a variable, use an array, as in @greeks = ("alpha", "beta", "gamma"). Both are ordered groups of scalar values; the difference is that an array is a named variable, one whose array length can be directly changed, whereas a list is a more ephemeral notion. You might think of an array as a variable and a list as the values it contains.

This distinction may seem arbitrary, but operations that modify the length of these groupings (like push and pop) require a proper array and not merely a list. Think of the difference between $a and 4. You can say $a++ but not 4++. Likewise, you can say pop(@a) but not pop (1,2,3).

The most important thing to glean from this is that Perl’s lists and arrays are both ordered groupings of scalars. Operators and functions that work on lists or arrays are designed to provide faster or more convenient access to the elements than manual access would provide. Since few actually deal with modifying the array’s length, you can usually use arrays and lists interchangeably.

You can’t use nested parentheses to create a list of lists. If you try that in Perl, your lists get flattened, meaning that both these lines are equivalent:

@nested = ("this", "that", "the", "other");
@nested = ("this", "that", ("the", "other"));

Why doesn’t Perl (usefully) just support nested lists directly? Although partially for historical reasons, this easily allows for operations (like print or sort) that work on arbitrarily long lists of arbitrary contents.

What happens if you want a more complex data structure, such as an array of arrays or an array of hashes? Remember that scalars aren’t restricted to containing just numbers or strings; they can also hold references. Complex (multilevel) data structures in Perl are always put together using references. Therefore, what appear to be “two-dimensional arrays” or “arrays of arrays” are always implemented as arrays of array references, in the same way that two-dimensional arrays in C can be arrays of pointers to arrays.

Most recipes in this chapter don’t care what you keep in your arrays; for example, the problem of merging two arrays is the same whether the arrays contains strings, numbers, or references. Some problems are intrinsically tied to the contents of your arrays; recipes for those are in Chapter 11. This chapter’s recipes deal with generic arrays.

Let’s have some more terminology. The scalar items in an array or list are called elements, which you access by specifying their position, or index. Indices in Perl start at 0. So, given this list:

@greeks = ( "alpha", "beta", "gamma" );

"alpha" is in the first position, but you’d access it as $greeks[0]. "beta" is in the second position, but you’d access it as $greeks[1]. This structure is doubly justified: the contrariness of computers, whose first representable number is 0, and the contrariness of language designers, who chose 0 because it is an offset into the array, not the ordinal number of the element.

		6.4.1  Specifying a List in Your Program
Problem

You want to include a list in your program. This is how you initialize arrays.
Solution

You can write out a comma-separated list of elements:

@a = ("quick", "brown", "fox");

If you have a lot of single-word elements, use the qw( ) operator:

@a = qw(Meddle not in the affairs of wizards.);

If you have a lot of multiword elements, use a here document and extract lines:

@lines = (<< "END_OF_HERE_DOC" =~ /^\s*(.+)/gm);
    I sit beside the fire and think
    of all that I have seen,
    of meadow-flowers and butterflies 
    and summers that have been;
END_OF_HERE_DOC

Discussion

The first technique is the one most commonly used, often because only small arrays are normally initialized as program literals. Initializing a large array would fill your program with values and make it hard to read, so such arrays either tend to be initialized in a separate library file (see Chapter 12), or else have their values read in from a file:

@bigarray = ( );
open(FH, "<", "myinfo")   or die "Couldn't open myinfo: $!";
while (<FH>) {
    chomp;
    push(@bigarray, $_);
}
close(FH);

The second technique uses qw( ), one of several pseudo-functions in Perl used for quoting without having to resort to actual quotation marks. This one splits its string argument on whitespace to produce a list of words, where “words” in this instance means strings that don’t contain any whitespace. The initial argument is not subject to interpolation of variables or (most) backslash escape sequences.

@banner = ('Costs', 'only', '$4.95');
@banner = qw(Costs only $4.95);
@banner = split(' ', 'Costs only $4.95');

You can use qw( ) only when each whitespace-separated argument is to be a distinct element in the return list. Be careful not to give Columbus four ships instead of three:

@ships  = qw(Niña Pinta Santa María);               # WRONG
@ships  = ('Niña', 'Pinta', 'Santa María');         # right

The third solution takes a here document, which is a single, multiline string, and applies a global pattern match to that string. The pattern /^\s*(.+)/ says to skip any whitespace at the start of the line, then capture everything through the end of each line. The /g modifier means to apply that match globally, and the /m modifier says to permit ^ to match not just at the beginning of the string, but also immediately after a newline, which, in a multiline string, is just what you need. Applying that technique to the ships example yields:

@ships = ( << "END_OF_FLOTILLA" =~ /^\s*(.+)/gm);
              Niña
              Pinta 
              Santa María
END_OF_FLOTILLA

See Also

The “List Value Constructors” section of perldata(1); the “List Values and Arrays” section of Chapter 2 of Programming Perl; the “Quote and Quote-Like Operators” section of perlop(1); the s/// operator in perlop(1) and Chapter 5 of Programming Perl

		6.4.2  
		6.4.3  
		6.4.4  
		6.4.5  
		6.4.6  
		6.4.7  
		6.4.8  
		6.4.9  
		6.4.10 
		6.4.11 
		6.4.12 
		6.4.13 
		6.4.14 
		6.4.15 
		6.4.16 
		6.4.17 
		6.4.18 
		6.4.19 
		6.4.20 
		6.4.21 


	6.5 
	6.6 
	6.7 
	6.8 
	6.9 
	6.10
	6.11
	6.12
	6.13
	6.14
	6.15
	6.16
	6.17
	6.18
	6.19
	6.20
	6.21
	6.22

7.  My examples

	7.1  Print all fields in file lines that match a pattern
print digit fields
perl -n -e'/test(\d+)/ && print $1'

	7.2 Looping

		7.2.1 looping over an array


foreach (@Array)
{
      SubRoutine($_);
}
Implementation 2

while($Element=shift(@Array))
{
      SubRoutine($Element);
}
Implementation 3

while(scalar(@Array) !=0)
{
      $Element=shift(@Array);
      SubRoutine($Element);
}
Implementation 4

for my $i (0 .. $#Array)
{
      SubRoutine($Array[$i]);
}
Implementation 5

map { SubRoutine($_) } @Array ;

	7.3 regexp

	
		7.3.1  non greedy match - .*?

		7.3.2

	7.4 Filter user names from file, sort and uniq them
- File (huge)
------------------------------------------------------------------------
r131613 | sjaganat | 2015-04-05 22:07:12 -0700 (Sun, 05 Apr 2015) | 1 line
Changed paths:
   M /trunk/cpm/wars/admin-v2/src/main/webapp/js/cisco/ise/framework/portal/views/PortalDetailView.js

fixed=CSCut24101 [IGNORE:COPYRIGHT] Fixed the portal settings ethernet interfaces updates issue.
------------------------------------------------------------------------
r131614 | veramine | 2015-04-05 22:08:50 -0700 (Sun, 05 Apr 2015) | 1 line
Changed paths:
   M /trunk/cpm/wars/admin-webapp/src/main/webapp/pages/modules/trustsec/policy/Repeater.js

fixed=CSCut51817
------------------------------------------------------------------------
r131615 | amabbu | 2015-04-05 22:51:24 -0700 (Sun, 05 Apr 2015) | 4 lines
Changed paths:
   M /trunk/ise-automation/tests/ise-test/src/main/resources/suites/profiler/testng-profiler.xml

fixed=pmbuCDETS [IGNORE:COPYRIGHT] 
Modified the testng for running the failed flows
commented the test classes for checking the failed flows

------------------------------------------------------------------------
r131617 | aessiari | 2015-04-05 23:24:35 -0700 (Sun, 05 Apr 2015) | 2 lines
Changed paths:
   M /trunk/cpm/jars/sxp-engine/sxp-runtime/src/main/java/com/cisco/cpm/sxp/engine/SxpEngine.java

fixed=CSCus61916 [IGNORE:COPYRIGHT]

------------------------------------------------------------------------
r131619 | gvaddadi | 2015-04-05 23:29:13 -0700 (Sun, 05 Apr 2015) | 3 lines
Changed paths:
   M /trunk/ise-automation/tests/ise-test/src/main/resources/suites/debug/testng-Deployment.xml

fixed=pmbuCDETS [IGNORE:COPYRIGHT]
debug suite file
...

- oneliner 
[yizaq@YIZAQ-M-D1BW:Wed Apr 08:~:]$ perl -lne 'if ( /^r\d+ \| (\w+) /  ) { if (not exists($hash{$1}) ) {$hash{$1} = 1; }; END {print for (sort keys %hash) ; } }' stam 
aessiari
ahoroviz
alspicer
amabbu
amibasu
anjkhatr
byju
chuliang
efux
ericchri
gvaddadi
iacote
kisjoshi
klebaka
mrossovs
pmbure
prponnus
rthella
sanmatta
shasc
shmichel
sjaganat
sshanmu2
veramine
vinverma
vradiya
vurankar
whalabe

	7.5 DNS query host address

		7.5.1 Using Net::DNS
[yizaq@YIZAQ-M-D1BW:Wed Apr 15:~/Desktop/Work/scripts/perl/cisco:]$ perl -ne ' /^(.*): / ;  use Net::DNS; $res = new Net::DNS::Resolver(); $rep = $res->search("$1"); if ($rep) {foreach $rr ($rep->answer) { next unless $rr->type eq "A"; print "$1 addr is ", $rr->address, "\n";} } else { warn "query failed ", $res->errorstring, "---------------- \n"; }' hosts
horse1 addr is 10.56.53.25
horse1 addr is 10.56.53.25
cow2 addr is 10.56.53.31
[yizaq@YIZAQ-M-D1BW:Wed Apr 15:~/Desktop/Work/scripts/perl/cisco:]$ cat hosts 
horse1: kkfkfk fksk
horse2:
cow2:  5904 ffffff

		7.5.2  Using gethostbyname 
[yizaq@YIZAQ-M-D1BW:Wed Apr 15:~/Desktop/Work/scripts/perl/cisco:]$ perl -ne ' use Socket;  /^(.*): / ;  @addrs = gethostbyname($1) ; @addresses = map { inet_ntoa($_) } @addrs[4 .. $#addrs]; foreach (@addresses) {print "host $1 address is  $_  \n"}; ' hosts
host horse1 address is  10.56.53.25  
host horse1 address is  10.56.53.25  
host cow2 address is  10.56.53.31  


		7.5.3 Using nslookup, also use output to block traffic 
[root@cd-pos-13-139 ~]#  perl -ne ' use Socket;  /^(.*): / ;  system("nslookup $1") '  stam | grep -v '10.56.14.161'
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
	LANGUAGE = (unset),
	LC_ALL = (unset),
	LC_CTYPE = "UTF-8",
	LANG = "en_US.UTF-8"
    are supported and installed on your system.
perl: warning: Falling back to the standard locale ("C").

Name:	rhdc20.rehovot.corp
Address: 10.56.63.84


Name:	rhdc05.rehovot.corp
Address: 10.56.14.175


Name:	rhdc01.rehovot.corp
Address: 10.56.14.171


Name:	dns03.rehovot.corp
Address: 10.56.14.163


Name:	rhdc16.rehovot.corp
Address: 10.56.63.80


Name:	rhdc11.rehovot.corp
Address: 10.56.63.75


Name:	rhdc24.rehovot.corp
Address: 10.56.63.88


Name:	rhdc10.rehovot.corp
Address: 10.56.14.180


Name:	rhdc28.rehovot.corp
Address: 10.56.52.80


Name:	rhdc07.sub.rehovot.corp
Address: 10.56.14.177


Name:	rhdc31.rehovot.corp
Address: 10.56.52.30


Name:	rhdc03.rehovot.corp
Address: 10.56.14.173


Name:	rhdc25.rehovot.corp
Address: 10.56.63.89


Name:	rhdc08.child.rehovot.corp
Address: 10.56.14.178


Name:	dns01.rehovot.corp


Name:	rhdc26.rehovot.corp
Address: 10.56.63.90


Name:	rhdc-30.rehovot.corp
Address: 10.56.52.29


Name:	rhdc18.rehovot.corp
Address: 10.56.63.82


Name:	dns02.rehovot.corp
Address: 10.56.14.162


Name:	rhdc02.rehovot.corp
Address: 10.56.14.172


Name:	rhdc13.rehovot.corp
Address: 10.56.63.77


Name:	rhdc04.sub.rehovot.corp
Address: 10.56.14.174


Name:	rhdc19.rehovot.corp
Address: 10.56.63.83


Name:	rhdc15.rehovot.corp
Address: 10.56.63.79


Name:	rhdc09.rehovot.corp
Address: 10.56.14.179


Name:	rhdc17.rehovot.corp
Address: 10.56.63.81


Name:	rhdc06.rehovot.corp
Address: 10.56.14.176


Name:	rhdc22.sub.child.rehovot.corp
Address: 10.56.63.86


Name:	rhdc27.rehovot.corp
Address: 10.56.63.91


Name:	rhdc29.rehovot.corp
Address: 10.56.52.82


Name:	rhdc23.child.rehovot.corp
Address: 10.56.63.87

[root@cd-pos-13-139 ~]#  perl -ne ' use Socket;  /^(.*): / ;  system("nslookup $1") '  stam | grep -v '10.56.14.161' | grep Address
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
	LANGUAGE = (unset),
	LC_ALL = (unset),
	LC_CTYPE = "UTF-8",
	LANG = "en_US.UTF-8"
    are supported and installed on your system.
perl: warning: Falling back to the standard locale ("C").
Address: 10.56.63.84
Address: 10.56.14.175
Address: 10.56.14.171
Address: 10.56.14.163
Address: 10.56.63.80
Address: 10.56.63.75
Address: 10.56.63.88
Address: 10.56.14.180
Address: 10.56.52.80
Address: 10.56.14.177
Address: 10.56.52.30
Address: 10.56.14.173
Address: 10.56.63.89
Address: 10.56.14.178
Address: 10.56.63.90
Address: 10.56.52.29
Address: 10.56.63.82
Address: 10.56.14.162
Address: 10.56.14.172
Address: 10.56.63.77
Address: 10.56.14.174
Address: 10.56.63.83
Address: 10.56.63.79
Address: 10.56.14.179
Address: 10.56.63.81
Address: 10.56.14.176
Address: 10.56.63.86
Address: 10.56.63.91
Address: 10.56.52.82
Address: 10.56.63.87
[root@cd-pos-13-139 ~]# iptables -A INPUT -s 10.56.53.79 -j DROP^C
[root@cd-pos-13-139 ~]#  perl -ne ' use Socket;  /^(.*): / ;  system("nslookup $1") '  stam | grep -v '10.56.14.161' | grep Address | perl -ne ' / (.*)$/ ; print "Blocking IP $1 \n";'
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
	LANGUAGE = (unset),
	LC_ALL = (unset),
	LC_CTYPE = "UTF-8",
	LANG = "en_US.UTF-8"
    are supported and installed on your system.
perl: warning: Falling back to the standard locale ("C").
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
	LANGUAGE = (unset),
	LC_ALL = (unset),
	LC_CTYPE = "UTF-8",
	LANG = "en_US.UTF-8"
    are supported and installed on your system.
perl: warning: Falling back to the standard locale ("C").
Blocking IP 10.56.63.84 
Blocking IP 10.56.14.175 
Blocking IP 10.56.14.171 
Blocking IP 10.56.14.163 
Blocking IP 10.56.63.80 
Blocking IP 10.56.63.75 
Blocking IP 10.56.63.88 
Blocking IP 10.56.14.180 
Blocking IP 10.56.52.80 
Blocking IP 10.56.14.177 
Blocking IP 10.56.52.30 
Blocking IP 10.56.14.173 
Blocking IP 10.56.63.89 
Blocking IP 10.56.14.178 
Blocking IP 10.56.63.90 
Blocking IP 10.56.52.29 
Blocking IP 10.56.63.82 
Blocking IP 10.56.14.162 
Blocking IP 10.56.14.172 
Blocking IP 10.56.63.77 
Blocking IP 10.56.14.174 
Blocking IP 10.56.63.83 
Blocking IP 10.56.63.79 
Blocking IP 10.56.14.179 
Blocking IP 10.56.63.81 
Blocking IP 10.56.14.176 
Blocking IP 10.56.63.86 
Blocking IP 10.56.63.91 
Blocking IP 10.56.52.82 
Blocking IP 10.56.63.87 
[root@cd-pos-13-139 ~]#  perl -ne ' use Socket;  /^(.*): / ;  system("nslookup $1") '  stam | grep -v '10.56.14.161' | grep Address | perl -ne ' / (.*)$/ ; print "Blocking IP $1 \n"; system ("iptables -A INPUT -s $1 -j DROP "); '
perl: warning: Setting locale failed.
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
perl: warning: Please check that your locale settings:
	LANGUAGE = (unset),
	LANGUAGE = (unset),
	LC_ALL = (unset),
	LC_ALL = (unset),
	LC_CTYPE = "UTF-8",
	LC_CTYPE = "UTF-8",
	LANG = "en_US.UTF-8"
	LANG = "en_US.UTF-8"
    are supported and installed on your system.
    are supported and installed on your system.
perl: warning: Falling back to the standard locale ("C").
perl: warning: Falling back to the standard locale ("C").
Blocking IP 10.56.63.84 
Blocking IP 10.56.14.175 
Blocking IP 10.56.14.171 
Blocking IP 10.56.14.163 
Blocking IP 10.56.63.80 
Blocking IP 10.56.63.75 
Blocking IP 10.56.63.88 
Blocking IP 10.56.14.180 
Blocking IP 10.56.52.80 
Blocking IP 10.56.14.177 
Blocking IP 10.56.52.30 
Blocking IP 10.56.14.173 
Blocking IP 10.56.63.89 
Blocking IP 10.56.14.178 
Blocking IP 10.56.63.90 
Blocking IP 10.56.52.29 
Blocking IP 10.56.63.82 
Blocking IP 10.56.14.162 
Blocking IP 10.56.14.172 
Blocking IP 10.56.63.77 
Blocking IP 10.56.14.174 
Blocking IP 10.56.63.83 
Blocking IP 10.56.63.79 
Blocking IP 10.56.14.179 
Blocking IP 10.56.63.81 
Blocking IP 10.56.14.176 
Blocking IP 10.56.63.86 
Blocking IP 10.56.63.91 
Blocking IP 10.56.52.82 
Blocking IP 10.56.63.87 
[root@cd-pos-13-139 ~]# iptables -L INPUT -n --line-numbers
Chain INPUT (policy DROP)
num  target     prot opt source               destination         
1    ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED 
2    RATELIMIT  all  --  0.0.0.0/0            0.0.0.0/0           
3    DROP       all  --  10.56.63.84          0.0.0.0/0           
4    DROP       all  --  10.56.14.175         0.0.0.0/0           
5    DROP       all  --  10.56.14.171         0.0.0.0/0           
6    DROP       all  --  10.56.14.163         0.0.0.0/0           
7    DROP       all  --  10.56.63.80          0.0.0.0/0           
8    DROP       all  --  10.56.63.75          0.0.0.0/0           
9    DROP       all  --  10.56.63.88          0.0.0.0/0           
10   DROP       all  --  10.56.14.180         0.0.0.0/0           
11   DROP       all  --  10.56.52.80          0.0.0.0/0           
12   DROP       all  --  10.56.14.177         0.0.0.0/0           
13   DROP       all  --  10.56.52.30          0.0.0.0/0           
14   DROP       all  --  10.56.14.173         0.0.0.0/0           
15   DROP       all  --  10.56.63.89          0.0.0.0/0           
16   DROP       all  --  10.56.14.178         0.0.0.0/0           
17   DROP       all  --  10.56.63.90          0.0.0.0/0           
18   DROP       all  --  10.56.52.29          0.0.0.0/0           
19   DROP       all  --  10.56.63.82          0.0.0.0/0           
20   DROP       all  --  10.56.14.162         0.0.0.0/0           
21   DROP       all  --  10.56.14.172         0.0.0.0/0           
22   DROP       all  --  10.56.63.77          0.0.0.0/0           
23   DROP       all  --  10.56.14.174         0.0.0.0/0           
24   DROP       all  --  10.56.63.83          0.0.0.0/0           
25   DROP       all  --  10.56.63.79          0.0.0.0/0           
26   DROP       all  --  10.56.14.179         0.0.0.0/0           
27   DROP       all  --  10.56.63.81          0.0.0.0/0           
28   DROP       all  --  10.56.14.176         0.0.0.0/0           
29   DROP       all  --  10.56.63.86          0.0.0.0/0           
30   DROP       all  --  10.56.63.91          0.0.0.0/0           
31   DROP       all  --  10.56.52.82          0.0.0.0/0           
32   DROP       all  --  10.56.63.87          0.0.0.0/0     

	7.6  replace last line matching pattern
[yizaq@YIZAQ-M-D1BW:Wed Sep 16:~/Desktop/Work/scripts/ISE:]$ ed temp
temp: No such file or directory
a
a
b
c
a
b
.
w
10
q
[yizaq@YIZAQ-M-D1BW:Wed Sep 16:~/Desktop/Work/scripts/ISE:]$  perl -e '@a=reverse<>;END{for(@a){if(/a/){s/a/c/;last}}print reverse @a}' temp
a
b
c
c
b
[yizaq@YIZAQ-M-D1BW:Wed Sep 16:~/Desktop/Work/scripts/ISE:]$  perl -e '@a=reverse<>;END{for(@a){if(/a/){s/a/c/;last}}print reverse @a}' temp
[yizaq@YIZAQ-M-D1BW:Wed Sep 16:~/Desktop/Work/scripts/ISE:]$  perl -i.bak -e '@a=reverse<>;END{for(@a){if(/a/){s/a/c/;last}}print reverse @a}' temp
a
b
c
c
b
[yizaq@YIZAQ-M-D1BW:Wed Sep 16:~/Desktop/Work/scripts/ISE:]$ cat temp.bak 
a
b
c
a
b

8. Oneliners

	8.1 Intro
Perl one-liners are small and awesome Perl programs that fit in a single line of code. They do one thing really well—like changing line spacing, numbering lines, performing calculations, converting and substituting text, deleting and printing specific lines, parsing logs, editing files in-place, calculating statistics, carrying out system administration tasks, or updating a bunch of files at once. Perl one-liners will make you a shell warrior: what took you minutes (or even hours) to solve will now take you only seconds!

In this introductory chapter, I’ll show you what one-liners look like and give you a taste of what’s in the rest of the book. This book requires some Perl knowledge, but most of the one-liners can be tweaked and modified without knowing the language in depth.

Let’s look at some examples. Here’s one:

perl -pi -e 's/you/me/g' file

This one-liner replaces all occurrences of the text you with me in the file file. Very useful if you ask me. Imagine you’re on a remote server and you need to replace text in a file. You can either open the file in a text editor and execute find-replace or simply perform the replacement through the command line and, bam, be done with it.

This one-liner and others in this book work well in UNIX. I’m using Perl 5.8 to run them, but they also work in newer Perl versions, such as Perl 5.10 and later. If you’re on a Windows computer, you’ll need to change them a little. To make this one-liner work on Windows, swap the single quotes for double quotes. To learn more about using Perl one-liners on Windows, see Appendix B.

I’ll be using Perl’s -e command-line argument throughout the book. It allows you to use the command line to specify the Perl code to be executed. In the previous one-liner, the code says “do the substitution (s/you/me/g command) and replace you with me globally (/g flag).” The -p argument ensures that the code is executed on every line of input and that the line is printed after execution. The -i argument ensures that file is edited in-place. Editing in-place means that Perl performs all the substitutions right in the file, overwriting the content you want to replace. I recommend that you always make a backup of the file you’re working with by specifying the backup extension to the -i argument, like this:

perl -pi.bak -e 's/you/me/g' file

Now Perl creates a file.bak backup file first and only then changes the contents of file.

How about doing this same replacement in multiple files? Just specify the files on the command line:

perl -pi -e 's/you/me/g' file1 file2 file3

Here, Perl first replaces you with me in file1 and then does the same in file2 and file3.

You can also perform the same replacement only on lines that match we, as simply as this:

perl -pi -e 's/you/me/g if /we/' file

Here, you use the conditional if /we/ to ensure that s/you/me/g is executed only on lines that match the regular expression /we/.

The regular expression can be anything. Say you want to execute the substitution only on lines with digits in them. You could use the /\d/ regular expression to match numbers:

perl -pi -e 's/you/me/g if /\d/' file

How about finding all lines in a file that appear more than once?

perl -ne 'print if $a{$_}++' file

This one-liner records the lines you’ve seen so far in the %a hash and counts the number of times it sees the lines. If it has already seen the line, the condition $a{$_}++ is true, so it prints the line. Otherwise it “automagically” creates an element that contains the current line in the %a hash and increments its value. The $_ special variable contains the current line. This one-liner also uses the -n command-line argument to loop over the input, but unlike -p, it doesn’t print the lines automatically. (Don’t worry about all the command-line arguments right now; you’ll learn about them as you work through this book!)

How about numbering lines? Super simple! Perl’s $. special variable maintains the current line number. Just print it together with the line:

perl -ne 'print "$. $_"' file

You can do the same thing by using the -p argument and modifying the $_ variable:

perl -pe '$_ = "$. $_"' file

Here, each line is replaced by the string "$. $_", which is equal to the current line number followed by the line itself. (See one-liner 3.1 on page 17 for a full explanation.)

If you omit the filename at the end of the one-liner, Perl reads data from standard input. From now on, I’ll assume the data comes from the standard input and drop the filename at the end. You can always put it back if you want to run one-liners on whole files.

You can also combine the previous two one-liners to create one that numbers only the repeated lines:

perl -ne 'print "$. $_" if $a{$_}++'

Another thing you can do is sum the numbers in each line using the sum function from the List::Util CPAN module. CPAN (Comprehensive Perl Archive Network; http://www.cpan.org/) is an archive of over 100,000 reusable Perl modules. List::Util is one of the modules on CPAN, and it contains various list utility functions. You don’t need to install this module because it comes with Perl. (It’s in Perl core.)

perl -MList::Util=sum -alne 'print sum @F'

The -MList::Util command-line argument imports the List::Util module. The =sum part of this one-liner imports the sum function from the List::Util module so that the program can use the function. Next, -a enables the automatic splitting of the current line into fields in the @F array. The splitting happens on the whitespace character by default. The -l argument ensures that print outputs a newline at the end of each line. Finally, sum @F sums all the elements in the @F list, and print prints the result followed by a newline (which I added with the -l argument). (See one-liner 4.2 on page 30 for a more detailed explanation.)

How about finding the date 1299 days ago? Try this:

perl -MPOSIX -le
  '@t = localtime; $t[3] -= 1299; print scalar localtime mktime @t'

I explain this example in detail in one-liner 4.19 (page 41), but basically you modify the fourth element of the structure returned by localtime, which happens to be days. You simply subtract 1299 days from the current day and then reassemble the result into a new time with localtime mktime @t and print the result in the scalar context to display human-readable time.

How about generating an eight-letter password? Here you go:

perl -le 'print map { ("a".."z")[rand 26] } 1..8'

The "a".."z" generates a list of letters from a to z (for a total of 26 letters). Then you randomly choose a letter eight times! (This example is explained in detail in one-liner 5.4 on page 51.)

Or suppose you want to find the decimal number that corresponds to an IP address. You can use unpack to find it really quickly:

perl -le 'print unpack("N", 127.0.0.1)'

This one-liner uses a v-string, which is a version literal. V-strings offer a way to compose a string with the specified ordinals. The IP address 127.0.0.1 is treated as a v-string, meaning the numbers 127, 0, 0, 1 are concatenated together into a string of four characters, where the first character has ordinal value 127, the second and third characters have ordinal values 0, and the last character has ordinal value 1. Next, unpack unpacks them to a single decimal number in “network” (big-endian) order. (See one-liner 4.27 on page 45 for more.)

What about calculations? Let’s find the sum of the numbers in the first column in a table:

perl -lane '$sum += $F[0]; END { print $sum }'

The lines are automatically split into fields with the -a argument, which can be accessed through the @F array. The first element of the array, $F[0], is the first column, so you simply sum all the columns with $sum += $F[0]. When the Perl program finishes, it executes any code in the END block, which, in this case, prints the total sum. Easy!

Now let’s find out how many packets have passed through iptables rules:

iptables -L -nvx | perl -lane '$pkts += $F[0]; END { print $pkts }'

The iptables program outputs the packets in the first column. All you have to do to find out how many packets have passed through the firewall rules is sum the numbers in the first column. Although iptables will output table headers as well, you can safely ignore these because Perl converts them to zero for the += operation.

How about getting a list of all users on the system?

perl -a -F: -lne 'print $F[4]' /etc/passwd

Combining -a with the -F argument lets you specify the character where lines should be split, which, by default, is whitespace. Here, you split lines on the colon character, the record separator of /etc/passwd. Next, you print the fifth field, $F[4], which contains the user’s real name.

If you ever get lost with command-line arguments, remember that Perl comes with a fantastic documentation system called perldoc. Type perldoc perlrun at the command line. This will display the documentation about how to run Perl and all the command-line arguments. It’s very useful when you suddenly forget which command-line argument does what and need to look it up quickly. You may also want to read perldoc perlvar, which explains variables; perldoc perlop, which explains operators; and perldoc perlfunc, which explains functions.

Perl one-liners let you accomplish many tasks quickly. You’ll find over 130 one-liners in this book. Read them, try them, and soon enough you’ll be the local shell wizard. (Just don’t tell your friends—unless you want competition.)

Enjoy!



	8.2 Spacing

		8.2.1 Double-space a file

perl -pe '$\ = "\n"' file

This one-liner double-spaces a file. I need to explain three things here: the -p and -e command-line options and the short $\ = "\n" Perl program.

Use the -e option to enter a Perl program directly at the command line. Typically you won’t want to create source files for every small program; with -e you can easily write a program directly at the command line as a one-liner. In this case, the entire Perl program contained in this one-liner is $\ = "\n". Be sure to use single quotes (') around the program, or your shell will interpret things like $\ as shell variables, which have no value, effectively removing them!

Now let’s look at the -p switch. Specifying -p tells Perl to assume the following loop around your program:

while (<>) {
    # your program goes here (specified by -e)
} continue {
    print or die "-p failed: $!\n";
}

Broadly speaking, this construct loops over all the input, executes your code, and prints the value of $_ (the print statement prints the value of $_), which allows you to modify all or some lines of the input quickly. The $_ variable is a special variable that gets replaced with the current line of text. It can be replaced with other stuff as well. You’ll learn all about $_ as you work through the book. (See Appendix A for a summary of its use cases.)

But understanding what is going on in this loop in more detail is important. First, the while (<>) loop takes each line from the standard input and puts it in the $_ variable. Next, the code specified by -e is executed, followed by the print or die portion.

The continue statement executes the print or die statement after each line, which attempts to print the contents of the $_ variable. If the attempt fails (for example, the terminal is not writable or standard output has been redirected to something that isn’t writable), die makes Perl exit (die) with an error message.

In this one-liner, the code specified by -e is $\ = "\n", so the program that Perl executes looks like this:

while (<>) {
    $\ = "\n";
} continue {
    print or die "-p failed: $!\n";
}

This Perl program reads each line into the $_ variable and then sets $\ to a newline and calls print. Another special variable is $\. It is similar to the ORS (Output Record Separator) variable in Awk in that it is appended after every print operation. A print statement with no arguments prints the contents of $_ and appends $\ at the end of the output. As a result, each line is printed unmodified, followed by the $\, which was set to newline. The input is now double-spaced.

In fact, you actually do not need to set $\ to newline for every line; you can set it just once at the beginning of the program:

perl -pe 'BEGIN { $\ = "\n" }' file

This one-liner sets $\ to the newline character just once before Perl does anything in the BEGIN code block. The BEGIN block is a special code block that is executed before everything else in a Perl program. Here’s what the expanded Perl program looks like, and it works exactly the same way as the previous one-liner:

BEGIN { $\ = "\n" }
while (<>) {
} continue {
    print or die "-p failed: $!\n";
}

Here is another way to double-space a file. This one-liner appends another newline character at the end of each line and then prints the line:

perl -pe '$_ .= "\n"' file

This one-liner is equivalent to

while (<>) {
    $_ = $_ . "\n"
} continue {
    print or die "-p failed: $!\n";
}

Writing $_ = $_ . "\n" is the same as writing $_ .= "\n". This expression simply concatenates $_ with "\n". (The period (.) is the string concatenation operator.)

But probably the cleanest way to double-space a file is to use the substitution operator s:

perl -pe 's/$/\n/' file

This one-liner replaces the regular expression $ that matches the end of a line with a newline, effectively adding a newline at the end.

If you’re running Perl 5.10 or later, you can use the say operator. The say operator acts much like print, but it always adds a newline at the end of the line. In Perl 5.10, this same one-liner can be written like this:

perl -nE 'say' file

The -E command-line argument works exactly the same way as the -e command-line argument, but it also enables Perl 5.10 features, including the say operator. The -n argument is similar to -p, but you have to print the line yourself. (I explain the -n argument in more detail in one-liner 2.6.) This one-liner prints the line, followed by another newline that’s appended by the say operator.

For example, if a file contains four lines:

line1
line2
line3
line4

running any of these one-liners outputs the following:

line1
line2
line3
line4

In these first few examples, I passed a filename as the last argument to the one-liners. When I do that, the one-liners operate on the contents of that file. If I didn’t pass a filename to the one-liners, they’d operate on the data from the standard input. From now on I won’t specify a file at the end of the one-liners, but you can always add it back if you want to run the one-liners on files. When writing one-liners, it’s a good idea to quickly test if they’re correct by typing something directly to the standard input. Then when you’re sure the one-liner works, you can pass one or more filenames at the end.

Again, don’t forget about Perl’s handy documentation system, perldoc. Just type perldoc perlrun at the command line to display information about how to run Perl and all the command-line arguments.

		8.2.2 Triple-space a file

You can also triple-space a file simply by outputting more newlines at the end of each line:

perl -pe '$\ = "\n\n"'

Or

perl -pe '$_ .= "\n\n"'

Or

perl -pe 's/$/\n\n/'

These one-liners are similar to the first one-liner in this chapter, except that two newlines are appended after each line.

		8.2.3 N-space a file

perl -pe '$_ .= "\n"x7'

This one-liner inserts seven newlines after each line. Notice how I’ve used "\n" x 7 to repeat the newline character seven times. The x operator repeats the value on the left N times.

For example, the line

perl -e 'print "foo"x5'

prints foofoofoofoofoo.

As a side note, sometimes when you need to generate a certain amount of data, the x operator comes in really handy. For example, to generate 1KB of data, you could do this:

perl -e 'print "a"x1024'

This one-liner prints the a character 1024 times.

		8.2.4 Add a blank line before every line

perl -pe 's/^/\n/'

This one-liner uses the s/regex/replace/ operator. It substitutes the given regular expression with the replacement. In this one-liner, the operator is s/^/\n/, the regular expression is ^, and the replacement is \n. The ^ pattern matches the beginning position of the text, and the s operator replaces it with \n, a newline. As a result, the newline character is inserted before the line. To insert something else before the line, simply replace \n with the bit to be inserted.

		8.2.5 Remove all blank lines

perl -ne 'print unless /^$/'

This one-liner uses the -n flag, which tells Perl to assume a different loop, other than -p, around the program:

while (<>) {
    # your program goes here
}

Compare this loop to the one that Perl assumes when you specify -p, and you’ll see that this loop has no continue { print or die } part. In this loop, each line is read by the diamond operator <> and is placed in the special variable $_, but it’s not printed! You have to print the line yourself—a useful feature if you want to print, modify, or delete lines selectively.

In this one-liner, the code is print unless /^$/, so the entire Perl program becomes

while (<>) {
    print unless /^$/
}

Unraveling this a bit further, you get this:

while (<>) {
    print $_ unless $_ =~ /^$/
}

This one-liner prints all nonblank lines. (You saw the /^$/ regular expression in one-liner 2.2 on page 11.)

This one-liner also removes all blank lines:

perl -lne 'print if length'

This one-liner uses the -l command-line argument, which automatically chomps the input line (basically removes the newline at the end) and appends it back at the end of the line when printing. The code specified to the -e argument is 'print if length', which says “print the line if it has some length.” Empty lines have a length of 0, so they’re not printed (0 is a false value in Perl, so the if length condition evaluates to false). All other lines have length and are printed. Without -l, the string would still have the newline at the end and thus be 1 or 2 characters long![1]

Here’s another one-liner to remove all blank lines:

perl -ne 'print if /\S/'

This one-liner behaves slightly differently from the previous two. Both print unless /^$/ and print if length also print the lines that consist of only spaces and/or tabs. Such lines appear to be empty to the eye, and you may want to filter them. This one-liner uses \S (explained in one-liner 2.2 on page 11), a regular expression sequence that matches nonblank characters. Lines containing only spaces and/or tabs don’t match \S and therefore are not printed.

As you can see, you can write the same program in many different ways. In fact, Perl’s motto is There’s More Than One Way To Do It, which is abbreviated as TIMTOWTDI and pronounced “Tim Toady.” (Fun trivia: Larry Wall, the inventor of Perl, uses the handle @TimToady on Twitter and IRC.)

		8.2.6 Remove all consecutive blank lines, leaving only one

perl -00 -pe ''

This one-liner is really tricky, isn’t it? First, it doesn’t have any code! The -e is empty. Next, it has a silly -00 command-line option that turns paragraph slurp mode on, meaning Perl reads text paragraph by paragraph, rather than line by line. (A paragraph is text between two or more newlines.) The paragraph is put into $_, and the -p option prints it out.

You can even write this in a shorter fashion:

perl -00pe0

Here, the code specified to -e is 0, which does nothing.

This is one of my favorite one-liners because if you haven’t seen it before, it can be tricky to figure out, and I love mind games. (There’s no code specified to -e! How can it possibly do something?)


		8.2.7 Compress/expand all blank lines into N consecutive lines

Say you have a file with two blank lines after each paragraph, and you wish to expand the line spacing between the paragraphs to three lines. To do so, you can simply combine one-liners 2.4 and 2.7 like this:

perl -00 -pe '$_ .= "\n"x2'

This one-liner slurps lines paragraph-wise via the -00 option and then appends three newline characters after each paragraph. The code "\n"x2 prints two newlines, which are added to the blank line already at the end of the paragraph.

In a similar vein, you can also reduce the spacing between paragraphs. Say you’ve got a file that for some crazy reason has ten blank lines between paragraphs, and you want to compress these blank lines to just three. You can use the same one-liner again!

		8.2.8 Double-space between all words

perl -pe 's/ /  /g'

Here, you use the substitution operator s to replace one space “ ” with two spaces “ ” globally on each line (the /g flag makes the replacement global), and you’re done. It’s that simple!

Here’s an example. Let’s say you have this line of text:

this line doesn't have enough whitespace!

Running this one-liner increases the spacing between words:

this  line  doesn't  have  enough  whitespace!

		8.2.9 Remove all spacing between words

perl -pe 's/ +//g'

This one-liner uses the “+” regular expression to match one or more spaces. When it finds a match, it substitutes it with nothing, globally, which deletes all spaces between words.

If you also want to get rid of tabs and other special characters that might add spacing, use the \s+ regular expression, which means “match a space, a tab, a vertical tab, a newline, or a carriage return”:

perl -pe 's/\s+//g'

Here’s an example. Let’s say you have this line of text:

this line has too much whitespace said cowboy neal

Running this one-liner removes all spaces:

thislinehastoomuchwhitespacesaidcowboyneal

		8.2.10 Change all spacing between words to one space

perl -pe 's/ +/ /g'

This one-liner is similar to the previous one, except that it replaces one or more spaces with just one space.

For example, if you have this line:

this   line has really           messed-up                    spacing

running this one-liner normalizes the spacing between words to one space:

this line has really messed-up spacing

		8.2.11 Insert a space between all characters

perl -lpe 's// /g'

Here you match seemingly nothing and replace it with a single space. The nothingness actually means “match between characters,” with the result that you insert a space between all characters. (The matching includes the beginning and end of the text.)

For example, given this line:

today was a great day

running this one-liner produces this result:

t o d a y   w a s   a   g r e a t   d a y

It might be difficult to see where all the spaces are added, so let’s illustrate that by modifying this one-liner to insert a colon between all characters:

perl -lpe 's//:/g'

This will output:

:t:o:d:a:y: :w:a:s: :a: :g:r:e:a:t: :d:a:y:

As you can see, spaces (or colons) are also inserted at the beginning and end of the text. Also note that the existing spaces count as characters, so they’re triple-spaced.


		8.2.12
		8.3 Numbering

			8.3.1  Number all lines in a file

perl -pe '$_ = "$. $_"'

As I explained in one-liner 2.1 (page 7), -p tells Perl to assume a loop around the program (specified by -e) that reads each line of input into the $_ variable, executes the program, and then prints the contents of the $_ variable.

This one-liner simply modifies $_ by prepending the $. variable to it. The special variable $. contains the current line number of the input. The result is that each line has its line number prepended.

Similarly, you can also use the -n argument and print the string "$. $_", which is the current line number followed by the line:

perl -ne 'print "$. $_"'

Say a file contains three lines:

foo
bar
baz

Running this one-liner numbers them:

1 foo
2 bar
3 baz

[yizaq@yizaq-mac:Tue Jan 21:~:]$ perl -pe '$_ = "$. $_";' stam
1 ﻿ct diff -pred -g /vob/nm_acs/acs/runtime/infrastructure/diagnostics/src/DiagnosticsManager.cpp
2 ct diff -pred -g /vob/nm_acs/acs/runtime/infrastructure/diagnostics/src/DiagnosticMediator.h
3 ct diff -pred -g /vob/nm_acs/acs/runtime/infrastructure/diagnostics/src/DiagnosticMediator.cpp
4 

			8.3.2  Number only non-empty lines in a file

perl -pe '$_ = ++$x." $_" if /./'

Here you employ an “action if condition” statement that executes an action only if the condition is true. In this case, the condition is the regular expression /./, which matches all characters other than newline (that is, it matches a non-empty line). The action $_ = ++$x." $_" prepends the variable $x incremented by one to the current line. Because you’re not using the strict pragma, $x is created automatically the first time it’s incremented.

The result is that at each non-empty line $x is incremented by one and prepended to that line. Nothing is modified at the empty lines, and they are printed as is.

One-liner 2.2 (page 11) shows another way to match non-empty lines through the \S regular expression:

perl -pe '$_ = ++$x." $_" if /\S/'

Say a file contains four lines, two of which are empty:

line1
line4

Running this one-liner numbers only lines one and four:

1 line1
2 line4

[yizaq@yizaq-mac:Tue Jan 21:~:]$ perl -pe '$_ = ++$y . " $_" if /./;' stam
1 ﻿ct diff -pred -g /vob/nm_acs/acs/runtime/infrastructure/diagnostics/src/DiagnosticsManager.cpp
2 ct diff -pred -g /vob/nm_acs/acs/runtime/infrastructure/diagnostics/src/DiagnosticMediator.h
3 ct diff -pred -g /vob/nm_acs/acs/runtime/infrastructure/diagnostics/src/DiagnosticMediator.cpp

			8.3.3  Number and print only non-empty lines in a file (drop empty lines)

perl -ne 'print ++$x." $_" if /./'

This one-liner uses the -n program argument, which places the line in the $_ variable and then executes the program specified by -e. Unlike -p, -n does not print the line after executing the code in -e, so you have to call print explicitly to print the contents of the $_ variable.

The one-liner calls print only on lines with at least one character, and as in the previous one-liner, it increments the line number in the variable $x by one for each non-empty line. The empty lines are ignored and never printed.

Say a file contains the same four lines as in one-liner 3.2:

line1
line4

Running this one-liner drops the empty lines and numbers lines one and four:

1 line1
2 line4
			8.3.4  Number all lines but print line numbers only for non-empty lines

perl -pe '$_ = "$. $_" if /./'

This one-liner is similar to one-liner 3.2. Here, you modify the $_ variable that holds the entire line only if the line has at least one character. All other empty lines are printed as is, without line numbers.

Say a file contains four lines:

line1

line4

Running this one-liner numbers all the lines but prints the line numbers only for lines one and four:

1 line1

4 line4


example:
[yizaq@YIZAQ-M-D1BW:Tue Feb 24:~/.vim/bundle:]$ perl -pe '$_ = "$. $_" if /./' Gundo/README 
1 This is a mirror of http://www.vim.org/scripts/script.php?script_id=3304

3 Gundo is a Vim plugin for visualizing your undo tree to make it usable.

5 Go to the site for more information: http://sjl.bitbucket.org/gundo.vim/

7 Requirements: Vim 7.3+ with Python 2.4+ support.
[yizaq@YIZAQ-M-D1BW:Tue Feb 24:~/.vim/bundle:]$ cat !$
cat Gundo/README
This is a mirror of http://www.vim.org/scripts/script.php?script_id=3304

Gundo is a Vim plugin for visualizing your undo tree to make it usable.

Go to the site for more information: http://sjl.bitbucket.org/gundo.vim/

Requirements: Vim 7.3+ with Python 2.4+ support.

			8.3.5  Number only lines that match a pattern; print others unmodified

perl -pe '$_ = ++$x." $_" if /regex/'

Here, again, you use an “action if condition” statement, and again the condition is a pattern (a regular expression): /regex/. The action is the same as in one-liner 3.2.

Say a file contains these lines:

record foo
bar baz
record qux

and you want to number the lines that contain the word record. You can replace /regex/ in the one-liner with /record/:

perl -pe '$_ = ++$x." $_" if /record/'

When you run this one-liner, it gives you the following output:

1 record foo
bar baz
2 record qux
			8.3.6  Number and print only lines that match a pattern

perl -ne 'print ++$x." $_" if /regex/'

This one-liner is almost exactly like one-liner 3.3, except it only numbers and prints lines that match /regex/. It doesn’t print nonmatching lines.

For example, a file contains the same lines as in one-liner 3.5:

record foo
bar baz
record qux

And let’s say you want to number and print only the lines that contain the word record. In this case, changing /regex/ to /record/ and running the one-liner gives you this result:

1 record foo
2 record qux
			8.3.7  Number all lines in a file using a custom format

perl -ne 'printf "%-5d %s", $., $_'

This one-liner uses printf to print the line number together with the line contents. printf does formatted printing. You specify the format and send it the data to print, and it formats and prints the data accordingly. Here, the format for the line numbers is %-5d, which aligns the line numbers five positions to the left.

Here’s an example. Say the input to this one-liner is

hello world
bye world

Then the output is

1     hello world
2     bye world

Other format strings include %5d, which aligns the line numbers five positions to the right, and %05d, which zero-fills and right-justifies the line numbers. Here’s the output you get with the %5d format string for line numbers:

    1 hello world
    2 bye world

And this is what you get with the %05d format string:

00001 hello world
00002 bye world

To learn more about the various formats that are available, run perldoc -f sprintf at the command line.

			8.3.8  Print the total number of lines in a file (emulate wc -l)

perl -lne 'END { print $. }'

This one-liner uses the END block that Perl took as a feature from the Awk language. The END block is executed once the Perl program has executed. Here, the Perl program is the hidden loop over the input created by the -n argument. Once it loops over the input, the special variable $. contains the number of lines in the input, and the END block prints this variable. The -l parameter sets the output record separator for print to a newline, so you don’t have to print the newline yourself, like this: print "$.\n".

You can do the same thing with this one-liner:

perl -le 'print $n = () = <>'

This one-liner is easy to grasp if you understand Perl contexts well. The () = <> part tells Perl to evaluate the <> operator (the diamond operator) in the list context, which makes the diamond operator read the whole file as a list of lines. Next, you assign this list to $n. Because $n is scalar, this list assignment is evaluated in the scalar context.

What’s really happening here is the = operator is right-associative, meaning the = on the right is done first and the = on the left is done second:

perl -le 'print $n = (() = <>)'

Evaluating a list assignment in the scalar context returns the number of elements in the list; thus, the $n = () = <> construction is equal to the number of lines in the input, that is, the number of lines in the file. The print statement prints this number. The -l argument ensures a newline is added after printing this number.

You can also drop the variable $n from this one-liner and force the scalar context through the scalar operator:

perl -le 'print scalar(() = <>)'

Here, instead of evaluating a list assignment in the scalar context by assigning it again to another scalar, you simply evaluate the list assignment in the scalar context using the scalar operator.

And now for a more obvious version:

perl -le 'print scalar(@foo = <>)'

Here, instead of using an empty list () to force the list context on <>, you use the variable @foo to achieve the same effect.

And here’s another way to do it:

perl -ne '}{print $.'

This one-liner uses the so-called eskimo operator }{ (actually a clever construct) in conjunction with the -n command-line argument. As I explained earlier, the -n argument forces Perl to assume a while(<>) { } loop around the program. The eskimo operator forces Perl to escape the loop, and the one-liner expands to

while (<>) {
}{               # eskimo operator here
    print $.;
}

As you can see, this program just loops over all the input, and once it’s finished, it prints the $., which is the number of lines in the input. It becomes even more obvious if you change the formatting a little:

while (<>) {}
{
    print $.;
}

As you can see, this is just an empty loop that loops over all the input, followed by the print statement wrapped in curly brackets.
--------------------------------------------------------------------------------------------------------------------------------------------
my example:
[yizaq@YIZAQ-M-D1BW:Thu Feb 26:/usr/local/Library:]$ perl -lne 'END {print $. ;}' brew.rb 
177
[yizaq@YIZAQ-M-D1BW:Thu Feb 26:/usr/local/Library:]$ perl -le 'END {print $n = () = <>  ;}' brew.rb 
177
--------------------------------------------------------------------------------------------------------------------------------------------

			8.3.9  3.10 Print the number of non-empty lines in a file

perl -le 'print scalar(grep { /./ } <>)'

This one-liner uses Perl’s grep function, which is similar to the grep UNIX command. Given a list of values, grep { condition } list returns only those values in the list that make the condition true. In this case, the condition is a regular expression that matches at least one character, so the input is filtered and grep{ /./ } returns all non-empty lines. To get the number of lines, you evaluate grep in the scalar context and print the result.

Some Perl programmers like to create the shortest Perl program that does some particular task—an exercise called Perl golfing. A golfer’s version of this one-liner would replace scalar() with ~~ (double bitwise negate) and drop the spaces, shortening it like this:

perl -le 'print ~~grep{/./}<>'

This double bitwise negate trick is effectively a synonym for scalar because the bitwise negation works on scalar values, so grep is evaluated in the scalar context.

You can make this even shorter by dropping the space after print and getting rid of the curly brackets:

perl -le 'print~~grep/./,<>'

If you have Perl 5.10 or later, you can also use the -E command-line switch and the say operator:

perl -lE 'say~~grep/./,<>'

A true golfer’s masterpiece!

--------------------------------------------------------------------------------------------------------------------------------------------
my example:
non empty lines:
[yizaq@YIZAQ-M-D1BW:Thu Feb 26:/usr/local/Library:]$ perl -le 'print scalar (grep {/./}  <>) ; ' brew.rb 
154
empty lines:
[yizaq@YIZAQ-M-D1BW:Thu Feb 26:/usr/local/Library:]$ perl -le 'print scalar (grep {/^$/}  <>) ; ' brew.rb 
23
--------------------------------------------------------------------------------------------------------------------------------------------

			8.3.10 Print the number of empty lines in a file

perl -lne '$x++ if /^$/; END { print $x+0 }'

Here, you use the variable $x to count the number of empty lines encountered. Once you’ve looped over all the lines, you print the value of $x in the END block. You use the $x+0 construction to ensure that 0 is output if no lines are empty. (Otherwise $x is never created and is undefined. Adding +0 to the undefined value produces 0.) An alternative to $x+0 is the int operator:

perl -lne '$x++ if /^$/; END { print int $x }'

You could also modify the previous one-liner by doing this:

perl -le 'print scalar(grep { /^$/ } <>)'

Or write it with ~~:

perl -le 'print ~~grep{ /^$/ } <>'

The ~~ does bitwise negation twice, which makes grep execute in the scalar context and return the number of empty lines.

These last two versions are not as effective as the one-liner with the END block because they read the whole file into memory, whereas the one-liner with the END block does it line by line and, therefore, keeps only one line of input in memory.

			8.3.11 
Print the number of lines in a file that match a pattern (emulate grep -c)

perl -lne '$x++ if /regex/; END { print $x+0 }'

This one-liner is basically the same as 3.11, except it increments the line counter $x by one when a line matches the regular expression /regex/. The $x+0 trick makes sure 0 is printed when no lines match /regex/. (See one-liner 3.11 for a more detailed explanation of the $x+0 trick.)

			8.3.12 Number words across all lines

perl -pe 's/(\w+)/++$i.".$1"/ge'

This one-liner uses the /e flag, which makes Perl evaluate the replace part of the s/regex/replace/ expression as code!

The code here is ++$i.".$1", which means “increment variable $i by one and then add it in front of the string ".$1" (that is, a dot followed by the contents of the matched group $1).” The matched group here is each word: (\w+).

In one sentence, this one-liner matches a word (\w+), puts it in $1, and then executes the ++$i.".$1" code that numbers the word globally (/g flag). There—all words are numbered.

For example, if you have a file with the following three lines:

just another
perl hacker
hacking perl code

running this one-liner numbers each word in the file and produces the following output:

|  1.just 2.another
|  3.perl 4.hacker
|  5.hacking 6.perl 7.code

[yizaq@YIZAQ-M-D1BW:Thu Feb 26:/usr/local/Library:]$ perl -pe 's/(\w+)/++$i.": $1"/ge' brew.rb  | head
#!/1: System/2: Library/3: Frameworks/4: Ruby.5: framework/6: Versions/7: Current/8: usr/9: bin/10: ruby -11: W0

12: std_trap = 13: trap("14: INT") { 15: exit! 16: 130 } # 17: no 18: backtrace 19: thanks

20: HOMEBREW_BREW_FILE = 21: ENV['22: HOMEBREW_BREW_FILE']

23: if 24: ARGV == %25: w{--26: prefix}
  27: puts 28: File.29: dirname(30: File.31: dirname(32: HOMEBREW_BREW_FILE))
  33: exit 34: 0
35: end

			8.3.13 Number words on each individual line

perl -pe '$i=0; s/(\w+)/++$i.".$1"/ge'

This is similar to one-liner 3.13, except that you reset the $i variable to 0 on each line. Here’s the result of running this one-liner on the example from one-liner 3.13:

| 1.just 2.another
| 1.perl 2.hacker
| 1.hacking 2.perl 3.code

As you can see, in each line the words are numbered independently of other lines.

[yizaq@YIZAQ-M-D1BW:Sun Mar 01:~/Desktop/Work:]$ perl -pe '$i=0; s/(\w+)/"(".++$i.")$1"/ge ' context_Apr_2014  | head
(1)This (2)file (3)contains (4)work (5)related (6)notes (7)for (8)Yosi (9)Izaq, (10)yizaq@(11)cisco.(12)com
(1)File (2)name: /(3)Users/(4)yizaq/(5)Desktop/(6)Work/(7)context_Apr_2014

     -> <(1)URL:~/(2)Desktop/(3)Work/(4)context_Jan_2014>
     -> <(1)URL:~/(2)Desktop/(3)Work/(4)context_Feb_2014>
     -> <(1)URL:~/(2)Desktop/(3)Work/(4)context_Jan_2014>
     -> <(1)URL:~/(2)Desktop/(3)Work/(4)ISE/(5)PBIS/(6)PBIS_notes>
     -> <(1)URL:~/(2)Desktop/(3)Work/(4)acs/(5)5.(6)0/(7)AD/(8)ADClientPlan>
     -> <(1)URL:~/(2)Desktop/(3)Work/(4)acs/(5)5.(6)0/(7)AD/(8)MAR_Plan>
     -> <(1)URL:~/(2)Desktop/(3)Work/(4)acs/(5)5.(6)1/(7)CoA/(8)CoA_Plan>

			8.3.14 Replace all words with their numeric positions

			perl -pe 's/(\w+)/++$i/ge'

			This one-liner is almost the same as one-liner 3.13. Here, you simply replace each word with its numeric position, which is kept in the variable $i. For example, if you run this one-liner on the file from one-liners 3.13 and 3.14, it replaces the words in the file with their numeric positions to produce this output:

			1 2
			3 4
			5 6 7


			8.3.15  

			8.3.16 


		8.4 Calculations

			8.4.1  Check if a number is a prime

perl -lne '(1x$_) !~ /^1?$|^(11+?)\1+$/ && print "$_ is prime"'

This one-liner uses an ingenious regular expression by Abigail to detect whether a given number is a prime. (Don’t take this regular expression too seriously; I’ve included it for its artistic value. For serious purposes, use the Math::Primality module from CPAN to see whether a number is prime.)

Here’s how this ingenious one-liner works: First, the number is converted into its unary representation by (1x$_). For example, 5 is converted into 1x5, which is 11111 (1 repeated 5 times). Next, the unary number is tested against the regular expression. If it doesn’t match, the number is a prime; otherwise it’s a composite. The !~ operator is the opposite of the =~ operator and is true if the regular expression doesn’t match.

The regular expression consists of two parts: The first part, ^1?$, matches 1 and the empty string. The empty string and 1 are clearly not prime numbers, so this part of the regular expression discards them.

The second part, ^(11+?)\1+$, determines whether two or more 1s repeatedly make up the whole number. If so, the regular expression matches, which means the number is a composite. If not, it’s a prime.

Now consider how the second part of the regular expression would act on the number 5. The number 5 in unary is 11111, so the (11+?) matches the first two 1s, the back-reference \1 becomes 11, and the whole regular expression now becomes ^11(11)+$. Because it can’t match five 1s, it fails. Next, it attempts to match the first three 1s. The back-reference becomes 111, and the whole regular expression becomes ^111(111)+$, which doesn’t match. The process repeats for 1111 and 11111, which also don’t match, and as a result the entire regular expression doesn’t match and the number is a prime.

What about the number 4? The number 4 is 1111 in unary. The (11+?) matches the first two 1s. The back-reference \1 becomes 11, and the regular expression becomes ^11(11)+$, which matches the original string and confirms that the number is not prime.

[yizaq@YIZAQ-M-D1BW:Sun Mar 01:~/Desktop/Work:]$ echo 11 | perl -lne 'print "got $_" ; (1x$_) !~ /^1?$|^(11+?)\1+$/ && print "$_ is primary" '
got 11
11 is primary
[yizaq@YIZAQ-M-D1BW:Sun Mar 01:~/Desktop/Work:]$ echo 127 | perl -lne 'print "got $_" ; (1x$_) !~ /^1?$|^(11+?)\1+$/ && print "$_ is primary" '
got 127
127 is primary

			8.4.2  Print the sum of all fields on each line

perl -MList::Util=sum -alne 'print sum @F'

This one-liner turns on field auto-splitting with the -a command-line option and imports the sum function from the List::Util module with -Mlist::Util=sum. (List::Util is part of the Perl core, so you don’t need install it.) Auto-splitting happens on whitespace characters by default, and the resulting fields are put in the @F variable. For example, the line 1 4 8 would be split on each space so that @F would become (1, 4, 8). The sum @F statement sums the elements in the @F array, giving you 13.

The -Mmodule=arg option imports arg from module. It’s the same as writing

use module qw(arg);

This one-liner is equivalent to

use List::Util qw(sum);
while (<>) {
    @F = split(' ');
    print sum @F, "\n";
}

You can change auto-splitting’s default behavior by specifying an argument to the -F command-line switch. Say you have the following line:

1:2:3:4:5:6:7:8:9:10

And you wish to find the sum of all these numbers. You can simply specify : as an argument to the -F switch, like this:

perl -MList::Util=sum -F: -alne 'print sum @F'

This splits the line on the colon character and sums all the numbers. The output is 55 because that’s the sum of the numbers 1 through 10.

[yizaq@YIZAQ-M-D1BW:Sun Mar 01:~/Desktop/Work:]$ echo "1 2 3" | perl -MList::Util=sum  -alne 'print "sum is " .  sum @F ' 
sum is 6
			8.4.3  Print the sum of all fields on all lines

perl -MList::Util=sum -alne 'push @S,@F; END { print sum @S }'

This one-liner keeps pushing the split fields in @F to the @S array. Once the input stops and Perl is about to quit, the END { } block is executed and it outputs the sum of all items in @S. This sums all fields over all lines.

Notice how pushing the @F array to the @S array actually appends elements to it. This differs from many other languages, where pushing array1 to array2 would put array1 into array2, rather than appending the elements of array1 onto array2. Perl performs list flattening by design.

Unfortunately, summing all fields on all lines using this solution creates a massive @S array. A better solution is to keep only the running sum, like this:

perl -MList::Util=sum -alne '$s += sum @F; END { print $s }'

Here, each line is split into @F and the values are summed and stored in the running sum variable $s. Once all input has been processed, the one-liner prints the value of $s.
[yizaq@YIZAQ-M-D1BW:Sun Mar 01:~/Desktop/Work:]$  perl -MList::Util=sum  -alne ' $s += sum @F; print $s; END {print "total sum is $s"} ' stam
6
26
2546
total sum is 2546

			8.4.4  Shuffle all fields on each line

perl -MList::Util=shuffle -alne 'print "@{[shuffle @F]}"'

The trickiest part of this one-liner is the @{[shuffle @F]} construction. This construction allows you to execute the code inside the quotation marks. Normally text and variables are placed inside quotation marks, but with the @{[ ... ]} construction you can run code, too.

In this one-liner, the code to execute inside of the quotation marks is shuffle @F, which shuffles the fields and returns the shuffled list. The [shuffle @F] creates an array reference containing the shuffled fields, and the @{ ... } dereferences it. You simply create a reference and immediately dereference it. This allows you to run the code inside the quotation marks.

Let’s look at several examples to understand why I chose to run the code inside the quotation marks. If I had written print shuffle @F, the fields on the line would be concatenated. Compare the output of this one-liner:

$ echo a b c d | perl -MList::Util=shuffle -alne 'print "@{[shuffle @F]}"'
b c d a

to this:

$ echo a b c d | perl -MList::Util=shuffle -alne 'print shuffle @F'
bcda

In the first example, the array of shuffled fields (inside the double quotation marks) is interpolated, and the array’s elements are separated by a space, so the output is b c d a. In the second example, interpolation doesn’t happen, and Perl simply dumps out element by element without separating them, and the output is bcda.

You can use the $, special variable to change the separator between array elements when they’re printed. For example, here’s what happens when I change the separator to a colon:

$ echo a b c d | perl -MList::Util=shuffle -alne '$,=":"; print shuffle @F'
b:c:d:a

You can also use the join function to join the elements of @F with a space:

perl -MList::Util=shuffle -alne 'print join " ", shuffle @F'

Here, the join function joins the elements of an array using the given separator, but the @{[ ... ]} construction is the cleanest way to do it.

			8.4.5  Find the numerically smallest element (minimum element) on each line

perl -MList::Util=min -alne 'print min @F'

This one-liner is somewhat similar to the previous ones. It uses the min function from List::Util. Once the line has been automatically split by -a and the elements are in the @F array, the min function finds the numerically smallest element, which it prints.

For example, if you have a file that contains these lines:

-8  9  10 5
7   0  9  3
5  -25 9  999

Running this one-liner produces the following output:

-8
0
-25

The smallest number on the first line is -8; on the second line, the smallest number is 0; and on the third line, -25.
[yizaq@YIZAQ-M-D1BW:Sun Mar 01:~/Desktop/Work:]$  perl -MList::Util=min  -alne ' print min @F ' stam
1
3
1
[yizaq@YIZAQ-M-D1BW:Sun Mar 01:~/Desktop/Work:]$  perl -MList::Util=max  -alne ' print max @F ' stam
3
9
2391
[yizaq@YIZAQ-M-D1BW:Sun Mar 01:~/Desktop/Work:]$ cat stam
1 2 3
5 9 3 3
102 2391 21 2 3 1

			8.4.6  Find the numerically smallest element (minimum element) over all lines

perl -MList::Util=min -alne '@M = (@M, @F); END { print min @M }'

This one-liner combines one-liners 4.3 and 4.5. The @M = (@M, @F) construct is the same as push @M, @F. It appends the contents of @F to the @M array.

This one-liner stores all data in memory, and if you run it on a really huge file, Perl will run out of memory. Your best bet is to find the smallest element on every line and compare that element with the smallest element on the previous line. If the element on the current line is less than the previous one, it’s the smallest element so far. Once all lines have been processed, you can just print the smallest element found through the END block:

perl -MList::Util=min -alne '
  $min = min @F;
  $rmin = $min unless defined $rmin && $min > $rmin;
  END { print $rmin }
'

Here, you first find the minimum element on the current line and store it in $min. Then you check to see if the smallest element on the current line is the smallest element so far. If so, assign it to $rmin. Once you’ve looped over the whole input, the END block executes and you print the $rmin.

Say your file contains these lines:

-8  9  10 5
7   0  9  3
5  -25 9  999

Running this one-liner outputs -25 because that’s the smallest number in the file.

If you’re using Perl 5.10 or later, you can do the same thing with this one-liner:

perl -MList::Util=min -alne '$min = min($min // (), @F); END { print $min }'

This one-liner uses the // operator, which is new to Perl 5.10. This operator is similar to the logical OR operator (||), except that it tests the left side’s definedness rather than the truth. What that means is it tests whether the left side is defined rather than whether it is true or false. In this one-liner, the expression $min // () returns $min if $min has been defined, or else it returns an empty list (). The // operator saves you from having to use defined to test definedness.

Consider what happens when this one-liner is run on the previous file. First, Perl reads the line -8 9 10 5, splits it, and puts the numbers in the @F array. The @F array is now (-8, 9, 10, 5). Next, it executes $min = min ($min // (), @F). Because $min hasn’t been defined, $min // () evaluates to (), so the whole expression becomes $min = min ((), (-8, 9, 10, 5)).

Perl does list flattening by design, so after flattening the arguments to the min function, the expression becomes $min = min(-8, 9, 10, 5). This defines $min, setting it to -8. Perl proceeds to the next line, where it sets @F to (7, 0, 9, 3) and again evaluates $min = min($min // (), @F). Because $min has now been defined, $min // () evaluates to $min and the expression becomes $min = min(-8, 7, 0, 9, 3). At this point, -8 is still the smallest element, so $min remains -8. Finally, Perl reads in the last line, and after evaluating $min = min(-8, 5, -25, 9, 999), it finds that -25 is the smallest element in the file.

			8.4.7   Find the numerically largest element (maximum element) on each line

			perl -MList::Util=max -alne 'print max @F'

			This works the same as one-liner 4.5, except that you replace min with max.

			8.4.8  Find the numerically largest element (maximum element) over all lines

perl -MList::Util=max -alne '@M = (@M, @F); END { print max @M }'

This one-liner is similar to one-liners 4.6 and 4.7. In this one-liner, each line is auto-split and put in the @F array, and then this array is merged with the @M array. When the input has been processed, the END block executes and the maximum element is printed.

Here’s another way to find the maximum element, keeping just the running maximum element instead of all elements in memory:

perl -MList::Util=max -alne '
  $max = max @F;
  $rmax = $max unless defined $rmax && $max < $rmax;
  END { print $rmax }
'

If you’re using Perl 5.10 or later, you can use the // operator to shorten this one-liner:

perl -MList::Util=max -alne '$max = max($max // (), @F); END { print $max }'

This is the same as one-liner 4.6, except you replace min with max.

			8.4.9  Print the total number of fields on each line

perl -alne 'print scalar @F'

This one-liner forces the evaluation of @F in the scalar context, which in Perl means “the number of elements in @F.” As a result, it prints the number of elements on each line.

For example, if your file contains the following lines:

foo bar baz
foo bar
baz

Running this one-liner produces the following output:

3
2
1

The first line has three fields, the second line has two fields, and the last line has one field.

			8.4.10 Print the total number of fields on each line, followed by the line

perl -alne 'print scalar @F, " $_"'

This one-liner is the same as one-liner 4.10, with the addition of $_ at the end, which prints the whole line. (Remember that -n puts each line in the $_ variable.)

Let’s run this one-liner on the same example file that I used in one-liner 4.10:

foo bar baz
foo bar
baz

Running the one-liner produces the following output:

3 foo bar baz
2 foo bar
1 baz
[yizaq@YIZAQ-M-D1BW:Sun Mar 01:~/Desktop/Work:]$ perl -alne 'print " @{[ scalar @F ]} -- $_" ' stam
 3 -- 1 2 3
 4 -- 5 9 3 3
 6 -- 102 2391 21 2 3 1
[yizaq@YIZAQ-M-D1BW:Sun Mar 01:~/Desktop/Work:]$ perl -alne 'print scalar @F  ," ", $_ ' stam
3 1 2 3
4 5 9 3 3
6 102 2391 21 2 3 1
[yizaq@YIZAQ-M-D1BW:Sun Mar 01:~/Desktop/Work:]$ perl -alne 'print scalar @F  ," --", $_ ' stam
3 --1 2 3
4 --5 9 3 3
6 --102 2391 21 2 3 1

			8.4.11 Print the total number of fields on all lines

perl -alne '$t += @F; END { print $t }'

Here, the one-liner keeps adding the number of fields on each line to variable $t until all lines have been processed. Next, it prints the result, which contains the number of words on all lines. Notice that you add the @F array to the scalar variable $t. Because $t is scalar, the @F array is evaluated in the scalar context and returns the number of elements it contains.

Running this one-liner on the following file:

foo bar baz
foo bar
baz

produces the number 6 as output because the file contains a total of six words.

			8.4.12 Print the total number of fields that match a pattern

perl -alne 'map { /regex/ && $t++ } @F; END { print $t || 0 }'

This one-liner uses map to apply an operation to each element in the @F array. In this example, the operation checks to see if each element matches /regex/, and if it does, it increments the $t variable. It then prints the $t variable, which contains the number of fields that match the /regex/ pattern. The $t || 0 construct is necessary because if no fields match, $t wouldn’t exist, so you must provide a default value. Instead of 0, you can provide any other default value, even a string!

Looping would be a better approach:

perl -alne '$t += /regex/ for @F; END { print $t }'

Here, each element in @F is tested against /regex/. If it matches, /regex/ returns true; otherwise it returns false. When used numerically, true converts to 1 and false converts to 0, so $t += /regex/ adds either 1 or 0 to the $t variable. As a result, the number of matches is counted in $t. You do not need a default value when printing the result in the END block because the += operator is run regardless of whether the field matches. You will always get a value, and sometimes that value will be 0.

Another way to do this is to use grep in the scalar context:

perl -alne '$t += grep /regex/, @F; END { print $t }'

Here, grep returns the number of matches because it’s evaluated in the scalar context. In the list context, grep returns all matching elements, but in the scalar context, it returns the number of matching elements. This number is accumulated in $t and printed in the END block. In this case, you don’t need to provide a default value for $t because grep returns 0 in those situations.

[yizaq@YIZAQ-M-D1BW:Thu Mar 05:~/Desktop/Work/KB:]$ perl -alne '$t+= /Yosi/ for @F; END {print "$t matches";}' C_KB 
6 matches

			8.4.13 Print the total number of lines that match a pattern

perl -lne '/regex/ && $t++; END { print $t || 0 }'

Here, /regex/ evaluates to true if the current line of input matches this regular expression. Writing /regex/ && $t++ is the same as writing if ($_ =~ /regex/) { $t++ }, which increments the $t variable if the line matches the specified pattern. In the END block, the $t variable contains the total number of pattern matches and is printed; but if no lines match, $t is once again undefined, so you must print a default value.

[yizaq@YIZAQ-M-D1BW:Thu Mar 05:~/Desktop/Work/KB:]$ perl -lne '$t+= /Yosi/ ; END {print "$t matches";}' C_KB 
6 matches
[yizaq@YIZAQ-M-D1BW:Thu Mar 05:~/Desktop/Work/KB:]$ perl -lne '$t+= /Yosi/ ; END {print "$t matches";}' log 
0 matches

			8.4.14 Print the number π

perl -Mbignum=bpi -le 'print bpi(21)'

The bignum package exports the bpi function that calculates the π constant to the desired accuracy. This one-liner prints π to 20 decimal places. (Notice that you need to specify n+1 to print it to an accuracy of n.)

The bignum library also exports the constant π, precomputed to 39 decimal places:

perl -Mbignum=PI -le 'print PI'
			8.4.15 Print the number e

perl -Mbignum=bexp -le 'print bexp(1,21)'

The bignum library exports the bexp function, which takes two arguments: the power to raise e to, and the desired accuracy. This one-liner prints the constant e to 20 decimal places.

For example, you could print the value of e2 to 30 decimal places:

perl -Mbignum=bexp -le 'print bexp(2,31)'

As with π, bignum also exports the constant e precomputed to 39 decimal places:

perl -Mbignum=e -le 'print e'
			8.4.16 Print UNIX time (seconds since January 1, 1970, 00:00:00 UTC)

perl -le 'print time'

The built-in time function returns seconds since the epoch. This one-liner simply prints the time.

[yizaq@YIZAQ-M-D1BW:Thu Mar 05:~/Desktop/Work/KB:]$ perl -le 'print time'
1425574660
			8.4.17 Print Greenwich Mean Time and local computer time

perl -le 'print scalar gmtime'

The gmtime function is a built-in Perl function. When used in the scalar context, it returns the time localized to Greenwich Mean Time (GMT).

The built-in localtime function acts like gmtime, except it returns the computer’s local time when it’s used in the scalar context:

perl -le 'print scalar localtime'

In the list context, both gmtime and localtime return a nine-element list (known as struct tm to UNIX programmers) with the following elements:

($second,             [0]
$minute,              [1]
$hour,                [2]
$month_day,           [3]
$month,               [4]
$year,                [5]
$week_day,            [6]
$year_day,            [7]
$is_daylight_saving   [8]
)

You can slice this list (that is, extract elements from it) or print individual elements if you need just some part of the information it contains. For example, to print H:M:S, slice the elements 2, 1, and 0 from localtime, like this:

perl -le 'print join ":", (localtime)[2,1,0]'

To slice elements individually, specify a list of elements to extract, for instance [2,1,0]. Or slice them as a range:

perl -le 'print join ":", (localtime)[2..6]'

This one-liner prints the hour, date, month, year, and day of the week.

You can also use negative indexes to select elements from the opposite end of a list:

perl -le 'print join ":", (localtime)[-2, -3]'

This one-liner prints elements 7 and 6, which are the day of the year (for example, the 200th day) and of the week (for example, the 4th day), respectively.

[yizaq@YIZAQ-M-D1BW:Thu Mar 05:~/Desktop/Work/KB:]$ perl -le 'print gmtime'
305816521154630
[yizaq@YIZAQ-M-D1BW:Thu Mar 05:~/Desktop/Work/KB:]$ perl -le 'print scalar gmtime'
Thu Mar  5 16:58:38 2015
[yizaq@YIZAQ-M-D1BW:Thu Mar 05:~/Desktop/Work/KB:]$ perl -le 'print scalar localtime'
Thu Mar  5 18:58:57 2015
[yizaq@YIZAQ-M-D1BW:Thu Mar 05:~/Desktop/Work/KB:]$ perl -le 'print join ":", (localtime)[0..6]'
57:1:19:5:2:115:4
[yizaq@YIZAQ-M-D1BW:Thu Mar 05:~/Desktop/Work/KB:]$ perl -le 'print scalar localtime'
Thu Mar  5 19:02:10 2015

			8.4.18 Print yesterday’s date

perl -MPOSIX -le '
  @now = localtime;
  $now[3] -= 1;
  print scalar localtime mktime @now
'

Remember that localtime returns a nine-item list (see one-liner 4.18) of various date elements. The fourth element in the list is the current month’s day. If you subtract 1 from this element, you get yesterday.

The mktime function constructs the UNIX epoch time from this modified nine-element list, and the scalar localtime construct prints the new date, which is yesterday. This one-liner also works in edge cases, such as when the current day is the first day of the month. You need the POSIX package because it exports the mktime function.

For example, if it’s Mon May 20 05:49:55 right now, running this one-liner prints Sun May 19 05:49:55.
			8.4.19 Print the date 14 months, 9 days, and 7 seconds ago

perl -MPOSIX -le '
  @now = localtime;
  $now[0] -= 7;
  $now[3] -= 9;
  $now[4] -= 14;
  print scalar localtime mktime @now
'

This one-liner modifies the first, fourth, and fifth elements of the @now list. The first element is seconds, the fourth is days, and the fifth is months. The mktime command generates the UNIX time from this new structure, and localtime, which is evaluated in the scalar context, prints the date 14 months, 9 days, and 7 seconds ago.

			8.4.20 Calculate the factorial

perl -MMath::BigInt -le 'print Math::BigInt->new(5)->bfac()'

This one-liner uses the bfac() function from the Math::BigInt module in the Perl core. (In other words, you don’t need to install it.) The Math::BigInt->new(5) construction creates a new Math::BigInt object with a value of 5, after which the bfac() method is called on the newly created object to calculate the factorial of 5. Change 5 to any number you wish to find its factorial.

Another way to calculate a factorial is to multiply the numbers from 1 to n together:

perl -le '$f = 1; $f *= $_ for 1..5; print $f'

Here, I set $f to 1 and then loop from 1 to 5 and multiply $f by each value. The result is 120 (1*2*3*4*5), the factorial of 5.

[yizaq@YIZAQ-M-D1BW:Thu Mar 05:~/Desktop/Work/KB:]$ perl -le '$f=1; $f*=$_ for (1..10) ; print $f;'
3628800
[yizaq@YIZAQ-M-D1BW:Thu Mar 05:~/Desktop/Work/KB:]$ perl -le '$f=1; $f*=$_ for (1..6) ; print $f;'
720
			8.4.21 Calculate the greatest common divisor

perl -MMath::BigInt=bgcd -le 'print bgcd(@list_of_numbers)'

Math::BigInt has several other useful math functions including bgcd, which calculates the greatest common divisor (gcd) of a list of numbers. For example, to find the greatest common divisor of (20, 60, 30), execute the one-liner like this:

perl -MMath::BigInt=bgcd -le 'print bgcd(20,60,30)'

To calculate the gcd from a file or user’s input, use the -a command-line argument and pass the @F array to the bgcd function:

perl -MMath::BigInt=bgcd -anle 'print bgcd(@F)'

(I explained the -a argument and the @F array in one-liner 4.2 on page 30.)

You could also use Euclid’s algorithm to find the gcd of $n and $m. This one-liner does just that and stores the result in $m:

perl -le '
  $n = 20; $m = 35;
  ($m,$n) = ($n,$m%$n) while $n;
  print $m
'

Euclid’s algorithm is one of the oldest algorithms for finding the gcd.

			8.4.22 Calculate the least common multiple

The least common multiple (lcm) function, blcm, is included in Math::BigInt. Use this one-liner to find the least common multiple of (35, 20, 8):

perl -MMath::BigInt=blcm -le 'print blcm(35,20,8)'

To find the lcm from a file with numbers, use the -a command-line switch and the @F array:

perl -MMath::BigInt=blcm -anle 'print blcm(@F)'

If you know a bit of number theory, you may recall that there is a connection between the gcd and the lcm. Given two numbers $n and $m, you know that their lcm is $n*$m/gcd($n,$m). This one-liner, therefore, follows:

perl -le '
  $a = $n = 20;
  $b = $m = 35;
  ($m,$n) = ($n,$m%$n) while $n;
  print $a*$b/$m
'
			8.4.23 Generate 10 random numbers between 5 and 15 (excluding 15)

perl -le 'print join ",", map { int(rand(15-5))+5 } 1..10'

This one-liner prints 10 random numbers between 5 and 15. It may look complicated, but it’s actually simple. int(rand(15-5)) is just int(rand(10)), which returns a random integer from 0 to 9. Adding 5 to it makes it return a random integer from 5 to 14. The range 1..10 makes it draw 10 random integers.

You can also write this one-liner more verbosely:

perl -le '
  $n=10;
  $min=5;
  $max=15;
  $, = " ";
  print map { int(rand($max-$min))+$min } 1..$n;
'

Here, all variables are more explicit. To modify this one-liner, change the variables $n, $min, and $max. The $n variable represents how many random numbers to generate, and $min-$max is the range of numbers for use in that generation.

The $, variable is set to a space because it’s the output field separator for print and it’s undef by default. If you didn’t set $, to a space, the numbers would be printed concatenated. (See one-liner 4.4 on page 32 for a discussion of $,.)

			8.4.24 Generate 10 random numbers between 5 and 15 (excluding 15)

perl -le 'print join ",", map { int(rand(15-5))+5 } 1..10'

This one-liner prints 10 random numbers between 5 and 15. It may look complicated, but it’s actually simple. int(rand(15-5)) is just int(rand(10)), which returns a random integer from 0 to 9. Adding 5 to it makes it return a random integer from 5 to 14. The range 1..10 makes it draw 10 random integers.

You can also write this one-liner more verbosely:

perl -le '
  $n=10;
  $min=5;
  $max=15;
  $, = " ";
  print map { int(rand($max-$min))+$min } 1..$n;
'

Here, all variables are more explicit. To modify this one-liner, change the variables $n, $min, and $max. The $n variable represents how many random numbers to generate, and $min-$max is the range of numbers for use in that generation.

The $, variable is set to a space because it’s the output field separator for print and it’s undef by default. If you didn’t set $, to a space, the numbers would be printed concatenated. (See one-liner 4.4 on page 32 for a discussion of $,.)
[yizaq@YIZAQ-M-D1BW:Sun Mar 08:~/Desktop/Work:]$ perl -le 'print join "," , map {int (rand (15-5)+5 ) } 1..10 ' 
10,5,12,14,6,7,13,6,13,12
[yizaq@YIZAQ-M-D1BW:Sun Mar 08:~/Desktop/Work:]$ perl -e 'for (1..10) {print int (rand (15-5)+5) , "," } ' 
12,7,13,13,6,7,11,7,11,12,

			8.4.25 Generate all permutations of a list

perl -MAlgorithm::Permute -le '
  $l = [1,2,3,4,5];
  $p = Algorithm::Permute->new($l);
  print "@r" while @r = $p->next
'

This one-liner uses the object-oriented interface of the module Algorithm::Permute to find all permutations of a list, that is, all ways to rearrange items. The constructor of Algorithm::Permute takes an array reference of elements to permute. In this particular one-liner, the elements are the numbers 1, 2, 3, 4, 5.

The next method returns the next permutation. Calling it repeatedly iterates over all permutations, and each permutation is put in the @r array and then printed. (Beware: The output list gets large really quickly. There are n! (n factorial) permutations for a list of n elements.)

Another way to print all permutations is with the permute subroutine:

perl -MAlgorithm::Permute -le '
  @l = (1,2,3,4,5);
  Algorithm::Permute::permute { print "@l" } @l
'

Here’s what you get if you change @l to just three elements (1, 2, 3) and run it:

1 2 3
1 3 2
3 1 2
2 1 3
2 3 1
3 2 1

			8.4.26 Generate the powerset

perl -MList::PowerSet=powerset -le '
  @l = (1,2,3,4,5);
  print "@$_" for @{powerset(@l)}
'

This one-liner uses the List::PowerSet module from CPAN. The module exports the powerset function, which takes a list of elements and returns a reference to an array containing references to subset arrays. You can install this module by running cpan List::PowerSet at the command line.

In the for loop, you call the powerset function and pass it the list of elements of @l. Next, you dereference the return value of powerset, which is a reference to an array of subsets, and then dereference each individual subset @$_ and print it.

The powerset is the set of all subsets. For a set of n elements, there are exactly 2n subsets in the powerset. Here’s an example of the powerset of (1, 2, 3):

1 2 3
2 3
1 3
3
1 2
2
1
			8.4.27 Convert an IP address to an unsigned integer

perl -le '
  $i=3;
  $u += ($_<<8*$i--) for "127.0.0.1" =~ /(\d+)/g;
  print $u
'

This one-liner converts the IP address 127.0.0.1 into an unsigned integer by first doing a global match of (\d+) on the IP address. Performing a for loop over a global match iterates over all the matches, which are the four parts of the IP address: 127, 0, 0, 1.

Next, the matches are summed in the $u variable. The first bit is shifted 8 × 3 = 24 places, the second is shifted 8 × 2 = 16 places, and the third is shifted 8 places. The last is simply added to $u. The resulting integer happens to be 2130706433 (a very geeky number).

Here are some more one-liners:

perl -le '
  $ip="127.0.0.1";
  $ip =~ s/(\d+)\.?/sprintf("%02x", $1)/ge;
  print hex($ip)
'

This one-liner utilizes the fact that 127.0.0.1 can be easily converted to hex. Here, the $ip is matched against (\d+), and each IP part is transformed into a hex number with sprintf("%02x", $1) inside the s operator. The /e flag of the s operator makes it evaluate the substitution part as a Perl expression. As a result, 127.0.0.1 is transformed into 7f000001 and then interpreted as a hexadecimal number by Perl’s hex operator, which converts it to a decimal number.

You can also use unpack:

perl -le 'print unpack("N", 127.0.0.1)'

This one-liner is probably as short as possible. It uses vstring literals (version strings) to express the IP address. A vstring forms a string literal composed of characters with the specified ordinal values. The newly formed string literal is unpacked into a number from a string in network byte order (big-endian order) and then printed.

If you have a string with an IP (rather than a vstring), you first have to convert it to byte form with the function inet_aton:

perl -MSocket -le 'print unpack("N", inet_aton("127.0.0.1"))'

Here, inet_aton converts the string 127.0.0.1 to the byte form (equivalent to the pure vstring 127.0.0.1) and then unpack unpacks it, as in the previous one-liner.

			8.4.28 Convert an unsigned integer to an IP address

perl -MSocket -le 'print inet_ntoa(pack("N", 2130706433))'

Here, the integer 2130706433 is packed into a number in big-endian byte order and then passed to the inet_ntoa function that converts a number back to an IP address. (Notice that inet_ntoa is the opposite of inet_aton.)

You can do the same thing like this:

perl -le '
  $ip = 2130706433;
  print join ".", map { (($ip>>8*($_))&0xFF) } reverse 0..3
'

Here, the $ip is shifted 24 bits to the right and then bitwise ANDed with 0xFF to produce the first part of the IP, which is 127. Next, it’s shifted 16 bits and bitwise ANDed with 0xFF, producing 0, and then shifted 8 bits and bitwise ANDed with 0xFF, producing another 0. Finally, the whole number is bitwise ANDed with 0xFF, producing 1.

The result from map { ... } is a list (127, 0, 0, 1). That list is now joined by a dot "." to produce the IP address 127.0.0.1.

You can replace join with the special variable $,, which acts as a value separator for the print statement:

perl -le '
  $ip = 2130706433;
  $, = ".";
  print map { (($ip>>8*($_))&0xFF) } reverse 0..3
'

Because reverse 0..3 is the same as 3,2,1,0, you could also write:

perl -le '
  $ip = 2130706433;
  $, = ".";
  print map { (($ip>>8*($_))&0xFF) } 3,2,1,0
'

-> Convert ipv6 address string to binary (on windows)
perl -MSocket -e "use Socket qw(inet_pton); print inet_pton(AF_INET6, \"2001::1\") ;"
			8.4.29 
			8.4.30 
			8.4.31 


		8.5 Working With Arrays and Strings

		In this chapter, we’ll look at various one-liners for creating strings and arrays, for doing things like generating passwords, creating strings of certain length, finding the numeric values of characters, and creating arrays of numbers. You’ll also learn about the range operator .., the x operator, the $, special variable, and the @ARGV array.

			8.5.1 Generate and print the alphabet

			perl -le 'print a..z'

			This one-liner prints all letters from a to z in the English alphabet as abcdefghijklmnopqrstuvwxyz. The letters are generated by the range operator .., which, when used on strings in the list context (provided here by print), applies the magical auto-increment algorithm that advances the string to the next character. Therefore, in this one-liner, the auto-increment algorithm on the range a..z produces all letters from a to z.

			I really golfed this one-liner. If I had used strict, it wouldn’t have worked because of the bare words a and z. This version is more correct semantically:

			perl -le 'print ("a".."z")'

			Remember that the range operator .. produces a list of values. If you wish, you could print the values with comma separations by setting the $, special variable:

			perl -le '$, = ","; print ("a".."z")'

			The $, is the field separator. It’s output by print between each field. Semantically, though, using join to separate the list of letters with a comma is more appealing because it works even when not using print directly:

			perl -le '$alphabet = join ",", ("a".."z"); print $alphabet'

			Here, the list a..z is joined by a comma before printing, and the output is

			a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z
$ perl -le 'print a..z'
abcdefghijklmnopqrstuvwxyz

			8.5.2  Generate and print all the strings from “a” to “zz”

perl -le 'print join ",", ("a".."zz")'

This one-liner uses the range operator .. again, but this time, it doesn’t stop at z as in the previous one-liner. Instead, it advances z by one character, producing aa. Then it keeps going, producing ab, ac, and so on, until it hits az. At that point, it advances the string to ba, continues with bb, bc, and so on, until eventually it reaches zz.

You could also generate all strings from aa to zz by doing this:

perl -le 'print join ",", "aa".."zz"'

The output from this one-liner is

aa, ab, ..., az, ba, bb, ..., bz, ca, ..., zz

			8.5.3  Create a hex lookup table

@hex = (0..9, "a".."f")

In this one-liner, the @hex array is filled with the numbers 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 and the letters a, b, c, d, e, f. You could use this array to convert a number (in variable $num) from decimal to hex with the following base conversion formula. (This isn’t a one-liner; I include it to illustrate how to use the @hex lookup array.)

perl -le '
  $num = 255;
  @hex = (0..9, "a".."f");
  while ($num) {
    $s = $hex[($num % 16)].$s;
    $num = int $num/16;
  }
  print $s
'

But surely, converting a number to hex is much easier if I use printf (or sprintf) with the %x format specifier.

perl -le 'printf("%x", 255)'

To convert the number back from hex to dec, use the hex operator:

perl -le '$num = "ff"; print hex $num'

The hex operator takes a hex string (beginning with or without 0x) and converts it to decimal.

			8.5.4  Generate a random eight-character password

perl -le 'print map { ("a".."z")[rand 26] } 1..8'

Here, the map operator executes the code ("a".."z")[rand 26] eight times because it iterates over the range 1..8. In each iteration, the code chooses a random letter from the alphabet. When map has finished iterating, it returns the generated list of characters, and print prints it, thereby concatenating all the characters.

To also include numbers in the password, add 0..9 to the list of characters to choose from and change 26 to 36 because you now have 36 possible characters:

perl -le 'print map { ("a".."z", 0..9)[rand 36] } 1..8'

If you need a longer password, change 1..8 to 1..20 to generate one that’s 20 characters long.

[yizaq@YIZAQ-M-D1BW:Sun Mar 08:~/Desktop/Work:]$ perl -le 'print map { (a..z)[rand 26] } 1..8'
xyuulrsa
[yizaq@YIZAQ-M-D1BW:Sun Mar 08:~/Desktop/Work:]$ perl -le 'print map { (a..z)[rand 26] } 1..8'
eygyoeul
[yizaq@YIZAQ-M-D1BW:Sun Mar 08:~/Desktop/Work:]$ perl -le 'print map { (a..z)[rand 26] } 1..8'
bsjfkugn
[yizaq@YIZAQ-M-D1BW:Sun Mar 08:~/Desktop/Work:]$ perl -le 'print map { (a..z)[rand 26] } 1..12'
dbmwvulqbjnr

			8.5.5  Create a string of specific length

perl -le 'print "a"x50'

This one-liner creates a string of 50 letters a and prints it. Operator x is the repetition operator. Here, the letter a is repeated 50 times by x50. This one-liner is handy when you need to generate a specific amount of data for debugging or other tasks. For example, if you need 1KB of data, just do this:

perl -e 'print "a"x1024'

I removed the -l argument because it would have output an additional newline symbol, producing 1025 bytes of data.

When you use the repetition operator in the list context, with a list as its first operand, you create a list with the given elements repeated, like this:

perl -le '@list = (1,2)x20; print "@list"'

This one-liner creates a list of 20 repetitions of (1, 2) that looks like (1, 2, 1, 2, 1, 2, ...). (The parentheses to the left of x make a list.)

			8.5.6  Create an array from a string

@months = split ' ', "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec"

Here, @months is filled with values from the string containing month names. Because all month names are separated by a space, the split operator splits them and puts them in @months. As a result, $months[0] contains Jan, $months[1] contains Feb, … , and $months[11] contains Dec.

You could do the same thing with the qw/.../ operator:

@months = qw/Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec/

The qw/.../ operator takes a space-separated string and creates an array in which each word is an array element.

Although not a one-liner per se, this is a useful, idiomatic way to create arrays that can come in handy when writing one-liners.

			8.5.7  Create a string from the command-line arguments

perl -le 'print "(", (join ",", @ARGV), ")"' val1 val2 val3

This one-liner uses the @ARGV array, which contains all the arguments that have been passed to Perl. In this one-liner, the values passed to Perl are val1, val2, and val3, so @ARGV contains the strings val1, val2, and val3. This one-liner prints the string (val1,val2,val3) and would be useful, for example, to generate a SQL query.

If you’re familiar with the INSERT query in SQL, you know its most basic form looks like INSERT INTO table VALUES (val1, val2, val3, ...). As you can see, this one-liner generates the VALUES part of the SQL query.

You can easily modify this one-liner to print the whole INSERT query:

perl -le '
  print "INSERT INTO table VALUES (", (join ",", @ARGV), ")"
' val1 val2 val3

Here’s what the one-liner prints:

INSERT INTO table VALUES (val1,val2,val3)

			8.5.8  Find the numeric values for characters in a string

perl -le 'print join ", ", map { ord } split //, "hello world"'

This one-liner takes the string "hello world" and splits it into a list of characters with split //, "hello world". It then maps the ord operator onto each of the characters, which returns each character’s numeric value. Finally, all of the numeric values are joined together by a comma and printed. Here’s the output:

104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100

You could also do this with the unpack operator by specifying C* as the unpacking template:

perl -le 'print join ", ", unpack("C*", "hello world")'

The C in the template means “unsigned character” and * means “all characters.”

To find the hexadecimal values of the characters, you could do this:

perl -le '
  print join ", ", map { sprintf "0x%x", ord $_ } split //, "hello world"
'

Here, the map operator executes sprintf "0x%x", ord $_ for every character, which returns the character’s hexadecimal value prepended with '0x'. Here’s the output:

0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64

Similarly, to get the octal values of characters, you do this:

perl -le '
  print join ", ", map { sprintf "%o", ord $_ } split //, "hello world"
'

Here’s the output:

150, 145, 154, 154, 157, 40, 167, 157, 162, 154, 144

And finally, to generate proper octal values that begin with 0, you can specify the %#o format to the sprintf function:

perl -le '
  print join ", ", map { sprintf "%#o", ord $_ } split //, "hello world"
'

And here’s the output:

0150, 0145, 0154, 0154, 0157, 040, 0167, 0157, 0162, 0154, 0144
YIZAQ-M-D1BW:~ yizaq$ echo "abcd" | perl -lne 'print join ", " , map {ord} split //, '
97, 98, 99, 100

			8.5.9  Convert a list of numeric ASCII values into a string

perl -le '
  @ascii = (99, 111, 100, 105, 110, 103);
  print pack("C*", @ascii)
'

Just as I unpacked a string into a list of values with the C* template in the previous one-liner, I can pack them into a string by using the same template. Here’s the output from the one-liner:

coding

Another way to convert a list of numeric ASCII values into a string is to use the chr operator, which takes the code point value and returns the corresponding character:

perl -le '
  @ascii = (99, 111, 100, 105, 110, 103);
  $str = join "", map chr, @ascii;
  print $str
'

Here, you simply map the chr operator onto each numeric value in the @ascii array, which produces a list of characters that correspond to the numeric values. Next, you join the characters together and produce the $str, and then you print it out.

You can also golf this one-liner and come up with the following:

perl -le 'print map chr, 99, 111, 100, 105, 110, 103'

You can also use the @ARGV array and pass the ASCII values as arguments to the one-liner:

perl -le 'print map chr, @ARGV' 99 111 100 105 110 103
[yizaq@YIZAQ-M-D1BW:Wed Mar 11:~/Desktop/Work:]$ echo "97 98 99 100" | perl -lne 'print join ", " , map {chr} split / /, '
a, b, c, d
			8.5.10 Generate an array with odd numbers from 1 to 100

perl -le '@odd = grep {$_ % 2 == 1} 1..100; print "@odd"'

This one-liner generates an array of odd numbers from 1 to 99 (that is, 1, 3, 5, 7, 9, 11, … , 99). It uses grep to evaluate the code $_ % 2 == 1 for each element in the list 1..100 and returns only those elements for which the given code evaluates to true. In this case, the code tests to see if the remainder when dividing by 2 is 1. If it is, the number is odd, and it’s put in the @odd array.

You could also write this using the fact that odd numbers have the least significant bit set and test for the least significant bit:

perl -le '@odd = grep { $_ & 1 } 1..100; print "@odd"'

The expression $_ & 1 isolates the least significant bit, and grep selects only those numbers with the least significant bit set—that is, all odd numbers.
[yizaq@YIZAQ-M-D1BW:Wed Mar 11:~/Desktop/Work:]$ perl -le 'for (1..100) {print if $_%2}' 
1
3
5
7
9
11
13
15
17
19
21
23
25
27
29
31
33
35
37
39
41
43
45
47
49
51
53
55
57
59
61
63
65
67
69
71
73
75
77
79
81
83
85
87
89
91
93
95
97
99
[yizaq@YIZAQ-M-D1BW:Wed Mar 11:~/Desktop/Work:]$ perl -e 'for (1..100) {print "$_, " if $_%2}' 
1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99, [yizaq@YIZAQ-M-D1BW:Wed Mar 11:~/Desktop/Work:]$ 
$ perl -le '@o = grep {$_ & 1} (1..200) ; print @o' 
13579111315171921232527293133353739414345474951535557596163656769717375777981838587899193959799101103105107109111113115117119121123125127129131133135137139141143145147149151153155157159161163165167169171173175177179181183185187189191193195197199
[yizaq@YIZAQ-M-D1BW:Wed Mar 11:~/Desktop/Work:]$ perl -le '@o = grep {$_ & 1} (1..200) ; $,=", "; print @o' 
1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99, 101, 103, 105, 107, 109, 111, 113, 115, 117, 119, 121, 123, 125, 127, 129, 131, 133, 135, 137, 139, 141, 143, 145, 147, 149, 151, 153, 155, 157, 159, 161, 163, 165, 167, 169, 171, 173, 175, 177, 179, 181, 183, 185, 187, 189, 191, 193, 195, 197, 199

			8.5.11 Generate an array with even numbers from 1 to 100

perl -le '@even = grep {$_ % 2 == 0} 1..100; print "@even"'

This one-liner is almost the same as the one in 5.10, except that grep tests for the condition “is the number even (remainder after dividing by two is 0)?”

			8.5.12 Find the length of a string

perl -le 'print length "one-liners are great"'

The length subroutine finds the length of a string.
[yizaq@YIZAQ-M-D1BW:Wed Mar 11:~/Desktop/Work:]$ echo "abcd" | perl -lne 'print length'
4
[yizaq@YIZAQ-M-D1BW:Wed Mar 11:~/Desktop/Work:]$ echo "abcdxxxxxda" | perl -lne 'print length'
11

			8.5.13 Find the number of elements in an array

perl -le '@array = ("a".."z"); print scalar @array'

Evaluating an array in the scalar context returns its number of elements.

You could also do this by adding 1 to the last index of an array:

perl -le '@array = ("a".."z"); print $#array + 1'

Here, $#array returns the last index in @array. Because that number is one less than the number of elements in the array, you add 1 to the result to find the total number of elements in the array.

For example, say you want to find out how many text files are in the current directory. You can use @ARGV and pass the *.txt wildcard to Perl. The shell expands the *.txt wildcard to a list of filenames that match *.txt, and Perl puts them into the @ARGV array and prints the array in the scalar context. The output will be the number of text files in the current directory:

perl -le 'print scalar @ARGV' *.txt

If your shell doesn’t support filename expansion (also known as globbing) or if you’re on Windows, you can use the diamond operator with the *.txt argument:

perl -le 'print scalar (@ARGV=<*.txt>)'

In this case, the diamond operator does the globbing and returns a list of filenames that match *.txt. Evaluating this list in the scalar context returns the number of files that matched.
YIZAQ-M-D1BW:Work yizaq$ perl -le '@a=("a".."z"); print scalar @a'
26
			8.5.14 


		8.6  Text Conversion and Substitution

		In this chapter, we’ll look at various one-liners that change, convert, and substitute text, including base64 encoding and decoding, URL escaping and unescaping, HTML escaping and unescaping, converting text case, and reversing lines. You’ll also get to know the y, tr, uc, lc, and reverse operators and string-escape sequences.

			8.6.1   ROT13 a string

perl -le '$string = "bananas"; $string =~ y/A-Za-z/N-ZA-Mn-za-m/; print $string'

This one-liner uses the y operator (also known as the tr operator) to do ROT13. The operators y and tr perform string transliteration. Given y/search/replace/, the y operator transliterates all occurrences of the characters found in the search list with the characters in the corresponding positions in the replace list. The y and tr operators are often mistaken for taking a regular expression, but they don’t. They transliterate things and take a list of characters in both the search and replace parts.

In this one-liner, A-Za-z creates the following list of characters:

ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz

And N-ZA-Mn-za-m creates this list:

NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm

Notice that in the second list the uppercase and lowercase alphabets are offset by 13 characters. Now the y operator translates each character in the first list to a character in the second list, thus performing the ROT13 operation. (One fun fact about ROT13 is that applying it twice produces the same string; that is, ROT13(ROT13(string)) equals string.)

To ROT13 the whole file bananas.txt and print it to the screen, just do this:

perl -lpe 'y/A-Za-z/N-ZA-Mn-za-m/' bananas.txt

You can also use Perl’s -i argument to do in-place replacement of the file. For example, to ROT13 oranges.txt in-place, write this:

perl -pi.bak -e 'y/A-Za-z/N-ZA-Mn-za-m/' oranges.txt

This one-liner first creates a backup file called oranges.txt.bak and then replaces the contents of oranges.txt with ROT13-ed text. The .bak part of the -i command creates the backup file. You can omit the .bak part of the command if you’re sure about the result, but I recommend always using -i.bak because one day you might make a mistake and mess up an important file. (I speak from experience.)

YIZAQ-M-D1BW:Work yizaq$ echo "abcd" | perl -lne '$s=$_; $s=~ y/A-Za-z/N-ZA-Mn-za-m/; print $s'
nopq

			8.6.2   Base64-encode a string

perl -MMIME::Base64 -e 'print encode_base64("string")'

This one-liner uses the MIME::Base64 module. It exports the encode_base64 function, which takes a string and returns a base64-encoded version of it.

To base64-encode the whole file, use this:

perl -MMIME::Base64 -0777 -ne 'print encode_base64($_)' file

Here, the -0777 argument together with -n causes Perl to slurp the whole file into the $_ variable. Next, the file is base64-encoded and printed. (If Perl didn’t slurp the entire file, it would be encoded line by line, and you’d end up with a mess.)
			8.6.3   Base64-decode a string

perl -MMIME::Base64 -le 'print decode_base64("base64string")'

The MIME::Base64 module also exports the decode_base64 function, which takes a base64-encoded string and decodes it.

The entire file can be decoded similarly with

perl -MMIME::Base64 -0777 -ne 'print decode_base64($_)' file
			8.6.4   URL-escape a string

perl -MURI::Escape -le 'print uri_escape("http://example.com")'

To use this one-liner, you need to install the URI::Escape module first by entering cpan URI::Escape in the shell. The module exports two functions: uri_escape and uri_unescape. The first function performs URL escaping (sometimes referred to as URL encoding), and the other does URL unescaping (or URL decoding). Now, to URL-escape a string, just call uri_escape($string) and you’re done!

The output of this one-liner is http%3A%2F%2Fexample.com.

			8.6.5   URL-unescape a string

perl -MURI::Escape -le 'print uri_unescape("http%3A%2F%2Fexample.com")'

This one-liner uses the uri_unescape function from the URI::Escape module to perform URL unescaping. It unescapes the output of the previous one-liner to reverse the operation.

The output of this one-liner is http://example.com.

			8.6.6   HTML-encode a string

perl -MHTML::Entities -le 'print encode_entities("<html>")'

This one-liner uses the encode_entities function from the HTML::Entities module to encode HTML entities. For example, you can turn < and > into &lt; and &gt;.

			8.6.7   HTML-decode a string

perl -MHTML::Entities -le 'print decode_entities("&lt;html&gt;")'

This one-liner uses the decode_entities function from the HTML::Entities module. For example, you can turn &lt; and &gt; back into < and >.

			8.6.8   HTML-decode a string

perl -MHTML::Entities -le 'print decode_entities("&lt;html&gt;")'

This one-liner uses the decode_entities function from the HTML::Entities module. For example, you can turn &lt; and &gt; back into < and >.

			8.6.9   Convert all text to uppercase

perl -nle 'print uc'

This one-liner uses the uc function, which, by default, operates on the $_ variable and returns an uppercase version of the text it contains.

You could do the same thing with the -p command-line option, which enables the automatic printing of the $_ variable and modifies it in-place:

perl -ple '$_ = uc'

Or you can apply the \U escape sequence to string interpolation:

perl -nle 'print "\U$_"'

This one-liner uppercases everything that follows it (or everything up to the first occurrence of \E).

YIZAQ-M-D1BW:Work yizaq$ echo "abcd" | perl -lne 'print uc'
ABCD
			8.6.10  Convert all text to lowercase

perl -nle 'print lc'

This one-liner is similar to the previous one. The lc function converts the contents of $_ to lowercase.

You could also use the escape sequence \L and string interpolation:

perl -nle 'print "\L$_"'

Here, \L lowercases everything after it (or until the first instance of \E).

			8.6.11  Uppercase only the first letter of each line

perl -nle 'print ucfirst lc'

This one-liner first lowercases the input with the lc function and then uses ucfirst to uppercase only the first character. For example, if you pass it a line that says foo bar baz, it produces the text Foo bar baz. Similarly, if you pass it a line FOO BAR BAZ, it lowercases the line first and then uppercases the first letter, producing Foo bar baz again.

You can do the same thing using escape codes and string interpolation:

perl -nle 'print "\u\L$_"'

First \L lowercases the whole line and then \u uppercases the first character.

			8.6.12  Invert the letter case

perl -ple 'y/A-Za-z/a-zA-Z/'

This one-liner changes the case of the letters: The capital letters become lowercase letters, and the lowercase letters become capital letters. For example, the text Cows are COOL becomes cOWS ARE cool. The transliteration operator y (explained in one-liner 6.1 on page 59) creates a mapping from capital letters A-Z to lowercase letters a-z and a mapping from lowercase letters a-z to capital letters A-Z.

			8.6.13  Title-case each line

perl -ple 's/(\w+)/\u$1/g'

This one-liner attempts to title-case a string, meaning the first letter of each word is uppercased; for example, This Text Is Written In Title Case. This one-liner works by matching every word with \w+ and replacing the matched word with \u$1, which uppercases the first letter of the word.

			8.6.14  Strip leading whitespace (spaces, tabs) from the beginning of each line

perl -ple 's/^[ \t]+//'

This one-liner deletes all whitespace from the beginning of every line with the help of the substitution operator s. Given s/regex/replace/, it replaces the matched regex with the replace string. In this case, the regex is ^[ \t]+, which means “match one or more spaces or tabs at the beginning of the string,” and replace is empty, meaning “replace the matched part with an empty string.”

The regular expression class [ \t] can also be replaced by \s+ to match any whitespace (including tabs and spaces):

perl -ple 's/^\s+//'

			8.6.15  Strip trailing whitespace (spaces, tabs) from the end of each line

perl -ple 's/[ \t]+$//'

This one-liner deletes all whitespace from the end of each line. The regex of the s operator says “match one or more spaces or tabs at the end of the string.” The replace part is empty again, which means “erase the matched whitespace.”

You can also achieve the same by writing:

perl -ple 's/\s+$//'

Here, you replace with [ \t]+$ with \s+, as in one-liner 6.13.

			8.6.16  Strip whitespace (spaces, tabs) from the beginning and end of each line

perl -ple 's/^[ \t]+|[ \t]+$//g'

This one-liner combines one-liners 6.13 and 6.14. It specifies the global /g flag to the s operator because you want it to delete whitespace at the beginning and the end of the string. If you don’t specify this, it deletes whitespace only at the beginning (if there is whitespace) or only at the end (if there was no whitespace at the beginning).

You can also replace [ \t]+$ with \s+ and get the same results:

perl -ple 's/^\s+|\s+$//g'

Writing \s+ is shorter than writing [ \t]+. And s stands for space, which makes it easier to remember.

			8.6.17  Convert UNIX newlines to DOS/Windows newlines

perl -pe 's|\012|\015\012|'

This one-liner substitutes the UNIX newline character \012 (LF) for the Windows/DOS newline character \015\012 (CRLF) on each line. One nice feature of s/regex/replace/ is that it can take characters other than forward slashes as delimiters. Here, it uses vertical pipes to delimit regex from replace to improve readability.

Newlines are usually represented as \n and carriage returns as \r, but across platforms, the meanings of the \n and \r sequences can vary. The UNIX newline character, however, is always available as \012 (LF), and the carriage-return character represented by \r is always available as \015 (CR). That’s why you use those numeric codes: Sometimes using the flexible sequence is preferable, but not here.

			8.6.18  Convert DOS/Windows newlines to UNIX newlines

perl -pe 's|\015\012|\012|'

This one-liner works in the opposite direction from one-liner 6.16. It takes Windows newlines (CRLF) and converts them to UNIX newlines (LF).

			8.6.19  Convert UNIX newlines to Mac newlines

perl -pe 's|\012|\015|'

Mac OS previously used \015 (CR) as newlines. This one-liner converts UNIX’s \012 (LF) to Mac OS’s \015 (CR).

			8.6.20  Substitute (find and replace) “foo” with “bar” on each line

perl -pe 's/foo/bar/'

This one-liner uses the s/regex/replace/ command to substitute the first occurrence of foo with bar on each line.

To replace all foos with bars, add the global /g flag:

perl -pe 's/foo/bar/g'

			8.6.21  Substitute (find and replace) “foo” with “bar” on lines that match “baz”

perl -pe '/baz/ && s/foo/bar/'

This one-liner is roughly equivalent to

while (defined($line = <>)) {
  if ($line =~ /baz/) {
    $line =~ s/foo/bar/
  }
}

This expanded code puts each line into the variable $line and then checks to see if a line in that variable matches baz. If so, it replaces foo with bar in that line.

You could also write

perl -pe 's/foo/bar/ if /baz/'

			8.6.22  Print paragraphs in reverse order

perl -00 -e 'print reverse <>' file

This one-liner uses the -00 argument discussed in one-liner 2.7 (page 14) to turn paragraph slurp mode on, meaning that Perl reads text paragraph by paragraph, rather than line by line. Next, it uses the <> operator to make Perl read the input from either standard input or files specified as arguments. Here, I’ve specified file as the argument so Perl will read file paragraph by paragraph (thanks to -00). Once Perl finishes reading the file, it returns all paragraphs as a list and calls reverse to reverse the order of the paragraph list. Finally, print prints the list of reversed paragraphs.

			8.6.23  Print all lines in reverse order

perl -lne 'print scalar reverse $_'

This one-liner evaluates the reverse operator in the scalar context. In the previous one-liner, you saw that evaluating reverse in the list context reverses the whole list, that is, the order of the elements. To do the same for scalar values such as $_ that contain the whole line, you have to call reverse in the scalar context. Otherwise, it simply reverses a list with only one element, which is the same list! Once you’ve done that, you simply print the reversed line.

Often you can drop the $_ variable when using operators and Perl will still apply the function on the $_ variable. In other words, you can rewrite the same one-liner as

perl -lne 'print scalar reverse'

Or you can substitute -n for -p, modify the $_ variable, and set its value to reverse:

perl -lpe '$_ = reverse $_'

You can also write this as

perl -lpe '$_ = reverse'

Here, $_ is dropped because most Perl operators default to $_ when not given an argument.

			8.6.24 Print columns in reverse order

perl -alne 'print "@{[reverse @F]}"'

This one-liner reverses the order of columns in a file. The -a command-line argument splits each line into columns at spaces and puts them in the @F array, which is then reversed and printed. This one-liner is similar to one-liner 4.4 on page 32; I explained the @{[ ... ]} construct there. It simply lets you run code inside of double quotes. For example, given the following input file:

one two three four
five six seven eight

the one-liner reverses the order of the columns, and the output is the following:

four three two one
eight seven six five

If the columns in your input are separated by any character other than a space, you can use the -F command-line argument to set a different delimiter. For example, given the following input file:

one:two:three:four
five:six:seven:eight

you can add the -F: command-line argument to the one-liner like this:

perl -F: -alne 'print "@{[reverse @F]}"'

and it produces this output:

four three two one
eight seven six five

Notice, however, that the : characters are missing in this output. To get them back, you need to modify the one-liner a bit and set the $" variable to ":", as shown here:

perl -F: -alne '$" = ":"; print "@{[reverse @F]}"'

This produces the expected output:

four:three:two:one
eight:seven:six:five

The $" variable changes the character that’s printed between array elements when an array is interpolated within a double-quoted string.

			8.6.25
		8.7  Selectively Printing and Deleting Lines

In this chapter, we’ll examine various one-liners that print and delete certain lines. These one-liners will, for example, print repeated lines, print the shortest line in a file, and print lines that match certain patterns.

But every one-liner that prints certain lines can also be viewed as one that deletes the lines that aren’t printed. For example, a one-liner that prints all unique lines deletes all repeated lines. I’ll discuss only the one-liners that print something, rather than delete something, because one is always the inverse of the other.

			8.7.1   Print the first line of a file (emulate head -1)

perl -ne 'print; exit' file

This one-liner is quite simple. Perl reads the first line into the $_ variable, thanks to the -n option, and then calls print to print the contents of the $_ variable. Then it just exits. That’s it. The first line is printed and that’s what you want.

You might also say that this one-liner deletes all lines except the first one. But don’t worry. This particular one-liner won’t delete the contents of the file unless you also specify the -i command-line argument, like this:

perl -i -ne 'print; exit' file

As I explained in Chapter 1 and in one-liner 6.1 on page 59, the -i argument edits the file in-place. In this case, all the lines in the file would be deleted except for the first. When using -i, always specify a backup extension to it, like this:

perl -i.bak -ne 'print; exit' file

This will create a backup file file.bak before the contents are overwritten.

You can add the -i command-line argument to any of the one-liners to change the file content. If you don’t use the -i argument, the one-liners simply print the new content of the file to screen rather than modifying the file.

			8.7.2    Print the first 10 lines of a file (emulate head -10)

perl -ne 'print if $. <= 10' file

This one-liner uses the $. special variable, which stands for “the current line number.” Each time Perl reads in a line, it increments $. by 1, so clearly this one-liner simply prints the first 10 lines.

This one-liner can also be written without the if statement:

perl -ne '$. <= 10 && print' file

Here, print is called only if the Boolean expression $. <= 10 is true, and this expression is true only if the current line number is less than or equal to 10.

Another, though somewhat trickier, way to do this is with the range operator (..) in the scalar context:

perl -ne 'print if 1..10' file

The range operator in the scalar context returns a Boolean value. The operator is bistable, like a flip-flop, and emulates the line-range (comma) operator in sed, awk, and various text editors. Its value is false as long as its left operand is false. Once the left operand is true, the range operator is true until the right operand is true, after which the range operator becomes false again. As a result, this bistable operator becomes true at the first line, stays true until the tenth line, and then becomes and remains false.

A fourth option is to follow the first example in this chapter:

perl -ne 'print; exit if $. == 10' file

Here, I put a condition on exit, which is that the current line (which I just printed) is number 10.

YIZAQ-M-D1BW:Work yizaq$ perl -ne 'print if $. <=10' context
02/04
jrules tutorial:
 D:\ILOG\JRules503\doc\html\tutorial\index.html
 
ILOG rule builder fishstore project.

all tutorials:
D:\ILOG\JRules503\examples.html

03/04

			8.7.3   Print the last line of a file (emulate tail -1)

perl -ne '$last = $_; END { print $last }' file

Printing the last line of a file is trickier than printing the first line, because you never know which is the last line. As a result, you always have to keep the line you just read in memory. In this one-liner, you always save the current line held in $_ into the $last variable. When the Perl program ends, it executes the code in the END block, which prints the last line read.

Here’s another way to do this:

perl -ne 'print if eof' file

This one-liner uses the eof (or end-of-file) function, which returns 1 if the next read returns the end-of-file. Because the next read after the last line in the file will return the end-of-file, this one-liner does the job. The next read means that Perl will attempt to read a character from the current file, and if reading the character fails, it will signal that the end-of-file has been reached, meaning the whole file has been read. If the read succeeds, Perl secretly puts the character back in the input stream as if nothing had happened.


$ perl -lne '$l=$_; END {print $l}' context
D:\ILOG\JRules503\doc\html\tutbrlanguage\index.html

			8.7.4   Print the last 10 lines of a file (emulate tail -10)

perl -ne 'push @a, $_; @a = @a[@a-10..$#a] if @a>10; END { print @a }' file

This one-liner is a bit tricky. Here, you push each line to the @a array and then replace @a with a slice of itself if the list contains more than 10 elements. The phrase @a = @a[@a-10..$#a] means “replace @a with the last 10 elements of @a.” The bit @a-10 causes @a to be evaluated in the scalar context, and thus it returns the number of elements in the array minus 10. The expression $#a is the last index in the @a array. And finally, @a[@a-10..$#a] slices (returns) the last 10 elements of the array, with which it overwrites @a itself so it always contains only the last 10 elements.

For example, suppose @a contains (line1, line2, line3, line4), and you want to print the last four lines of the file. When you read the fifth line, the array becomes (line1, line2, line3, line4, line5), and the value of @a-4 is 1 because @a in the scalar context is 5. But the value of $#a is 4 because it’s the last index in the array. Therefore when you take the slice @a[@a-4..$#a], it becomes @a[1..4], which drops the front element from the array, and the @a array becomes (line2, line3, line4, line5).

A simpler way to write this is with shift:

perl -ne 'push @a, $_; shift @a if @a>10; END { print @a }' file

This one-liner doesn’t need to slice @a because you can guarantee that if @a > 10, then @a == 11. shift is an operator that removes the first element of an array. So in this loop, you can simply shift off the first stored line when you have more than 10 lines.


| 
| YIZAQ-M-D1BW:Work yizaq$ tail -10 !$
| tail -10 context
| D:\ILOG\JRules503\examples.html
| 
| 03/04
| 1. cont. XSD tutorial
| http://www.w3schools.com/schema/schema_complex_text.asp
| 
| 2. Install ACS. talk 2 eitan fux 7290
| 
| 3. cont BRL tutorial:
| D:\ILOG\JRules503\doc\html\tutbrlanguage\index.htmlYIZAQ-M-D1BW:Work yizaq$ perl -ne 'push @a , $_; shift @a if @a > 10 ; END {print @a}' context
| D:\ILOG\JRules503\examples.html
| 
| 03/04
| 1. cont. XSD tutorial
| http://www.w3schools.com/schema/schema_complex_text.asp
| 
| 2. Install ACS. talk 2 eitan fux 7290
| 
| 3. cont BRL tutorial:

			8.7.5   Print only lines that match a regular expression

perl -ne '/regex/ && print'

This one-liner tests to see whether the current line matches /regex/. If so, the /regex/ match succeeds and print is called.

Instead of using &&, you can also use if to reverse the /regex/ and print statements:

perl -ne 'print if /regex/'

Print only lines that match a regular expression

perl -ne '/regex/ && print'

This one-liner tests to see whether the current line matches /regex/. If so, the /regex/ match succeeds and print is called.

Instead of using &&, you can also use if to reverse the /regex/ and print statements:

perl -ne 'print if /regex/'

			8.7.6    Print only lines that do not match a regular expression

perl -ne '!/regex/ && print'

This one-liner inverts the previous one-liner. Here, I test to see that the line doesn’t match /regex/ by inverting the match via the ! operator. If the line doesn’t match, I call print to print the line.

You can also write this the other way around:

perl -ne 'print if !/regex/'

And you can also use unless instead of if !:

perl -ne 'print unless /regex/'

Another way to write this is to apply De Morgan’s law to !/regex/ && print:

perl -ne '/regex/ || print'

			8.7.7   Print every line preceding a line that matches a regular expression

perl -ne '/regex/ && $last && print $last; $last = $_'

This one-liner prints a line when it is above a line that matches /regex/. Let’s walk through it, beginning at the last statement, $last = $_, which saves each line in the $last variable. Suppose the next line is read and it matches /regex/. Because the previous line is saved in $last, the one-liner simply prints it. The series of && means first that the regular expression must match and second that $last must be a true value. (Blank lines are still printed because they contain the newline character.)

Say you have a file with four lines:

hello world
magic line
bye world
magic line

and you want to print all lines above those that match magic. You can do this:

perl -ne '/magic/ && $last && print $last; $last = $_'

and the one-liner will print:

hello world
bye world

YIZAQ-M-D1BW:Work yizaq$ perl -ne '/^\d+/ && $last && print $last; $last = $_' context

03/04


			8.7.8 Print every line following a line that matches a regular expression

perl -ne 'if ($p) { print; $p = 0 } $p++ if /regex/'

Here, I set the variable $p to 1 if the current line matches the regular expression. The fact that the variable $p is 1 indicates that the next line should be printed. Now, when the next line is read in and $p is set, that line is printed and $p is reset to 0. Quite simple.

Let’s say you have this four-line file:

science
physics
science
math

and you want to print all lines below those that match science. Do this:

perl -ne 'if ($p) { print; $p = 0 } $p++ if /science/'

The one-liner will print:

physics
math

If you want to write this with && and avoid using if and curly brackets, do this:

perl -ne '$p && print && ($p = 0); $p++ if /science/'

You can also be very smart about this and simplify this one-liner to the following:

perl -ne '$p && print; $p = /science/'

If the current line matches science, then variable $p is set to a true value and the next line gets printed. If the current line doesn’t match science, then $p becomes undefined and the next line doesn’t get printed.  

			8.7.9   Print lines that match regular expressions AAA and BBB in any order

perl -ne '/AAA/ && /BBB/ && print'

This one-liner tests to see whether a line matches two regular expressions. If a line matches /AAA/ and /BBB/, it’s printed. Specifically, this one-liner prints the line foo AAA bar BBB baz because it contains both AAA and BBB, but it won’t print the line foo AAA bar AAA because it doesn’t contain BBB.

			8.7.10  Print lines that match regular expression AAA followed by BBB followed by CCC

perl -ne '/AAA.*BBB.*CCC/ && print'

Here, I simply chain the regular expressions AAA, BBB, and CCC with .*, which means “match anything or nothing at all.” If AAA is followed by BBB, which is followed by CCC, the line prints. For example, this one-liner matches and prints strings like 123AAA880BBB222CCC, xAAAyBBBzCCC, and AAABBBCCC.

			8.7.11   Print lines that are at least 80 characters long

perl -ne 'print if length >= 80'

This one-liner prints all lines that are at least 80 characters long. In Perl, you can sometimes omit the parentheses () for function calls, so here I’ve omitted them for the length function call. In fact, the invocations length, length(), and length($_) are all the same as far as Perl is concerned.

If you don’t want to count line endings, you can turn on automatic handling of line endings with -l:

perl -lne 'print if length >= 80'

This switch ensures that a blank line has zero length, whereas it usually has length 1 or 2, depending on the file format. (UNIX newlines have length 1; Windows newlines have length 2.)

			8.7.12  Print lines that are fewer than 80 characters long

perl -ne 'print if length() < 80'

This one-liner reverses the previous one. It checks to see whether the length of a line is less than 80 characters. Again, you use -l if you don’t want the line endings to be counted.

			8.7.13  Print only line 13

perl -ne '$. == 13 && print && exit'

As I explained in one-liner 7.2 on page 70, the $. special variable stands for “the current line number.” Therefore, if $. has a value of 13, this one-liner prints the line and exits.

			8.7.14  Print all lines except line 27

perl -ne '$. != 27 && print'

As in the previous one-liner, this one checks to see whether the line number of the current line is 27. If a line is not 27, it prints; if it is, it doesn’t print.

You can accomplish the same thing by reversing print and $. != 27 and using the if statement modifier—just like this:

perl -ne 'print if $. != 27'

Or you can use unless:

perl -ne 'print unless $. == 27'

			8.7.15  Print only lines 13, 19, and 67

perl -ne 'print if $. == 13 || $. == 19 || $. == 67'

This one-liner prints only lines 13, 19, and 67. It doesn’t print any other lines. Here’s how it works: It calls print if the current line number, stored in the $. variable, is 13, 19, or 67. You can use any line numbers to print specific lines. For example, to print the lines 13, 19, 88, 290, and 999, you do this:

perl -ne 'print if $. == 13 || $. == 19 || $. == 88 || $. == 290 || $. == 999'

If you want to print more lines, you can put them in a separate array and then test whether $. is in this array:

perl -ne '
  @lines = (13, 19, 88, 290, 999, 1400, 2000);
  print if grep { $_ == $. } @lines
'

This one-liner uses grep to test if the current line $. is in the @lines array. If the current line number is found in the @lines array, the grep function returns a list of one element that contains the current line number and this list evaluates to true. If the current line number is not found in the @lines array, the grep function returns an empty list that evaluates to false.


$ perl -ne '
@lines = (1,3,4,5,7);
print if grep { $_ == $. } @lines  
' stam
{ 
, "TrustedDomains":
[
{"trustee":"<null>", forest":"R1.dom, "domain":"r1.dom",	         "netbiosname":"R1, "sid":"S-1-5-21-1326888423-829440567-4131818482",  "site":"Default-First-Site-Name", "authenticable":"yes"},
{"trustee":"R1.DOM", forest":"R2.dom, "domain":"r2.dom",          "netbiosname":"R2, "sid":"S-1-5-21-971665854-3820453311-4154378001",  "site":"Default-First-Site-Name", "authenticable":"yes"},
[yizaq@YIZAQ-M-D1BW:Sun Mar 22:~:]$ 

			8.7.16  Print all lines from 17 to 30

perl -ne 'print if $. >= 17 && $. <= 30'

In this one-liner, the $. variable stands for the current line number. As a result, the one-liner checks to see whether the current line number is greater than or equal to 17 and less than or equal to 30.

You can do the same thing using the flip-flop operator, which is explained in one-liner 7.2 on page 70. The flip-flop operator operates on $. when used with integers:

perl -ne 'print if 17..30'

			8.7.17  Print all lines between two regular expressions (including the lines that match)

perl -ne 'print if /regex1/../regex2/'

This one-liner uses the flip-flop operator (explained in one-liner 7.2 on page 70). When used with integers, the operands are tested against the $. variable. When used with regular expressions, the operands are tested against the current line, stored in the $_ variable. Initially the operator returns false. When a line matches regex1, the operator flips and starts returning true until another line matches regex2. At that point, the operator returns true for the last time and then flips to the false state. From now on the operator returns false. This one-liner, therefore, prints all lines between (and including) the lines that match regex1 and regex2.

[yizaq@YIZAQ-M-D1BW:Sun Mar 22:~:]$ perl -ne ' print if /provider/../R2.dom/ ' stam
"provider":"lsa-activedirectory-provider", "forest":"R1.dom", "domain":"R1.DOM" 
, "TrustedDomains":
[
{"trustee":"<null>", forest":"R1.dom, "domain":"r1.dom",	         "netbiosname":"R1, "sid":"S-1-5-21-1326888423-829440567-4131818482",  "site":"Default-First-Site-Name", "authenticable":"yes"},
{"trustee":"R1.DOM", forest":"R1.dom, "domain":"c1.r1.dom",       "netbiosname":"C1, "sid":"S-1-5-21-744145595-4020540173-647283928",   "site":"<null>", "authenticable":"yes"},
{"trustee":"R1.DOM", forest":"R2.dom, "domain":"r2.dom",          "netbiosname":"R2, "sid":"S-1-5-21-971665854-3820453311-4154378001",  "site":"Default-First-Site-Name", "authenticable":"yes"},
[yizaq@YIZAQ-M-D1BW:Sun Mar 22:~:]$ 

			8.7.18  Print the longest line

perl -ne '
  $l = $_ if length($_) > length($l);
  END { print $l }
'

This one-liner keeps the longest line seen so far in the $l variable. If the length of the current line $_ exceeds the length of the longest line, the value in $l is replaced with the value of the current line. Before exiting, the END block is executed, and it prints the longest line value that’s held in $l.

Remember to use -l if you want to prevent the newline characters from counting toward the line length.

			8.7.19  Print the shortest line

perl -ne '
  $s = $_ if $. == 1;
  $s = $_ if length($_) < length($s);
  END { print $s }
'

This one-liner is the opposite of the previous one. Because it’s finding the shortest line and $s is not defined for the first line, you have to set its value to the first line explicitly through $s = $_ if $. == 1. Then it simply does the opposite of the previous one-liner. That is, it checks to see whether the current line is the shortest line so far and, if so, assigns it to $s.

			8.7.20  Print all lines containing digits

perl -ne 'print if /\d/'

This one-liner uses the regular expression \d (which stands for “a digit”) to see whether a line contains a digit. If so, the check succeeds, and the line is printed. For example, this line would be printed because it contains digits:

coding is as easy as 123

However, this line wouldn’t be printed because it doesn’t contain digits:

coding is as easy as pie

			8.7.21  Print all lines containing only digits

perl -ne 'print if /^\d+$/'

In this one-liner, the regular expression ^\d+$ means “match a line if it contains only digits from the beginning until the end.” For example, this line would be printed because it contains only digits:

3883737189170238912377

However, this line wouldn’t be printed because it also contains some characters:

8388338 foo bar random data 999

You can also invert the ^\d$ regular expression and use \D:

perl -lne 'print unless /\D/'

This one-liner is great for developing your logical reasoning because it uses logical negation twice. Here, the line prints only if it does not contain a non-numeric character. In other words, it prints only if all the characters are numeric. (Notice that I used the -l command-line argument for this one-liner because of the newline character at the end of the line. If I didn’t use -l, the line would contain the newline character—a non-numeric character—and it wouldn’t be printed.)

			8.7.22  Print all lines containing only alphabetic characters

perl -ne 'print if /^[[:alpha:]]+$/

This one-liner checks to see whether a line contains only alphabetic characters. If so, it prints the line. The [[:alpha:]] stands for “any alphabetic character.” And [[:alpha:]]+ stands for “all alphabetic characters.”

			8.7.23  Print every second line

perl -ne 'print if $. % 2'

This one-liner prints the first, third, fifth, and seventh lines (and so on). It does so because $. % 2 is true when the current line number is odd and false when the current line number is even.

			8.7.24  Print every second line, beginning with the second line

perl -ne 'print if $. % 2 == 0'

This one-liner is like previous one, except it prints the second, fourth, sixth, and eighth lines (and so on) because $. % 2 == 0 is true when the current line number is even.

Alternatively, you can simply invert the test from the previous example:

perl -ne 'print unless $. % 2'

			8.7.25  Print all repeated lines only once

perl -ne 'print if ++$a{$_} == 2'

This one-liner tracks the lines it has seen so far and counts the number of times it has seen the lines previously. If it sees a line a second time, it prints the line because ++$a{$_} == 2 is true. If it sees a line more than two times, it does nothing because the count for this line is greater than 2.

breakdown:
$a{} - hash, key is line content $_, value starts at 1 for each line, ++ when same line encountered

			8.7.26  Print all unique lines

perl -ne 'print unless $a{$_}++'

This one-liner prints a line only if the hash value $a{$_} for that line is false. Every time Perl reads in a line, it increments $a{$_}, which ensures that this one-liner prints only never-before-seen lines.

			8.7.27   Print n line before regexp
ex, n=4
[yizaq@YIZAQ-M-W1ZV:Sun Mar 12:~:]$ ed stam5
stam5: No such file or directory
aaa
?
a
aaaaa
bbb
ccccc
dddddd
eeeee
ffffff
gggggg

-> w/o regex
[yizaq@YIZAQ-M-W1ZV:Sun Mar 12:~:]$ perl -ne 'if (/fff/) {  print @a ; undef @a} ; if (@a<4) {push @a, $_} ;if (@a ==4) {shift @a} ; ' stam5
ccccc
dddddd
eeeee


-> with regex
[yizaq@YIZAQ-M-W1ZV:Sun Mar 12:~:]$ perl -ne 'if (/fff/) {  print @a ; undef @a; print $_} ; if (@a<4) {push @a, $_} ;if (@a ==4) {shift @a} ; ' stam5
ccccc
dddddd
eeeee
ffffff

-> before lines as paeameter
[yizaq@YIZAQ-M-W1ZV:Sun Mar 12:~:]$ perl -ne 'BEGIN {$b=4} ; if (/fff/) {  print @a ; undef @a; print $_} ; if (@a<$b) {push @a, $_} ;if (@a == $b) {shift @a} ; ' stam5
ccccc
dddddd
eeeee
ffffff

			8.7.28  



		8.8  Useful Regular Expressions

		In this chapter, we’ll look at various regular expressions and how to use them in some handy one-liners. The regular expressions include matching IP addresses, HTTP headers, and email addresses; matching numbers and number ranges; and extracting and changing matches. I’ll also share some regular expression puzzles and best practices. This chapter will be a bit different from previous ones because I’ll start with a regular expression and then write a one-liner that uses it.

			8.8.1 Match something that looks like an IP address

/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/

This regular expression doesn’t actually guarantee that the thing that matched is, in fact, a valid IP; it simply matches something that looks like an IP address. For example, it matches a valid IP such as 81.198.240.140 as well as an invalid IP such as 936.345.643.21.

Here’s how it works. The ^ at the beginning of the regular expression is an anchor that matches the beginning of the string. Next, \d{1,3} matches one, two, or three consecutive digits. The \. matches a dot. The $ at the end is an anchor that matches the end of the string. (You use both ^ and $ anchors to prevent strings like foo213.3.1.2bar from matching.)

You can simplify this regular expression by grouping the first three repeated \d{1,3}\. expressions:

/^(\d{1,3}\.){3}\d{1,3}$/

Say you have a file with the following content and you want to extract only the lines that look like IP addresses:

|     81.198.240.140
|     1.2.3.4
|     5.5
|     444.444.444.444
|     90.9000.90000.90000
|     127.0.0.1

To extract only the matching lines, you can write this:

perl -ne 'print if /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/'

which should print

| 81.198.240.140
| 1.2.3.4
| 444.444.444.444
| 127.0.0.1

One-liner 8.3 explains how to match an IP precisely, not just something that looks like an IP.   

			8.8.2   Test whether a number is in the range 0 to 255

/^([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$/

I like to challenge people with puzzles. One of my favorites is to ask someone to come up with a regular expression that matches a number range. Writing one is actually quite tricky if you’ve never done so before.

Here’s how it works. A number can have one, two, or three digits. If the number has one digit, you allow it to be anything [0-9]. If it has two digits, you also let it be any combination of [0-9][0-9]. But if the number has three digits, it has to be either one hundred–something or two hundred–something. If the number is one hundred–something, 1[0-9][0-9] matches it. If the number is two hundred–something, the number is either 200 to 249 (which is matched by 2[0-4][0-9]) or it’s 250 to 255 (which is matched by 25[0-5]).

Let’s confirm this regular expression really matches all numbers in the range 0 to 255 and write a one-liner to do it:

perl -le '
  map { $n++ if /^([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$/ } 0..255;
  END { print $n }
'

This one-liner outputs 256, the total numbers in the range 0 to 255. It iterates over the range 0 to 255 and increments the $n variable for every number that matches. If the output value was less than 256, you’d know that some numbers didn’t match.

Let’s also make sure this one-liner doesn’t match numbers above 255:

perl -le '
  map { $n++ if /^([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$/ } 0..1000;
  END { print $n }
'

Although there are 1001 iterations, from 0 to 1000, the final value of $n and the output should still be 256 because numbers greater than 255 should not match. If the value was greater than 256, you’d know that too many numbers matched and the regular expression was incorrect.

			8.8.3   Match an IP address

my $ip_part = qr/[0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]/;
if ($ip =~ /^$ip_part\.$ip_part\.$ip_part\.$ip_part$/) {
  print "valid ip\n";
}

This regular expression combines the ideas from the previous two regular expressions (8.1 and 8.2) and introduces the qr/.../ operator, which lets you construct a regular expression and save it in a variable. Here, I’m saving the regular expression that matches all numbers in the range 0 to 255 in the $ip_part variable. Next, the $ip_part matches the four parts of the IP address.

You can simplify this by grouping the first three IP parts:

if ($ip =~ /^($ip_part\.){3}$ip_part$/) {
  print "valid ip\n";
}

Let’s run this on the same file from one-liner 8.1. If you have this file as input:

|    81.198.240.140
|    1.2.3.4
|    5.5
|    444.444.444.444
|    90.9000.90000.90000
|    127.0.0.1

and your one-liner is

perl -ne '
  $ip_part = qr{([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])};
  print if /^($ip_part\.){3}$ip_part$/
'

then the output is

| 81.198.240.140
| 1.2.3.4
| 127.0.0.1

As you can see, only the valid IP addresses are printed.

			8.8.4   Check whether a string looks like an email address

/\S+@\S+\.\S+/

This regular expression makes sure the string looks like an email address; it doesn’t guarantee the string is an email address, however. First, it matches something that’s not whitespace (\S+) up to the @ symbol; then it matches as much as possible until it finds a dot; then it matches some more.

If the matches succeed, you know the string at least looks like an email address with the @ symbol and a dot in it. For example, cats@catonmat.net matches, but cats@catonmat doesn’t because the regular expression can’t find the dot that’s required in a fully qualified domain name.

Here’s a much more robust way to see whether a string is a valid email address, using the Email::Valid module:

use Email::Valid;
print Email::Valid->address('cats@catonmat.net') ? 'valid email' : 'invalid email';

Here, you use the ternary operator cond ? true : false. If the cond is true, the true part executes; otherwise the false part executes. This prints valid email if the email is valid; if not, it prints invalid email.

So a one-liner would look like this:

perl -MEmail::Valid -ne 'print if Email::Valid->address($_)'

Here, if the email address is valid, you simply print it.

			8.8.5    Check whether a string is a number

Determining whether a string is a number is difficult with a regular expression. This is a derivation of a regular expression that matches decimal numbers.

I start with Perl’s \d regular expression, which matches the digits 0 through 9:

/^\d+$/

This regular expression matches one or more digits \d from the beginning of the string ^ to the end at $. But it doesn’t match numbers such as +3 and -3. Let’s modify the regular expression to match them:

/^[+-]?\d+$/

Here, the [+-]? means “match an optional plus or a minus before the digits.” This regular expression now matches +3 and -3 but not -0.3. Let’s add that:

/^[+-]?\d+\.?\d*$/

I’ve expanded the previous regular expression by adding \.?\d*, which matches an optional dot followed by zero or more numbers. Now we’re in business. This regular expression also matches numbers like -0.3 and 0.3, though it would not match numbers such as 123,456 or .5.

A much better way to match a decimal number is to use the Regexp::Common module. For example, to match a decimal number, you can use $RE{num}{real} from Regexp::Common. Here’s a one-liner that filters the input and prints only the decimal numbers:

perl -MRegexp::Common -ne 'print if /$RE{num}{real}/'

This one-liner also matches and prints numbers such as 123,456 and .5.

How about matching positive hexadecimal numbers? Here’s how:

/^0x[0-9a-f]+$/i

This one-liner matches the hex prefix 0x followed by the hex number itself. The /i flag at the end ensures the match is case insensitive. For example, 0x5af matches, 0X5Fa matches, but 97 doesn’t because 97 has no hex prefix.

Better still, use $RE{num}{hex} because it supports negative numbers, decimal places, and number grouping.

How about matching octals?

/^0[0-7]+$/

Octal numbers are prefixed by 0, which is followed by the octal digits 0-7. For example, 013 matches but 09 doesn’t because it’s not a valid octal number. Using $RE{num}{oct} is better because it supports negative octal numbers, octal numbers with decimal places, and number grouping.

Finally, we come to binary matching:

/^[01]+$/

Binary base consists of only 0s and 1s, so 010101 matches but 210101 doesn’t because 2 is not a valid binary digit.

Regexp::Common also offers a better regular expression for matching binary numbers: $RE{num}{bin}.

			8.8.6   Check whether a word appears in a string twice

/(word).*\1/

This regular expression matches a word followed by something or nothing at all, followed by the same word. Here, (word) captures the word in group 1, and \1 refers to the contents of group 1, which is the same as writing /(word).*word/. For example, silly things are silly matches /(silly).*\1/, but silly things are boring doesn’t because silly is not repeated in the string.

			8.8.7    Increase all integers in a string by one

$str =~ s/(\d+)/$1+1/ge

Here, you use the substitution operator s to match all integers (\d+), put them in capture group 1, and then replace them with their value incremented by one: $1+1. The g flag finds all numbers in the string, and the e flag evaluates $1+1 as a Perl expression. For example, this 1234 is awesome 444 is turned into this 1235 is awesome 445.

Note that this regular expression doesn’t increment floating-point numbers because it uses \d+ to match integers. To increment floating-point numbers, use the $RE{num}{real} regular expression from one-liner 8.5. Here’s a sample one-liner that uses $RE{num}{real}:

perl -MRegexp::Common -pe 's/($RE{num}{real})/$1+1/ge'

If you pass this one-liner the input weird 44.5 line -1.25, it prints weird 45.5 line -0.25.

			8.8.8   Extract the HTTP User-Agent string from HTTP headers

/^User-Agent: (.+)$/

HTTP headers are formatted as Key: Value pairs. You can easily parse such strings by instructing the regular expression engine to save the Value part in the $1 group variable. For example, if the HTTP headers contain the following:

Host: www.catonmat.net
Connection: keep-alive
User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_0_0; en-US)
Accept: application/xml,application/xhtml+xml,text/html
Accept-Encoding: gzip,deflate,sdch
Accept-Language: en-US,en;q=0.8
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.3

then the regular expression will extract the string Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_0_0; en-US).

			8.8.9   Match printable ASCII characters

/[ -~]/

This regular expression is tricky and smart. To understand it, take a look at man ascii, and you’ll see that space starts at value 0x20 and the ~ character is 0x7e. The expression [ -~] defines a range of characters from the space until ~. Because all characters between the space and ~ are printable, this regular expression matches all printable characters. This is my favorite regular expression of all time because it’s quite puzzling when you first see it. What does it match? A space, a dash, and a tilde? No, it matches a range of characters from the space until the tilde!

To invert the match, place ^ as the first character in the group:

/[^ -~]/

This matches the opposite of [ -~], that is, all nonprintable characters.

			8.8.10  Extract text between two HTML tags

m|<strong>([^<]*)</strong>|

Before I explain this regular expression, let me say that it’s okay to match HTML with regular expressions only for quick hacks when you need to get things done and move on. You should never use regular expressions to match and parse HTML in serious applications because HTML is actually a complicated language, and, in general, it can’t be parsed by a regular expression. Instead, use modules like HTML::TreeBuilder to accomplish the task more cleanly!

This regular expression saves text between the <strong>...</strong> HTML tags in the $1 special variable. The trickiest part of this one-liner is ([^<]*), which matches everything up to the < character. It’s a regular expression idiom.

For example, if the HTML you’re trying to match is <strong>hello</strong>, then this regular expression captures hello in the $1 variable. However, if the HTML you’re trying to match is <strong><em>hello</em> </strong>, then this regular expression doesn’t match at all because there is another HTML tag between <strong> and </strong>.

To extract everything between two HTML tags, including other HTML tags, you can write:

m|<strong>(.*?)</strong>|

This regular expression saves everything between <strong>...</strong> in the $1 variable. For example, if the HTML is <strong><em>hello</em> </strong>, this regular expression sets $1 to <em>hello</em>. The (.*?) part of the regular expression matches everything between the two nearest <strong> and </strong> tags. The question mark ? in this regular expression controls its greediness.

If you want to be a good citizen and use HTML::TreeBuilder, then a Perl program that does the same thing would look like this:

use warnings;
use strict;
use HTML::TreeBuilder;
my $tree = HTML::TreeBuilder->new_from_content(
  "<strong><em>hello</em></strong>"
);
my $strong = $tree->look_down(_tag => 'strong');
if ($strong) {
  print $_->as_HTML for $strong->content_list;
}
$tree->delete;

Here, I created a new HTML::TreeBuilder instance from the given string; then I found the <strong> tag and dumped all the child elements of the <strong> tag as HTML. As you can see, although writing a program like this isn’t suitable as a one-liner, it’s a much more robust solution.

			8.8.11  Replace all <b> tags with <strong>

$html =~ s|<(/)?b>|<$1strong>|g

Here, I assume that the HTML is in the variable $html. The expression <(/)?b> matches the opening and closing <b> tags, captures the optional closing tag slash in the group $1, and then replaces the matched tag with either <strong> or </strong>, depending on whether it finds an opening or closing tag.

Remember that the correct way to do this is to use HTML::TreeBuilder and write a proper program. You should only use this regular expression for a quick hack. Here’s what a program that uses HTML::TreeBuilder looks like:

use warnings;
use strict;
use HTML::TreeBuilder;
my $tree = HTML::TreeBuilder->new_from_content("
  <div><p><b>section 1</b></p><p><b>section 2</b></p></div>
");
my @bs = $tree->look_down(_tag => 'b');
$_->tag('strong') for @bs;
print $tree->as_HTML;
$tree->delete;

Here, I’ve created the HTML::TreeBuilder object from the given string; next, I found all the <b> tags, stored them in the @bs array, and then looped over all @bs and changed their tag name to <strong>.

			8.8.12  Extract all matches from a regular expression

my @matches = $text =~ /regex/g;

Here, the regular expression match is evaluated in the list context, which makes it return all matches. The matches are put in the @matches variable.

For example, the following regular expression extracts all integers from a string:

my $t = "10 hello 25 moo 30 foo";
my @nums = $text =~ /\d+/g;

After executing this code, @nums contains (10, 25, 30). You can also use parentheses to capture only part of the string. For example, here’s how to capture only the values from a line containing lots of key-value pairs (such as key=value), separated by semicolons:

my @vals = $text =~ /[^=]+=([^;]+)/g;

This regular expression first matches the keys through [^=]+, then it matches the = character that separates the keys and values, and then it matches the values ([^;]+). As you can see, the value part of the regular expression is wrapped in parentheses so the values are captured.

Here’s an example. Say you have a file with the following contents:

access=all; users=peter,alastair,bill; languages=awk,sed,perl

and you write this one-liner:

perl -nle 'my @vals = $_ =~ /[^=]+=([^;]+)/g; print "@vals"'

Running it outputs the following:

all peter,alastair,bill awk,sed,perl

These are the values for the access, users, and languages keys!


		8.9 Perl’s Special Variables

In this appendix, I summarize Perl’s most commonly used special (predefined) variables, such as $_, $., $/, $\, $1, $2, $3 (and so on), $,, @F, and @ARGV, among others.

			8.9.1   
 Variable $_

The $_ variable, called the default variable, is the most commonly used variable in Perl. Often this variable is pronounced “it” (when not pronounced “dollar-underscore”); as you read on, you’ll understand why.

When using the -n and -p command-line arguments, it’s (see?) where the input is stored. Also, many operators and functions act on it implicitly. Here’s an example:

perl -le '$_ = "foo"; print'

Here, I place the string "foo" in the $_ variable and then call print. When given no arguments, print prints the contents of the $_ variable, which is "foo".

Similarly, $_ is used by the s/regex/replace/ and /regex/ operators when used without the =~ operator. Consider this example:

perl -ne '/foo/ && print'

This one-liner prints only lines that match /foo/. The /foo/ operator implicitly operates on the $_ variable that contains the current line. You could rewrite this as follows, but doing so would require too much typing:

perl -ne 'if ($_ =~ /foo/) { print $_ }'

“If it matches /foo/, print it”—you get the idea. You could also replace text in all the lines simply by calling s/foo/bar/:

perl -pe 's/foo/bar/'

Interestingly, Perl borrows the $_ variable from sed. Remember that sed has a pattern space? The $_ variable can also be called Perl’s pattern space. If you wrote the previous one-liner (perl -pe 's/foo/bar/') in sed, it would look like sed 's/foo/bar/' because sed puts each line in the pattern space and the s command acts on it implicitly. Perl borrows many concepts and commands from sed.
Using $_ with the -n argument

When using the -n argument, Perl puts the following loop around your program:

while (<>) {
    # your program goes here (specified by -e)
}

The while (<>) loop reads lines from standard input or files named on the command line and puts each line into the $_ variable. You can then modify the lines and print them. For example, you can reverse the lines:

perl -lne 'print scalar reverse'

Because I’m using the -n argument here, this program becomes

while (<>) {
    print scalar reverse
}

which is equivalent to

while (<>) {
    print scalar reverse $_
}

The two programs are equivalent because many Perl functions act on $_ implicitly, which makes writing reverse and reverse $_ functionally the same thing. You need scalar to put the reverse function in the scalar context. Otherwise it’s in the list context (print forces the list context) and won’t reverse strings. (I explain the -n flag in great detail in one-liner 2.6 on page 12 and line reversing in one-liner 6.22 on page 67.)
Using $_ with the -p argument

When you use the -p argument, Perl puts the following loop around your program:

while (<>) {
    # your program goes here (specified by -e)
} continue {
    print or die "-p failed: $!\n";
}

The result is almost the same as for the -n argument, except that after each iteration the content of $_ is printed (through print in the continue block).

To reverse the lines as I did with -n, I can do this:

perl -pe '$_ = reverse $_'

The program now becomes:

while (<>) {
    $_ = reverse $_;
} continue {
    print or die "-p failed: $!\n";
}

I’ve modified the $_ variable and set it to reverse $_, which reverses the line. The continue block makes sure that it’s printed. (One-liner 2.1 on page 7 explains the -p argument in more detail.)
Using $_ explicitly

The $_ variable is also often used explicitly. Here are some examples of using the $_ variable explicitly:

perl -le '@vals = map { $_ * 2 } 1..10; print "@vals"'

The output of this one-liner is 2 4 6 8 10 12 14 16 18 20. Here, I use the map function to map an expression over each element in the given list and return a new list, where each element is the result of the expression. In this case, the list is 1..10 (1 2 3 4 5 6 7 8 9 10) and the expression is $_ * 2, which means multiply each element (“it”) by 2. As you can see, I’m using $_ explicitly. When the map function iterates over the list, each element is put into $_ for my convenience.

Now let’s use map in a handy one-liner. How about one that multiplies each element on a line by 2?

perl -alne 'print "@{[map { $_ * 2 } @F]}"'

This one-liner maps the expression $_ * 2 onto each element in @F. The crazy-looking "@{[...]}" is just a way to execute code inside quotes. (One-liner 4.2 on page 30 explains @F, and one-liner 4.4 on page 32 explains "@{[...]}".)

Another function that explicitly uses $_ is grep, which lets you filter the elements from a list. Here’s an example:

perl -le '@vals = grep { $_ > 5 } 1..10; print "@vals"'

The output of this one-liner is 6 7 8 9 10. As you can see, grep filtered elements greater than 5 from the list. The condition $_ > 5 asks, “Is the current element greater than 5?”—or, more succinctly, “Is it greater than 5?”

Let’s use grep in a one-liner. How about one that finds and prints all elements on the current line that are palindromes?

perl -alne 'print "@{[grep { $_ eq reverse $_ } @F]}"'

The condition specified to the grep function here is $_ eq reverse $_, which asks, “Is the current element the same as its reverse?” This condition is true only for palindromes. For example, given the following input:

civic foo mom dad
bar baz 1234321 x

the one-liner outputs this:

civic mom dad
1234321 x

As you can see, all of these elements are palindromes.

You can learn even more about the $_ variable by typing perldoc perlvar at the command line. The perlvar documentation explains all the predefined variables in Perl.

			8.9.2  A.2 Variable $.

When reading a file, the $. variable always contains the line number of the line currently being read. For example, this one-liner numbers the lines in file:

perl -lne 'print "$. $_"' file

You can do the same thing with this one-liner, which replaces the current line with the line number followed by the same line:

perl -pe '$_ = "$. $_"' file

The $. variable isn’t reset across files, so to number multiple files simultaneously, you write

perl -pe '$_ = "$. $_"' file1 file2

This one-liner continues numbering lines in file2 where file1 left off. (If file1 contains 10 lines, the first line of file2 is numbered 11.)

To reset the $. variable, you use an explicit close on the current file handle ARGV:

perl -pe '$_ = "$. $_"; close ARGV if eof' file1 file2

ARGV is a special file handle that contains the currently open file. By calling eof, I’m checking to see if it’s the end of the current file. If so, close closes it, which resets the $. variable.

You can change what Perl considers to be a line by modifying the $/ variable. The next section discusses this variable.

			8.9.3  Variable $/

The $/ variable is the input record separator, which is a newline by default. This variable tells Perl what to consider a line. Say you have this simple program that numbers lines:

perl -lne 'print "$. $_"' file

Because $/ is a newline by default, Perl reads everything up to the first newline, puts it in the $_ variable, and increments the $. variable. Next, it calls print "$. $_", which prints the current line number and the line. But if you change the value of $/ to two newlines, like $/ = "\n\n", Perl reads everything up to the first two newlines; that is, it reads text paragraph by paragraph rather than line by line.

Here’s another example. If you have a file like the following, you can set $/ to :, and Perl will read the file digit by digit.

3:9:0:7:1:2:4:3:8:4:1:0:0:1:... (goes on and on)

Or if you set $/ to undef, Perl reads the entire file in a single read (called slurping):

perl -le '$/ = undef; open $f, "<", "file"; $contents = <$f>"

This one-liner slurps the entire file file in variable $contents.

You can also set $/ to reference an integer:

$/ = \1024

In this case, Perl reads the file 1024 bytes at a time. (This is also called record-by-record reading.)

You can also use the -0 command-line switch to provide this variable with a value, but note that you can’t do the record-by-record version like this. For example, to set $/ to :, specify -0072 because 072 is the octal value of the : character.

To remember what this variable does, recall that when quoting poetry, lines are separated by /.

			8.9.4  Variable $\

The dollar-backslash variable is appended after every print operation. For example, you could append a dot followed by a space ". " after each print:

perl -e '$\ = ". "; print "hello"; print "world"'

This one-liner produces the following output:

hello. world.

Modifying this variable is especially helpful when you want to separate printouts by double newlines.

To remember this variable, just recall that you probably want to print \n after every line. Note that for Perl 5.10 and later, the function say is available, which is like print, except that it always adds a newline at the end and doesn’t use the $\ variable.

			8.9.5  ariables $1, $2, $3, and so on

Variables $1, $2, $3, and so on contain the matches from the corresponding set of capturing parentheses in the last pattern match. Here’s an example:

perl -nle 'if (/She said: (.*)/) { print $1 }'

This one-liner matches lines that contain the string She said: and then captures everything after the string in variable $1 and prints it.

When you use another pair of parentheses, the text is captured in variable $2, and so on:

perl -nle 'if (/(She|He) said: (.*)/) { print "$1: $2" }'

In this one-liner, first either "She" or "He" is captured in variable $1 and then anything she or he said is captured in variable $2 and printed as "$1: $2". You’ll get the same number of capture variables as you have pairs of parentheses.

To avoid capturing text in a variable, use the ?: symbols inside the opening parenthesis. For example, changing (She|He) to (?:She|He):

perl -nle 'if (/(?:She|He) said: (.*)/) { print "Someone said: $1" }'

will not capture "She" or "He" in variable $1. Instead, the second pair of parentheses captures what she or he said in variable $1.

Beginning with Perl 5.10, you can use named capture groups as in (?<name>...). When you do, instead of using variables $1, $2, and so on, you can use $+{name} to refer to the group. For example, this captures "She" or "He" in the named group gender and the said text in the named group text:

perl -nle 'if (/(?<gender>She|He) said: (?<text>.*)/) {
  print "$+{gender}: $+{text}"
}'

			8.9.6  Variable $,

The $, variable is the output field separator for print when printing multiple values. It’s undefined by default, which means that all items printed are concatenated together. Indeed, if you do this:

perl -le 'print 1, 2, 3'

you get 123 printed out. If you set $, to a colon, however:

perl -le '$,=":"; print 1, 2, 3'

you get 1:2:3.

Now, suppose you want to print an array of values. If you do this:

perl -le '@data=(1,2,3); print @data'

the output is 123. But if you quote the variable, the values are space separated:

perl -le '@data=(1,2,3); print "@data"'

So the output is 1 2 3 because the array is interpolated in a double-quoted string.

			8.9.7  Variable $”

This brings us to the $" variable: a single white space (by default) that’s inserted between every array value when it’s interpolated. When you write things like print "@data", the @data array gets interpolated, and the value of $" is inserted between every array element. For example, this prints 1 2 3:

perl -le '@data=(1,2,3); print "@data"'

But if you change $" to, say, a dash -, the output becomes 1-2-3:

perl -le '@data=(1,2,3); $" = "-"; print "@data"'

Recall the @{[...]} trick here. If you print "@{[...]}", you can execute code placed between the square brackets. For examples and more details, see section A.1 Variable $_’s discussion of the $_ variable on page 95 and one-liner 4.4 on page 32.

			8.9.8  Variable @F

The @F variable is created in your Perl program when you use the -a argument, which stands for auto-split fields. When you use -a, the input is split on whitespace characters and the resulting fields are put in @F. For example, if the input line is foo bar baz, then @F is an array ("foo", "bar", "baz").

This technique allows you to operate on individual fields. For instance, you can access $F[2] to print the third field as follows (remembering that arrays start from index 0):

perl -ane 'print $F[2]'

You can also perform various calculations, like multiplying the fifth field by 2:

perl -ane '$F[4] *= 2; print "@F"'

Here, the fifth field $F[4] is multiplied by 2, and print "@F" prints all the fields, separated by a space.

You can also use the -a argument with the -F argument, which specifies the character to split on. For example, to process the colon-separated entries in /etc/passwd entries, you write

perl -a -F: -ne 'print $F[0]' /etc/passwd

which prints the usernames from /etc/passwd.

			8.9.9  Variable @ARGV

The @ARGV variable contains the arguments that you pass to your Perl program. For example, this prints foo bar baz:

perl -le 'print "@ARGV"' foo bar baz

When you use -n or -p flags, the arguments that you pass to your Perl program are opened one by one as files and removed from @ARGV. To access the filenames passed to your program, save them in a new variable in the BEGIN block:

perl -nle 'BEGIN { @A = @ARGV }; ...' file1 file2

Now you can use @A in your program, which contains ("file1", "file2"). If you didn’t do this and you used @ARGV, it would contain ("file2") at first, but when file1 was processed, it would be empty (). Be careful here!

A similar-looking variable, $ARGV, contains the filename of the file currently being read, which is "-" if the program is currently reading from the standard input.

			8.9.10 Variable %ENV

The %ENV hash contains environment variables from your shell. This variable comes in handy when you wish to predefine some values in your script and then use these values in your Perl program or one-liner.

Say you want to use the system function to execute a program that’s not in the path. You could modify the $ENV{PATH} variable and append the needed path:

perl -nle '
  BEGIN { $ENV{PATH} .= ":/usr/local/yourprog/bin" }
  ...
  system("yourprog ...");
'

This one-liner prints all environment variables from Perl:

perl -le 'print "$_: $ENV{$_}" for keys %ENV'

It loops over the keys (environment variable names) of the %ENV hash, puts each key into the $_ variable, and then prints the name followed by $ENV{$_}, which is the value of the environment variable.

[yizaq@YIZAQ-M-D1BW:Tue Mar 24:~/Desktop/Work/scripts/perl/cisco:]$ perl -le 'print "$_ : $ENV{$_}" for keys %ENV'
PATH : /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin:/usr/local/git/bin:/Users/yizaq:/Users/yizaq/Desktop/Work/scripts/util/:/Users/yizaq/Desktop/Work/scripts/perl/:/Users/yizaq/Desktop/Work/scripts/perl/util/:/Users/yizaq/Desktop/Work/scripts/python/util:/Users/yizaq/Desktop/Work/scripts/sh::/Users/yizaq/Desktop/Work/scripts/sed/:
_ : /usr/bin/perl
EDITOR : vi
XPC_FLAGS : 0x0
OLDPWD : /Users/yizaq
SHELL : /bin/bash
LOGNAME : yizaq
SHLVL : 1
__CF_USER_TEXT_ENCODING : 0x1F5:0x0:0x0
XPC_SERVICE_NAME : 0
VERSIONER_PERL_VERSION : 5.18
HISTCONTROL : ignoredups
HOME : /Users/yizaq
TMPDIR : /var/folders/93/4pntyw1d3fl4dchm031n456m0000gn/T/
SECURITYSESSIONID : 186a6
PAGER : less
PYTHONSTARTUP : /Users/yizaq/.pythonrc
SSH_AUTH_SOCK : /private/tmp/com.apple.launchd.36j8ocRpf2/Listeners
PROMPT_COMMAND : history -a
TERM : xterm-256color
USER : yizaq
TERM_PROGRAM_VERSION : 343.6
VERSIONER_PERL_PREFER_32_BIT : no
TERM_SESSION_ID : 40F2249C-EDFA-429E-B680-94330DA77E39
DISPLAY : /private/tmp/com.apple.launchd.Rh3jH5Rc9D/org.macosforge.xquartz:0
PWD : /Users/yizaq/Desktop/Work/scripts/perl/cisco
LC_CTYPE : UTF-8
TERM_PROGRAM : Apple_Terminal
Apple_PubSub_Socket_Render : /private/tmp/com.apple.launchd.dZMHLmTGsL/Render


			8.9.11 $| flush operator
$| = 1;  # flush output

		8.10 All oneliners
Useful One-Line Scripts for Perl                    Dec 03 2013 | version 1.10
--------------------------------                    -----------   ------------

Compiled by Peteris Krumins (peter@catonmat.net, @pkrumins on Twitter)
http://www.catonmat.net -- good coders code, great reuse

Latest version of this file is always at:

    http://www.catonmat.net/download/perl1line.txt

This file is also available in other languages:

    Chinese: https://github.com/vinian/perl1line.txt

    Please email me peter@catonmat.net if you wish to translate it.

Perl One-Liners on Github:
 
    https://github.com/pkrumins/perl1line.txt

    You can send me pull requests over GitHub! I accept bug fixes,
    new one-liners, translations and everything else related.

I have also written "Perl One-Liners Explained" ebook that's based on
this file. It explains all the one-liners here. Get it at:

    http://www.catonmat.net/blog/perl-book/

No Starch Press has published "Perl One-Liners" as a real book too:

    http://nostarch.com/perloneliners

These one-liners work both on UNIX systems and Windows. Most likely your
UNIX system already has Perl. For Windows get the Strawberry Perl at:

    http://www.strawberryperl.com/

|Table of contents:
|
|    1. File Spacing
|    2. Line Numbering
|    3. Calculations
|    4. String Creation and Array Creation
|    5. Text Conversion and Substitution
|    6. Selective Printing and Deleting of Certain Lines    
|    7. Handy Regular Expressions
|    8. Perl tricks


FILE SPACING 
------------

# Double space a file
perl -pe '$\="\n"'
perl -pe 'BEGIN { $\="\n" }'
perl -pe '$_ .= "\n"'
perl -pe 's/$/\n/'
perl -nE 'say'

# Double space a file, except the blank lines
perl -pe '$_ .= "\n" unless /^$/'
perl -pe '$_ .= "\n" if /\S/'

# Triple space a file
perl -pe '$\="\n\n"'
perl -pe '$_.="\n\n"'

# N-space a file
perl -pe '$_.="\n"x7'

# Add a blank line before every line
perl -pe 's//\n/'

# Remove all blank lines
perl -ne 'print unless /^$/'
perl -lne 'print if length'
perl -ne 'print if /\S/'

# Remove all consecutive blank lines, leaving just one
perl -00 -pe ''
perl -00pe0

# Compress/expand all blank lines into N consecutive ones
perl -00 -pe '$_.="\n"x4'

# Fold a file so that every set of 10 lines becomes one tab-separated line
perl -lpe '$\ = $. % 10 ? "\t" : "\n"'


LINE NUMBERING
--------------

# Number all lines in a file
perl -pe '$_ = "$. $_"'

# Number only non-empty lines in a file
perl -pe '$_ = ++$a." $_" if /./'

# Number and print only non-empty lines in a file (drop empty lines)
perl -ne 'print ++$a." $_" if /./'

# Number all lines but print line numbers only non-empty lines
perl -pe '$_ = "$. $_" if /./'

# Number only lines that match a pattern, print others unmodified
perl -pe '$_ = ++$a." $_" if /regex/'

# Number and print only lines that match a pattern
perl -ne 'print ++$a." $_" if /regex/'

# Number all lines, but print line numbers only for lines that match a pattern
perl -pe '$_ = "$. $_" if /regex/'

# Number all lines in a file using a custom format (emulate cat -n)
perl -ne 'printf "%-5d %s", $., $_'

# Print the total number of lines in a file (emulate wc -l)
perl -lne 'END { print $. }'
perl -le 'print $n=()=<>'
perl -le 'print scalar(()=<>)'
perl -le 'print scalar(@foo=<>)'
perl -ne '}{print $.'
perl -nE '}{say $.'

# Print the number of non-empty lines in a file
perl -le 'print scalar(grep{/./}<>)'
perl -le 'print ~~grep{/./}<>'
perl -le 'print~~grep/./,<>'
perl -E 'say~~grep/./,<>'

# Print the number of empty lines in a file
perl -lne '$a++ if /^$/; END {print $a+0}'
perl -le 'print scalar(grep{/^$/}<>)'
perl -le 'print ~~grep{/^$/}<>'
perl -E 'say~~grep{/^$/}<>'

# Print the number of lines in a file that match a pattern (emulate grep -c)
perl -lne '$a++ if /regex/; END {print $a+0}'
perl -nE '$a++ if /regex/; END {say $a+0}'


CALCULATIONS
------------

# Check if a number is a prime
perl -lne '(1x$_) !~ /^1?$|^(11+?)\1+$/ && print "$_ is prime"'

# Print the sum of all the fields on a line
perl -MList::Util=sum -alne 'print sum @F'

# Print the sum of all the fields on all lines
perl -MList::Util=sum -alne 'push @S,@F; END { print sum @S }'
perl -MList::Util=sum -alne '$s += sum @F; END { print $s }'

# Shuffle all fields on a line
perl -MList::Util=shuffle -alne 'print "@{[shuffle @F]}"'
perl -MList::Util=shuffle -alne 'print join " ", shuffle @F'

# Find the minimum element on a line
perl -MList::Util=min -alne 'print min @F'

# Find the minimum element over all the lines
perl -MList::Util=min -alne '@M = (@M, @F); END { print min @M }'
perl -MList::Util=min -alne '$min = min @F; $rmin = $min unless defined $rmin && $min > $rmin; END { print $rmin }'

# Find the maximum element on a line
perl -MList::Util=max -alne 'print max @F'

# Find the maximum element over all the lines
perl -MList::Util=max -alne '@M = (@M, @F); END { print max @M }'

# Replace each field with its absolute value
perl -alne 'print "@{[map { abs } @F]}"'

# Find the total number of fields (words) on each line
perl -alne 'print scalar @F'

# Print the total number of fields (words) on each line followed by the line
perl -alne 'print scalar @F, " $_"'

# Find the total number of fields (words) on all lines
perl -alne '$t += @F; END { print $t}'

# Print the total number of fields that match a pattern
perl -alne 'map { /regex/ && $t++ } @F; END { print $t }'
perl -alne '$t += /regex/ for @F; END { print $t }'
perl -alne '$t += grep /regex/, @F; END { print $t }'

# Print the total number of lines that match a pattern
perl -lne '/regex/ && $t++; END { print $t }'

# Print the number PI to n decimal places
perl -Mbignum=bpi -le 'print bpi(n)'

# Print the number PI to 39 decimal places
perl -Mbignum=PI -le 'print PI'

# Print the number E to n decimal places
perl -Mbignum=bexp -le 'print bexp(1,n+1)'

# Print the number E to 39 decimal places
perl -Mbignum=e -le 'print e'

# Print UNIX time (seconds since Jan 1, 1970, 00:00:00 UTC)
perl -le 'print time'

# Print GMT (Greenwich Mean Time) and local computer time
perl -le 'print scalar gmtime'
perl -le 'print scalar localtime'

# Print local computer time in H:M:S format
perl -le 'print join ":", (localtime)[2,1,0]'

# Print yesterday's date
perl -MPOSIX -le '@now = localtime; $now[3] -= 1; print scalar localtime mktime @now'

# Print date 14 months, 9 days and 7 seconds ago
perl -MPOSIX -le '@now = localtime; $now[0] -= 7; $now[4] -= 14; $now[7] -= 9; print scalar localtime mktime @now'

# Prepend timestamps to stdout (GMT, localtime)
tail -f logfile | perl -ne 'print scalar gmtime," ",$_'
tail -f logfile | perl -ne 'print scalar localtime," ",$_'

# Calculate factorial of 5
perl -MMath::BigInt -le 'print Math::BigInt->new(5)->bfac()'
perl -le '$f = 1; $f *= $_ for 1..5; print $f'

# Calculate greatest common divisor (GCM)
perl -MMath::BigInt=bgcd -le 'print bgcd(@list_of_numbers)'

# Calculate GCM of numbers 20 and 35 using Euclid's algorithm
perl -le '$n = 20; $m = 35; ($m,$n) = ($n,$m%$n) while $n; print $m'

# Calculate least common multiple (LCM) of numbers 35, 20 and 8
perl -MMath::BigInt=blcm -le 'print blcm(35,20,8)'

# Calculate LCM of 20 and 35 using Euclid's formula: n*m/gcd(n,m)
perl -le '$a = $n = 20; $b = $m = 35; ($m,$n) = ($n,$m%$n) while $n; print $a*$b/$m'

# Generate 10 random numbers between 5 and 15 (excluding 15)
perl -le '$n=10; $min=5; $max=15; $, = " "; print map { int(rand($max-$min))+$min } 1..$n'

# Find and print all permutations of a list
perl -MAlgorithm::Permute -le '$l = [1,2,3,4,5]; $p = Algorithm::Permute->new($l); print @r while @r = $p->next'

# Generate the power set
perl -MList::PowerSet=powerset -le '@l = (1,2,3,4,5); for (@{powerset(@l)}) { print "@$_" }'

# Convert an IP address to unsigned integer
perl -le '$i=3; $u += ($_<<8*$i--) for "127.0.0.1" =~ /(\d+)/g; print $u'
perl -le '$ip="127.0.0.1"; $ip =~ s/(\d+)\.?/sprintf("%02x", $1)/ge; print hex($ip)'
perl -le 'print unpack("N", 127.0.0.1)'
perl -MSocket -le 'print unpack("N", inet_aton("127.0.0.1"))'

# Convert an unsigned integer to an IP address
perl -MSocket -le 'print inet_ntoa(pack("N", 2130706433))'
perl -le '$ip = 2130706433; print join ".", map { (($ip>>8*($_))&0xFF) } reverse 0..3'
perl -le '$ip = 2130706433; $, = "."; print map { (($ip>>8*($_))&0xFF) } reverse 0..3'


STRING CREATION AND ARRAY CREATION
----------------------------------

# Generate and print the alphabet
perl -le 'print a..z'
perl -le 'print ("a".."z")'
perl -le '$, = ","; print ("a".."z")'
perl -le 'print join ",", ("a".."z")'

# Generate and print all the strings from "a" to "zz"
perl -le 'print ("a".."zz")'
perl -le 'print "aa".."zz"'

# Create a hex lookup table
@hex = (0..9, "a".."f")

# Convert a decimal number to hex using @hex lookup table
perl -le '$num = 255; @hex = (0..9, "a".."f"); while ($num) { $s = $hex[($num%16)&15].$s; $num = int $num/16 } print $s'
perl -le '$hex = sprintf("%x", 255); print $hex'
perl -le '$num = "ff"; print hex $num'

# Generate a random 8 character password
perl -le 'print map { ("a".."z")[rand 26] } 1..8'
perl -le 'print map { ("a".."z", 0..9)[rand 36] } 1..8'

# Create a string of specific length
perl -le 'print "a"x50'

# Create a repeated list of elements
perl -le '@list = (1,2)x20; print "@list"'

# Create an array from a string
@months = split ' ', "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec"
@months = qw/Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec/

# Create a string from an array
@stuff = ("hello", 0..9, "world"); $string = join '-', @stuff

# Find the numeric values for characters in the string
perl -le 'print join ", ", map { ord } split //, "hello world"'

# Convert a list of numeric ASCII values into a string
perl -le '@ascii = (99, 111, 100, 105, 110, 103); print pack("C*", @ascii)'
perl -le '@ascii = (99, 111, 100, 105, 110, 103); print map { chr } @ascii'

# Generate an array with odd numbers from 1 to 100
perl -le '@odd = grep {$_ % 2 == 1} 1..100; print "@odd"'
perl -le '@odd = grep { $_ & 1 } 1..100; print "@odd"'

# Generate an array with even numbers from 1 to 100
perl -le '@even = grep {$_ % 2 == 0} 1..100; print "@even"'

# Find the length of the string
perl -le 'print length "one-liners are great"'

# Find the number of elements in an array
perl -le '@array = ("a".."z"); print scalar @array'
perl -le '@array = ("a".."z"); print $#array + 1'


TEXT CONVERSION AND SUBSTITUTION
--------------------------------

# ROT13 a string
'y/A-Za-z/N-ZA-Mn-za-m/'

# ROT 13 a file
perl -lpe 'y/A-Za-z/N-ZA-Mn-za-m/' file

# Base64 encode a string
perl -MMIME::Base64 -e 'print encode_base64("string")'
perl -MMIME::Base64 -0777 -ne 'print encode_base64($_)' file

# Base64 decode a string
perl -MMIME::Base64 -le 'print decode_base64("base64string")'
perl -MMIME::Base64 -ne 'print decode_base64($_)' file

# URL-escape a string
perl -MURI::Escape -le 'print uri_escape($string)'

# URL-unescape a string
perl -MURI::Escape -le 'print uri_unescape($string)'

# HTML-encode a string
perl -MHTML::Entities -le 'print encode_entities($string)'

# HTML-decode a string
perl -MHTML::Entities -le 'print decode_entities($string)'

# Convert all text to uppercase
perl -nle 'print uc'
perl -ple '$_=uc'
perl -nle 'print "\U$_"'

# Convert all text to lowercase
perl -nle 'print lc'
perl -ple '$_=lc'
perl -nle 'print "\L$_"'

# Uppercase only the first word of each line
perl -nle 'print ucfirst lc'
perl -nle 'print "\u\L$_"'

# Invert the letter case
perl -ple 'y/A-Za-z/a-zA-Z/'

# Camel case each line
perl -ple 's/(\w+)/\u$1/g'
perl -ple 's/(?<!['])(\w+)/\u\1/g'

# Strip leading whitespace (spaces, tabs) from the beginning of each line
perl -ple 's/^[ \t]+//'
perl -ple 's/^\s+//'

# Strip trailing whitespace (space, tabs) from the end of each line
perl -ple 's/[ \t]+$//'

# Strip whitespace from the beginning and end of each line
perl -ple 's/^[ \t]+|[ \t]+$//g'

# Convert UNIX newlines to DOS/Windows newlines
perl -pe 's|\n|\r\n|'

# Convert DOS/Windows newlines to UNIX newlines
perl -pe 's|\r\n|\n|'

# Convert UNIX newlines to Mac newlines
perl -pe 's|\n|\r|'

# Substitute (find and replace) "foo" with "bar" on each line
perl -pe 's/foo/bar/'

# Substitute (find and replace) all "foo"s with "bar" on each line
perl -pe 's/foo/bar/g'

# Substitute (find and replace) "foo" with "bar" on lines that match "baz"
perl -pe '/baz/ && s/foo/bar/'

# Binary patch a file (find and replace a given array of bytes as hex numbers)
perl -pi -e 's/\x89\xD8\x48\x8B/\x90\x90\x48\x8B/g' file


SELECTIVE PRINTING AND DELETING OF CERTAIN LINES
------------------------------------------------

# Print the first line of a file (emulate head -1)
perl -ne 'print; exit'

# Print the first 10 lines of a file (emulate head -10)
perl -ne 'print if $. <= 10'
perl -ne '$. <= 10 && print'
perl -ne 'print if 1..10'

# Print the last line of a file (emulate tail -1)
perl -ne '$last = $_; END { print $last }'
perl -ne 'print if eof'

# Print the last 10 lines of a file (emulate tail -10)
perl -ne 'push @a, $_; @a = @a[@a-10..$#a]; END { print @a }'

# Print only lines that match a regular expression
perl -ne '/regex/ && print'

# Print only lines that do not match a regular expression
perl -ne '!/regex/ && print'

# Print the line before a line that matches a regular expression
perl -ne '/regex/ && $last && print $last; $last = $_'

# Print the line after a line that matches a regular expression
perl -ne 'if ($p) { print; $p = 0 } $p++ if /regex/'

# Print lines that match regex AAA and regex BBB in any order
perl -ne '/AAA/ && /BBB/ && print'

# Print lines that don't match match regexes AAA and BBB
perl -ne '!/AAA/ && !/BBB/ && print'

# Print lines that match regex AAA followed by regex BBB followed by CCC
perl -ne '/AAA.*BBB.*CCC/ && print'

# Print lines that are 80 chars or longer
perl -ne 'print if length >= 80'

# Print lines that are less than 80 chars in length
perl -ne 'print if length < 80'

# Print only line 13
perl -ne '$. == 13 && print && exit'

# Print all lines except line 27
perl -ne '$. != 27 && print'
perl -ne 'print if $. != 27'

# Print only lines 13, 19 and 67
perl -ne 'print if $. == 13 || $. == 19 || $. == 67'
perl -ne 'print if int($.) ~~ (13, 19, 67)' 

# Print all lines between two regexes (including lines that match regex)
perl -ne 'print if /regex1/../regex2/'

# Print all lines from line 17 to line 30
perl -ne 'print if $. >= 17 && $. <= 30'
perl -ne 'print if int($.) ~~ (17..30)'
perl -ne 'print if grep { $_ == $. } 17..30'

# Print the longest line
perl -ne '$l = $_ if length($_) > length($l); END { print $l }'

# Print the shortest line
perl -ne '$s = $_ if $. == 1; $s = $_ if length($_) < length($s); END { print $s }'

# Print all lines that contain a number
perl -ne 'print if /\d/'

# Find all lines that contain only a number
perl -ne 'print if /^\d+$/'

# Print all lines that contain only characters
perl -ne 'print if /^[[:alpha:]]+$/

# Print every second line
perl -ne 'print if $. % 2'

# Print every second line, starting the second line
perl -ne 'print if $. % 2 == 0'

# Print all lines that repeat
perl -ne 'print if ++$a{$_} == 2'

# Print all unique lines
perl -ne 'print unless $a{$_}++'

# Print the first field (word) of every line (emulate cut -f 1 -d ' ')
perl -alne 'print $F[0]'


HANDY REGULAR EXPRESSIONS
-------------------------

# Match something that looks like an IP address
/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/
/^(\d{1,3}\.){3}\d{1,3}$/

# Test if a number is in range 0-255
/^([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$/

# Match an IP address
my $ip_part = qr|([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|;
if ($ip =~ /^($ip_part\.){3}$ip_part$/) {
 say "valid ip";
}

# Check if the string looks like an email address
/\S+@\S+\.\S+/

# Check if the string is a decimal number
/^\d+$/
/^[+-]?\d+$/
/^[+-]?\d+\.?\d*$/

# Check if the string is a hexadecimal number
/^0x[0-9a-f]+$/i

# Check if the string is an octal number
/^0[0-7]+$/

# Check if the string is binary
/^[01]+$/

# Check if a word appears twice in the string
/(word).*\1/

# Increase all numbers by one in the string
$str =~ s/(\d+)/$1+1/ge

# Extract HTTP User-Agent string from the HTTP headers
/^User-Agent: (.+)$/

# Match printable ASCII characters
/[ -~]/

# Match unprintable ASCII characters
/[^ -~]/

# Match text between two HTML tags
m|<strong>([^<]*)</strong>|
m|<strong>(.*?)</strong>|

# Replace all <b> tags with <strong>
$html =~ s|<(/)?b>|<$1strong>|g

# Extract all matches from a regular expression
my @matches = $text =~ /regex/g;


PERL TRICKS
-----------

# Print the version of a Perl module
perl -MModule -le 'print $Module::VERSION'
perl -MLWP::UserAgent -le 'print $LWP::UserAgent::VERSION'


PERL ONE-LINERS EXPLAINED E-BOOK
--------------------------------

I have written an ebook based on the one-liners in this file. If you wish to
support my work and learn more about these one-liners, you can get a copy
of my ebook at:

    http://www.catonmat.net/blog/perl-book/

The ebook is based on the 7-part article series that I wrote on my blog.
In the ebook I reviewed all the one-liners, improved explanations, added
new ones, and added two new chapters - introduction to Perl one-liners
and summary of commonly used special variables.

You can read the original article series here:

    http://www.catonmat.net/blog/perl-one-liners-explained-part-one/
    http://www.catonmat.net/blog/perl-one-liners-explained-part-two/
    http://www.catonmat.net/blog/perl-one-liners-explained-part-three/
    http://www.catonmat.net/blog/perl-one-liners-explained-part-four/
    http://www.catonmat.net/blog/perl-one-liners-explained-part-five/
    http://www.catonmat.net/blog/perl-one-liners-explained-part-six/
    http://www.catonmat.net/blog/perl-one-liners-explained-part-seven/


CREDITS
-------

Andy Lester       http://www.petdance.com
Shlomi Fish       http://www.shlomifish.org
Madars Virza      http://www.madars.org
caffecaldo        https://github.com/caffecaldo
Kirk Kimmel       https://github.com/kimmel
avar              https://github.com/avar
rent0n


FOUND A BUG? HAVE ANOTHER ONE-LINER?
------------------------------------

Email bugs and new one-liners to me at peter@catonmat.net!


HAVE FUN
--------

I hope you found these one-liners useful. Have fun!

#---end of file---

		8.11
		8.12
		8.13
		8.14
		8.15
		8.16

		8.17 My examples

			8.17.1  Block range of IP addresses


[root@horse2 ~]# perl -e 'foreach (6..9) { system "echo block 10.56.53.8$_" ; system "iptables -A OUTPUT -d 10.56.53.8$_ -j DROP"  } '
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
	LANGUAGE = (unset),
	LC_ALL = (unset),
	LC_CTYPE = "UTF-8",
	LANG = "en_US.UTF-8"
    are supported and installed on your system.
perl: warning: Falling back to the standard locale ("C").
block 10.56.53.86
block 10.56.53.87
block 10.56.53.88
block 10.56.53.89
[root@horse2 ~]# iptables -L OUTPUT -n --line-numbers
Chain OUTPUT (policy ACCEPT)
num  target     prot opt source               destination         
1    DROP       icmp --  0.0.0.0/0            0.0.0.0/0           icmp type 14 
2    ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           
3    ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0           
4    DROP       all  --  0.0.0.0/0            10.56.53.86         
5    DROP       all  --  0.0.0.0/0            10.56.53.87         
6    DROP       all  --  0.0.0.0/0            10.56.53.88         
7    DROP       all  --  0.0.0.0/0            10.56.53.89         

			8.17.2 If pattern1 is found and after it pattern2 is found then print pattern2 + n consecutive lines
example when pattern1="Date:" and pattern2="per program memory start" and n=10
[root@yizaq-ise4 tmp]#  perl -ne '/Date:/ && print ;   if ( /per program memory start/) {$print =1; $cnt=10;} ; if ( $print && $cnt--) { print $_;} ; if ($cnt == 0 ) { $print =0; } ;' memdetailsreport
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
	LANGUAGE = (unset),
	LC_ALL = (unset),
	LC_CTYPE = "UTF-8",
	LANG = "en_US.UTF-8"
    are supported and installed on your system.
perl: warning: Falling back to the standard locale ("C").
Date: Tue Sep  1 15:22:15 IDT 2015 
*** per program memory start
##################################
Private 	 + 	 Shared 	 = 	 RAM used 	 Program
3.97 gb  	 + 	 16.02 mb  	 = 	 3.98 gb  	 jsvc(4)
1.19 gb  	 + 	 14.09 mb  	 = 	 1.21 gb  	 java(2)
773.51 mb  	 + 	 444.11 mb  	 = 	 1.18 gb  	 oracle(41)
45.79 mb  	 + 	 2.63 mb  	 = 	 48.43 mb  	 timestensubd(4)
35.49 mb  	 + 	 275.00 kb  	 = 	 35.76 mb  	 Decap_main
27.97 mb  	 + 	 805.00 kb  	 = 	 28.76 mb  	 lwsmd
12.21 mb  	 + 	 50.00 kb  	 = 	 12.26 mb  	 tnslsnr
Date: Tue Sep  1 15:27:26 IDT 2015 
*** per program memory start
##################################
Private 	 + 	 Shared 	 = 	 RAM used 	 Program
3.97 gb  	 + 	 16.02 mb  	 = 	 3.98 gb  	 jsvc(4)
1.19 gb  	 + 	 14.09 mb  	 = 	 1.21 gb  	 java(2)
771.46 mb  	 + 	 444.11 mb  	 = 	 1.18 gb  	 oracle(40)
45.81 mb  	 + 	 2.63 mb  	 = 	 48.45 mb  	 timestensubd(4)
35.49 mb  	 + 	 270.00 kb  	 = 	 35.75 mb  	 Decap_main
27.97 mb  	 + 	 805.00 kb  	 = 	 28.76 mb  	 lwsmd
12.21 mb  	 + 	 51.00 kb  	 = 	 12.26 mb  	 tnslsnr
Date: Tue Sep  1 15:32:36 IDT 2015 
*** per program memory start
##################################
Private 	 + 	 Shared 	 = 	 RAM used 	 Program
3.97 gb  	 + 	 16.02 mb  	 = 	 3.98 gb  	 jsvc(4)
1.17 gb  	 + 	 14.09 mb  	 = 	 1.19 gb  	 java(2)
773.75 mb  	 + 	 444.53 mb  	 = 	 1.18 gb  	 oracle(41)
45.83 mb  	 + 	 2.63 mb  	 = 	 48.47 mb  	 timestensubd(4)
35.49 mb  	 + 	 270.00 kb  	 = 	 35.75 mb  	 Decap_main
34.91 mb  	 + 	 805.00 kb  	 = 	 35.70 mb  	 lwsmd
12.21 mb  	 + 	 50.00 kb  	 = 	 12.26 mb  	 tnslsnr
Date: Tue Sep  1 15:37:46 IDT 2015 
*** per program memory start
##################################
Private 	 + 	 Shared 	 = 	 RAM used 	 Program
3.97 gb  	 + 	 16.02 mb  	 = 	 3.98 gb  	 jsvc(4)
1.17 gb  	 + 	 14.09 mb  	 = 	 1.19 gb  	 java(2)
769.21 mb  	 + 	 444.12 mb  	 = 	 1.18 gb  	 oracle(39)
45.85 mb  	 + 	 2.63 mb  	 = 	 48.49 mb  	 timestensubd(4)
35.49 mb  	 + 	 275.00 kb  	 = 	 35.76 mb  	 Decap_main
34.91 mb  	 + 	 805.00 kb  	 = 	 35.70 mb  	 lwsmd
12.21 mb  	 + 	 52.00 kb  	 = 	 12.26 mb  	 tnslsnr


		8.18
		8.19 My one liners 

			8.19.1 Delete line n, like sed -ie '1d'

			say n=1 , delete line 1.
[yizaq@YIZAQ-M-D1BW:Thu Feb 26:~/Downloads:]$ perl -i.bak -ne 'print if ($. != 1)  ' cctree.txt 
[yizaq@YIZAQ-M-D1BW:Thu Feb 26:~/Downloads:]$ perl -ne ' print if ($. == 1)   ' cctree.txt 

[yizaq@YIZAQ-M-D1BW:Thu Feb 26:~/Downloads:]$ diff cctree.txt cctree.txt.bak 
0a1
> *CCTree.txt*	Plugin for C Call-Tree Explorer *CCTree*

			8.19.2 Filter log files for patterns
[yizaq@YIZAQ-M-W1ZV:Thu Mar 09:~/Desktop/Work/ISE/support/ISE1_2/681519769_IBM_TAIWAN_CORPORATION/logs1:]$ perl -ne '/StepLatency=(.*?),/ && print "$_ \n latency: ",$1, "\n____________________\n"' *
____________________
AcsLogs,2017-01-10 14:02:55,447,DEBUG,0x2b21532a9940,cntx=0072338853,sesn=S0021ISENK02/251359947/8829699,Log_Message=[2017-01-10 14:02:55.447 +08:00 0250449176 5440 NOTICE RADIUS: Endpoint abandoned EAP session and started new, ConfigVersionId=392, Device IP Address=10.34.95.2, DestinationIPAddress=10.35.192.150, UserName=CTCB\\Z00007141, AcsSessionID=S0021ISENK02/251359947/8829699, SelectedAccessService=Default Network Access, FailureReason=5440 Endpoint abandoned EAP session and started new, Step=11001, Step=11017, Step=15049, Step=15008, Step=15048, Step=15048, Step=15048, Step=15004, Step=11507, Step=12500, Step=12625, Step=11006, Step=11001, Step=11018, Step=12301, Step=12300, Step=12625, Step=11006, Step=11001, Step=11018, Step=12302, Step=12318, Step=12800, Step=12805, Step=12806, Step=12801, Step=12802, Step=12305, Step=11006, Step=5440, NetworkDeviceName=TW-TPE-NKB-11F-DS-3850-1, NetworkDeviceGroups=Location#All Locations#NKB#NKB-11F, NetworkDeviceGroups=Device Type#All Device Types#Wireless, EapTunnel=PEAP, User-Name=CTCB\\Z00007141, NAS-IP-Address=10.34.95.2, Framed-IP-Address=10.34.91.131, Calling-Station-ID=48-45-20-3F-B1-FF, NAS-Port-Type=Wireless - IEEE 802.11, NAS-Port-Id=Capwap27, Airespace-Wlan-Id=1, CPMSessionID=0a225f0258743fff0001a68d, EndPointMACAddress=48-45-20-3F-B1-FF, ISEPolicySetName=Default, AllowedProtocolMatchedRule=Dot1X, StepLatency=29=18106, Location=Location#All Locations#NKB#NKB-11F, Device Type=Device Type#All Device Types#Wireless, Response={RadiusPacketType=Drop; },],MessageFormatter.cpp:75
 
 latency: 29=18106
____________________
AcsLogs,2017-01-10 14:07:03,398,DEBUG,0x2b21533aa940,cntx=0072341830,sesn=S0021ISENK02/251359947/8830175,user=host/W0211497-old,Log_Message=[2017-01-10 14:07:03.397 +08:00 0250461050 5400 NOTICE Failed-Attempt: Authentication failed, ConfigVersionId=392, Device IP Address=10.34.151.11, Device Port=1645, DestinationIPAddress=10.35.192.150, DestinationPort=1645, RadiusPacketType=AccessRequest, UserName=host/W0211497-old, Protocol=Radius, RequestLatency=8, NetworkDeviceName=TW-TPE-NKB-18F-FS-2960x-1, User-Name=host/W0211497-old, NAS-IP-Address=10.34.151.11, NAS-Port=50112, Service-Type=Framed, Framed-IP-Address=10.34.148.222, Framed-MTU=1500, State=37CPMSessionID=0A22970B000000CD10089E8A\;40SessionID=S0021ISENK02/251359947/8830175\;, Called-Station-ID=00-59-DC-D9-82-8C, Calling-Station-ID=40-A8-F0-48-70-E2, NAS-Port-Type=Ethernet, NAS-Port-Id=GigabitEthernet1/0/12, EAP-Key-Name=, cisco-av-pair=service-type=Framed, cisco-av-pair=audit-session-id=0A22970B000000CD10089E8A, cisco-av-pair=method=dot1x, AcsSessionID=S0021ISENK02/251359947/8830175, SelectedAccessService=Default Network Access, FailureReason=12321 PEAP failed SSL/TLS handshake because the client rejected the ISE local-certificate, Step=11001, Step=11017, Step=15049, Step=15008, Step=15048, Step=15048, Step=15048, Step=15004, Step=11507, Step=12500, Step=12625, Step=11006, Step=11001, Step=11018, Step=12301, Step=12300, Step=12625, Step=11006, Step=11001, Step=11018, Step=12302, Step=12318, Step=12800, Step=12805, Step=12806, Step=12807, Step=12810, Step=12305, Step=11006, Step=11001, Step=11018, Step=12304, Step=12305, Step=11006, Step=11001, Step=11018, Step=12304, Step=12318, Step=12815, Step=12321, Step=12307, Step=11504, Step=11003, NetworkDeviceGroups=Location#All Locations#NKB-Agent, NetworkDeviceGroups=Device Type#All Device Types#Wired, EapTunnel=PEAP, OpenSSLErrorMessage=SSL alert: code=0x230=560 \; source=remote \; type=fatal \; message="unknown CA", OpenSSLErrorStack=  47422130268480:error:14094418:SSL routines:SSL3_READ_BYTES:tlsv1 alert unknown ca:s3_pkt.c:1102:SSL alert number 48, CPMSessionID=0A22970B000000CD10089E8A, EndPointMACAddress=40-A8-F0-48-70-E2, ISEPolicySetName=Default, AllowedProtocolMatchedRule=Dot1X, StepLatency=34=15004, Location=Location#All Locations#NKB-Agent, Device Type=Device Type#All Device Types#Wired, Response={RadiusPacketType=AccessReject; },],MessageFormatter.cpp:75
 
 latency: 34=15004
____________________
AcsLogs,2017-01-10 14:07:24,022,DEBUG,0x2b21530a7940,cntx=0072342012,sesn=S0021ISENK02/251359947/8830166,Log_Message=[2017-01-10 14:07:24.022 +08:00 0250461791 5440 NOTICE RADIUS: Endpoint abandoned EAP session and started new, ConfigVersionId=392, Device IP Address=10.34.87.2, DestinationIPAddress=10.35.192.150, UserName=CTCB\\Z00014253, AcsSessionID=S0021ISENK02/251359947/8830166, SelectedAccessService=Default Network Access, FailureReason=5440 Endpoint abandoned EAP session and started new, Step=11001, Step=11017, Step=15049, Step=15008, Step=15048, Step=15048, Step=15048, Step=15004, Step=11507, Step=12500, Step=12625, Step=11006, Step=11001, Step=11018, Step=12301, Step=12300, Step=12625, Step=11006, Step=11001, Step=11018, Step=12302, Step=12318, Step=12800, Step=12805, Step=12806, Step=12801, Step=12802, Step=12305, Step=11006, Step=5440, NetworkDeviceName=TW-TPE-NKB-10F-DS-3850-1, NetworkDeviceGroups=Location#All Locations#NKB#NKB-10F, NetworkDeviceGroups=Device Type#All Device Types#Wireless, EapTunnel=PEAP, User-Name=CTCB\\Z00014253, NAS-IP-Address=10.34.87.2, Framed-IP-Address=10.34.83.137, Calling-Station-ID=10-02-B5-70-7C-90, NAS-Port-Type=Wireless - IEEE 802.11, NAS-Port-Id=Capwap27, Airespace-Wlan-Id=1, CPMSessionID=0a225702587472c300074696, EndPointMACAddress=10-02-B5-70-7C-90, ISEPolicySetName=Default, AllowedProtocolMatchedRule=Dot1X, StepLatency=29=36451, Location=Location#All Locations#NKB#NKB-10F, Device Type=Device Type#All Device Types#Wireless, Response={RadiusPacketType=Drop; },],MessageFormatter.cpp:75
 
 latency: 29=36451
____________________

With filename and more data:
[yizaq@YIZAQ-M-W1ZV:Thu Mar 09:~/Desktop/Work/ISE/support/ISE1_2/681519769_IBM_TAIWAN_CORPORATION/logs1:]$ perl -ne '/StepLatency=(\d+)=(\d+),/ && print "File $ARGV\nLine: $_ \nStep $1 latency: ",$2, "\n____________________\n"' *

			8.19.3 Print file suffixes sorted lexicographically
.xml[212680136@G9VK2GH2E:Thu Nov 09:/cygdrive/c/Users/212680136/Desktop/Yosi/Work/PET/source:]$ find -type f | perl -ne ' /.*(\.\w+$)/ && $suffix_hash{$1}++; END {$,="\n"; print sort keys  fix_hash} '

...
.cfg
.changes
.cmak
.codedemo
.cpp
.css
.dbi
.def
.dict
.diff
.dir
.doc
.dsp
.dummy
...

		8.20 nslookup hostnames in text file
[yizaq@YIZAQ-M-D1BW:Wed Jun 24:~:]$ cat stam
yizaq-ise1 - 10.56.55.120 
yizaq-ise2 - 10.56.55.121 
yizaq-ise3 - 10.56.55.122 
yizaq-ise4 - 10.56.55.123 
yizaq-ise5 - 10.56.55.124 
yizaq-ise6 - 10.56.55.125

[yizaq@YIZAQ-M-D1BW:Wed Jun 24:~:]$ perl -ne 'system ("nslookup $1") if /(\w+-\w+)/ ;' stam 
Server:		144.254.71.184
Address:	144.254.71.184#53

Name:	yizaq-ise1.cisco.com
Address: 10.56.55.120

Server:		144.254.71.184
Address:	144.254.71.184#53

Name:	yizaq-ise2.cisco.com
Address: 10.56.55.121

Server:		144.254.71.184
Address:	144.254.71.184#53

Name:	yizaq-ise3.cisco.com
Address: 10.56.55.122

Server:		144.254.71.184
Address:	144.254.71.184#53

Name:	yizaq-ise4.cisco.com
Address: 10.56.55.123

Server:		144.254.71.184
Address:	144.254.71.184#53

Name:	yizaq-ise5.cisco.com
Address: 10.56.55.124

Server:		144.254.71.184
Address:	144.254.71.184#53

Name:	yizaq-ise6.cisco.com
Address: 10.56.55.125

		8.21 sort lines According to given pattern
YIZAQ-M-D1BW:~ yizaq$ cat !$
cat stam
a=123
a=2345
a=i54

1232345i54YIZAQ-M-D1BW:~ yizaq$ perl -ne ' if (/a=(.*)$/)  { push @b,"$1\n" ;} END {print sort(@b) ; } ' stam
123
2345
i54

for non greedy use *? (say if lines look like: a=123,b=546,c= , use /a=(.*?),/ )

		8.22 Count lines that contain pattern and sort according to pattern 
YIZAQ-M-D1BW:~ yizaq$ cat stam
a=123
a=123
a=123
a=2345
a=i54
YIZAQ-M-D1BW:~ yizaq$ perl -ne ' if (/a=(.*)$/)  { $b{$1}++ } END { foreach $l (sort keys %b ) {print " $l $b{$l} times \n" } print "\n"} ' stam 
 123 3 times 
 2345 1 times 
 i54 1 times 


		8.23
9.  FAQ, troubleshooting

	9.1  system

		9.1.1  sh: line 1: ... Permission denied

ex:
Executing: cleartool lsact -long yizaq_CSCum97393Found file     /vob/nm_acs/pbis/cisco/CAD_Diag/systemHealthDiagnostics/src/sysHealthDiag.cpp, version 10, run diff vs. 0 
cleartool diff -diff /vob/nm_acs/pbis/cisco/CAD_Diag/systemHealthDiagnostics/src/sysHealthDiag.cpp@@/main/yizaq2.int.pbis/10
sh: line 1: /vob/nm_acs/pbis/cisco/CAD_Diag/systemHealthDiagnostics/src/sysHealthDiag.cpp@@/main/yizaq2.int.pbis/0: Permission denied

code: system  "cleartool diff -diff $curr_ver $base_ver \n";
reason: rouge \n in $curr_ver -> 2 lines are passed to sh -c instead of just one.
fix: chomp $curr_ver 
also use system(cmd, arg1, arg2...); safer format.

	9.2 Files

		9.2.1 Get file last modification time


You can use the built-in module File::stat (included as of Perl 5.004).

Calling stat($fh) returns an array with the following information about the file handle passed in (from the perlfunc man page for stat):

  0 dev      device number of filesystem
  1 ino      inode number
  2 mode     file mode  (type and permissions)
  3 nlink    number of (hard) links to the file
  4 uid      numeric user ID of file's owner
  5 gid      numeric group ID of file's owner
  6 rdev     the device identifier (special files only)
  7 size     total size of file, in bytes
  8 atime    last access time since the epoch
  9 mtime    last modify time since the epoch
 10 ctime    inode change time (NOT creation time!) since the epoch
 11 blksize  preferred block size for file system I/O
 12 blocks   actual number of blocks allocated

The 9th element in this array will give you the last modified time since the epoch (00:00 January 1, 1970 GMT). From that you can determine the local time:

my $epoch_timestamp = (stat($fh))[9];
my $timestamp       = localtime($epoch_timestamp);

To avoid the magic number 9 needed in the previous example, additionally use Time::localtime, another built-in module (also included as of Perl 5.004). This requires some (arguably) more legible code:

use File::stat;
use Time::localtime;
my $timestamp = ctime(stat($fh)->mtime);


		9.2.2

	9.3
10. My scripts

	10.1 Check that build process is not stuck

- prepartion:
Simulate build on left hand side of pipe, check elapsed time on right
[yizaq@YIZAQ-M-D1BW:Mon Mar 23:~:]$ perl -le ' while (1) { ++$i; print "aaa $i"; $| = 1; sleep 2;}' | perl -lne ' if ($t1) {$t0 = $t1} ; $t1 = time(); $nt1 = localtime($t1); print "caught input $_ at $nt1" ; if (defined $t0) {print "time diff from last input ", $t1 - $t0 }'
caught input aaa 1 at Mon Mar 23 18:26:06 2015
caught input aaa 2 at Mon Mar 23 18:26:08 2015
time diff from last input 2
caught input aaa 3 at Mon Mar 23 18:26:10 2015
time diff from last input 2
caught input aaa 4 at Mon Mar 23 18:26:12 2015
time diff from last input 2
caught input aaa 5 at Mon Mar 23 18:26:14 2015
time diff from last input 2
caught input aaa 6 at Mon Mar 23 18:26:16 2015
time diff from last input 2
caught input aaa 7 at Mon Mar 23 18:26:18 2015
time diff from last input 2
caught input aaa 8 at Mon Mar 23 18:26:20 2015
time diff from last input 2
caught input aaa 9 at Mon Mar 23 18:26:22 2015
time diff from last input 2
caught input aaa 10 at Mon Mar 23 18:26:24 2015
time diff from last input 2
caught input aaa 11 at Mon Mar 23 18:26:26 2015
time diff from last input 2

[yizaq@YIZAQ-M-D1BW:Mon Mar 23:~:]$ perl -le ' while (1) { ++$i; print "aaa $i"; $| = 1; sleep 2;}' | perl -lne ' if ($t1) {$t0 = $t1} ; $t1 = time(); $nt1 = localtime($t1); print "caught input $_ at $nt1" ; if (defined $t0) {print "time diff from last input ", $t1 - $t0 }'

	10.2 tail -f emulate
- from web
#!/usr/bin/perl
open (LOGFILE, "aa") or die "could not open file reason $! \n";

for (;;)
{
        seek(LOGFILE,0,1);  ### clear OF condition        
        for ($curpos = tell(LOGFILE); <LOGFILE>; $curpos = tell(LOGFILE)) 
        {
                print "$_ \n";
        }

        sleep 1;
        seek(LOGFILE,$curpos,0); ### Setting cursor at the EOF
}

- My example , read from pipe


- My example, some changes to read from stdin
r /Users/yizaq/Desktop/Work/scripts/perl/cisco/tail-f.pl

#!/usr/bin/perl

#Author. Yosi Izaq
#Desc: monit build, if stuck report

#use strict;


seek(STDIN,0,1);  ### clear OF condition        
for (;;)
{

	print "in main loop\n";
	$t0=time();
    $d= tell(STDIN);
	print "current pos: $d\n";

	#regular loop that simulates tail -f
    for ($c= tell(STDIN); <STDIN>; $c= tell(STDIN)) 
    {
		$t1=time();
		$lt1=localtime($t1);
		$difft= $t1-$t0;

        print "got line $. at $lt1, waited $difft sec, content: $_";
		$t0= $t1;
    }
	print "after read loop\n";
    sleep 1;
    seek(STDIN,$c,0); ### Setting cursor at the EOF
}

-
	10.3
11. regexp syntax

    11.1 common operators
   [bgh.]      One of the characters listed in the character class b,g,h or . in this case.
   [b-h]       The same as [bcdefgh].
   [a-z]       Lower case Latin letters. 
   [bc-]       The characters b, c or - (dash).
   [^bx]       Complementary character class. Anything except b or x.
   \w          Word characters: [a-zA-Z0-9_].
   \d          Digits: [0-9]
   \s          [\f\t\n\r ] form-feed, tab, newline, carriage return and SPACE
   \W          The complementary of \w: [^\w]
   \D          [^\d]
   \S          [^\s]
   [:class:]   POSIX character classes (alpha, alnum...)
   \p{...}     Unicode definitions (IsAlpha, IsLower, IsHebrew, ...)
   \P{...}     Complementary Unicode character classes.

    11.2

12.
