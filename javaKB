.........................................Table Of Contents...............................................................
1. spring <URL:#tn=1. spring>
    1.1 tutorial <URL:#tn=    1.1 tutorial>
        1.1.1  IDE, intellij <URL:#tn=        1.1.1  IDE, intellij>
        1.1.2 Key concepts / files <URL:#tn=        1.1.2 Key concepts / files>
            1.1.2.1 dependency Injection <URL:#tn=            1.1.2.1 dependency Injection>
            1.1.2.2 Spring configuration file, usually spring.xml <URL:#tn=            1.1.2.2 Spring configuration file, usually spring.xml>
            1.1.2.3 main application <URL:#tn=            1.1.2.3 main application>
                1.1.2.3.1 example of BeanFactory, ApplicationContext, AbstractApplicationContext, getting beans and wiring to HTTP requests <URL:#tn=                1.1.2.3.1 example of BeanFactory, ApplicationContext, AbstractApplicationContext, getting beans and wiring to HTTP requests>
                1.1.2.3.2 <URL:#tn=                1.1.2.3.2>
            1.1.2.4 beans <URL:#tn=            1.1.2.4 beans>
                1.1.2.4.1 example, simple bean <URL:#tn=                1.1.2.4.1 example, simple bean>
                1.1.2.4.2 Bean that is ApplicationContext and name aware , also has init and cleanup callbacks <URL:#tn=                1.1.2.4.2 Bean that is ApplicationContext and name aware , also has init and cleanup callbacks>
                1.1.2.4.3 Bean that is InitializingBean and DisposableBean, also contains a container member field <URL:#tn=                1.1.2.4.3 Bean that is InitializingBean and DisposableBean, also contains a container member field>
                1.1.2.4.4 BeanPostProcessor <URL:#tn=                1.1.2.4.4 BeanPostProcessor>
                1.1.2.4.5 code to interface example <URL:#tn=                1.1.2.4.5 code to interface example>
                    1.1.2.4.5.1  animal interface <URL:#tn=                    1.1.2.4.5.1  animal interface>
                    1.1.2.4.5.2 animals: cat, dog, horse <URL:#tn=                    1.1.2.4.5.2 animals: cat, dog, horse>
                1.1.2.4.6 Internationalization and application resources <URL:#tn=                1.1.2.4.6 Internationalization and application resources>
                1.1.2.4.7 Events <URL:#tn=                1.1.2.4.7 Events>
                    1.1.2.4.7.1 GeneralEvtListener <URL:#tn=                    1.1.2.4.7.1 GeneralEvtListener>
                    1.1.2.4.7.2 ToStringEvt <URL:#tn=                    1.1.2.4.7.2 ToStringEvt>
                    1.1.2.4.7.3 publish custom events <URL:#tn=                    1.1.2.4.7.3 publish custom events>
                    1.1.2.4.7.4 <URL:#tn=                    1.1.2.4.7.4>
                1.1.2.4.8 <URL:#tn=                1.1.2.4.8>
            1.1.2.5 <URL:#tn=            1.1.2.5>
        1.1.3 <URL:#tn=        1.1.3>
    1.2 database <URL:#tn=    1.2 database>
        1.2.1  database connections <URL:#tn=        1.2.1  database connections>
            1.2.1.1    database connections pools <URL:#tn=            1.2.1.1    database connections pools>
                1.2.1.1.1    Apache Commons DBCP <URL:#tn=                1.2.1.1.1    Apache Commons DBCP>
                1.2.1.1.2 HikariCP <URL:#tn=                1.2.1.1.2 HikariCP>
                1.2.1.1.3 C3PO <URL:#tn=                1.2.1.1.3 C3PO>
                1.2.1.1.4 A Simple Implementation <URL:#tn=                1.2.1.1.4 A Simple Implementation>
            1.2.1.2 <URL:#tn=            1.2.1.2>
        1.2.2 <URL:#tn=        1.2.2>
    1.3 chatgpt <URL:#tn=    1.3 chatgpt>
        1.3.1  q. what is spring-boot-starter-webflux <URL:#tn=        1.3.1  q. what is spring-boot-starter-webflux>
        1.3.2 q. explain the basics of setting up a reactive web application using <URL:#tn=        1.3.2 q. explain the basics of setting up a reactive web application using>
        1.3.3 q. example using maven and postgress DB <URL:#tn=        1.3.3 q. example using maven and postgress DB>
        1.3.4 use JDBC instead of JPA <URL:#tn=        1.3.4 use JDBC instead of JPA>
        1.3.5 explain java org.springframework.context.annotation.Profile <URL:#tn=        1.3.5 explain java org.springframework.context.annotation.Profile>
1. Defining Profiles: Profiles are defined using the `@Profile` annotation at the class or method level. You can assign one or more profile names to the annotation. For example: <URL:#tn=1. Defining Profiles: Profiles are defined using the `@Profile` annotation at the class or method level. You can assign one or more profile names to the annotation. For example:>
2. Activating Profiles: Profiles can be activated in various ways, depending on your application's setup. Here are a few common methods: <URL:#tn=2. Activating Profiles: Profiles can be activated in various ways, depending on your application's setup. Here are a few common methods:>
3. Conditional Bean Creation: The `@Profile` annotation can also be used to conditionally create beans based on profiles. By annotating a bean definition or `@Configuration` class with `@Profile`, the bean(s) will only be created when the specified profile is active. For example: <URL:#tn=3. Conditional Bean Creation: The `@Profile` annotation can also be used to conditionally create beans based on profiles. By annotating a bean definition or `@Configuration` class with `@Profile`, the bean(s) will only be created when the specified profile is active. For example:>
        1.3.6 is there a spring framework DataSource class or interface <URL:#tn=        1.3.6 is there a spring framework DataSource class or interface>
        1.3.7 explain org.springframework.jdbc.core.JdbcTemplate <URL:#tn=        1.3.7 explain org.springframework.jdbc.core.JdbcTemplate>
1. Database Operations: The `JdbcTemplate` class provides methods for executing various types of SQL operations, such as updates, inserts, deletes, and selects. These methods handle all the necessary details, including acquiring and releasing database connections, executing SQL statements, binding parameters, and processing result sets. <URL:#tn=1. Database Operations: The `JdbcTemplate` class provides methods for executing various types of SQL operations, such as updates, inserts, deletes, and selects. These methods handle all the necessary details, including acquiring and releasing database connections, executing SQL statements, binding parameters, and processing result sets.>
2. Exception Handling: The `JdbcTemplate` class handles SQLExceptions that occur during database operations and wraps them in more meaningful and standardized Spring exceptions, such as `DataAccessException`. This simplifies error handling and allows for consistent exception handling across different database operations. <URL:#tn=2. Exception Handling: The `JdbcTemplate` class handles SQLExceptions that occur during database operations and wraps them in more meaningful and standardized Spring exceptions, such as `DataAccessException`. This simplifies error handling and allows for consistent exception handling across different database operations.>
3. PreparedStatement Creation: The `JdbcTemplate` class can create `PreparedStatement` objects for executing SQL statements with bound parameters. It automatically handles the preparation of the statement and sets the appropriate parameter values based on the provided arguments. <URL:#tn=3. PreparedStatement Creation: The `JdbcTemplate` class can create `PreparedStatement` objects for executing SQL statements with bound parameters. It automatically handles the preparation of the statement and sets the appropriate parameter values based on the provided arguments.>
4. ResultSet Processing: The `JdbcTemplate` class provides methods for processing `ResultSet` objects returned from SELECT queries. It simplifies the process of iterating over the result set, extracting data, and mapping it to Java objects or data structures. <URL:#tn=4. ResultSet Processing: The `JdbcTemplate` class provides methods for processing `ResultSet` objects returned from SELECT queries. It simplifies the process of iterating over the result set, extracting data, and mapping it to Java objects or data structures.>
5. Batch Updates: The `JdbcTemplate` class supports batch updates, allowing you to execute multiple SQL statements as a single batch. This can significantly improve performance when dealing with multiple database operations. <URL:#tn=5. Batch Updates: The `JdbcTemplate` class supports batch updates, allowing you to execute multiple SQL statements as a single batch. This can significantly improve performance when dealing with multiple database operations.>
6. Exception Translation: The `JdbcTemplate` class integrates with Spring's `SQLExceptionTranslator` mechanism, which translates database-specific SQL exceptions into Spring's standardized `DataAccessException` hierarchy. This helps to abstract away the database-specific exception handling and provides a consistent exception model. <URL:#tn=6. Exception Translation: The `JdbcTemplate` class integrates with Spring's `SQLExceptionTranslator` mechanism, which translates database-specific SQL exceptions into Spring's standardized `DataAccessException` hierarchy. This helps to abstract away the database-specific exception handling and provides a consistent exception model.>
7. Callback Mechanism: The `JdbcTemplate` class supports a callback mechanism through the use of various callback interfaces. These interfaces, such as `PreparedStatementCreator`, `PreparedStatementSetter`, `RowMapper`, and others, allow you to customize the behavior of database operations and provide more flexibility in handling SQL statements and result sets. <URL:#tn=7. Callback Mechanism: The `JdbcTemplate` class supports a callback mechanism through the use of various callback interfaces. These interfaces, such as `PreparedStatementCreator`, `PreparedStatementSetter`, `RowMapper`, and others, allow you to customize the behavior of database operations and provide more flexibility in handling SQL statements and result sets.>
        1.3.8 explain  org.springframework.beans.factory.annotation.Qualifier <URL:#tn=        1.3.8 explain  org.springframework.beans.factory.annotation.Qualifier>
1. Define Bean Qualifiers: In the application context, when defining multiple beans of the same type, you can assign a unique qualifier value using the `@Qualifier` annotation. For example: <URL:#tn=1. Define Bean Qualifiers: In the application context, when defining multiple beans of the same type, you can assign a unique qualifier value using the `@Qualifier` annotation. For example:>
2. Use `@Qualifier` for Dependency Injection: In the dependent class or component, you can use the `@Qualifier` annotation along with `@Autowired` to specify which bean should be injected. For example: <URL:#tn=2. Use `@Qualifier` for Dependency Injection: In the dependent class or component, you can use the `@Qualifier` annotation along with `@Autowired` to specify which bean should be injected. For example:>
        1.3.9 <URL:#tn=        1.3.9>
    1.4 <URL:#tn=    1.4>
2. general <URL:#tn=2. general>
    2.1. manipulate jar files. <URL:#tn=    2.1. manipulate jar files.>
    2.2. remote debug java application. <URL:#tn=    2.2. remote debug java application.>
    2.3. deploy JSP pages to web container. <URL:#tn=    2.3. deploy JSP pages to web container.>
    2.4. Tomcat <URL:#tn=    2.4. Tomcat>
	1. listen port and shutdown port are defined in server.xml. <URL:#tn=	1. listen port and shutdown port are defined in server.xml.>
    2.5.  Reverse engineer. <URL:#tn=    2.5.  Reverse engineer.>
    2.6 Set java version, toggle java versions, switch jdk versions <URL:#tn=    2.6 Set java version, toggle java versions, switch jdk versions>
        2.6.1 mac, OS X <URL:#tn=        2.6.1 mac, OS X>
    14.0.2, x86_64:	"OpenJDK 14.0.2"	/Library/Java/JavaVirtualMachines/openjdk-14.0.2.jdk/Contents/Home <URL:#tn=    14.0.2, x86_64:	"OpenJDK 14.0.2"	/Library/Java/JavaVirtualMachines/openjdk-14.0.2.jdk/Contents/Home>
    10.0.2, x86_64:	"Java SE 10.0.2"	/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home <URL:#tn=    10.0.2, x86_64:	"Java SE 10.0.2"	/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home>
    1.8.0_265, x86_64:	"AdoptOpenJDK 8"	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home <URL:#tn=    1.8.0_265, x86_64:	"AdoptOpenJDK 8"	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home>
    1.8.0_241, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home <URL:#tn=    1.8.0_241, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home>
    13.0.1, x86_64:	"OpenJDK 13.0.1"	/Library/Java/JavaVirtualMachines/openjdk-13.0.1.jdk/Contents/Home <URL:#tn=    13.0.1, x86_64:	"OpenJDK 13.0.1"	/Library/Java/JavaVirtualMachines/openjdk-13.0.1.jdk/Contents/Home>
    10.0.2, x86_64:	"Java SE 10.0.2"	/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home <URL:#tn=    10.0.2, x86_64:	"Java SE 10.0.2"	/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home>
    1.8.0_241, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home <URL:#tn=    1.8.0_241, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home>
    1.8.0_232, x86_64:	"AdoptOpenJDK 8"	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home <URL:#tn=    1.8.0_232, x86_64:	"AdoptOpenJDK 8"	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home>
    2.7 chatgpt <URL:#tn=    2.7 chatgpt>
        2.7.1 java set data structure, tags: java set data structure <URL:#tn=        2.7.1 java set data structure, tags: java set data structure>
        2.7.2  java Files  , tags: java Files <URL:#tn=        2.7.2  java Files  , tags: java Files>
        2.7.3 java Objects.requireNonNull , tags: java Objects.requireNonNull <URL:#tn=        2.7.3 java Objects.requireNonNull , tags: java Objects.requireNonNull>
        2.7.4 java File.toPath() , tags: java File.toPath() <URL:#tn=        2.7.4 java File.toPath() , tags: java File.toPath()>
        2.7.5 java use class loader to read a file that contains a sql statement and then run it on a PG DB , tags: java use class loader to read a file that contains a sql statement and then run it on a PG DB <URL:#tn=        2.7.5 java use class loader to read a file that contains a sql statement and then run it on a PG DB , tags: java use class loader to read a file that contains a sql statement and then run it on a PG DB>
        2.7.6 java org.stringtemplate.v4.ST , tags: java org.stringtemplate.v4.ST <URL:#tn=        2.7.6 java org.stringtemplate.v4.ST , tags: java org.stringtemplate.v4.ST>
        2.7.7 java StringBuilder, tags: java StringBuilder <URL:#tn=        2.7.7 java StringBuilder, tags: java StringBuilder>
        2.7.8 java jackson @JsonCreator annotation, tags: java jackson @JsonCreator annotation <URL:#tn=        2.7.8 java jackson @JsonCreator annotation, tags: java jackson @JsonCreator annotation>
        2.7.9 how to read an array property into a List<String> in a @JsonCreator annotated class constructor, tags: how to read an array property into a List<String> in a @JsonCreator annotated class constructor <URL:#tn=        2.7.9 how to read an array property into a List<String> in a @JsonCreator annotated class constructor, tags: how to read an array property into a List<String> in a @JsonCreator annotated class constructor>
        2.7.10 <URL:#tn=        2.7.10>
    2.8 <URL:#tn=    2.8>
3.  IDE, intellij <URL:#tn=3.  IDE, intellij>
    3.1   VIM plugin <URL:#tn=    3.1   VIM plugin>
    3.2   Code generation <URL:#tn=    3.2   Code generation>
        3.2.1    generate getters and setters <URL:#tn=        3.2.1    generate getters and setters>
        3.2.2 <URL:#tn=        3.2.2>
    3.3 <URL:#tn=    3.3>
4. Build java projects <URL:#tn=4. Build java projects>
    4.1 Build java projects with maven <URL:#tn=    4.1 Build java projects with maven>
        4.1.1 Build java projects with maven spring tutorial <URL:#tn=        4.1.1 Build java projects with maven spring tutorial>
        4.1.2 maven <URL:#tn=        4.1.2 maven>
            4.1.2.1 getting started <URL:#tn=            4.1.2.1 getting started>
                4.1.2.1.1  Create project <URL:#tn=                4.1.2.1.1  Create project>
                4.1.2.1.2 . Main phases <URL:#tn=                4.1.2.1.2 . Main phases>
                4.1.2.1.3 . Maven phase commands(Project Build Commands) <URL:#tn=                4.1.2.1.3 . Maven phase commands(Project Build Commands)>
                4.1.2.1.4  Skip running tests <URL:#tn=                4.1.2.1.4  Skip running tests>
                4.1.2.1.5 Project Site Generation <URL:#tn=                4.1.2.1.5 Project Site Generation>
                4.1.2.1.6 Code quality analysis <URL:#tn=                4.1.2.1.6 Code quality analysis>
                4.1.2.1.7 Code coverage reporting <URL:#tn=                4.1.2.1.7 Code coverage reporting>
                4.1.2.1.8 Dependency Management <URL:#tn=                4.1.2.1.8 Dependency Management>
                4.1.2.1.9 Getting Help <URL:#tn=                4.1.2.1.9 Getting Help>
            4.1.2.2 commonly use CLI <URL:#tn=            4.1.2.2 commonly use CLI>
            4.1.2.3 <URL:#tn=            4.1.2.3>
        4.1.3 <URL:#tn=        4.1.3>
    4.2 <URL:#tn=    4.2>
5. Java basics <URL:#tn=5. Java basics>
    5.1 <URL:#tn=    5.1>
6. JDK 5,6 <URL:#tn=6. JDK 5,6>
	6.1 Annotations <URL:#tn=	6.1 Annotations>
		6.1.1 Description <URL:#tn=		6.1.1 Description>
		6.1.2 Usage <URL:#tn=		6.1.2 Usage>
			6.1.2.1 Documentation <URL:#tn=			6.1.2.1 Documentation>
			6.1.2.2 Annotation Processing <URL:#tn=			6.1.2.2 Annotation Processing>
	6.2 Enums, enumaration <URL:#tn=	6.2 Enums, enumaration>
    6.3 Nested Classes <URL:#tn=    6.3 Nested Classes>
	6.2.1 Inner Class Example <URL:#tn=	6.2.1 Inner Class Example>
    6.4 generics <URL:#tn=    6.4 generics>
	6.4.1 Article: Using and Programming Generics in J2SE 5.0 <URL:#tn=	6.4.1 Article: Using and Programming Generics in J2SE 5.0>
   1. "? extends Type": Denotes a family of subtypes of type Type. This is the most useful wildcard <URL:#tn=   1. "? extends Type": Denotes a family of subtypes of type Type. This is the most useful wildcard>
   2. "? super Type": Denotes a family of supertypes of type Type <URL:#tn=   2. "? super Type": Denotes a family of supertypes of type Type>
   3. "?": Denotes the set of all types or any <URL:#tn=   3. "?": Denotes the set of all types or any>
7. Install <URL:#tn=7. Install>
	7.1 Linux <URL:#tn=	7.1 Linux>
	7.2 Mac. tags: install java MAC OSX <URL:#tn=	7.2 Mac. tags: install java MAC OSX>
	7.3 <URL:#tn=	7.3>
8. Code Snipplets <URL:#tn=8. Code Snipplets>
	8.1 Encoding, utf-8, utf-16 <URL:#tn=	8.1 Encoding, utf-8, utf-16>
	8.2 <URL:#tn=	8.2>
9. Cookbook <URL:#tn=9. Cookbook>
	9.1  Files <URL:#tn=	9.1  Files>
		9.1.1   read file content java <URL:#tn=		9.1.1   read file content java>
			9.1.1.1   Reading and writing text files <URL:#tn=			9.1.1.1   Reading and writing text files>
			9.1.1.2 BufferedReader <URL:#tn=			9.1.1.2 BufferedReader>
			9.1.1.3 <URL:#tn=			9.1.1.3>
		9.1.2 Edit files <URL:#tn=		9.1.2 Edit files>
			9.1.2.1 Java – Edit File Example, Modify File java <URL:#tn=			9.1.2.1 Java – Edit File Example, Modify File java>
			9.1.2.2 <URL:#tn=			9.1.2.2>
		9.1.3 <URL:#tn=		9.1.3>
	9.2 <URL:#tn=	9.2>
10. IDEs <URL:#tn=10. IDEs>
	10.1 Eclipse <URL:#tn=	10.1 Eclipse>
		10.1.1 Quick references <URL:#tn=		10.1.1 Quick references>
			10.1.1.1 official <URL:#tn=			10.1.1.1 official>
			10.1.1.2 <URL:#tn=			10.1.1.2>
		10.1.2 FAQ <URL:#tn=		10.1.2 FAQ>
			10.1.2.1 error log <URL:#tn=			10.1.2.1 error log>
			10.1.2.2 java.lang.UnsatisfiedLinkError: Cannot load 32-bit SWT libraries on 64-bit JVM <URL:#tn=			10.1.2.2 java.lang.UnsatisfiedLinkError: Cannot load 32-bit SWT libraries on 64-bit JVM>
			10.1.2.3 <URL:#tn=			10.1.2.3>
		10.1.3 <URL:#tn=		10.1.3>
	10.2 <URL:#tn=	10.2>
11. Server side programming <URL:#tn=11. Server side programming>
	11.1 Servlet <URL:#tn=	11.1 Servlet>
		11.1.1 Basic example & walkthrough <URL:#tn=		11.1.1 Basic example & walkthrough>
			11.1.1.1 Eclipse <URL:#tn=			11.1.1.1 Eclipse>
			11.1.1.2 <URL:#tn=			11.1.1.2>
		11.1.2 <URL:#tn=		11.1.2>
	11.2 <URL:#tn=	11.2>
12. My snippets, examples, demos <URL:#tn=12. My snippets, examples, demos>
    12.1 Performance tests <URL:#tn=    12.1 Performance tests>
        12.1.1 HashMap vs array contains <URL:#tn=        12.1.1 HashMap vs array contains>
        12.1.2 <URL:#tn=        12.1.2>
    12.2 <URL:#tn=    12.2>
13.  Memory Management <URL:#tn=13.  Memory Management>
    13.1  memsize equivalent - How to Get the Size of an Object <URL:#tn=    13.1  memsize equivalent - How to Get the Size of an Object>
        13.1.1  https://www.baeldung.com/java-size-of-object <URL:#tn=        13.1.1  https://www.baeldung.com/java-size-of-object>
2. Memory Consumption in Java <URL:#tn=2. Memory Consumption in Java>
3.2. Example Class <URL:#tn=3.2. Example Class>
        13.1.2 <URL:#tn=        13.1.2>
    13.2 <URL:#tn=    13.2>
14. Java versions main features and tools, tags: Java versions main features and tools, tags: versions main features and tools <URL:#tn=14. Java versions main features and tools, tags: Java versions main features and tools, tags: versions main features and tools>
    14.1   Java version 1 <URL:#tn=    14.1   Java version 1>
    14.2   Java version 2 <URL:#tn=    14.2   Java version 2>
    14.3   Java version 3 <URL:#tn=    14.3   Java version 3>
    14.4   Java version 4 <URL:#tn=    14.4   Java version 4>
    14.5   Java version 5 <URL:#tn=    14.5   Java version 5>
    14.6   Java version 6 <URL:#tn=    14.6   Java version 6>
    14.7   Java version 7 <URL:#tn=    14.7   Java version 7>
    14.8   Java version 8 <URL:#tn=    14.8   Java version 8>
        14.8.1    functional interfaces, tags: functional interfaces <URL:#tn=        14.8.1    functional interfaces, tags: functional interfaces>
          14.8.1.1    chatgpt, lambda expressions and functional interfaces <URL:#tn=          14.8.1.1    chatgpt, lambda expressions and functional interfaces>
        14.8.2 forEach <URL:#tn=        14.8.2 forEach>
        14.8.3 optional class , tags: optional class <URL:#tn=        14.8.3 optional class , tags: optional class>
        14.8.4 Default And Static Methods In Interfaces, tags: Default And Static Methods In Interfaces <URL:#tn=        14.8.4 Default And Static Methods In Interfaces, tags: Default And Static Methods In Interfaces>
        14.8.4 Java Stream API For Bulk Data Operations On Collections , tags: Java Stream API For Bulk Data Operations On Collections <URL:#tn=        14.8.4 Java Stream API For Bulk Data Operations On Collections , tags: Java Stream API For Bulk Data Operations On Collections>
        14.8.5 java data time API usage, tags: java data time API usage <URL:#tn=        14.8.5 java data time API usage, tags: java data time API usage>
            14.8.5.1 gpt <URL:#tn=            14.8.5.1 gpt>
            14.8.5.2 my demo <URL:#tn=            14.8.5.2 my demo>
            14.8.5.3 <URL:#tn=            14.8.5.3>
        14.8.6 Collection API Improvements, tags: Collection API Improvements <URL:#tn=        14.8.6 Collection API Improvements, tags: Collection API Improvements>
        14.8.7 Java IO Improvements <URL:#tn=        14.8.7 Java IO Improvements>
        14.8.8 Miscellaneous Core API Improvements <URL:#tn=        14.8.8 Miscellaneous Core API Improvements>
        14.8.9 Base64 Encode Decode <URL:#tn=        14.8.9 Base64 Encode Decode>
            14.8.9.1 GTP example <URL:#tn=            14.8.9.1 GTP example>
            14.8.9.2 my demo <URL:#tn=            14.8.9.2 my demo>
            14.8.9.3 <URL:#tn=            14.8.9.3>
        14.8.10 <URL:#tn=        14.8.10>
    14.10  Java version 9, tags: Java version 9 <URL:#tn=    14.10  Java version 9, tags: Java version 9>
        14.10.1  summary 9-17 <URL:#tn=        14.10.1  summary 9-17>
            14.10.1.1   other <URL:#tn=            14.10.1.1   other>
        14.10.1  REPL, jshell, tags: REPL, jshell <URL:#tn=        14.10.1  REPL, jshell, tags: REPL, jshell>
        14.10.2 Factory Methods for Immutable List, Set, Map and Map.Entry, tags: Factory Methods for Immutable List <URL:#tn=        14.10.2 Factory Methods for Immutable List, Set, Map and Map.Entry, tags: Factory Methods for Immutable List>
        14.10.3 Private methods in Interfaces <URL:#tn=        14.10.3 Private methods in Interfaces>
        14.10.4 Java 9 Module System <URL:#tn=        14.10.4 Java 9 Module System>
            14.10.4.1 GPT explanation <URL:#tn=            14.10.4.1 GPT explanation>
            14.10.4.2 https://www.baeldung.com/java-9-modularity <URL:#tn=            14.10.4.2 https://www.baeldung.com/java-9-modularity>
                14.10.4.2.1 Packages <URL:#tn=                14.10.4.2.1 Packages>
                14.10.4.2.2 resources <URL:#tn=                14.10.4.2.2 resources>
                14.10.4.2.3 Module Descriptor <URL:#tn=                14.10.4.2.3 Module Descriptor>
                14.10.4.2.4 java list-modules command <URL:#tn=                14.10.4.2.4 java list-modules command>
                14.10.4.2.5 Module Types <URL:#tn=                14.10.4.2.5 Module Types>
                14.10.4.2.6 Distribution <URL:#tn=                14.10.4.2.6 Distribution>
                14.10.4.2.7 Default Modules <URL:#tn=                14.10.4.2.7 Default Modules>
                14.10.4.2.8 Module Declarations <URL:#tn=                14.10.4.2.8 Module Declarations>
                    14.10.4.2.8.1 Requires <URL:#tn=                    14.10.4.2.8.1 Requires>
                    14.10.4.2.8.2 Requires Static <URL:#tn=                    14.10.4.2.8.2 Requires Static>
                    14.10.4.2.8.3 Requires Transitive <URL:#tn=                    14.10.4.2.8.3 Requires Transitive>
                    14.10.4.2.8.4 Exports <URL:#tn=                    14.10.4.2.8.4 Exports>
                    14.10.4.2.8.5 Exports … To <URL:#tn=                    14.10.4.2.8.5 Exports … To>
                    14.10.4.2.8.6 Uses <URL:#tn=                    14.10.4.2.8.6 Uses>
                    14.10.4.2.8.7 Provides … With <URL:#tn=                    14.10.4.2.8.7 Provides … With>
                    14.10.4.2.8.8 Open <URL:#tn=                    14.10.4.2.8.8 Open>
                    14.10.4.2.8.9 Opens <URL:#tn=                    14.10.4.2.8.9 Opens>
                    14.10.4.2.8.10 Opens … To <URL:#tn=                    14.10.4.2.8.10 Opens … To>
                    14.10.4.2.8.11 <URL:#tn=                    14.10.4.2.8.11>
                14.10.4.2.9 Command Line Options <URL:#tn=                14.10.4.2.9 Command Line Options>
                14.10.4.2.10 Visibility <URL:#tn=                14.10.4.2.10 Visibility>
                14.10.4.2.11 Putting It All Together - java modules demo, tags: Putting It All Together - java modules demo <URL:#tn=                14.10.4.2.11 Putting It All Together - java modules demo, tags: Putting It All Together - java modules demo>
                    14.10.4.2.11.1 directory structure <URL:#tn=                    14.10.4.2.11.1 directory structure>
                    14.10.4.2.11.2 first module <URL:#tn=                    14.10.4.2.11.2 first module>
                    14.10.4.2.11.3 second module <URL:#tn=                    14.10.4.2.11.3 second module>
                    14.10.4.2.11.4 build <URL:#tn=                    14.10.4.2.11.4 build>
                    14.10.4.2.11.5 Run <URL:#tn=                    14.10.4.2.11.5 Run>
                    14.10.4.2.11.6 Adding a Service <URL:#tn=                    14.10.4.2.11.6 Adding a Service>
                14.10.4.2.12 Final demo structure and code <URL:#tn=                14.10.4.2.12 Final demo structure and code>
                14.10.4.2.13 Adding Modules to the Unnamed Module <URL:#tn=                14.10.4.2.13 Adding Modules to the Unnamed Module>
                14.10.4.2.14 <URL:#tn=                14.10.4.2.14>
            14.10.4.3 <URL:#tn=            14.10.4.3>
            14.10.4.4 <URL:#tn=            14.10.4.4>
        14.10.5 Process API Improvements <URL:#tn=        14.10.5 Process API Improvements>
            14.10.5.1  chatgpt <URL:#tn=            14.10.5.1  chatgpt>
            14.10.5.2 demo <URL:#tn=            14.10.5.2 demo>
            14.10.5.3  try-with-resources statement <URL:#tn=            14.10.5.3  try-with-resources statement>
                14.10.5.3.1   explanation <URL:#tn=                14.10.5.3.1   explanation>
                14.10.5.3.2 demo <URL:#tn=                14.10.5.3.2 demo>
                14.10.5.3.3 <URL:#tn=                14.10.5.3.3>
        14.10.6 CompletableFuture API Improvements in java 9 <URL:#tn=        14.10.6 CompletableFuture API Improvements in java 9>
            14.10.6.1  GPT <URL:#tn=            14.10.6.1  GPT>
            14.10.6.2 GTP demo <URL:#tn=            14.10.6.2 GTP demo>
            14.10.6.3 my demo <URL:#tn=            14.10.6.3 my demo>
            14.10.6.4 <URL:#tn=            14.10.6.4>
        14.10.7 java 9 reactive streams <URL:#tn=        14.10.7 java 9 reactive streams>
            14.10.7.1 https://www.baeldung.com/java-9-reactive-streams <URL:#tn=            14.10.7.1 https://www.baeldung.com/java-9-reactive-streams>
                14.10.7.1.1 Overview <URL:#tn=                14.10.7.1.1 Overview>
                14.10.7.1.2 Reactive API Overview <URL:#tn=                14.10.7.1.2 Reactive API Overview>
                14.10.7.1.3 Publishing and Consuming Messages <URL:#tn=                14.10.7.1.3 Publishing and Consuming Messages>
                14.10.7.1.4 <URL:#tn=                14.10.7.1.4>
            14.10.7.2 chatgpt <URL:#tn=            14.10.7.2 chatgpt>
            14.10.7.3 <URL:#tn=            14.10.7.3>
        14.10.8 Diamond Operator for Anonymous Inner Class <URL:#tn=        14.10.8 Diamond Operator for Anonymous Inner Class>
        14.10.9 Optional Class Improvements <URL:#tn=        14.10.9 Optional Class Improvements>
        14.10.10 Stream API Improvements <URL:#tn=        14.10.10 Stream API Improvements>
        14.10.11 Enhanced @Deprecated annotation <URL:#tn=        14.10.11 Enhanced @Deprecated annotation>
        14.10.12 HTTP 2 Client <URL:#tn=        14.10.12 HTTP 2 Client>
        14.10.13 Multi-Resolution Image API <URL:#tn=        14.10.13 Multi-Resolution Image API>
        14.10.14 Miscellaneous Java 9 Features <URL:#tn=        14.10.14 Miscellaneous Java 9 Features>
        14.10.15 <URL:#tn=        14.10.15>
    14.11  Java version 10, tags: Java version 10 <URL:#tn=    14.11  Java version 10, tags: Java version 10>
        14.11.1   https://javagoal.com/java-10-features/ <URL:#tn=        14.11.1   https://javagoal.com/java-10-features/>
            14.11.1.1   Java 10 Features <URL:#tn=            14.11.1.1   Java 10 Features>
            14.11.1.2 Local Variable Type Inference <URL:#tn=            14.11.1.2 Local Variable Type Inference>
            14.11.1.3 <URL:#tn=            14.11.1.3>
        14.11.2 <URL:#tn=        14.11.2>
    14.11  Java version 11 <URL:#tn=    14.11  Java version 11>
    14.12  Java version 12 <URL:#tn=    14.12  Java version 12>
    14.13  Java version 13 <URL:#tn=    14.13  Java version 13>
    14.14  Java version 14 <URL:#tn=    14.14  Java version 14>
    14.15  Java version 15 <URL:#tn=    14.15  Java version 15>
    14.16  Java version 16 <URL:#tn=    14.16  Java version 16>
    14.17  Java version 17 <URL:#tn=    14.17  Java version 17>
        14.17.1  Java 17 vs Java 8 <URL:#tn=        14.17.1  Java 17 vs Java 8>
            14.17.1.1  https://pretius.com/blog/java-17-features/ <URL:#tn=            14.17.1.1  https://pretius.com/blog/java-17-features/>
            14.17.1.2 <URL:#tn=            14.17.1.2>
        14.17.2 <URL:#tn=        14.17.2>
    14.18  Java version 18 <URL:#tn=    14.18  Java version 18>
    14.19  Java version 19 <URL:#tn=    14.19  Java version 19>
    14.20  Java version 20 <URL:#tn=    14.20  Java version 20>
    14.21  Java version 21 <URL:#tn=    14.21  Java version 21>
    14.22  Java version 22 <URL:#tn=    14.22  Java version 22>
    14.23  Java version 23 <URL:#tn=    14.23  Java version 23>
    14.24  Java version 24 <URL:#tn=    14.24  Java version 24>
    14.25  Java version 25 <URL:#tn=    14.25  Java version 25>
    14.26  Java version 26 <URL:#tn=    14.26  Java version 26>
    14.27  Java version 27 <URL:#tn=    14.27  Java version 27>
    14.28  Java version 28 <URL:#tn=    14.28  Java version 28>
    14.29  Java version 29 <URL:#tn=    14.29  Java version 29>
    14.30  Java version 30 <URL:#tn=    14.30  Java version 30>
    14.31  Java version 31 <URL:#tn=    14.31  Java version 31>
    14.32  Java version 32 <URL:#tn=    14.32  Java version 32>
    14.33  Java version 33 <URL:#tn=    14.33  Java version 33>
    14.34  Java version 34 <URL:#tn=    14.34  Java version 34>
    14.35  Java version 35 <URL:#tn=    14.35  Java version 35>
    14.36  Java version 36 <URL:#tn=    14.36  Java version 36>
    14.37  Java version 37 <URL:#tn=    14.37  Java version 37>
    14.38  Java version 38 <URL:#tn=    14.38  Java version 38>
    14.39  Java version 39 <URL:#tn=    14.39  Java version 39>
    14.40  Java version 40 <URL:#tn=    14.40  Java version 40>
    14.41  Java version 41 <URL:#tn=    14.41  Java version 41>
15. multithreading, tags: multithreading <URL:#tn=15. multithreading, tags: multithreading>
    15.1 Multithreading in java , threading, threads, parallelization, concurrency , tags: Multithreading in java , threading, threads, parallelization, concurrency <URL:#tn=    15.1 Multithreading in java , threading, threads, parallelization, concurrency , tags: Multithreading in java , threading, threads, parallelization, concurrency>
        15.1.1 https://www.geeksforgeeks.org/java-multithreading-tutorial/ <URL:#tn=        15.1.1 https://www.geeksforgeeks.org/java-multithreading-tutorial/>
            15.1.1.1 Using Thread Class <URL:#tn=            15.1.1.1 Using Thread Class>
            15.1.1.2 Using Runnable Interface <URL:#tn=            15.1.1.2 Using Runnable Interface>
            15.1.1.3 Thread methods <URL:#tn=            15.1.1.3 Thread methods>
                15.1.1.3.1  Sleep <URL:#tn=                15.1.1.3.1  Sleep>
                15.1.1.3.2 start <URL:#tn=                15.1.1.3.2 start>
                15.1.1.3.3 suspend <URL:#tn=                15.1.1.3.3 suspend>
                15.1.1.3.4 stop <URL:#tn=                15.1.1.3.4 stop>
                15.1.1.3.5 wait() <URL:#tn=                15.1.1.3.5 wait()>
                15.1.1.3.6 notify, notifyAll <URL:#tn=                15.1.1.3.6 notify, notifyAll>
                15.1.1.3.7 <URL:#tn=                15.1.1.3.7>
            15.1.1.4 Priorities in threads, , tags: Priorities in threads <URL:#tn=            15.1.1.4 Priorities in threads, , tags: Priorities in threads>
            15.1.1.5 daemon threads <URL:#tn=            15.1.1.5 daemon threads>
            15.1.1.6 <URL:#tn=            15.1.1.6>
        15.1.2 Thread lifecycle and state-machine <URL:#tn=        15.1.2 Thread lifecycle and state-machine>
        15.1.3 <URL:#tn=        15.1.3>
    15.2 <URL:#tn=    15.2>
16. jackson <URL:#tn=16. jackson>
    16.1 highlevel overview <URL:#tn=    16.1 highlevel overview>
    16.2 ObjectMapper <URL:#tn=    16.2 ObjectMapper>
        16.2.1 valueToTree <URL:#tn=        16.2.1 valueToTree>
        16.2.2 JsonNode traversal <URL:#tn=        16.2.2 JsonNode traversal>
        16.2.3 DFS traversal of JsonNode <URL:#tn=        16.2.3 DFS traversal of JsonNode>
        16.2.4 jackson stdSerialize <URL:#tn=        16.2.4 jackson stdSerialize>
            16.2.4.1 GPT <URL:#tn=            16.2.4.1 GPT>
1. **`serialize` Method:** <URL:#tn=1. **`serialize` Method:**>
2. **`handledType` Method:** <URL:#tn=2. **`handledType` Method:**>
3. **`serializeWithType` Method:** <URL:#tn=3. **`serializeWithType` Method:**>
            16.2.4.2 <URL:#tn=            16.2.4.2>
        16.2.5 <URL:#tn=        16.2.5>
    16.3 <URL:#tn=    16.3>
17. java collections, tags:  java collections <URL:#tn=17. java collections, tags:  java collections>
    17.1 java Collections.singletonList <URL:#tn=    17.1 java Collections.singletonList>
    17.2 <URL:#tn=    17.2>
18.  chatgpt, <URL:#tn=18.  chatgpt,>
        1.1.2 Key concepts / files <URL:#tn=        1.1.2 Key concepts / files> <URL:#tn=        1.1.2 Key concepts / files <URL:#tn=        1.1.2 Key concepts / files>>
            1.1.2.1 dependency Injection <URL:#tn=            1.1.2.1 dependency Injection> <URL:#tn=            1.1.2.1 dependency Injection <URL:#tn=            1.1.2.1 dependency Injection>>
            1.1.2.2 Spring configuration file, usually spring.xml <URL:#tn=            1.1.2.2 Spring configuration file, usually spring.xml> <URL:#tn=            1.1.2.2 Spring configuration file, usually spring.xml <URL:#tn=            1.1.2.2 Spring configuration file, usually spring.xml>>
            1.1.2.3 main application <URL:#tn=            1.1.2.3 main application> <URL:#tn=            1.1.2.3 main application <URL:#tn=            1.1.2.3 main application>>
                1.1.2.3.1 example of BeanFactory, ApplicationContext, AbstractApplicationContext, getting beans and wiring to HTTP requests <URL:#tn=                1.1.2.3.1 example of BeanFactory, ApplicationContext, AbstractApplicationContext, getting beans and wiring to HTTP requests> <URL:#tn=                1.1.2.3.1 example of BeanFactory, ApplicationContext, AbstractApplicationContext, getting beans and wiring to HTTP requests <URL:#tn=                1.1.2.3.1 example of BeanFactory, ApplicationContext, AbstractApplicationContext, getting beans and wiring to HTTP requests>>
                1.1.2.3.2 <URL:#tn=                1.1.2.3.2> <URL:#tn=                1.1.2.3.2 <URL:#tn=                1.1.2.3.2>>
            1.1.2.4 beans <URL:#tn=            1.1.2.4 beans> <URL:#tn=            1.1.2.4 beans <URL:#tn=            1.1.2.4 beans>>
                1.1.2.4.1 example, simple bean <URL:#tn=                1.1.2.4.1 example, simple bean> <URL:#tn=                1.1.2.4.1 example, simple bean <URL:#tn=                1.1.2.4.1 example, simple bean>>
                1.1.2.4.2 Bean that is ApplicationContext and name aware , also has init and cleanup callbacks <URL:#tn=                1.1.2.4.2 Bean that is ApplicationContext and name aware , also has init and cleanup callbacks> <URL:#tn=                1.1.2.4.2 Bean that is ApplicationContext and name aware , also has init and cleanup callbacks <URL:#tn=                1.1.2.4.2 Bean that is ApplicationContext and name aware , also has init and cleanup callbacks>>
                1.1.2.4.3 Bean that is InitializingBean and DisposableBean, also contains a container member field <URL:#tn=                1.1.2.4.3 Bean that is InitializingBean and DisposableBean, also contains a container member field> <URL:#tn=                1.1.2.4.3 Bean that is InitializingBean and DisposableBean, also contains a container member field <URL:#tn=                1.1.2.4.3 Bean that is InitializingBean and DisposableBean, also contains a container member field>>
                1.1.2.4.4 BeanPostProcessor <URL:#tn=                1.1.2.4.4 BeanPostProcessor> <URL:#tn=                1.1.2.4.4 BeanPostProcessor <URL:#tn=                1.1.2.4.4 BeanPostProcessor>>
                1.1.2.4.5 code to interface example <URL:#tn=                1.1.2.4.5 code to interface example> <URL:#tn=                1.1.2.4.5 code to interface example <URL:#tn=                1.1.2.4.5 code to interface example>>
                    1.1.2.4.5.1  animal interface <URL:#tn=                    1.1.2.4.5.1  animal interface> <URL:#tn=                    1.1.2.4.5.1  animal interface <URL:#tn=                    1.1.2.4.5.1  animal interface>>
                    1.1.2.4.5.2 animals: cat, dog, horse <URL:#tn=                    1.1.2.4.5.2 animals: cat, dog, horse> <URL:#tn=                    1.1.2.4.5.2 animals: cat, dog, horse <URL:#tn=                    1.1.2.4.5.2 animals: cat, dog, horse>>
                1.1.2.4.6 Internationalization and application resources <URL:#tn=                1.1.2.4.6 Internationalization and application resources> <URL:#tn=                1.1.2.4.6 Internationalization and application resources <URL:#tn=                1.1.2.4.6 Internationalization and application resources>>
                1.1.2.4.7 Events <URL:#tn=                1.1.2.4.7 Events> <URL:#tn=                1.1.2.4.7 Events <URL:#tn=                1.1.2.4.7 Events>>
                    1.1.2.4.7.1 GeneralEvtListener <URL:#tn=                    1.1.2.4.7.1 GeneralEvtListener> <URL:#tn=                    1.1.2.4.7.1 GeneralEvtListener <URL:#tn=                    1.1.2.4.7.1 GeneralEvtListener>>
                    1.1.2.4.7.2 ToStringEvt <URL:#tn=                    1.1.2.4.7.2 ToStringEvt> <URL:#tn=                    1.1.2.4.7.2 ToStringEvt <URL:#tn=                    1.1.2.4.7.2 ToStringEvt>>
                    1.1.2.4.7.3 publish custom events <URL:#tn=                    1.1.2.4.7.3 publish custom events> <URL:#tn=                    1.1.2.4.7.3 publish custom events <URL:#tn=                    1.1.2.4.7.3 publish custom events>>
                    1.1.2.4.7.4 <URL:#tn=                    1.1.2.4.7.4> <URL:#tn=                    1.1.2.4.7.4 <URL:#tn=                    1.1.2.4.7.4>>
                1.1.2.4.8 <URL:#tn=                1.1.2.4.8> <URL:#tn=                1.1.2.4.8 <URL:#tn=                1.1.2.4.8>>
            1.1.2.5 <URL:#tn=            1.1.2.5> <URL:#tn=            1.1.2.5 <URL:#tn=            1.1.2.5>>
        1.1.3 <URL:#tn=        1.1.3> <URL:#tn=        1.1.3 <URL:#tn=        1.1.3>>
    1.2 database <URL:#tn=    1.2 database> <URL:#tn=    1.2 database <URL:#tn=    1.2 database>>
        1.2.1  database connections <URL:#tn=        1.2.1  database connections> <URL:#tn=        1.2.1  database connections <URL:#tn=        1.2.1  database connections>>
            1.2.1.1    database connections pools <URL:#tn=            1.2.1.1    database connections pools> <URL:#tn=            1.2.1.1    database connections pools <URL:#tn=            1.2.1.1    database connections pools>>
                1.2.1.1.1    Apache Commons DBCP <URL:#tn=                1.2.1.1.1    Apache Commons DBCP> <URL:#tn=                1.2.1.1.1    Apache Commons DBCP <URL:#tn=                1.2.1.1.1    Apache Commons DBCP>>
                1.2.1.1.2 HikariCP <URL:#tn=                1.2.1.1.2 HikariCP> <URL:#tn=                1.2.1.1.2 HikariCP <URL:#tn=                1.2.1.1.2 HikariCP>>
                1.2.1.1.3 C3PO <URL:#tn=                1.2.1.1.3 C3PO> <URL:#tn=                1.2.1.1.3 C3PO <URL:#tn=                1.2.1.1.3 C3PO>>
                1.2.1.1.4 A Simple Implementation <URL:#tn=                1.2.1.1.4 A Simple Implementation> <URL:#tn=                1.2.1.1.4 A Simple Implementation <URL:#tn=                1.2.1.1.4 A Simple Implementation>>
            1.2.1.2 <URL:#tn=            1.2.1.2> <URL:#tn=            1.2.1.2 <URL:#tn=            1.2.1.2>>
        1.2.2 <URL:#tn=        1.2.2> <URL:#tn=        1.2.2 <URL:#tn=        1.2.2>>
    1.3 chatgpt <URL:#tn=    1.3 chatgpt> <URL:#tn=    1.3 chatgpt <URL:#tn=    1.3 chatgpt>>
        1.3.1  q. what is spring-boot-starter-webflux <URL:#tn=        1.3.1  q. what is spring-boot-starter-webflux> <URL:#tn=        1.3.1  q. what is spring-boot-starter-webflux <URL:#tn=        1.3.1  q. what is spring-boot-starter-webflux>>
        1.3.2 q. explain the basics of setting up a reactive web application using <URL:#tn=        1.3.2 q. explain the basics of setting up a reactive web application using> <URL:#tn=        1.3.2 q. explain the basics of setting up a reactive web application using <URL:#tn=        1.3.2 q. explain the basics of setting up a reactive web application using>>
        1.3.3 q. example using maven and postgress DB <URL:#tn=        1.3.3 q. example using maven and postgress DB> <URL:#tn=        1.3.3 q. example using maven and postgress DB <URL:#tn=        1.3.3 q. example using maven and postgress DB>>
        1.3.4 use JDBC instead of JPA <URL:#tn=        1.3.4 use JDBC instead of JPA> <URL:#tn=        1.3.4 use JDBC instead of JPA <URL:#tn=        1.3.4 use JDBC instead of JPA>>
        1.3.5 explain java org.springframework.context.annotation.Profile <URL:#tn=        1.3.5 explain java org.springframework.context.annotation.Profile> <URL:#tn=        1.3.5 explain java org.springframework.context.annotation.Profile <URL:#tn=        1.3.5 explain java org.springframework.context.annotation.Profile>>
1. Defining Profiles: Profiles are defined using the `@Profile` annotation at the class or method level. You can assign one or more profile names to the annotation. For example: <URL:#tn=1. Defining Profiles: Profiles are defined using the `@Profile` annotation at the class or method level. You can assign one or more profile names to the annotation. For example:> <URL:#tn=1. Defining Profiles: Profiles are defined using the `@Profile` annotation at the class or method level. You can assign one or more profile names to the annotation. For example: <URL:#tn=1. Defining Profiles: Profiles are defined using the `@Profile` annotation at the class or method level. You can assign one or more profile names to the annotation. For example:>>
2. Activating Profiles: Profiles can be activated in various ways, depending on your application's setup. Here are a few common methods: <URL:#tn=2. Activating Profiles: Profiles can be activated in various ways, depending on your application's setup. Here are a few common methods:> <URL:#tn=2. Activating Profiles: Profiles can be activated in various ways, depending on your application's setup. Here are a few common methods: <URL:#tn=2. Activating Profiles: Profiles can be activated in various ways, depending on your application's setup. Here are a few common methods:>>
3. Conditional Bean Creation: The `@Profile` annotation can also be used to conditionally create beans based on profiles. By annotating a bean definition or `@Configuration` class with `@Profile`, the bean(s) will only be created when the specified profile is active. For example: <URL:#tn=3. Conditional Bean Creation: The `@Profile` annotation can also be used to conditionally create beans based on profiles. By annotating a bean definition or `@Configuration` class with `@Profile`, the bean(s) will only be created when the specified profile is active. For example:> <URL:#tn=3. Conditional Bean Creation: The `@Profile` annotation can also be used to conditionally create beans based on profiles. By annotating a bean definition or `@Configuration` class with `@Profile`, the bean(s) will only be created when the specified profile is active. For example: <URL:#tn=3. Conditional Bean Creation: The `@Profile` annotation can also be used to conditionally create beans based on profiles. By annotating a bean definition or `@Configuration` class with `@Profile`, the bean(s) will only be created when the specified profile is active. For example:>>
        1.3.6 is there a spring framework DataSource class or interface <URL:#tn=        1.3.6 is there a spring framework DataSource class or interface> <URL:#tn=        1.3.6 is there a spring framework DataSource class or interface <URL:#tn=        1.3.6 is there a spring framework DataSource class or interface>>
        1.3.7 explain org.springframework.jdbc.core.JdbcTemplate <URL:#tn=        1.3.7 explain org.springframework.jdbc.core.JdbcTemplate> <URL:#tn=        1.3.7 explain org.springframework.jdbc.core.JdbcTemplate <URL:#tn=        1.3.7 explain org.springframework.jdbc.core.JdbcTemplate>>
1. Database Operations: The `JdbcTemplate` class provides methods for executing various types of SQL operations, such as updates, inserts, deletes, and selects. These methods handle all the necessary details, including acquiring and releasing database connections, executing SQL statements, binding parameters, and processing result sets. <URL:#tn=1. Database Operations: The `JdbcTemplate` class provides methods for executing various types of SQL operations, such as updates, inserts, deletes, and selects. These methods handle all the necessary details, including acquiring and releasing database connections, executing SQL statements, binding parameters, and processing result sets.> <URL:#tn=1. Database Operations: The `JdbcTemplate` class provides methods for executing various types of SQL operations, such as updates, inserts, deletes, and selects. These methods handle all the necessary details, including acquiring and releasing database connections, executing SQL statements, binding parameters, and processing result sets. <URL:#tn=1. Database Operations: The `JdbcTemplate` class provides methods for executing various types of SQL operations, such as updates, inserts, deletes, and selects. These methods handle all the necessary details, including acquiring and releasing database connections, executing SQL statements, binding parameters, and processing result sets.>>
2. Exception Handling: The `JdbcTemplate` class handles SQLExceptions that occur during database operations and wraps them in more meaningful and standardized Spring exceptions, such as `DataAccessException`. This simplifies error handling and allows for consistent exception handling across different database operations. <URL:#tn=2. Exception Handling: The `JdbcTemplate` class handles SQLExceptions that occur during database operations and wraps them in more meaningful and standardized Spring exceptions, such as `DataAccessException`. This simplifies error handling and allows for consistent exception handling across different database operations.> <URL:#tn=2. Exception Handling: The `JdbcTemplate` class handles SQLExceptions that occur during database operations and wraps them in more meaningful and standardized Spring exceptions, such as `DataAccessException`. This simplifies error handling and allows for consistent exception handling across different database operations. <URL:#tn=2. Exception Handling: The `JdbcTemplate` class handles SQLExceptions that occur during database operations and wraps them in more meaningful and standardized Spring exceptions, such as `DataAccessException`. This simplifies error handling and allows for consistent exception handling across different database operations.>>
3. PreparedStatement Creation: The `JdbcTemplate` class can create `PreparedStatement` objects for executing SQL statements with bound parameters. It automatically handles the preparation of the statement and sets the appropriate parameter values based on the provided arguments. <URL:#tn=3. PreparedStatement Creation: The `JdbcTemplate` class can create `PreparedStatement` objects for executing SQL statements with bound parameters. It automatically handles the preparation of the statement and sets the appropriate parameter values based on the provided arguments.> <URL:#tn=3. PreparedStatement Creation: The `JdbcTemplate` class can create `PreparedStatement` objects for executing SQL statements with bound parameters. It automatically handles the preparation of the statement and sets the appropriate parameter values based on the provided arguments. <URL:#tn=3. PreparedStatement Creation: The `JdbcTemplate` class can create `PreparedStatement` objects for executing SQL statements with bound parameters. It automatically handles the preparation of the statement and sets the appropriate parameter values based on the provided arguments.>>
4. ResultSet Processing: The `JdbcTemplate` class provides methods for processing `ResultSet` objects returned from SELECT queries. It simplifies the process of iterating over the result set, extracting data, and mapping it to Java objects or data structures. <URL:#tn=4. ResultSet Processing: The `JdbcTemplate` class provides methods for processing `ResultSet` objects returned from SELECT queries. It simplifies the process of iterating over the result set, extracting data, and mapping it to Java objects or data structures.> <URL:#tn=4. ResultSet Processing: The `JdbcTemplate` class provides methods for processing `ResultSet` objects returned from SELECT queries. It simplifies the process of iterating over the result set, extracting data, and mapping it to Java objects or data structures. <URL:#tn=4. ResultSet Processing: The `JdbcTemplate` class provides methods for processing `ResultSet` objects returned from SELECT queries. It simplifies the process of iterating over the result set, extracting data, and mapping it to Java objects or data structures.>>
5. Batch Updates: The `JdbcTemplate` class supports batch updates, allowing you to execute multiple SQL statements as a single batch. This can significantly improve performance when dealing with multiple database operations. <URL:#tn=5. Batch Updates: The `JdbcTemplate` class supports batch updates, allowing you to execute multiple SQL statements as a single batch. This can significantly improve performance when dealing with multiple database operations.> <URL:#tn=5. Batch Updates: The `JdbcTemplate` class supports batch updates, allowing you to execute multiple SQL statements as a single batch. This can significantly improve performance when dealing with multiple database operations. <URL:#tn=5. Batch Updates: The `JdbcTemplate` class supports batch updates, allowing you to execute multiple SQL statements as a single batch. This can significantly improve performance when dealing with multiple database operations.>>
6. Exception Translation: The `JdbcTemplate` class integrates with Spring's `SQLExceptionTranslator` mechanism, which translates database-specific SQL exceptions into Spring's standardized `DataAccessException` hierarchy. This helps to abstract away the database-specific exception handling and provides a consistent exception model. <URL:#tn=6. Exception Translation: The `JdbcTemplate` class integrates with Spring's `SQLExceptionTranslator` mechanism, which translates database-specific SQL exceptions into Spring's standardized `DataAccessException` hierarchy. This helps to abstract away the database-specific exception handling and provides a consistent exception model.> <URL:#tn=6. Exception Translation: The `JdbcTemplate` class integrates with Spring's `SQLExceptionTranslator` mechanism, which translates database-specific SQL exceptions into Spring's standardized `DataAccessException` hierarchy. This helps to abstract away the database-specific exception handling and provides a consistent exception model. <URL:#tn=6. Exception Translation: The `JdbcTemplate` class integrates with Spring's `SQLExceptionTranslator` mechanism, which translates database-specific SQL exceptions into Spring's standardized `DataAccessException` hierarchy. This helps to abstract away the database-specific exception handling and provides a consistent exception model.>>
7. Callback Mechanism: The `JdbcTemplate` class supports a callback mechanism through the use of various callback interfaces. These interfaces, such as `PreparedStatementCreator`, `PreparedStatementSetter`, `RowMapper`, and others, allow you to customize the behavior of database operations and provide more flexibility in handling SQL statements and result sets. <URL:#tn=7. Callback Mechanism: The `JdbcTemplate` class supports a callback mechanism through the use of various callback interfaces. These interfaces, such as `PreparedStatementCreator`, `PreparedStatementSetter`, `RowMapper`, and others, allow you to customize the behavior of database operations and provide more flexibility in handling SQL statements and result sets.> <URL:#tn=7. Callback Mechanism: The `JdbcTemplate` class supports a callback mechanism through the use of various callback interfaces. These interfaces, such as `PreparedStatementCreator`, `PreparedStatementSetter`, `RowMapper`, and others, allow you to customize the behavior of database operations and provide more flexibility in handling SQL statements and result sets. <URL:#tn=7. Callback Mechanism: The `JdbcTemplate` class supports a callback mechanism through the use of various callback interfaces. These interfaces, such as `PreparedStatementCreator`, `PreparedStatementSetter`, `RowMapper`, and others, allow you to customize the behavior of database operations and provide more flexibility in handling SQL statements and result sets.>>
        1.3.8 explain  org.springframework.beans.factory.annotation.Qualifier <URL:#tn=        1.3.8 explain  org.springframework.beans.factory.annotation.Qualifier> <URL:#tn=        1.3.8 explain  org.springframework.beans.factory.annotation.Qualifier <URL:#tn=        1.3.8 explain  org.springframework.beans.factory.annotation.Qualifier>>
1. Define Bean Qualifiers: In the application context, when defining multiple beans of the same type, you can assign a unique qualifier value using the `@Qualifier` annotation. For example: <URL:#tn=1. Define Bean Qualifiers: In the application context, when defining multiple beans of the same type, you can assign a unique qualifier value using the `@Qualifier` annotation. For example:> <URL:#tn=1. Define Bean Qualifiers: In the application context, when defining multiple beans of the same type, you can assign a unique qualifier value using the `@Qualifier` annotation. For example: <URL:#tn=1. Define Bean Qualifiers: In the application context, when defining multiple beans of the same type, you can assign a unique qualifier value using the `@Qualifier` annotation. For example:>>
2. Use `@Qualifier` for Dependency Injection: In the dependent class or component, you can use the `@Qualifier` annotation along with `@Autowired` to specify which bean should be injected. For example: <URL:#tn=2. Use `@Qualifier` for Dependency Injection: In the dependent class or component, you can use the `@Qualifier` annotation along with `@Autowired` to specify which bean should be injected. For example:> <URL:#tn=2. Use `@Qualifier` for Dependency Injection: In the dependent class or component, you can use the `@Qualifier` annotation along with `@Autowired` to specify which bean should be injected. For example: <URL:#tn=2. Use `@Qualifier` for Dependency Injection: In the dependent class or component, you can use the `@Qualifier` annotation along with `@Autowired` to specify which bean should be injected. For example:>>
        1.3.9 <URL:#tn=        1.3.9> <URL:#tn=        1.3.9 <URL:#tn=        1.3.9>>
    1.4 <URL:#tn=    1.4> <URL:#tn=    1.4 <URL:#tn=    1.4>>
2. general <URL:#tn=2. general> <URL:#tn=2. general <URL:#tn=2. general>>
    2.1. manipulate jar files. <URL:#tn=    2.1. manipulate jar files.> <URL:#tn=    2.1. manipulate jar files. <URL:#tn=    2.1. manipulate jar files.>>
    2.2. remote debug java application. <URL:#tn=    2.2. remote debug java application.> <URL:#tn=    2.2. remote debug java application. <URL:#tn=    2.2. remote debug java application.>>
    2.3. deploy JSP pages to web container. <URL:#tn=    2.3. deploy JSP pages to web container.> <URL:#tn=    2.3. deploy JSP pages to web container. <URL:#tn=    2.3. deploy JSP pages to web container.>>
    2.4. Tomcat <URL:#tn=    2.4. Tomcat> <URL:#tn=    2.4. Tomcat <URL:#tn=    2.4. Tomcat>>
	1. listen port and shutdown port are defined in server.xml. <URL:#tn=	1. listen port and shutdown port are defined in server.xml.> <URL:#tn=	1. listen port and shutdown port are defined in server.xml. <URL:#tn=	1. listen port and shutdown port are defined in server.xml.>>
    2.5.  Reverse engineer. <URL:#tn=    2.5.  Reverse engineer.> <URL:#tn=    2.5.  Reverse engineer. <URL:#tn=    2.5.  Reverse engineer.>>
    2.6 Set java version, toggle java versions, switch jdk versions <URL:#tn=    2.6 Set java version, toggle java versions, switch jdk versions> <URL:#tn=    2.6 Set java version, toggle java versions, switch jdk versions <URL:#tn=    2.6 Set java version, toggle java versions, switch jdk versions>>
        2.6.1 mac, OS X <URL:#tn=        2.6.1 mac, OS X> <URL:#tn=        2.6.1 mac, OS X <URL:#tn=        2.6.1 mac, OS X>>
    14.0.2, x86_64:	"OpenJDK 14.0.2"	/Library/Java/JavaVirtualMachines/openjdk-14.0.2.jdk/Contents/Home <URL:#tn=    14.0.2, x86_64:	"OpenJDK 14.0.2"	/Library/Java/JavaVirtualMachines/openjdk-14.0.2.jdk/Contents/Home> <URL:#tn=    14.0.2, x86_64:	"OpenJDK 14.0.2"	/Library/Java/JavaVirtualMachines/openjdk-14.0.2.jdk/Contents/Home <URL:#tn=    14.0.2, x86_64:	"OpenJDK 14.0.2"	/Library/Java/JavaVirtualMachines/openjdk-14.0.2.jdk/Contents/Home>>
    10.0.2, x86_64:	"Java SE 10.0.2"	/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home <URL:#tn=    10.0.2, x86_64:	"Java SE 10.0.2"	/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home> <URL:#tn=    10.0.2, x86_64:	"Java SE 10.0.2"	/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home <URL:#tn=    10.0.2, x86_64:	"Java SE 10.0.2"	/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home>>
    1.8.0_265, x86_64:	"AdoptOpenJDK 8"	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home <URL:#tn=    1.8.0_265, x86_64:	"AdoptOpenJDK 8"	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home> <URL:#tn=    1.8.0_265, x86_64:	"AdoptOpenJDK 8"	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home <URL:#tn=    1.8.0_265, x86_64:	"AdoptOpenJDK 8"	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home>>
    1.8.0_241, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home <URL:#tn=    1.8.0_241, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home> <URL:#tn=    1.8.0_241, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home <URL:#tn=    1.8.0_241, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home>>
    13.0.1, x86_64:	"OpenJDK 13.0.1"	/Library/Java/JavaVirtualMachines/openjdk-13.0.1.jdk/Contents/Home <URL:#tn=    13.0.1, x86_64:	"OpenJDK 13.0.1"	/Library/Java/JavaVirtualMachines/openjdk-13.0.1.jdk/Contents/Home> <URL:#tn=    13.0.1, x86_64:	"OpenJDK 13.0.1"	/Library/Java/JavaVirtualMachines/openjdk-13.0.1.jdk/Contents/Home <URL:#tn=    13.0.1, x86_64:	"OpenJDK 13.0.1"	/Library/Java/JavaVirtualMachines/openjdk-13.0.1.jdk/Contents/Home>>
    10.0.2, x86_64:	"Java SE 10.0.2"	/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home <URL:#tn=    10.0.2, x86_64:	"Java SE 10.0.2"	/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home> <URL:#tn=    10.0.2, x86_64:	"Java SE 10.0.2"	/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home <URL:#tn=    10.0.2, x86_64:	"Java SE 10.0.2"	/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home>>
    1.8.0_241, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home <URL:#tn=    1.8.0_241, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home> <URL:#tn=    1.8.0_241, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home <URL:#tn=    1.8.0_241, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home>>
    1.8.0_232, x86_64:	"AdoptOpenJDK 8"	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home <URL:#tn=    1.8.0_232, x86_64:	"AdoptOpenJDK 8"	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home> <URL:#tn=    1.8.0_232, x86_64:	"AdoptOpenJDK 8"	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home <URL:#tn=    1.8.0_232, x86_64:	"AdoptOpenJDK 8"	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home>>
    2.7 chatgpt <URL:#tn=    2.7 chatgpt> <URL:#tn=    2.7 chatgpt <URL:#tn=    2.7 chatgpt>>
        2.7.1 java set data structure, tags: java set data structure <URL:#tn=        2.7.1 java set data structure, tags: java set data structure> <URL:#tn=        2.7.1 java set data structure, tags: java set data structure <URL:#tn=        2.7.1 java set data structure, tags: java set data structure>>
        2.7.2  java Files  , tags: java Files <URL:#tn=        2.7.2  java Files  , tags: java Files> <URL:#tn=        2.7.2  java Files  , tags: java Files <URL:#tn=        2.7.2  java Files  , tags: java Files>>
        2.7.3 java Objects.requireNonNull , tags: java Objects.requireNonNull <URL:#tn=        2.7.3 java Objects.requireNonNull , tags: java Objects.requireNonNull> <URL:#tn=        2.7.3 java Objects.requireNonNull , tags: java Objects.requireNonNull <URL:#tn=        2.7.3 java Objects.requireNonNull , tags: java Objects.requireNonNull>>
        2.7.4 java File.toPath() , tags: java File.toPath() <URL:#tn=        2.7.4 java File.toPath() , tags: java File.toPath()> <URL:#tn=        2.7.4 java File.toPath() , tags: java File.toPath() <URL:#tn=        2.7.4 java File.toPath() , tags: java File.toPath()>>
        2.7.5 java use class loader to read a file that contains a sql statement and then run it on a PG DB , tags: java use class loader to read a file that contains a sql statement and then run it on a PG DB <URL:#tn=        2.7.5 java use class loader to read a file that contains a sql statement and then run it on a PG DB , tags: java use class loader to read a file that contains a sql statement and then run it on a PG DB> <URL:#tn=        2.7.5 java use class loader to read a file that contains a sql statement and then run it on a PG DB , tags: java use class loader to read a file that contains a sql statement and then run it on a PG DB <URL:#tn=        2.7.5 java use class loader to read a file that contains a sql statement and then run it on a PG DB , tags: java use class loader to read a file that contains a sql statement and then run it on a PG DB>>
        2.7.6 java org.stringtemplate.v4.ST , tags: java org.stringtemplate.v4.ST <URL:#tn=        2.7.6 java org.stringtemplate.v4.ST , tags: java org.stringtemplate.v4.ST> <URL:#tn=        2.7.6 java org.stringtemplate.v4.ST , tags: java org.stringtemplate.v4.ST <URL:#tn=        2.7.6 java org.stringtemplate.v4.ST , tags: java org.stringtemplate.v4.ST>>
        2.7.7 java StringBuilder, tags: java StringBuilder <URL:#tn=        2.7.7 java StringBuilder, tags: java StringBuilder> <URL:#tn=        2.7.7 java StringBuilder, tags: java StringBuilder <URL:#tn=        2.7.7 java StringBuilder, tags: java StringBuilder>>
        2.7.8 java jackson @JsonCreator annotation, tags: java jackson @JsonCreator annotation <URL:#tn=        2.7.8 java jackson @JsonCreator annotation, tags: java jackson @JsonCreator annotation> <URL:#tn=        2.7.8 java jackson @JsonCreator annotation, tags: java jackson @JsonCreator annotation <URL:#tn=        2.7.8 java jackson @JsonCreator annotation, tags: java jackson @JsonCreator annotation>>
        2.7.9 how to read an array property into a List<String> in a @JsonCreator annotated class constructor, tags: how to read an array property into a List<String> in a @JsonCreator annotated class constructor <URL:#tn=        2.7.9 how to read an array property into a List<String> in a @JsonCreator annotated class constructor, tags: how to read an array property into a List<String> in a @JsonCreator annotated class constructor> <URL:#tn=        2.7.9 how to read an array property into a List<String> in a @JsonCreator annotated class constructor, tags: how to read an array property into a List<String> in a @JsonCreator annotated class constructor <URL:#tn=        2.7.9 how to read an array property into a List<String> in a @JsonCreator annotated class constructor, tags: how to read an array property into a List<String> in a @JsonCreator annotated class constructor>>
        2.7.10 <URL:#tn=        2.7.10> <URL:#tn=        2.7.10 <URL:#tn=        2.7.10>>
    2.8 <URL:#tn=    2.8> <URL:#tn=    2.8 <URL:#tn=    2.8>>
3.  IDE, intellij <URL:#tn=3.  IDE, intellij> <URL:#tn=3.  IDE, intellij <URL:#tn=3.  IDE, intellij>>
    3.1   VIM plugin <URL:#tn=    3.1   VIM plugin> <URL:#tn=    3.1   VIM plugin <URL:#tn=    3.1   VIM plugin>>
    3.2   Code generation <URL:#tn=    3.2   Code generation> <URL:#tn=    3.2   Code generation <URL:#tn=    3.2   Code generation>>
        3.2.1    generate getters and setters <URL:#tn=        3.2.1    generate getters and setters> <URL:#tn=        3.2.1    generate getters and setters <URL:#tn=        3.2.1    generate getters and setters>>
        3.2.2 <URL:#tn=        3.2.2> <URL:#tn=        3.2.2 <URL:#tn=        3.2.2>>
    3.3 <URL:#tn=    3.3> <URL:#tn=    3.3 <URL:#tn=    3.3>>
4. Build java projects <URL:#tn=4. Build java projects> <URL:#tn=4. Build java projects <URL:#tn=4. Build java projects>>
    4.1 Build java projects with maven <URL:#tn=    4.1 Build java projects with maven> <URL:#tn=    4.1 Build java projects with maven <URL:#tn=    4.1 Build java projects with maven>>
        4.1.1 Build java projects with maven spring tutorial <URL:#tn=        4.1.1 Build java projects with maven spring tutorial> <URL:#tn=        4.1.1 Build java projects with maven spring tutorial <URL:#tn=        4.1.1 Build java projects with maven spring tutorial>>
        4.1.2 maven <URL:#tn=        4.1.2 maven> <URL:#tn=        4.1.2 maven <URL:#tn=        4.1.2 maven>>
            4.1.2.1 getting started <URL:#tn=            4.1.2.1 getting started> <URL:#tn=            4.1.2.1 getting started <URL:#tn=            4.1.2.1 getting started>>
                4.1.2.1.1  Create project <URL:#tn=                4.1.2.1.1  Create project> <URL:#tn=                4.1.2.1.1  Create project <URL:#tn=                4.1.2.1.1  Create project>>
                4.1.2.1.2 . Main phases <URL:#tn=                4.1.2.1.2 . Main phases> <URL:#tn=                4.1.2.1.2 . Main phases <URL:#tn=                4.1.2.1.2 . Main phases>>
                4.1.2.1.3 . Maven phase commands(Project Build Commands) <URL:#tn=                4.1.2.1.3 . Maven phase commands(Project Build Commands)> <URL:#tn=                4.1.2.1.3 . Maven phase commands(Project Build Commands) <URL:#tn=                4.1.2.1.3 . Maven phase commands(Project Build Commands)>>
                4.1.2.1.4  Skip running tests <URL:#tn=                4.1.2.1.4  Skip running tests> <URL:#tn=                4.1.2.1.4  Skip running tests <URL:#tn=                4.1.2.1.4  Skip running tests>>
                4.1.2.1.5 Project Site Generation <URL:#tn=                4.1.2.1.5 Project Site Generation> <URL:#tn=                4.1.2.1.5 Project Site Generation <URL:#tn=                4.1.2.1.5 Project Site Generation>>
                4.1.2.1.6 Code quality analysis <URL:#tn=                4.1.2.1.6 Code quality analysis> <URL:#tn=                4.1.2.1.6 Code quality analysis <URL:#tn=                4.1.2.1.6 Code quality analysis>>
                4.1.2.1.7 Code coverage reporting <URL:#tn=                4.1.2.1.7 Code coverage reporting> <URL:#tn=                4.1.2.1.7 Code coverage reporting <URL:#tn=                4.1.2.1.7 Code coverage reporting>>
                4.1.2.1.8 Dependency Management <URL:#tn=                4.1.2.1.8 Dependency Management> <URL:#tn=                4.1.2.1.8 Dependency Management <URL:#tn=                4.1.2.1.8 Dependency Management>>
                4.1.2.1.9 Getting Help <URL:#tn=                4.1.2.1.9 Getting Help> <URL:#tn=                4.1.2.1.9 Getting Help <URL:#tn=                4.1.2.1.9 Getting Help>>
            4.1.2.2 commonly use CLI <URL:#tn=            4.1.2.2 commonly use CLI> <URL:#tn=            4.1.2.2 commonly use CLI <URL:#tn=            4.1.2.2 commonly use CLI>>
            4.1.2.3 <URL:#tn=            4.1.2.3> <URL:#tn=            4.1.2.3 <URL:#tn=            4.1.2.3>>
        4.1.3 <URL:#tn=        4.1.3> <URL:#tn=        4.1.3 <URL:#tn=        4.1.3>>
    4.2 <URL:#tn=    4.2> <URL:#tn=    4.2 <URL:#tn=    4.2>>
5. Java basics <URL:#tn=5. Java basics> <URL:#tn=5. Java basics <URL:#tn=5. Java basics>>
    5.1 <URL:#tn=    5.1> <URL:#tn=    5.1 <URL:#tn=    5.1>>
6. JDK 5,6 <URL:#tn=6. JDK 5,6> <URL:#tn=6. JDK 5,6 <URL:#tn=6. JDK 5,6>>
	6.1 Annotations <URL:#tn=	6.1 Annotations> <URL:#tn=	6.1 Annotations <URL:#tn=	6.1 Annotations>>
		6.1.1 Description <URL:#tn=		6.1.1 Description> <URL:#tn=		6.1.1 Description <URL:#tn=		6.1.1 Description>>
		6.1.2 Usage <URL:#tn=		6.1.2 Usage> <URL:#tn=		6.1.2 Usage <URL:#tn=		6.1.2 Usage>>
			6.1.2.1 Documentation <URL:#tn=			6.1.2.1 Documentation> <URL:#tn=			6.1.2.1 Documentation <URL:#tn=			6.1.2.1 Documentation>>
			6.1.2.2 Annotation Processing <URL:#tn=			6.1.2.2 Annotation Processing> <URL:#tn=			6.1.2.2 Annotation Processing <URL:#tn=			6.1.2.2 Annotation Processing>>
	6.2 Enums, enumaration <URL:#tn=	6.2 Enums, enumaration> <URL:#tn=	6.2 Enums, enumaration <URL:#tn=	6.2 Enums, enumaration>>
    6.3 Nested Classes <URL:#tn=    6.3 Nested Classes> <URL:#tn=    6.3 Nested Classes <URL:#tn=    6.3 Nested Classes>>
	6.2.1 Inner Class Example <URL:#tn=	6.2.1 Inner Class Example> <URL:#tn=	6.2.1 Inner Class Example <URL:#tn=	6.2.1 Inner Class Example>>
    6.4 generics <URL:#tn=    6.4 generics> <URL:#tn=    6.4 generics <URL:#tn=    6.4 generics>>
	6.4.1 Article: Using and Programming Generics in J2SE 5.0 <URL:#tn=	6.4.1 Article: Using and Programming Generics in J2SE 5.0> <URL:#tn=	6.4.1 Article: Using and Programming Generics in J2SE 5.0 <URL:#tn=	6.4.1 Article: Using and Programming Generics in J2SE 5.0>>
   1. "? extends Type": Denotes a family of subtypes of type Type. This is the most useful wildcard <URL:#tn=   1. "? extends Type": Denotes a family of subtypes of type Type. This is the most useful wildcard> <URL:#tn=   1. "? extends Type": Denotes a family of subtypes of type Type. This is the most useful wildcard <URL:#tn=   1. "? extends Type": Denotes a family of subtypes of type Type. This is the most useful wildcard>>
   2. "? super Type": Denotes a family of supertypes of type Type <URL:#tn=   2. "? super Type": Denotes a family of supertypes of type Type> <URL:#tn=   2. "? super Type": Denotes a family of supertypes of type Type <URL:#tn=   2. "? super Type": Denotes a family of supertypes of type Type>>
   3. "?": Denotes the set of all types or any <URL:#tn=   3. "?": Denotes the set of all types or any> <URL:#tn=   3. "?": Denotes the set of all types or any <URL:#tn=   3. "?": Denotes the set of all types or any>>
7. Install <URL:#tn=7. Install> <URL:#tn=7. Install <URL:#tn=7. Install>>
	7.1 Linux <URL:#tn=	7.1 Linux> <URL:#tn=	7.1 Linux <URL:#tn=	7.1 Linux>>
	7.2 Mac. tags: install java MAC OSX <URL:#tn=	7.2 Mac. tags: install java MAC OSX> <URL:#tn=	7.2 Mac. tags: install java MAC OSX <URL:#tn=	7.2 Mac. tags: install java MAC OSX>>
	7.3 <URL:#tn=	7.3> <URL:#tn=	7.3 <URL:#tn=	7.3>>
8. Code Snipplets <URL:#tn=8. Code Snipplets> <URL:#tn=8. Code Snipplets <URL:#tn=8. Code Snipplets>>
	8.1 Encoding, utf-8, utf-16 <URL:#tn=	8.1 Encoding, utf-8, utf-16> <URL:#tn=	8.1 Encoding, utf-8, utf-16 <URL:#tn=	8.1 Encoding, utf-8, utf-16>>
	8.2 <URL:#tn=	8.2> <URL:#tn=	8.2 <URL:#tn=	8.2>>
9. Cookbook <URL:#tn=9. Cookbook> <URL:#tn=9. Cookbook <URL:#tn=9. Cookbook>>
	9.1  Files <URL:#tn=	9.1  Files> <URL:#tn=	9.1  Files <URL:#tn=	9.1  Files>>
		9.1.1   read file content java <URL:#tn=		9.1.1   read file content java> <URL:#tn=		9.1.1   read file content java <URL:#tn=		9.1.1   read file content java>>
			9.1.1.1   Reading and writing text files <URL:#tn=			9.1.1.1   Reading and writing text files> <URL:#tn=			9.1.1.1   Reading and writing text files <URL:#tn=			9.1.1.1   Reading and writing text files>>
			9.1.1.2 BufferedReader <URL:#tn=			9.1.1.2 BufferedReader> <URL:#tn=			9.1.1.2 BufferedReader <URL:#tn=			9.1.1.2 BufferedReader>>
			9.1.1.3 <URL:#tn=			9.1.1.3> <URL:#tn=			9.1.1.3 <URL:#tn=			9.1.1.3>>
		9.1.2 Edit files <URL:#tn=		9.1.2 Edit files> <URL:#tn=		9.1.2 Edit files <URL:#tn=		9.1.2 Edit files>>
			9.1.2.1 Java – Edit File Example, Modify File java <URL:#tn=			9.1.2.1 Java – Edit File Example, Modify File java> <URL:#tn=			9.1.2.1 Java – Edit File Example, Modify File java <URL:#tn=			9.1.2.1 Java – Edit File Example, Modify File java>>
			9.1.2.2 <URL:#tn=			9.1.2.2> <URL:#tn=			9.1.2.2 <URL:#tn=			9.1.2.2>>
		9.1.3 <URL:#tn=		9.1.3> <URL:#tn=		9.1.3 <URL:#tn=		9.1.3>>
	9.2 <URL:#tn=	9.2> <URL:#tn=	9.2 <URL:#tn=	9.2>>
10. IDEs <URL:#tn=10. IDEs> <URL:#tn=10. IDEs <URL:#tn=10. IDEs>>
	10.1 Eclipse <URL:#tn=	10.1 Eclipse> <URL:#tn=	10.1 Eclipse <URL:#tn=	10.1 Eclipse>>
		10.1.1 Quick references <URL:#tn=		10.1.1 Quick references> <URL:#tn=		10.1.1 Quick references <URL:#tn=		10.1.1 Quick references>>
			10.1.1.1 official <URL:#tn=			10.1.1.1 official> <URL:#tn=			10.1.1.1 official <URL:#tn=			10.1.1.1 official>>
			10.1.1.2 <URL:#tn=			10.1.1.2> <URL:#tn=			10.1.1.2 <URL:#tn=			10.1.1.2>>
		10.1.2 FAQ <URL:#tn=		10.1.2 FAQ> <URL:#tn=		10.1.2 FAQ <URL:#tn=		10.1.2 FAQ>>
			10.1.2.1 error log <URL:#tn=			10.1.2.1 error log> <URL:#tn=			10.1.2.1 error log <URL:#tn=			10.1.2.1 error log>>
			10.1.2.2 java.lang.UnsatisfiedLinkError: Cannot load 32-bit SWT libraries on 64-bit JVM <URL:#tn=			10.1.2.2 java.lang.UnsatisfiedLinkError: Cannot load 32-bit SWT libraries on 64-bit JVM> <URL:#tn=			10.1.2.2 java.lang.UnsatisfiedLinkError: Cannot load 32-bit SWT libraries on 64-bit JVM <URL:#tn=			10.1.2.2 java.lang.UnsatisfiedLinkError: Cannot load 32-bit SWT libraries on 64-bit JVM>>
			10.1.2.3 <URL:#tn=			10.1.2.3> <URL:#tn=			10.1.2.3 <URL:#tn=			10.1.2.3>>
		10.1.3 <URL:#tn=		10.1.3> <URL:#tn=		10.1.3 <URL:#tn=		10.1.3>>
	10.2 <URL:#tn=	10.2> <URL:#tn=	10.2 <URL:#tn=	10.2>>
11. Server side programming <URL:#tn=11. Server side programming> <URL:#tn=11. Server side programming <URL:#tn=11. Server side programming>>
	11.1 Servlet <URL:#tn=	11.1 Servlet> <URL:#tn=	11.1 Servlet <URL:#tn=	11.1 Servlet>>
		11.1.1 Basic example & walkthrough <URL:#tn=		11.1.1 Basic example & walkthrough> <URL:#tn=		11.1.1 Basic example & walkthrough <URL:#tn=		11.1.1 Basic example & walkthrough>>
			11.1.1.1 Eclipse <URL:#tn=			11.1.1.1 Eclipse> <URL:#tn=			11.1.1.1 Eclipse <URL:#tn=			11.1.1.1 Eclipse>>
			11.1.1.2 <URL:#tn=			11.1.1.2> <URL:#tn=			11.1.1.2 <URL:#tn=			11.1.1.2>>
		11.1.2 <URL:#tn=		11.1.2> <URL:#tn=		11.1.2 <URL:#tn=		11.1.2>>
	11.2 <URL:#tn=	11.2> <URL:#tn=	11.2 <URL:#tn=	11.2>>
12. My snippets, examples, demos <URL:#tn=12. My snippets, examples, demos> <URL:#tn=12. My snippets, examples, demos <URL:#tn=12. My snippets, examples, demos>>
    12.1 Performance tests <URL:#tn=    12.1 Performance tests> <URL:#tn=    12.1 Performance tests <URL:#tn=    12.1 Performance tests>>
        12.1.1 HashMap vs array contains <URL:#tn=        12.1.1 HashMap vs array contains> <URL:#tn=        12.1.1 HashMap vs array contains <URL:#tn=        12.1.1 HashMap vs array contains>>
        12.1.2 <URL:#tn=        12.1.2> <URL:#tn=        12.1.2 <URL:#tn=        12.1.2>>
    12.2 <URL:#tn=    12.2> <URL:#tn=    12.2 <URL:#tn=    12.2>>
13.  Memory Management <URL:#tn=13.  Memory Management> <URL:#tn=13.  Memory Management <URL:#tn=13.  Memory Management>>
    13.1  memsize equivalent - How to Get the Size of an Object <URL:#tn=    13.1  memsize equivalent - How to Get the Size of an Object> <URL:#tn=    13.1  memsize equivalent - How to Get the Size of an Object <URL:#tn=    13.1  memsize equivalent - How to Get the Size of an Object>>
        13.1.1  https://www.baeldung.com/java-size-of-object <URL:#tn=        13.1.1  https://www.baeldung.com/java-size-of-object> <URL:#tn=        13.1.1  https://www.baeldung.com/java-size-of-object <URL:#tn=        13.1.1  https://www.baeldung.com/java-size-of-object>>
2. Memory Consumption in Java <URL:#tn=2. Memory Consumption in Java> <URL:#tn=2. Memory Consumption in Java <URL:#tn=2. Memory Consumption in Java>>
3.2. Example Class <URL:#tn=3.2. Example Class> <URL:#tn=3.2. Example Class <URL:#tn=3.2. Example Class>>
        13.1.2 <URL:#tn=        13.1.2> <URL:#tn=        13.1.2 <URL:#tn=        13.1.2>>
    13.2 <URL:#tn=    13.2> <URL:#tn=    13.2 <URL:#tn=    13.2>>
14. Java versions main features and tools, tags: Java versions main features and tools, tags: versions main features and tools <URL:#tn=14. Java versions main features and tools, tags: Java versions main features and tools, tags: versions main features and tools> <URL:#tn=14. Java versions main features and tools, tags: Java versions main features and tools, tags: versions main features and tools <URL:#tn=14. Java versions main features and tools, tags: Java versions main features and tools, tags: versions main features and tools>>
    14.1   Java version 1 <URL:#tn=    14.1   Java version 1> <URL:#tn=    14.1   Java version 1 <URL:#tn=    14.1   Java version 1>>
    14.2   Java version 2 <URL:#tn=    14.2   Java version 2> <URL:#tn=    14.2   Java version 2 <URL:#tn=    14.2   Java version 2>>
    14.3   Java version 3 <URL:#tn=    14.3   Java version 3> <URL:#tn=    14.3   Java version 3 <URL:#tn=    14.3   Java version 3>>
    14.4   Java version 4 <URL:#tn=    14.4   Java version 4> <URL:#tn=    14.4   Java version 4 <URL:#tn=    14.4   Java version 4>>
    14.5   Java version 5 <URL:#tn=    14.5   Java version 5> <URL:#tn=    14.5   Java version 5 <URL:#tn=    14.5   Java version 5>>
    14.6   Java version 6 <URL:#tn=    14.6   Java version 6> <URL:#tn=    14.6   Java version 6 <URL:#tn=    14.6   Java version 6>>
    14.7   Java version 7 <URL:#tn=    14.7   Java version 7> <URL:#tn=    14.7   Java version 7 <URL:#tn=    14.7   Java version 7>>
    14.8   Java version 8 <URL:#tn=    14.8   Java version 8> <URL:#tn=    14.8   Java version 8 <URL:#tn=    14.8   Java version 8>>
        14.8.1    functional interfaces, tags: functional interfaces <URL:#tn=        14.8.1    functional interfaces, tags: functional interfaces> <URL:#tn=        14.8.1    functional interfaces, tags: functional interfaces <URL:#tn=        14.8.1    functional interfaces, tags: functional interfaces>>
          14.8.1.1    chatgpt, lambda expressions and functional interfaces <URL:#tn=          14.8.1.1    chatgpt, lambda expressions and functional interfaces> <URL:#tn=          14.8.1.1    chatgpt, lambda expressions and functional interfaces <URL:#tn=          14.8.1.1    chatgpt, lambda expressions and functional interfaces>>
        14.8.2 forEach <URL:#tn=        14.8.2 forEach> <URL:#tn=        14.8.2 forEach <URL:#tn=        14.8.2 forEach>>
        14.8.3 optional class , tags: optional class <URL:#tn=        14.8.3 optional class , tags: optional class> <URL:#tn=        14.8.3 optional class , tags: optional class <URL:#tn=        14.8.3 optional class , tags: optional class>>
        14.8.4 Default And Static Methods In Interfaces, tags: Default And Static Methods In Interfaces <URL:#tn=        14.8.4 Default And Static Methods In Interfaces, tags: Default And Static Methods In Interfaces> <URL:#tn=        14.8.4 Default And Static Methods In Interfaces, tags: Default And Static Methods In Interfaces <URL:#tn=        14.8.4 Default And Static Methods In Interfaces, tags: Default And Static Methods In Interfaces>>
        14.8.4 Java Stream API For Bulk Data Operations On Collections , tags: Java Stream API For Bulk Data Operations On Collections <URL:#tn=        14.8.4 Java Stream API For Bulk Data Operations On Collections , tags: Java Stream API For Bulk Data Operations On Collections> <URL:#tn=        14.8.4 Java Stream API For Bulk Data Operations On Collections , tags: Java Stream API For Bulk Data Operations On Collections <URL:#tn=        14.8.4 Java Stream API For Bulk Data Operations On Collections , tags: Java Stream API For Bulk Data Operations On Collections>>
        14.8.5 java data time API usage, tags: java data time API usage <URL:#tn=        14.8.5 java data time API usage, tags: java data time API usage> <URL:#tn=        14.8.5 java data time API usage, tags: java data time API usage <URL:#tn=        14.8.5 java data time API usage, tags: java data time API usage>>
            14.8.5.1 gpt <URL:#tn=            14.8.5.1 gpt> <URL:#tn=            14.8.5.1 gpt <URL:#tn=            14.8.5.1 gpt>>
            14.8.5.2 my demo <URL:#tn=            14.8.5.2 my demo> <URL:#tn=            14.8.5.2 my demo <URL:#tn=            14.8.5.2 my demo>>
            14.8.5.3 <URL:#tn=            14.8.5.3> <URL:#tn=            14.8.5.3 <URL:#tn=            14.8.5.3>>
        14.8.6 Collection API Improvements, tags: Collection API Improvements <URL:#tn=        14.8.6 Collection API Improvements, tags: Collection API Improvements> <URL:#tn=        14.8.6 Collection API Improvements, tags: Collection API Improvements <URL:#tn=        14.8.6 Collection API Improvements, tags: Collection API Improvements>>
        14.8.7 Java IO Improvements <URL:#tn=        14.8.7 Java IO Improvements> <URL:#tn=        14.8.7 Java IO Improvements <URL:#tn=        14.8.7 Java IO Improvements>>
        14.8.8 Miscellaneous Core API Improvements <URL:#tn=        14.8.8 Miscellaneous Core API Improvements> <URL:#tn=        14.8.8 Miscellaneous Core API Improvements <URL:#tn=        14.8.8 Miscellaneous Core API Improvements>>
        14.8.9 Base64 Encode Decode <URL:#tn=        14.8.9 Base64 Encode Decode> <URL:#tn=        14.8.9 Base64 Encode Decode <URL:#tn=        14.8.9 Base64 Encode Decode>>
            14.8.9.1 GTP example <URL:#tn=            14.8.9.1 GTP example> <URL:#tn=            14.8.9.1 GTP example <URL:#tn=            14.8.9.1 GTP example>>
            14.8.9.2 my demo <URL:#tn=            14.8.9.2 my demo> <URL:#tn=            14.8.9.2 my demo <URL:#tn=            14.8.9.2 my demo>>
            14.8.9.3 <URL:#tn=            14.8.9.3> <URL:#tn=            14.8.9.3 <URL:#tn=            14.8.9.3>>
        14.8.10 <URL:#tn=        14.8.10> <URL:#tn=        14.8.10 <URL:#tn=        14.8.10>>
    14.10  Java version 9, tags: Java version 9 <URL:#tn=    14.10  Java version 9, tags: Java version 9> <URL:#tn=    14.10  Java version 9, tags: Java version 9 <URL:#tn=    14.10  Java version 9, tags: Java version 9>>
        14.10.1  REPL, jshell, tags: REPL, jshell <URL:#tn=        14.10.1  REPL, jshell, tags: REPL, jshell> <URL:#tn=        14.10.1  REPL, jshell, tags: REPL, jshell <URL:#tn=        14.10.1  REPL, jshell, tags: REPL, jshell>>
        14.10.2 Factory Methods for Immutable List, Set, Map and Map.Entry, tags: Factory Methods for Immutable List <URL:#tn=        14.10.2 Factory Methods for Immutable List, Set, Map and Map.Entry, tags: Factory Methods for Immutable List> <URL:#tn=        14.10.2 Factory Methods for Immutable List, Set, Map and Map.Entry, tags: Factory Methods for Immutable List <URL:#tn=        14.10.2 Factory Methods for Immutable List, Set, Map and Map.Entry, tags: Factory Methods for Immutable List>>
        14.10.3 Private methods in Interfaces <URL:#tn=        14.10.3 Private methods in Interfaces> <URL:#tn=        14.10.3 Private methods in Interfaces <URL:#tn=        14.10.3 Private methods in Interfaces>>
        14.10.4 Java 9 Module System <URL:#tn=        14.10.4 Java 9 Module System> <URL:#tn=        14.10.4 Java 9 Module System <URL:#tn=        14.10.4 Java 9 Module System>>
            14.10.4.1 GPT explanation <URL:#tn=            14.10.4.1 GPT explanation> <URL:#tn=            14.10.4.1 GPT explanation <URL:#tn=            14.10.4.1 GPT explanation>>
            14.10.4.2 https://www.baeldung.com/java-9-modularity <URL:#tn=            14.10.4.2 https://www.baeldung.com/java-9-modularity> <URL:#tn=            14.10.4.2 https://www.baeldung.com/java-9-modularity <URL:#tn=            14.10.4.2 https://www.baeldung.com/java-9-modularity>>
                14.10.4.2.1 Packages <URL:#tn=                14.10.4.2.1 Packages> <URL:#tn=                14.10.4.2.1 Packages <URL:#tn=                14.10.4.2.1 Packages>>
                14.10.4.2.2 resources <URL:#tn=                14.10.4.2.2 resources> <URL:#tn=                14.10.4.2.2 resources <URL:#tn=                14.10.4.2.2 resources>>
                14.10.4.2.3 Module Descriptor <URL:#tn=                14.10.4.2.3 Module Descriptor> <URL:#tn=                14.10.4.2.3 Module Descriptor <URL:#tn=                14.10.4.2.3 Module Descriptor>>
                14.10.4.2.4 java list-modules command <URL:#tn=                14.10.4.2.4 java list-modules command> <URL:#tn=                14.10.4.2.4 java list-modules command <URL:#tn=                14.10.4.2.4 java list-modules command>>
                14.10.4.2.5 Module Types <URL:#tn=                14.10.4.2.5 Module Types> <URL:#tn=                14.10.4.2.5 Module Types <URL:#tn=                14.10.4.2.5 Module Types>>
                14.10.4.2.6 Distribution <URL:#tn=                14.10.4.2.6 Distribution> <URL:#tn=                14.10.4.2.6 Distribution <URL:#tn=                14.10.4.2.6 Distribution>>
                14.10.4.2.7 Default Modules <URL:#tn=                14.10.4.2.7 Default Modules> <URL:#tn=                14.10.4.2.7 Default Modules <URL:#tn=                14.10.4.2.7 Default Modules>>
                14.10.4.2.8 Module Declarations <URL:#tn=                14.10.4.2.8 Module Declarations> <URL:#tn=                14.10.4.2.8 Module Declarations <URL:#tn=                14.10.4.2.8 Module Declarations>>
                    14.10.4.2.8.1 Requires <URL:#tn=                    14.10.4.2.8.1 Requires> <URL:#tn=                    14.10.4.2.8.1 Requires <URL:#tn=                    14.10.4.2.8.1 Requires>>
                    14.10.4.2.8.2 Requires Static <URL:#tn=                    14.10.4.2.8.2 Requires Static> <URL:#tn=                    14.10.4.2.8.2 Requires Static <URL:#tn=                    14.10.4.2.8.2 Requires Static>>
                    14.10.4.2.8.3 Requires Transitive <URL:#tn=                    14.10.4.2.8.3 Requires Transitive> <URL:#tn=                    14.10.4.2.8.3 Requires Transitive <URL:#tn=                    14.10.4.2.8.3 Requires Transitive>>
                    14.10.4.2.8.4 Exports <URL:#tn=                    14.10.4.2.8.4 Exports> <URL:#tn=                    14.10.4.2.8.4 Exports <URL:#tn=                    14.10.4.2.8.4 Exports>>
                    14.10.4.2.8.5 Exports … To <URL:#tn=                    14.10.4.2.8.5 Exports … To> <URL:#tn=                    14.10.4.2.8.5 Exports … To <URL:#tn=                    14.10.4.2.8.5 Exports … To>>
                    14.10.4.2.8.6 Uses <URL:#tn=                    14.10.4.2.8.6 Uses> <URL:#tn=                    14.10.4.2.8.6 Uses <URL:#tn=                    14.10.4.2.8.6 Uses>>
                    14.10.4.2.8.7 Provides … With <URL:#tn=                    14.10.4.2.8.7 Provides … With> <URL:#tn=                    14.10.4.2.8.7 Provides … With <URL:#tn=                    14.10.4.2.8.7 Provides … With>>
                    14.10.4.2.8.8 Open <URL:#tn=                    14.10.4.2.8.8 Open> <URL:#tn=                    14.10.4.2.8.8 Open <URL:#tn=                    14.10.4.2.8.8 Open>>
                    14.10.4.2.8.9 Opens <URL:#tn=                    14.10.4.2.8.9 Opens> <URL:#tn=                    14.10.4.2.8.9 Opens <URL:#tn=                    14.10.4.2.8.9 Opens>>
                    14.10.4.2.8.10 Opens … To <URL:#tn=                    14.10.4.2.8.10 Opens … To> <URL:#tn=                    14.10.4.2.8.10 Opens … To <URL:#tn=                    14.10.4.2.8.10 Opens … To>>
                    14.10.4.2.8.11 <URL:#tn=                    14.10.4.2.8.11> <URL:#tn=                    14.10.4.2.8.11 <URL:#tn=                    14.10.4.2.8.11>>
                14.10.4.2.9 Command Line Options <URL:#tn=                14.10.4.2.9 Command Line Options> <URL:#tn=                14.10.4.2.9 Command Line Options <URL:#tn=                14.10.4.2.9 Command Line Options>>
                14.10.4.2.10 Visibility <URL:#tn=                14.10.4.2.10 Visibility> <URL:#tn=                14.10.4.2.10 Visibility <URL:#tn=                14.10.4.2.10 Visibility>>
                14.10.4.2.11 Putting It All Together - java modules demo, tags: Putting It All Together - java modules demo <URL:#tn=                14.10.4.2.11 Putting It All Together - java modules demo, tags: Putting It All Together - java modules demo> <URL:#tn=                14.10.4.2.11 Putting It All Together - java modules demo, tags: Putting It All Together - java modules demo <URL:#tn=                14.10.4.2.11 Putting It All Together - java modules demo, tags: Putting It All Together - java modules demo>>
                    14.10.4.2.11.1 directory structure <URL:#tn=                    14.10.4.2.11.1 directory structure> <URL:#tn=                    14.10.4.2.11.1 directory structure <URL:#tn=                    14.10.4.2.11.1 directory structure>>
                    14.10.4.2.11.2 first module <URL:#tn=                    14.10.4.2.11.2 first module> <URL:#tn=                    14.10.4.2.11.2 first module <URL:#tn=                    14.10.4.2.11.2 first module>>
                    14.10.4.2.11.3 second module <URL:#tn=                    14.10.4.2.11.3 second module> <URL:#tn=                    14.10.4.2.11.3 second module <URL:#tn=                    14.10.4.2.11.3 second module>>
                    14.10.4.2.11.4 build <URL:#tn=                    14.10.4.2.11.4 build> <URL:#tn=                    14.10.4.2.11.4 build <URL:#tn=                    14.10.4.2.11.4 build>>
                    14.10.4.2.11.5 Run <URL:#tn=                    14.10.4.2.11.5 Run> <URL:#tn=                    14.10.4.2.11.5 Run <URL:#tn=                    14.10.4.2.11.5 Run>>
                    14.10.4.2.11.6 Adding a Service <URL:#tn=                    14.10.4.2.11.6 Adding a Service> <URL:#tn=                    14.10.4.2.11.6 Adding a Service <URL:#tn=                    14.10.4.2.11.6 Adding a Service>>
                14.10.4.2.12 Final demo structure and code <URL:#tn=                14.10.4.2.12 Final demo structure and code> <URL:#tn=                14.10.4.2.12 Final demo structure and code <URL:#tn=                14.10.4.2.12 Final demo structure and code>>
                14.10.4.2.13 Adding Modules to the Unnamed Module <URL:#tn=                14.10.4.2.13 Adding Modules to the Unnamed Module> <URL:#tn=                14.10.4.2.13 Adding Modules to the Unnamed Module <URL:#tn=                14.10.4.2.13 Adding Modules to the Unnamed Module>>
                14.10.4.2.14 <URL:#tn=                14.10.4.2.14> <URL:#tn=                14.10.4.2.14 <URL:#tn=                14.10.4.2.14>>
            14.10.4.3 <URL:#tn=            14.10.4.3> <URL:#tn=            14.10.4.3 <URL:#tn=            14.10.4.3>>
            14.10.4.4 <URL:#tn=            14.10.4.4> <URL:#tn=            14.10.4.4 <URL:#tn=            14.10.4.4>>
        14.10.5 Process API Improvements <URL:#tn=        14.10.5 Process API Improvements> <URL:#tn=        14.10.5 Process API Improvements <URL:#tn=        14.10.5 Process API Improvements>>
            14.10.5.1  chatgpt <URL:#tn=            14.10.5.1  chatgpt> <URL:#tn=            14.10.5.1  chatgpt <URL:#tn=            14.10.5.1  chatgpt>>
            14.10.5.2 demo <URL:#tn=            14.10.5.2 demo> <URL:#tn=            14.10.5.2 demo <URL:#tn=            14.10.5.2 demo>>
            14.10.5.3  try-with-resources statement <URL:#tn=            14.10.5.3  try-with-resources statement> <URL:#tn=            14.10.5.3  try-with-resources statement <URL:#tn=            14.10.5.3  try-with-resources statement>>
                14.10.5.3.1   explanation <URL:#tn=                14.10.5.3.1   explanation> <URL:#tn=                14.10.5.3.1   explanation <URL:#tn=                14.10.5.3.1   explanation>>
                14.10.5.3.2 demo <URL:#tn=                14.10.5.3.2 demo> <URL:#tn=                14.10.5.3.2 demo <URL:#tn=                14.10.5.3.2 demo>>
                14.10.5.3.3 <URL:#tn=                14.10.5.3.3> <URL:#tn=                14.10.5.3.3 <URL:#tn=                14.10.5.3.3>>
        14.10.6 CompletableFuture API Improvements in java 9 <URL:#tn=        14.10.6 CompletableFuture API Improvements in java 9> <URL:#tn=        14.10.6 CompletableFuture API Improvements in java 9 <URL:#tn=        14.10.6 CompletableFuture API Improvements in java 9>>
            14.10.6.1  GPT <URL:#tn=            14.10.6.1  GPT> <URL:#tn=            14.10.6.1  GPT <URL:#tn=            14.10.6.1  GPT>>
            14.10.6.2 GTP demo <URL:#tn=            14.10.6.2 GTP demo> <URL:#tn=            14.10.6.2 GTP demo <URL:#tn=            14.10.6.2 GTP demo>>
            14.10.6.3 my demo <URL:#tn=            14.10.6.3 my demo> <URL:#tn=            14.10.6.3 my demo <URL:#tn=            14.10.6.3 my demo>>
            14.10.6.4 <URL:#tn=            14.10.6.4> <URL:#tn=            14.10.6.4 <URL:#tn=            14.10.6.4>>
        14.10.7 java 9 reactive streams <URL:#tn=        14.10.7 java 9 reactive streams> <URL:#tn=        14.10.7 java 9 reactive streams <URL:#tn=        14.10.7 java 9 reactive streams>>
            14.10.7.1 https://www.baeldung.com/java-9-reactive-streams <URL:#tn=            14.10.7.1 https://www.baeldung.com/java-9-reactive-streams> <URL:#tn=            14.10.7.1 https://www.baeldung.com/java-9-reactive-streams <URL:#tn=            14.10.7.1 https://www.baeldung.com/java-9-reactive-streams>>
                14.10.7.1.1 Overview <URL:#tn=                14.10.7.1.1 Overview> <URL:#tn=                14.10.7.1.1 Overview <URL:#tn=                14.10.7.1.1 Overview>>
                14.10.7.1.2 Reactive API Overview <URL:#tn=                14.10.7.1.2 Reactive API Overview> <URL:#tn=                14.10.7.1.2 Reactive API Overview <URL:#tn=                14.10.7.1.2 Reactive API Overview>>
                14.10.7.1.3 Publishing and Consuming Messages <URL:#tn=                14.10.7.1.3 Publishing and Consuming Messages> <URL:#tn=                14.10.7.1.3 Publishing and Consuming Messages <URL:#tn=                14.10.7.1.3 Publishing and Consuming Messages>>
                14.10.7.1.4 <URL:#tn=                14.10.7.1.4> <URL:#tn=                14.10.7.1.4 <URL:#tn=                14.10.7.1.4>>
            14.10.7.2 chatgpt <URL:#tn=            14.10.7.2 chatgpt> <URL:#tn=            14.10.7.2 chatgpt <URL:#tn=            14.10.7.2 chatgpt>>
            14.10.7.3 <URL:#tn=            14.10.7.3> <URL:#tn=            14.10.7.3 <URL:#tn=            14.10.7.3>>
        14.10.8 Diamond Operator for Anonymous Inner Class <URL:#tn=        14.10.8 Diamond Operator for Anonymous Inner Class> <URL:#tn=        14.10.8 Diamond Operator for Anonymous Inner Class <URL:#tn=        14.10.8 Diamond Operator for Anonymous Inner Class>>
        14.10.9 Optional Class Improvements <URL:#tn=        14.10.9 Optional Class Improvements> <URL:#tn=        14.10.9 Optional Class Improvements <URL:#tn=        14.10.9 Optional Class Improvements>>
        14.10.10 Stream API Improvements <URL:#tn=        14.10.10 Stream API Improvements> <URL:#tn=        14.10.10 Stream API Improvements <URL:#tn=        14.10.10 Stream API Improvements>>
        14.10.11 Enhanced @Deprecated annotation <URL:#tn=        14.10.11 Enhanced @Deprecated annotation> <URL:#tn=        14.10.11 Enhanced @Deprecated annotation <URL:#tn=        14.10.11 Enhanced @Deprecated annotation>>
        14.10.12 HTTP 2 Client <URL:#tn=        14.10.12 HTTP 2 Client> <URL:#tn=        14.10.12 HTTP 2 Client <URL:#tn=        14.10.12 HTTP 2 Client>>
        14.10.13 Multi-Resolution Image API <URL:#tn=        14.10.13 Multi-Resolution Image API> <URL:#tn=        14.10.13 Multi-Resolution Image API <URL:#tn=        14.10.13 Multi-Resolution Image API>>
        14.10.14 Miscellaneous Java 9 Features <URL:#tn=        14.10.14 Miscellaneous Java 9 Features> <URL:#tn=        14.10.14 Miscellaneous Java 9 Features <URL:#tn=        14.10.14 Miscellaneous Java 9 Features>>
        14.10.15 <URL:#tn=        14.10.15> <URL:#tn=        14.10.15 <URL:#tn=        14.10.15>>
    14.11  Java version 10, tags: Java version 10 <URL:#tn=    14.11  Java version 10, tags: Java version 10> <URL:#tn=    14.11  Java version 10, tags: Java version 10 <URL:#tn=    14.11  Java version 10, tags: Java version 10>>
    14.11  Java version 11 <URL:#tn=    14.11  Java version 11> <URL:#tn=    14.11  Java version 11 <URL:#tn=    14.11  Java version 11>>
    14.12  Java version 12 <URL:#tn=    14.12  Java version 12> <URL:#tn=    14.12  Java version 12 <URL:#tn=    14.12  Java version 12>>
    14.13  Java version 13 <URL:#tn=    14.13  Java version 13> <URL:#tn=    14.13  Java version 13 <URL:#tn=    14.13  Java version 13>>
    14.14  Java version 14 <URL:#tn=    14.14  Java version 14> <URL:#tn=    14.14  Java version 14 <URL:#tn=    14.14  Java version 14>>
    14.15  Java version 15 <URL:#tn=    14.15  Java version 15> <URL:#tn=    14.15  Java version 15 <URL:#tn=    14.15  Java version 15>>
    14.16  Java version 16 <URL:#tn=    14.16  Java version 16> <URL:#tn=    14.16  Java version 16 <URL:#tn=    14.16  Java version 16>>
    14.17  Java version 17 <URL:#tn=    14.17  Java version 17> <URL:#tn=    14.17  Java version 17 <URL:#tn=    14.17  Java version 17>>
        14.17.1  Java 17 vs Java 8 <URL:#tn=        14.17.1  Java 17 vs Java 8> <URL:#tn=        14.17.1  Java 17 vs Java 8 <URL:#tn=        14.17.1  Java 17 vs Java 8>>
            14.17.1.1  https://pretius.com/blog/java-17-features/ <URL:#tn=            14.17.1.1  https://pretius.com/blog/java-17-features/> <URL:#tn=            14.17.1.1  https://pretius.com/blog/java-17-features/ <URL:#tn=            14.17.1.1  https://pretius.com/blog/java-17-features/>>
            14.17.1.2 <URL:#tn=            14.17.1.2> <URL:#tn=            14.17.1.2 <URL:#tn=            14.17.1.2>>
        14.17.2 <URL:#tn=        14.17.2> <URL:#tn=        14.17.2 <URL:#tn=        14.17.2>>
    14.18  Java version 18 <URL:#tn=    14.18  Java version 18> <URL:#tn=    14.18  Java version 18 <URL:#tn=    14.18  Java version 18>>
    14.19  Java version 19 <URL:#tn=    14.19  Java version 19> <URL:#tn=    14.19  Java version 19 <URL:#tn=    14.19  Java version 19>>
    14.20  Java version 20 <URL:#tn=    14.20  Java version 20> <URL:#tn=    14.20  Java version 20 <URL:#tn=    14.20  Java version 20>>
    14.21  Java version 21 <URL:#tn=    14.21  Java version 21> <URL:#tn=    14.21  Java version 21 <URL:#tn=    14.21  Java version 21>>
    14.22  Java version 22 <URL:#tn=    14.22  Java version 22> <URL:#tn=    14.22  Java version 22 <URL:#tn=    14.22  Java version 22>>
    14.23  Java version 23 <URL:#tn=    14.23  Java version 23> <URL:#tn=    14.23  Java version 23 <URL:#tn=    14.23  Java version 23>>
    14.24  Java version 24 <URL:#tn=    14.24  Java version 24> <URL:#tn=    14.24  Java version 24 <URL:#tn=    14.24  Java version 24>>
    14.25  Java version 25 <URL:#tn=    14.25  Java version 25> <URL:#tn=    14.25  Java version 25 <URL:#tn=    14.25  Java version 25>>
    14.26  Java version 26 <URL:#tn=    14.26  Java version 26> <URL:#tn=    14.26  Java version 26 <URL:#tn=    14.26  Java version 26>>
    14.27  Java version 27 <URL:#tn=    14.27  Java version 27> <URL:#tn=    14.27  Java version 27 <URL:#tn=    14.27  Java version 27>>
    14.28  Java version 28 <URL:#tn=    14.28  Java version 28> <URL:#tn=    14.28  Java version 28 <URL:#tn=    14.28  Java version 28>>
    14.29  Java version 29 <URL:#tn=    14.29  Java version 29> <URL:#tn=    14.29  Java version 29 <URL:#tn=    14.29  Java version 29>>
    14.30  Java version 30 <URL:#tn=    14.30  Java version 30> <URL:#tn=    14.30  Java version 30 <URL:#tn=    14.30  Java version 30>>
    14.31  Java version 31 <URL:#tn=    14.31  Java version 31> <URL:#tn=    14.31  Java version 31 <URL:#tn=    14.31  Java version 31>>
    14.32  Java version 32 <URL:#tn=    14.32  Java version 32> <URL:#tn=    14.32  Java version 32 <URL:#tn=    14.32  Java version 32>>
    14.33  Java version 33 <URL:#tn=    14.33  Java version 33> <URL:#tn=    14.33  Java version 33 <URL:#tn=    14.33  Java version 33>>
    14.34  Java version 34 <URL:#tn=    14.34  Java version 34> <URL:#tn=    14.34  Java version 34 <URL:#tn=    14.34  Java version 34>>
    14.35  Java version 35 <URL:#tn=    14.35  Java version 35> <URL:#tn=    14.35  Java version 35 <URL:#tn=    14.35  Java version 35>>
    14.36  Java version 36 <URL:#tn=    14.36  Java version 36> <URL:#tn=    14.36  Java version 36 <URL:#tn=    14.36  Java version 36>>
    14.37  Java version 37 <URL:#tn=    14.37  Java version 37> <URL:#tn=    14.37  Java version 37 <URL:#tn=    14.37  Java version 37>>
    14.38  Java version 38 <URL:#tn=    14.38  Java version 38> <URL:#tn=    14.38  Java version 38 <URL:#tn=    14.38  Java version 38>>
    14.39  Java version 39 <URL:#tn=    14.39  Java version 39> <URL:#tn=    14.39  Java version 39 <URL:#tn=    14.39  Java version 39>>
    14.40  Java version 40 <URL:#tn=    14.40  Java version 40> <URL:#tn=    14.40  Java version 40 <URL:#tn=    14.40  Java version 40>>
    14.41  Java version 41 <URL:#tn=    14.41  Java version 41> <URL:#tn=    14.41  Java version 41 <URL:#tn=    14.41  Java version 41>>
15. multithreading, tags: multithreading <URL:#tn=15. multithreading, tags: multithreading> <URL:#tn=15. multithreading, tags: multithreading <URL:#tn=15. multithreading, tags: multithreading>>
    15.1 Multithreading in java , threading, threads, parallelization, concurrency , tags: Multithreading in java , threading, threads, parallelization, concurrency <URL:#tn=    15.1 Multithreading in java , threading, threads, parallelization, concurrency , tags: Multithreading in java , threading, threads, parallelization, concurrency> <URL:#tn=    15.1 Multithreading in java , threading, threads, parallelization, concurrency , tags: Multithreading in java , threading, threads, parallelization, concurrency <URL:#tn=    15.1 Multithreading in java , threading, threads, parallelization, concurrency , tags: Multithreading in java , threading, threads, parallelization, concurrency>>
        15.1.1 https://www.geeksforgeeks.org/java-multithreading-tutorial/ <URL:#tn=        15.1.1 https://www.geeksforgeeks.org/java-multithreading-tutorial/> <URL:#tn=        15.1.1 https://www.geeksforgeeks.org/java-multithreading-tutorial/ <URL:#tn=        15.1.1 https://www.geeksforgeeks.org/java-multithreading-tutorial/>>
            15.1.1.1 Using Thread Class <URL:#tn=            15.1.1.1 Using Thread Class> <URL:#tn=            15.1.1.1 Using Thread Class <URL:#tn=            15.1.1.1 Using Thread Class>>
            15.1.1.2 Using Runnable Interface <URL:#tn=            15.1.1.2 Using Runnable Interface> <URL:#tn=            15.1.1.2 Using Runnable Interface <URL:#tn=            15.1.1.2 Using Runnable Interface>>
            15.1.1.3 Thread methods <URL:#tn=            15.1.1.3 Thread methods> <URL:#tn=            15.1.1.3 Thread methods <URL:#tn=            15.1.1.3 Thread methods>>
                15.1.1.3.1  Sleep <URL:#tn=                15.1.1.3.1  Sleep> <URL:#tn=                15.1.1.3.1  Sleep <URL:#tn=                15.1.1.3.1  Sleep>>
                15.1.1.3.2 start <URL:#tn=                15.1.1.3.2 start> <URL:#tn=                15.1.1.3.2 start <URL:#tn=                15.1.1.3.2 start>>
                15.1.1.3.3 suspend <URL:#tn=                15.1.1.3.3 suspend> <URL:#tn=                15.1.1.3.3 suspend <URL:#tn=                15.1.1.3.3 suspend>>
                15.1.1.3.4 stop <URL:#tn=                15.1.1.3.4 stop> <URL:#tn=                15.1.1.3.4 stop <URL:#tn=                15.1.1.3.4 stop>>
                15.1.1.3.5 wait() <URL:#tn=                15.1.1.3.5 wait()> <URL:#tn=                15.1.1.3.5 wait() <URL:#tn=                15.1.1.3.5 wait()>>
                15.1.1.3.6 notify, notifyAll <URL:#tn=                15.1.1.3.6 notify, notifyAll> <URL:#tn=                15.1.1.3.6 notify, notifyAll <URL:#tn=                15.1.1.3.6 notify, notifyAll>>
                15.1.1.3.7 <URL:#tn=                15.1.1.3.7> <URL:#tn=                15.1.1.3.7 <URL:#tn=                15.1.1.3.7>>
            15.1.1.4 Priorities in threads, , tags: Priorities in threads <URL:#tn=            15.1.1.4 Priorities in threads, , tags: Priorities in threads> <URL:#tn=            15.1.1.4 Priorities in threads, , tags: Priorities in threads <URL:#tn=            15.1.1.4 Priorities in threads, , tags: Priorities in threads>>
            15.1.1.5 daemon threads <URL:#tn=            15.1.1.5 daemon threads> <URL:#tn=            15.1.1.5 daemon threads <URL:#tn=            15.1.1.5 daemon threads>>
            15.1.1.6 <URL:#tn=            15.1.1.6> <URL:#tn=            15.1.1.6 <URL:#tn=            15.1.1.6>>
        15.1.2 Thread lifecycle and state-machine <URL:#tn=        15.1.2 Thread lifecycle and state-machine> <URL:#tn=        15.1.2 Thread lifecycle and state-machine <URL:#tn=        15.1.2 Thread lifecycle and state-machine>>
        15.1.3 <URL:#tn=        15.1.3> <URL:#tn=        15.1.3 <URL:#tn=        15.1.3>>
    15.2 <URL:#tn=    15.2> <URL:#tn=    15.2 <URL:#tn=    15.2>>
16. jackson <URL:#tn=16. jackson> <URL:#tn=16. jackson <URL:#tn=16. jackson>>
    16.1 highlevel overview <URL:#tn=    16.1 highlevel overview> <URL:#tn=    16.1 highlevel overview <URL:#tn=    16.1 highlevel overview>>
    16.2 ObjectMapper <URL:#tn=    16.2 ObjectMapper> <URL:#tn=    16.2 ObjectMapper <URL:#tn=    16.2 ObjectMapper>>
        16.2.1 valueToTree <URL:#tn=        16.2.1 valueToTree> <URL:#tn=        16.2.1 valueToTree <URL:#tn=        16.2.1 valueToTree>>
        16.2.2 JsonNode traversal <URL:#tn=        16.2.2 JsonNode traversal> <URL:#tn=        16.2.2 JsonNode traversal <URL:#tn=        16.2.2 JsonNode traversal>>
        16.2.3 DFS traversal of JsonNode <URL:#tn=        16.2.3 DFS traversal of JsonNode> <URL:#tn=        16.2.3 DFS traversal of JsonNode <URL:#tn=        16.2.3 DFS traversal of JsonNode>>
        16.2.4 <URL:#tn=        16.2.4> <URL:#tn=        16.2.4 <URL:#tn=        16.2.4>>
    16.3 <URL:#tn=    16.3> <URL:#tn=    16.3 <URL:#tn=    16.3>>
17. java collections, tags:  java collections <URL:#tn=17. java collections, tags:  java collections> <URL:#tn=17. java collections, tags:  java collections <URL:#tn=17. java collections, tags:  java collections>>
    17.1 java Collections.singletonList <URL:#tn=    17.1 java Collections.singletonList> <URL:#tn=    17.1 java Collections.singletonList <URL:#tn=    17.1 java Collections.singletonList>>
    17.2 <URL:#tn=    17.2> <URL:#tn=    17.2 <URL:#tn=    17.2>>
18. <URL:#tn=18.> <URL:#tn=18. <URL:#tn=18.>>
1. spring <URL:#tn=1. spring>
    1.1 tutorial <URL:#tn=    1.1 tutorial>
        1.1.1  IDE, intellij <URL:#tn=        1.1.1  IDE, intellij>
        1.1.2 Key concepts / files <URL:#tn=        1.1.2 Key concepts / files>
            1.1.2.1 dependency Injection <URL:#tn=            1.1.2.1 dependency Injection>
            1.1.2.2 Spring configuration file, usually spring.xml <URL:#tn=            1.1.2.2 Spring configuration file, usually spring.xml>
            1.1.2.3 main application <URL:#tn=            1.1.2.3 main application>
                1.1.2.3.1 example of BeanFactory, ApplicationContext, AbstractApplicationContext, getting beans and wiring to HTTP requests <URL:#tn=                1.1.2.3.1 example of BeanFactory, ApplicationContext, AbstractApplicationContext, getting beans and wiring to HTTP requests>
                1.1.2.3.2 <URL:#tn=                1.1.2.3.2>
            1.1.2.4 beans <URL:#tn=            1.1.2.4 beans>
                1.1.2.4.1 example, simple bean <URL:#tn=                1.1.2.4.1 example, simple bean>
                1.1.2.4.2 Bean that is ApplicationContext and name aware , also has init and cleanup callbacks <URL:#tn=                1.1.2.4.2 Bean that is ApplicationContext and name aware , also has init and cleanup callbacks>
                1.1.2.4.3 Bean that is InitializingBean and DisposableBean, also contains a container member field <URL:#tn=                1.1.2.4.3 Bean that is InitializingBean and DisposableBean, also contains a container member field>
                1.1.2.4.4 BeanPostProcessor <URL:#tn=                1.1.2.4.4 BeanPostProcessor>
                1.1.2.4.5 code to interface example <URL:#tn=                1.1.2.4.5 code to interface example>
                    1.1.2.4.5.1  animal interface <URL:#tn=                    1.1.2.4.5.1  animal interface>
                    1.1.2.4.5.2 animals: cat, dog, horse <URL:#tn=                    1.1.2.4.5.2 animals: cat, dog, horse>
                1.1.2.4.6 Internationalization and application resources <URL:#tn=                1.1.2.4.6 Internationalization and application resources>
                1.1.2.4.7 Events <URL:#tn=                1.1.2.4.7 Events>
                    1.1.2.4.7.1 GeneralEvtListener <URL:#tn=                    1.1.2.4.7.1 GeneralEvtListener>
                    1.1.2.4.7.2 ToStringEvt <URL:#tn=                    1.1.2.4.7.2 ToStringEvt>
                    1.1.2.4.7.3 publish custom events <URL:#tn=                    1.1.2.4.7.3 publish custom events>
                    1.1.2.4.7.4 <URL:#tn=                    1.1.2.4.7.4>
                1.1.2.4.8 <URL:#tn=                1.1.2.4.8>
            1.1.2.5 <URL:#tn=            1.1.2.5>
        1.1.3 <URL:#tn=        1.1.3>
    1.2 database <URL:#tn=    1.2 database>
        1.2.1  database connections <URL:#tn=        1.2.1  database connections>
            1.2.1.1    database connections pools <URL:#tn=            1.2.1.1    database connections pools>
                1.2.1.1.1    Apache Commons DBCP <URL:#tn=                1.2.1.1.1    Apache Commons DBCP>
                1.2.1.1.2 HikariCP <URL:#tn=                1.2.1.1.2 HikariCP>
                1.2.1.1.3 C3PO <URL:#tn=                1.2.1.1.3 C3PO>
                1.2.1.1.4 A Simple Implementation <URL:#tn=                1.2.1.1.4 A Simple Implementation>
            1.2.1.2 <URL:#tn=            1.2.1.2>
        1.2.2 <URL:#tn=        1.2.2>
    1.3 chatgpt <URL:#tn=    1.3 chatgpt>
        1.3.1  q. what is spring-boot-starter-webflux <URL:#tn=        1.3.1  q. what is spring-boot-starter-webflux>
        1.3.2 q. explain the basics of setting up a reactive web application using <URL:#tn=        1.3.2 q. explain the basics of setting up a reactive web application using>
        1.3.3 q. example using maven and postgress DB <URL:#tn=        1.3.3 q. example using maven and postgress DB>
        1.3.4 use JDBC instead of JPA <URL:#tn=        1.3.4 use JDBC instead of JPA>
        1.3.5 explain java org.springframework.context.annotation.Profile <URL:#tn=        1.3.5 explain java org.springframework.context.annotation.Profile>
1. Defining Profiles: Profiles are defined using the `@Profile` annotation at the class or method level. You can assign one or more profile names to the annotation. For example: <URL:#tn=1. Defining Profiles: Profiles are defined using the `@Profile` annotation at the class or method level. You can assign one or more profile names to the annotation. For example:>
2. Activating Profiles: Profiles can be activated in various ways, depending on your application's setup. Here are a few common methods: <URL:#tn=2. Activating Profiles: Profiles can be activated in various ways, depending on your application's setup. Here are a few common methods:>
3. Conditional Bean Creation: The `@Profile` annotation can also be used to conditionally create beans based on profiles. By annotating a bean definition or `@Configuration` class with `@Profile`, the bean(s) will only be created when the specified profile is active. For example: <URL:#tn=3. Conditional Bean Creation: The `@Profile` annotation can also be used to conditionally create beans based on profiles. By annotating a bean definition or `@Configuration` class with `@Profile`, the bean(s) will only be created when the specified profile is active. For example:>
        1.3.6 is there a spring framework DataSource class or interface <URL:#tn=        1.3.6 is there a spring framework DataSource class or interface>
        1.3.7 explain org.springframework.jdbc.core.JdbcTemplate <URL:#tn=        1.3.7 explain org.springframework.jdbc.core.JdbcTemplate>
1. Database Operations: The `JdbcTemplate` class provides methods for executing various types of SQL operations, such as updates, inserts, deletes, and selects. These methods handle all the necessary details, including acquiring and releasing database connections, executing SQL statements, binding parameters, and processing result sets. <URL:#tn=1. Database Operations: The `JdbcTemplate` class provides methods for executing various types of SQL operations, such as updates, inserts, deletes, and selects. These methods handle all the necessary details, including acquiring and releasing database connections, executing SQL statements, binding parameters, and processing result sets.>
2. Exception Handling: The `JdbcTemplate` class handles SQLExceptions that occur during database operations and wraps them in more meaningful and standardized Spring exceptions, such as `DataAccessException`. This simplifies error handling and allows for consistent exception handling across different database operations. <URL:#tn=2. Exception Handling: The `JdbcTemplate` class handles SQLExceptions that occur during database operations and wraps them in more meaningful and standardized Spring exceptions, such as `DataAccessException`. This simplifies error handling and allows for consistent exception handling across different database operations.>
3. PreparedStatement Creation: The `JdbcTemplate` class can create `PreparedStatement` objects for executing SQL statements with bound parameters. It automatically handles the preparation of the statement and sets the appropriate parameter values based on the provided arguments. <URL:#tn=3. PreparedStatement Creation: The `JdbcTemplate` class can create `PreparedStatement` objects for executing SQL statements with bound parameters. It automatically handles the preparation of the statement and sets the appropriate parameter values based on the provided arguments.>
4. ResultSet Processing: The `JdbcTemplate` class provides methods for processing `ResultSet` objects returned from SELECT queries. It simplifies the process of iterating over the result set, extracting data, and mapping it to Java objects or data structures. <URL:#tn=4. ResultSet Processing: The `JdbcTemplate` class provides methods for processing `ResultSet` objects returned from SELECT queries. It simplifies the process of iterating over the result set, extracting data, and mapping it to Java objects or data structures.>
5. Batch Updates: The `JdbcTemplate` class supports batch updates, allowing you to execute multiple SQL statements as a single batch. This can significantly improve performance when dealing with multiple database operations. <URL:#tn=5. Batch Updates: The `JdbcTemplate` class supports batch updates, allowing you to execute multiple SQL statements as a single batch. This can significantly improve performance when dealing with multiple database operations.>
6. Exception Translation: The `JdbcTemplate` class integrates with Spring's `SQLExceptionTranslator` mechanism, which translates database-specific SQL exceptions into Spring's standardized `DataAccessException` hierarchy. This helps to abstract away the database-specific exception handling and provides a consistent exception model. <URL:#tn=6. Exception Translation: The `JdbcTemplate` class integrates with Spring's `SQLExceptionTranslator` mechanism, which translates database-specific SQL exceptions into Spring's standardized `DataAccessException` hierarchy. This helps to abstract away the database-specific exception handling and provides a consistent exception model.>
7. Callback Mechanism: The `JdbcTemplate` class supports a callback mechanism through the use of various callback interfaces. These interfaces, such as `PreparedStatementCreator`, `PreparedStatementSetter`, `RowMapper`, and others, allow you to customize the behavior of database operations and provide more flexibility in handling SQL statements and result sets. <URL:#tn=7. Callback Mechanism: The `JdbcTemplate` class supports a callback mechanism through the use of various callback interfaces. These interfaces, such as `PreparedStatementCreator`, `PreparedStatementSetter`, `RowMapper`, and others, allow you to customize the behavior of database operations and provide more flexibility in handling SQL statements and result sets.>
        1.3.8 explain  org.springframework.beans.factory.annotation.Qualifier <URL:#tn=        1.3.8 explain  org.springframework.beans.factory.annotation.Qualifier>
1. Define Bean Qualifiers: In the application context, when defining multiple beans of the same type, you can assign a unique qualifier value using the `@Qualifier` annotation. For example: <URL:#tn=1. Define Bean Qualifiers: In the application context, when defining multiple beans of the same type, you can assign a unique qualifier value using the `@Qualifier` annotation. For example:>
2. Use `@Qualifier` for Dependency Injection: In the dependent class or component, you can use the `@Qualifier` annotation along with `@Autowired` to specify which bean should be injected. For example: <URL:#tn=2. Use `@Qualifier` for Dependency Injection: In the dependent class or component, you can use the `@Qualifier` annotation along with `@Autowired` to specify which bean should be injected. For example:>
        1.3.9 <URL:#tn=        1.3.9>
    1.4 <URL:#tn=    1.4>
2. general <URL:#tn=2. general>
    2.1. manipulate jar files. <URL:#tn=    2.1. manipulate jar files.>
    2.2. remote debug java application. <URL:#tn=    2.2. remote debug java application.>
    2.3. deploy JSP pages to web container. <URL:#tn=    2.3. deploy JSP pages to web container.>
    2.4. Tomcat <URL:#tn=    2.4. Tomcat>
	1. listen port and shutdown port are defined in server.xml. <URL:#tn=	1. listen port and shutdown port are defined in server.xml.>
    2.5.  Reverse engineer. <URL:#tn=    2.5.  Reverse engineer.>
    2.6 Set java version, toggle java versions, switch jdk versions <URL:#tn=    2.6 Set java version, toggle java versions, switch jdk versions>
        2.6.1 mac, OS X <URL:#tn=        2.6.1 mac, OS X>
    14.0.2, x86_64:	"OpenJDK 14.0.2"	/Library/Java/JavaVirtualMachines/openjdk-14.0.2.jdk/Contents/Home <URL:#tn=    14.0.2, x86_64:	"OpenJDK 14.0.2"	/Library/Java/JavaVirtualMachines/openjdk-14.0.2.jdk/Contents/Home>
    10.0.2, x86_64:	"Java SE 10.0.2"	/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home <URL:#tn=    10.0.2, x86_64:	"Java SE 10.0.2"	/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home>
    1.8.0_265, x86_64:	"AdoptOpenJDK 8"	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home <URL:#tn=    1.8.0_265, x86_64:	"AdoptOpenJDK 8"	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home>
    1.8.0_241, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home <URL:#tn=    1.8.0_241, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home>
    13.0.1, x86_64:	"OpenJDK 13.0.1"	/Library/Java/JavaVirtualMachines/openjdk-13.0.1.jdk/Contents/Home <URL:#tn=    13.0.1, x86_64:	"OpenJDK 13.0.1"	/Library/Java/JavaVirtualMachines/openjdk-13.0.1.jdk/Contents/Home>
    10.0.2, x86_64:	"Java SE 10.0.2"	/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home <URL:#tn=    10.0.2, x86_64:	"Java SE 10.0.2"	/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home>
    1.8.0_241, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home <URL:#tn=    1.8.0_241, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home>
    1.8.0_232, x86_64:	"AdoptOpenJDK 8"	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home <URL:#tn=    1.8.0_232, x86_64:	"AdoptOpenJDK 8"	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home>
    2.7 chatgpt <URL:#tn=    2.7 chatgpt>
        2.7.1 java set data structure, tags: java set data structure <URL:#tn=        2.7.1 java set data structure, tags: java set data structure>
        2.7.2  java Files  , tags: java Files <URL:#tn=        2.7.2  java Files  , tags: java Files>
        2.7.3 java Objects.requireNonNull , tags: java Objects.requireNonNull <URL:#tn=        2.7.3 java Objects.requireNonNull , tags: java Objects.requireNonNull>
        2.7.4 java File.toPath() , tags: java File.toPath() <URL:#tn=        2.7.4 java File.toPath() , tags: java File.toPath()>
        2.7.5 java use class loader to read a file that contains a sql statement and then run it on a PG DB , tags: java use class loader to read a file that contains a sql statement and then run it on a PG DB <URL:#tn=        2.7.5 java use class loader to read a file that contains a sql statement and then run it on a PG DB , tags: java use class loader to read a file that contains a sql statement and then run it on a PG DB>
        2.7.6 java org.stringtemplate.v4.ST , tags: java org.stringtemplate.v4.ST <URL:#tn=        2.7.6 java org.stringtemplate.v4.ST , tags: java org.stringtemplate.v4.ST>
        2.7.7 java StringBuilder, tags: java StringBuilder <URL:#tn=        2.7.7 java StringBuilder, tags: java StringBuilder>
        2.7.8 java jackson @JsonCreator annotation, tags: java jackson @JsonCreator annotation <URL:#tn=        2.7.8 java jackson @JsonCreator annotation, tags: java jackson @JsonCreator annotation>
        2.7.9 how to read an array property into a List<String> in a @JsonCreator annotated class constructor, tags: how to read an array property into a List<String> in a @JsonCreator annotated class constructor <URL:#tn=        2.7.9 how to read an array property into a List<String> in a @JsonCreator annotated class constructor, tags: how to read an array property into a List<String> in a @JsonCreator annotated class constructor>
        2.7.10 <URL:#tn=        2.7.10>
    2.8 <URL:#tn=    2.8>
3.  IDE, intellij <URL:#tn=3.  IDE, intellij>
    3.1   VIM plugin <URL:#tn=    3.1   VIM plugin>
    3.2   Code generation <URL:#tn=    3.2   Code generation>
        3.2.1    generate getters and setters <URL:#tn=        3.2.1    generate getters and setters>
        3.2.2 <URL:#tn=        3.2.2>
    3.3 <URL:#tn=    3.3>
4. Build java projects <URL:#tn=4. Build java projects>
    4.1 Build java projects with maven <URL:#tn=    4.1 Build java projects with maven>
        4.1.1 Build java projects with maven spring tutorial <URL:#tn=        4.1.1 Build java projects with maven spring tutorial>
        4.1.2 maven <URL:#tn=        4.1.2 maven>
            4.1.2.1 getting started <URL:#tn=            4.1.2.1 getting started>
                4.1.2.1.1  Create project <URL:#tn=                4.1.2.1.1  Create project>
                4.1.2.1.2 . Main phases <URL:#tn=                4.1.2.1.2 . Main phases>
                4.1.2.1.3 . Maven phase commands(Project Build Commands) <URL:#tn=                4.1.2.1.3 . Maven phase commands(Project Build Commands)>
                4.1.2.1.4  Skip running tests <URL:#tn=                4.1.2.1.4  Skip running tests>
                4.1.2.1.5 Project Site Generation <URL:#tn=                4.1.2.1.5 Project Site Generation>
                4.1.2.1.6 Code quality analysis <URL:#tn=                4.1.2.1.6 Code quality analysis>
                4.1.2.1.7 Code coverage reporting <URL:#tn=                4.1.2.1.7 Code coverage reporting>
                4.1.2.1.8 Dependency Management <URL:#tn=                4.1.2.1.8 Dependency Management>
                4.1.2.1.9 Getting Help <URL:#tn=                4.1.2.1.9 Getting Help>
            4.1.2.2 commonly use CLI <URL:#tn=            4.1.2.2 commonly use CLI>
            4.1.2.3 <URL:#tn=            4.1.2.3>
        4.1.3 <URL:#tn=        4.1.3>
    4.2 <URL:#tn=    4.2>
5. Java basics <URL:#tn=5. Java basics>
    5.1 <URL:#tn=    5.1>
6. JDK 5,6 <URL:#tn=6. JDK 5,6>
	6.1 Annotations <URL:#tn=	6.1 Annotations>
		6.1.1 Description <URL:#tn=		6.1.1 Description>
		6.1.2 Usage <URL:#tn=		6.1.2 Usage>
			6.1.2.1 Documentation <URL:#tn=			6.1.2.1 Documentation>
			6.1.2.2 Annotation Processing <URL:#tn=			6.1.2.2 Annotation Processing>
	6.2 Enums, enumaration <URL:#tn=	6.2 Enums, enumaration>
    6.3 Nested Classes <URL:#tn=    6.3 Nested Classes>
	6.2.1 Inner Class Example <URL:#tn=	6.2.1 Inner Class Example>
    6.4 generics <URL:#tn=    6.4 generics>
	6.4.1 Article: Using and Programming Generics in J2SE 5.0 <URL:#tn=	6.4.1 Article: Using and Programming Generics in J2SE 5.0>
   1. "? extends Type": Denotes a family of subtypes of type Type. This is the most useful wildcard <URL:#tn=   1. "? extends Type": Denotes a family of subtypes of type Type. This is the most useful wildcard>
   2. "? super Type": Denotes a family of supertypes of type Type <URL:#tn=   2. "? super Type": Denotes a family of supertypes of type Type>
   3. "?": Denotes the set of all types or any <URL:#tn=   3. "?": Denotes the set of all types or any>
7. Install <URL:#tn=7. Install>
	7.1 Linux <URL:#tn=	7.1 Linux>
	7.2 Mac. tags: install java MAC OSX <URL:#tn=	7.2 Mac. tags: install java MAC OSX>
	7.3 <URL:#tn=	7.3>
8. Code Snipplets <URL:#tn=8. Code Snipplets>
	8.1 Encoding, utf-8, utf-16 <URL:#tn=	8.1 Encoding, utf-8, utf-16>
	8.2 <URL:#tn=	8.2>
9. Cookbook <URL:#tn=9. Cookbook>
	9.1  Files <URL:#tn=	9.1  Files>
		9.1.1   read file content java <URL:#tn=		9.1.1   read file content java>
			9.1.1.1   Reading and writing text files <URL:#tn=			9.1.1.1   Reading and writing text files>
			9.1.1.2 BufferedReader <URL:#tn=			9.1.1.2 BufferedReader>
			9.1.1.3 <URL:#tn=			9.1.1.3>
		9.1.2 Edit files <URL:#tn=		9.1.2 Edit files>
			9.1.2.1 Java – Edit File Example, Modify File java <URL:#tn=			9.1.2.1 Java – Edit File Example, Modify File java>
			9.1.2.2 <URL:#tn=			9.1.2.2>
		9.1.3 <URL:#tn=		9.1.3>
	9.2 <URL:#tn=	9.2>
10. IDEs <URL:#tn=10. IDEs>
	10.1 Eclipse <URL:#tn=	10.1 Eclipse>
		10.1.1 Quick references <URL:#tn=		10.1.1 Quick references>
			10.1.1.1 official <URL:#tn=			10.1.1.1 official>
			10.1.1.2 <URL:#tn=			10.1.1.2>
		10.1.2 FAQ <URL:#tn=		10.1.2 FAQ>
			10.1.2.1 error log <URL:#tn=			10.1.2.1 error log>
			10.1.2.2 java.lang.UnsatisfiedLinkError: Cannot load 32-bit SWT libraries on 64-bit JVM <URL:#tn=			10.1.2.2 java.lang.UnsatisfiedLinkError: Cannot load 32-bit SWT libraries on 64-bit JVM>
			10.1.2.3 <URL:#tn=			10.1.2.3>
		10.1.3 <URL:#tn=		10.1.3>
	10.2 <URL:#tn=	10.2>
11. Server side programming <URL:#tn=11. Server side programming>
	11.1 Servlet <URL:#tn=	11.1 Servlet>
		11.1.1 Basic example & walkthrough <URL:#tn=		11.1.1 Basic example & walkthrough>
			11.1.1.1 Eclipse <URL:#tn=			11.1.1.1 Eclipse>
			11.1.1.2 <URL:#tn=			11.1.1.2>
		11.1.2 <URL:#tn=		11.1.2>
	11.2 <URL:#tn=	11.2>
12. My snippets, examples, demos <URL:#tn=12. My snippets, examples, demos>
    12.1 Performance tests <URL:#tn=    12.1 Performance tests>
        12.1.1 HashMap vs array contains <URL:#tn=        12.1.1 HashMap vs array contains>
        12.1.2 <URL:#tn=        12.1.2>
    12.2 <URL:#tn=    12.2>
13.  Memory Management <URL:#tn=13.  Memory Management>
    13.1  memsize equivalent - How to Get the Size of an Object <URL:#tn=    13.1  memsize equivalent - How to Get the Size of an Object>
        13.1.1  https://www.baeldung.com/java-size-of-object <URL:#tn=        13.1.1  https://www.baeldung.com/java-size-of-object>
2. Memory Consumption in Java <URL:#tn=2. Memory Consumption in Java>
3.2. Example Class <URL:#tn=3.2. Example Class>
        13.1.2 <URL:#tn=        13.1.2>
    13.2 <URL:#tn=    13.2>
14. Java versions main features and tools, tags: Java versions main features and tools, tags: versions main features and tools <URL:#tn=14. Java versions main features and tools, tags: Java versions main features and tools, tags: versions main features and tools>
    14.1   Java version 1 <URL:#tn=    14.1   Java version 1>
    14.2   Java version 2 <URL:#tn=    14.2   Java version 2>
    14.3   Java version 3 <URL:#tn=    14.3   Java version 3>
    14.4   Java version 4 <URL:#tn=    14.4   Java version 4>
    14.5   Java version 5 <URL:#tn=    14.5   Java version 5>
    14.6   Java version 6 <URL:#tn=    14.6   Java version 6>
    14.7   Java version 7 <URL:#tn=    14.7   Java version 7>
    14.8   Java version 8 <URL:#tn=    14.8   Java version 8>
        14.8.1    functional interfaces, tags: functional interfaces <URL:#tn=        14.8.1    functional interfaces, tags: functional interfaces>
          14.8.1.1    chatgpt, lambda expressions and functional interfaces <URL:#tn=          14.8.1.1    chatgpt, lambda expressions and functional interfaces>
        14.8.2 forEach <URL:#tn=        14.8.2 forEach>
        14.8.3 optional class , tags: optional class <URL:#tn=        14.8.3 optional class , tags: optional class>
        14.8.4 Default And Static Methods In Interfaces, tags: Default And Static Methods In Interfaces <URL:#tn=        14.8.4 Default And Static Methods In Interfaces, tags: Default And Static Methods In Interfaces>
        14.8.4 Java Stream API For Bulk Data Operations On Collections , tags: Java Stream API For Bulk Data Operations On Collections <URL:#tn=        14.8.4 Java Stream API For Bulk Data Operations On Collections , tags: Java Stream API For Bulk Data Operations On Collections>
        14.8.5 java data time API usage, tags: java data time API usage <URL:#tn=        14.8.5 java data time API usage, tags: java data time API usage>
            14.8.5.1 gpt <URL:#tn=            14.8.5.1 gpt>
            14.8.5.2 my demo <URL:#tn=            14.8.5.2 my demo>
            14.8.5.3 <URL:#tn=            14.8.5.3>
        14.8.6 Collection API Improvements, tags: Collection API Improvements <URL:#tn=        14.8.6 Collection API Improvements, tags: Collection API Improvements>
        14.8.7 Java IO Improvements <URL:#tn=        14.8.7 Java IO Improvements>
        14.8.8 Miscellaneous Core API Improvements <URL:#tn=        14.8.8 Miscellaneous Core API Improvements>
        14.8.9 Base64 Encode Decode <URL:#tn=        14.8.9 Base64 Encode Decode>
            14.8.9.1 GTP example <URL:#tn=            14.8.9.1 GTP example>
            14.8.9.2 my demo <URL:#tn=            14.8.9.2 my demo>
            14.8.9.3 <URL:#tn=            14.8.9.3>
        14.8.10 <URL:#tn=        14.8.10>
    14.10  Java version 9, tags: Java version 9 <URL:#tn=    14.10  Java version 9, tags: Java version 9>
        14.10.1  summary 9-17 <URL:#tn=        14.10.1  summary 9-17>
            14.10.1.1   other <URL:#tn=            14.10.1.1   other>
        14.10.1  REPL, jshell, tags: REPL, jshell <URL:#tn=        14.10.1  REPL, jshell, tags: REPL, jshell>
        14.10.2 Factory Methods for Immutable List, Set, Map and Map.Entry, tags: Factory Methods for Immutable List <URL:#tn=        14.10.2 Factory Methods for Immutable List, Set, Map and Map.Entry, tags: Factory Methods for Immutable List>
        14.10.3 Private methods in Interfaces <URL:#tn=        14.10.3 Private methods in Interfaces>
        14.10.4 Java 9 Module System <URL:#tn=        14.10.4 Java 9 Module System>
            14.10.4.1 GPT explanation <URL:#tn=            14.10.4.1 GPT explanation>
            14.10.4.2 https://www.baeldung.com/java-9-modularity <URL:#tn=            14.10.4.2 https://www.baeldung.com/java-9-modularity>
                14.10.4.2.1 Packages <URL:#tn=                14.10.4.2.1 Packages>
                14.10.4.2.2 resources <URL:#tn=                14.10.4.2.2 resources>
                14.10.4.2.3 Module Descriptor <URL:#tn=                14.10.4.2.3 Module Descriptor>
                14.10.4.2.4 java list-modules command <URL:#tn=                14.10.4.2.4 java list-modules command>
                14.10.4.2.5 Module Types <URL:#tn=                14.10.4.2.5 Module Types>
                14.10.4.2.6 Distribution <URL:#tn=                14.10.4.2.6 Distribution>
                14.10.4.2.7 Default Modules <URL:#tn=                14.10.4.2.7 Default Modules>
                14.10.4.2.8 Module Declarations <URL:#tn=                14.10.4.2.8 Module Declarations>
                    14.10.4.2.8.1 Requires <URL:#tn=                    14.10.4.2.8.1 Requires>
                    14.10.4.2.8.2 Requires Static <URL:#tn=                    14.10.4.2.8.2 Requires Static>
                    14.10.4.2.8.3 Requires Transitive <URL:#tn=                    14.10.4.2.8.3 Requires Transitive>
                    14.10.4.2.8.4 Exports <URL:#tn=                    14.10.4.2.8.4 Exports>
                    14.10.4.2.8.5 Exports … To <URL:#tn=                    14.10.4.2.8.5 Exports … To>
                    14.10.4.2.8.6 Uses <URL:#tn=                    14.10.4.2.8.6 Uses>
                    14.10.4.2.8.7 Provides … With <URL:#tn=                    14.10.4.2.8.7 Provides … With>
                    14.10.4.2.8.8 Open <URL:#tn=                    14.10.4.2.8.8 Open>
                    14.10.4.2.8.9 Opens <URL:#tn=                    14.10.4.2.8.9 Opens>
                    14.10.4.2.8.10 Opens … To <URL:#tn=                    14.10.4.2.8.10 Opens … To>
                    14.10.4.2.8.11 <URL:#tn=                    14.10.4.2.8.11>
                14.10.4.2.9 Command Line Options <URL:#tn=                14.10.4.2.9 Command Line Options>
                14.10.4.2.10 Visibility <URL:#tn=                14.10.4.2.10 Visibility>
                14.10.4.2.11 Putting It All Together - java modules demo, tags: Putting It All Together - java modules demo <URL:#tn=                14.10.4.2.11 Putting It All Together - java modules demo, tags: Putting It All Together - java modules demo>
                    14.10.4.2.11.1 directory structure <URL:#tn=                    14.10.4.2.11.1 directory structure>
                    14.10.4.2.11.2 first module <URL:#tn=                    14.10.4.2.11.2 first module>
                    14.10.4.2.11.3 second module <URL:#tn=                    14.10.4.2.11.3 second module>
                    14.10.4.2.11.4 build <URL:#tn=                    14.10.4.2.11.4 build>
                    14.10.4.2.11.5 Run <URL:#tn=                    14.10.4.2.11.5 Run>
                    14.10.4.2.11.6 Adding a Service <URL:#tn=                    14.10.4.2.11.6 Adding a Service>
                14.10.4.2.12 Final demo structure and code <URL:#tn=                14.10.4.2.12 Final demo structure and code>
                14.10.4.2.13 Adding Modules to the Unnamed Module <URL:#tn=                14.10.4.2.13 Adding Modules to the Unnamed Module>
                14.10.4.2.14 <URL:#tn=                14.10.4.2.14>
            14.10.4.3 <URL:#tn=            14.10.4.3>
            14.10.4.4 <URL:#tn=            14.10.4.4>
        14.10.5 Process API Improvements <URL:#tn=        14.10.5 Process API Improvements>
            14.10.5.1  chatgpt <URL:#tn=            14.10.5.1  chatgpt>
            14.10.5.2 demo <URL:#tn=            14.10.5.2 demo>
            14.10.5.3  try-with-resources statement <URL:#tn=            14.10.5.3  try-with-resources statement>
                14.10.5.3.1   explanation <URL:#tn=                14.10.5.3.1   explanation>
                14.10.5.3.2 demo <URL:#tn=                14.10.5.3.2 demo>
                14.10.5.3.3 <URL:#tn=                14.10.5.3.3>
        14.10.6 CompletableFuture API Improvements in java 9 <URL:#tn=        14.10.6 CompletableFuture API Improvements in java 9>
            14.10.6.1  GPT <URL:#tn=            14.10.6.1  GPT>
            14.10.6.2 GTP demo <URL:#tn=            14.10.6.2 GTP demo>
            14.10.6.3 my demo <URL:#tn=            14.10.6.3 my demo>
            14.10.6.4 <URL:#tn=            14.10.6.4>
        14.10.7 java 9 reactive streams <URL:#tn=        14.10.7 java 9 reactive streams>
            14.10.7.1 https://www.baeldung.com/java-9-reactive-streams <URL:#tn=            14.10.7.1 https://www.baeldung.com/java-9-reactive-streams>
                14.10.7.1.1 Overview <URL:#tn=                14.10.7.1.1 Overview>
                14.10.7.1.2 Reactive API Overview <URL:#tn=                14.10.7.1.2 Reactive API Overview>
                14.10.7.1.3 Publishing and Consuming Messages <URL:#tn=                14.10.7.1.3 Publishing and Consuming Messages>
                14.10.7.1.4 <URL:#tn=                14.10.7.1.4>
            14.10.7.2 chatgpt <URL:#tn=            14.10.7.2 chatgpt>
            14.10.7.3 <URL:#tn=            14.10.7.3>
        14.10.8 Diamond Operator for Anonymous Inner Class <URL:#tn=        14.10.8 Diamond Operator for Anonymous Inner Class>
        14.10.9 Optional Class Improvements <URL:#tn=        14.10.9 Optional Class Improvements>
        14.10.10 Stream API Improvements <URL:#tn=        14.10.10 Stream API Improvements>
        14.10.11 Enhanced @Deprecated annotation <URL:#tn=        14.10.11 Enhanced @Deprecated annotation>
        14.10.12 HTTP 2 Client <URL:#tn=        14.10.12 HTTP 2 Client>
        14.10.13 Multi-Resolution Image API <URL:#tn=        14.10.13 Multi-Resolution Image API>
        14.10.14 Miscellaneous Java 9 Features <URL:#tn=        14.10.14 Miscellaneous Java 9 Features>
        14.10.15 <URL:#tn=        14.10.15>
    14.11  Java version 10, tags: Java version 10 <URL:#tn=    14.11  Java version 10, tags: Java version 10>
        14.11.1   https://javagoal.com/java-10-features/ <URL:#tn=        14.11.1   https://javagoal.com/java-10-features/>
            14.11.1.1   Java 10 Features <URL:#tn=            14.11.1.1   Java 10 Features>
            14.11.1.2 Local Variable Type Inference <URL:#tn=            14.11.1.2 Local Variable Type Inference>
            14.11.1.3 <URL:#tn=            14.11.1.3>
        14.11.2 <URL:#tn=        14.11.2>
    14.11  Java version 11 <URL:#tn=    14.11  Java version 11>
    14.12  Java version 12 <URL:#tn=    14.12  Java version 12>
    14.13  Java version 13 <URL:#tn=    14.13  Java version 13>
    14.14  Java version 14 <URL:#tn=    14.14  Java version 14>
    14.15  Java version 15 <URL:#tn=    14.15  Java version 15>
    14.16  Java version 16 <URL:#tn=    14.16  Java version 16>
    14.17  Java version 17 <URL:#tn=    14.17  Java version 17>
        14.17.1  Java 17 vs Java 8 <URL:#tn=        14.17.1  Java 17 vs Java 8>
            14.17.1.1  https://pretius.com/blog/java-17-features/ <URL:#tn=            14.17.1.1  https://pretius.com/blog/java-17-features/>
            14.17.1.2 <URL:#tn=            14.17.1.2>
        14.17.2 <URL:#tn=        14.17.2>
    14.18  Java version 18 <URL:#tn=    14.18  Java version 18>
    14.19  Java version 19 <URL:#tn=    14.19  Java version 19>
    14.20  Java version 20 <URL:#tn=    14.20  Java version 20>
    14.21  Java version 21 <URL:#tn=    14.21  Java version 21>
    14.22  Java version 22 <URL:#tn=    14.22  Java version 22>
    14.23  Java version 23 <URL:#tn=    14.23  Java version 23>
    14.24  Java version 24 <URL:#tn=    14.24  Java version 24>
    14.25  Java version 25 <URL:#tn=    14.25  Java version 25>
    14.26  Java version 26 <URL:#tn=    14.26  Java version 26>
    14.27  Java version 27 <URL:#tn=    14.27  Java version 27>
    14.28  Java version 28 <URL:#tn=    14.28  Java version 28>
    14.29  Java version 29 <URL:#tn=    14.29  Java version 29>
    14.30  Java version 30 <URL:#tn=    14.30  Java version 30>
    14.31  Java version 31 <URL:#tn=    14.31  Java version 31>
    14.32  Java version 32 <URL:#tn=    14.32  Java version 32>
    14.33  Java version 33 <URL:#tn=    14.33  Java version 33>
    14.34  Java version 34 <URL:#tn=    14.34  Java version 34>
    14.35  Java version 35 <URL:#tn=    14.35  Java version 35>
    14.36  Java version 36 <URL:#tn=    14.36  Java version 36>
    14.37  Java version 37 <URL:#tn=    14.37  Java version 37>
    14.38  Java version 38 <URL:#tn=    14.38  Java version 38>
    14.39  Java version 39 <URL:#tn=    14.39  Java version 39>
    14.40  Java version 40 <URL:#tn=    14.40  Java version 40>
    14.41  Java version 41 <URL:#tn=    14.41  Java version 41>
15. multithreading, tags: multithreading <URL:#tn=15. multithreading, tags: multithreading>
    15.1 Multithreading in java , threading, threads, parallelization, concurrency , tags: Multithreading in java , threading, threads, parallelization, concurrency <URL:#tn=    15.1 Multithreading in java , threading, threads, parallelization, concurrency , tags: Multithreading in java , threading, threads, parallelization, concurrency>
        15.1.1 https://www.geeksforgeeks.org/java-multithreading-tutorial/ <URL:#tn=        15.1.1 https://www.geeksforgeeks.org/java-multithreading-tutorial/>
            15.1.1.1 Using Thread Class <URL:#tn=            15.1.1.1 Using Thread Class>
            15.1.1.2 Using Runnable Interface <URL:#tn=            15.1.1.2 Using Runnable Interface>
            15.1.1.3 Thread methods <URL:#tn=            15.1.1.3 Thread methods>
                15.1.1.3.1  Sleep <URL:#tn=                15.1.1.3.1  Sleep>
                15.1.1.3.2 start <URL:#tn=                15.1.1.3.2 start>
                15.1.1.3.3 suspend <URL:#tn=                15.1.1.3.3 suspend>
                15.1.1.3.4 stop <URL:#tn=                15.1.1.3.4 stop>
                15.1.1.3.5 wait() <URL:#tn=                15.1.1.3.5 wait()>
                15.1.1.3.6 notify, notifyAll <URL:#tn=                15.1.1.3.6 notify, notifyAll>
                15.1.1.3.7 <URL:#tn=                15.1.1.3.7>
            15.1.1.4 Priorities in threads, , tags: Priorities in threads <URL:#tn=            15.1.1.4 Priorities in threads, , tags: Priorities in threads>
            15.1.1.5 daemon threads <URL:#tn=            15.1.1.5 daemon threads>
            15.1.1.6 <URL:#tn=            15.1.1.6>
        15.1.2 Thread lifecycle and state-machine <URL:#tn=        15.1.2 Thread lifecycle and state-machine>
        15.1.3 <URL:#tn=        15.1.3>
    15.2 <URL:#tn=    15.2>
16. jackson <URL:#tn=16. jackson>
    16.1 highlevel overview <URL:#tn=    16.1 highlevel overview>
    16.2 ObjectMapper <URL:#tn=    16.2 ObjectMapper>
        16.2.1 valueToTree <URL:#tn=        16.2.1 valueToTree>
        16.2.2 JsonNode traversal <URL:#tn=        16.2.2 JsonNode traversal>
        16.2.3 DFS traversal of JsonNode <URL:#tn=        16.2.3 DFS traversal of JsonNode>
        16.2.4 <URL:#tn=        16.2.4>
    16.3 <URL:#tn=    16.3>
17. java collections, tags:  java collections <URL:#tn=17. java collections, tags:  java collections>
    17.1 java Collections.singletonList <URL:#tn=    17.1 java Collections.singletonList>
    17.2 <URL:#tn=    17.2>
18.  chatgpt, tags: chatgpt <URL:#tn=18.  chatgpt, tags: chatgpt>
    18.1   java 17 load integer env var , tags: java 17 load integer env var <URL:#tn=    18.1   java 17 load integer env var , tags: java 17 load integer env var>
    18.2 <URL:#tn=    18.2>
19. SSL and TLS, tags: and TLS <URL:#tn=19. SSL and TLS, tags: and TLS>
    19.1 chatgpt <URL:#tn=    19.1 chatgpt>
        19.1.1 java establish ssl client connection with sslmode verify-full  also explain how to send client certificate and key and validate server certificate <URL:#tn=        19.1.1 java establish ssl client connection with sslmode verify-full  also explain how to send client certificate and key and validate server certificate>
    19.2 <URL:#tn=    19.2>
20. <URL:#tn=20.>
.................................................END TOC..............................................

















Description: 	Java related knowledge.
Author:		Yosi Izaq.

1. spring 

    1.1 tutorial

        1.1.1  IDE, intellij

        1.1.2 Key concepts / files

            1.1.2.1 dependency Injection
decouples the dependencies between classes so that spring Framework would be responsibile for constructing required java classes (beans)

            1.1.2.2 Spring configuration file, usually spring.xml
ex:


<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"
       default-init-method="myInit" default-destroy-method="myDestroy">
    <!-- define the default init/destroy methods for all beans. if they are implemented they will be called -->

    <!-- note that by defaults all beans have singelton scope. meaning appCtxt.getBean()
    will return reference to same singelton instance (that was created when app context is created)
    another scope is 'prototype', in which case getBean() will create and return a new instance every time it is called
    (lazy initialization)
    There also web scopes. Request (new bean per HTTP req) / Session (new bean per HTTP session) / Global session (new bean per global session)
    singelton is the default


    -->
    <bean id="demoRootBean"  class="com.example.springbootdemo.DemoBean"  > <!-- demonstrate bean inheritance -->
        <property name="id" value="999" /> <!-- invoke setter -->
    </bean>
    <bean id="demoBean" class="com.example.springbootdemo.DemoBean" scope="prototype">
        <property name="id" value="999" /> <!-- invoke setter -->
        <constructor-arg value="A_Bean" /> <!-- provide CTOR w/ 1st args vals -->
        <constructor-arg type="int" value="10" /> <!-- provide CTOR w/ 2nd arg. use type to specify type -->
        <constructor-arg index="2" value=", that demonstrate spring beans creation" /> <!-- provide CTOR w/ 3rd arg.
        use index to specify index in argument list -->
    </bean>
    <bean id="demoChildBean" class="com.example.springbootdemo.DemoBean" parent="demoRootBean">
        <constructor-arg value="A_Bean" /> <!-- provide CTOR w/ 1st args vals -->
        <constructor-arg type="int" value="10" /> <!-- provide CTOR w/ 2nd arg. use type to specify type -->
        <constructor-arg index="2" value=", that demonstrate spring beans creation" /> <!-- provide CTOR w/ 3rd arg.
        use index to specify index in argument list -->
    </bean>
    <bean id="triangle" class="com.example.springbootdemo.Triangle" name="triangle3" init-method="myInit" destroy-method="myDestroy"> <!-- call CTOR w/ references to Point instance beans
    that are defined below
    also note name serves as another alias
    register init method -->
         <property name="point1" ref="point1Ref" /> <!--ref can refer to an id a name or an alias -->
        <property name="point2" >
            <bean class="com.example.springbootdemo.Point" >
                <property name="x" value="-20"/>
                <property name="y" value="0"/>
            </bean>
        </property>
        <property name="point3" ref="point3Ref" />
    </bean>

    <!-- demonstrate inheritence of container members. and the merge flag for adding to parent list
    rather than overwriting the list
    -->
    <bean id="pointsListParent" class="com.example.springbootdemo.Points" abstract="true"> <!-- abstract means
    that this only serves as base definition but can't be instantiated
    -->
        <property name="points">
            <list>
                <ref bean="point1Ref"/>
            </list>
        </property>
    </bean>
    <bean id="pointsListChild" class="com.example.springbootdemo.Points" parent="pointsListParent">
        <property name="points">
            <list merge="true">
                <ref bean="point2Ref"/>
                <ref bean="point3Ref"/>
            </list>
        </property>
    </bean>


    <bean id="pointsList" class="com.example.springbootdemo.Points">
        <!-- when commented out the @Required will have RequiredAnnotationBeanPostProcessor throw exception
       Caused by: org.springframework.beans.factory.BeanInitializationException: Property 'points' is required for bean 'pointsList'
        <property name="points">
            <list>
                <ref bean="point1Ref"/>
                <ref bean="point2Ref"/>
                <ref bean="point3Ref"/>
            </list>
        </property>
        -->
        <property name="points">
            <list>
                <ref bean="point1Ref"/>
                <ref bean="point2Ref"/>
                <ref bean="point3Ref"/>
            </list>
        </property>
    </bean>

    <alias name="triangle" alias="triangle2" /> <!-- alias to a bean (like a reference) -->

    <bean id="point1Ref" class="com.example.springbootdemo.Point" > <!-- external bean, can be used by any bean-->
        <property name="x" value="0"/>
        <property name="y" value="0"/>
    </bean>
    <bean id="point2Ref" class="com.example.springbootdemo.Point" >
        <property name="x" value="-20"/>
        <property name="y" value="0"/>
    </bean>
    <bean id="point3Ref" class="com.example.springbootdemo.Point" >
        <property name="x" value="+20"/>
        <property name="y" value="0"/>
    </bean>

    <!-- demonstrate auto-wiring. inject the dependencies when bean names match member variable names -->
    <bean id="triangle4" class="com.example.springbootdemo.Triangle" autowire="byName"> <!-- call CTOR w/ references to Point instance beans
    that are autotmatically populated so long as spring finds beans names that match class Triangle members
    it also possible to set autoWire "byType" which will inject a ref so long as there's one member of that type
    that matches one bean definition of matchine type
    Another option is "constructor" which is similar to byType w/ the difference that spring would try to match
    to a CTOR by type (so multiple beans of same type will not work)
    -->
    </bean>

    <bean id="point1" class="com.example.springbootdemo.Point" > <!-- external bean, can be used by any bean-->
        <property name="x" value="1"/>
        <property name="y" value="2"/>
    </bean>
    <bean id="point2" class="com.example.springbootdemo.Point" >
        <property name="x" value="3"/>
        <property name="y" value="4"/>
    </bean>
    <bean id="point3" class="com.example.springbootdemo.Point" >
        <property name="x" value="5"/>
        <property name="y" value="6"/>
    </bean>
    <bean id="point4" class="com.example.springbootdemo.Point" >
        <!-- placeholder for populating values taken from properties file -->
        <property name="x" value="${point4.x_cfg}"/>
        <property name="y" value="${point4.y_cfg}"/>
    </bean>
    <bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" >
        <property name="locations" value="application.properties" />
    </bean>
    <!-- this is a special
    BeanFactoryPostProcessor that reads from properties file and populates the placeholders w/ values
    -->

    <!-- demonstrate auto-wiring. inject the dependencies when bean names match member variable names -->


    <bean class="com.example.springbootdemo.DisplayNameBeanPostProcessor" /> <!-- spring will create an instance
    of this class so that it can function a post processor
    -->
    <bean class="com.example.springbootdemo.DemoBeanFactoryPostProcessor" />

    <!-- note that its possible to add all annotations post processors beans by adding line
    <context:annotation-config />
    -->
    <context:annotation-config />

    <!-- with <context:annotation-config /> there's no need to manually add each annotation post processor -->
    <!-- <bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor" /> --> <!-- check for
    required annotations -->
    <!-- <bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor" /> --> <!-- wire values to
    setters marked w/ @Autowire
    -->
    <!-- note that @Autowire annotation is by type => so long as there's one bean of this type
    in the spring config it will be wired correctly!
    -->


    <!-- <bean id="msgFormatter" class="com.example.springbootdemo.msgFormatter"/>  --> <!-- match by name -->
    <bean id="msgFormatter" class="com.example.springbootdemo.msgFormatter">  <!-- match by qualifier -->
        <qualifier value="PointsRelated" />
    </bean>
    <!-- note that in case of multiple
    beans w/ same type an dependancy injection failed exception is thrown. ex:
   Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'com.example.springbootdemo.msgFormatter' available: expected single matching bean but found 2: msgFmt,msgFmt1
   So, the injection algorithm for @Autowire annotation starts by injecting when single match to type exists
   otherwise it will try to match by member name if possible.
   Another way to tie the dependancy is by using a qualifier.
    -->
    <bean id="msgFmt1" class="com.example.springbootdemo.msgFormatter"/>

    <!-- demonstrating coding to interface technique in spring -->
    <bean id="horsi" class="com.example.springbootdemo.horse" >
       <property name="sound" value="${horse.sound}" />
    </bean>
    <bean id="bell" class="com.example.springbootdemo.dog" >
        <property name="sound" value="${dog.sound}" />
    </bean>
    <!-- demonstrating coding to interface technique in spring -->

    <!-- tell spring to scan for @Component annotated classes so that they would be
        loaded as beans
        Unfortunately I get an exception Caused by: javax.management.InstanceAlreadyExistsException: org.springframework.boot:type=Admin,name=SpringApplication
        so for now skip
        -->
<!--     <context:component-scan base-package="com.example.springbootdemo" /> -->

    <!-- support for i8n via class="org.springframework.context.support.ResourceBundleMessageSource"
    The ResourceBundleMessageSource will load a properties file that contains the messages
    -->
    <bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource"  >

        <property name="basenames">
           <list>
               <value> messages</value>

           </list>
        </property>
    </bean>

    <!-- register event listener bean -->
    <bean id="GeneralEvtListener" class="com.example.springbootdemo.GeneralEvtListener" >

    </bean>
</beans>



            1.1.2.3 main application

                1.1.2.3.1 example of BeanFactory, ApplicationContext, AbstractApplicationContext, getting beans and wiring to HTTP requests 
package com.example.springbootdemo;

import org.springframework.context.ApplicationContext;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.FileSystemResource;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class SpringbootDemoApplication {

    public static void main(String[] args) {

        //BeanFactory bFactory = new XmlBeanFactory( new FileSystemResource("src/main/resources/spring.xml"));
        // Note that even though there is no BeanFactory still the DemoBeanFactoryPostProcessor get called.
        //The reason is that an ApplicationContext is also a BeanFactory
        ApplicationContext  appCtxt  = new ClassPathXmlApplicationContext( "spring.xml");
        //DemoBean dBean = (DemoBean) bFactory.getBean("demoBean");
        DemoBean dBean = (DemoBean) appCtxt.getBean("demoBean");
        System.out.println(dBean.toString());

        SpringApplication.run(SpringbootDemoApplication.class, args);
        System.out.println( appCtxt.getMessage("msg1", null, "msg1 not found", null) );


    }

    @RequestMapping("hello")
    public String sayHello()
    {
        //Note that ApplicationContext is autoclosed when deployed as webapp. For desktop
        // app or when explicit shutdown handling is required use AbstractApplicationContext
        //ApplicationContext  appCtxt  = new ClassPathXmlApplicationContext( "spring.xml");
        AbstractApplicationContext appCtxt  = new ClassPathXmlApplicationContext( "spring.xml");
        appCtxt.registerShutdownHook();
        //DemoBean dBean = (DemoBean) bFactory.getBean("demoBean");
        DemoBean dBean = (DemoBean) appCtxt.getBean("demoBean");
        DemoBean dcBean = (DemoBean) appCtxt.getBean("demoChildBean");

        //Triangle triangle = (Triangle) appCtxt.getBean("triangle"); //note that all triangle dependecies (points)
        // will be initialized by spring according to spring.xml config
        Triangle triangle = (Triangle) appCtxt.getBean("triangle2"); //note that we are using an alias to triangle
        Triangle triangle4 = (Triangle) appCtxt.getBean("triangle4"); //get an auto-wired bean
        triangle.publishDemoEvent();

        Points pointsList = (Points) appCtxt.getBean("pointsList");
        Points pointsListChild = (Points) appCtxt.getBean("pointsListChild");

        //coding dependendant on implementation. not advisable!
        //horse horsi = (horse) appCtxt.getBean("horsi");
        //dog bell = (dog) appCtxt.getBean("bell");
        //coding to implementation. advisable!
        animal horsi = (animal) appCtxt.getBean("horsi");
        horse realHorse = (horse) horsi ;
        animal bell = (animal) appCtxt.getBean("bell");
        //animal mitzi = (animal) appCtxt.getBean("cat");
        //cat derivedMitzi = (cat) mitzi ;

        return  String.format("<p>Hello Spring Boot App%nDemo Bean: %s</p>%n<p>Spring Inheriting Bean= %s</p>%n" +
                        "<p>Manually defined Triangle: %s</p>%nAut0-wired Triangle: %s</p>%n" +
                        "<p>Points: %s%n Points  %s</p>%n" +
                        "<p>Points Child Bean=%s</p>%n" +
                        "<p>Animal %s . message %s</p>%n" + //horse
                        //"<p>Animal %s . message %s</p>%n" + //cat
                        "<p>Animal %s </p>%n", //dog
                dBean.toString(), dcBean.toString(),
                triangle.toString(),
                triangle4.toString(),
                pointsList.toString(),
                pointsList.getMsgFormatter().formatMsg("formated message"),
                pointsListChild.toString(),
                horsi.Classification(),
                realHorse.getMsgFormatter().formatMsg("I'm derived class, the msg formatter was injected using java @Resource annotation"),
                //mitzi.Classification(),
                //derivedMitzi.getMsgFormatter().formatMsg("I'm an annotated bean"),
                bell.Classification()
        );


    }
}


                1.1.2.3.2

            1.1.2.4 beans

                1.1.2.4.1 example, simple bean
package com.example.springbootdemo;

public class DemoBean {


    //private static int id = 0;

    private int id;
    private  String name;
    private  String message;

    public  int getId()
    {
        return  id;
    }

    public  void  setId(int id)
    {
        this.id = id;
    }

    public DemoBean()
    {
        this.name = "uninitialized";
        this.id = -1;
        this.message="uninitialized bean";
    }
    public  DemoBean(String name)
    {
        //id++;
        //m_id = id;
        this.name = name;
        System.out.printf("Created DemoBean [%s] instance [%d]%n", name, id);
    }

    public  DemoBean(String name, int id)
    {
        this.name = name;
        this.id = id;
    }

    public  DemoBean(String name, int id, String message)
    {
        this.name = name;
        this.id = id;
        this.message = message;
    }


    public String toString(){

        return  String.format("I am DemoBean [%s], instance [%d]%nMy message is %s", name, id, message);
    }
}


                1.1.2.4.2 Bean that is ApplicationContext and name aware , also has init and cleanup callbacks
package com.example.springbootdemo;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanNameAware;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
//import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.ApplicationEventPublisherAware;

//yosi.izaq. demo of using spring dependancy injection.
//Triangle will not init (new) Points.
// Neither will main init Triangle/Points
//Spring will take care of init
public class Triangle implements ApplicationEventPublisherAware, ApplicationContextAware, BeanNameAware { //this bean is now aware of spring app context

    private Point point1;
    private ApplicationContext appCtxt;
    private String beanName;

    public Point getPoint1() {
        return point1;
    }

    public void setPoint1(Point point1) {
        this.point1 = point1;
    }

    public Point getPoint2() {
        return point2;
    }

    public void setPoint2(Point point2) {
        this.point2 = point2;
    }

    public Point getPoint3() {
        return point3;
    }

    public void setPoint3(Point point3) {
        this.point3 = point3;
    }

    private Point point2;
    private Point point3;

    public Point getPoint4() {
        return point4;
    }

    public void setPoint4(Point point4) {
        this.point4 = point4;
    }

    private Point point4; //just for demo of place holders

    @Override
    public String toString() {
        return "Triangle{" +
                "point1=" + point1 +
                ", point2=" + point2 +
                ", point3=" + point3 +
                ", point4=" + point4 +
                ", beanName=" + beanName +
                '}';
    }


    public void publishDemoEvent()
    {
        //publish a toString method called event
        ToStringEvt toStringEvt = new ToStringEvt(this);
        appEvtPub.publishEvent(toStringEvt);
    }

    @Override
    public  void setApplicationContext(ApplicationContext ctxt)
            throws BeansException
    {
        appCtxt = ctxt;
    }

    @Override
public void setBeanName(String name)
    {
        beanName = name;

    }

    public  void  myInit(){
        System.out.printf("My manual init method, registerd to be called for bean initialization in spring.xml%n" );
    }

    public  void myDestroy(){
        System.out.printf("My manual cleanyp method, registerd to be called for bean destruction in spring.xml%n" );
    }

    private ApplicationEventPublisher appEvtPub;

    //Note that actually spring passes the ApplicationContext (which implements the publisher
    // interface). The consumer class uses the interface and the concrete class
    //This complies w/ Spring concept of coding to interface (thus reducing concrete dependencies)
    @Override
    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {
        appEvtPub = applicationEventPublisher;

    }
}

                1.1.2.4.3 Bean that is InitializingBean and DisposableBean, also contains a container member field
package com.example.springbootdemo;

import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Required;
import org.springframework.context.MessageSource;

import java.util.List;
import java.util.Locale;

public class Points implements InitializingBean, DisposableBean { //InitializingBean interface allow to register bean init callback
    //so afterPropertiesSet will be called upon bean init
    // DisposableBean is for bean destruction
    public List<Point> getPoints() {
        return points;
    }

    @Required //instruct spring to validate that setPoints is called, otherwise BeanPostProcessor will throw an exception
    // org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor must be registered
    //in spring config file as it is actually doing the check
    public void setPoints(List<Point> points) {
        this.points = points;
    }

    @Override
    public String toString() {
        return this.msgSrc.getMessage("pointsMsg1", null, "Points I8N intro message not found!", null)+
                //this.msgSrc.getMessage("pointsMsg2", new  Object[]  {points} ,"Points I8N intro message not found!", null ) +
                this.msgSrc.getMessage("pointsMsg2", points.toArray(new Object[0]),"Points I8N intro message not found!", Locale.GERMANY ) +
                "I8N msg: "+ this.msgSrc.getMessage("msg1", null, "I8N message not found!", null)+
                '}';
    }

    @Override
    public void afterPropertiesSet() throws Exception {

        System.out.printf("Bean Points init callback was called%n");
    }

    @Override
    public void destroy() throws Exception {
        System.out.printf("Bean Points shutdown callback was called%n");
    }

    private List<Point> points;



    public com.example.springbootdemo.msgFormatter getMsgFormatter() {
        return msgFormatter;
    }

    @Autowired
    @Qualifier("PointsRelated") //inject the bean that has this qualifier. only required when @Autowired
   // can't match by type (multiple defined) or name (none exists)
    public void setMsgFormatter(com.example.springbootdemo.msgFormatter msgFormatter) {
        this.msgFormatter = msgFormatter;
    }

    private msgFormatter msgFormatter; //just to demo @AutoWired...

    public MessageSource getMsgSrc() {
        return msgSrc;
    }

    public void setMsgSrc(MessageSource msgSrc) {
        this.msgSrc = msgSrc;
    }

    @Autowired
    private MessageSource msgSrc;
}


                1.1.2.4.4 BeanPostProcessor
package com.example.springbootdemo;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

/**
 *
implement a post process method before and after every
bean initialization
need to be registered in spring.xml
 */
public class DisplayNameBeanPostProcessor implements BeanPostProcessor {

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.printf("postProcessBeforeInitialization(Object() called for bean %s%n ", beanName);
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.printf("postProcessAfterInitialization(Object() called for bean %s%n ", beanName) ;
        return bean;
    }
}

package com.example.springbootdemo;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanFactoryPostProcessor;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;

public class DemoBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {
        System.out.printf("DemoBeanFactoryPostProcessor:postProcessBeanFactory() was called%n ");
    }
}

                1.1.2.4.5 code to interface example

                    1.1.2.4.5.1  animal interface


package com.example.springbootdemo;

/*
This interface is meant for demonstrating coding to interface technique in spring
 */
public interface animal {
    public String Classification() ; //what kind of animal are you
}

                    1.1.2.4.5.2 animals: cat, dog, horse
package com.example.springbootdemo;

import org.springframework.stereotype.Component;
import org.springframework.stereotype.Controller;
import org.springframework.stereotype.Repository;
import org.springframework.stereotype.Service;

//Component annotation tells spring to treat this class as a bean
// its equivalent to <bean></bean> clause
//however , when using this annotation, its not possible to have multiple instances of a bean of same class
@Component //bean
//MVC beans annotations
//@Service // BL (view) bean
//@Repository //data (model) bean
//@Controller //controller bean
public class cat implements animal{

    private static String classification="felis catus";

    public com.example.springbootdemo.msgFormatter getMsgFormatter() {
        return msgFormatter;
    }

    public void setMsgFormatter(com.example.springbootdemo.msgFormatter msgFormatter) {
        this.msgFormatter = msgFormatter;
    }

    private  msgFormatter msgFormatter; //note that message formatter bean will be injected according to spring config

    public String getClassification() {
        return classification;
    }

    public void setClassification(String classification) {
        this.classification = classification;
    }

    @Override
    public String Classification() {
        return classification;
    }
}

package com.example.springbootdemo;

public class dog implements  animal{
    private static  final String   classification = "canis lupus familaris";

    public String getSound() {
        return sound;
    }

    public void setSound(String sound) {
        this.sound = sound;
    }

    private String sound;

    @Override
    public String Classification() {
        return  String.format("dog classificatio is %s. %s%n", classification, sound);
    }

}

package com.example.springbootdemo;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.annotation.Resource;

public class horse implements animal{
   private static  final String   classification = "Equus caballus";

   public String getSound() {
      return sound;
   }

   public void setSound(String sound) {
      this.sound = sound;
   }

   private String sound;


   public com.example.springbootdemo.msgFormatter getMsgFormatter() {
      return msgFormatter;
   }


   //@Resource(name = "msgFormatter") //use standard java annotations to inject dependancy
   //Note that @Resource alone (w/o name) will try inject a bean that has name that matches
   // the member name. since they are same in our case we shall omit the name
   @Resource
   public void setMsgFormatter(com.example.springbootdemo.msgFormatter msgFormatter) {
      this.msgFormatter = msgFormatter;
   }

   private msgFormatter msgFormatter;

   @Override
   public String Classification() {
      return  String.format("horse classificatio is %s. %s%n", classification, sound);
   }

   //use java annotations to wire init/destroy callback
   //rather than using spring InitializingBean, DisposableBean  interfaces or specifying these callbacks
   //in spring config file
    @PostConstruct
   public void initHorse(){
       System.out.printf("horse::initHorse() called%n");
   }

   @PreDestroy
   public void destroyHorse(){
      System.out.printf("horse::destroyHorse() called%n");
   }
}

                1.1.2.4.6 Internationalization and application resources 
                application.properties:
point4.x_cfg=0
point4.y_cfg=1
horse.sound="hihiheeeeeee!"
dog.sound="woof woof!"

messages.properties, 
msg1=This is I8N message 1
pointsMsg1=This is points I8N intro!
pointsMsg2=The actual points are {0} {1}

load in spring.xml :
    <bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource"  >

wire to beans as in:
    @Autowired
    private MessageSource msgSrc;

                1.1.2.4.7 Events

                    1.1.2.4.7.1 GeneralEvtListener
package com.example.springbootdemo;

import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

//@Component
//ToDo, talk to yan. Fix the double app ctxt init error...
public class GeneralEvtListener implements ApplicationListener {

    @Override
    public void onApplicationEvent(ApplicationEvent applicationEvent) {
        System.out.println("GeneralEvtListener::onApplicationEvent() got event  "+applicationEvent.toString());
    }
}


                    1.1.2.4.7.2 ToStringEvt
package com.example.springbootdemo;

import org.springframework.context.ApplicationEvent;

public class ToStringEvt extends ApplicationEvent {

    public ToStringEvt(Object source) {
        super(source);
    }

    @Override
    public String toString() {
        return "ToStringEvt{" +
                "super toString=" + source +
                "ToStringEvt toString="+" this is a toString() called event!"+
                '}';
    }
}

                    1.1.2.4.7.3 publish custom events
                    snip:
    public void publishDemoEvent()
    {
        //publish a toString method called event
        ToStringEvt toStringEvt = new ToStringEvt(this);
        appEvtPub.publishEvent(toStringEvt);
    }

                    1.1.2.4.7.4

                1.1.2.4.8

            1.1.2.5


        1.1.3



    1.2 database

        1.2.1  database connections

            1.2.1.1    database connections pools
https://www.baeldung.com/java-connection-pooling

                1.2.1.1.1    Apache Commons DBCP
 -> Configure data source
               public class DBCPDataSource {
    
    private static BasicDataSource ds = new BasicDataSource();
    
    static {
        ds.setUrl("jdbc:h2:mem:test");
        ds.setUsername("user");
        ds.setPassword("password");
        ds.setMinIdle(5);
        ds.setMaxIdle(10);
        ds.setMaxOpenPreparedStatements(100);
    }
    
    public static Connection getConnection() throws SQLException {
        return ds.getConnection();
    }
    
    private DBCPDataSource(){ } 

    -> to get connection:
    Connection con = DBCPDataSource.getConnection();

                1.2.1.1.2 HikariCP
Performant Connection-Pool
-> Configure
public class HikariCPDataSource {
    
    private static HikariConfig config = new HikariConfig();
    private static HikariDataSource ds;
    
    static {
        config.setJdbcUrl("jdbc:h2:mem:test");
        config.setUsername("user");
        config.setPassword("password");
        config.addDataSourceProperty("cachePrepStmts", "true");
        config.addDataSourceProperty("prepStmtCacheSize", "250");
        config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048");
        ds = new HikariDataSource(config);
    }
    
    public static Connection getConnection() throws SQLException {
        return ds.getConnection();
    }
    
    private HikariCPDataSource(){}
}

-> get connection:
Connection con = HikariCPDataSource.getConnection();

                1.2.1.1.3 C3PO
Last in this review is C3PO, a powerful JDBC4 connection and statement pooling framework developed by Steve Waldman:
-> Configure data source:
public class C3poDataSource {

    private static ComboPooledDataSource cpds = new ComboPooledDataSource();

    static {
        try {
            cpds.setDriverClass("org.h2.Driver");
            cpds.setJdbcUrl("jdbc:h2:mem:test");
            cpds.setUser("user");
            cpds.setPassword("password");
        } catch (PropertyVetoException e) {
            // handle the exception
        }
    }
    
    public static Connection getConnection() throws SQLException {
        return cpds.getConnection();
    }
    
    private C3poDataSource(){}
}
-> get connection:
Connection con = C3poDataSource.getConnection();

                1.2.1.1.4 A Simple Implementation
To better understand the underlying logic of connection pooling, let's create a simple implementation.

Let's start out with a loosely-coupled design, based on just one single interface:

public interface ConnectionPool {
    Connection getConnection();
    boolean releaseConnection(Connection connection);
    String getUrl();
    String getUser();
    String getPassword();
}
The ConnectionPool interface defines the public API of a basic connection pool.

Now, let's create an implementation, which provides some basic functionality, including getting and releasing a pooled connection:


freestar
public class BasicConnectionPool 
  implements ConnectionPool {

    private String url;
    private String user;
    private String password;
    private List<Connection> connectionPool;
    private List<Connection> usedConnections = new ArrayList<>();
    private static int INITIAL_POOL_SIZE = 10;
    
    public static BasicConnectionPool create(
      String url, String user, 
      String password) throws SQLException {
 
        List<Connection> pool = new ArrayList<>(INITIAL_POOL_SIZE);
        for (int i = 0; i < INITIAL_POOL_SIZE; i++) {
            pool.add(createConnection(url, user, password));
        }
        return new BasicConnectionPool(url, user, password, pool);
    }
    
    // standard constructors
    
    @Override
    public Connection getConnection() {
        Connection connection = connectionPool
          .remove(connectionPool.size() - 1);
        usedConnections.add(connection);
        return connection;
    }
    
    @Override
    public boolean releaseConnection(Connection connection) {
        connectionPool.add(connection);
        return usedConnections.remove(connection);
    }
    
    private static Connection createConnection(
      String url, String user, String password) 
      throws SQLException {
        return DriverManager.getConnection(url, user, password);
    }
    
    public int getSize() {
        return connectionPool.size() + usedConnections.size();
    }

    // standard getters
}
While pretty naive, the BasicConnectionPool class provides the minimal functionality that we'd expect from a typical connection pooling implementation.

In a nutshell, the class initializes a connection pool based on an ArrayList that stores 10 connections, which can be easily reused.

It's possible to create JDBC connections with the DriverManager class and with Datasource implementations.

As it's much better to keep the creation of connections database agnostic, we've used the former, within the create() static factory method.

In this case, we've placed the method within the BasicConnectionPool, because this is the only implementation of the interface.

In a more complex design, with multiple ConnectionPool implementations, it'd be preferable to place it in the interface, therefore getting a more flexible design and a greater level of cohesion.

The most relevant point to stress here is that once the pool is created, connections are fetched from the pool, so there's no need to create new ones.

Furthermore, when a connection is released, it's actually returned back to the pool, so other clients can reuse it.

There's no any further interaction with the underlying database, such as an explicit call to the Connection's close() method.

->  Using the BasicConnectionPool Class
As expected, using our BasicConnectionPool class is straightforward.

Let's create a simple unit test and get a pooled in-memory H2 connection:

@Test
public whenCalledgetConnection_thenCorrect() {
    ConnectionPool connectionPool = BasicConnectionPool
      .create("jdbc:h2:mem:test", "user", "password");
 
    assertTrue(connectionPool.getConnection().isValid(1));
}
-> Further Improvements and Refactoring
Of course, there's plenty of room to tweak/extend the current functionality of our connection pooling implementation.

For instance, we could refactor the getConnection() method, and add support for maximum pool size. If all available connections are taken, and the current pool size is less than the configured maximum, the method will create a new connection.

Also, we could additionally verify whether the connection obtained from the pool is still alive, before passing it to the client.

@Override
public Connection getConnection() throws SQLException {
    if (connectionPool.isEmpty()) {
        if (usedConnections.size() < MAX_POOL_SIZE) {
            connectionPool.add(createConnection(url, user, password));
        } else {
            throw new RuntimeException(
              "Maximum pool size reached, no available connections!");
        }
    }

    Connection connection = connectionPool
      .remove(connectionPool.size() - 1);

    if(!connection.isValid(MAX_TIMEOUT)){
        connection = createConnection(url, user, password);
    }

    usedConnections.add(connection);
    return connection;
}
Note that the method now throws SQLException, meaning we'll have to update the interface signature as well.

Or, we could add a method to gracefully shut down our connection pool instance:

public void shutdown() throws SQLException {
    usedConnections.forEach(this::releaseConnection);
    for (Connection c : connectionPool) {
        c.close();
    }
    connectionPool.clear();
}
In production-ready implementations, a connection pool should provide a bunch of extra features, such as the ability for tracking the connections that are currently in use, support for prepared statement pooling, and so forth.

As we'll keep things simple, we'll omit how to implement these additional features and keep the implementation non-thread-safe for the sake of clarity.


-> Configure data source:
-> get connection:
Spring Framework JPA
            1.2.1.2

        1.2.2

    1.3 chatgpt


        1.3.1  q. what is spring-boot-starter-webflux
a. 
spring-boot-starter-webflux is a Spring Boot starter dependency that provides a set of libraries for building reactive web applications using Spring WebFlux.

Spring WebFlux is a module of the Spring Framework that provides support for building reactive web applications. Reactive programming is a programming paradigm that focuses on building asynchronous, non-blocking, and event-driven systems. With Spring WebFlux, you can build web applications that are capable of handling a large number of concurrent requests with low resource consumption.

The spring-boot-starter-webflux dependency includes the following libraries:

Spring WebFlux: Provides support for building reactive web applications.
Reactor Core: A reactive library that provides a set of classes for building asynchronous and non-blocking systems.
Jackson JSON: Provides support for working with JSON data.
Spring Boot Actuator: Provides support for monitoring and managing your application.
By including spring-boot-starter-webflux in your Spring Boot application, you can quickly set up a reactive web application with all the necessary dependencies and configurations.

        1.3.2 q. explain the basics of setting up a reactive web application using 
a.
Sure, here are the basics of setting up a reactive web application using Spring WebFlux:

Add the necessary dependencies: To build a reactive web application using Spring WebFlux, you will need to add the spring-boot-starter-webflux dependency to your project. You can add this dependency using your build tool of choice (Maven or Gradle).

Create a Controller: A Controller is a class that handles HTTP requests and returns a response. In Spring WebFlux, you can create a Controller by annotating a class with @RestController.

Define the Routes: To define the routes for your web application, you can use the @RequestMapping annotation. This annotation specifies the HTTP method and the path for each endpoint.

Define the Request and Response Objects: You will need to define the objects that represent the request and response for each endpoint. In Spring WebFlux, you can define these objects as Java classes.

Implement the Business Logic: In the Controller method, you can implement the business logic for handling the request and returning the response.

Here's an example of a simple Spring WebFlux Controller:
@RestController
public class MyController {

  @GetMapping("/hello")
  public Mono<String> sayHello() {
    return Mono.just("Hello World!");
  }

}

In this example, we have defined a Controller that handles GET requests to the /hello endpoint. The sayHello() method returns a Mono object, which represents a single asynchronous result.

That's a basic overview of setting up a reactive web application using Spring WebFlux. Of course, there are many more features and capabilities of Spring WebFlux, but this should give you a good starting point.

        1.3.3 q. example using maven and postgress DB 


Sure, here's an example of setting up a Spring Boot application with Maven and PostgreSQL as the database:

Create a new Maven project: You can create a new Maven project using the following command in the terminal or command prompt:
mvn archetype:generate -DgroupId=com.example -DartifactId=myproject -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false

Add the necessary dependencies: To use PostgreSQL as the database in your Spring Boot application, you will need to add the following dependencies to your pom.xml file:
<dependencies>
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
  </dependency>
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
  </dependency>
  <dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <version>42.2.23</version>
  </dependency>
</dependencies>

The spring-boot-starter-web dependency provides support for building web applications, while the spring-boot-starter-data-jpa dependency provides support for working with databases. The postgresql dependency provides the PostgreSQL driver for Spring Boot to connect to the database.

Configure the database connection: In the application.properties file, you can configure the connection to the PostgreSQL database:
spring.datasource.url=jdbc:postgresql://localhost:5432/mydb
spring.datasource.username=postgres
spring.datasource.password=postgres

Replace mydb, postgres, and postgres with the name of your database, username, and password, respectively.

Create a JPA Entity: A JPA Entity is a Java class that maps to a table in the database. Here's an example of a simple JPA Entity:
@Entity
public class User {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  private String name;

  private String email;

  // Getters and Setters
}

In this example, we have defined a JPA Entity that represents a User table in the database. The @Id annotation specifies the primary key, while the @GeneratedValue annotation generates a unique identifier automatically.

Create a Repository: A Repository is an interface that defines methods for accessing and manipulating data in the database. Here's an example of a simple Repository:
@Repository
public interface UserRepository extends JpaRepository<User, Long> {

}

In this example, we have defined a Repository that extends the JpaRepository interface, which provides a set of methods for working with data in the database.

Create a Controller: A Controller is a class that handles HTTP requests and returns a response. Here's an example of a simple Controller:
@RestController
public class UserController {

  @Autowired
  private UserRepository userRepository;

  @GetMapping("/users")
  public List<User> getUsers() {
    return userRepository.findAll();
  }

  @PostMapping("/users")
  public User createUser(@RequestBody User user) {
    return userRepository.save(user);
  }

}

In this example, we have defined a Controller that handles GET and POST requests to the /users endpoint. The @Autowired annotation injects the UserRepository dependency, which we can use to access and manipulate data in the database.

That's a basic example of setting up a Spring Boot application with Maven and PostgreSQL as the database. Of course, there are many more features and configurations that you can add to this setup,

        1.3.4 use JDBC instead of JPA
Sure, here's an example of setting up a Spring Boot application with Maven and PostgreSQL as the database using JDBC instead of JPA:

Create a new Maven project: You can create a new Maven project using the following command in the terminal or command prompt:
mvn archetype:generate -DgroupId=com.example -DartifactId=myproject -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false

Add the necessary dependencies: To use PostgreSQL as the database in your Spring Boot application with JDBC, you will need to add the following dependencies to your pom.xml file:
<dependencies>
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
  </dependency>
  <dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <version>42.2.23</version>
  </dependency>
</dependencies>

The spring-boot-starter-web dependency provides support for building web applications, while the postgresql dependency provides the PostgreSQL driver for Spring Boot to connect to the database.

Configure the database connection: In the application.properties file, you can configure the connection to the PostgreSQL database:
spring.datasource.url=jdbc:postgresql://localhost:5432/mydb
spring.datasource.username=postgres
spring.datasource.password=postgres

Replace mydb, postgres, and postgres with the name of your database, username, and password, respectively.

Create a DAO: A DAO (Data Access Object) is a class that encapsulates the logic for accessing and manipulating data in the database. Here's an example of a simple DAO:
@Repository
public class UserDao {

  @Autowired
  private JdbcTemplate jdbcTemplate;

  public List<User> getUsers() {
    String sql = "SELECT * FROM users";
    return jdbcTemplate.query(sql, new UserRowMapper());
  }

  public User createUser(User user) {
    String sql = "INSERT INTO users(name, email) VALUES (?, ?)";
    jdbcTemplate.update(sql, user.getName(), user.getEmail());
    return user;
  }

}

In this example, we have defined a DAO that uses the JdbcTemplate class to interact with the database. The getUsers() method executes a SELECT statement to retrieve a list of users from the database, while the createUser() method executes an INSERT statement to insert a new user into the database.

Create a RowMapper: A RowMapper is an interface that maps a row of data from the database to a Java object. Here's an example of a simple RowMapper:
public class UserRowMapper implements RowMapper<User> {

  @Override
  public User mapRow(ResultSet rs, int rowNum) throws SQLException {
    User user = new User();
    user.setId(rs.getLong("id"));
    user.setName(rs.getString("name"));
    user.setEmail(rs.getString("email"));
    return user;
  }

}

In this example, we have defined a RowMapper that maps a row of data from the users table in the database to a User object.

Create a Controller: A Controller is a class that handles HTTP requests and returns a response. Here's an example of a simple Controller:
@RestController
public class UserController {

  @Autowired
  private UserDao userDao;

  @GetMapping("/users")
  public List<User> getUsers() {
    return userDao.getUsers();
  }

  @PostMapping("/users")
  public User createUser(@RequestBody User user) {
    return userDao.createUser(user);
  }

}

q. why JdbcTemplate is @Autowired
a. In the example I provided earlier, the JdbcTemplate object is autowired into the UserDao class using the @Autowired annotation. This is because the JdbcTemplate class is a Spring framework class that provides a convenient way to interact with a JDBC datasource.

By autowiring the JdbcTemplate object, Spring takes care of creating an instance of the JdbcTemplate class and injecting it into the UserDao class at runtime. This makes it easier to use the JdbcTemplate object without having to manually create an instance of the class or worry about managing its lifecycle.

In addition, the @Autowired annotation is used in conjunction with Spring's IoC (Inversion of Control) container, which is responsible for managing the lifecycle of objects and their dependencies in a Spring application. By using @Autowired, the JdbcTemplate object is automatically wired up by the IoC container, which reduces the amount of boilerplate code that would be required if we had to create and manage the JdbcTemplate object manually.


        1.3.5 explain java org.springframework.context.annotation.Profile
In Java and the Spring Framework, the `@Profile` annotation is used to define different configurations and beans based on specific runtime environments or application profiles. It allows you to selectively activate or deactivate certain parts of your application's configuration based on the specified profile.

Here's how the `@Profile` annotation works:

1. Defining Profiles: Profiles are defined using the `@Profile` annotation at the class or method level. You can assign one or more profile names to the annotation. For example:

```java
@Configuration
@Profile("development")
public class DevelopmentConfig {
    // Configuration for development profile
}

@Configuration
@Profile("production")
public class ProductionConfig {
    // Configuration for production profile
}
```

In this example, two configuration classes are defined, each associated with a different profile. The `DevelopmentConfig` class is active only when the "development" profile is active, and the `ProductionConfig` class is active only when the "production" profile is active.

2. Activating Profiles: Profiles can be activated in various ways, depending on your application's setup. Here are a few common methods:

   - Via Configuration: You can set the active profiles using configuration properties, such as in the `application.properties` or `application.yml` file:

     ```
     spring.profiles.active=development,anotherProfile
     ```

   - Programmatically: You can programmatically activate profiles during application startup by using the `ConfigurableEnvironment` or `SpringApplication` APIs:

     ```java
     SpringApplication app = new SpringApplication(MyApplication.class);
     ConfigurableEnvironment environment = app.getEnvironment();
     environment.setActiveProfiles("development");
     app.run(args);
     ```

   - Using Command Line Arguments: You can specify active profiles as command line arguments:

     ```
     java -jar myapp.jar --spring.profiles.active=development
     ```

3. Conditional Bean Creation: The `@Profile` annotation can also be used to conditionally create beans based on profiles. By annotating a bean definition or `@Configuration` class with `@Profile`, the bean(s) will only be created when the specified profile is active. For example:

```java
@Configuration
public class MyConfig {
    @Bean
    @Profile("development")
    public DataSource developmentDataSource() {
        // Configuration for development data source
    }

    @Bean
    @Profile("production")
    public DataSource productionDataSource() {
        // Configuration for production data source
    }
}
```

In this case, the `developmentDataSource` bean will be created and used when the "development" profile is active, while the `productionDataSource` bean will be created and used when the "production" profile is active.

The `@Profile` annotation provides a powerful way to manage different configurations and beans based on specific profiles or runtime environments. It allows you to easily switch between different configurations during development, testing, and production, providing flexibility and maintainability in your Spring applications.

        1.3.6 is there a spring framework DataSource class or interface
Yes, in the Spring Framework, there is a `DataSource` interface provided that represents a database connection pool. The `DataSource` interface defines a set of methods to obtain and manage database connections, allowing you to interact with a database in a standardized way.

Here's an example of how the `DataSource` interface can be used in the Spring Framework:

```java
import org.springframework.jdbc.datasource.DriverManagerDataSource;

DataSource dataSource = new DriverManagerDataSource();
((DriverManagerDataSource) dataSource).setDriverClassName("com.mysql.jdbc.Driver");
((DriverManagerDataSource) dataSource).setUrl("jdbc:mysql://localhost:3306/mydb");
((DriverManagerDataSource) dataSource).setUsername("username");
((DriverManagerDataSource) dataSource).setPassword("password");

// Use the dataSource in your application
```

In this example, the `DriverManagerDataSource` class is used to create an instance of the `DataSource` interface. The `DriverManagerDataSource` is a basic implementation of the `DataSource` interface provided by Spring, and it allows you to configure the necessary database connection details such as driver class name, URL, username, and password.

Spring provides several other implementations of the `DataSource` interface, such as `TomcatDataSource`, `HikariDataSource`, and more. These implementations offer advanced features like connection pooling, connection management, and performance optimizations.

You can also configure a `DataSource` bean in your Spring application context XML or using annotations such as `@Bean`. By declaring a `DataSource` bean, you can inject it into your application's components, such as `JdbcTemplate`, `JPA`, or other data access frameworks provided by Spring, to interact with the database.

Using the `DataSource` interface in conjunction with Spring's data access frameworks helps to abstract away the underlying database connection details and provides a consistent and convenient way to work with databases in your Spring applications.

        1.3.7 explain org.springframework.jdbc.core.JdbcTemplate
The `JdbcTemplate` class in the `org.springframework.jdbc.core` package is a central class in the Spring Framework's JDBC support. It simplifies the process of working with relational databases using JDBC by providing a higher-level abstraction and a set of convenient methods.

The `JdbcTemplate` class encapsulates the boilerplate code required to manage database connections, execute SQL statements or queries, handle exceptions, and process the results. It helps to reduce repetitive JDBC-related code and promotes cleaner and more concise database access code.

Here are some key features and functionalities of the `JdbcTemplate` class:

1. Database Operations: The `JdbcTemplate` class provides methods for executing various types of SQL operations, such as updates, inserts, deletes, and selects. These methods handle all the necessary details, including acquiring and releasing database connections, executing SQL statements, binding parameters, and processing result sets.

2. Exception Handling: The `JdbcTemplate` class handles SQLExceptions that occur during database operations and wraps them in more meaningful and standardized Spring exceptions, such as `DataAccessException`. This simplifies error handling and allows for consistent exception handling across different database operations.

3. PreparedStatement Creation: The `JdbcTemplate` class can create `PreparedStatement` objects for executing SQL statements with bound parameters. It automatically handles the preparation of the statement and sets the appropriate parameter values based on the provided arguments.

4. ResultSet Processing: The `JdbcTemplate` class provides methods for processing `ResultSet` objects returned from SELECT queries. It simplifies the process of iterating over the result set, extracting data, and mapping it to Java objects or data structures.

5. Batch Updates: The `JdbcTemplate` class supports batch updates, allowing you to execute multiple SQL statements as a single batch. This can significantly improve performance when dealing with multiple database operations.

6. Exception Translation: The `JdbcTemplate` class integrates with Spring's `SQLExceptionTranslator` mechanism, which translates database-specific SQL exceptions into Spring's standardized `DataAccessException` hierarchy. This helps to abstract away the database-specific exception handling and provides a consistent exception model.

7. Callback Mechanism: The `JdbcTemplate` class supports a callback mechanism through the use of various callback interfaces. These interfaces, such as `PreparedStatementCreator`, `PreparedStatementSetter`, `RowMapper`, and others, allow you to customize the behavior of database operations and provide more flexibility in handling SQL statements and result sets.

Overall, the `JdbcTemplate` class simplifies and streamlines database access code by encapsulating the complexity of JDBC operations. It promotes best practices, such as using prepared statements, handling exceptions, and separating concerns, resulting in cleaner and more maintainable code when working with relational databases in Spring applications.

        1.3.8 explain  org.springframework.beans.factory.annotation.Qualifier
The `@Qualifier` annotation in the `org.springframework.beans.factory.annotation` package is used in the Spring Framework to disambiguate bean dependencies when multiple beans of the same type are present in the application context. It helps to resolve the issue of having multiple candidates for autowiring by specifying a unique qualifier value.

When autowiring dependencies using `@Autowired` or other similar annotations, Spring attempts to match the required dependency with a bean of the same type in the application context. However, if there are multiple beans of the same type, Spring cannot determine which one to use by default. This is where the `@Qualifier` annotation comes into play.

Here's how the `@Qualifier` annotation is used:

1. Define Bean Qualifiers: In the application context, when defining multiple beans of the same type, you can assign a unique qualifier value using the `@Qualifier` annotation. For example:

```java
@Component
@Qualifier("foo")
public class FooService implements SomeService {
    // ...
}

@Component
@Qualifier("bar")
public class BarService implements SomeService {
    // ...
}
```

In this example, two beans of type `SomeService` are defined with different qualifiers: `"foo"` and `"bar"`. These qualifiers help to differentiate between the beans during autowiring.

2. Use `@Qualifier` for Dependency Injection: In the dependent class or component, you can use the `@Qualifier` annotation along with `@Autowired` to specify which bean should be injected. For example:

```java
@Component
public class MyComponent {
    @Autowired
    @Qualifier("foo")
    private SomeService someService;

    // ...
}
```

In this case, the `@Qualifier("foo")` annotation specifies that the bean with the qualifier `"foo"` should be injected into the `someService` field. This resolves the ambiguity when multiple beans of type `SomeService` are available.

The `@Qualifier` annotation works in conjunction with the bean name or other custom qualifier annotations. If you use the default bean names as qualifiers, you can omit the `@Qualifier` annotation and rely on Spring's default behavior of matching by bean name.

By using `@Qualifier`, you can explicitly specify which bean should be injected when multiple beans of the same type are present. It provides fine-grained control over dependency injection and helps to resolve conflicts in cases where the default autowiring mechanism is not sufficient.
        1.3.9
    1.4
2. general
    2.1. manipulate jar files.
	help:
	$jar 

	list files in archive
	$jar -tvf <file>.jar
	
	searh for a specific class (in sh, bash ...)
	$for jar in *.jar;  do echo  $jar; jar tvf $jar | grep <class>; done
	
    2.2. remote debug java application.

first run jvm (java) with extra flags to open listen socket:
-Xdebug -Xnoagent -Djava.compiler=none -Xrunjdwp:transport=dt_socket,server=y,suspend=y

then connect via
jdb -connect com.sun.jdi.SocketAttach:hostname=localhost,port=XXXX

In case of C++ application with java parts, make sure the C++ app is running after socket is opened (like press enter in prompt).

For Eclipse connect to the port then switch to debug prespective.
Also make sure the code is compiled with debug flag:
 -g or for ant set <property name="javac.debug" value="on" /> and in the <javac> command add
  debug="on" property.
  
    2.3. deploy JSP pages to web container.
deploy war file reccomended but can deploy the whole dir instead.
project dir must contain WEB-INF,  WEB-INF/lib, WEB-INF/classes libs.
To include classes use the <import> directive.
If needed edit web server configuration to specify needed classpath ( for TOMCAT, config/web.xml, classpath).
x
    2.4. Tomcat
	1. listen port and shutdown port are defined in server.xml. 

    2.5.  Reverse engineer.
	$ use javap -c (that comes with java installation)
	$ also eclispse will do that.
	$ there are commercial tools. like DJ java. 

    2.6 Set java version, toggle java versions, switch jdk versions 

        2.6.1 mac, OS X
TLDR, use my aliases
[i500695@C02X632CJGH6:2020-10-25 16:13:31:~/work/SAP/git/portal-cf-provisioning-service:]2077$ java_versions 
Matching Java Virtual Machines (4):
    14.0.2, x86_64:	"OpenJDK 14.0.2"	/Library/Java/JavaVirtualMachines/openjdk-14.0.2.jdk/Contents/Home
    10.0.2, x86_64:	"Java SE 10.0.2"	/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home
    1.8.0_265, x86_64:	"AdoptOpenJDK 8"	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home
    1.8.0_241, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home

/Library/Java/JavaVirtualMachines/openjdk-14.0.2.jdk/Contents/Home
[i500695@C02X632CJGH6:2020-10-25 16:13:35:~/work/SAP/git/portal-cf-provisioning-service:]2078$ java_set1_8 
[i500695@C02X632CJGH6:2020-10-25 16:13:39:~/work/SAP/git/portal-cf-provisioning-service:]2079$ echo $JAVA_HOME 
/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home

long read:

Setting v 1.8 on my Mac:
$ /usr/libexec/java_home -V
Matching Java Virtual Machines (4):
    13.0.1, x86_64:	"OpenJDK 13.0.1"	/Library/Java/JavaVirtualMachines/openjdk-13.0.1.jdk/Contents/Home
    10.0.2, x86_64:	"Java SE 10.0.2"	/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home
    1.8.0_241, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home
    1.8.0_232, x86_64:	"AdoptOpenJDK 8"	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home

/Library/Java/JavaVirtualMachines/openjdk-13.0.1.jdk/Contents/Home
[i500695@C02X632CJGH6:2020-03-05 13:55:26:~/work/SAP/git/portal-cf-provisioning-service:]2117$ export JAVA_HOME=`/usr/libexec/java_home -v 1.8.0_232`


https://stackoverflow.com/questions/21964709/how-to-set-or-change-the-default-java-jdk-version-on-os-x

| First run /usr/libexec/java_home -V which will output something like the following:
| Matching Java Virtual Machines (3):
| 1.8.0_05, x86_64:   "Java SE 8" /Library/Java/JavaVirtualMachines/jdk1.8.0_05.jdk/Contents/Home
| 1.6.0_65-b14-462, x86_64:   "Java SE 6" /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home
| 1.6.0_65-b14-462, i386: "Java SE 6" /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home

/Library/Java/JavaVirtualMachines/jdk1.8.0_05.jdk/Contents/Home
Pick the version you want to be the default (1.6.0_65-b14-462 for arguments sake) then:
export JAVA_HOME=`/usr/libexec/java_home -v 1.6.0_65-b14-462`
or you can specify just the major version, like:
export JAVA_HOME=`/usr/libexec/java_home -v 1.8`
Now when you run java -version you will see:
java version "1.6.0_65"
Java(TM) SE Runtime Environment (build 1.6.0_65-b14-462-11M4609)
Java HotSpot(TM) 64-Bit Server VM (build 20.65-b04-462, mixed mode)
Add the export JAVA_HOME… line to your shell’s init file.
For Bash (as stated by antonyh):
export JAVA_HOME=$(/usr/libexec/java_home -v 1.8)
    
    2.7 chatgpt

        2.7.1 java set data structure, tags: java set data structure
In Java, the `Set` data structure is part of the Java Collections Framework and is used to store a collection of unique elements. It does not allow duplicate elements, and it does not guarantee the order of elements.

There are several classes in Java that implement the `Set` interface. Some commonly used implementations include:

|  1. `HashSet`: This implementation uses a hash table to store the elements. It provides constant-time performance for basic operations like add, remove, and contains, assuming a good hash function is used for the objects being stored.
|  
|  2. `TreeSet`: This implementation stores elements in a sorted tree structure. It maintains the elements in ascending order or according to a custom `Comparator` provided during creation. The add, remove, and contains operations have a time complexity of O(log n).
|  
|  3. `LinkedHashSet`: This implementation maintains a doubly-linked list of the elements in addition to using a hash table. It guarantees that the elements will be iterated in the order they were inserted. The time complexity for basic operations is similar to `HashSet`.
|  
|  Here's an example that demonstrates how to use the `HashSet` class:
|  
|  ```java
|  import java.util.HashSet;
|  import java.util.Set;
|  
|  public class SetExample {
|      public static void main(String[] args) {
|          Set<String> set = new HashSet<>();
|  
|          // Adding elements to the set
|          set.add("apple");
|          set.add("banana");
|          set.add("orange");
|  
|          // Adding a duplicate element (it will be ignored)
|          set.add("apple");
|  
|          // Printing the set
|          System.out.println(set); // Output: [orange, banana, apple]
|  
|          // Checking if an element exists in the set
|          boolean containsOrange = set.contains("orange");
|          System.out.println(containsOrange); // Output: true
|  
|          // Removing an element from the set
|          set.remove("banana");
|  
|          // Printing the set after removal
|          System.out.println(set); // Output: [orange, apple]
|  
|          // Getting the size of the set
|          int size = set.size();
|          System.out.println(size); // Output: 2
|      }
|  }
|  ```

This example demonstrates basic operations such as adding elements, checking for element existence, removing elements, and retrieving the size of the set using a `HashSet`.

        2.7.2  java Files  , tags: java Files  
In Java, the `java.nio.file.Files` class provides a set of static methods for working with files and directories. It is part of the Java NIO (New I/O) package and introduced in Java 7. The `Files` class provides various methods for common file operations such as creating, deleting, copying, moving, and reading files.

Here are some commonly used methods of the `Files` class:

| 1. `createFile(Path path, FileAttribute<?>... attrs)`: Creates a new empty file at the specified path.
| 
| 2. `createDirectory(Path dir, FileAttribute<?>... attrs)`: Creates a new directory at the specified path.
| 
| 3. `delete(Path path)`: Deletes a file or an empty directory at the specified path.
| 
| 4. `copy(Path source, Path target, CopyOption... options)`: Copies a file or a directory from the source path to the target path. The `CopyOption` parameter allows specifying options like replacing existing files or preserving file attributes.
| 
| 5. `move(Path source, Path target, CopyOption... options)`: Moves a file or a directory from the source path to the target path. This method can also be used for renaming files.
| 
| 6. `readAllLines(Path path, Charset cs)`: Reads all lines from a file and returns them as a `List` of strings.
| 
| 7. `write(Path path, byte[] bytes, OpenOption... options)`: Writes the specified byte array to a file.
| 
| 8. `isDirectory(Path path)`: Checks if the specified path represents a directory.
| 
| 9. `isRegularFile(Path path, LinkOption... options)`: Checks if the specified path represents a regular file.

These are just a few examples of the methods provided by the `Files` class. There are more methods available for various file operations. To use these methods, you need to import the `java.nio.file.Files` class and work with `java.nio.file.Path` objects to represent file and directory paths.

Here's an example that demonstrates the usage of some `Files` methods:

```java
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.charset.StandardCharsets;
import java.io.IOException;
import java.util.List;

public class FilesExample {
    public static void main(String[] args) {
        try {
            // Creating a new directory
            Path directoryPath = Paths.get("mydirectory");
            Files.createDirectory(directoryPath);

            // Creating a new file
            Path filePath = Paths.get("mydirectory/myfile.txt");
            Files.createFile(filePath);

            // Writing content to the file
            String content = "Hello, World!";
            Files.write(filePath, content.getBytes(StandardCharsets.UTF_8));

            // Reading all lines from the file
            List<String> lines = Files.readAllLines(filePath, StandardCharsets.UTF_8);
            for (String line : lines) {
                System.out.println(line);
            }

            // Deleting the file
            Files.delete(filePath);

            // Deleting the directory
            Files.delete(directoryPath);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

In this example, we create a directory called "mydirectory," create a file called "myfile.txt" inside the directory, write some content to the file, read the content back, and finally delete the file and directory.

        2.7.3 java Objects.requireNonNull , tags: java Objects.requireNonNull 
In Java, `Objects.requireNonNull` is a utility method provided by the `java.util.Objects` class. It is commonly used to check if an object reference is null and throw a `NullPointerException` if it is.

The `requireNonNull` method has the following signature:

```java
public static <T> T requireNonNull(T obj)
```

It takes an object reference `obj` as a parameter and returns the reference if it is not null. If `obj` is null, it throws a `NullPointerException`.

Here's an example to illustrate the usage of `Objects.requireNonNull`:

```java
import java.util.Objects;

public class Example {
    public static void main(String[] args) {
        String name = null;

        // Using Objects.requireNonNull to check if the reference is null
        String nonNullName = Objects.requireNonNull(name);

        System.out.println(nonNullName);
    }
}
```

In this example, the variable `name` is assigned a null value. When we pass `name` to `Objects.requireNonNull`, it will throw a `NullPointerException` because the reference is null.

If you want to provide a custom error message when a null value is encountered, you can use the overloaded version of `requireNonNull` that takes a message as the second parameter:

```java
public static <T> T requireNonNull(T obj, String message)
```

Here's an example using the overloaded `requireNonNull` method:

```java
import java.util.Objects;

public class Example {
    public static void main(String[] args) {
        String name = null;

        try {
            String nonNullName = Objects.requireNonNull(name, "Name cannot be null");
            System.out.println(nonNullName);
        } catch (NullPointerException e) {
            System.out.println(e.getMessage()); // Output: Name cannot be null
        }
    }
}
```

In this example, we pass the custom error message "Name cannot be null" as the second argument to `requireNonNull`. If the reference is null, it will throw a `NullPointerException` with the specified message.

        2.7.4 java File.toPath() , tags: java File.toPath() 
In Java, the `File` class represents a file or directory on the file system. Starting from Java 7, the `File` class has a method called `toPath()` which returns a `java.nio.file.Path` object representing the abstract path of the `File`.

The `toPath()` method has the following signature:

```java
public Path toPath()
```

Here's an example that demonstrates the usage of `toPath()`:

```java
import java.io.File;
import java.nio.file.Path;

public class Example {
    public static void main(String[] args) {
        File file = new File("path/to/file.txt");

        // Converting File to Path
        Path path = file.toPath();

        // Printing the Path
        System.out.println(path);
    }
}
```

In this example, we create a `File` object representing a file path "path/to/file.txt". We then call the `toPath()` method on the `File` object to convert it to a `Path` object. Finally, we print the `Path` object.

Note that `toPath()` is available starting from Java 7. If you are using an older version of Java, you can still convert a `File` to a `Path` by using the `Paths.get(String)` method, as shown below:

```java
import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;

public class Example {
    public static void main(String[] args) {
        File file = new File("path/to/file.txt");

        // Converting File to Path
        Path path = Paths.get(file.getPath());

        // Printing the Path
        System.out.println(path);
    }
}
```

In this example, we use the `Paths.get(String)` method and pass the file's path obtained from `file.getPath()` to convert the `File` object to a `Path`.

        2.7.5 java use class loader to read a file that contains a sql statement and then run it on a PG DB , tags: java use class loader to read a file that contains a sql statement and then run it on a PG DB 
To read a file containing an SQL statement using a class loader and execute it on a PostgreSQL database in Java, you can follow these steps:

| 1. Place the SQL file in the appropriate location within your project's resources. For example, you can create a folder called `sql` in the `src/main/resources` directory and place the SQL file there.
| 
| 2. Use the class loader to read the file as an input stream. Here's an example:

```java
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;

public class SQLRunner {
    public static void main(String[] args) {
        // Load the SQL file using the class loader
        InputStream inputStream = SQLRunner.class.getClassLoader().getResourceAsStream("sql/myquery.sql");

        if (inputStream != null) {
            try {
                // Read the SQL file content as a string
                String sql = new String(inputStream.readAllBytes(), StandardCharsets.UTF_8);

                // Establish a connection to the PostgreSQL database
                Connection connection = DriverManager.getConnection("jdbc:postgresql://localhost:5432/mydb", "username", "password");

                // Create a statement
                Statement statement = connection.createStatement();

                // Execute the SQL statement
                statement.executeUpdate(sql);

                // Close the statement and connection
                statement.close();
                connection.close();

                System.out.println("SQL statement executed successfully.");
            } catch (IOException | SQLException e) {
                e.printStackTrace();
            }
        } else {
            System.out.println("SQL file not found.");
        }
    }
}
```

In this example, the SQL file `myquery.sql` is located in the `sql` folder under `src/main/resources`. The class loader is used to read the file as an input stream. The content of the SQL file is then converted to a string.

Next, a connection is established to the PostgreSQL database using the appropriate JDBC URL, username, and password. A `Statement` object is created from the connection, and the SQL statement is executed using `statement.executeUpdate(sql)`.

Finally, the statement and connection are closed, and a message is printed indicating the successful execution of the SQL statement.

Make sure to replace the JDBC URL, username, and password with the appropriate values for your PostgreSQL database.



        2.7.6 java org.stringtemplate.v4.ST , tags: java org.stringtemplate.v4.ST 
The `org.stringtemplate.v4.ST` class is part of the StringTemplate library, which is a powerful template engine for generating text-based output such as code, HTML, XML, etc., from templates. StringTemplate is available for Java and several other programming languages.

The `ST` class represents a single template and provides methods for setting template attributes, rendering the template, and retrieving the generated output. It allows you to dynamically populate placeholders in the template with values.

Here's an example that demonstrates the basic usage of `ST`:

```java
import org.stringtemplate.v4.ST;

public class STExample {
    public static void main(String[] args) {
        // Create a template with a placeholder
        ST template = new ST("Hello, <name>!");

        // Set the value for the placeholder
        template.add("name", "John");

        // Render the template and get the output
        String output = template.render();

        // Print the generated output
        System.out.println(output);
    }
}
```

In this example, we create an `ST` object with the template "Hello, \<name>!". The `<name>` part is a placeholder that will be dynamically replaced with a value. We set the value for the "name" placeholder using `template.add("name", "John")`. Finally, we call `template.render()` to generate the output, which is then printed to the console.

StringTemplate supports more advanced features like conditionals, loops, and template inheritance. You can define templates with more complex structures and use them to generate dynamic text output.

To use StringTemplate in your project, you need to include the StringTemplate library in your project dependencies. You can find the StringTemplate library and its documentation on the official website: http://www.stringtemplate.org/

        2.7.7 java StringBuilder, tags: java StringBuilder
In Java, `StringBuilder` is a class that provides a mutable sequence of characters. It is commonly used when you need to efficiently build or manipulate strings that can change frequently, especially when concatenating multiple strings or performing frequent modifications.

Here's an example of how to use `StringBuilder` in Java:

```java
StringBuilder sb = new StringBuilder();

// Appending strings
sb.append("Hello");
sb.append(" ");
sb.append("World");

// Inserting strings at a specific position
sb.insert(5, ","); // Output: Hello, World

// Replacing a portion of the string
sb.replace(7, 12, "There"); // Output: Hello, There

// Deleting characters from the string
sb.delete(5, 7); // Output: Hello There

// Getting the final string
String result = sb.toString();
System.out.println(result); // Output: Hello There
```

In this example, we create a `StringBuilder` object named `sb`. We then use various methods of the `StringBuilder` class to append, insert, replace, and delete characters or portions of the string. Finally, we convert the `StringBuilder` object to a regular `String` using the `toString()` method and store it in the `result` variable. The resulting string is then printed to the console.

`StringBuilder` provides efficient string manipulation operations because it internally maintains a mutable character array. This avoids unnecessary memory allocations and copying when performing concatenation or modifications. It is generally preferred over `String` concatenation using the `+` operator when you need to build or modify strings dynamically.

Note: `StringBuilder` is not thread-safe. If you require thread safety, you can use the `StringBuffer` class, which provides similar functionality but with thread-safe operations.


        2.7.8 java jackson @JsonCreator annotation, tags: java jackson @JsonCreator annotation
In Java with Jackson, the `@JsonCreator` annotation is used to mark a constructor or a static factory method as a creator for deserialization. It is used to specify how Jackson should create an instance of a class when deserializing JSON into Java objects.

Here's how the `@JsonCreator` annotation can be used:

|  1. Constructor-based deserialization:
|  ```java
|  public class MyClass {
|      private String property;
|  
|      @JsonCreator
|      public MyClass(@JsonProperty("property") String property) {
|          this.property = property;
|      }
|  }
|  ```
|  In this example, the `@JsonCreator` annotation is applied to the constructor of the `MyClass` class. It indicates that this constructor should be used during deserialization. The `@JsonProperty("property")` annotation is used to map the JSON property named "property" to the corresponding constructor parameter.
|  
|  2. Static factory method-based deserialization:
|  ```java
|  public class MyClass {
|      private String property;
|  
|      private MyClass(String property) {
|          this.property = property;
|      }
|  
|      @JsonCreator
|      public static MyClass createInstance(@JsonProperty("property") String property) {
|          return new MyClass(property);
|      }
|  }
|  ```
In this example, the `@JsonCreator` annotation is applied to a static factory method `createInstance()`. It specifies that this method should be used for deserialization. The `@JsonProperty("property")` annotation is used to map the JSON property named "property" to the corresponding method parameter.

Both approaches allow Jackson to create instances of the annotated class during deserialization by matching the JSON properties with the constructor parameters or factory method arguments based on their names.

The `@JsonCreator` annotation provides flexibility in deserialization, allowing you to customize how JSON data is converted into Java objects.

        2.7.9 how to read an array property into a List<String> in a @JsonCreator annotated class constructor, tags: how to read an array property into a List<String> in a @JsonCreator annotated class constructor
To read an array property into a `List<String>` in a `@JsonCreator` annotated class constructor, you can use the `@JsonProperty` annotation along with the `List` type.

Here's an example:

```java
public class MyClass {
    private List<String> values;

    @JsonCreator
    public MyClass(@JsonProperty("values") List<String> values) {
        this.values = values;
    }

    // Getter and Setter for values
}
```

In this example, the `MyClass` constructor is annotated with `@JsonCreator`, indicating that it should be used for deserialization. The `@JsonProperty("values")` annotation is applied to the constructor parameter `values`, specifying that the JSON property with the name "values" should be mapped to this parameter.

During deserialization, Jackson will automatically convert the JSON array property named "values" into a `List<String>` and pass it to the constructor.

Here's an example JSON that can be deserialized using the `MyClass` constructor:

```json
{
  "values": ["value1", "value2", "value3"]
}
```

When you deserialize this JSON using Jackson, the `values` property will be mapped to a `List<String>` in the `MyClass` instance, with each element of the JSON array becoming an element in the list.

Remember to include the necessary Jackson dependencies in your project for JSON serialization and deserialization, such as `jackson-core`, `jackson-databind`, and `jackson-annotations`.

        2.7.10
    2.8
3.  IDE, intellij 

    3.1   VIM plugin
    IdeaVim

install
Preferences -> plugins -> IdeaVim

    3.2   Code generation

        3.2.1    generate getters and setters
write code for fields. e.g.

   private int x;
    private int y;
    
hit cmd+N
choose generate setters and getters

        3.2.2

    3.3

4. Build java projects

    4.1 Build java projects with maven

        4.1.1 Build java projects with maven spring tutorial
https://spring.io/guides/gs/maven/

Create the directory structure

In a project directory of your choosing, create the following subdirectory structure; for example, with mkdir -p src/main/java/hello on *nix systems:
[i500695@C02X632CJGH6:2020-01-19 17:42:28:~/work/code/java/helloWorld:]2038$ mkdir -p src/main/java/hello 
create these two classes: HelloWorld.java and Greeter.java.

src/main/java/hello/HelloWorld.java

package hello;

public class HelloWorld {
  public static void main(String[] args) {
    Greeter greeter = new Greeter();
    System.out.println(greeter.sayHello());
  }
}

src/main/java/hello/Greeter.java

package hello;

public class Greeter {
  public String sayHello() {
    return "Hello world!";
  }
}

Now that you have a project that is ready to be built with Maven, the next step is to install Maven.

(already done)
[i500695@C02X632CJGH6:2020-01-19 17:45:24:~/work/code/java/helloWorld:]2042$ mvn -v
Apache Maven 3.6.2 (40f52333136460af0dc0d7232c0dc0bcf0d9e117; 2019-08-27T18:06:16+03:00)
Maven home: /usr/local/Cellar/maven/3.6.2/libexec
Java version: 13.0.1, vendor: Oracle Corporation, runtime: /Library/Java/JavaVirtualMachines/openjdk-13.0.1.jdk/Contents/Home
Default locale: en_IL, platform encoding: UTF-8
OS name: "mac os x", version: "10.15.2", arch: "x86_64", family: "mac"

Define a simple Maven build

Now that Maven is installed, you need to create a Maven project definition. Maven projects are defined with an XML file named pom.xml. Among other things, this file gives the project’s name, version, and dependencies that it has on external libraries.

Create a file named pom.xml at the root of the project (i.e. put it next to the src folder) and give it the following contents:

pom.xml

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.springframework</groupId>
    <artifactId>gs-maven</artifactId>
    <packaging>jar</packaging>
    <version>0.1.0</version>

    <properties>
        <maven.compiler.source>1.8</maven.compiler.source>
        <maven.compiler.target>1.8</maven.compiler.target>
    </properties>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>2.1</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                        <configuration>
                            <transformers>
                                <transformer
                                    implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                                    <mainClass>hello.HelloWorld</mainClass>
                                </transformer>
                            </transformers>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>

With the exception of the optional <packaging> element, this is the simplest possible pom.xml file necessary to build a Java project. It includes the following details of the project configuration:

<modelVersion>. POM model version (always 4.0.0).
<groupId>. Group or organization that the project belongs to. Often expressed as an inverted domain name.
<artifactId>. Name to be given to the project’s library artifact (for example, the name of its JAR or WAR file).
<version>. Version of the project that is being built.
<packaging> - How the project should be packaged. Defaults to "jar" for JAR file packaging. Use "war" for WAR file packaging.
When it comes to choosing a versioning scheme, Spring recommends the semantic versioning approach.
At this point you have a minimal, yet capable Maven project defined.

[i500695@C02X632CJGH6:2020-01-19 17:48:26:~/work/code/java/helloWorld:]2046$ mvn compile
[INFO] Scanning for projects...
[INFO] 
[INFO] --------------------< org.springframework:gs-maven >--------------------
[INFO] Building gs-maven 0.1.0
[INFO] --------------------------------[ jar ]---------------------------------
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ gs-maven ---
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] skip non existing resourceDirectory /Users/i500695/work/code/java/helloWorld/src/main/resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ gs-maven ---
[INFO] Changes detected - recompiling the module!
[WARNING] File encoding has not been set, using platform encoding UTF-8, i.e. build is platform dependent!
[INFO] Compiling 2 source files to /Users/i500695/work/code/java/helloWorld/target/classes
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  1.082 s
[INFO] Finished at: 2020-01-19T17:48:34+02:00
[INFO] ------------------------------------------------------------------------
[i500695@C02X632CJGH6:2020-01-19 17:48:34:~/work/code/java/helloWorld:]2047$ find . -name '*.class'
./target/classes/hello/HelloWorld.class
./target/classes/hello/Greeter.class

$ mvn package
[i500695@C02X632CJGH6:2020-01-19 17:51:00:~/work/code/java/helloWorld:]2051$ java -jar target/HelloWorld-0.1.0.jar 
Hello world!

Maven also maintains a repository of dependencies on your local machine (usually in a .m2/repository directory in your home directory) for quick access to project dependencies. If you’d like to install your project’s JAR file to that local repository, then you should invoke the install goal:

mvn install
The install goal will compile, test, and package your project’s code and then copy it into the local dependency repository, ready for another project to reference it as a dependency.

Speaking of dependencies, now it’s time to declare dependencies in the Maven build.

Declare Dependencies

The simple Hello World sample is completely self-contained and does not depend on any additional libraries. Most applications, however, depend on external libraries to handle common and complex functionality.

For example, suppose that in addition to saying "Hello World!", you want the application to print the current date and time. While you could use the date and time facilities in the native Java libraries, you can make things more interesting by using the Joda Time libraries.

First, change HelloWorld.java to look like this:

src/main/java/hello/HelloWorld.java

package hello;

import org.joda.time.LocalTime;

public class HelloWorld {
  public static void main(String[] args) {
    LocalTime currentTime = new LocalTime();
    System.out.println("The current local time is: " + currentTime);
    Greeter greeter = new Greeter();
    System.out.println(greeter.sayHello());
  }
}
Here HelloWorld uses Joda Time’s LocalTime class to get and print the current time.

If you were to run mvn compile to build the project now, the build would fail because you’ve not declared Joda Time as a compile dependency in the build.
ex:
[i500695@C02X632CJGH6:2020-01-19 17:54:17:~/work/code/java/helloWorld:]2053$ mvn compile
[INFO] Scanning for projects...
[INFO] 
[INFO] -------------------------< com.sap:HelloWorld >-------------------------
[INFO] Building HelloWorld 0.1.0
[INFO] --------------------------------[ jar ]---------------------------------
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ HelloWorld ---
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] skip non existing resourceDirectory /Users/i500695/work/code/java/helloWorld/src/main/resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ HelloWorld ---
[INFO] Changes detected - recompiling the module!
[WARNING] File encoding has not been set, using platform encoding UTF-8, i.e. build is platform dependent!
[INFO] Compiling 2 source files to /Users/i500695/work/code/java/helloWorld/target/classes
[INFO] -------------------------------------------------------------
[ERROR] COMPILATION ERROR : 
[INFO] -------------------------------------------------------------
[ERROR] /Users/i500695/work/code/java/helloWorld/src/main/java/hello/HelloWorld.java:[3,21] package org.joda.time does not exist
[ERROR] /Users/i500695/work/code/java/helloWorld/src/main/java/hello/HelloWorld.java:[7,5] cannot find symbol
...


You can fix that by adding the following lines to pom.xml (within the <project> element):

<dependencies>
		<dependency>
			<groupId>joda-time</groupId>
			<artifactId>joda-time</artifactId>
			<version>2.9.2</version>
		</dependency>
</dependencies>
This block of XML declares a list of dependencies for the project. Specifically, it declares a single dependency for the Joda Time library. Within the <dependency> element, the dependency coordinates are defined by three sub-elements:

<groupId> - The group or organization that the dependency belongs to.
<artifactId> - The library that is required.
<version> - The specific version of the library that is required.
By default, all dependencies are scoped as compile dependencies. That is, they should be available at compile-time (and if you were building a WAR file, including in the /WEB-INF/libs folder of the WAR). Additionally, you may specify a <scope> element to specify one of the following scopes:

provided - Dependencies that are required for compiling the project code, but that will be provided at runtime by a container running the code (e.g., the Java Servlet API).
test - Dependencies that are used for compiling and running tests, but not required for building or running the project’s runtime code.
Now if you run mvn compile or mvn package, Maven should resolve the Joda Time dependency from the Maven Central repository and the build will be successful.

Write a Test

First add JUnit as a dependency to your pom.xml, in the test scope:

<dependency>
	<groupId>junit</groupId>
	<artifactId>junit</artifactId>
	<version>4.12</version>
	<scope>test</scope>
</dependency>

Note that junit depends on hamcrest, in my case mvn did not resolve that
dependancy b/c I accidently put the test file in src dir.
dependancey, (
$mvn install
...
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (default-compile) on project HelloWorld: Compilation failure: Compilation failure: 
[ERROR] /Users/i500695/work/code/java/helloWorld/src/main/java/hello/GreeterTest.java:[3,27] package org.hamcrest does not exist
)
putting the test file in test/... dir fixes the issue

Then create a test case like this:

src/test/java/hello/GreeterTest.java

package hello;

import static org.hamcrest.CoreMatchers.containsString;
import static org.junit.Assert.*;

import org.junit.Test;

public class GreeterTest {

  private Greeter greeter = new Greeter();

  @Test
  public void greeterSaysHello() {
    assertThat(greeter.sayHello(), containsString("Hello"));
  }

}
Maven uses a plugin called "surefire" to run unit tests. The default configuration of this plugin compiles and runs all classes in src/test/java with a name matching *Test. You can run the tests on the command line like this

mvn test
or just use mvn install step as we already showed above (there is a lifecycle definition where "test" is included as a stage in "install").


        4.1.2 maven 

            4.1.2.1 getting started

                4.1.2.1.1  Create project
Create Java project with below maven command:
mvn archetype:generate
-DgroupId=org.yourcompany.project
-DartifactId=application
Create web project with below maven command:
mvn archetype:generate
-DgroupId=org.yourcompany.project
-DartifactId=application
-DarchetypeArtifactId=maven-archetype-webapp
Create archetype from existing project
mvn archetype:create-from-project

                4.1.2.1.2 . Main phases
clean — delete target directory
validate — validate, if the project is correct
compile — compile source code, classes stored in target/classes
test — run tests
package — take the compiled code and package it in its distributable format, e.g. JAR, WAR
verify — run any checks to verify the package is valid and meets quality criteria
install — install the package into the local repository
deploy — copies the final package to the remote repository


                4.1.2.1.3 . Maven phase commands(Project Build Commands)
clean project: This command will delete target directory
mvn clean
validate project: validate the project is correct and all necessary information is available
mvn validate
compile project: compile source code, classes stored in target/classes
mvn compile
test project: run tests using a suitable unit testing framework
mvn test
package project: take the compiled code and package it in its distributable format, such as a JAR /WAR
mvn package
verify project: run any checks to verify the package is valid and meets quality criteria
mvn verify
install project: install the package into the local repository, for use as a dependency in other projects locally
mvn install
deploy project: done in an integration or release environment, copies the final package to the remote repository for sharing with other developers and projects
mvn deploy

                4.1.2.1.4  Skip running tests
Compiles the tests, but skips running them.
mvn install -DskipTests=true 
Skips compiling the tests and does not run them.
mvn install -Dmaven.test.skip=true 

                4.1.2.1.5 Project Site Generation
Generate site without tests reports (tests are not executed):
mvn site:site
Generate site with unit tests reports:
mvn test site:site
Generate site with unit and integration tests reports:
mvn verify site:site

                4.1.2.1.6 Code quality analysis
Analyse code quality with Sonar:
mvn clean install -DskipTests=true
mvn sonar:sonar
Read Sonar configuration guide.

                4.1.2.1.7 Code coverage reporting
Notice:
It is much more feasible to generate code coverage reports directly from IDE than from Maven. Write test, write code, run coverage for separated test, and check that all important branches are covered.
Generate Clover reports for unit tests:
mvn clover2:setup test clover2:aggregate clover2:clover
Generate clover reports for unit and integration tests:
mvn clover2:setup verify clover2:aggregate clover2:clover
Read Clover configuration guide.

                4.1.2.1.8 Dependency Management
Check dependencies for newer versions:
mvn versions:display-dependency-updates
Check plugins for newer versions:
mvn versions:display-plugin-updates
Check for newer versions defined as properties:
mvn versions:display-property-updates
Display project dependencies:
mvn dependency:tree
Analyze project dependencies:
mvn dependency:analyze

                4.1.2.1.9 Getting Help
Display effective Maven settings:
mvn help:effective-settings
Display effective POM:
mvn help:effective-pom
Display all profiles (from settings.xml and POMs hierarchy):
mvn help:active-profiles
Display plugin goals (for m-compiler-p in the example below):
mvn compiler:help
Display plugin's goal description (for goal compile in m-compiler-p in the example below):
mvn compiler:help -Dgoal=compile -Ddetail

            4.1.2.2 commonly use CLI

generate dependancey tree:  mvn dependency:tree
check updated versions: mvn versions:display-dependency-updates
            4.1.2.3

        4.1.3

    4.2

5. Java basics

    5.1 


6. JDK 5,6

	6.1 Annotations
	Based on: http://java.sun.com/docs/books/tutorial/java/javaOO/annotations.html
		
		6.1.1 Description

    Annotations provide data about a program that is not part of the program itself. They have no direct effect on the operation of the code they annotate.

    Annotations have a number of uses, among them:

        * Information for the compiler  Annotations can be used by the compiler to detect errors or suppress warnings.

        * Compiler-time and deployment-time processing  Software tools can process annotation information to generate code, XML files, and so forth.

        * Runtime processing  Some annotations are available to be examined at runtime.

    Annotations can be applied to a program's declarations of classes, fields, methods, and other program elements.

    The annotation appears first, often (by convention) on its own line, and may include elements with named or unnamed values:

        @Author(
           name = "Benjamin Franklin",
           date = "3/27/2003"
        )
        class MyClass() { }

    or

        @SuppressWarnings(value = "unchecked")
        void myMethod() { }

    If there is just one element named "value," then the name may be omitted, as in:

        @SuppressWarnings("unchecked")
        void myMethod() { }

    Also, if an annotation has no elements, the parentheses may be omitted, as in:

        @Override
        void mySuperMethod() { }

		6.1.2 Usage
			
			6.1.2.1 Documentation
    Many annotations replace what would otherwise have been comments in code.

    Suppose that a software group has traditionally begun the body of every class with comments providing important information:

        public class Generation3List extends Generation2List {

           // Author: John Doe
           // Date: 3/17/2002
           // Current revision: 6
           // Last modified: 4/12/2004
           // By: Jane Doe
           // Reviewers: Alice, Bill, Cindy

           // class code goes here

        }

    To add this same metadata with an annotation, you must first define the annotation type. The syntax for doing this is:

        @interface ClassPreamble {
           String author();
           String date();
           int currentRevision() default 1;
           String lastModified() default "N/A";
           String lastModifiedBy() default "N/A";
           String[] reviewers();  // Note use of array
        }

    The annotation type definition looks somewhat like an interface definition where the keyword interface is preceded by the @ character (@ = "AT" as in Annotation Type). Annotation types are, in fact, a form of interface, which will be covered in a later lesson. For the moment, you do not need to understand interfaces.

    The body of the annotation definition above contains annotation type element declarations, which look a lot like methods. Note that they may define optional default values.

    Once the annotation type has been defined, you can use annotations of that type, with the values filled in, like this:

        @ClassPreamble (
           author = "John Doe",
           date = "3/17/2002",
           currentRevision = 6,
           lastModified = "4/12/2004",
           lastModifiedBy = "Jane Doe"
           reviewers = {"Alice", "Bob", "Cindy"} // Note array notation
        )
        public class Generation3List extends Generation2List {

        // class code goes here

        }

        Note: To make the information in @ClassPreamble appear in Javadoc-generated documentation, you must annotate the @ClassPreamble definition itself with the @Documented annotation:

            import java.lang.annotation.*; // import this to use @Documented

            @Documented
            @interface ClassPreamble {

               // Annotation element definitions
               
            }

    Annotations Used by the Compiler
    There are three annotation types that are predefined by the language specification itself: @Deprecated, @Override, and @SuppressWarnings.

    @Deprecatedthe @Deprecated annotation indicates that the marked element is deprecated and should no longer be used. The compiler generates a warning whenever a program uses a method, class, or field with the @Deprecated annotation. When an element is deprecated, it should also be documented using the Javadoc @deprecated tag, as shown in the following example. The use of the "@" symbol in both Javadoc comments and in annotations is not coincidentalthey are related conceptually. Also, note that the Javadoc tag starts with a lowercase "d" and the annotation starts with an uppercase "D".

           // Javadoc comment follows
            /**
             * @deprecated
             * explanation of why it was deprecated
             */
            @Deprecated
            static void deprecatedMethod() { }
        }

    @Overridethe @Override annotation informs the compiler that the element is meant to override an element declared in a superclass (overriding methods will be discussed in the the lesson titled "Interfaces and Inheritance").

           // mark method as a superclass method
           // that has been overridden
           @Override 
           int overriddenMethod() { }

    While it's not required to use this annotation when overriding a method, it helps to prevent errors. If a method marked with @Override fails to correctly override a method in one of its superclasses, the compiler generates an error.

    @SuppressWarningsthe @SuppressWarnings annotation tells the compiler to suppress specific warnings that it would otherwise generate. In the example below, a deprecated method is used and the compiler would normally generate a warning. In this case, however, the annotation causes the warning to be suppressed.

           // use a deprecated method and tell 
           // compiler not to generate a warning
           @SuppressWarnings("deprecation")
            void useDeprecatedMethod() {
                objectOne.deprecatedMethod(); //deprecation warning - suppressed
            }

    Every compiler warning belongs to a category. The Java Language Specification lists two categories: "deprecation" and "unchecked." The "unchecked" warning can occur when interfacing with legacy code written before the advent of generics (discussed in the lesson titled "Generics"). To suppress more than one category of warnings, use the following syntax:

        @SuppressWarnings({"unchecked", "deprecation"})

			6.1.2.2 Annotation Processing

    The more advanced uses of annotations include writing an annotation processor that can read a Java program and take actions based on its annotations. It might, for example, generate auxiliary source code, relieving the programmer of having to create boilerplate code that always follows predictable patterns. To facilitate this task, release 5.0 of the JDK includes an annotation processing tool, called apt. In release 6 of the JDK, the functionality of apt is a standard part of the Java compiler.

    To make annotation information available at runtime, the annotation type itself must be annotated with @Retention(RetentionPolicy.RUNTIME), as follows:

        import java.lang.annotation.*; 

        @Retention(RetentionPolicy.RUNTIME)
        @interface AnnotationForRuntime {

           // Elements that give information
           // for runtime processing
           
        }

	6.2 Enums, enumaration
	An enum type is a type whose fields consist of a fixed set of constants. Common examples include compass directions (values of NORTH, SOUTH, EAST, and WEST) and the days of the week.

Because they are constants, the names of an enum type's fields are in uppercase letters.

In the Java programming language, you define an enum type by using the enum keyword. For example, you would specify a days-of-the-week enum type as:

    public enum Day {
        SUNDAY, MONDAY, TUESDAY, WEDNESDAY, 
        THURSDAY, FRIDAY, SATURDAY 
    }

You should use enum types any time you need to represent a fixed set of constants. That includes natural enum types such as the planets in our solar system and data sets where you know all possible values at compile timefor example, the choices on a menu, command line flags, and so on.

Here is some code that shows you how to use the Day enum defined above:

    public class EnumTest {
    	Day day;
    	
    	public EnumTest(Day day) {
    		this.day = day;
    	}
    	
    	public void tellItLikeItIs() {
    		switch (day) {
    			case MONDAY: System.out.println("Mondays are bad.");
    					     break;
    					
    			case FRIDAY: System.out.println("Fridays are better.");
    					     break;
    					     
    			case SATURDAY:
    			case SUNDAY: System.out.println("Weekends are best.");
    					     break;
    					     
    			default:	 System.out.println("Midweek days are so-so.");
    					     break;
    		}
    	}
    	
    	public static void main(String[] args) {
    		EnumTest firstDay = new EnumTest(Day.MONDAY);
    		firstDay.tellItLikeItIs();
    		EnumTest thirdDay = new EnumTest(Day.WEDNESDAY);
    		thirdDay.tellItLikeItIs();
    		EnumTest fifthDay = new EnumTest(Day.FRIDAY);
    		fifthDay.tellItLikeItIs();
    		EnumTest sixthDay = new EnumTest(Day.SATURDAY);
    		sixthDay.tellItLikeItIs();
    		EnumTest seventhDay = new EnumTest(Day.SUNDAY);
    		seventhDay.tellItLikeItIs();
    		
    		
    	}
    }


The output is:

    Mondays are bad.
    Midweek days are so-so.
    Fridays are better.
    Weekends are best.
    Weekends are best.

Java programming language enum types are much more powerful than their counterparts in other languages. The enum declaration defines a class (called an enum type). The enum class body can include methods and other fields. The compiler automatically adds some special methods when it creates an enum. For example, they have a static values method that returns an array containing all of the values of the enum in the order they are declared. This method is commonly used in combination with the for-each construct to iterate over the values of an enum type. For example, this code from the Planet class example below iterates over all the planets in the solar system.

    for (Planet p : Planet.values()) {
        System.out.printf("Your weight on %s is %f%n",
                              p, p.surfaceWeight(mass));
    }

    Note: All enums implicitly extend java.lang.Enum. Since Java does not support multiple inheritance, an enum cannot extend anything else. 

In the following example, Planet is an enum type that represents the planets in the solar system. They are defined with constant mass and radius properties.

Each enum constant is declared with values for the mass and radius parameters. These values are passed to the constructor when the constant is created. Java requires that the constants be defined first, prior to any fields or methods. Also, when there are fields and methods, the list of enum constants must end with a semicolon.

    Note: The constructor for an enum type must be package-private or private access. It automatically creates the constants that are defined at the beginning of the enum body. You cannot invoke an enum constructor yourself. 

In addition to its properties and constructor, Planet has methods that allow you to retrieve the surface gravity and weight of an object on each planet. Here is a sample program that takes your weight on earth (in any unit) and calculates and prints your weight on all of the planets (in the same unit):

    public enum Planet {
        MERCURY (3.303e+23, 2.4397e6),
        VENUS   (4.869e+24, 6.0518e6),
        EARTH   (5.976e+24, 6.37814e6),
        MARS    (6.421e+23, 3.3972e6),
        JUPITER (1.9e+27,   7.1492e7),
        SATURN  (5.688e+26, 6.0268e7),
        URANUS  (8.686e+25, 2.5559e7),
        NEPTUNE (1.024e+26, 2.4746e7);

        private final double mass;   // in kilograms
        private final double radius; // in meters
        Planet(double mass, double radius) {
            this.mass = mass;
            this.radius = radius;
        }
        private double mass()   { return mass; }
        private double radius() { return radius; }

        // universal gravitational constant  (m3 kg-1 s-2)
        public static final double G = 6.67300E-11;

        double surfaceGravity() {
            return G * mass / (radius * radius);
        }
        double surfaceWeight(double otherMass) {
            return otherMass * surfaceGravity();
        }
        public static void main(String[] args) {
            double earthWeight = Double.parseDouble(args[0]);
            double mass = earthWeight/EARTH.surfaceGravity();
            for (Planet p : Planet.values())
               System.out.printf("Your weight on %s is %f%n",
                                 p, p.surfaceWeight(mass));
        }
    }

If you run Planet.class from the command line with an argument of 175, you get this output:

    $ java Planet 175
    Your weight on MERCURY is 66.107583
    Your weight on VENUS is 158.374842
    Your weight on EARTH is 175.000000
    Your weight on MARS is 66.279007
    Your weight on JUPITER is 442.847567
    Your weight on SATURN is 186.552719
    Your weight on URANUS is 158.397260
    Your weight on NEPTUNE is 199.207413

    6.3 Nested Classes

    The Java programming language allows you to define a class within another class. Such a class is called a nested class and is illustrated here:

        class OuterClass {
            ...
            class NestedClass {
                ...
            }
        }

    A nested class is a member of its enclosing class and, as such, has access to other members of the enclosing class, even if they are declared private. As a member of OuterClass, a nested class can be declared private, public, protected, or package private. (Recall that outer classes can only be declared public or package private.)

        Terminology: Nested classes are divided into two categories: static and non-static. Nested classes that are declared static are simply called static nested classes. Non-static nested classes are called inner classes. 

        class OuterClass {
            ...
            static class StaticNestedClass {
                ...
            }
            class InnerClass {
                ...
            }
        }

    Why Use Nested Classes?
    There are several compelling reasons for using nested classes, among them:

        * It is a way of logically grouping classes that are only used in one place.
        * It increases encapsulation.
        * Nested classes can lead to more readable and maintainable code.

    Logical grouping of classesIf a class is useful to only one other class, then it is logical to embed it in that class and keep the two together. Nesting such "helper classes" makes their package more streamlined.

    Increased encapsulationConsider two top-level classes, A and B, where B needs access to members of A that would otherwise be declared private. By hiding class B within class A, A's members can be declared private and B can access them. In addition, B itself can be hidden from the outside world.

    More readable, maintainable codeNesting small classes within top-level classes places the code closer to where it is used.
    Static Nested Classes
    As with class methods and variables, a static nested class is associated with its outer class. And like static class methods, a static nested class cannot refer directly to instance variables or methods defined in its enclosing class  it can use them only through an object reference.

        Note: A static nested class interacts with the instance members of its outer class (and other classes) just like any other top-level class. In effect, a static nested class is behaviorally a top-level class that has been nested in another top-level class for packaging convenience. 

    Static nested classes are accessed using the enclosing class name:

        OuterClass.StaticNestedClass

    For example, to create an object for the static nested class, use this syntax:

        OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();

    Inner Classes
    As with instance methods and variables, an inner class is associated with an instance of its enclosing class and has direct access to that object's methods and fields. Also, because an inner class is associated with an instance, it cannot define any static members itself.

    Objects that are instances of an inner class exist within an instance of the outer class. Consider the following classes:

        class OuterClass {
            ...
            class InnerClass {
                ...
            }
        }


    An instance of InnerClass can exist only within an instance of OuterClass and has direct access to the methods and fields of its enclosing instance. The next figure illustrates this idea.

    An InnerClass Exists Within an Instance of OuterClass.

    An InnerClass Exists Within an Instance of OuterClass

    To instantiate an inner class, you must first instantiate the outer class. Then, create the inner object within the outer object with this syntax:

        OuterClass.InnerClass innerObject = outerObject.new InnerClass();

    Additionally, there are two special kinds of inner classes: local classes and anonymous classes (also called anonymous inner classes). Both of these will be discussed briefly in the next section. 


	6.2.1 Inner Class Example

    To see an inner class in use, consider a simple stack of integers. Stacks, which are a common data structure in programming, are well-named they are like a "stack" of dishes. When you add a dish to the stack, you put it on top; when you remove one, you remove it from the top. The acronym for this is LIFO (last in, first out). Dishes on the bottom of the stack may stay there quite a long time while the upper dishes come and go.

    The StackOfInts class below is implemented as an array. When you add an integer (called "pushing"), it goes into the first available empty element. When you remove an integer (called "popping"), you remove the last integer in the array.

    The StackOfInts class below (an application) consists of:

        * The StackOfInts outer class, which includes methods to push an integer onto the stack, pop an integer off the stack, and test to see if the stack is empty.
        * The StepThrough inner class, which is similar to a standard Java iterator. Iterators are used to step through a data structure and typically have methods to test for the last element, retrieve the current element, and move to the next element.
        * A main method that instantiates a StackOfInts array (stackOne) and fills it with integers (0, 2, 4, etc.), then instantiates a StepThrough object (iterator) and uses it to print out the contents of stackOne.

        public class StackOfInts {
        	
        	private int[] stack;
        	private int next = 0;  // index of last item in stack + 1
        	
        	public StackOfInts(int size) {
        		//create an array large enough to hold the stack
        		stack = new int[size];
        	}
        	
        	public void push(int on) {
        		if (next < stack.length)
        		   stack[next++] = on;
        	}
        	public boolean isEmpty() {
        		return (next == 0);
        	}
        	
        	public int pop(){
        		if (!isEmpty()) 
        		   return stack[--next]; // top item on stack
        		else
        		   return 0;
        	}
        	
        	public int getStackSize() {
        		return next;
        	}
        	
        	private class StepThrough { 		
        		// start stepping through at i=0
        		private int i = 0; 
        		
        		// increment index
        		public void increment() {
        			if ( i < stack.length)
        			   i++;
        		}
        		
        		// retrieve current element
        		public int current() {
        			return stack[i];
        		}
        		
        		// last element on stack?
        		public boolean isLast(){
        			if (i == getStackSize() - 1)
        			   return true;
        			else
        			   return false;
        		}
        	}
        	
        	public StepThrough stepThrough() {
        		return new StepThrough();
        	}
        	
        	public static void main(String[] args) {
        		
        		// instantiate outer class as "stackOne"
        		StackOfInts stackOne = new StackOfInts(15);
        		
        		// populate stackOne
        		for (int j = 0 ; j < 15 ; j++) {
        			stackOne.push(2*j);
        		}
        		
        		// instantiate inner class as "iterator"
        		StepThrough iterator = stackOne.stepThrough();
        		
        		// print out stackOne[i], one per line
        		while(!iterator.isLast()) {
        			System.out.print(iterator.current() + " ");
        			iterator.increment();
        		}
        		System.out.println();
        		
        	}
        	
        }

    The output is:

        0 2 4 6 8 10 12 14 16 18 20 22 24 26 

    Note that the StepThrough class refers directly to the stack instance variable of StackOfInts.

    Inner classes are used primarily to implement helper classes like the one shown in this example. If you plan on handling user-interface events, you'll need to know about using inner classes because the event-handling mechanism makes extensive use of them.

    Local and Anonymous Inner Classes
    There are two additional types of inner classes. You can declare an inner class within the body of a method. Such a class is known as a local inner class. You can also declare an inner class within the body of a method without naming it. These classes are known as anonymous inner classes. You will encounter such classes in advanced Java programming.

    Modifiers
    You can use the same modifiers for inner classes that you use for other members of the outer class. For example, you can use the access specifiers  private, public, and protected  to restrict access to inner classes, just as you do to other class members. 

    6.4 generics

	6.4.1 Article: Using and Programming Generics in J2SE 5.0
	 
By Qusay H. Mahmoud, October 2004 	  	

A Java collection is a flexible data structure that can hold heterogeneous objects where the elements may have any reference type. It is your responsibility, however, to keep track of what types of objects your collections contain. As an example, consider adding an int to a collection; since you cannot have collections of primitive data types you must convert the int to the corresponding reference type (i.e. Integer) before storing it in the collection. Now, when the element is extracted from the collection an Object is returned that must be cast to an Integer in order to ensure type safety. All this makes Java programs unnecessarily hard to read and maintain, and are more likely to fail with runtime errors.

If the compiler could keep track of the element type, you do not need to keep track of what collections you have and the need for casting would be eliminated. This would make programs easier to read and maintain, and less likely to fail at runtime. J2SE 5.0 has added a new core language feature known as generics (also known as parameterized types), that provides compile-time type safety for collections and eliminate the drudgery of casting. The effort of adding generics to Java is led by Sun Microsystems as JSR 14 under the Java Community Process (JCP).

Generics are one of the most frequently requested language extensions to Java, and they have been finally added in J2SE 5.0. This article provides an introduction to programming with generics.
The Need for Generics

The motivation for adding generics to the Java programming language stems from the lack of information about a collection's element type, the need for developers to keep track of what type of elements collections contain, and the need for casts all over the place. Using generics, a collection is no longer treated as a list of Object references, but you would be able to differentiate between a collection of references to Integers and collection of references to Bytes. A collection with a generic type has a type parameter that specifies the element type to be stored in the collection.

As an example, consider the following segment of code that creates a linked list and adds an element to the list:

LinkedList list = new LinkedList();
list.add(new Integer(1));
Integer num = (Integer) list.get(0);


As you can see, when an element is extracted from the list it must be cast. The casting is safe as it will be checked at runtime, but if you cast to a type that is different from, and not a supertype of, the extracted type then a runtime exception, ClassCastException will be thrown.

Using generic types, the previous segment of code can be written as follows:

LinkedList<Integer> list = new LinkedList<Integer>();
list.add(new Integer(1));
Integer num = list.get(0);


Here we say that LinkedList is a generic class that takes a type parameter, Integer in this case.

As you can see, you no longer need to cast to an Integer since the get() method would return a reference to an object of a specific type (Integer in this case). If you were to assign an extracted element to a different type, the error would be at compile-time instead of run-time. This early static checking increases the type safety of the Java language.

To reduce the clutter, the above example can be rewritten as follows...using autoboxing:

LinkedList<Integer> list = new LinkedList<Integer>();
list.add(1);
int num = list.get(0);


As a complete example, consider the following class, Ex1, which creates a collection of two Strings and one Integer, and then prints out the collection:

Ex1.java

import java.util.*;

public class Ex1 {

  private void testCollection() {
    List list = new ArrayList();
    list.add(new String("Hello world!"));
    list.add(new String("Good bye!"));
    list.add(new Integer(95));
    printCollection(list);
  }

  private void printCollection(Collection c) {
    Iterator i = c.iterator();
    while(i.hasNext()) {
      String item = (String) i.next();
      System.out.println("Item: "+item);
    }
  }

  public static void main(String argv[]) {
    Ex1 e = new Ex1();
    e.testCollection();
  }
}


Again, an explicit cast is required in the printCollection method. This class compiles fine, but throws a CLassCastException at runtime as it attempts to cast an Integer to a String:

Item: Hello world!
Item: Good bye!
Exception in thread "main" java.lang.ClassCastException: java.lang.Integer
        at Ex1.printCollection(Ex1.java:16)
        at Ex1.testCollection(Ex1.java:10)
        at Ex1.main(Ex1.java:23)


Using Generics

Using generics, the Ex1 class above can be written as follows:

Ex2.java

import java.util.*;

public class Ex2 {

  private void testCollection() {
    List<String> list = new ArrayList<String>();
    list.add(new String("Hello world!"));
    list.add(new String("Good bye!"));
    list.add(new Integer(95));
    printCollection(list);
  }

  private void printCollection(Collection c) {
    Iterator<String> i = c.iterator();
    while(i.hasNext()) {
      System.out.println("Item: "+i.next());
    }
  }

  public static void main(String argv[]) {
    Ex2 e = new Ex2();
    e.testCollection();
  }
}


Now, if you try to compile this code, a compile-time error will be produced informing you that you cannot add an Integer to a collection of Strings. Therefore, generics enable more compile-time type checking and therefore mismatch errors are caught at compile-time rather than at run-time.

You may have already noticed the new syntax used to create an instance of ArrayList (List<String> list = new ArrayList<String>()). ArrayList is now a parameterized type. A parameterized type consists of a class or interface name E and a parameter section <T1, T2, ..., Tn>, which must match the number of declared parameters of E, and each actual parameter must be a subtype of the formal parameter's bound types. The following segment of code shows parts of the new class definition for ArrayList:

public class ArrayList<E> extends AbstractList<E> implements List<E>, 
    RandomAccess, Cloneable, Serializable {
   // ...
}


Here E is a type variable, which is an unqualified identifier. It simply acts as a placeholder for a type to be defined when the list is used.
Implementing Generic Types

In addition to using generic types, you can implement your own. A generic type has one or more type parameters. Here is an example with only one type parameter called E. A parameterized type must be a reference type, and therefore primitive types are not allowed to be parameterized types.

interface List<E> {
   void add(E x);
   Iterator<E> iterator();
}

interface Iterator<E> {
   E next();
   boolean hasNext();
}


class LinkedList<E> implements List<E> {
   // implementation   
}


Here, E represents the type of elements contained in the collection. Think of E as a placeholder that will be replaced by a concrete type. For example, if you write LinkedList<String> then E will be replaced by String.

In some of your code you may need to invoke methods of the element type, such as Object's hashCode() and equals(). Here is an example that takes two type parameters:

class HashMap<K, V> extends AbstractMap<K, V> implements Map<K, V> {

   // ...

   public V get(Object k) {
      ...
      int hash = k.hashCode();  
      ...
   }
   // ...   
}


The important thing to note is that you are required to replace the type variables K and V by concrete types that are subtypes of Object.
Generic Methods

Genericity is not limited to classes and interfaces, you can define generic methods. Static methods, nonstatic methods, and constructors can all be parameterized in almost the same way as for classes and interfaces, but the syntax is a bit different. Generic methods are also invoked in the same way as non-generic methods.

Before we see an example of a generics method, consider the following segment of code that prints out all the elements in a collection:

public void printCollection(Collection c) {
   Iterator i = c.iterator();
   for(int k = 0;k<c.size();k++) {
     System.out.println(i.next());
   }
}


Using generics, this can be re-written as follows. Note that the Collection<?> is the collection of an unknown type.

void printCollection(Collection<?> c) {
   for(Object o:c) {
      System.out.println(o);
   }
}


This example uses a feature of generics known as wildcards.
Wildcards

There are three types of wildcards:

   1. "? extends Type": Denotes a family of subtypes of type Type. This is the most useful wildcard
   2. "? super Type": Denotes a family of supertypes of type Type
   3. "?": Denotes the set of all types or any 

As an example of using wildcards, consider a draw() method that should be capable of drawing any shape such as circle, rectangle, and triangle. The implementation may look something like this. Here Shape is an abstract class with three subclasses: Circle, Rectangle, and Triangle.

public void draw(List<Shape> shape) {
  for(Shape s: shape) {
    s.draw(this);
  }
}


It is worth noting that the draw() method can only be called on lists of Shape and cannot be called on a list of Circle, Rectangle, and Triangle for example. In order to have the method accept any kind of shape, it should be written as follows:

public void draw(List<? extends Shape> shape) {
   // rest of the code is the same
}


Here is another example of a generics method that uses wildcards to sort a list into ascending order. Basically, all elements in the list must implement the Comparable interface.

public static <T extends Comparable<? super T>> void sort(List<T> list) {
   Object a[] = list.toArray();
   Arrays.sort(a);
   ListIterator<T> i = list.listIterator();
   for(int j=0; j<a.length; j++) {
      i.index();
      i.set((T)a[j]);
   }
}


Changes to the Java Specification, JVM, and APIs

In order to support generic types, some modifications are necessary to the Java programming language, the Java virtual machine1, and the Java APIs. The notable changes to the Java APIs are related to the Collection hierarchy in the java.util package, changes to the java.lang.Class class, and the java.lang.reflect package so that it is possible to examine a type, method, constructor or field declaration and obtain generic type information. If you like to learn about the exact changes, please see JSR 14: Adding Generics to the Java Programming Language.
Behind the Scenes

Generics are implemented by the Java compiler as a front-end conversion called erasure, which is the process of translating or rewriting code that uses generics into non-generic code (that is, maps the new syntax to the current JVM specification). In other words, this conversion erases all generic type information; all information between angle brackets is erased. For example, LinkedList<Integer> will become LinkedList. Uses of other type variables are replaced by the upper bound of the type variable (for example, Object), and when the resulting code is not type correct, a cast to the appropriate type is inserted.
Java Generics vs. C++ Templates

While generics look like the C++ templates, it is important to note that they are not the same. Generics simply provide compile-time type safety and eliminate the need for casts. The main difference is encapsulation: errors are flagged where they occur and not later at some use site, and source code is not exposed to clients. Generics use a technique known as type erasure as described above, and the compiler keeps track of the generics internally, and all instances use the same class file at compile/run time.

A C++ template on the other hand is just a fancy macro processor; whenever a template class is instantiated with a new class, the entire code for the class is reproduced and recompiled for the new class.
Conclusion

Generics are a new core feature in J2SE 5.0, and a major addition to the core language. This feature provides a useful abstract and compile-time type safety for collections and eliminates the drudgery of casting. This article provided an overview and introduction to Java generics, and showed how to use generics as well as write your own. The examples provided in this article demonstrate how useful this new core feature is. 

7. Install

	7.1 Linux
a. http://www.oracle.com/technetwork/java/javase/install-linux-self-extracting-138783.html
Installation Instructions
This procedure installs the Java Development Kit (JDK) for 32-bit Linux, using a self-extracting binary file. The JDK download includes the Java SE Runtime Environment (JRE) – you do not have to download the JRE separately.

For RPM-based Linux distributions, like Red Hat or SuSE, refer to the RPM installation instructions.

The name of the downloaded file has the following format:

    jdk-6u
            
<version>-linux-i586.bin
          
<version>
    jdk-6u18-linux-i586.bin
To install, download this file and use the following instructions.


a1. Download and check the download file size. 
You can download to any directory that you can write to.

This bundle can be installed by anyone (not only root users), in any location that the user can write to. However, only the root user can displace the system version of the Java platform supplied by Linux.

a2. Make sure that execute permissions are set
Run this command: 
% chmod a+x jdk-6u <version>-linux-i586.bin
a3. Change directory to the location where you would like the files to be installed.

The next step installs the JDK into the current directory.
Note, on my box its /usr/java

a4. Run the self-extracting binary.

Execute the downloaded file, prepended by the path to it. For example, if the file is in the current directory, prepend it with " ./" (necessary if " ." is not in the PATH environment variable):
% ./jdk-6u <version>-linux-i586.bin

b. create symbolic links
[yizaq@yizaq-lnx:Thu Dec 02:/usr/java]$ sudo rm /usr/bin/java /usr/bin/javac
[yizaq@yizaq-lnx:Thu Dec 02:/usr/java]$ sudo ln -s /usr/java/jdk1.6.0_22/bin/java   /usr/bin/java
[yizaq@yizaq-lnx:Thu Dec 02:/usr/java]$ ls -l /usr/bin/java
lrwxrwxrwx  1 root root 30 Dec  2 17:46 /usr/bin/java -> /usr/java/jdk1.6.0_22/bin/java*
[yizaq@yizaq-lnx:Thu Dec 02:/usr/java]$ sudo ln -s /usr/java/jdk1.6.0_22/bin/javac   /usr/bin/javac
[yizaq@yizaq-lnx:Thu Dec 02:/usr/java]$ java -version
java version "1.6.0_22"
Java(TM) SE Runtime Environment (build 1.6.0_22-b04)
Java HotSpot(TM) Server VM (build 17.1-b03, mixed mode)

c. modify Environment variables
[yizaq@yizaq-lnx:Thu Dec 02:/view/yizaq__yizaq.PI_Rest.int.acs5_0.lx/vob/nm_acs/acs/mgmt]$ grep JAVA_HOME ~/.bashrc 
PATH=${PATH}:/auto/cwtools/perl/focus/bin/lnx/:/usr/atria/bin/:/sbin/:/vob/enm_jdk/maven-2.0.9/bin:JAVA_HOME/:auto/cwtools/perl/focus/bin/lnx:/usr/atria/bin:
JAVA_HOME=/usr/java/jdk1.5.0_10; export JAVA_HOME;
[yizaq@yizaq-lnx:Thu Dec 02:/view/yizaq__yizaq.PI_Rest.int.acs5_0.lx/vob/nm_acs/acs/mgmt]$ ed !$
ed ~/.bashrc
1510
/jdk1.5.0_10
JAVA_HOME=/usr/java/jdk1.5.0_10; export JAVA_HOME;
s/jdk1.5.0_10/jdk1.6.0_22/
p
JAVA_HOME=/usr/java/jdk1.6.0_22; export JAVA_HOME;
w
q
1510

d.  Fix GTK fonts issue
[yizaq@yizaq-lnx:Sun Dec 05:/usr/share/fonts]$ eclipse

** (Eclipse:8821): WARNING **: Cannot open font file for font Lucida Sans 10

** (Eclipse:8821): WARNING **: Cannot open fallback font, nothing to do
[yizaq@yizaq-lnx:Sun Dec 05:/usr/share/fonts]$ locate Lucida
/usr/java/jdk1.6.0_22/jre/lib/fonts/LucidaSansDemiBold.ttf
/usr/java/jdk1.6.0_22/jre/lib/fonts/LucidaTypewriterBold.ttf
/usr/java/jdk1.6.0_22/jre/lib/fonts/LucidaBrightDemiItalic.ttf
/usr/java/jdk1.6.0_22/jre/lib/fonts/LucidaBrightDemiBold.ttf
/usr/java/jdk1.6.0_22/jre/lib/fonts/LucidaTypewriterRegular.ttf
/usr/java/jdk1.6.0_22/jre/lib/fonts/LucidaBrightRegular.ttf
/usr/java/jdk1.6.0_22/jre/lib/fonts/LucidaBrightItalic.ttf
/usr/java/jdk1.6.0_22/jre/lib/fonts/LucidaSansRegular.ttf
/usr/java/jdk1.6.0_22/jre/lib/oblique-fonts/LucidaSansDemiOblique.ttf
/usr/java/jdk1.6.0_22/jre/lib/oblique-fonts/LucidaTypewriterOblique.ttf
/usr/java/jdk1.6.0_22/jre/lib/oblique-fonts/LucidaTypewriterBoldOblique.ttf
/usr/java/jdk1.6.0_22/jre/lib/oblique-fonts/LucidaSansOblique.ttf
[yizaq@yizaq-lnx:Sun Dec 05:/usr/share/fonts]$ sudo mkdir /usr/java/jdk1.5.0_10/
Password:
[yizaq@yizaq-lnx:Sun Dec 05:/usr/share/fonts]$ sudo mkdir /usr/java/jdk1.5.0_10/jre
[yizaq@yizaq-lnx:Sun Dec 05:/usr/share/fonts]$ sudo mkdir /usr/java/jdk1.5.0_10/jre/lib
[yizaq@yizaq-lnx:Sun Dec 05:/usr/share/fonts]$ sudo cp -r /usr/java/jdk1.6.0_22/jre/lib/fonts/ /usr/java/jdk1.5.0_10/jre/lib/

e. Fix vnc server issue (somehow depends on previous jre)
[yizaq@yizaq-lnx:Mon Dec 06:/usr/java/jdk1.5.0_10]$ ln -s ../jdk1.6.0_22/jre/ jre

	7.2 Mac. tags: install java MAC OSX
install via brew:
 brew tap adoptopenjdk/openjdk
 brew install --cask adoptopenjdk8

	7.3
8. Code Snipplets

	8.1 Encoding, utf-8, utf-16
import java.io.ByteArrayInputStream;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;


public class EncodingTester {

	/**
	Name: 
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		String original = new String("A" + "\u00ea" + "\u00f1" + "\u00fc" + "C");
		System.out.println("UTF-16 string:"+original);
		
		try {
			byte[] utf8bytes = original.getBytes("UTF8");
			String utf8str = new String(utf8bytes, "UTF8");
			System.out.println("UTF-8 string:"+utf8str);
			
			InputStreamReader isr = new InputStreamReader(new ByteArrayInputStream(original.getBytes()));
			System.out.println("String enoding is:"+isr.getEncoding());
			isr = new InputStreamReader(new ByteArrayInputStream(utf8str.getBytes()));
			System.out.println("String enoding is:"+isr.getEncoding());
			
		} catch (UnsupportedEncodingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		

	}

}

	8.2

9. Cookbook

	9.1  Files


		9.1.1   read file content java

			9.1.1.1   Reading and writing text files

When reading and writing text files :

    it's almost always a good idea to use buffering (default size is 8K)
    it's often possible to use references to abstract base classes, instead of references to specific concrete classes
    there is always a need to pay attention to exceptions (in particular, IOException and FileNotFoundException)

The close method :

    always needs to be called, or else resources will leak
    will automatically flush the stream, if necessary
    calling close on a "wrapper" stream will automatically call close on its underlying stream
    closing a stream a second time has no consequence
    when called on a Scanner, the close operation only works if the item passed to its constructor implements Closeable. Warning: if you pass a File to a Scanner, you will not be able to close it! Try using a FileReader instead. 

Commonly used items :

    Scanner - allows reading files in a compact way
    BufferedReader - readLine
    BufferedWriter - write + newLine

The FileReader and FileWriter classes are a bit tricky, since they implicitly use the system's default character encoding. If this default is not appropriate (for example, when reading an XML file which specifies its own encoding), the recommended alternatives are, for example :

FileInputStream fis = new FileInputStream("test.txt");
InputStreamReader in = new InputStreamReader(fis, "UTF-8");

FileOutputStream fos = new FileOutputStream("test.txt");
OutputStreamWriter out = new OutputStreamWriter(fos, "UTF-8");

Scanner scanner = new Scanner(file, "UTF-8");

Example 1

Here is a fairly compact example (for JDK 1.5) of reading and writing a text file, using an explicit encoding. If you remove all references to encoding from this class, it will still work -- the system's default encoding will simply be used instead.

import java.io.*;
import java.util.Scanner;

/** 
 Read and write a file using an explicit encoding.
 Removing the encoding from this code will simply cause the 
 system's default encoding to be used instead.  
*/
public final class ReadWriteTextFileWithEncoding {

  /** Requires two arguments - the file name, and the encoding to use.  */
  public static void main(String... aArgs) throws IOException {
    String fileName = aArgs[0];
    String encoding = aArgs[1];
    ReadWriteTextFileWithEncoding test = new ReadWriteTextFileWithEncoding(
      fileName, encoding
    );
    test.write();
    test.read();
  }
  
  /** Constructor. */
  ReadWriteTextFileWithEncoding(String aFileName, String aEncoding){
    fEncoding = aEncoding;
    fFileName = aFileName;
  }
  
  /** Write fixed content to the given file. */
  void write() throws IOException  {
    log("Writing to file named " + fFileName + ". Encoding: " + fEncoding);
    Writer out = new OutputStreamWriter(new FileOutputStream(fFileName), fEncoding);
    try {
      out.write(FIXED_TEXT);
    }
    finally {
      out.close();
    }
  }
  
  /** Read the contents of the given file. */
  void read() throws IOException {
    log("Reading from file.");
    StringBuilder text = new StringBuilder();
    String NL = System.getProperty("line.separator");
    Scanner scanner = new Scanner(new FileInputStream(fFileName), fEncoding);
    try {
      while (scanner.hasNextLine()){
        text.append(scanner.nextLine() + NL);
      }
    }
    finally{
      scanner.close();
    }
    log("Text read in: " + text);
  }
  
  // PRIVATE 
  private final String fFileName;
  private final String fEncoding;
  private final String FIXED_TEXT = "But soft! what code in yonder program breaks?";
  
  private void log(String aMessage){
    System.out.println(aMessage);
  }
}
 



Example 2

This example uses FileReader and FileWriter, which implicitly use the system's default encoding. To make this example compatible with JDK 1.4, just change StringBuilder to StringBuffer:

import java.io.*;

public class ReadWriteTextFile {

  /**
  * Fetch the entire contents of a text file, and return it in a String.
  * This style of implementation does not throw Exceptions to the caller.
  *
  * @param aFile is a file which already exists and can be read.
  */
  static public String getContents(File aFile) {
    //...checks on aFile are elided
    StringBuilder contents = new StringBuilder();
    
    try {
      //use buffering, reading one line at a time
      //FileReader always assumes default encoding is OK!
      BufferedReader input =  new BufferedReader(new FileReader(aFile));
      try {
        String line = null; //not declared within while loop
        /*
        * readLine is a bit quirky :
        * it returns the content of a line MINUS the newline.
        * it returns null only for the END of the stream.
        * it returns an empty String if two newlines appear in a row.
        */
        while (( line = input.readLine()) != null){
          contents.append(line);
          contents.append(System.getProperty("line.separator"));
        }
      }
      finally {
        input.close();
      }
    }
    catch (IOException ex){
      ex.printStackTrace();
    }
    
    return contents.toString();
  }

  /**
  * Change the contents of text file in its entirety, overwriting any
  * existing text.
  *
  * This style of implementation throws all exceptions to the caller.
  *
  * @param aFile is an existing file which can be written to.
  * @throws IllegalArgumentException if param does not comply.
  * @throws FileNotFoundException if the file does not exist.
  * @throws IOException if problem encountered during write.
  */
  static public void setContents(File aFile, String aContents)
                                 throws FileNotFoundException, IOException {
    if (aFile == null) {
      throw new IllegalArgumentException("File should not be null.");
    }
    if (!aFile.exists()) {
      throw new FileNotFoundException ("File does not exist: " + aFile);
    }
    if (!aFile.isFile()) {
      throw new IllegalArgumentException("Should not be a directory: " + aFile);
    }
    if (!aFile.canWrite()) {
      throw new IllegalArgumentException("File cannot be written: " + aFile);
    }

    //use buffering
    Writer output = new BufferedWriter(new FileWriter(aFile));
    try {
      //FileWriter always assumes default encoding is OK!
      output.write( aContents );
    }
    finally {
      output.close();
    }
  }

  /** Simple test harness.   */
  public static void main (String... aArguments) throws IOException {
    File testFile = new File("C:\\Temp\\blah.txt");
    System.out.println("Original file contents: " + getContents(testFile));
    setContents(testFile, "The content of this file has been overwritten...");
    System.out.println("New file contents: " + getContents(testFile));
  }
} 



Example 3

This example demonstrates using Scanner to read a file containing lines of structured data. Each line is then parsed using a second Scanner and a simple delimiter character, used to separate each line into a name-value pair. The Scanner class is used only for reading, not for writing.

import java.io.*;
import java.util.Scanner;

public class ReadWithScanner {

  public static void main(String... aArgs) throws FileNotFoundException {
    ReadWithScanner parser = new ReadWithScanner("C:\\Temp\\test.txt");
    parser.processLineByLine();
    log("Done.");
  }
  
  /**
   Constructor.
   @param aFileName full name of an existing, readable file.
  */
  public ReadWithScanner(String aFileName){
    fFile = new File(aFileName);  
  }
  
  /** Template method that calls {@link #processLine(String)}.  */
  public final void processLineByLine() throws FileNotFoundException {
    //Note that FileReader is used, not File, since File is not Closeable
    Scanner scanner = new Scanner(new FileReader(fFile));
    try {
      //first use a Scanner to get each line
      while ( scanner.hasNextLine() ){
        processLine( scanner.nextLine() );
      }
    }
    finally {
      //ensure the underlying stream is always closed
      //this only has any effect if the item passed to the Scanner
      //constructor implements Closeable (which it does in this case).
      scanner.close();
    }
  }
  
  /** 
   Overridable method for processing lines in different ways.
    
   <P>This simple default implementation expects simple name-value pairs, separated by an 
   '=' sign. Examples of valid input : 
   <tt>height = 167cm</tt>
   <tt>mass =  65kg</tt>
   <tt>disposition =  "grumpy"</tt>
   <tt>this is the name = this is the value</tt>
  */
  protected void processLine(String aLine){
    //use a second Scanner to parse the content of each line 
    Scanner scanner = new Scanner(aLine);
    scanner.useDelimiter("=");
    if ( scanner.hasNext() ){
      String name = scanner.next();
      String value = scanner.next();
      log("Name is : " + quote(name.trim()) + ", and Value is : " + quote(value.trim()) );
    }
    else {
      log("Empty or invalid line. Unable to process.");
    }
    //no need to call scanner.close(), since the source is a String
  }
  
  // PRIVATE 
  private final File fFile;
  
  private static void log(Object aObject){
    System.out.println(String.valueOf(aObject));
  }
  
  private String quote(String aText){
    String QUOTE = "'";
    return QUOTE + aText + QUOTE;
  }
} 



Example run of this class :

Name is : 'height', and Value is : '167cm'
Name is : 'mass', and Value is : '65kg'
Name is : 'disposition', and Value is : '"grumpy"'
Name is : 'this is the name', and Value is : 'this is the value'
Done.


			9.1.1.2 BufferedReader

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class SimpleFileReader {
	public static void main(String[] args) {
		 
		BufferedReader br = null;
 
		try {
 
			String sCurrentLine;
 
			br = new BufferedReader(new FileReader("C:\\license"));
 
			while ((sCurrentLine = br.readLine()) != null) {
				System.out.println(sCurrentLine);
			}
 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				if (br != null)br.close();
			} catch (IOException ex) {
				ex.printStackTrace();
			}
		}
 
	}
}
			9.1.1.3

		9.1.2 Edit files


			9.1.2.1 Java – Edit File Example, Modify File java

File can be appended by File class and other input output stream. To write content in a file in java we need to use java.io package. File class is used to create a file at specific path. We can use either StringBuffer for text and content to store in file. In java we can write file with FileWriter class with BufferedWriter class. write() method is used to create file and write the content in file.

To edit file in java we need to search text which replace with new text. indexOf() method will search text in java and append() method will modify old content in string.

This example will explain how to edit file in java and modify text in file by java.

text file in c drive

Content in this text, abc change xyz with new content by java io package

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;

public class JavaIOEditFileExample {

    public static void main(String[] args) {

        File f=new File("c:\\appendOldFile.txt");

        FileInputStream fs = null;
        InputStreamReader in = null;
        BufferedReader br = null;

        StringBuffer sb = new StringBuffer();

        String textinLine;

        try {
             fs = new FileInputStream(f);
             in = new InputStreamReader(fs);
             br = new BufferedReader(in);

            while(true)
            {
                textinLine=br.readLine();
                if(textinLine==null)
                    break;
                sb.append(textinLine);
            }
              String textToEdit1 = "abc";
              int cnt1 = sb.indexOf(textToEdit1);
              sb.replace(cnt1,cnt1+textToEdit1.length(),"New Append text");

              String textToEdit2 = "xyz";
              int cnt2 = sb.indexOf(textToEdit2);
              sb.replace(cnt2,cnt2+textToEdit2.length(),"Second new edit text");

              fs.close();
              in.close();
              br.close();

            } catch (FileNotFoundException e) {
              e.printStackTrace();
            } catch (IOException e) {
              e.printStackTrace();
            }

            try{
                FileWriter fstream = new FileWriter(f);
                BufferedWriter outobj = new BufferedWriter(fstream);
                outobj.write(sb.toString());
                outobj.close();

            }catch (Exception e){
              System.err.println("Error: " + e.getMessage());
            }
    }
}

Output

Content in this text, New Append text change Second new edit text with new content by java io package

			9.1.2.2

		9.1.3
	9.2


10. IDEs

	10.1 Eclipse

		10.1.1 Quick references

			10.1.1.1 official
Keyboard Shortcuts Eclipse 3.1
Emacs configuration

Edit
Content Assist		Alt+/	In Dialogs and Windows
Context Information		Alt+?		In Windows
Context Information		Shift+Alt+?	In Windows
Context Information		Shift+Ctrl+Space	In Windows
Copy			Alt+W	In Dialogs and Windows
Copy			Ctrl+C	In Dialogs and Windows
Copy			Ctrl+Insert	In Dialogs and Windows
Copy			Esc W	In Dialogs and Windows
Cut			Ctrl+W	In Dialogs and Windows
Cut			Ctrl+X	In Dialogs and Windows
Cut			Shift+Del	In Dialogs and Windows
Delete			Delete		In Windows
Find Previous		Shift+Ctrl+K	Editing Text
Find and Replace		Alt+R		In Windows
Find and Replace		Esc R		In Windows
Incremental Find		Ctrl+J		Editing Text
Incremental Find		Ctrl+S		Editing Text
Incremental Find Reverse	Ctrl+R		Editing Text
Incremental Find Reverse	Shift+Ctrl+J	Editing Text
Paste			Ctrl+Y	In Dialogs and Windows
Paste			Shift+Ins	In Dialogs and Windows
Quick Diff Toggle		Shift+Ctrl+Q	Editing Text
Quick Fix			Ctrl+1		In Windows
Redo			Ctrl+X R		In Windows
Redo			F10		In Windows
Redo			Shift+Ctrl++	In Windows
Restore Last Selection	Shift+Alt+Down	Editing Java Source
Select All			Ctrl+X H	In Dialogs and Windows
Select Enclosing Element	Shift+Alt+Up	Editing Java Source
Select Next Element		Shift+Alt+Right	Editing Java Source
Select Previous Element	Shift+Alt+Left	Editing Java Source
Show Tooltip Description	F2		Editing Java Source
Toggle Insert Mode		Shift+Ctrl+Insert	Editing Text
Undo			Ctrl+X U		In Windows
Undo			F9		In Windows
Undo			Shift+Ctrl+-	In Windows






© 2005 Carsten Ullrich.
Creative Commons Attribution-ShareAlike 2.5 License
http://creativecommons.org/licenses/by-sa/2.5/


File
Close			Ctrl+F4		In Windows
Close			Ctrl+X K		In Windows
Close All			Ctrl+X Ctrl+C	In Windows
Close All			Shift+Ctrl+F4	In Windows
Close All			Shift+Ctrl+W	In Windows
New menu			Shift+Alt+N	In Windows
Print			Alt+F9		In Windows
Print			Esc F9		In Windows
Properties			Alt+Enter		In Windows
Refresh			F5		In Windows
Rename			F2		In Windows
Save			Ctrl+X Ctrl+S	In Windows
Save All			Ctrl+X S		In Windows
Save All			Shift+Ctrl+S	In Windows

Navigate
Backward History		Alt+Left		In Windows
Forward History		Alt+Right		In Windows
Go to Line			Ctrl+L		Editing Text
Go to Line			Ctrl+X G		Editing Text
Go to Matching Bracket	Shift+Ctrl+P	Editing Java Source
Go to Next Member		Shift+Ctrl+Down	Editing Java Source
Go to Previous Member	Shift+Ctrl+Up	Editing Java Source
Last Edit Location		Ctrl+Q		In Windows
Next			Ctrl+.		In Windows
Open Call Hierarchy		Ctrl+Alt+H		In Windows
Open Declaration		F3		In Windows
Open External Javadoc	Shift+F2		In Windows
Open Resource		Shift+Ctrl+R	In Windows
Open Structure		Ctrl+F3		Editing Java Source
Open Type			Shift+Ctrl+T	In Windows
Open Type Hierarchy		F4		In Windows
Open Type in Hierarchy	Shift+Ctrl+H	In Windows
Previous			Ctrl+		In Windows
Quick Hierarchy		Ctrl+T		Editing Java Source
Quick Outline		Ctrl+O		Editing Java Source
Show In menu		Shift+Alt+W	In Windows

Refactor - Java
Change Method Signature	Shift+Alt+C	In Windows
Convert Local Variable to Field	Shift+Alt+F	Editing Java Source
Extract Local Variable		Shift+Alt+L	In Windows
Extract Method		Shift+Alt+M	In Windows
Inline			Shift+Alt+I		In Windows
Move - Refactoring 		Shift+Alt+V	In Windows
Redo - Refactoring 		Shift+Alt+Y	In Windows
Rename - Refactoring 	Shift+Alt+R	In Windows
Show Refactor Quick Menu	Shift+Alt+T	In Windows
Undo - Refactoring		Shift+Alt+Z	In Windows



Run/Debug
Debug Ant Build		Shift+Alt+D Q	In Windows
Debug Eclipse Application	Shift+Alt+D E	In Windows
Debug JUnit Plug-in Test	Shift+Alt+D P	In Windows
Debug JUnit Test		Shift+Alt+D T	In Windows
Debug Java Applet		Shift+Alt+D A	In Windows
Debug Java Application	Shift+Alt+D J	In Windows
Debug Last Launched		F11		In Windows
Debug SWT Application	Shift+Alt+D S	In Windows
Display			Shift+Ctrl+D	In Dialogs&Windows
Display			Shift+Ctrl+V	In Dialogs&Windows
Execute			Ctrl+U		In Windows
Inspect			Shift+Ctrl+I	In Dialogs&Windows
Resume			F8		Debugging
Run Ant Build		Shift+Alt+X Q	In Windows
Run Eclipse Application	Shift+Alt+X E	In Windows
Run JUnit Plug-in Test	Shift+Alt+X P	In Windows
Run JUnit Test		Shift+Alt+X T	In Windows
Run Java Applet		Shift+Alt+X A	In Windows
Run Java Application		Shift+Alt+X J	In Windows
Run Last Launched		Ctrl+F11		In Windows
Run SWT Application		Shift+Alt+X S	In Windows
Step Into			F5		Debugging
Step Into Selection		Ctrl+F5		Debugging
Step Over			F6		Debugging
Step Return		F7		Debugging
Toggle Line Breakpoint	Shift+Ctrl+B	In Windows
Toggle Step Filters		Shift+F5		In Windows

Search
Open Search Dialog		Ctrl+H		In Windows
References in Workspace	Shift+Ctrl+G	In Windows
Show Occurrences in File Quick Menu	Shift+Ctrl+U In Windows


















Source
Add Block Comment		Shift+Ctrl+/	Editing Java Source
Add Import			Shift+Ctrl+M	Editing Java Source
Add Javadoc Comment	Shift+Alt+J	In Windows
Format			Esc Ctrl+F		Editing Java Source
Format			Shift+Ctrl+F	Editing Ant Buildfiles
Indent Line			Ctrl+I		Editing Java Source
Open External Documentation	Shift+F2		Editing Ant Buildfiles
Organize Imports		Shift+Ctrl+O	In Windows
Quick Assist - Assign to field	Ctrl+2 F		Editing Java Source
Quick Assist - Assign to local variable Ctrl+2 L	Editing Java Source
Quick Assist - Rename in file	Ctrl+2 R		Editing Java Source
Remove Block Comment	Shift+Ctrl+\	Editing Java Source
Remove Occurrence Annotations	Shift+Alt+U	Editing Java Source
Rename In File		Shift+Alt+R	Editing Ant Buildfiles
Show Source Quick Menu	Shift+Alt+S	In Windows
Show Tooltip Description	F2		Editing Ant Buildfiles
Toggle Ant Mark Occurrences	Shift+Alt+O	Editing Ant Buildfiles
Toggle Comment		Ctrl+/		Editing Java Source
Toggle Comment		Ctrl+7		Editing Java Source
Toggle Comment		Esc Ctrl+C	Editing Java Source
Toggle Mark Occurrences	Shift+Alt+O	Editing Java Source


Text Editing
Clear Mark			Ctrl+G		Editing Text
Collapse			Ctrl+Numpad_SubtractEditing Text
Copy Lines			Ctrl+Alt+Down	Editing Text
Cut to Beginning of Line	Alt+0 Ctrl+K	Editing Text
Cut to Beginning of Line	Esc 0 Ctrl+K	Editing Text
Cut to End of Line		Ctrl+K		Editing Text
Delete Next		Ctrl+D		Editing Text
Delete Next Word		Alt+D		Editing Text
Delete Next Word		Ctrl+Delete	Editing Text
Delete Next Word		Esc D		Editing Text
Delete Previous Word		Alt+Backspace	Editing Text
Delete Previous Word		Ctrl+Backspace	Editing Text
Delete Previous Word		Esc Backspace	Editing Text
Delete to End of Line		Shift+Ctrl+Delete	Editing Text
Duplicate Lines		Ctrl+Alt+Up	Editing Text
Expand			Ctrl+Numpad_Add	Editing Text
Expand All			Ctrl+Numpad_Multiply Editing Text
Insert Line Above Current Line	Shift+Ctrl+Enter	Editing Text
Insert Line Below Current Line	Shift+Enter	Editing Text
Line Down			Ctrl+N		Editing Text
Line End			Ctrl+E		Editing Text
Line Start			Ctrl+A		Editing Text
Line Up			Ctrl+P		Editing Text
Move Lines Down		Alt+Down		Editing Text
Move Lines Up		Alt+Up		Editing Text
Next Column		Ctrl+F		Editing Text
Next Word			Alt+F		Editing Text
Next Word			Ctrl+Right		Editing Text
Next Word			Esc F		Editing Text
Page Down		Ctrl+V		Editing Text
Page Up			Alt+V		Editing Text
Page Up			Esc V		Editing Text
Previous Column		Ctrl+B		Editing Text
Previous Word		Alt+B		Editing Text
Previous Word		Ctrl+Left		Editing Text
Previous Word		Esc B		Editing Text
Scroll Line Down		Ctrl+Down		Editing Text
Scroll Line Down		Ctrl+Z		Editing Text
Scroll Line Up		Alt+Z		Editing Text
Scroll Line Up		Ctrl+Up		Editing Text
Scroll Line Up		Esc Z		Editing Text
Select Next Word		Shift+Ctrl+Right	Editing Text
Select Previous Word		Shift+Ctrl+Left	Editing Text
Set Mark			Ctrl+2		Editing Text
Set Mark			Ctrl+Space	Editing Text
Swap Mark			Ctrl+X Ctrl+X	Editing Text
Text End			Alt+>		Editing Text
Text End			Ctrl+X ]		Editing Text
Text End			Esc >		Editing Text
Text End			Esc Shift+>	Editing Text
Text End			Shift+Alt+>	Editing Text
Text Start			Alt+<		Editing Text
Text Start			Ctrl+X [		Editing Text
Text Start			Esc <		Editing Text
Text Start			Esc Shift+<	Editing Text
Text Start			Shift+Alt+<	Editing Text
To Lower Case		Shift+Ctrl+Y	Editing Text
To Upper Case		Shift+Ctrl+X	Editing Text
Toggle Folding		Ctrl+Numpad_Divide	Editing Text
Toggle Overwrite		Insert		Editing Text




















Views
Breakpoints		Shift+Alt+Q B	In Windows
Cheat Sheets		Shift+Alt+Q H	In Windows
Console			Shift+Alt+Q C	In Windows
Java Declaration		Shift+Alt+Q D	In Windows
Java Package Explorer	Shift+Alt+Q P	In Windows
Java Type Hierarchy		Shift+Alt+Q T	In Windows
Javadoc			Shift+Alt+Q J	In Windows
Search			Shift+Alt+Q S	In Windows
Show View (View: Outline)	Shift+Alt+Q O	In Windows
Show View (View: Problems)	Shift+Alt+Q X	In Windows
Synchronize		Shift+Alt+Q Y	In Windows
Variables			Shift+Alt+Q V	In Windows

Window
Activate Editor		F12		In Windows
Maximize Active View or Editor	Ctrl+M		In Windows
Next Editor			Ctrl+F6		In Windows
Next Perspective		Ctrl+F8		In Windows
Next View			Ctrl+F7		In Windows
Open Editor Drop Down	Ctrl+X B		In Windows
Previous Editor		Shift+Ctrl+F6	In Windows
Previous Perspective		Shift+Ctrl+F8	In Windows
Previous View		Shift+Ctrl+F7	In Windows
Show Key Assist		Shift+Ctrl+L	In Dialogs&Windows
Show Ruler Context Menu	Ctrl+F10		Editing Text
Show System Menu		Alt+-		In Windows
Show View Menu		Ctrl+F10		In Windows
Switch to Editor		Ctrl+X Ctrl+B	In Windows
Switch to Editor		Esc Ctrl+E	In Windows

			10.1.1.2

		10.1.2 FAQ

			10.1.2.1 error log

[yizaq@cow1:Wed Jun 12:1065:70:/ws/yizaq-csi/eclipse]$ eclipse   -consolelog
!SESSION 2013-06-12 13:50:24.032 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_21
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=linux, ARCH=x86, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os linux -ws gtk -arch x86 -product org.eclipse.epp.package.jee.product -consolelog

!ENTRY org.eclipse.osgi 4 0 2013-06-12 13:50:25.772
!MESSAGE Application error
!STACK 1
java.lang.UnsatisfiedLinkError: Cannot load 32-bit SWT libraries on 64-bit JVM
        at org.eclipse.swt.internal.Library.loadLibrary(Library.java:217)
        at org.eclipse.swt.internal.Library.loadLibrary(Library.java:194)
        at org.eclipse.swt.internal.C.<clinit>(C.java:21)
        at org.eclipse.swt.internal.Converter.wcsToMbcs(Converter.java:63)
        at org.eclipse.swt.internal.Converter.wcsToMbcs(Converter.java:54)
        at org.eclipse.swt.widgets.Display.<clinit>(Display.java:132)
        at org.eclipse.ui.internal.Workbench.createDisplay(Workbench.java:695)
        at org.eclipse.ui.PlatformUI.createDisplay(PlatformUI.java:161)
        at org.eclipse.ui.internal.ide.application.IDEApplication.createDisplay(IDEApplication.java:153)
        at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:95)
        at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
        at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
        at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
        at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
        at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
        at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
        at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
        at org.eclipse.equinox.launcher.Main.main(Main.java:1386)

			10.1.2.2 java.lang.UnsatisfiedLinkError: Cannot load 32-bit SWT libraries on 64-bit JVM 
- debug:
[yizaq@cow1:Thu Jun 13:1142:149:/ws/yizaq-csi/cpp_eclipse/eclipse]$ ./eclipse  -consolelog -debug
- fix 
: yum install libswt3-gtk2.x86_64
: mv /usr/share/eclipse /usr/share/eclipse-bak

			10.1.2.3
		10.1.3

	10.2

11. Server side programming

	11.1 Servlet

		11.1.1 Basic example & walkthrough

			11.1.1.1 Eclipse
- DL + deploy Eclipse (I use "Luna")
- Run it -> New "dynamic web project" -> Name it, say "test"

- Copy Servlet.jar:
[yizaq@pmbu-dev-vm58:Thu Oct 23:803:126:/ws/yizaq-csi/apps/apache-tomcat-7.0.56]$ cp /usr/share/java/servlet.jar /ws/yizaq-csi/workspace/test/WebContent/WEB-INF/lib/

-  Under Java Resources, src
default package create new servlet. say "myservlet.java"

code:

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class myservlet
 */
//@WebServlet("/myservlet")
public class myservlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

    /**
     * Default constructor. 
     */
    public myservlet() {
        // TODO Auto-generated constructor stub
    }

	/**
	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	
	      response.setContentType("text/html");

	      // Actual logic goes here.
	      PrintWriter out = response.getWriter();
	      out.println("{AD:\"AD1\"}");
	}

	/**
	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
	}

}

This code handles get. Can add code to handle post.

-  Edit WEB-INF/lib/web.xml to include the servlet
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0">
  <display-name>test</display-name>
  <welcome-file-list>
    <welcome-file>index.html</welcome-file>
    <welcome-file>index.htm</welcome-file>
    <welcome-file>index.jsp</welcome-file>
    <welcome-file>default.html</welcome-file>
    <welcome-file>default.htm</welcome-file>
    <welcome-file>default.jsp</welcome-file>
  </welcome-file-list>




 <servlet>
        <servlet-name>myservlet</servlet-name>
        <servlet-class>myservlet</servlet-class>
    </servlet>

    <servlet-mapping>
        <servlet-name>myservlet</servlet-name>
        <url-pattern>/myservlet</url-pattern>
    </servlet-mapping>
</web-app>

- Add index.html w/ jquery javasript code:
<!DOCTYPE html>
<html>
<head>

<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.2.6/jquery.js"></script>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<script type="text/javascript">
 
$(document).ready(function(){
 $("#msgid").html("This is Hello World by JQuery");
 
 
 $.ajax({
	   url: '  http://pmbu-dev-vm58:8080/test/myservlet',
	   
		 
	   data: {
	        id: 123
	    },
	 
	    // whether this is a POST or GET request
	    type: "GET",
	 
	    // the type of data we expect back
	    dataType : "json",
	 
	    // code to run if the request succeeds;
	    // the response is passed to the function
	    success: function( json ) {
	    	 alert( json );
	    },
	 
	    // code to run if the request fails; the raw request and
	    // status codes are passed to the function
	    error: function( xhr, status, errorThrown ) {
	        alert( "Sorry, there was a problem!" );
	        
	    },
	 
	    // code to run regardless of success or failure
	    complete: function( xhr, status ) {
	        alert( "The request is complete!" );
	    }
 
});
});

</script>
 
This is Hello World by HTML
 
<div id="msgid">
</div>
 
 
</body>
</html>
			11.1.1.2

		11.1.2

	11.2

12. My snippets, examples, demos

    12.1 Performance tests

        12.1.1 HashMap vs array contains
code:
[i500695@C02X632CJGH6:2021-03-22 18:35:33:~/work/code/java/perfTestSnippets/arrayVsHashMap:]2013$ cat !$ | pbcopy 
cat arrayVsHashMapPerfTest.java | pbcopy 

import java.util.HashMap;
import java.util.concurrent.TimeUnit;

public class arrayVsHashMapPerfTest {

    public static void main(String[] args) {
        // Test which is more efficient for get key value
        // when there are multiple keys and only two values
        // #keys<=10
        HashMap<String, String> kvMap = new HashMap<String, String>();
        kvMap.put("k1", "v1");
        kvMap.put("k2", "v2");
        kvMap.put("k3", "v1");
        kvMap.put("k4", "v2");
        kvMap.put("k5", "v1");
        kvMap.put("k6", "v2");
        kvMap.put("k7", "v1");
        kvMap.put("k8", "v2");
        kvMap.put("k9", "v1");
        kvMap.put("k10", "v2");
        kvMap.put("k11", "v1");

        String[] val1Arr = {"k1", "k3", "k5", "k7", "k9", "k11"  };
        String[] val2Arr = {"k2", "k4", "k6", "k8", "k10"};

        long startTime = System.nanoTime();
        final int times = 100000000;
        System.out.println("Test "+times+" times test get map value");
        for (int i = 0; i < times; i++) {
            kvMap.containsKey("k1");
        }
        long endTime = System.nanoTime();

        long timeElapsed = endTime - startTime;
        System.out.println("HashMap Contains Run time "+timeElapsed/1000000000+" seconds, "+timeElapsed/1000000+" milliseconds");

        startTime = System.nanoTime();
        System.out.println("Test "+times+" times test get array value");
        boolean found = false;
        for (int i = 0; i < times; i++) {
            for (int j = 0; j < val1Arr.length; j++) {
                if (val1Arr[j].equals("k7")) {
                    found = true;
                }
            }
        }
        endTime = System.nanoTime();

        timeElapsed = endTime - startTime;
        System.out.println("Array Contains Run time "+timeElapsed/1000000000+" seconds, "+timeElapsed/1000000+" milliseconds");

    }
}

test:
[i500695@C02X632CJGH6:2021-03-22 18:21:30:~/work/code/java/perfTestSnippets/arrayVsHashMap:]2025$ javac arrayVsHashMapPerfTest.java 
[i500695@C02X632CJGH6:2021-03-22 18:21:52:~/work/code/java/perfTestSnippets/arrayVsHashMap:]2026$ java arrayVsHashMapPerfTest
Test 100000000 times test get map value
HashMap Contains Run time 0 seconds, 210 milliseconds
Test 100000000 times test get array value
Array Contains Run time 0 seconds, 522 milliseconds

        12.1.2

    12.2

13.  Memory Management

    13.1  memsize equivalent - How to Get the Size of an Object


        13.1.1  https://www.baeldung.com/java-size-of-object
Unlike C/C++ where we can use sizeof() method to get an object size in bytes, there's no true equivalent of such method in Java.

In this article, we'll demonstrate how we can still get the size of a particular object.

Memory Consumption in Java
Although there is no sizeof operator in Java, we actually don't need one. All primitive types have a standard size, and there are typically no pad or alignment bytes. Still, this isn't always straightforward.

Although primitives must behave as if they have the official sizes, a JVM can store data in any way it pleases internally, with any amount of padding or overhead. It can choose to store a boolean[] in 64-bit long chunks like BitSet, allocate some temporary Objects on the stack or optimize some variables or method calls totally out of existence replacing them with constants, etc… But, as long as the program gives the same result, it's perfectly fine.

Taking also into the account hardware and OS caches impact (our data could be duplicated on every cache level), it means that we can only roughly predict RAM consumptionUnlike C/C++ where we can use sizeof() method to get an object size in bytes, there's no true equivalent of such method in Java.

In this article, we'll demonstrate how we can still get the size of a particular object.

2. Memory Consumption in Java
Although there is no sizeof operator in Java, we actually don't need one. All primitive types have a standard size, and there are typically no pad or alignment bytes. Still, this isn't always straightforward.

Although primitives must behave as if they have the official sizes, a JVM can store data in any way it pleases internally, with any amount of padding or overhead. It can choose to store a boolean[] in 64-bit long chunks like BitSet, allocate some temporary Objects on the stack or optimize some variables or method calls totally out of existence replacing them with constants, etc… But, as long as the program gives the same result, it's perfectly fine.

Taking also into the account hardware and OS caches impact (our data could be duplicated on every cache level), it means that we can only roughly predict RAM consumption..


Minimum object size is 16 bytes for modern 64-bit JDK since the object has 12-byte header, padded to a multiple of 8 bytes. In 32-bit JDK, the overhead is 8 bytes, padded to a multiple of 4 bytes.

References have a typical size of 4 bytes on 32-bit platforms and on 64-bits platforms with heap boundary less than 32Gb (-Xmx32G), and 8 bytes for this boundary above 32Gb.

This means that a 64-bit JVM usually requires 30-50% more heap space.

Especially relevant is to note that boxed types, arrays, Strings and other containers like multidimensional arrays are memory costly since they add certain overhead. For example, when we compare int primitive (which consumes only 4 bytes) to the Integer object which takes 16 bytes, we see that there is 300% memory overhead.


 Estimating Object Size Using Instrumentation
One way to get an estimate of an object's size in Java is to use getObjectSize(Object) method of the Instrumentation interface introduced in Java 5.


freestar
As we could see in Javadoc documentation, the method provides “implementation-specific approximation” of the specified object's size. It's noteworthy that a potential inclusion of overhead in the size exists and values can be different during single JVM invocation.

This approach only supports size estimation of the considered object itself and not the sizes of objects it references. To estimate a total size of the object, we would need a code that would go over those references and calculate the estimated size.

 Creating Instrumentation Agent
In order to call Instrumentation.getObjectSize(Object) to get object's size, we need to be able to access the instance of Instrumentation first. We need to use the instrumentation agent and there are two ways to do it, as described in the documentation for the java.lang.instrument package.

Instrumentation agent can be specified via the command-line or we can use it with an already running JVM. We'll focus on the first one.

To specify the instrumentation agent via the command-line, we'll need the implementation of the overloaded premain method that will be first invoked by the JVM when using instrumentation. Besides that, we need to expose a static method to be able to access Instrumentation.getObjectSize(Object).


freestar
Let's now create the InstrumentationAgent class:

public class InstrumentationAgent {
    private static volatile Instrumentation globalInstrumentation;

    public static void premain(final String agentArgs, final Instrumentation inst) {
        globalInstrumentation = inst;
    }

    public static long getObjectSize(final Object object) {
        if (globalInstrumentation == null) {
            throw new IllegalStateException("Agent not initialized.");
        }
        return globalInstrumentation.getObjectSize(object);
    }
}
Before we create a JAR for this agent, we need to make sure that a simple metafile, MANIFEST.MF is included in it:

Premain-class: com.baeldung.objectsize.InstrumentationAgent
Now we can make an Agent JAR with the MANIFEST.MF file included. One way is via command-line:

javac InstrumentationAgent.java
jar cmf MANIFEST.MF InstrumentationAgent.jar InstrumentationAgent.class

3.2. Example Class
Let's see this in action by creating a class with sample objects that will make use of our agent class:

public class InstrumentationExample {

    public static void printObjectSize(Object object) {
        System.out.println("Object type: " + object.getClass() +
          ", size: " + InstrumentationAgent.getObjectSize(object) + " bytes");
    }

    public static void main(String[] arguments) {
        String emptyString = "";
        String string = "Estimating Object Size Using Instrumentation";
        String[] stringArray = { emptyString, string, "com.baeldung" };
        String[] anotherStringArray = new String[100];
        List<String> stringList = new ArrayList<>();
        StringBuilder stringBuilder = new StringBuilder(100);
        int maxIntPrimitive = Integer.MAX_VALUE;
        int minIntPrimitive = Integer.MIN_VALUE;
        Integer maxInteger = Integer.MAX_VALUE;
        Integer minInteger = Integer.MIN_VALUE;
        long zeroLong = 0L;
        double zeroDouble = 0.0;
        boolean falseBoolean = false;
        Object object = new Object();

        class EmptyClass {
        }
        EmptyClass emptyClass = new EmptyClass();

        class StringClass {
            public String s;
        }
        StringClass stringClass = new StringClass();

        printObjectSize(emptyString);
        printObjectSize(string);
        printObjectSize(stringArray);
        printObjectSize(anotherStringArray);
        printObjectSize(stringList);
        printObjectSize(stringBuilder);
        printObjectSize(maxIntPrimitive);
        printObjectSize(minIntPrimitive);
        printObjectSize(maxInteger);
        printObjectSize(minInteger);
        printObjectSize(zeroLong);
        printObjectSize(zeroDouble);
        printObjectSize(falseBoolean);
        printObjectSize(Day.TUESDAY);
        printObjectSize(object);
        printObjectSize(emptyClass);
        printObjectSize(stringClass);
    }

    public enum Day {
        MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
    }
}
For this to work, we need to include –javaagent option with the path to agent JAR when running our application:

VM Options: -javaagent:"path_to_agent_directory\InstrumentationAgent.jar"
The output of running our class will show us estimated object sizes:

Object type: class java.lang.String, size: 24 bytes
Object type: class java.lang.String, size: 24 bytes
Object type: class [Ljava.lang.String;, size: 32 bytes
Object type: class [Ljava.lang.String;, size: 416 bytes
Object type: class java.util.ArrayList, size: 24 bytes
Object type: class java.lang.StringBuilder, size: 24 bytes
Object type: class java.lang.Integer, size: 16 bytes
Object type: class java.lang.Integer, size: 16 bytes
Object type: class java.lang.Integer, size: 16 bytes
Object type: class java.lang.Integer, size: 16 bytes
Object type: class java.lang.Long, size: 24 bytes
Object type: class java.lang.Double, size: 24 bytes
Object type: class java.lang.Boolean, size: 16 bytes
Object type: class com.baeldung.objectsize.InstrumentationExample$Day, size: 24 bytes
Object type: class java.lang.Object, size: 16 bytes
Object type: class com.baeldung.objectsize.InstrumentationExample$1EmptyClass, size: 16 bytes
Object type: class com.baeldung.objectsize.InstrumentationExample$1StringClass, size: 16 bytes

        13.1.2

    13.2

14. Java versions main features and tools, tags: Java versions main features and tools, tags: versions main features and tools
https://pianalytix.com/java-versions-its-features/

    14.1   Java version 1 
1995( JDK Alpha-Beta Version): 
It Consisted Of An Unstable API. It Is Not A Stable Version.


1995( JDK Alpha-Beta Version): 
Oak Changed To Java.
First Stable Version. 
Access Specifiers Were Added.

February 1997 (JDK 1.1) Java Versions:  
Language Changes: Inner Classes, JavaBeans.
Library Changes: AWT Event Changes, JDBC, And RMI( Remote Method Invocation), JIT(Just In Time Compiler For Microsoft Windows Platforms).

    14.2   Java version 2 
J2SE 1.2 December 1998 Playground: 
Language Changes: The Strictfp Keyword.
Library Changes: Swing As A New UI-System On Top Of AWT. JVM Was Added With JIT Compiler, Java Plugins, And Java IDL (Technology For Distributed Objects, Similar To RMI But It Can Interact Regardless Of The Objects Written In Java Or C Or C++ Or COBOL, Etc). 

    14.3   Java version 3 
    J2SE 1.3 May 2000 Kestral: 
Platform Changes: Hotspot JVM Included. RMI Was Modified To Be Compatible With CORBA (Design Specification For ORB (Object Request Broker)). 
Also, Language Changes: Java Naming And Directory Interface Added To The Core Libraries.
Library Changes:  Java Platform Debugger Architecture (JPDA), Java Sound, And Synthetic Proxy Classes Got Added.

    14.4   Java version 4 
J2SE 1.4 February 2002 Merlin: 
Language Changes: The Assert Keyword. 
Library Changes: Regular Expressions, Exception Chaining, IPV6 Support, Non-Blocking IO, Logging API, Image I/O API, Integrated XML Parser, And XSLT(EXtensible Stylesheet Language Transformations) Processor, Integrated Security And Also Cryptography Extensions(JCE, JSSE, JAAS), Java Web Start Included, Java.Util.Prefs.

    14.5   Java version 5 
 J2SE 5.0 September 2004 Tiger: 
Language Changes: Generics, Annotations, Enum Types.Var-Args, Enhanced For Loops. 
Library Changes: Concurrent Utilities In Java.Util.Concurrent. Scanner Class Joins For Parsing Data Thus From Different Input Streams And Buffers.

    14.6   Java version 6 
Java SE6 December 2006 Mustang: 
Scripting Language Support I.E., Generic API For Tight Integration With Scripting Languages. JDBC 4.0 Support. Here, Improvements To The Existing Libraries No Extra Language Features Adds Up Except @Override.

    14.7   Java version 7 
Java SE 7 July 2011 Dolphin: 
Language Changes: Project Coin(Small Changes/Enhancements And Bug Releases). Try-With-Resources, The Diamond Operator(“<TypeName>:  To Simplify The Use Of Generics ”).
Library Changes:  A New Abstracted File-System API With Support For Virtual File Systems. Improved Concurrency Libraries And Elliptic Curve Encryption.
Platform Changes: Support For Dynamic Languages.

    14.8   Java version 8 
Java SE 8 (LTS) March 2014 Spider (Older But Maintained): 
Language Changes: Lambda Expressions, Annotation On Java Types. Improvements Or Development In Project Coin( Small Language Improvements).
Library Changes: Improved Data And Time API.

        14.8.1    functional interfaces, tags: functional interfaces

          14.8.1.1    chatgpt, lambda expressions and functional interfaces

lambda's are Java's anonymous functions. they are a Shortcut syntax for Functional interfaces.
syntax: (p1,p2,...,pn) -> { expression }
where expression will usually run a calculation on the passed params and return a result

In Java, a functional interface is an interface that contains only one abstract method. Functional interfaces are often used in conjunction with lambda expressions and method references to provide a concise way to define behavior for functions or operations.

Here's an example of a functional interface and its usage:

```java
// Define a functional interface with a single abstract method
@FunctionalInterface
interface Calculator {
    double calculate(double num1, double num2);
}

public class FunctionalInterfaceExample {
    public static void main(String[] args) {
        // Using a lambda expression to implement the Calculator functional interface
        Calculator addition = (a, b) -> a + b;
        Calculator subtraction = (a, b) -> a - b;
        Calculator multiplication = (a, b) -> a * b;
        Calculator division = (a, b) -> {
            if (b == 0) {
                throw new ArithmeticException("Division by zero is not allowed");
            }
            return a / b;
        };

        // Using the functional interfaces to perform calculations
        double result1 = addition.calculate(10, 5);
        double result2 = subtraction.calculate(10, 5);
        double result3 = multiplication.calculate(10, 5);
        double result4 = division.calculate(10, 5);

        System.out.println("Addition: " + result1);
        System.out.println("Subtraction: " + result2);
        System.out.println("Multiplication: " + result3);
        System.out.println("Division: " + result4);
    }
}
```

In this example:

|1. We define a functional interface called `Calculator` with a single abstract method `calculate`. We annotate it with `@FunctionalInterface` to indicate that it is a functional interface (though this annotation is optional).
|
|2. Inside the `main` method, we create lambda expressions to implement the `Calculator` functional interface for addition, subtraction, multiplication, and division operations.
|
|3. We then use these lambda expressions to perform calculations with different operations and print the results.

Functional interfaces are widely used in Java to work with lambdas and provide a more functional programming style when working with APIs that require passing behavior as parameters, such as the `java.util.function` package used in streams and functional programming constructs in Java.


my example:
code: 
[i500695@WYLQRXL9LQ:2023-09-05 22:08:38:~/work/code/java/features/java_8/functional_interfaces:]2022$ cat FunctionalInterfaceExample.java 
// Define a functional interface with a single abstract method
@FunctionalInterface
interface Calculator {
    double calculate(double num1, double num2);
}

public class FunctionalInterfaceExample {
    public static void main(String[] args) {
        // Using a lambda expression to implement the Calculator functional interface
        Calculator addition = (a, b) -> a + b;
        Calculator subtraction = (a, b) -> a - b;
        Calculator multiplication = (a, b) -> a * b;
        Calculator division = (a, b) -> {
            if (b == 0) {
                throw new ArithmeticException("Division by zero is not allowed");
            }
            return a / b;
        };
        Calculator exponent = (a, b) -> {
            double ret = 1;
            if (b==0) {
                ret = 1;
            }
            else if (b >0) {
                ret = 1;
                for (int i = 0; i < b; i++) {
                    ret *= a;
                }
            }
            else {
                ret = 1;
                for (int i = 0; i < -b; i++) {
                    ret *= a;
                }
                ret = 1/a;
            }
            return ret;
        };

        // Using the functional interfaces to perform calculations
        double result1 = addition.calculate(10, 5);
        double result2 = subtraction.calculate(10, 5);
        double result3 = multiplication.calculate(10, 5);
        double result4 = division.calculate(10, 5);
        double result5 = exponent.calculate(10, 5);
        double result6 = exponent.calculate(3, 0);
        double result7 = exponent.calculate(2, -2);

        System.out.println("Addition: " + result1);
        System.out.println("Subtraction: " + result2);
        System.out.println("Multiplication: " + result3);
        System.out.println("Division: " + result4);
        System.out.println("Exponent: " + result5);
        System.out.println("Exponent: " + result6);
        System.out.println("Exponent: " + result7);
    }
}

run:
[i500695@WYLQRXL9LQ:2023-09-05 22:08:32:~/work/code/java/features/java_8/functional_interfaces:]2021$ java FunctionalInterfaceExample
Addition: 15.0
Subtraction: 5.0
Multiplication: 50.0
Division: 2.0
Exponent: 100000.0
Exponent: 1.0
Exponent: 0.5

        14.8.2 forEach
[i500695@WYLQRXL9LQ:2023-09-06 18:19:46:~/work/code/java/features/java_8/forEach:]2036$ cat ForEach.java 
import java.util.ArrayList;
import java.util.List;

/**
 * ForEach
 */
public class ForEach {

        public static void main(String[] args) {
            List<String> myList = new ArrayList<String>();
            myList.add("Deby");
            myList.add("May");
            myList.add("Itay");
            myList.add("Kay");
            myList.add("Aimy");
            System.out.println("Family members names");
            myList.forEach(name -> System.out.println(name));
            System.out.println("Family members upper case");
            myList.forEach((name) -> System.out.println(name.toUpperCase()));
        }
}
[i500695@WYLQRXL9LQ:2023-09-06 18:19:45:~/work/code/java/features/java_8/forEach:]2035$ java ForEach
Family members names
Deby
May
Itay
Kay
Aimy
Family members upper case
DEBY
MAY
ITAY
KAY
AIMY

        14.8.3 optional class , tags: optional class 
In Java 8, the “java.util” package included an optional class. The public final class “Optional” is used to handle NullPointerException in a Java program. You may give other code or values to execute using Optional. Thus, optional reduces the number of null checks required to avoid a nullPointerException.

You may use the Optional class to prevent the application from crashing and terminating unexpectedly. The Optional class has methods for checking the existence of a value for a given variable.

`Optional.ofNullable` is a method provided by the `java.util.Optional` class in Java. It's used to create an `Optional` instance that may or may not contain a non-null value. The purpose of `Optional.ofNullable` is to handle cases where you have a potentially nullable value, and you want to wrap it in an `Optional` to work with it more safely and conveniently.

Here's how `Optional.ofNullable` works:

|1. If the provided value is not null, it creates an `Optional` containing that value.
|2. If the provided value is null, it creates an empty `Optional` (an `Optional` instance with no value).

Example:

```java
String value = "Hello, Optional!";
Optional<String> optionalWithValue = Optional.ofNullable(value);

String nullValue = null;
Optional<String> optionalWithNull = Optional.ofNullable(nullValue);
```

In the example above:

- `optionalWithValue` will contain an `Optional` with the value "Hello, Optional!" because the `value` variable is not null.
- `optionalWithNull` will contain an empty `Optional` because the `nullValue` variable is null.

Using `Optional.ofNullable` is especially useful when working with methods or APIs that may return null values. It allows you to avoid null checks and null pointer exceptions by providing a more structured and safe way to handle the absence of a value.

You can then use methods like `isPresent`, `ifPresent`, `orElse`, and others to work with the value or handle the absence of a value in a more controlled manner.

my demo:
[i500695@WYLQRXL9LQ:2023-09-07 18:26:29:~/work/code/java/features/java_8/optional:]2051$ cat OptionalDemo.java 
import java.util.Optional;

public class OptionalDemo{ 
 
   public static void main(String[] args) { 
        String[] str = new String[10]; 
        Optional<String> checkNull =
                       Optional.ofNullable(str[5]); 
        if (checkNull.isPresent()) { 
            String word = str[5].toLowerCase(); 
            System.out.print(str); 
         } else
           System.out.println("string is null"); 

          String nullVal = null;
          Optional<String> optionalStrWithNull = Optional.ofNullable(nullVal);

          if (optionalStrWithNull.isPresent()) {
            System.out.println("found non null value");
          }
          else {
            System.out.println("found null value");
          }
    } 
}[i500695@WYLQRXL9LQ:2023-09-07 18:26:38:~/work/code/java/features/java_8/optional:]2052$ javac OptionalDemo.java 
[i500695@WYLQRXL9LQ:2023-09-07 18:26:41:~/work/code/java/features/java_8/optional:]2053$ java OptionalDemo
string is null
found null value

        14.8.4 Default And Static Methods In Interfaces, tags: Default And Static Methods In Interfaces
In Java 8, you may add non-abstract methods to interfaces, allowing you to create interfaces with method implementation. To construct interfaces with method implementation, use the Default and Static keywords. Lambda Expression functionality is mostly enabled through default approaches.

You may extend the functionality of your libraries’ interfaces by using default methods. This ensures that the code created for previous versions is compatible with the newer interfaces (binary compatibility).
Default methods and static methods in interfaces were introduced in Java 8 to allow for the addition of new methods to existing interfaces without breaking backward compatibility. Here's an example of both default and static methods in interfaces:

```java
// Define an interface with a default and a static method
interface MyInterface {
    // Abstract method (no implementation required)
    void regularMethod();

    // Default method with implementation
    default void defaultMethod() {
        System.out.println("This is a default method.");
    }

    // Static method with implementation
    static void staticMethod() {
        System.out.println("This is a static method.");
    }
}

// Implement the interface in a class
class MyClass implements MyInterface {
    @Override
    public void regularMethod() {
        System.out.println("This is the regular method implementation.");
    }
}

public class InterfaceExample {
    public static void main(String[] args) {
        MyClass myClass = new MyClass();

        // Calling regularMethod from the implemented class
        myClass.regularMethod();

        // Calling defaultMethod from the interface
        myClass.defaultMethod();

        // Calling staticMethod from the interface
        MyInterface.staticMethod();
    }
}
```

In this example:

- `MyInterface` is an interface that defines three methods:
  - `regularMethod`: An abstract method that must be implemented by any class that implements `MyInterface`.
  - `defaultMethod`: A default method with a default implementation.
  - `staticMethod`: A static method with a static implementation.

- `MyClass` is a class that implements `MyInterface`. It provides an implementation for the `regularMethod` as required by the interface.

- In the `main` method of `InterfaceExample`, we create an instance of `MyClass` and demonstrate the usage of these methods:
  - We call `regularMethod`, which is implemented in `MyClass`.
  - We call `defaultMethod`, which is provided by the default implementation in the interface.
  - We call `staticMethod` directly on the interface itself.

Default methods provide a way to add new methods to existing interfaces without breaking the classes that already implement those interfaces. Static methods in interfaces can be used to provide utility methods that are associated with the interface but don't depend on an instance of the implementing class.

my demo:
[i500695@WYLQRXL9LQ:2023-09-07 18:43:03:~/work/code/java/features/java_8/default_static_methods_in_intefaces:]2062$ cat InterfaceExample.java 
interface MyInterface {
    // Abstract method (no implementation required)
    void regularMethod();

    // Default method with implementation
    default void defaultMethod() {
        System.out.println("This is a default method.");
    }

    // Static method with implementation
    static void staticMethod() {
        System.out.println("This is a static method.");
    }
}

// Implement the interface in a class
class MyClass implements MyInterface {
    @Override
    public void regularMethod() {
        System.out.println("This is the regular method implementation.");
    }
}

// // Implement the interface in a class
// // uncomment will yeild error: InterfaceExample.java:25: error: MyClass2 is not abstract and does not override abstract method regularMethod() in MyInterface
// class MyClass2 implements MyInterface {
// }

public class InterfaceExample {
    public static void main(String[] args) {
        MyClass myClass = new MyClass();
        //MyClass2 myClass2 = new MyClass2();

        System.out.println("calling myClass methods:");
        // Calling regularMethod from the implemented class
        myClass.regularMethod();

        // Calling defaultMethod from the interface
        myClass.defaultMethod();

        // Calling staticMethod from the interface
        MyInterface.staticMethod();

        // System.out.println("calling myClass2 methods:");
        // myClass2.regularMethod();
        // myClass2.defaultMethod();
        // myClass2.staticMethod();
    }
}
[i500695@WYLQRXL9LQ:2023-09-07 18:43:10:~/work/code/java/features/java_8/default_static_methods_in_intefaces:]2063$ javac InterfaceExample.java 
[i500695@WYLQRXL9LQ:2023-09-07 18:43:15:~/work/code/java/features/java_8/default_static_methods_in_intefaces:]2064$ java InterfaceExample
calling myClass methods:
This is the regular method implementation.
This is a default method.
This is a static method.

        14.8.4 Java Stream API For Bulk Data Operations On Collections , tags: Java Stream API For Bulk Data Operations On Collections 
In Java, the Stream API and bulk data operations provide a powerful and concise way to perform operations on collections of data. They were introduced in Java 8 and have since become an integral part of Java's functional programming features. The Stream API allows you to process collections of data in a more declarative and functional style, making your code more readable and efficient.

Here's an overview of the Stream API and some common bulk data operations:

| 1. **Stream API**:
|    - A `Stream` in Java represents a sequence of elements that can be processed in a functional style.
|    - You can create a Stream from various data sources, including collections, arrays, or by generating elements dynamically.
|    - Streams can be processed in a chain of operations like filtering, mapping, and reducing, without modifying the original data source.
| 
| 2. **Common Bulk Data Operations**:
   - **Filtering**: Use the `filter` operation to select elements from a Stream that satisfy a given condition.
   - **Mapping**: Use the `map` operation to transform elements in a Stream to another form.
   - **Reducing**: Use the `reduce` operation to combine elements of a Stream into a single result, such as summing all elements.
   - **Collecting**: Use the `collect` operation to accumulate elements from a Stream into a collection or other data structure.
   - **Sorting**: Use the `sorted` operation to sort elements in a Stream based on a specified comparator.

Here are some usage examples:

```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class StreamExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // Example 1: Filtering
        List<Integer> evenNumbers = numbers.stream()
                .filter(n -> n % 2 == 0)
                .collect(Collectors.toList());
        System.out.println("Even numbers: " + evenNumbers);

        // Example 2: Mapping
        List<String> squareStrings = numbers.stream()
                .map(n -> n * n)
                .map(Object::toString)
                .collect(Collectors.toList());
        System.out.println("Square strings: " + squareStrings);

        // Example 3: Reducing
        int sum = numbers.stream()
                .reduce(0, Integer::sum);
        System.out.println("Sum of numbers: " + sum);

        // Example 4: Sorting
        List<Integer> sortedNumbers = numbers.stream()
                .sorted((a, b) -> b.compareTo(a)) // Descending order
                .collect(Collectors.toList());
        System.out.println("Sorted numbers (descending): " + sortedNumbers);
    }
}
```

In this example, we have a list of numbers, and we use various Stream operations to filter, map, reduce, and sort the data. These operations allow you to express your intentions concisely and readably while performing complex data manipulations on collections.

my demo:
[i500695@WYLQRXL9LQ:2023-09-11 18:26:55:~/work/code/java/features/java_8/streams:]2017$ javac StreamExample.java 
[i500695@WYLQRXL9LQ:2023-09-11 18:28:04:~/work/code/java/features/java_8/streams:]2018$ java StreamExample
Even numbers: [2, 4, 6, 8, 10]
Square strings: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
Sum of numbers: 55
Sorted numbers (descending): [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
Sorted numbers (ascending): [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Unique list of numbers is:
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 
[i500695@WYLQRXL9LQ:2023-09-11 18:28:05:~/work/code/java/features/java_8/streams:]2019$ cat StreamExample.java 
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.stream.Collector;
import java.util.stream.Collectors;

public class StreamExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // Example 1: Filtering
        List<Integer> evenNumbers = numbers.stream()
                .filter(n -> n % 2 == 0)
                .collect(Collectors.toList());
        System.out.println("Even numbers: " + evenNumbers);

        // Example 2: Mapping
        List<String> squareStrings = numbers.stream()
                .map(n -> n * n)
                .map(Object::toString)
                .collect(Collectors.toList());
        System.out.println("Square strings: " + squareStrings);

        // Example 3: Reducing
        int sum = numbers.stream()
                .reduce(0, Integer::sum);
        System.out.println("Sum of numbers: " + sum);

        // Example 4: Sorting
        List<Integer> sortedNumbers = numbers.stream()
                .sorted((a, b) -> b.compareTo(a)) // Descending order
                .collect(Collectors.toList());
        System.out.println("Sorted numbers (descending): " + sortedNumbers);

        // Example 4: Sorting ascending
        List<Integer> sortedNumbersAsc = numbers.stream()
                .sorted((a, b) -> a.compareTo(b)) // Descending order
                .collect(Collectors.toList());
        System.out.println("Sorted numbers (ascending): " + sortedNumbersAsc);

        List<Integer> numbers2 = Arrays.asList(1, 2,2,2, 3, 4, 5, 6, 6,7, 8, 8,8, 9, 10);
        Set<Integer> uniqNumbers = numbers.stream()
                .collect(Collectors.toSet());
                System.out.println("Unique list of numbers is:");
                uniqNumbers.forEach( elem -> System.out.printf("%d, ", elem));
                System.out.println("");
    }
}

        14.8.5 java data time API usage, tags: java data time API usage

            14.8.5.1 gpt
The Java Date and Time API, introduced in Java 8, provides a comprehensive and robust way to handle date and time operations. It's located in the `java.time` package. Here's an example of how to use the Java Date and Time API:

```java
import java.time.*;
import java.time.format.DateTimeFormatter;

public class DateTimeExample {
    public static void main(String[] args) {
        // Getting the current date and time
        LocalDateTime now = LocalDateTime.now();
        System.out.println("Current Date and Time: " + now);

        // Creating a specific date and time
        LocalDate date = LocalDate.of(2023, Month.JANUARY, 15);
        LocalTime time = LocalTime.of(14, 30);
        LocalDateTime dateTime = LocalDateTime.of(date, time);
        System.out.println("Specific Date and Time: " + dateTime);

        // Formatting date and time
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String formattedDateTime = dateTime.format(formatter);
        System.out.println("Formatted Date and Time: " + formattedDateTime);

        // Adding and subtracting time
        LocalDateTime futureDateTime = dateTime.plusDays(7).minusHours(2);
        System.out.println("Future Date and Time: " + futureDateTime);

        // Duration between two times
        Duration duration = Duration.between(dateTime, futureDateTime);
        System.out.println("Duration: " + duration.toHours() + " hours");

        // Working with time zones
        ZoneId newYorkZone = ZoneId.of("America/New_York");
        ZonedDateTime newYorkTime = ZonedDateTime.of(dateTime, newYorkZone);
        System.out.println("New York Time: " + newYorkTime);

        // Checking for leap years
        boolean isLeapYear = Year.of(2024).isLeap();
        System.out.println("Is 2024 a leap year? " + isLeapYear);
    }
}
```

In this example:

| 1. We get the current date and time using `LocalDateTime.now()`.
| 
| 2. We create a specific date and time using `LocalDate.of()` and `LocalTime.of()`.
| 
| 3. We format the date and time using `DateTimeFormatter`.
| 
| 4. We add and subtract time from a date and time using methods like `plusDays()` and `minusHours()`.
| 
| 5. We calculate the duration between two times using `Duration.between()`.
| 
| 6. We work with time zones using `ZoneId` and `ZonedDateTime`.
| 
| 7. We check if a year is a leap year using the `Year` class.

Make sure you have Java 8 or a later version installed to run this code because the Java Date and Time API was introduced in Java 8.

            14.8.5.2 my demo
[i500695@WYLQRXL9LQ:2023-09-11 18:35:52:~/work/code/java/features/java_8/DateTime:]2026$ javac DateTimeExample.java
[i500695@WYLQRXL9LQ:2023-09-11 18:36:57:~/work/code/java/features/java_8/DateTime:]2027$ java DateTimeExample
Current Date and Time: 2023-09-11T18:36:58.252988
Demo Creation Specific Date and Time: 2023-09-11T18:37
Formatted Date and Time: 2023-09-11 18:37:00
Future Date and Time: 2024-09-18T16:37
Duration: 372 days
Duration: 8950 hours
Duration: 32220000 seconds
Duration: 32220000000 milliseconds
New York Time: 2023-09-11T18:37-04:00[America/New_York]
Is 2024 a leap year? true
[i500695@WYLQRXL9LQ:2023-09-11 18:36:58:~/work/code/java/features/java_8/DateTime:]2028$ cat DateTimeExample.java 
import java.time.*;
import java.time.format.DateTimeFormatter;

public class DateTimeExample {
    public static void main(String[] args) {
        // Getting the current date and time
        LocalDateTime now = LocalDateTime.now();
        System.out.println("Current Date and Time: " + now);

        // Creating a specific date and time
        LocalDate date = LocalDate.of(2023, Month.SEPTEMBER, 11); //the day this demo was created...
        LocalTime time = LocalTime.of(18, 37);
        LocalDateTime dateTime = LocalDateTime.of(date, time);
        System.out.println("Demo Creation Specific Date and Time: " + dateTime);

        // Formatting date and time
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String formattedDateTime = dateTime.format(formatter);
        System.out.println("Formatted Date and Time: " + formattedDateTime);

        // Adding and subtracting time
        LocalDateTime futureDateTime = dateTime.plusYears(1).plusDays(7).minusHours(2);
        System.out.println("Future Date and Time: " + futureDateTime);

        // Duration between two times
        Duration duration = Duration.between(dateTime, futureDateTime);
        System.out.println("Duration: " + duration.toDays() + " days");
        System.out.println("Duration: " + duration.toHours() + " hours");
        System.out.println("Duration: " + duration.toSeconds() + " seconds");
        System.out.println("Duration: " + duration.toMillis() + " milliseconds");

        // Working with time zones
        ZoneId newYorkZone = ZoneId.of("America/New_York");
        ZonedDateTime newYorkTime = ZonedDateTime.of(dateTime, newYorkZone);
        System.out.println("New York Time: " + newYorkTime);

        // Checking for leap years
        boolean isLeapYear = Year.of(2024).isLeap();
        System.out.println("Is 2024 a leap year? " + isLeapYear);
    }
}


            14.8.5.3 




        14.8.6 Collection API Improvements, tags: Collection API Improvements
The Collection API in Java 8 now includes the following new methods. A few of them are listed below.  

This is a default method for the Iterator. forEachRemaining (Consumer action): This is a default method for the Iterator. It repeats the “action” for the remaining items until all of them have been processed, or the “action” throws an exception.
The default technique for removing items from a collection is removed (Predicate filter). This removes all objects from the collection that satisfy the supplied “filter.”
Spliterator () This collection method returns a spliterator object that may be used to traverse the items sequentially or in parallel.
ReplaceAll (), calculate(), and merge() are methods in the Map collection.
The performance of the HashMap class with Key collisions has been enhanced etc.

        14.8.7 Java IO Improvements
The following are some of the IO enhancements made in Java 8:

Files.list (Path dir): Returns a lazily filled stream, each element of which represents a directory entry.
Files.lines (Path path): Reads all the lines from a stream.
Files.find (): Returns a stream filled by a path after searching for files in the file tree rooted at a provided beginning file and many more. 
BufferedReader.lines (): Returns a stream containing all of the elements of BufferedReader’s lines and much more
Buffered

        14.8.8 Miscellaneous Core API Improvements
 ThreadLocal’s static function with initial (Supplier supplier) allows you to build an instance quickly.
The default and static methods for natural ordering, reverse order, and other operations have been added to the “Comparator” interface.
The min (), max (), and sum () methods are available in the Integer, Long, and Double wrapper classes.
The logicalAnd (), logicalOr (), and logicalXor () methods have been added to the Boolean class.
The Math class introduces a number of useful techniques.
The JDBC-ODBC Bridge has been deactivated.
The memory space used by PermGen is no longer available.

        14.8.9 Base64 Encode Decode 
For Base64 encoding, Java 8 has built-in encode and decode functions. The Base64 encoding class in Java.util.Base64.

Three Base64 encoders and decoders are provided in this class:

The output is mapped to a set of characters between A-Za-z0-9+/ in this version. The encoder does not add a line feed to the output, and the decoder rejects any character other than the above.
The filename safe is mapped to the set of characters between A-Za-z0-9+/, and the output is the URL.
The output of this sort of encoder is mapped to a MIME-friendly format.

            14.8.9.1 GTP example
In Java, you can encode and decode data in Base64 using the `java.util.Base64` class, which was introduced in Java 8. Here's an example of how to do that:

**Encoding to Base64:**

```java
import java.util.Base64;

public class Base64Example {
    public static void main(String[] args) {
        // The string to be encoded
        String originalText = "Hello, World!";

        // Encoding to Base64
        byte[] encodedBytes = Base64.getEncoder().encode(originalText.getBytes());

        String encodedText = new String(encodedBytes);
        System.out.println("Encoded Text: " + encodedText);
    }
}
```

In this example, we use `Base64.getEncoder().encode()` to encode the string "Hello, World!" into Base64. The result is stored as a byte array, and we convert it back to a string for printing.

**Decoding from Base64:**

```java
import java.util.Base64;

public class Base64Example {
    public static void main(String[] args) {
        // The Base64 encoded string
        String encodedText = "SGVsbG8sIFdvcmxkIQ==";

        // Decoding from Base64
        byte[] decodedBytes = Base64.getDecoder().decode(encodedText);

        String decodedText = new String(decodedBytes);
        System.out.println("Decoded Text: " + decodedText);
    }
}
```

In this example, we use `Base64.getDecoder().decode()` to decode the Base64 encoded string "SGVsbG8sIFdvcmxkIQ==". The result is stored as a byte array, and we convert it back to a string for printing.

When you run these examples, you should see the original text "Hello, World!" after decoding the Base64-encoded string.

            14.8.9.2 my demo
[i500695@WYLQRXL9LQ:2023-09-12 18:29:42:~/work/code/java/features/java_8/base64:]2049$ javac Base64Demo.java
[i500695@WYLQRXL9LQ:2023-09-12 18:31:11:~/work/code/java/features/java_8/base64:]2050$ java Base64Demo
Text: base64 demo, encode: [B@6b95977
Decoded Text: base64 demo
[i500695@WYLQRXL9LQ:2023-09-12 18:31:12:~/work/code/java/features/java_8/base64:]2051$ cat Base64Demo.java 
import java.util.Base64;

public class Base64Demo {
    public static void main(String[] args) {
        String text = "base64 demo";
        byte[] encoded_text = Base64.getEncoder().encode(text.getBytes());
        System.out.printf("Text: %s, encode: %s\n", text, encoded_text);
        byte[] decoded_text = Base64.getDecoder().decode(encoded_text);
        System.out.printf("Decoded Text: %s\n", text, decoded_text);
    }
}
            14.8.9.3
        14.8.10
    14.10  Java version 9, tags: Java version 9

        14.10.1  summary 9-17

Java 9 (2017):
Module System (Project Jigsaw): Java 9 introduced the module system, which allows developers to create modular applications, making it easier to manage dependencies and encapsulate code.

JShell (Interactive REPL): The JShell tool provides an interactive Read-Eval-Print Loop (REPL) for Java, making it easier to experiment with code snippets and learn the language.

Improved Stream API: Java 9 enhanced the Stream API with additional methods for processing and transforming streams of data.

Private Methods in Interfaces: Interfaces could now have private methods, which can be used for code reuse and organization.

Java 10 (2018):
Local-Variable Type Inference (var): Java 10 introduced the var keyword, allowing type inference for local variables, reducing verbosity in code.

Application Class-Data Sharing: This feature enables the sharing of class metadata and can lead to improved application startup times.

Experimental JIT Compiler (Graal): The GraalVM Just-In-Time (JIT) compiler was made available for experimentation.

Java 11 (2018):
HTTP Client (Standard): Java 11 introduced a new, standardized HTTP client library, making it easier to make HTTP requests.

Local-Variable Syntax for Lambda Parameters: It extended the use of var for lambda parameters.

Epsilon Garbage Collector: This is a no-op garbage collector for performance testing and diagnostic purposes.

Java 12 (2019):
Switch Expressions (Preview): The switch statement was enhanced to be used as an expression, making code more concise and readable.

Shenandoah Garbage Collector (Experimental): Shenandoah is a low-pause-time garbage collector that was introduced as an experimental feature.

Java 13 (2019):
Text Blocks: Java 13 introduced text blocks, making it easier to write multi-line string literals in a more readable and maintainable way.

Dynamic CDS Archives: This feature extended the class-data sharing (CDS) functionality to allow dynamic archiving of classes at runtime.

Java 14 (2020):
Pattern Matching (Preview): This preview feature introduced the instanceof pattern matching for more concise and safer code.

Records (Preview): Records are a preview feature that simplifies the creation of immutable data classes.

Java 15 (2020):
Sealed Classes (Preview): Sealed classes and interfaces were introduced as a preview feature, restricting which classes can extend or implement a given type.

Text Blocks (Standard): Text blocks became a standard feature, making it easier to work with multi-line strings.

Java 16 (2021):
Records (Standard): Records were finalized as a standard feature, providing a concise way to define data classes.

Pattern Matching (Standard): The pattern matching feature was finalized, including the instanceof pattern matching and the switch expression.

Java 17 (2021):
Pattern Matching (Continued): Java 17 continued the pattern matching feature and introduced the "patterns" keyword.

Sealed Classes (Standard): Sealed classes and interfaces were finalized as a standard feature.

Strong encapsulation (Incubator): Strong encapsulation was introduced as an incubator feature, aiming to improve security and reliability.

Foreign Function and Memory API (Incubator): The Foreign Function and Memory API was introduced as an incubator feature for interaction with native code and memory.a

https://www.digitalocean.com/community/tutorials/java-9-features-with-examples


            14.10.1.1   other


        14.10.1  REPL, jshell, tags: REPL, jshell
example:
jshell> String s = "hello";
s ==> "hello"

jshell> import java.util.Base64;

jshell> Base64.GetEncoder().encode(s)
|  Error:
|  cannot find symbol
|    symbol:   method GetEncoder()
|  Base64.GetEncoder().encode(s)
|  ^---------------^

jshell> Base64.getEncoder().encode(s.getBytes())
$3 ==> byte[8] { 97, 71, 86, 115, 98, 71, 56, 61 }

jshell> System.out.pr
print(     printf(    println(   
jshell> System.out.println(s)
hello

jshell> byte[] s_enc = Base64.getEncoder().encode(s.getBytes())
s_enc ==> byte[8] { 97, 71, 86, 115, 98, 71, 56, 61 }

jshell> System.out.println(s_enc)
[B@1b2c6ec2

        14.10.2 Factory Methods for Immutable List, Set, Map and Map.Entry, tags: Factory Methods for Immutable List
Oracle Corp has introduced some convenient factory methods to create Immutable List, Set, Map and Map.Entry objects. These utility methods are used to create empty or non-empty Collection objects. In Java SE 8 and earlier versions, We can use Collections class utility methods like unmodifiableXXX to create Immutable Collection objects. For instance, if we want to create an Immutable List, then we can use Collections.unmodifiableList method. However, these Collections.unmodifiableXXX methods are a tedious and verbose approach. To overcome those shortcomings, Oracle Corp has added a couple of utility methods to List, Set and Map interfaces. List and Set interfaces have “of()” methods to create an empty or no-empty Immutable List or Set objects 

List immutableList = List.of();
Non-Empty List Example

List immutableList = List.of("one","two","three");
The Map has two sets of methods: of() methods and ofEntries() methods to create an Immutable Map object and an Immutable Map.Entry object respectively. Empty Map Example

jshell> Map emptyImmutableMap = Map.of()
emptyImmutableMap ==> {}
Non-Empty Map Example

jshell> Map nonemptyImmutableMap = Map.of(1, "one", 2, "two", 3, "three")
nonemptyImmutableMap ==> {2=two, 3=three, 1=one}

        14.10.3 Private methods in Interfaces
In Java 8, we can provide method implementation in Interfaces using Default and Static methods. However we cannot create private methods in Interfaces. To avoid redundant code and more re-usability, Oracle Corp is going to introduce private methods in Java SE 9 Interfaces. From Java SE 9 onwards, we can write private and private static methods too in an interface using a ‘private’ keyword. These private methods are like other class private methods only, there is no difference between them.

public interface Card{

  private Long createCardID(){
    // Method implementation goes here.
  }

  private static void displayCardDetails(){
    // Method implementation goes here.
  }

}
If you want to read more about this new feature, please go through this link: Java 9 Private methods in Interface.

        14.10.4 Java 9 Module System
One of the big changes or java 9 feature is the Module System. Oracle Corp is going to introduce the following features as part of Jigsaw Project.

Modular JDK
Modular Java Source Code
Modular Run-time Images
Encapsulate Java Internal APIs
Java Platform Module System
Before Java SE 9 versions, we are using Monolithic Jars to develop Java-Based applications. This architecture has a lot of limitations and drawbacks. To avoid all these shortcomings, Java SE 9 is coming with the Module System. JDK 9 is coming with 92 modules (may change in final release). We can use JDK Modules and also we can create our own modules as shown below

            14.10.4.1 GPT explanation

As of my last knowledge update in September 2021, Java introduced a module system in Java 9 as part of the Java Platform Module System (JPMS). Modules help you modularize your Java applications by explicitly declaring dependencies, encapsulating code, and improving maintainability. Here's a basic example of how to create and use modules in Java:

Let's assume we have a simple Java application with two modules:

|1. **Module A (com.example.moduleA)**: This module contains a single class, `HelloA`, with a method that prints a message.
|
|2. **Module B (com.example.moduleB)**: This module depends on Module A and uses the `HelloA` class to print a message.

**Step 1: Create the Module A**

Create a directory structure like this:

```
module-example/
   ├── moduleA/
   │     ├── module-info.java
   │     └── com/
   │          └── example/
   │               └── moduleA/
   │                    └── HelloA.java
```

In `module-info.java` for Module A:

```java
module com.example.moduleA {
}
```

In `HelloA.java`:

```java
package com.example.moduleA;

public class HelloA {
    public void sayHello() {
        System.out.println("Hello from Module A!");
    }
}
```

**Step 2: Create Module B**

Create a directory structure like this:

```
module-example/
   ├── moduleA/
   ├── moduleB/
   │     ├── module-info.java
   │     └── com/
   │          └── example/
   │               └── moduleB/
   │                    └── HelloB.java
```

In `module-info.java` for Module B:

```java
module com.example.moduleB {
    requires com.example.moduleA;
}
```

In `HelloB.java`:

```java
package com.example.moduleB;

import com.example.moduleA.HelloA;

public class HelloB {
    public static void main(String[] args) {
        HelloA helloA = new HelloA();
        helloA.sayHello();
        System.out.println("Hello from Module B!");
    }
}
```

**Step 3: Compile and Run**

Compile the modules using the `javac` command:

```bash
javac -d out moduleA/module-info.java moduleA/com/example/moduleA/HelloA.java
javac --module-path out -d out moduleB/module-info.java moduleB/com/example/moduleB/HelloB.java
```

Run the `HelloB` class:

```bash
java --module-path out -m com.example.moduleB/com.example.moduleB.HelloB
```

You'll see the following output:

```
Hello from Module A!
Hello from Module B!
```

This example demonstrates a simple use case of creating and using modules in Java. Module A contains a class that Module B depends on, and the modules are compiled and run using the `--module-path` and `-m` options.

Please note that the module system is particularly useful for larger projects where you need to manage dependencies and encapsulate code more effectively. In smaller projects, traditional package organization may suffice. Additionally, Java may have introduced changes or improvements to the module system in versions beyond Java 9, so be sure to check the documentation for the latest updates.

            14.10.4.2 https://www.baeldung.com/java-9-modularity
Java 9 introduces a new level of abstraction above packages, formally known as the Java Platform Module System (JPMS), or “Modules” for short.
In this tutorial, we’ll go through the new system and discuss its various aspects.

We’ll also build a simple project to demonstrate all concepts we’ll be learning in this guide.
First of all, we need to understand what a module is before we can understand how to use them.
A Module is a group of closely related packages and resources along with a new module descriptor file.
In other words, it’s a “package of Java Packages” abstraction that allows us to make our code even more reusable.

                14.10.4.2.1 Packages
The packages inside a module are identical to the Java packages we’ve been using since the inception of Java.

When we create a module, we organize the code internally in packages just like we previously did with any other project.

Aside from organizing our code, packages are used to determine what code is publicly accessible outside of the module. We’ll spend more time talking about this later in the article.


                14.10.4.2.2 resources
                Each module is responsible for its resources, like media or configuration files.
Previously we’d put all resources into the root level of our project and manually manage which resources belonged to different parts of the application.
With modules, we can ship required images and XML files with the module that needs it, making our projects much easier to manage.

                14.10.4.2.3 Module Descriptor
When we create a module, we include a descriptor file that defines several aspects of our new module:

Name – the name of our module
Dependencies – a list of other modules that this module depends on
Public Packages – a list of all packages we want accessible from outside the module
Services Offered – we can provide service implementations that can be consumed by other modules
Services Consumed – allows the current module to be a consumer of a service
Reflection Permissions – explicitly allows other classes to use reflection to access the private members of a package
The module naming rules are similar to how we name packages (dots are allowed, dashes are not). It’s very common to do either project-style (my.module) or Reverse-DNS (com.baeldung.mymodule) style names. We’ll use project-style in this guide.

We need to list all packages we want to be public because by default all packages are module private.


The same is true for reflection. By default, we cannot use reflection on classes we import from another module.

Later in the article, we’ll look at examples of how to use the module descriptor file.


                14.10.4.2.4 java list-modules command
The `java list-modules` command is used to list the modules available in a Java application. It is available starting from Java 9 and is a part of the Java Platform Module System (JPMS), which was introduced in Java 9 to improve modularity in Java applications.

Here's how you can use the `java list-modules` command:

a. Open your command prompt or terminal.

b. Run the `java list-modules` command followed by the options and arguments you want to use. The basic syntax is as follows:

```shell
java --list-modules
```

This command will list all the modules available in your Java installation.

You can also specify additional options to filter the list or get more detailed information about the modules. For example:

- To list only the non-system modules (modules not part of the Java SE Platform), you can use the `--limit-modules` option:

  ```shell
  java --list-modules --limit-modules java.se
  ```

- To get more detailed information about a specific module, you can use the `--describe-module` option followed by the module name. For example:

  ```shell
  java --describe-module java.base
  ```

The `java list-modules` command is useful for exploring the module system in Java, especially when you want to understand which modules are available and how they are structured in your Java runtime environment. It's commonly used in conjunction with Java 9 and later versions to work with modular Java applications.


                14.10.4.2.5 Module Types
There are four types of modules in the new module system:

System Modules – These are the modules listed when we run the list-modules command above. They include the Java SE and JDK modules.
Application Modules – These modules are what we usually want to build when we decide to use Modules. They are named and defined in the compiled module-info.class file included in the assembled JAR.
Automatic Modules – We can include unofficial modules by adding existing JAR files to the module path. The name of the module will be derived from the name of the JAR. Automatic modules will have full read access to every other module loaded by the path.
Unnamed Module – When a class or JAR is loaded onto the classpath, but not the module path, it’s automatically added to the unnamed module. It’s a catch-all module to maintain backward compatibility with previously-written Java code.

                14.10.4.2.6 Distribution
Modules can be distributed one of two ways: as a JAR file or as an “exploded” compiled project. This, of course, is the same as any other Java project so it should come as no surprise.

We can create multi-module projects comprised of a “main application” and several library modules.

We have to be careful though because we can only have one module per JAR file.

When we set up our build file, we need to make sure to bundle each module in our project as a separate jar.


                14.10.4.2.7 Default Modules
When we install Java 9, we can see that the JDK now has a new structure.


They have taken all the original packages and moved them into the new module system.

We can see what these modules are by typing into the command line:

$java --list-modules
These modules are split into four major groups: java, javafx, jdk, and Oracle.

java modules are the implementation classes for the core SE Language Specification.

javafx modules are the FX UI libraries.

Anything needed by the JDK itself is kept in the jdk modules.

And finally, anything that is Oracle-specific is in the oracle modules.

                14.10.4.2.8 Module Declarations
To set up a module, we need to put a special file at the root of our packages named module-info.java.
This file is known as the module descriptor and contains all of the data needed to build and use our new module.

We construct the module with a declaration whose body is either empty or made up of module directives:

module myModuleName {
    // all directives are optional
}
We start the module declaration with the module keyword, and we follow that with the name of the module.

The module will work with this declaration, but we’ll commonly need more information.

That is where the module directives come in.

                    14.10.4.2.8.1 Requires
Our first directive is requires. This module directive allows us to declare module dependencies:

module my.module {
    requires module.name;
}
Now, my.module has both a runtime and a compile-time dependency on module.name.

And all public types exported from a dependency are accessible by our module when we use this directive.

                    14.10.4.2.8.2 Requires Static
Sometimes we write code that references another module, but that users of our library will never want to use.

For instance, we might write a utility function that pretty-prints our internal state when another logging module is present. But, not every consumer of our library will want this functionality, and they don’t want to include an extra logging library.

In these cases, we want to use an optional dependency. By using the requires static directive, we create a compile-time-only dependency:

module my.module {
    requires static module.name;
}

                    14.10.4.2.8.3 Requires Transitive
We commonly work with libraries to make our lives easier.

But, we need to make sure that any module that brings in our code will also bring in these extra ‘transitive’ dependencies or they won’t work.

Luckily, we can use the requires transitive directive to force any downstream consumers also to read our required dependencies:

module my.module {
    requires transitive module.name;
}
Now, when a developer requires my.module, they won’t also have also to say requires module.name for our module to still work.

                    14.10.4.2.8.4 Exports
By default, a module doesn’t expose any of its API to other modules. This strong encapsulation was one of the key motivators for creating the module system in the first place.

Our code is significantly more secure, but now we need to explicitly open our API up to the world if we want it to be usable.

We use the exports directive to expose all public members of the named package:

module my.module {
    exports com.my.package.name;
}
Now, when someone does requires my.module, they will have access to the public types in our com.my.package.name package, but not any other package.

                    14.10.4.2.8.5 Exports … To
We can use exports…to to open up our public classes to the world.

But, what if we don’t want the entire world to access our API?

We can restrict which modules have access to our APIs using the exports…to directive.

Similar to the exports directive, we declare a package as exported. But, we also list which modules we are allowing to import this package as a requires. Let’s see what this looks like:

module my.module {
    export com.my.package.name to com.specific.package;
}

                    14.10.4.2.8.6 Uses
A service is an implementation of a specific interface or abstract class that can be consumed by other classes.
We designate the services our module consumes with the uses directive.

Note that the class name we use is either the interface or abstract class of the service, not the implementation class:

module my.module {
    uses class.name;
}
We should note here that there’s a difference between a requires directive and the uses directive.

We might require a module that provides a service we want to consume, but that service implements an interface from one of its transitive dependencies.

Instead of forcing our module to require all transitive dependencies just in case, we use the uses directive to add the required interface to the module path.

                    14.10.4.2.8.7 Provides … With
A module can also be a service provider that other modules can consume.

The first part of the directive is the provides keyword. Here is where we put the interface or abstract class name.

Next, we have the with directive where we provide the implementation class name that either implements the interface or extends the abstract class.
Here’s what it looks like put together:

module my.module {
    provides MyInterface with MyInterfaceImpl;
}

                    14.10.4.2.8.8 Open
We mentioned earlier that encapsulation was a driving motivator for the design of this module system.

Before Java 9, it was possible to use reflection to examine every type and member in a package, even the private ones. Nothing was truly encapsulated, which can open up all kinds of problems for developers of the libraries.

Because Java 9 enforces strong encapsulation, we now have to explicitly grant permission for other modules to reflect on our classes.

If we want to continue to allow full reflection as older versions of Java did, we can simply open the entire module up:

open module my.module {
}

                    14.10.4.2.8.9 Opens
If we need to allow reflection of private types, but we don’t want all of our code exposed, we can use the opens directive to expose specific packages.

But remember, this will open the package up to the entire world, so make sure that is what you want:

module my.module {
  opens com.my.package;
}

                    14.10.4.2.8.10 Opens … To
Okay, so reflection is great sometimes, but we still want as much security as we can get from encapsulation. We can selectively open our packages to a pre-approved list of modules, in this case, using the opens…to directive:

module my.module {
    opens com.my.package to moduleOne, moduleTwo, etc.;
}

                    14.10.4.2.8.11
                14.10.4.2.9 Command Line Options
By now, support for Java 9 modules has been added to Maven and Gradle, so you won’t need to do a lot of manual building of your projects. However, it’s still valuable to know how to use the module system from the command line.

We’ll be using the command line for our full example down below to help solidify how the entire system works in our minds.

module-path – We use the –module-path option to specify the module path. This is a list of one or more directories that contain your modules.
add-reads – Instead of relying on the module declaration file, we can use the command line equivalent of the requires directive; –add-reads.
add-exports – Command line replacement for the exports directive.
add-opens – Replace the open clause in the module declaration file.
add-modules – Adds the list of modules into the default set of modules
list-modules – Prints a list of all modules and their version strings
patch-module – Add or override classes in a modules
illegal-access=permit|warn|deny – Either relax strong encapsulation by showing a single global warning, shows every warning, or fails with errors. The default is permit.

                14.10.4.2.10 Visibility
We should spend a little time talking about the visibility of our code.

A lot of libraries depend on reflection to work their magic (JUnit and Spring come to mind).

By default in Java 9, we will only have access to public classes, methods, and fields in our exported packages. Even if we use reflection to get access to non-public members and call setAccessible(true), we won’t be able to access these members.

We can use the open, opens, and opens…to options to grant runtime-only access for reflection. Note, this is runtime-only!

We won’t be able to compile against private types, and we should never need to anyway.

If we must have access to a module for reflection, and we’re not the owner of that module (i.e., we can’t use the opens…to directive), then it’s possible to use the command line –add-opens option to allow own modules reflection access to the locked down module at runtime.


The only caveat here’s that you need to have access to the command line arguments that are used to run a module for this to work.

                14.10.4.2.11 Putting It All Together - java modules demo, tags: Putting It All Together - java modules demo
Now that we know what a module is and how to use them let’s go ahead and build a simple project to demonstrate all the concepts we just learned.

To keep things simple, we won’t be using Maven or Gradle. Instead, we’ll rely on the command line tools to build our modules.

                    14.10.4.2.11.1 directory structure
[i500695@WYLQRXL9LQ:2023-09-18 15:54:36:~/work/code/java/features/java_8/modules:]2144$ mkdir simple-modules
[i500695@WYLQRXL9LQ:2023-09-18 15:56:50:~/work/code/java/features/java_8/modules:]2145$ mkdir simple-modules/hello.modules
[i500695@WYLQRXL9LQ:2023-09-18 15:57:02:~/work/code/java/features/java_8/modules:]2146$ mkdir simple-modules/hello.modules/com
[i500695@WYLQRXL9LQ:2023-09-18 15:57:17:~/work/code/java/features/java_8/modules:]2147$ mkdir simple-modules/hello.modules/com/baeldung
[i500695@WYLQRXL9LQ:2023-09-18 15:57:32:~/work/code/java/features/java_8/modules:]2148$ mkdir simple-modules/hello.modules/com/baeldung/modules
[i500695@WYLQRXL9LQ:2023-09-18 15:57:42:~/work/code/java/features/java_8/modules:]2149$ mkdir simple-modules/hello.modules/com/baeldung/modules/hello
[i500695@WYLQRXL9LQ:2023-09-18 15:57:45:~/work/code/java/features/java_8/modules:]2150$ mkdir simple-modules/main.app
[i500695@WYLQRXL9LQ:2023-09-18 15:57:54:~/work/code/java/features/java_8/modules:]2151$ mkdir simple-modules/main.app/com
[i500695@WYLQRXL9LQ:2023-09-18 15:57:57:~/work/code/java/features/java_8/modules:]2152$ mkdir simple-modules/main.app/com/baeldung
[i500695@WYLQRXL9LQ:2023-09-18 15:58:02:~/work/code/java/features/java_8/modules:]2153$ mkdir simple-modules/main.app/com/baeldung/modules
[i500695@WYLQRXL9LQ:2023-09-18 15:58:06:~/work/code/java/features/java_8/modules:]2154$ mkdir simple-modules/main.app/com/baeldung/modules/main
[i500695@WYLQRXL9LQ:2023-09-18 15:58:08:~/work/code/java/features/java_8/modules:]2155$ dir_tree 
   |-simple-modules
   |---hello.modules
   |-----com
   |-------baeldung
   |---------modules
   |-----------hello
   |---main.app
   |-----com
   |-------baeldung
   |---------modules
   |-----------main

                    14.10.4.2.11.2 first module
package:com.baeldung.modules.hello 
class: HelloModules.java 
package com.baeldung.modules.hello;

public class HelloModules {
    public static void doSomething() {
        System.out.println("Hello, Modules!");
    }
}

descriptor: module-info.java
module hello.modules {
    exports com.baeldung.modules.hello;
}
Note that this means we export all public members

all together:
[i500695@WYLQRXL9LQ:2023-09-18 15:58:27:~/work/code/java/features/java_8/modules:]2156$ ed simple-modules/hello.modules/com/baeldung/HelloModules.java 
simple-modules/hello.modules/com/baeldung/HelloModules.java: No such file or directory
a
package com.baeldung.modules.hello;

public class HelloModules {
    public static void doSomething() {
        System.out.println("Hello, Modules!");
    }
}
.
w
159
q
[i500695@WYLQRXL9LQ:2023-09-18 17:53:46:~/work/code/java/features/java_8/modules:]2157$ ed simple-modules/hello.modules/module-info.java
simple-modules/hello.modules/module-info.java: No such file or directory
a
module hello.modules {
    exports com.baeldung.modules.hello;
}
.
w
65
q


                    14.10.4.2.11.3 second module
- create module descriptor, note we don't export anything (no need), just importing hello.modules
[i500695@WYLQRXL9LQ:2023-09-18 17:54:49:~/work/code/java/features/java_8/modules:]2158$ ed simple-modules/main.app/module-info.java
simple-modules/main.app/module-info.java: No such file or directory
a
module main.app {
    requires hello.modules;
}
.
w
48
q

- create the using app
[i500695@WYLQRXL9LQ:2023-09-18 17:56:40:~/work/code/java/features/java_8/modules:]2159$ ed simple-modules/main.app/com/baeldung/MainApp.java
simple-modules/main.app/com/baeldung/MainApp.java: No such file or directory
a
package com.baeldung.modules.main;

import com.baeldung.modules.hello.HelloModules;

public class MainApp {
    public static void main(String[] args) {
        HelloModules.doSomething();
    }
}
.
w
197
q


                    14.10.4.2.11.4 build
[i500695@WYLQRXL9LQ:2023-09-18 17:59:43:~/work/code/java/features/java_8/modules:]2161$ ed compile-simple-modules.sh
compile-simple-modules.sh: No such file or directory
a
#!/usr/bin/env bash
javac -d outDir --module-source-path simple-modules $(find simple-modules -name "*.java")
.
w
110
q
[i500695@WYLQRXL9LQ:2023-09-18 18:00:13:~/work/code/java/features/java_8/modules:]2162$ . !$
. compile-simple-modules.sh
[i500695@WYLQRXL9LQ:2023-09-18 18:00:16:~/work/code/java/features/java_8/modules:]2163$ ls outDir/
hello.modules/	main.app/

                    14.10.4.2.11.5 Run
[i500695@WYLQRXL9LQ:2023-09-18 18:00:22:~/work/code/java/features/java_8/modules:]2164$ ed run-simple-module-app.sh
run-simple-module-app.sh: No such file or directory
a
#!/usr/bin/env bash
java --module-path outDir -m main.app/com.baeldung.modules.main.MainApp
.
w
92
q
[i500695@WYLQRXL9LQ:2023-09-18 18:01:30:~/work/code/java/features/java_8/modules:]2165$ . !$
. run-simple-module-app.sh
Hello, Modules!


                    14.10.4.2.11.6 Adding a Service
Now that we have a basic understanding of how to build a module, let’s make it a little more complicated.
We’re going to see how to use the provides…with and uses directives.
Start by defining a new file in the hello.modules module named HelloInterface.java, and adapting HelloModules class to implement it...
[i500695@WYLQRXL9LQ:2023-09-18 18:01:43:~/work/code/java/features/java_8/modules:]2166$ ed simple-modules/hello.modules/com/baeldung/HelloInterface.java
simple-modules/hello.modules/com/baeldung/HelloInterface.java: No such file or directory
a
public interface HelloInterface {
    void sayHello();
}
.
w
57
q
[i500695@WYLQRXL9LQ:2023-09-18 18:03:39:~/work/code/java/features/java_8/modules:]2167$ ed simple-modules/hello.modules/com/baeldung/HelloModules.java 
159
%d
a
public class HelloModules implements HelloInterface {
    public static void doSomething() {
        System.out.println("Hello, Modules!");
    }

    public void sayHello() {
        System.out.println("Hello!");
    }
}
.
w
222
q

That is all we need to do to create a service.
Now, we need to tell the world that our module provides this service.
Add the following to our module-info.java:
provides com.baeldung.modules.hello.HelloInterface with com.baeldung.modules.hello.HelloModules;
As we can see, we declare the interface and which class implements it.
$ cat simple-modules/hello.modules/module-info.java
module hello.modules {
    exports com.baeldung.modules.hello;
    provides com.baeldung.modules.hello.HelloInterface with com.baeldung.modules.hello.HelloModules;
}

As we can see, we declare the interface and which class implements it.

Next, we need to consume this service. In our main.app module, let’s add the following to our module-info.java:

uses com.baeldung.modules.hello.HelloInterface;

$ cat simple-modules/main.app/module-info.java
module main.app {
    requires hello.modules;
    uses com.baeldung.modules.hello.HelloInterface;
}

Finally, in our main method we can use this service via a ServiceLoader:
Iterable<HelloInterface> services = ServiceLoader.load(HelloInterface.class);
HelloInterface service = services.iterator().next();
service.sayHello();

$cat simple-modules/main.app/com/baeldung/modules/main/MainApp.java
package com.baeldung.modules.main;

import com.baeldung.modules.hello.HelloModules;

public class MainApp {
    public static void main(String[] args) {
        // HelloModules.doSomething();
        Iterable<HelloInterface> services = ServiceLoader.load(HelloInterface.class);
        HelloInterface service = services.iterator().next();
        service.sayHello();
    }
}

                14.10.4.2.12 Final demo structure and code
[i500695@WYLQRXL9LQ:2023-09-18 18:27:23:~/work/code/java/features/java_8/modules:]2199$ dir_tree 
   |-outDir
   |---hello.modules
   |-----com
   |-------baeldung
   |---------modules
   |-----------hello
   |---main.app
   |-----com
   |-------baeldung
   |---------modules
   |-----------main
   |-simple-modules
   |---hello.modules
   |-----com
   |-------baeldung
   |---------modules
   |-----------hello
   |---main.app
   |-----com
   |-------baeldung
   |---------modules
   |-----------main
[i500695@WYLQRXL9LQ:2023-09-18 18:27:45:~/work/code/java/features/java_8/modules:]2200$ for file in $(find . -name '*.java'); do echo $file; cat $file; echo "--------"; done
./simple-modules/hello.modules/module-info.java
module hello.modules {
    exports com.baeldung.modules.hello;
    provides com.baeldung.modules.hello.HelloInterface with com.baeldung.modules.hello.HelloModules;
}
--------
./simple-modules/hello.modules/com/baeldung/modules/hello/HelloModules.java
package com.baeldung.modules.hello;
public class HelloModules implements HelloInterface {
    public static void doSomething() {
        System.out.println("Hello, Modules!");
    }

    public void sayHello() {
        System.out.println("Hello!");
    }
}
--------
./simple-modules/hello.modules/com/baeldung/modules/hello/HelloInterface.java
package com.baeldung.modules.hello;
public interface HelloInterface {
    void sayHello();
}
--------
./simple-modules/main.app/module-info.java
module main.app {
    requires hello.modules;
    uses com.baeldung.modules.hello.HelloInterface;
}
--------
./simple-modules/main.app/com/baeldung/modules/main/MainApp.java
package com.baeldung.modules.main;

import java.util.ServiceLoader;

import com.baeldung.modules.hello.HelloInterface;

public class MainApp {
    public static void main(String[] args) {
        // HelloModules.doSomething();
        Iterable<HelloInterface> services = ServiceLoader.load(HelloInterface.class);
        HelloInterface service = services.iterator().next();
        service.sayHello();
    }
}
--------
[i500695@WYLQRXL9LQ:2023-09-18 18:27:47:~/work/code/java/features/java_8/modules:]2201$ . compile-simple-modules.sh
[i500695@WYLQRXL9LQ:2023-09-18 18:28:05:~/work/code/java/features/java_8/modules:]2202$ . run-simple-module-app.sh
Hello!

                14.10.4.2.13 Adding Modules to the Unnamed Module
The unnamed module concept is similar to the default package. Therefore, it’s not considered a real module, but can be viewed as the default module.

If a class is not a member of a named module, then it will be automatically considered as part of this unnamed module.

Sometimes, to ensure specific platform, library, or service-provider modules in the module graph, we need to add modules to the default root set. For example, when we try to run Java 8 programs as-is with Java 9 compiler we may need to add modules.

In general, the option to add the named modules to the default set of root modules is –add-modules <module>(,<module>)* where <module> is a module name.

For example, to provide access to all java.xml.bind modules the syntax would be:

--add-modules java.xml.bind
Copy
To use this in Maven, we can embed the same to the maven-compiler-plugin:

<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>3.8.0</version>
    <configuration>
        <source>9</source>
        <target>9</target>
        <compilerArgs>
            <arg>--add-modules</arg>
            <arg>java.xml.bind</arg>
        </compilerArgs>
    </configuration>
</plugin>

                14.10.4.2.14
            14.10.4.3
            14.10.4.4
        14.10.5 Process API Improvements
Java SE 9 is coming with some improvements in Process API. They have added couple new classes and methods to ease the controlling and managing of OS processes. Two new interfcase in Process API:

java.lang.ProcessHandle
java.lang.ProcessHandle.Info

            14.10.5.1  chatgpt

Java 9 introduced several improvements to the Process API to enhance the interaction between Java applications and native processes, making it easier to manage and control external processes. These improvements include the introduction of the `ProcessHandle` interface and related methods. Here are some of the key enhancements:

| 1. **Introduction of `ProcessHandle` Interface**: Java 9 introduced the `java.lang.ProcessHandle` interface, which represents a native process. This interface provides methods for inspecting and controlling processes.
| 
| 2. **Listing All Processes**: You can use the `ProcessHandle.allProcesses()` method to obtain a stream of all currently running processes on the system. This allows you to inspect and interact with each process.
| 
| ```java
| ProcessHandle.allProcesses().forEach(process -> {
|     System.out.println("PID: " + process.pid());
|     System.out.println("Command: " + process.info().command().orElse("N/A"));
|     System.out.println("Arguments: " + String.join(" ", process.info().arguments().orElse(new String[] {})));
| });
| ```
| 
| 3. **Accessing Process Information**: The `ProcessHandle` interface provides methods to retrieve information about a process, such as its PID (Process ID), command, arguments, start time, user, and more.

```java
ProcessHandle process = ... // Obtain a ProcessHandle
System.out.println("PID: " + process.pid());
System.out.println("Command: " + process.info().command().orElse("N/A"));
System.out.println("Arguments: " + String.join(" ", process.info().arguments().orElse(new String[] {})));
System.out.println("Start Time: " + process.info().startInstant().orElse(null));
System.out.println("User: " + process.info().user().orElse("N/A"));
```

|4. **Destroying and Monitoring Processes**: You can use the `destroy()` and `destroyForcibly()` methods to terminate a process. Additionally, you can use the `isAlive()` method to check if a process is still running. These methods make it easier to manage external processes from Java.

```java
ProcessHandle process = ... // Obtain a ProcessHandle
boolean destroyed = process.destroy();
boolean forciblyDestroyed = process.destroyForcibly();
boolean isAlive = process.isAlive();
```

|5. **OnExit Callbacks**: You can register an `onExit` callback with a `ProcessHandle` to perform actions when a process exits. This allows you to respond to process termination events.

```java
ProcessHandle process = ... // Obtain a ProcessHandle
process.onExit().thenAccept(p -> System.out.println("Process exited with PID: " + p.pid()));
```

These enhancements to the Process API in Java 9 make it more powerful and versatile for managing external processes, inspecting process information, and responding to process events, improving the overall interaction between Java applications and the underlying operating system.


            14.10.5.2 demo
[i500695@WYLQRXL9LQ:2023-09-19 18:30:02:~/work/code/java/features/java_9/process_handle:]2226$ cat ProcessHandleDemo.java 
class ProcessHandleDemo {
    public static void main(String[] args) {
        ProcessHandle.allProcesses().forEach(process -> {
            String user = process.info().user().orElse("N/A");
            if (user.equals("i500695")) { //print my processes 
                System.out.printf("PID=%d, Command=%s, Arguments=%s, Start time=%s, user=%s \n", process.pid(),
                        process.info().command().orElse("N/A"),
                        String.join(" ", process.info().arguments().orElse(new String[] {})),
                        process.info().startInstant().orElse(null),
                        process.info().user().orElse("N/A"));

            }
        });

    }
}[i500695@WYLQRXL9LQ:2023-09-19 18:30:49:~/work/code/java/features/java_9/process_handle:]2227$ javac ProcessHandleDemo.java 
[i500695@WYLQRXL9LQ:2023-09-19 18:30:52:~/work/code/java/features/java_9/process_handle:]2228$ java ProcessHandleDemo | head -n 4
PID=27795, Command=/opt/homebrew/Cellar/openjdk/20.0.2/libexec/openjdk.jdk/Contents/Home/bin/java, Arguments=ProcessHandleDemo, Start time=2023-09-19T15:30:58.289Z, user=i500695 
PID=27796, Command=/usr/bin/head, Arguments=-n 4, Start time=2023-09-19T15:30:58.291Z, user=i500695 
PID=27745, Command=/System/Library/Frameworks/CoreServices.framework/Frameworks/Metadata.framework/Versions/A/Support/mdworker_shared, Arguments=-s mdworker -c MDSImporterWorker -m com.apple.mdworker.shared, Start time=2023-09-19T15:30:15.186Z, user=i500695 
PID=27722, Command=/System/Library/PrivateFrameworks/HelpData.framework/Versions/A/Resources/helpd, Arguments=, Start time=2023-09-19T15:30:02.319Z, user=i500695 

            14.10.5.3  try-with-resources statement 

                14.10.5.3.1   explanation


The try-with-resources statement is a try statement with one or more resources duly declared. Here resource is an object which should be closed once it is no more required. The try-with-resources statement ensures that each resource is closed after the requirement finishes. Any object implementing java.lang.AutoCloseable or java.io.Closeable, interface can be used as a resource.

Prior to Java 9, resources are to be declared before try or inside try statement as shown below in given example. In this example, we'll use BufferedReader as resource to read a string and then BufferedReader is to be closed.

Tester.java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;

public class Tester {
   public static void main(String[] args) throws IOException {
      System.out.println(readData("test"));
   } 
   static String readData(String message) throws IOException {
      Reader inputString = new StringReader(message);
      BufferedReader br = new BufferedReader(inputString);
      try (BufferedReader br1 = br) {
         return br1.readLine();
      }
   }
}

Output
test
Here we need to declare a resource br1 within try statment and then use it. In Java9, we don't need to declare br1 anymore and following program will give the same result.

Tester.java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;

public class Tester {
   public static void main(String[] args) throws IOException {
      System.out.println(readData("test"));
   } 
   static String readData(String message) throws IOException {
      Reader inputString = new StringReader(message);
      BufferedReader br = new BufferedReader(inputString);
      try (br) {
         return br.readLine();
      }
   }
}

Output
test

                14.10.5.3.2 demo
[i500695@WYLQRXL9LQ:2023-09-19 18:39:10:~/work/code/java/features/java_9/try_with_resource:]2237$ cat TryWithResourceDemo.java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;

public class TryWithResourceDemo{
   public static void main(String[] args) throws IOException {
      System.out.println(readData("Try-With-Resource demo. resource will auto close after try clause"));
   } 

   static String readData(String message) throws IOException {
      Reader inputString = new StringReader(message);
      BufferedReader br = new BufferedReader(inputString);
      try (br) {
         return br.readLine();
      }
   }
}
[i500695@WYLQRXL9LQ:2023-09-19 18:39:19:~/work/code/java/features/java_9/try_with_resource:]2238$ javac TryWithResourceDemo.java 
[i500695@WYLQRXL9LQ:2023-09-19 18:39:20:~/work/code/java/features/java_9/try_with_resource:]2239$ java TryWithResourceDemo
Try-With-Resource demo. resource will auto close after try clause

                14.10.5.3.3

        14.10.6 CompletableFuture API Improvements in java 9

            14.10.6.1  GPT
Java 9 introduced several improvements to the `CompletableFuture` class, which is part of the Java Concurrency framework and is used for asynchronous and concurrent programming. These improvements aimed to enhance the usability and flexibility of the `CompletableFuture` API. Here are some of the key improvements:

**1. Factory Methods for `CompletableFuture`**

Java 9 introduced factory methods for creating instances of `CompletableFuture`. These methods simplify the creation of completed, exceptionally completed, and incomplete futures:

- `CompletableFuture.completedFuture(T value)`: Returns a new `CompletableFuture` that is already completed with the given value.
- `CompletableFuture.failedFuture(Throwable ex)`: Returns a new `CompletableFuture` that is already exceptionally completed with the given exception.
- `new CompletableFuture().obtrudeValue(T value)`: Explicitly sets the value of a `CompletableFuture`, making it completed.
- `new CompletableFuture().obtrudeException(Throwable ex)`: Explicitly sets an exception for a `CompletableFuture`, making it exceptionally completed.

**2. Improved `thenAccpet`, `thenApply`, and `thenRun` Variants**

In Java 9, the `thenAccept`, `thenApply`, and `thenRun` methods were enhanced to include async variants that allow you to specify an executor for the dependent action. This provides more control over the execution context:

- `thenAcceptAsync(Consumer<? super T> action, Executor executor)`: Executes the action asynchronously using the specified executor when the source `CompletableFuture` completes.
- `thenApplyAsync(Function<? super T,? extends U> fn, Executor executor)`: Applies the function asynchronously using the specified executor when the source `CompletableFuture` completes.
- `thenRunAsync(Runnable action, Executor executor)`: Runs the action asynchronously using the specified executor when the source `CompletableFuture` completes.

**3. `or` and `completeOnTimeout` Methods**

- `or`: Introduced as an alternative to `applyToEither` and `acceptEither`, `or` returns a new `CompletableFuture` that is completed with the result of the first of the given CompletableFutures to complete.
- `completeOnTimeout`: Allows you to complete a `CompletableFuture` with a default value if it hasn't completed within a specified timeout.

**4. `completeAsync` and `obtrudeAsync` Methods**

- `completeAsync`: Completes a `CompletableFuture` asynchronously using a supplied supplier or future supplier.
- `obtrudeAsync`: Similar to `obtrudeValue` and `obtrudeException`, but performs the operation asynchronously.

**5. `delayedExecutor` Method**

Introduced the `delayedExecutor` method in the `Executor` interface, which returns an executor that introduces a delay between submission and execution of tasks.

These improvements in Java 9 make working with `CompletableFuture` more powerful and flexible, allowing developers to write asynchronous and concurrent code more efficiently and effectively. They provide better control over execution contexts, handling exceptional cases, and specifying timeout behavior.
            14.10.6.2 GTP demo
Certainly! Let's create a simple demo that showcases some of the `CompletableFuture` API improvements introduced in Java 9.

In this example, we'll cover the following features:
|1. Factory methods for `CompletableFuture`.
|2. Improved `thenAcceptAsync`, `thenApplyAsync`, and `thenRunAsync`.
|3. `or` method for handling the first completed future.
|4. `completeOnTimeout` for setting a timeout.
|5. `delayedExecutor` for introducing a delay.

```java
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class CompletableFutureDemo {
    public static void main(String[] args) throws Exception {
        // Factory methods
        CompletableFuture<Integer> completedFuture = CompletableFuture.completedFuture(42);
        CompletableFuture<String> failedFuture = CompletableFuture.failedFuture(new RuntimeException("Failed!"));

        // thenAcceptAsync with a custom executor
        Executor customExecutor = Executors.newSingleThreadExecutor();
        CompletableFuture<Void> thenAcceptAsyncDemo = completedFuture.thenAcceptAsync(result -> {
            System.out.println("Received result: " + result);
            System.out.println("Thread: " + Thread.currentThread().getName());
        }, customExecutor);

        // or method to handle the first completed future
        CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "Result from Future 1");
        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> "Result from Future 2");
        CompletableFuture<String> firstCompleted = future1.or(() -> future2);

        // completeOnTimeout to handle a timeout
        CompletableFuture<Integer> delayedFuture = CompletableFuture.supplyAsync(() -> {
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return 100;
        });

        CompletableFuture<Integer> result = delayedFuture.completeOnTimeout(42, 1, TimeUnit.SECONDS);

        // delayedExecutor to introduce a delay
        Executor delayedExecutor = Executors.newScheduledThreadPool(1);
        CompletableFuture<Void> delayedDemo = CompletableFuture.runAsync(() -> {
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Task executed after a delay.");
        }, delayedExecutor);

        // Wait for completion
        thenAcceptAsyncDemo.get();
        System.out.println("First completed: " + firstCompleted.join());
        System.out.println("Timeout result: " + result.join());
        delayedDemo.get();
    }
}
```

In this demo:

- We use factory methods to create completed and failed futures.
- `thenAcceptAsync` demonstrates asynchronous execution with a custom executor.
- `or` method allows us to choose the result from the first completed future.
- `completeOnTimeout` demonstrates setting a timeout for a future.
- `delayedExecutor` is used to introduce a delay in the execution of a task.

Make sure to replace the custom executor and file paths with appropriate values for your environment.


            14.10.6.3 my demo
[i500695@WYLQRXL9LQ:2023-09-26 19:02:13:~/work/code/java/features/java_9/CompletableFuture:]2023$ cat CompletableFutureDemo.java 
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class CompletableFutureDemo {
    public static void main(String[] args) throws Exception {
        
        // Factory methods
        CompletableFuture<Integer> completedFuture = CompletableFuture.completedFuture(42);
        CompletableFuture<String> failedFuture = CompletableFuture.failedFuture(new RuntimeException("Failed!"));

        // thenAcceptAsync with a custom executor
        Executor customExecutor = Executors.newSingleThreadExecutor();
        CompletableFuture<Void> thenAcceptAsyncDemo = completedFuture.thenAcceptAsync(result -> {
            System.out.println("Received result: " + result);
            System.out.println("Thread: " + Thread.currentThread().getName());
        }, customExecutor);

        // or method to handle the first completed future
        CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "Result from Future 1");
        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> "Result from Future 2");
        CompletableFuture<String> firstCompleted = future1.thenCombine(future2, (res1, res2) -> res1+" | "+res2);
        firstCompleted.thenAccept( res3 -> System.out.println("Combined result of two futures: " + res3));

        // completeOnTimeout to handle a timeout
        CompletableFuture<Integer> delayedFuture = CompletableFuture.supplyAsync(() -> {
            try {
                TimeUnit.SECONDS.sleep(2); //simulate long running task
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return 100; //return value
        });

        CompletableFuture<Integer> result = delayedFuture.completeOnTimeout(42, 1, TimeUnit.SECONDS); // 42 is value to return on TO, 1 is TO, in seconds

        // delayedExecutor to introduce a delay
        Executor delayedExecutor = Executors.newScheduledThreadPool(1); // 1 thread in executor thread pool
        CompletableFuture<Void> delayedDemo = CompletableFuture.runAsync(() -> {
            try {
                TimeUnit.SECONDS.sleep(2); // this is the delay
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Task executed after a delay."); // this is the task
        }, delayedExecutor);

        // Wait for completion
        thenAcceptAsyncDemo.get();
        System.out.println("First completed: " + firstCompleted.join());
        System.out.println("Timeout result: " + result.join());
        delayedDemo.get();
    }
}
[i500695@WYLQRXL9LQ:2023-09-26 19:02:51:~/work/code/java/features/java_9/CompletableFuture:]2024$ javac CompletableFutureDemo.java 
[i500695@WYLQRXL9LQ:2023-09-26 19:02:57:~/work/code/java/features/java_9/CompletableFuture:]2025$ java CompletableFutureDemo
Received result: 42
Thread: pool-1-thread-1
Combined result of two futures: Result from Future 1 | Result from Future 2
First completed: Result from Future 1 | Result from Future 2
Timeout result: 42
Task executed after a delay.
            14.10.6.4

        14.10.7 java 9 reactive streams 

            14.10.7.1 https://www.baeldung.com/java-9-reactive-streams

                14.10.7.1.1 Overview
In this article, we’ll be looking at the Java 9 Reactive Streams. Simply put, we’ll be able to use the Flow class, which encloses the primary building blocks for building reactive stream processing logic.

Reactive Streams is a standard for asynchronous stream processing with non-blocking back pressure. This specification is defined in the Reactive Manifesto, and there are various implementations of it, for example, RxJava or Akka-Streams.

                14.10.7.1.2 Reactive API Overview
To build a Flow, we can use three main abstractions and compose them into asynchronous processing logic.

Every Flow needs to process events that are published to it by a Publisher instance; the Publisher has one method – subscribe().

If any of the subscribers want to receive events published by it, they need to subscribe to the given Publisher.


The receiver of messages needs to implement the Subscriber interface. Typically this is the end for every Flow processing because the instance of it does not send messages further.

We can think about Subscriber as a Sink. This has four methods that need to be overridden – onSubscribe(), onNext(), onError(), and onComplete(). We’ll be looking at those in the next section.

If we want to transform incoming message and pass it further to the next Subscriber, we need to implement the Processor interface. This acts both as a Subscriber because it receives messages, and as the Publisher because it processes those messages and sends them for further processing.

                14.10.7.1.3 Publishing and Consuming Messages
Let’s say we want to create a simple Flow, in which we have a Publisher publishing messages, and a simple Subscriber consuming messages as they arrive – one at the time.

Let’s create an EndSubscriber class. We need to implement the Subscriber interface. Next, we’ll override the required methods.
The onSubscribe() method is called before processing starts. The instance of the Subscription is passed as the argument. It is a class that is used to control the flow of messages between Subscriber and the Publisher:
public class EndSubscriber<T> implements Subscriber<T> {
    private Subscription subscription;
    public List<T> consumedElements = new LinkedList<>();

    @Override
    public void onSubscribe(Subscription subscription) {
        this.subscription = subscription;
        subscription.request(1);
    }
}
We also initialized an empty List of consumedElements that’ll be utilized in the tests.

Now, we need to implement the remaining methods from the Subscriber interface. The main method here is onNext() – this is called whenever the Publisher publishes a new message:
@Override
public void onNext(T item) {
    System.out.println("Got : " + item);
    consumedElements.add(item);
    subscription.request(1);
}
Note that when we started the subscription in the onSubscribe() method and when we processed a message we need to call the request() method on the Subscription to signal that the current Subscriber is ready to consume more messages.

Lastly, we need to implement onError() – which is called whenever some exception will be thrown in the processing, as well as onComplete() – called when the Publisher is closed:
@Override
public void onError(Throwable t) {
    t.printStackTrace();
}

@Override
public void onComplete() {
    System.out.println("Done");
}

Let’s write a test for the Processing Flow. We’ll be using the SubmissionPublisher class – a construct from the java.util.concurrent – which implements the Publisher interface.

We’re going to be submitting N elements to the Publisher – which our EndSubscriber will be receiving:
@Test
public void whenSubscribeToIt_thenShouldConsumeAll() 
  throws InterruptedException {
 
    // given
    SubmissionPublisher<String> publisher = new SubmissionPublisher<>();
    EndSubscriber<String> subscriber = new EndSubscriber<>();
    publisher.subscribe(subscriber);
    List<String> items = List.of("1", "x", "2", "x", "3", "x");

    // when
    assertThat(publisher.getNumberOfSubscribers()).isEqualTo(1);
    items.forEach(publisher::submit);
    publisher.close();

    // then
     await().atMost(1000, TimeUnit.MILLISECONDS)
       .until(
         () -> assertThat(subscriber.consumedElements)
         .containsExactlyElementsOf(items)
     );
}
                14.10.7.1.4

            14.10.7.2 chatgpt
Java 9 introduced the Reactive Streams API as part of the `java.util.concurrent.Flow` package. Reactive Streams are a standard for asynchronous stream processing in Java, designed to handle asynchronous and backpressure-aware stream processing. Here's a simple example of using the Reactive Streams API in Java 9:

```java
import java.util.concurrent.Flow.*;
import java.util.concurrent.SubmissionPublisher;
import java.util.concurrent.TimeUnit;

public class ReactiveStreamsExample {
    public static void main(String[] args) throws InterruptedException {
        // Create a SubmissionPublisher
        SubmissionPublisher<Integer> publisher = new SubmissionPublisher<>();

        // Create a Subscriber
        Subscriber<Integer> subscriber = new Subscriber<Integer>() {
            private Subscription subscription;

            @Override
            public void onSubscribe(Subscription subscription) {
                this.subscription = subscription;
                subscription.request(1); // Request the first item
            }

            @Override
            public void onNext(Integer item) {
                System.out.println("Received: " + item);
                subscription.request(1); // Request the next item
            }

            @Override
            public void onError(Throwable throwable) {
                throwable.printStackTrace();
            }

            @Override
            public void onComplete() {
                System.out.println("Done");
            }
        };

        // Subscribe the subscriber to the publisher
        publisher.subscribe(subscriber);

        // Publish some items
        for (int i = 1; i <= 5; i++) {
            publisher.submit(i);
            TimeUnit.MILLISECONDS.sleep(500); // Sleep to simulate asynchronous processing
        }

        // Close the publisher (important to avoid resource leaks)
        publisher.close();

        // Wait for a while to let the processing complete
        TimeUnit.SECONDS.sleep(2);
    }
}
```

In this example:

|1. We create a `SubmissionPublisher<Integer>` to publish integer items.
|
|2. We create a `Subscriber<Integer>` to subscribe to the publisher.
|
|3. In the `onSubscribe()` method of the subscriber, we request the first item to start the flow.
|
|4. In the `onNext()` method, we process received items and request the next one.
|
|5. In the `onError()` method, we handle errors if they occur.
|
|6. In the `onComplete()` method, we handle the completion of the stream.
|
|7. We subscribe the subscriber to the publisher.
|
|8. We publish integer items from 1 to 5 to the publisher with a 500ms delay between each item to simulate asynchronous processing.
|
|9. Finally, we close the publisher and wait for a while to ensure that all items are processed.

This example demonstrates the basic usage of the Reactive Streams API in Java 9, including publishing, subscribing, and handling items in a reactive and backpressure-aware manner.

            14.10.7.3

        14.10.8 Diamond Operator for Anonymous Inner Class
We know, Java SE 7 has introduced one new feature: Diamond Operator to avoid redundant code and verbosity, to improve readability. However, in Java SE 8, Oracle Corp (Java Library Developer) has found that some limitations in the use of Diamond operator with Anonymous Inner Class. They have fixed those issues and going to release them as part of Java 9.

  public List getEmployee(String empid){
     // Code to get Employee details from Data Store
     return new List(emp){ };
  }
Here we are using just “List” without specifying the type parameter.


        14.10.9 Optional Class Improvements
In Java SE 9, Oracle Corp has added some useful new methods to java.util.Optional class. Here I’m going to discuss about one of those methods with some simple example: stream method If a value present in the given Optional object, this stream() method returns a sequential Stream with that value. Otherwise, it returns an empty Stream. They have added “stream()” method to work on Optional objects lazily as shown below:

Stream<Optional> emp = getEmployee(id)
Stream empStream = emp.flatMap(Optional::stream)
Here Optional.stream() method is used to convert a Stream of Optional of Employee object into a Stream of Employee so that we can work on this result lazily in the result code.

        14.10.10 Stream API Improvements
In Java SE 9, Oracle Corp has added four useful new methods to java.util.Stream interface. As Stream is an interface, all those new implemented methods are default methods. Two of them are very important: dropWhile and takeWhile methods If you are familiar with Scala Language or any Functions programming language, you will definitely know about these methods. These are very useful methods in writing some functional style code. Let us discuss the takeWhile utility method here. This takeWhile() takes a predicate as an argument and returns a Stream of the subset of the given Stream values until that Predicate returns false for the first time. If the first value does NOT satisfy that Predicate, it just returns an empty Stream.

jshell> Stream.of(1,2,3,4,5,6,7,8,9,10).takeWhile(i -> i < 5 )
                 .forEach(System.out::println);

        14.10.11 Enhanced @Deprecated annotation
In Java SE 8 and earlier versions, @Deprecated annotation is just a Marker interface without any methods. It is used to mark a Java API that is a class, field, method, interface, constructor, enum etc. In Java SE 9, Oracle Corp has enhanced @Deprecated annotation to provide more information about deprecated API and also provide a Tool to analyze an application’s static usage of deprecated APIs. They have add two methods to this Deprecated interface: forRemoval and since to serve this information

        14.10.12 HTTP 2 Client
In Java SE 9, Oracle Corp is going to release New HTTP 2 Client API to support HTTP/2 protocol and WebSocket features. As existing or Legacy HTTP Client API has numerous issues (like supports HTTP/1.1 protocol and does not support HTTP/2 protocol and WebSocket, works only in Blocking mode and lot of performance issues.), they are replacing this HttpURLConnection API with new HTTP client. They are going to introduce a new HTTP 2 Client API under the “java.net.http” package. It supports both HTTP/1.1 and HTTP/2 protocols. It supports both Synchronous (Blocking Mode) and Asynchronous Modes. It supports Asynchronous Mode using the WebSocket API. We can see this new API at https://download.java.net/java/jdk9/docs/api/java/net/http/package-summary.html HTTP 2 Client Example

jshell> import java.net.http.*

jshell> import static java.net.http.HttpRequest.*

jshell> import static java.net.http.HttpResponse.*

jshell> URI uri = new URI("https://rams4java.blogspot.co.uk/2016/05/java-news.html")
uri ==> https://rams4java.blogspot.co.uk/2016/05/java-news.html

jshell> HttpResponse response = HttpRequest.create(uri).body(noBody()).GET().response()
response ==> java.net.http.HttpResponseImpl@79efed2d

jshell> System.out.println("Response was " + response.body(asString()))


        14.10.13 Multi-Resolution Image API
In Java SE 9, Oracle Corp is going to introduce a new Multi-Resolution Image API. Important interface in this API is MultiResolutionImage . It is available in java.awt.image package. MultiResolutionImage encapsulates a set of images with different Height and Widths (that is different resolutions) and allows us to query them with our requirements.

        14.10.14 Miscellaneous Java 9 Features
In this section, I will just list out some miscellaneous Java SE 9 New Features. I’m NOT saying these are less important features. They are also important and useful to understand them very well with some useful examples. As of now, I did not get enough information about these features. That’s why I am going to list them here for a brief understanding. I will pick up these features one by one and add to the above section with a brief discussion and example. And finally write a separate tutorial later.

GC (Garbage Collector) Improvements
Stack-Walking API
Filter Incoming Serialization Data
Deprecate the Applet API
Indify String Concatenation
Enhanced Method Handles
Java Platform Logging API and Service
Compact Strings
Parser API for Nashorn
Javadoc Search
HTML5 Javadoc

        14.10.15
    14.11  Java version 10, tags: Java version 10
Language Changes: Local Variable Type Inference(Var Keyword), Garbage Collector Interface.

        14.11.1   https://javagoal.com/java-10-features/

            14.11.1.1   Java 10 Features
Java 10 was released on March 20, 2018, The JDK 10 is an implementation of JAVA SE 10. As we know, Java is slow in growth and evolution as compared to other languages.  But Java 10 was quick to release after Java 9. With this release, the six-month release cycle has begun. You must think about why I am saying the six-month release cycle. I will explain it below in detail. To understand this concept, we have to understand LTS (Long Term Support model). In this post, we will read the most common and useful Java 10 Features and Java 10 tutorial.


            14.11.1.2 Local Variable Type Inference
Local variable type inference was the biggest feature of Java 10. As we know we have to define a variable with its data type but from Java 10 onward we can use the var keyword to declare the local variables. We don’t need to specify the data type with the variable name. Now it’s the compiler’s responsibility to infer the type of the variable using the value provided. We will discuss it in a separate post with various types of examples and what will be restrictions and rules. You can read it here.

// Declaring and initlizing an int variable with value
int i = 5;
// Declaring and initlizing an String variable with value
String hello = "Hello world!";
// Creating an ArrayList
ArrayList<String> list = new ArrayList<String>();
// Creating a HashMap 
HashMap<Integer, String> hashMap = new HashMap<Integer, String>()
// Declaring and initlizing variable with value
var i = 5;
// Declaring and initlizing variable with value
var hello = "Hello world!";
// Creating an ArrayList
var list = new ArrayList<String>();
// Creating a HashMap 
HashMap<Integer, String> hashMap = new HashMap<Integer, String>()

            14.11.1.3
        14.11.2

    14.11  Java version 11
    Language Changes: The Local Variable Syntax Adds Up For Lambda Parameters.

Library Changes: JEP 321 HTTP Client Standardized.

    14.12  Java version 12
    14.13  Java version 13
    14.14  Java version 14
    14.15  Java version 15
    14.16  Java version 16
    14.17  Java version 17

        14.17.1  Java 17 vs Java 8

            14.17.1.1  https://pretius.com/blog/java-17-features/
A few months from now – in March 2022 – Java 8 will lose its Oracle Premier Support. It doesn’t mean that it won’t receive any new updates, but Oracle’s effort put into maintaining it will likely be significantly smaller than it is right now.

That means there’ll be a good reason to make the move to a new version. Especially since just a month ago – on September 14th, 2021 – Java 17 was released. It’s the new Long Term Support version, with Oracle Premier Support to last until September 2026 (at least). What does Java 17 bring? How difficult will the migration be? Is it worth it? I’ll try to answer those questions in this article.

The popularity of Java 8 – a little bit of history
A screen showing Java logo with a looking glass.
Let’s take a look at some of the features.
Java 8, which was released in March 2014, is currently used by 69% of programmers in their main application. Why is it, after more than 7 years, still the most commonly used version? There are many reasons for that.

Java 8 provided lots of language features that made developers want to switch from previous versions. Lambdas, streams, functional programming, extensive API extensions – not to mention MetaSpace or G1 extensions. It was the Java version to use.

Java 9 appeared 3 years later, in September 2017, and for a typical developer, it changed next to nothing. A new HTTP client, process API, minor diamond operator and try-with-resources improvements. 

Sure, Java 9 did bring one significant change, groundbreaking even – the Jigsaw Project. It changed a lot, a great lot of things – but internally. Java modularization gives great possibilities, solves lots of technical problems, and applies to everyone, but only a relatively small group of users actually needed to deeply understand the changes. Due to the changes introduced with the Jigsaw Project lots of libraries required additional modifications, new versions were released, some of them did not work properly. 

Java 9 migration – in particular for large, corporate applications – was often difficult, time-consuming, and caused regression problems. So why do it, if there is little to gain and it costs a lot of time and money?

This brings us to the current day, October 2021. Java Development Kit 17 (JDK 17) was released just a month ago. Is it a good time to move on from the 7-year-old Java 8? First, let’s see what’s in Java 17. What does it bring to the programmer and admin or SRE, when compared to Java 8?

Java 17 vs Java 8 – the changes
This article covers only the changes that I deemed important enough or interesting enough to mention. They are not everything that was changed, improved, optimized in all the years of Java evolution. If you want to see a full list of changes to JDK, you should know that they are tracked as JEPs (JDK Enhancement Proposals). The list can be found in JEP-0.

Also, if you want to compare Java APIs between versions, there is a great tool called Java Version Almanac. There were many useful, small additions to Java APIs, and checking this website is likely the best option if someone wants to learn about all these changes.

As for now, let’s analyze the changes and new features in each iteration of Java, that are most important from the perspective of most of us Java Developers.

New var keyword
A new var keyword was added that allows local variables to be declared in a more concise manner. Consider this code:

// java 8 way
Map<String, List<MyDtoType>> myMap = new HashMap<String, List<MyDtoType>>();
List<MyDomainObjectWithLongName> myList = aDelegate.fetchDomainObjects();
// java 10 way
var myMap = new HashMap<String, List<MyDtoType>>();
var myList = aDelegate.fetchDomainObjects()
When using var, the declaration it’s much, much shorter and, perhaps, a bit more readable than before. One must make sure to take the readability into account first, so in some cases, it may be wrong to hide the type from the programmer. Take care to name the variables properly.

Unfortunately, it is not possible to assign a lambda to a variable using var keyword:

// causes compilation error: 
//   method reference needs an explicit target-type
var fun = MyObject::mySpecialFunction;
It is, however, possible to use the var in lambda expressions. Take a look at the example below:

boolean isThereAneedle = stringsList.stream()
  .anyMatch((@NonNull var s) -> s.equals(“needle”));
Using var in lambda arguments, we can add annotations to the arguments. 

Records
One may say Records are Java’s answer to Lombok. At least partly, that is. Record is a type designed to store some data. Let me quote a fragment of JEP 395 that describes it well: 

[…] a record acquires many standard members automatically:

A private final field for each component of the state description;
A public read accessor method for each component of the state description, with the same name and type as the component;
A public constructor, whose signature is the same as the state description, which initializes each field from the corresponding argument;
Implementations of equals and hashCode that say two records are equal if they are of the same type and contain the same state; and
An implementation of toString that includes the string representation of all the record components, with their names.
In other words, it’s roughly equivalent to Lombok’s @Value. In terms of language, it’s kind of similar to an enum. However, instead of declaring possible values, you declare the fields. Java generates some code based on that declaration and is capable of handling it in a better, optimized way. Like enum, it can’t extend or be extended by other classes, but it can implement an interface and have static fields and methods. Contrary to an enum, a record can be instantiated with the new keyword.

A record may look like this:

record BankAccount (String bankName, String accountNumber) implements HasAccountNumber {}
And this is it. Pretty short. Short is good!

Any automatically generated methods can be declared manually by the programmer. A set of constructors can be also declared. Moreover, in constructors, all fields that are definitely unassigned are implicitly assigned to their corresponding constructor parameters. It means that the assignment can be skipped entirely in the constructor!

record BankAccount (String bankName, String accountNumber) implements HasAccountNumber {
  public BankAccount { // <-- this is the constructor! no () !
    if (accountNumber == null || accountNumber.length() != 26) {
      throw new ValidationException(“Account number invalid”);
    }
    // no assignment necessary here!
  }
}
For all the details like formal grammar, notes on usage and implementation, make sure to consult the JEP 359. You could also check StackOverflow for the most upvoted questions on Java Records.

Extended switch expressions
Switch is present in a lot of languages, but over the years it got less and less useful because of the limitations it had. Other parts of Java grew, switch did not. Nowadays switch cases can be grouped much more easily and in a more readable manner (note there’s no break!) and the switch expression itself actually returns a result.

DayOfWeek dayOfWeek = LocalDate.now().getDayOfWeek();
boolean freeDay = switch (dayOfWeek) {
    case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -> false;
    case SATURDAY, SUNDAY -> true;
};
Even more can be achieved with the new yield keyword that allows returning a value from inside a code block. It’s virtually a return that works from inside a case block and sets that value as a result of its switch. It can also accept an expression instead of a single value. Let’s take a look at an example:

DayOfWeek dayOfWeek = LocalDate.now().getDayOfWeek();
boolean freeDay = switch (dayOfWeek) {
    case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -> {
      System.out.println("Work work work");
      yield false;
    }
    case SATURDAY, SUNDAY -> {
      System.out.println("Yey, a free day!");
      yield true;
    }
};
Instanceof pattern matching
While not a groundbreaking change, in my opinion, instanceof solves one of the more irritating problems with the Java language. Did you ever have to use such syntax?

if (obj instanceof MyObject) {
  MyObject myObject = (MyObject) obj;
  // … further logic
}
Now, you won’t have to. Java can now create a local variable inside the if, like this:

if (obj instanceof MyObject myObject) {
  // … the same logic
}
It is just one line removed, but it was a totally unnecessary line in terms of the code flow. Moreover, the declared variable can be used in the same if condition, like this:

if (obj instanceof MyObject myObject && myObject.isValid()) {
  // … the same logic
}
 

Are you looking for Java developers?
Schedule a call
Sealed classes
This is a tricky one to explain. Let’s start with this – did the “no default” warning in switch ever annoy you? You covered all the options that the domain accepted, but still, the warning was there. Sealed classes let you get rid of such a warning for the instanceof type checks.

If you have a hierarchy like this:

public abstract sealed class Animal
    permits Dog, Cat {
}
public final class Dog extends Animal {
}
public final class Cat extends Animal {
}
You will now be able to do this:

if (animal instanceof Dog d) {
    return d.woof();
} 
else if (animal instanceof Cat c) {
    return c.meow();
}
And you won’t get a warning. Well, let me rephrase that: if you get a warning with a similar sequence, that warning will be meaningful! And more information is always good.

I have mixed feelings about this change. Introducing a cyclic reference does not seem like a good practice. If I used this in my production code, I’d do my best to hide it somewhere deep and never show it to the outside world – I mean, never expose it through an API, not that I would be ashamed of using it in a valid situation.

TextBlocks
Declaring long strings does not often happen in Java programming, but when it does, it is tiresome and confusing. Java 13 came up with a fix for that, further improved in later releases. A multiline text block can now be declared as follows:

String myWallOfText = ”””
______         _   _           
| ___ \       | | (_)          
| |_/ / __ ___| |_ _ _   _ ___ 
|  __/ '__/ _ \ __| | | | / __|
| |  | | |  __/ |_| | |_| \__ \
\_|  |_|  \___|\__|_|\__,_|___/
”””
There is no need for escaping quotes or newlines. It is possible to escape a newline and keep the string a one-liner, like this:

String myPoem = ”””
Roses are red, violets are blue - \
Pretius makes the best software, that is always true
”””
Which is the equivalent of:

String myPoem = ”Roses are red, violets are blue - Pretius makes the best software, that still is true”.
Text blocks can be used to keep a reasonably readable json or xml template in your code. External files are still likely a better idea, but it’s still a nice option to do it in pure Java if necessary.

Better NullPointerExceptions
So, I had this chain of calls in my app once. And I think it may look familiar to you too:

company.getOwner().getAddress().getCity();
And I got an NPE that told me precisely in which line the null was encountered. Yes, it was that line. Without a debugger I couldn’t tell which object was null, or rather, which invoke operation has actually caused the problem. Now the message will be specific and it’ll tell us that the JVM “cannot invoke Person.getAddress()”. 

Actually, this is more of a JVM change than a Java one – as the bytecode analysis to build the detailed message is performed at runtime JVM – but it does appeal to programmers a lot.

New HttpClient
There are many libraries that do the same thing, but it is nice to have a proper HTTP client in Java itself. You can find a nice introduction to the new APIs in Baeldung.

New Optional.orElseThrow() method
A get() method on Optional is used to get the value under the Optional. If there is no value, this method throws an exception. Like in the code below.

MyObject myObject = myList.stream()
  .filter(MyObject::someBoolean)
  .filter((b) -> false)
  .findFirst()
  .get();
Java 10 introduced a new method in Optional, called orElseThrow(). What does it do? Exactly the same! But consider the readability change for the programmer.

MyObject myObject = myList.stream()
  .filter(MyObject::someBoolean)
  .filter((b) -> false)
  .findFirst()
  .orElseThrow();
Now, the programmer knows exactly what will happen when the object is not found. In fact, using this method is recommended instead of the simple – albeit ubiquitous – get().

Other small but nice API changes
Talk is cheap, this is the code. In bold are the new things.

// invert a Predicate, will be even shorter with static import
collection.stream()
  .filter(Predicate.not(MyObject::isEmpty))
  .collect(Collectors.toList());
// String got some new stuff too
“\nPretius\n rules\n  all!”.repeat(10).lines().
  .filter(Predictions.not(String::isBlank))
  .map(String::strip)
  .map(s -> s.indent(2))
  .collect(Collectors.toList());
// no need to have an instance of array passed as an argument
String[] myArray= aList.toArray(String[]::new);
// read and write to files quickly!
// remember to catch all the possible exceptions though
Path path = Files.writeString(myFile, "Pretius Rules All !");
String fileContent = Files.readString(path);
// .toList() on a stream()
String[] arr={"a", "b", "c"};
var list = Arrays.stream(arr).toList();
JVM 17 vs JVM 8 changes
Project Jigsaw
A screen showing a jigsaw puzzle.
Project Jigsaw turned some things on their heads, but now everything works well.
JDK 9’s Project Jigsaw significantly altered the internals of JVM. It changed both JLS and JVMS, added several JEPs (list available in the Project Jigsaw link above), and, most importantly, introduced some breaking changes, alterations that were incompatible with previous Java versions.

Java 9 modules were introduced, as an additional, highest level of jar and class organization. There’s lots of introductory content on this topic, like this one on Baeldung or these slides from Yuichi Sakuraba. 

The gains were significant, though not visible to the naked eye. So-called JAR hell is no more (have you been there? I was… and it was really a hell), though a module hell is now a possibility.

From the point of view of a typical programmer, these changes are now almost invisible. Only the biggest and the most complex projects may somehow be impacted. New versions of virtually all commonly used libraries adhere to the new rules and take them into account internally.

Garbage Collectors
As of Java 9, the G1 is the default garbage collector. It reduces the pause times in comparison with the Parallel GC, though it may have lower throughput overall. It has undergone some changes since it was made default, including the ability to return unused committed memory to the OS (JEP 346).

A ZGC garbage collector has been introduced in Java 11 and has reached product state in Java 15 (JEP 377). It aims to reduce the pauses even further. As of Java 13, it’s also capable of returning unused committed memory to the OS (JEP 351).

A Shenandoah GC has been introduced in JDK 14 and has reached product state in Java 15 (JEP 379). It aims to keep the pause times low and independent of the heap size.

Note that in Java 8 you had much fewer options, and if you did not change your GC manually, you still used the Parallel GC. Simply switching to Java 17 may cause your application to work faster and have more consistent method run times. Switching to, then unavailable, ZGC or Shenandoah may give even better results.

Finally, there’s a new No-Op Garbage Collector available (JEP 318), though it’s an experimental feature. This garbage collector does not actually do any work – thus allowing you to precisely measure your application’s memory usage. Useful, if you want to keep your memory operations throughput as low as possible.

If you want to learn more about available options, I recommend reading a great series of articles by Marko Topolnik that compares the GCs. 

Container awareness
In case you didn’t know, there was a time that Java was unaware that it was running in a container. It didn’t take into account the memory restrictions of a container and read available system memory instead. So, when you had a machine with 16 GB of RAM, set your container’s max memory to 1 GB, and had a Java application running on it, then often the application would fail as it would try to allocate more memory than was available on the container. A nice article from Carlos Sanchez explains this in more detail.

These problems are in the past now. As of Java 10, the container integration is enabled by default. However, this may not be a noticeable improvement for you, as the same change was introduced in Java 8 update 131, though it required enabling experimental options and using -XX:+UseCGroupMemoryLimitForHeap. 

PS: It’s often a good idea to specify the max memory for Java using an -Xmx parameter. The problem does not appear in such cases.

CDS Archives
In an effort to make the JVM start faster, the CDS Archives have undergone some changes in the time that passed since the Java 8 release. Starting from JDK 12, creating CDS Archives during the build process is enabled by default (JEP 341). An enhancement in JDK 13 (JEP 350) allowed the archives to be updated after each application run.

A great article from Nicolai Parlog demonstrates how to use this feature to improve startup time for your application.

Java Flight Recorder and Java Mission Control
Java Flight Recorder (JEP 328) allows monitoring and profiling of a running Java application at a low (target 1%) performance cost. Java Mission Control allows ingesting and visualizing JFR data. See Baeldung’s tutorial to get a general idea of how to use it and what one can get from it. 

Should you migrate from Java 8 to Java 17?
To keep it short: yes, you should. If you have a large, high-load enterprise application and still use Java 8, you will definitely see better performance, faster startup time, lower memory footprint after migrating. Programmers working on that application should also be happier, as there are many improvements to the language itself.

The cost of doing so, however, is difficult to estimate and varies greatly depending on used application servers, libraries, and the complexity of the application itself (or rather the number of low-level features it uses/reimplements).

If your applications are microservices, it’s likely that all you will need to do is to change the base docker image to 17-alpine, code version in maven to 17, and everything will work just fine. Some frameworks or library updates may come in handy (but you’re doing them periodically anyway, right?).

All popular servers and frameworks have the Java 9’s Jigsaw Project support by now. It’s production-grade, it has been heavily tested, and bugfixed over the years. Many products offer migration guides or at least extensive release notes for the Java 9-compatible version. See a nice article from OSGI or some release notes for Wildfly 15 mentioning modules support.

If you use Spring Boot as your framework, there are some articles available with migration tips, like this one in the spring-boot wiki, this one on Baeldung, and yet another one on DZone. There’s also an interesting case study from infoq. Migrating Spring Boot 1 to Spring Boot 2 is a different topic, it might be worth considering too. There’s a tutorial from Spring Boot itself, and an article on Baeldung covering this topic.

If your application didn’t have custom classloaders, didn’t heavily rely on Unsafe, lots of sun.misc or sun.security usages – you’re likely to be fine. Consult this article from JDEP on Java Dependency Analysis Tool, for some changes you may have to make.

Some things were removed from Java since version 8, including Nashorn JS Engine, Pack200 APIs and Tools, Solaris/Sparc ports, AOT and JIT compilers, Java EE, and Corba modules. Some things still remain but are deprecated for removal, like Applet API or Security Manager. And since there are good reasons for their removal, you should reconsider their use in your application anyway.

I asked our Project technical Leaders at Pretius about their experiences with Java 8 to Java 9+ migrations. There were several examples and none were problematic. Here, a library did not work and had to be updated;, there, some additional library or configuration was required but overall, it wasn’t a bad experience at all.

Conclusion
Java 17 LTS is out now, and it’s going to be supported for years to come. On the other hand, Java 8’s support is going to run out in just a few months. It’s certainly a solid reason to consider moving to the newest version of Java. In this article, I covered the most important language and JVM changes between versions 8 and 17 (including some information about the Java 8 to Java 9+ migration process), so that it’s easier to understand the differences between them – as well as to assess the risks and gains of migration.

If you happen to be a decision maker in your company, the question to ask yourself is this: will there ever be “a good time” to leave Java 8 behind? Some money will always have to be spent, some time will always have to be consumed and the risk of some additional work that needs to be done will always exist. If there’s never “a good time”, this particular window – the few months between Java 17 release and Java 8 losing Premier Support – is likely the best there’s ever going to be.
            14.17.1.2

        14.17.2

    14.18  Java version 18
    14.19  Java version 19
    14.20  Java version 20
    14.21  Java version 21
    14.22  Java version 22
    14.23  Java version 23
    14.24  Java version 24
    14.25  Java version 25
    14.26  Java version 26
    14.27  Java version 27
    14.28  Java version 28
    14.29  Java version 29
    14.30  Java version 30
    14.31  Java version 31
    14.32  Java version 32
    14.33  Java version 33
    14.34  Java version 34
    14.35  Java version 35
    14.36  Java version 36
    14.37  Java version 37
    14.38  Java version 38
    14.39  Java version 39
    14.40  Java version 40
    14.41  Java version 41


15. multithreading, tags: multithreading

    15.1 Multithreading in java , threading, threads, parallelization, concurrency , tags: Multithreading in java , threading, threads, parallelization, concurrency 

        15.1.1 https://www.geeksforgeeks.org/java-multithreading-tutorial/

            15.1.1.1 Using Thread Class
Java provides Thread class to achieve programming invoking threads thereby some major methods of thread class are shown below in the tabular format with which we deal frequently along the action performed by them.
Methods	Action Performed
isDaemon()	It checks whether the current thread is daemon or not
start()	It starts the execution of the thread
run()	It does the executable operations statements in the body of this method over a thread
sleep()	It is a static method that puts the thread to sleep for a certain time been passed as an argument to it
wait()	It sets the thread back in waiting state.
notify()	It gives out a notification to one thread that is in waiting state
notifyAll()	It gives out a notification to all the thread in the waiting state
setDaemon()	It set the current thread as Daemon thread
stop()	It is used to stop the execution of the thread
resume()	It is used to resume the suspended thread.
Pre-requisites: Basic syntax and methods to deal with threads
Now let us come up with how to set the name of the thread. By default, threads are named thread-0, thread-1, and so on. But there is also a method that is often used  as setName() method. Also corresponding to it there is a method getName() which returns the name of the thread be it default or settled already by using setName() method. The syntax is as follows:
Syntax: 
(a) Returning the name of the thread
public String getName() ;
(b) Changing the name of the thread
 public void setName(String name);
My demo, 2 worker threads:
Run:
[i500695@WYLQRXL9LQ:2023-02-16 18:49:00:~/work/code/java/multithreading:]2013$ javac HelloWorldThreads.java 
[i500695@WYLQRXL9LQ:2023-02-16 18:50:01:~/work/code/java/multithreading:]2014$ java HelloWorldThreads
Thread 1 crunching input 0
Thread 2 crunching input 0
Thread 1 crunching input 1
Thread 2 crunching input 1
Thread 1 crunching input 2
Thread 2 crunching input 2
Thread 2 crunching input 3
Thread 1 crunching input 3
Thread 1 crunching input 4
…

Code:
[i500695@WYLQRXL9LQ:2023-02-16 18:51:47:~/work/code/java/multithreading:]2017$ for f in *.java; do echo $f; cat $f;echo "";  echo "------"; done
HelloWorldThreads.java

public class HelloWorldThreads extends Thread{

    public static void main(String[] args) {
        Thread1 myThread1 = new Thread1();
        Thread2 myThread2 = new Thread2();
        myThread1.start();
        myThread2.start();
        
    }
}
------
Thread1.java
public class Thread1 extends Thread{

    public void run(){
        for (int i=0; i<100; i++) {
            System.out.println(String.format("Thread 1 crunching input %d", i));
        }
    }

}
------
Thread2.java
public class Thread2 extends Thread{

    public void run(){
        for (int i=0; i<100; i++) {
            System.out.println(String.format("Thread 2 crunching input %d", i));
        }
    }

}
------


            15.1.1.2 Using Runnable Interface 
Another way to achieve multithreading in java is via the Runnable interface. Here as we have seen in the above example in way 1 where Thread class is extended. Here Runnable interface being a functional interface has its own run() method. Here classes are implemented to the Runnable interface. Later on, in the main() method, Runnable reference is created for the classes that are implemented in order to make bondage with Thread class to run our own corresponding run() methods. Further, while creating an object of Thread class we will pass these references in Thread class as its constructor allows only one runnable object, which is passed as a parameter while creating Thread class object in a main() method. Now lastly just like what we did in Thread class, start() method is invoked over the runnable object who are now already linked with Thread class objects, so the execution begins for our run() methods in case of Runnable interface. It is shown in the program below as follows:
[i500695@WYLQRXL9LQ:2023-02-19 18:10:09:~/work/code/java/multithreading:]2026$ cat RunnableThread1.java RunnableThread2.java  HelloWorldThreads.java 
public class RunnableThread1 implements Runnable{

    public void run(){
        for (int i=0; i<4; i++) {
            System.out.println(String.format("RunnableThread 1 crunching input %d", i));
        }
    }

}public class RunnableThread2 implements Runnable{

    public void run(){
        for (int i=0; i<4; i++) {
            System.out.println(String.format("RunnableThread 2 crunching input %d", i));
        }
    }
}
public class HelloWorldThreads extends Thread{

    public static void main(String[] args) {
        System.out.println("Running two threads to crunch some numbers...");
        Thread1 myThread1 = new Thread1();
        Thread2 myThread2 = new Thread2();
        myThread1.start();
        myThread2.start();

        System.out.println("Running two more threads to crunch some more numbers, this time the threads CTOR is passed a Runnable implementing class...");
        RunnableThread1 rt1 = new RunnableThread1();
        RunnableThread2 rt2 = new RunnableThread2();
        Thread t1 = new Thread(rt1);
        Thread t2 = new Thread(rt2);
        t1.start();
        t2.start();

    }
}


            15.1.1.3 Thread methods

                15.1.1.3.1  Sleep
[i500695@WYLQRXL9LQ:2023-02-19 18:10:19:~/work/code/java/multithreading:]2027$ cat Thread1.java Thread2.java 
public class Thread1 extends Thread {

    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(String.format("Thread 1 crunching input %d", i));
            try {
                Thread.sleep(1000); // slow thread
            }
            catch (Exception e) {
                System.out.println("Caught exception "+ e);
            }
        }
    }

}public class Thread2 extends Thread{

    public void run(){
        for (int i=0; i<100; i++) {
            System.out.println(String.format("Thread 2 crunching input %d", i));
            try {
                Thread.sleep(200); //faster thread, sleeps 200 ms
            }
            catch (Exception e) {
                System.out.println("Caught exception " + e);
            }
        }
    }

}
Observe T2 faster than T1:
[i500695@WYLQRXL9LQ:2023-02-19 18:29:28:~/work/code/java/multithreading:]2029$ java HelloWorldThreads
Running two threads to crunch some numbers...
Running two more threads to crunch some more numbers, this time the threads CTOR is passed a Runnable implementing class...
RunnableThread 1 crunching input 0
Thread 1 crunching input 0
Thread 2 crunching input 0
RunnableThread 2 crunching input 0
RunnableThread 2 crunching input 1
RunnableThread 1 crunching input 1
RunnableThread 2 crunching input 2
RunnableThread 1 crunching input 2
RunnableThread 1 crunching input 3
RunnableThread 2 crunching input 3
Thread 2 crunching input 1
Thread 2 crunching input 2
Thread 2 crunching input 3
Thread 2 crunching input 4
Thread 1 crunching input 1
Thread 2 crunching input 5
Thread 2 crunching input 6
Thread 2 crunching input 7
Thread 2 crunching input 8
Thread 2 crunching input 9
Thread 1 crunching input 2
Thread 2 crunching input 10
Thread 2 crunching input 11
Thread 2 crunching input 12
...

For more information see: https://www.geeksforgeeks.org/thread-sleep-method-in-java-with-examples/
in short, calling it from main thread will put it to sleep.
ex:
// Java Program for sleeping the main thread.
import java.io.*;
import java.lang.Thread;
class GFG {
	public static void main(String[] args)
	{
		// we can also use throws keyword followed by
		// exception name for throwing the exception
	
		try {
			for (int i = 0; i < 5; i++) {
			
				// it will sleep the main thread for 1 sec
				// ,each time the for loop runs
				Thread.sleep(1000);
			
				// printing the value of the variable
				System.out.println(i);
			}
		}
		catch (Exception e) {
		
			// catching the exception
			System.out.println(e);
		}
	}
}

Calling it from thread will sleep the thread. 
Example, see above code. 

Flavors:
|1. public static void sleep(long millis)throws InterruptedException
|2. public static void sleep(long millis)throws IllegalArguementException
|3. public static void sleep(long millis, int nanos)throws InterruptedException
|4. public static void sleep(long millis, int nanos)throws  IllegalArguementException

                15.1.1.3.2 start
https://www.geeksforgeeks.org/start-function-multithreading-java/
 Java threads are typically created using one of the two methods : (1) Extending thread class. (2) Implementing Runnable
In both the approaches, we override the run() function, but we start a thread by calling the start() function. So why don’t we directly call the overridden run() function? Why always the start function is called to execute a thread?
What happens when a function is called? 
When a function is called the following operations take place: 
 

The arguments are evaluated.
A new stack frame is pushed into the call stack.
Parameters are initialized.
Method body is executed.
Value is returned and current stack frame is popped from the call stack.
The purpose of start() is to create a separate call stack for the thread. A separate call stack is created by it, and then run() is called by JVM.
Let us see what happens if we don’t call start() and rather call run() directly. We have modified the first program discussed here. 

demo:
Illustrate that we cant call run directly. We need to call start to allocate a new call stuck and JVM calls run()
Thread 1 crunching input 0
Thread 1 crunching input 1
Thread 1 crunching input 2
Thread 1 crunching input 3
Thread 1 crunching input 4
Thread 1 crunching input 5
Thread 1 crunching input 6

code:
public class Thread3 extends Thread {

    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(String.format("Thread %d crunching input %d", Thread.currentThread().getId(), i));
            try {
                Thread.sleep(1000); // slow thread
            }
            catch (Exception e) {
                System.out.println("Caught exception "+ e);
            }
        }
    }

}public class HelloWorldThreads extends Thread{

    public static void main(String[] args) {
        System.out.println("Running two threads to crunch some numbers...");
        Thread1 myThread1 = new Thread1();
        Thread2 myThread2 = new Thread2();
        myThread1.start();
        myThread2.start();

        System.out.println("Running two more threads to crunch some more numbers, this time the threads CTOR is passed a Runnable implementing class...");
        RunnableThread1 rt1 = new RunnableThread1();
        RunnableThread2 rt2 = new RunnableThread2();
        Thread t1 = new Thread(rt1);
        Thread t2 = new Thread(rt2);
        t1.start();
        t2.start();

        System.out.println("Illustrate that we cant call run directly. We need to call start to allocate a new call stuck and JVM calls run()");
        Thread3 myThread3 = new Thread3();
        myThread3.run();
    }
}
                15.1.1.3.3 suspend 
https://www.geeksforgeeks.org/how-to-temporarily-stop-a-thread-in-java/
The suspend() method of thread class puts the thread from running to waiting state. This method is employed if you would like to prevent the thread execution and begin it again when a particular event occurs. This method allows a thread to temporarily cease execution. The suspended thread is often resumed using the resume() method. If the present thread cannot modify the target thread then it’ll throw Security Exception.
Note: suspend() method is deprecated in the latest Java version.

code:
// Java program to demonstrate suspend() method
// of Thread class

import java.io.*;

class GFG extends Thread {
	public void run()
	{
		for (int i = 1; i < 5; i++) {
			try {
				
				// thread to sleep for 500 milliseconds
				sleep(5);
				System.out.println(
					"Currently running - "
					+ Thread.currentThread().getName());
			}
			catch (InterruptedException e) {
				System.out.println(e);
			}
			System.out.println(i);
		}
	}
	public static void main(String args[])
	{
		// creating three threads
		GFG t1 = new GFG();
		GFG t2 = new GFG();
		GFG t3 = new GFG();
		
		// call run() method
		t1.start();
		t2.start();
		
		// suspend t2 thread
		t2.suspend();
		
		// call run() method
		t3.start();
	}
}

Note: Thread t2 can be resumed by resume() method.
t2.resume() 

                15.1.1.3.4 stop

A thread is automatically destroyed when the run() method has completed. But it might be required to kill/stop a thread before it has completed its life cycle. Previously, methods suspend(), resume() and stop() were used to manage the execution of threads. But these methods were deprecated by Java 2 because they could result in system failures. Modern ways to suspend/stop a thread are by using a boolean flag and Thread.interrupt() method.
 

Using a boolean flag: We can define a boolean variable which is used for stopping/killing threads say ‘exit’. Whenever we want to stop a thread, the ‘exit’ variable will be set to true. 

 Using a volatile boolean flag: We can also use a volatile boolean flag to make our code thread safe. A volatile variable is directly stored in the main memory so that threads cannot have locally cached values of it. A situation may arise when more than one threads are accessing the same variable and the changes made by one might not be visible to other threads. In such a situation, we can use a volatile boolean flag. 

demo issue:
[i500695@WYLQRXL9LQ:2023-02-23 17:43:16:~/work/code/java/multithreading/killing_threads:]2032$ cat  KillThreadWrongWay.java
public class KillThreadWrongWay{

    static boolean exit = false; // We need static scope since main is static
                                 // and we want to access exit from main
                                 
    public static void main(String[] args) {
        System.out.println("Main thread starting...");
        new Thread() {
            public void run(){
                System.out.println("In thread run()");
                while (!exit){
                    System.out.println("Thread working. waiting for exit flag to finish");
                }
                System.out.println("Thread got exit flag. quitting.");
            }
        }.start();

        try {
            Thread.sleep(500);
        } catch(InterruptedException e){
            e.printStackTrace();
        }
        
        exit = true;
        System.out.println("Exiting main thread");
    }

}
[i500695@WYLQRXL9LQ:2023-02-23 17:43:22:~/work/code/java/multithreading/killing_threads:]2033$ javac KillThreadWrongWay.java
[i500695@WYLQRXL9LQ:2023-02-23 17:43:03:~/work/code/java/multithreading/killing_threads:]2032$ java KillThreadWrongWay
Thread working. waiting for exit flag to finish
Thread working. waiting for exit flag to finish
Thread working. waiting for exit flag to finish
...

Fix:
[i500695@WYLQRXL9LQ:2023-02-23 17:46:03:~/work/code/java/multithreading/killing_threads:]2040$ cat KillThread.java
public class KillThread{

    static volatile boolean exit = false; // We need static scope since main is static
                                 // and we want to access exit from main
                                 
    public static void main(String[] args) {
        System.out.println("Main thread starting...");
        new Thread() {
            public void run(){
                System.out.println("In thread run()");
                while (!exit){
                    System.out.println("Thread working. waiting for exit flag to finish");
                }
                System.out.println("Thread got exit flag. quitting.");
            }
        }.start();

        try {
            Thread.sleep(500);
        } catch(InterruptedException e){
            e.printStackTrace();
        }
        
        exit = true;
        System.out.println("Exiting main thread");
    }

}

Using Thread.interrupt() method: Whenever an interrupt has been sent to a thread, it should stop whatever task it is performing. It is very likely that whenever the thread receives an interrupt, it is to be terminated. This action can be done by using the interrupt() method. Whenever Thread.interrupt() is called, it sets a flag known as the interrupt status to true. This means that the thread has to stop performing further execution. The default value of this flag is false.
// Java program to illustrate
// stopping a thread
// using the interrupt() method

class MyThread implements Runnable {

	Thread t;

	MyThread()
	{
		t = new Thread(this);
		System.out.println("New thread: " + t);
		t.start(); // Starting the thread
	}

	// execution of thread starts from run() method
	public void run()
	{
		while (!Thread.interrupted()) {
			System.out.println("Thread is running");
		}
		System.out.println("Thread has stopped.");
	}
}

// Main class
public class Main {
	public static void main(String args[])
	{
		// creating objects t1 of MyThread
		MyThread t1 = new MyThread();

		try {
			Thread.sleep(1);

			// t1 is an object of MyThread
			// which has an object t
			// which is of type Thread
			t1.t.interrupt();

			Thread.sleep(5);
		}
		catch (InterruptedException e) {
			System.out.println("Caught:" + e);
		}
		System.out.println("Exiting the main Thread");
	}
}

source: https://www.geeksforgeeks.org/killing-threads-in-java/


                15.1.1.3.5 wait()
The wait() and join() methods are used to pause the current thread. The wait() is used in with notify() and notifyAll() methods, but join() is used in Java to wait until one thread finishes its execution. wait() is mainly used for shared resources, a thread notifies other waiting thread when a resource becomes free. On the other hand join() is used for waiting a thread to die.
Similarities between wait() and join()

The method wait() and join() both are used to pause the current thread in Java.
Both wait() and join() can be interrupted by calling interrupt() method in Java.
Both wait() and join() are a non-static method.
Both wait() and join() are overloaded in Java. wait() and join() which without timeout as well as accepts a timeout parameter.
Difference between wait() and join() method

Most obvious difference, both are present different packages, the wait() method is declared in java.lang.Object class while join() is declared in java.lang.Thread class.
The wait() is used for inter-thread communication while the join() is used for adding sequencing between multiple threads, one thread starts execution after first thread execution finished.
We can start a waiting thread (went into this state by calling wait()) by using notify() and notifyAll() method but we can not break the waiting imposed by join without unless or interruption the thread on which join is called has execution finished.
One most important difference between wait() and join() that is wait() must be called from synchronized context i.e. synchronized block or method otherwise it will throw IllegalMonitorStateException but On the other hand, we can call join() method with and without synchronized context in Java.

                15.1.1.3.6 notify, notifyAll 
The notify() and notifyAll() methods with wait() methods are used for communication between the threads. A thread that goes into waiting for state by calling the wait() method will be in waiting for the state until any other thread calls either notify() or notifyAll() method on the same object. 

notify(): The notify() method is defined in the Object class, which is Java’s top-level class. It’s used to wake up only one thread that’s waiting for an object, and that thread then begins execution. The thread class notify() method is used to wake up a single thread.

notifyAll(): The notifyAll() wakes up all threads that are waiting on this object’s monitor. A thread waits on an object’s monitor by calling one of the wait methods. The awakened threads will not be able to proceed until the current thread relinquishes the lock on this object.




Now the question is both notify() and notifyAll() the method is used to give notification to the waiting thread, then what is the difference between them or where we should use notify() method and where we should go for the notifyAll() method? 

Sr. No.	Key	notify()	notifyAll() 
1	Notifications	In the case of the multiThreading, notify() method sends the notification to only one thread among the multiple waiting threads which are waiting for the send lock.	While notifyAll() methods in the same context send notifications to all waiting threads instead of a single thread.
2	Thread identifications	As in the case of notify() method, the notification is sent to a single thread among the multiple waiting threads, so it is sure that which of those waiting threads is going to receive the lock.	On the other hand, notifyAll() sends a notification to all waiting threads. Hence, it is not clear which of the thread is going to receive the lock.
3	Risk factor	In the case of notify() method, the risk of thread missing is high as notification is sent only a single thread, and if it misses that, then no other thread would get a notification and hence the lock.	While in the case of notifyAll(), it sends a notification to all the waiting threads, and hence if any thread misses the notification, there are other threads to do the job. Hence the risk is less.
4	Performance	Memory and CPU drain is less in notify() method as compared to notifyAll() method as notification is sent to single one thread so performance is better as compared to notifyAll().	On the other hand, the cost of no notification is dropped and notification is sent to all waiting threads, the memory and CPU drain is more as compared to notify() and hence performance of notifyAll() is lesser.
5	Interchangeable	In the case of the notify() method, only a single thread is in the picture hence no concept of thread Interchangeable is possible.	While we should go for notifyAll() if all your waiting threads are interchangeable (the order they wake up doesn’t matter).
Let’s understand how the notify() method behaves:

Java
// Java program to illustrate the
// behaviour of notify() method
class Geek1 extends Thread {
    public void run()
    {
        synchronized (this)
        {
            System.out.println(
                Thread.currentThread().getName()
                + "...starts");
            try {
                this.wait();
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(
                Thread.currentThread().getName()
                + "...notified");
        }
    }
}
class Geek2 extends Thread {
    Geek1 geeks1;
   
    Geek2(Geek1 geeks1){
      this.geeks1 = geeks1;
    }
   
    public void run()
    {
        synchronized (this.geeks1)
        {
            System.out.println(
                Thread.currentThread().getName()
                + "...starts");
 
            try {
                this.geeks1.wait();
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(
                Thread.currentThread().getName()
                + "...notified");
        }
    }
}
class Geek3 extends Thread {
    Geek1 geeks1;
    Geek3(Geek1 geeks1) { this.geeks1 = geeks1; }
    public void run()
    {
        synchronized (this.geeks1)
        {
            System.out.println(
                Thread.currentThread().getName()
                + "...starts");
            this.geeks1.notify();
            System.out.println(
                Thread.currentThread().getName()
                + "...notified");
        }
    }
}
class MainClass {
    public static void main(String[] args)
        throws InterruptedException
    {
 
        Geek1 geeks1 = new Geek1();
        Geek2 geeks2 = new Geek2(geeks1);
        Geek3 geeks3 = new Geek3(geeks1);
        Thread t1 = new Thread(geeks1, "Thread-1");
        Thread t2 = new Thread(geeks2, "Thread-2");
        Thread t3 = new Thread(geeks3, "Thread-3");
        t1.start();
        t2.start();
        Thread.sleep(100);
        t3.start();
    }
}
Output: 

Thread-1...start
Thread-2...starts
Thread-3...starts
Thread-3...notified
Thread-1...notified
Lets understand how notifyAll() method behaves:  

Java

// Java program to illustrate the
// behavior of notifyAll() method
 
class Geek1 extends Thread {
    public void run()
    {
        synchronized (this)
        {
            System.out.println(
                Thread.currentThread().getName()
                + "...starts");
            try {
                this.wait();
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(
                Thread.currentThread().getName()
                + "...notified");
        }
    }
}
class Geek2 extends Thread {
    Geek1 geeks1;
   
    Geek2(Geek1 geeks1){
      this.geeks1 = geeks1;
    }
   
    public void run()
    {
        synchronized (this.geeks1)
        {
            System.out.println(
                Thread.currentThread().getName()
                + "...starts");
 
            try {
                this.geeks1.wait();
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(
                Thread.currentThread().getName()
                + "...notified");
        }
    }
}
class Geek3 extends Thread {
    Geek1 geeks1;
    Geek3(Geek1 geeks1) { this.geeks1 = geeks1; }
    public void run()
    {
        synchronized (this.geeks1)
        {
            System.out.println(
                Thread.currentThread().getName()
                + "...starts");
 
            this.geeks1.notifyAll();
            System.out.println(
                Thread.currentThread().getName()
                + "...notified");
        }
    }
}
class MainClass {
    public static void main(String[] args)
        throws InterruptedException
    {
 
        Geek1 geeks1 = new Geek1();
        Geek2 geeks2 = new Geek2(geeks1);
        Geek3 geeks3 = new Geek3(geeks1);
        Thread t1 = new Thread(geeks1, "Thread-1");
        Thread t2 = new Thread(geeks2, "Thread-2");
        Thread t3 = new Thread(geeks3, "Thread-3");
        t1.start();
        t2.start();
        Thread.sleep(100);
        t3.start();
    }
}
Output
Thread-1...starts
Thread-2...starts
Thread-3...starts
Thread-3...notified
Thread-1...notified
Thread-2...notified
When to Use notify() method and notifyAll()?
In the case of mutually exclusive locking, only one of the waiting threads can do something useful after being notified (in this case acquire the lock). In such a case, you would rather use notify(). Properly implemented, you could use notifyAll() in this situation as well, but you would unnecessarily wake threads that can’t do anything anyway.
In some cases, all waiting threads can take useful action once the wait finishes. An example would be a set of threads waiting for a certain task to finish; once the task has finished, all waiting threads can continue with their business. In such a case you would use notifyAll() to wake up all waiting threads at the same time.
Applications of notify() and notifyAll()
A maintenance operation on a shared resource, where multiple threads are waiting for the operation to complete before accessing the resource; for these, we should go for notifyAll().
Let’s say we have a producer thread and a consumer thread. Each “packet” produced by the producer should be consumed by a consumer. The consumer puts something in a queue and then calls notify().
We want to have a notification when a lengthy process has finished. You want a beep and a screen update. The process performs notifyAll() to notify both the beeping thread and the screen-update-thread.

                15.1.1.3.7
            15.1.1.4 Priorities in threads, , tags: Priorities in threads
Impact of Thread Priorities
Thread priorities influence how the JVM schedules and allocates resources to threads. A higher priority thread has a better chance of being executed before lower priority threads. However, it’s important to remember that priority alone does not determine the order of thread execution. The JVM’s thread scheduler takes other factors, such as the underlying operating system and thread states, into account.

Thread priority is useful when certain threads require more processing time or have critical tasks. By giving such threads a higher priority, developers can ensure that they receive enough CPU time to complete their tasks on time. It is not, however, recommended to rely solely on thread priorities to achieve specific execution behavior.
Priorities in threads is a concept where each thread is having a priority which is represented by numbers ranging from 1 to 10. 

The default priority is set to 5 as excepted.
Minimum priority is set to 0.
Maximum priority is set to 10.
Here 3 constants are defined in it namely as follows:

public static int NORM_PRIORITY
public static int MIN_PRIORITY
public static int MAX_PRIORITY
Let us discuss it with an example to get how internally the work is getting executed. Here we will be using the knowledge gathered above as follows:

We will use currentThread() method to get the name of the current thread. User can also use setName() method if he/she wants to make names of thread as per choice for understanding purposes.
getName() method will be used to get the name of the thread.

demo and code:
[i500695@WYLQRXL9LQ:2023-02-23 18:09:07:~/work/code/java/multithreading/thread_priorities:]2069$ cat ThreadPriority.java 
// Java Program to illustrate Priority Threads
// Case 1: No priority is assigned (Default priority)

// Importing input output thread class
import java.io.*;
// Importing Thread class from java.util package
import java.util.*;

// Class 1
// Helper Class (Our thread class)
class MyThread extends Thread {

	public void run()
	{

		// Printing the current running thread via getName()
		// method using currentThread() method
		System.out.println("Running Thread : "
						+ currentThread().getName());

		// Print and display the priority of current thread
		// via currentThread() using getPriority() method
		System.out.println("Running Thread Priority : "
						+ currentThread().getPriority());
	}
}

class DefaultPriority {

	// Main driver method
	public static void main(String[] args)
	{

		// Creating objects of MyThread(above class)
		// in the main() method
		MyThread t1 = new MyThread();
		MyThread t2 = new MyThread();

		t1.start();
		t2.start();
	}
}

class NormalPriority {

	// Main driver method
	public static void main(String[] args)
	{

		// Creating objects of MyThread(above class)
		// in the main() method
		MyThread t1 = new MyThread();
		MyThread t2 = new MyThread();

       // Setting priority to thread via NORM_PRIORITY
        // which set priority to 5 as default thread
        t1.setPriority(Thread.NORM_PRIORITY);
        t2.setPriority(Thread.NORM_PRIORITY);

		// Case 1: Default Priority no setting
		t1.start();
		t2.start();
	}
}

class MinPriority {

	// Main driver method
	public static void main(String[] args)
	{

		// Creating objects of MyThread(above class)
		// in the main() method
		MyThread t1 = new MyThread();
		MyThread t2 = new MyThread();

       // Setting priority to thread via NORM_PRIORITY
        // which set priority to 5 as default thread
        t1.setPriority(Thread.MIN_PRIORITY);
        t2.setPriority(Thread.MIN_PRIORITY);

		// Case 1: Default Priority no setting
		t1.start();
		t2.start();
	}
}

class MaxPriority {

	// Main driver method
	public static void main(String[] args)
	{

		// Creating objects of MyThread(above class)
		// in the main() method
		MyThread t1 = new MyThread();
		MyThread t2 = new MyThread();

       // Setting priority to thread via NORM_PRIORITY
        // which set priority to 5 as default thread
        t1.setPriority(Thread.MAX_PRIORITY);
        t2.setPriority(Thread.MAX_PRIORITY);

		// Case 1: Default Priority no setting
		t1.start();
		t2.start();
	}
}

[i500695@WYLQRXL9LQ:2023-02-23 18:09:19:~/work/code/java/multithreading/thread_priorities:]2070$ for f in *.class; do echo "Running ${f%.*}"; java "${f%.*}" ; echo "---------"; done
Running DefaultPriority
Running Thread : Thread-0
Running Thread : Thread-1
Running Thread Priority : 5
Running Thread Priority : 5
---------
Running MaxPriority
Running Thread : Thread-0
Running Thread : Thread-1
Running Thread Priority : 10
Running Thread Priority : 10
---------
Running MinPriority
Running Thread : Thread-0
Running Thread : Thread-1
Running Thread Priority : 1
Running Thread Priority : 1
---------
Running MyThread
Error: Main method not found in class MyThread, please define the main method as:
   public static void main(String[] args)
or a JavaFX application class must extend javafx.application.Application
---------
Running NormalPriority
Running Thread : Thread-0
Running Thread : Thread-1
Running Thread Priority : 5
Running Thread Priority : 5
---------

            15.1.1.5 daemon threads

            15.1.1.6
        15.1.2 Thread lifecycle and state-machine
https://www.geeksforgeeks.org/lifecycle-and-states-of-a-thread-in-java/
A thread in Java at any point of time exists in any one of the following states. A thread lies only in one of the shown states at any instant: 
New
Runnable
Blocked
Waiting
Timed Waiting
Terminated
Life Cycle of a thread
New Thread: When a new thread is created, it is in the new state. The thread has not yet started to run when the thread is in this state. When a thread lies in the new state, its code is yet to be run and hasn’t started to execute.
Runnable State: A thread that is ready to run is moved to a runnable state. In this state, a thread might actually be running or it might be ready to run at any instant of time. It is the responsibility of the thread scheduler to give the thread, time to run. 
A multi-threaded program allocates a fixed amount of time to each individual thread. Each and every thread runs for a short while and then pauses and relinquishes the CPU to another thread so that other threads can get a chance to run. When this happens, all such threads that are ready to run, waiting for the CPU and the currently running thread lie in a runnable state.
Blocked/Waiting state: When a thread is temporarily inactive, then it’s in one of the following states: 
Blocked
Waiting
Timed Waiting: A thread lies in a timed waiting state when it calls a method with a time-out parameter. A thread lies in this state until the timeout is completed or until a notification is received. For example, when a thread calls sleep or a conditional wait, it is moved to a timed waiting state.
Terminated State: A thread terminates because of either of the following reasons: 
Because it exits normally. This happens when the code of the thread has been entirely executed by the program.
Because there occurred some unusual erroneous event, like segmentation fault or an unhandled exception.

| 1. New 
| Declaration: public static final Thread.State NEW
| Description: Thread state for a thread that has not yet started. 
| 
| 2. Runnable 
| Declaration: public static final Thread.State RUNNABLE
| Description: Thread state for a runnable thread. A thread in the runnable state is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as a processor. 
| 
| 3. Blocked 
| Declaration: public static final Thread.State BLOCKED
| Description: Thread state for a thread blocked waiting for a monitor lock. A thread in the blocked state is waiting for a monitor lock to enter a synchronized block/method or reenter a synchronized block/method after calling Object.wait(). 
| 4. Waiting 
| Declaration: public static final Thread.State WAITING
| Description: Thread state for a waiting thread. A thread is in the waiting state due to calling one of the following methods: 
| 
| Object.wait with no timeout
| Thread.join with no timeout
| LockSupport.park
| 5. Timed Waiting 
| Declaration: public static final Thread.State TIMED_WAITING
| Description: Thread state for a waiting thread with a specified waiting time. A thread is in the timed waiting state due to calling one of the following methods with a specified positive waiting time: 
| 
| Thread.sleep
| Object.wait with timeout
| Thread.join with timeout
| LockSupport.parkNanos
| LockSupport.parkUntil
| 6. Terminated 
| Declaration: public static final Thread.State TERMINATED

demo:
[i500695@WYLQRXL9LQ:2023-02-21 18:19:18:~/work/code/java/multithreading/thread_states_demo:]2011$ cat Test.java 
// Java program to demonstrate thread states
class thread implements Runnable {
	public void run()
	{
		// moving thread2 to timed waiting state
		try {
			Thread.sleep(1500);
		}
		catch (InterruptedException e) {
			e.printStackTrace();
		}

		System.out.println(
			"State of thread1 while it called join() method on thread2 -"
			+ Test.thread1.getState());
		try {
			Thread.sleep(200);
		}
		catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}

public class Test implements Runnable {
	public static Thread thread1;
	public static Test obj;

	public static void main(String[] args)
	{
		obj = new Test();
		thread1 = new Thread(obj);

		// thread1 created and is currently in the NEW
		// state.
		System.out.println(
			"State of thread1 after creating it - "
			+ thread1.getState());
		thread1.start();

		// thread1 moved to Runnable state
		System.out.println(
			"State of thread1 after calling .start() method on it - "
			+ thread1.getState());
	}

	public void run()
	{
		thread myThread = new thread();
		Thread thread2 = new Thread(myThread);

		// thread1 created and is currently in the NEW
		// state.
		System.out.println(
			"State of thread2 after creating it - "
			+ thread2.getState());
		thread2.start();

		// thread2 moved to Runnable state
		System.out.println(
			"State of thread2 after calling .start() method on it - "
			+ thread2.getState());

		// moving thread1 to timed waiting state
		try {
			// moving thread1 to timed waiting state
			Thread.sleep(200);
		}
		catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println(
			"State of thread2 after calling .sleep() method on it - "
			+ thread2.getState());

		try {
			// waiting for thread2 to die
			thread2.join();
		}
		catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println(
			"State of thread2 when it has finished it's execution - "
			+ thread2.getState());
	}
}

[i500695@WYLQRXL9LQ:2023-02-21 18:19:32:~/work/code/java/multithreading/thread_states_demo:]2012$ javac Test.java
[i500695@WYLQRXL9LQ:2023-02-21 18:19:36:~/work/code/java/multithreading/thread_states_demo:]2013$ java Test
State of thread1 after creating it - NEW
State of thread1 after calling .start() method on it - RUNNABLE
State of thread2 after creating it - NEW
State of thread2 after calling .start() method on it - RUNNABLE
State of thread2 after calling .sleep() method on it - TIMED_WAITING
State of thread1 while it called join() method on thread2 -WAITING
State of thread2 when it has finished it's execution - TERMINATED

        15.1.3
    15.2


16. jackson

    16.1 highlevel overview
Jackson is a popular Java library for working with JSON data. It provides functionality to serialize Java objects to JSON and deserialize JSON to Java objects.

The core component of the Jackson library is the `ObjectMapper` class, which provides methods for converting between Java objects and JSON data. Here's an example of how to use `ObjectMapper` to serialize a Java object to JSON:

```java
import com.fasterxml.jackson.databind.ObjectMapper;

public class MyObject {
    private String name;
    private int age;
    
    public MyObject(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Getters and setters
    
    public static void main(String[] args) throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        MyObject obj = new MyObject("John Doe", 30);
        String json = mapper.writeValueAsString(obj);
        System.out.println(json); // {"name":"John Doe","age":30}
    }
}
```

In this example, we create a `MyObject` class with a name and age field, and then create an instance of this class with the name "John Doe" and age 30. We then create an `ObjectMapper` instance and use the `writeValueAsString()` method to serialize the `MyObject` instance to a JSON string.

Here's another example that demonstrates how to deserialize a JSON string to a Java object:

```java
import com.fasterxml.jackson.databind.ObjectMapper;

public class MyObject {
    private String name;
    private int age;
    
    public MyObject() {
        // Default constructor required for deserialization
    }
    
    // Getters and setters
    
    public static void main(String[] args) throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        String json = "{\"name\":\"John Doe\",\"age\":30}";
        MyObject obj = mapper.readValue(json, MyObject.class);
        System.out.println(obj.getName()); // John Doe
        System.out.println(obj.getAge()); // 30
    }
}
```

In this example, we create a `MyObject` class with a default constructor (required for deserialization), and then create a JSON string representing a `MyObject` instance with the name "John Doe" and age 30. We then use the `readValue()` method of `ObjectMapper` to deserialize the JSON string to a `MyObject` instance.

Jackson also provides many annotations for customizing the serialization and deserialization of Java objects, such as `@JsonProperty`, `@JsonFormat`, and `@JsonIgnore`. You can find more information on how to use Jackson in the official documentation: https://github.com/FasterXML/jackson-databind.

    16.2 ObjectMapper 

        16.2.1 valueToTree
`ObjectMapper`'s `valueToTree` method is used to convert a Java object to a JSON tree representation. The resulting `JsonNode` object can be used to traverse and manipulate the JSON structure programmatically, which can be useful in certain scenarios.

Here's an example of using `ObjectMapper` to convert a Java object to a `JsonNode` object:

```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class MyObject {
    private String name;
    private int age;
    
    public MyObject(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Getters and setters
    
    public static void main(String[] args) throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        MyObject obj = new MyObject("John Doe", 30);
        JsonNode jsonNode = mapper.valueToTree(obj);
        System.out.println(jsonNode.toString()); // {"name":"John Doe","age":30}
    }
}
```

In this example, we create a `MyObject` class with a name and age field, and then create an instance of this class with the name "John Doe" and age 30. We then create an `ObjectMapper` instance and use the `valueToTree()` method to convert the `MyObject` instance to a `JsonNode` object. Finally, we print the JSON string representation of the `JsonNode` object.

The resulting `JsonNode` object can be further manipulated using the `JsonNode` API to extract or modify specific parts of the JSON structure. This can be useful when working with complex JSON structures that require programmatic manipulation.

        16.2.2 JsonNode traversal
Sure! Here's an example of how to traverse a `JsonNode` object using Jackson's `JsonNode` API:

```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class JsonTraversalExample {
    public static void main(String[] args) throws Exception {
        String json = "{\"name\":\"John Doe\",\"age\":30,\"address\":{\"street\":\"123 Main St\",\"city\":\"Anytown\",\"state\":\"CA\",\"zip\":\"12345\"}}";
        ObjectMapper mapper = new ObjectMapper();
        JsonNode rootNode = mapper.readTree(json);
        JsonNode nameNode = rootNode.get("name");
        String name = nameNode.asText();
        System.out.println("Name: " + name); // Name: John Doe
        JsonNode ageNode = rootNode.get("age");
        int age = ageNode.asInt();
        System.out.println("Age: " + age); // Age: 30
        JsonNode addressNode = rootNode.get("address");
        String street = addressNode.get("street").asText();
        System.out.println("Street: " + street); // Street: 123 Main St
        String city = addressNode.get("city").asText();
        System.out.println("City: " + city); // City: Anytown
        String state = addressNode.get("state").asText();
        System.out.println("State: " + state); // State: CA
        String zip = addressNode.get("zip").asText();
        System.out.println("ZIP: " + zip); // ZIP: 12345
    }
}
```

In this example, we create a JSON string representing a person with a name, age, and address, and then parse it into a `JsonNode` object using `ObjectMapper`'s `readTree()` method. We then use the `get()` method of the `JsonNode` object to retrieve specific parts of the JSON structure, and use the `asText()` and `asInt()` methods to convert the values to Java strings and integers, respectively.

To traverse the nested `address` object, we first retrieve the `address` node using `get()`, and then use `get()` again to retrieve the individual fields within the `address` object.

Note that `JsonNode` also provides other methods for traversing JSON structures, such as `iterator()` and `fields()`, which can be useful in certain scenarios.

        16.2.3 DFS traversal of JsonNode
To perform a depth-first traversal of a `JsonNode` object using recursion, you can create a helper method that takes a `JsonNode` object as a parameter and then recursively calls itself for each child node. Here's an example:

```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class JsonDfsTraversalExample {
    public static void main(String[] args) throws Exception {
        String json = "{\"name\":\"John Doe\",\"age\":30,\"address\":{\"street\":\"123 Main St\",\"city\":\"Anytown\",\"state\":\"CA\",\"zip\":\"12345\"}}";
        ObjectMapper mapper = new ObjectMapper();
        JsonNode rootNode = mapper.readTree(json);
        traverse(rootNode);
    }
    
    private static void traverse(JsonNode node) {
        if (node.isObject()) {
            System.out.println("Object: " + node);
            node.fields().forEachRemaining(entry -> traverse(entry.getValue()));
        } else if (node.isArray()) {
            System.out.println("Array: " + node);
            node.elements().forEachRemaining(JsonDfsTraversalExample::traverse);
        } else if (node.isValueNode()) {
            System.out.println("Value: " + node);
        } else if (node.isNull()) {
            System.out.println("Null: " + node);
        }
    }
}
```

In this example, we create a `traverse()` method that takes a `JsonNode` object as a parameter. If the node is an object, we print a message indicating that it's an object and then iterate over its fields using the `fields()` method, calling `traverse()` recursively for each value in the field. If the node is an array, we print a message indicating that it's an array and then iterate over its elements using the `elements()` method, again calling `traverse()` recursively for each element. If the node is a value node, we print a message indicating that it's a value node, and if it's null, we print a message indicating that it's null.

When we call the `traverse()` method on the root node of a JSON structure, it will recursively traverse the entire structure in a depth-first manner, printing out messages for each node type as it encounters them.

        16.2.4 jackson stdSerialize

            16.2.4.1 GPT
In the Jackson library for Java, the `StdSerializer` class is a standard implementation of the `JsonSerializer` interface. It is part of Jackson's serialization framework, which allows you to customize the serialization process for specific types.

Here's an overview of the `StdSerializer` class:

### `StdSerializer` Class:

- **Package:** `com.fasterxml.jackson.databind.ser.std`
- **Extends:** `JsonSerializer<T>`
- **Implements:** `ResolvableSerializer` (for handling cyclic dependencies)

#### Key Methods:

1. **`serialize` Method:**
   - This method is responsible for converting an object of type `T` into a JSON representation.
   - You need to implement this method to define how the object should be serialized.

   ```java
   @Override
   public void serialize(T value, JsonGenerator gen, SerializerProvider provider) throws IOException {
       // Custom serialization logic here
   }
   ```

2. **`handledType` Method:**
   - Specifies the type of objects that this serializer can handle. It's a method from the `JsonSerializer` interface.

   ```java
   @Override
   public Class<T> handledType() {
       return ...; // Return the class type that this serializer can handle
   }
   ```

3. **`serializeWithType` Method:**
   - If the serialized type information is included in the JSON output, this method is used to add that information.

   ```java
   @Override
   public void serializeWithType(T value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {
       // Custom serialization with type information
   }
   ```

### Example:

Let's say you want to create a custom serializer for a `Person` class:

```java
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.jsontype.TypeSerializer;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;

import java.io.IOException;

public class PersonSerializer extends StdSerializer<Person> {

    public PersonSerializer() {
        super(Person.class);
    }

    @Override
    public void serialize(Person person, JsonGenerator gen, SerializerProvider provider) throws IOException {
        // Custom serialization logic for Person class
        gen.writeStartObject();
        gen.writeStringField("name", person.getName());
        gen.writeNumberField("age", person.getAge());
        // Add other fields as needed
        gen.writeEndObject();
    }
}
```

In this example, `PersonSerializer` extends `StdSerializer<Person>`, and the `serialize` method is overridden to provide custom serialization logic for the `Person` class. You can then register this serializer with your Jackson `ObjectMapper` to use it during serialization.

```java
ObjectMapper objectMapper = new ObjectMapper();
SimpleModule module = new SimpleModule();
module.addSerializer(Person.class, new PersonSerializer());
objectMapper.registerModule(module);

String json = objectMapper.writeValueAsString(personInstance);
```

By creating custom serializers, you can tailor the JSON representation of your objects according to your application's needs.

            16.2.4.2

        16.2.5
    16.3
17. java collections, tags:  java collections

    17.1 java Collections.singletonList
`Collections.singletonList()` is a method in the Java Collections Framework that returns an immutable list containing only the specified object. 

Here is an example of how to use `Collections.singletonList()`:

```java
import java.util.Collections;
import java.util.List;

public class SingletonListExample {
    public static void main(String[] args) {
        String fruit = "apple";
        List<String> fruitList = Collections.singletonList(fruit);
        System.out.println(fruitList);
    }
}
```

In this example, we use `Collections.singletonList()` to create an immutable list containing a single string object `"apple"`. The `singletonList()` method takes a single argument that represents the object to be added to the list. 

The resulting list is immutable, meaning that its size cannot be modified, and any attempt to add or remove elements will result in an `UnsupportedOperationException`. This method is useful when you need to pass a single object as a list to a method or API that expects a list as input.

Yes, here are a few other use cases where `Collections.singletonList()` can be helpful:

|1. As a return value: If you have a method that returns a list containing a single element, using `Collections.singletonList()` can be a clean and simple way to create and return that list.
|
|2. As a parameter: If you have a method that takes a list as a parameter, and you only need to pass a single element to that method, you can use `Collections.singletonList()` to create a temporary list containing that element.
|
|3. As an optimization: If you have a situation where you know that a list will only ever contain a single element, using `Collections.singletonList()` can be more memory-efficient than creating a regular ArrayList or other list implementation.

Overall, `Collections.singletonList()` is a useful utility method that can simplify your code and make it more efficient in certain situations where you only need to work with a list containing a single element.

    17.2

18.  chatgpt, 
        1.1.2 Key concepts / files <URL:#tn=        1.1.2 Key concepts / files>
            1.1.2.1 dependency Injection <URL:#tn=            1.1.2.1 dependency Injection>
            1.1.2.2 Spring configuration file, usually spring.xml <URL:#tn=            1.1.2.2 Spring configuration file, usually spring.xml>
            1.1.2.3 main application <URL:#tn=            1.1.2.3 main application>
                1.1.2.3.1 example of BeanFactory, ApplicationContext, AbstractApplicationContext, getting beans and wiring to HTTP requests <URL:#tn=                1.1.2.3.1 example of BeanFactory, ApplicationContext, AbstractApplicationContext, getting beans and wiring to HTTP requests>
                1.1.2.3.2 <URL:#tn=                1.1.2.3.2>
            1.1.2.4 beans <URL:#tn=            1.1.2.4 beans>
                1.1.2.4.1 example, simple bean <URL:#tn=                1.1.2.4.1 example, simple bean>
                1.1.2.4.2 Bean that is ApplicationContext and name aware , also has init and cleanup callbacks <URL:#tn=                1.1.2.4.2 Bean that is ApplicationContext and name aware , also has init and cleanup callbacks>
                1.1.2.4.3 Bean that is InitializingBean and DisposableBean, also contains a container member field <URL:#tn=                1.1.2.4.3 Bean that is InitializingBean and DisposableBean, also contains a container member field>
                1.1.2.4.4 BeanPostProcessor <URL:#tn=                1.1.2.4.4 BeanPostProcessor>
                1.1.2.4.5 code to interface example <URL:#tn=                1.1.2.4.5 code to interface example>
                    1.1.2.4.5.1  animal interface <URL:#tn=                    1.1.2.4.5.1  animal interface>
                    1.1.2.4.5.2 animals: cat, dog, horse <URL:#tn=                    1.1.2.4.5.2 animals: cat, dog, horse>
                1.1.2.4.6 Internationalization and application resources <URL:#tn=                1.1.2.4.6 Internationalization and application resources>
                1.1.2.4.7 Events <URL:#tn=                1.1.2.4.7 Events>
                    1.1.2.4.7.1 GeneralEvtListener <URL:#tn=                    1.1.2.4.7.1 GeneralEvtListener>
                    1.1.2.4.7.2 ToStringEvt <URL:#tn=                    1.1.2.4.7.2 ToStringEvt>
                    1.1.2.4.7.3 publish custom events <URL:#tn=                    1.1.2.4.7.3 publish custom events>
                    1.1.2.4.7.4 <URL:#tn=                    1.1.2.4.7.4>
                1.1.2.4.8 <URL:#tn=                1.1.2.4.8>
            1.1.2.5 <URL:#tn=            1.1.2.5>
        1.1.3 <URL:#tn=        1.1.3>
    1.2 database <URL:#tn=    1.2 database>
        1.2.1  database connections <URL:#tn=        1.2.1  database connections>
            1.2.1.1    database connections pools <URL:#tn=            1.2.1.1    database connections pools>
                1.2.1.1.1    Apache Commons DBCP <URL:#tn=                1.2.1.1.1    Apache Commons DBCP>
                1.2.1.1.2 HikariCP <URL:#tn=                1.2.1.1.2 HikariCP>
                1.2.1.1.3 C3PO <URL:#tn=                1.2.1.1.3 C3PO>
                1.2.1.1.4 A Simple Implementation <URL:#tn=                1.2.1.1.4 A Simple Implementation>
            1.2.1.2 <URL:#tn=            1.2.1.2>
        1.2.2 <URL:#tn=        1.2.2>
    1.3 chatgpt <URL:#tn=    1.3 chatgpt>
        1.3.1  q. what is spring-boot-starter-webflux <URL:#tn=        1.3.1  q. what is spring-boot-starter-webflux>
        1.3.2 q. explain the basics of setting up a reactive web application using <URL:#tn=        1.3.2 q. explain the basics of setting up a reactive web application using>
        1.3.3 q. example using maven and postgress DB <URL:#tn=        1.3.3 q. example using maven and postgress DB>
        1.3.4 use JDBC instead of JPA <URL:#tn=        1.3.4 use JDBC instead of JPA>
        1.3.5 explain java org.springframework.context.annotation.Profile <URL:#tn=        1.3.5 explain java org.springframework.context.annotation.Profile>
1. Defining Profiles: Profiles are defined using the `@Profile` annotation at the class or method level. You can assign one or more profile names to the annotation. For example: <URL:#tn=1. Defining Profiles: Profiles are defined using the `@Profile` annotation at the class or method level. You can assign one or more profile names to the annotation. For example:>
2. Activating Profiles: Profiles can be activated in various ways, depending on your application's setup. Here are a few common methods: <URL:#tn=2. Activating Profiles: Profiles can be activated in various ways, depending on your application's setup. Here are a few common methods:>
3. Conditional Bean Creation: The `@Profile` annotation can also be used to conditionally create beans based on profiles. By annotating a bean definition or `@Configuration` class with `@Profile`, the bean(s) will only be created when the specified profile is active. For example: <URL:#tn=3. Conditional Bean Creation: The `@Profile` annotation can also be used to conditionally create beans based on profiles. By annotating a bean definition or `@Configuration` class with `@Profile`, the bean(s) will only be created when the specified profile is active. For example:>
        1.3.6 is there a spring framework DataSource class or interface <URL:#tn=        1.3.6 is there a spring framework DataSource class or interface>
        1.3.7 explain org.springframework.jdbc.core.JdbcTemplate <URL:#tn=        1.3.7 explain org.springframework.jdbc.core.JdbcTemplate>
1. Database Operations: The `JdbcTemplate` class provides methods for executing various types of SQL operations, such as updates, inserts, deletes, and selects. These methods handle all the necessary details, including acquiring and releasing database connections, executing SQL statements, binding parameters, and processing result sets. <URL:#tn=1. Database Operations: The `JdbcTemplate` class provides methods for executing various types of SQL operations, such as updates, inserts, deletes, and selects. These methods handle all the necessary details, including acquiring and releasing database connections, executing SQL statements, binding parameters, and processing result sets.>
2. Exception Handling: The `JdbcTemplate` class handles SQLExceptions that occur during database operations and wraps them in more meaningful and standardized Spring exceptions, such as `DataAccessException`. This simplifies error handling and allows for consistent exception handling across different database operations. <URL:#tn=2. Exception Handling: The `JdbcTemplate` class handles SQLExceptions that occur during database operations and wraps them in more meaningful and standardized Spring exceptions, such as `DataAccessException`. This simplifies error handling and allows for consistent exception handling across different database operations.>
3. PreparedStatement Creation: The `JdbcTemplate` class can create `PreparedStatement` objects for executing SQL statements with bound parameters. It automatically handles the preparation of the statement and sets the appropriate parameter values based on the provided arguments. <URL:#tn=3. PreparedStatement Creation: The `JdbcTemplate` class can create `PreparedStatement` objects for executing SQL statements with bound parameters. It automatically handles the preparation of the statement and sets the appropriate parameter values based on the provided arguments.>
4. ResultSet Processing: The `JdbcTemplate` class provides methods for processing `ResultSet` objects returned from SELECT queries. It simplifies the process of iterating over the result set, extracting data, and mapping it to Java objects or data structures. <URL:#tn=4. ResultSet Processing: The `JdbcTemplate` class provides methods for processing `ResultSet` objects returned from SELECT queries. It simplifies the process of iterating over the result set, extracting data, and mapping it to Java objects or data structures.>
5. Batch Updates: The `JdbcTemplate` class supports batch updates, allowing you to execute multiple SQL statements as a single batch. This can significantly improve performance when dealing with multiple database operations. <URL:#tn=5. Batch Updates: The `JdbcTemplate` class supports batch updates, allowing you to execute multiple SQL statements as a single batch. This can significantly improve performance when dealing with multiple database operations.>
6. Exception Translation: The `JdbcTemplate` class integrates with Spring's `SQLExceptionTranslator` mechanism, which translates database-specific SQL exceptions into Spring's standardized `DataAccessException` hierarchy. This helps to abstract away the database-specific exception handling and provides a consistent exception model. <URL:#tn=6. Exception Translation: The `JdbcTemplate` class integrates with Spring's `SQLExceptionTranslator` mechanism, which translates database-specific SQL exceptions into Spring's standardized `DataAccessException` hierarchy. This helps to abstract away the database-specific exception handling and provides a consistent exception model.>
7. Callback Mechanism: The `JdbcTemplate` class supports a callback mechanism through the use of various callback interfaces. These interfaces, such as `PreparedStatementCreator`, `PreparedStatementSetter`, `RowMapper`, and others, allow you to customize the behavior of database operations and provide more flexibility in handling SQL statements and result sets. <URL:#tn=7. Callback Mechanism: The `JdbcTemplate` class supports a callback mechanism through the use of various callback interfaces. These interfaces, such as `PreparedStatementCreator`, `PreparedStatementSetter`, `RowMapper`, and others, allow you to customize the behavior of database operations and provide more flexibility in handling SQL statements and result sets.>
        1.3.8 explain  org.springframework.beans.factory.annotation.Qualifier <URL:#tn=        1.3.8 explain  org.springframework.beans.factory.annotation.Qualifier>
1. Define Bean Qualifiers: In the application context, when defining multiple beans of the same type, you can assign a unique qualifier value using the `@Qualifier` annotation. For example: <URL:#tn=1. Define Bean Qualifiers: In the application context, when defining multiple beans of the same type, you can assign a unique qualifier value using the `@Qualifier` annotation. For example:>
2. Use `@Qualifier` for Dependency Injection: In the dependent class or component, you can use the `@Qualifier` annotation along with `@Autowired` to specify which bean should be injected. For example: <URL:#tn=2. Use `@Qualifier` for Dependency Injection: In the dependent class or component, you can use the `@Qualifier` annotation along with `@Autowired` to specify which bean should be injected. For example:>
        1.3.9 <URL:#tn=        1.3.9>
    1.4 <URL:#tn=    1.4>
2. general <URL:#tn=2. general>
    2.1. manipulate jar files. <URL:#tn=    2.1. manipulate jar files.>
    2.2. remote debug java application. <URL:#tn=    2.2. remote debug java application.>
    2.3. deploy JSP pages to web container. <URL:#tn=    2.3. deploy JSP pages to web container.>
    2.4. Tomcat <URL:#tn=    2.4. Tomcat>
	1. listen port and shutdown port are defined in server.xml. <URL:#tn=	1. listen port and shutdown port are defined in server.xml.>
    2.5.  Reverse engineer. <URL:#tn=    2.5.  Reverse engineer.>
    2.6 Set java version, toggle java versions, switch jdk versions <URL:#tn=    2.6 Set java version, toggle java versions, switch jdk versions>
        2.6.1 mac, OS X <URL:#tn=        2.6.1 mac, OS X>
    14.0.2, x86_64:	"OpenJDK 14.0.2"	/Library/Java/JavaVirtualMachines/openjdk-14.0.2.jdk/Contents/Home <URL:#tn=    14.0.2, x86_64:	"OpenJDK 14.0.2"	/Library/Java/JavaVirtualMachines/openjdk-14.0.2.jdk/Contents/Home>
    10.0.2, x86_64:	"Java SE 10.0.2"	/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home <URL:#tn=    10.0.2, x86_64:	"Java SE 10.0.2"	/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home>
    1.8.0_265, x86_64:	"AdoptOpenJDK 8"	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home <URL:#tn=    1.8.0_265, x86_64:	"AdoptOpenJDK 8"	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home>
    1.8.0_241, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home <URL:#tn=    1.8.0_241, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home>
    13.0.1, x86_64:	"OpenJDK 13.0.1"	/Library/Java/JavaVirtualMachines/openjdk-13.0.1.jdk/Contents/Home <URL:#tn=    13.0.1, x86_64:	"OpenJDK 13.0.1"	/Library/Java/JavaVirtualMachines/openjdk-13.0.1.jdk/Contents/Home>
    10.0.2, x86_64:	"Java SE 10.0.2"	/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home <URL:#tn=    10.0.2, x86_64:	"Java SE 10.0.2"	/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home>
    1.8.0_241, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home <URL:#tn=    1.8.0_241, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home>
    1.8.0_232, x86_64:	"AdoptOpenJDK 8"	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home <URL:#tn=    1.8.0_232, x86_64:	"AdoptOpenJDK 8"	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home>
    2.7 chatgpt <URL:#tn=    2.7 chatgpt>
        2.7.1 java set data structure, tags: java set data structure <URL:#tn=        2.7.1 java set data structure, tags: java set data structure>
        2.7.2  java Files  , tags: java Files <URL:#tn=        2.7.2  java Files  , tags: java Files>
        2.7.3 java Objects.requireNonNull , tags: java Objects.requireNonNull <URL:#tn=        2.7.3 java Objects.requireNonNull , tags: java Objects.requireNonNull>
        2.7.4 java File.toPath() , tags: java File.toPath() <URL:#tn=        2.7.4 java File.toPath() , tags: java File.toPath()>
        2.7.5 java use class loader to read a file that contains a sql statement and then run it on a PG DB , tags: java use class loader to read a file that contains a sql statement and then run it on a PG DB <URL:#tn=        2.7.5 java use class loader to read a file that contains a sql statement and then run it on a PG DB , tags: java use class loader to read a file that contains a sql statement and then run it on a PG DB>
        2.7.6 java org.stringtemplate.v4.ST , tags: java org.stringtemplate.v4.ST <URL:#tn=        2.7.6 java org.stringtemplate.v4.ST , tags: java org.stringtemplate.v4.ST>
        2.7.7 java StringBuilder, tags: java StringBuilder <URL:#tn=        2.7.7 java StringBuilder, tags: java StringBuilder>
        2.7.8 java jackson @JsonCreator annotation, tags: java jackson @JsonCreator annotation <URL:#tn=        2.7.8 java jackson @JsonCreator annotation, tags: java jackson @JsonCreator annotation>
        2.7.9 how to read an array property into a List<String> in a @JsonCreator annotated class constructor, tags: how to read an array property into a List<String> in a @JsonCreator annotated class constructor <URL:#tn=        2.7.9 how to read an array property into a List<String> in a @JsonCreator annotated class constructor, tags: how to read an array property into a List<String> in a @JsonCreator annotated class constructor>
        2.7.10 <URL:#tn=        2.7.10>
    2.8 <URL:#tn=    2.8>
3.  IDE, intellij <URL:#tn=3.  IDE, intellij>
    3.1   VIM plugin <URL:#tn=    3.1   VIM plugin>
    3.2   Code generation <URL:#tn=    3.2   Code generation>
        3.2.1    generate getters and setters <URL:#tn=        3.2.1    generate getters and setters>
        3.2.2 <URL:#tn=        3.2.2>
    3.3 <URL:#tn=    3.3>
4. Build java projects <URL:#tn=4. Build java projects>
    4.1 Build java projects with maven <URL:#tn=    4.1 Build java projects with maven>
        4.1.1 Build java projects with maven spring tutorial <URL:#tn=        4.1.1 Build java projects with maven spring tutorial>
        4.1.2 maven <URL:#tn=        4.1.2 maven>
            4.1.2.1 getting started <URL:#tn=            4.1.2.1 getting started>
                4.1.2.1.1  Create project <URL:#tn=                4.1.2.1.1  Create project>
                4.1.2.1.2 . Main phases <URL:#tn=                4.1.2.1.2 . Main phases>
                4.1.2.1.3 . Maven phase commands(Project Build Commands) <URL:#tn=                4.1.2.1.3 . Maven phase commands(Project Build Commands)>
                4.1.2.1.4  Skip running tests <URL:#tn=                4.1.2.1.4  Skip running tests>
                4.1.2.1.5 Project Site Generation <URL:#tn=                4.1.2.1.5 Project Site Generation>
                4.1.2.1.6 Code quality analysis <URL:#tn=                4.1.2.1.6 Code quality analysis>
                4.1.2.1.7 Code coverage reporting <URL:#tn=                4.1.2.1.7 Code coverage reporting>
                4.1.2.1.8 Dependency Management <URL:#tn=                4.1.2.1.8 Dependency Management>
                4.1.2.1.9 Getting Help <URL:#tn=                4.1.2.1.9 Getting Help>
            4.1.2.2 commonly use CLI <URL:#tn=            4.1.2.2 commonly use CLI>
            4.1.2.3 <URL:#tn=            4.1.2.3>
        4.1.3 <URL:#tn=        4.1.3>
    4.2 <URL:#tn=    4.2>
5. Java basics <URL:#tn=5. Java basics>
    5.1 <URL:#tn=    5.1>
6. JDK 5,6 <URL:#tn=6. JDK 5,6>
	6.1 Annotations <URL:#tn=	6.1 Annotations>
		6.1.1 Description <URL:#tn=		6.1.1 Description>
		6.1.2 Usage <URL:#tn=		6.1.2 Usage>
			6.1.2.1 Documentation <URL:#tn=			6.1.2.1 Documentation>
			6.1.2.2 Annotation Processing <URL:#tn=			6.1.2.2 Annotation Processing>
	6.2 Enums, enumaration <URL:#tn=	6.2 Enums, enumaration>
    6.3 Nested Classes <URL:#tn=    6.3 Nested Classes>
	6.2.1 Inner Class Example <URL:#tn=	6.2.1 Inner Class Example>
    6.4 generics <URL:#tn=    6.4 generics>
	6.4.1 Article: Using and Programming Generics in J2SE 5.0 <URL:#tn=	6.4.1 Article: Using and Programming Generics in J2SE 5.0>
   1. "? extends Type": Denotes a family of subtypes of type Type. This is the most useful wildcard <URL:#tn=   1. "? extends Type": Denotes a family of subtypes of type Type. This is the most useful wildcard>
   2. "? super Type": Denotes a family of supertypes of type Type <URL:#tn=   2. "? super Type": Denotes a family of supertypes of type Type>
   3. "?": Denotes the set of all types or any <URL:#tn=   3. "?": Denotes the set of all types or any>
7. Install <URL:#tn=7. Install>
	7.1 Linux <URL:#tn=	7.1 Linux>
	7.2 Mac. tags: install java MAC OSX <URL:#tn=	7.2 Mac. tags: install java MAC OSX>
	7.3 <URL:#tn=	7.3>
8. Code Snipplets <URL:#tn=8. Code Snipplets>
	8.1 Encoding, utf-8, utf-16 <URL:#tn=	8.1 Encoding, utf-8, utf-16>
	8.2 <URL:#tn=	8.2>
9. Cookbook <URL:#tn=9. Cookbook>
	9.1  Files <URL:#tn=	9.1  Files>
		9.1.1   read file content java <URL:#tn=		9.1.1   read file content java>
			9.1.1.1   Reading and writing text files <URL:#tn=			9.1.1.1   Reading and writing text files>
			9.1.1.2 BufferedReader <URL:#tn=			9.1.1.2 BufferedReader>
			9.1.1.3 <URL:#tn=			9.1.1.3>
		9.1.2 Edit files <URL:#tn=		9.1.2 Edit files>
			9.1.2.1 Java – Edit File Example, Modify File java <URL:#tn=			9.1.2.1 Java – Edit File Example, Modify File java>
			9.1.2.2 <URL:#tn=			9.1.2.2>
		9.1.3 <URL:#tn=		9.1.3>
	9.2 <URL:#tn=	9.2>
10. IDEs <URL:#tn=10. IDEs>
	10.1 Eclipse <URL:#tn=	10.1 Eclipse>
		10.1.1 Quick references <URL:#tn=		10.1.1 Quick references>
			10.1.1.1 official <URL:#tn=			10.1.1.1 official>
			10.1.1.2 <URL:#tn=			10.1.1.2>
		10.1.2 FAQ <URL:#tn=		10.1.2 FAQ>
			10.1.2.1 error log <URL:#tn=			10.1.2.1 error log>
			10.1.2.2 java.lang.UnsatisfiedLinkError: Cannot load 32-bit SWT libraries on 64-bit JVM <URL:#tn=			10.1.2.2 java.lang.UnsatisfiedLinkError: Cannot load 32-bit SWT libraries on 64-bit JVM>
			10.1.2.3 <URL:#tn=			10.1.2.3>
		10.1.3 <URL:#tn=		10.1.3>
	10.2 <URL:#tn=	10.2>
11. Server side programming <URL:#tn=11. Server side programming>
	11.1 Servlet <URL:#tn=	11.1 Servlet>
		11.1.1 Basic example & walkthrough <URL:#tn=		11.1.1 Basic example & walkthrough>
			11.1.1.1 Eclipse <URL:#tn=			11.1.1.1 Eclipse>
			11.1.1.2 <URL:#tn=			11.1.1.2>
		11.1.2 <URL:#tn=		11.1.2>
	11.2 <URL:#tn=	11.2>
12. My snippets, examples, demos <URL:#tn=12. My snippets, examples, demos>
    12.1 Performance tests <URL:#tn=    12.1 Performance tests>
        12.1.1 HashMap vs array contains <URL:#tn=        12.1.1 HashMap vs array contains>
        12.1.2 <URL:#tn=        12.1.2>
    12.2 <URL:#tn=    12.2>
13.  Memory Management <URL:#tn=13.  Memory Management>
    13.1  memsize equivalent - How to Get the Size of an Object <URL:#tn=    13.1  memsize equivalent - How to Get the Size of an Object>
        13.1.1  https://www.baeldung.com/java-size-of-object <URL:#tn=        13.1.1  https://www.baeldung.com/java-size-of-object>
2. Memory Consumption in Java <URL:#tn=2. Memory Consumption in Java>
3.2. Example Class <URL:#tn=3.2. Example Class>
        13.1.2 <URL:#tn=        13.1.2>
    13.2 <URL:#tn=    13.2>
14. Java versions main features and tools, tags: Java versions main features and tools, tags: versions main features and tools <URL:#tn=14. Java versions main features and tools, tags: Java versions main features and tools, tags: versions main features and tools>
    14.1   Java version 1 <URL:#tn=    14.1   Java version 1>
    14.2   Java version 2 <URL:#tn=    14.2   Java version 2>
    14.3   Java version 3 <URL:#tn=    14.3   Java version 3>
    14.4   Java version 4 <URL:#tn=    14.4   Java version 4>
    14.5   Java version 5 <URL:#tn=    14.5   Java version 5>
    14.6   Java version 6 <URL:#tn=    14.6   Java version 6>
    14.7   Java version 7 <URL:#tn=    14.7   Java version 7>
    14.8   Java version 8 <URL:#tn=    14.8   Java version 8>
        14.8.1    functional interfaces, tags: functional interfaces <URL:#tn=        14.8.1    functional interfaces, tags: functional interfaces>
          14.8.1.1    chatgpt, lambda expressions and functional interfaces <URL:#tn=          14.8.1.1    chatgpt, lambda expressions and functional interfaces>
        14.8.2 forEach <URL:#tn=        14.8.2 forEach>
        14.8.3 optional class , tags: optional class <URL:#tn=        14.8.3 optional class , tags: optional class>
        14.8.4 Default And Static Methods In Interfaces, tags: Default And Static Methods In Interfaces <URL:#tn=        14.8.4 Default And Static Methods In Interfaces, tags: Default And Static Methods In Interfaces>
        14.8.4 Java Stream API For Bulk Data Operations On Collections , tags: Java Stream API For Bulk Data Operations On Collections <URL:#tn=        14.8.4 Java Stream API For Bulk Data Operations On Collections , tags: Java Stream API For Bulk Data Operations On Collections>
        14.8.5 java data time API usage, tags: java data time API usage <URL:#tn=        14.8.5 java data time API usage, tags: java data time API usage>
            14.8.5.1 gpt <URL:#tn=            14.8.5.1 gpt>
            14.8.5.2 my demo <URL:#tn=            14.8.5.2 my demo>
            14.8.5.3 <URL:#tn=            14.8.5.3>
        14.8.6 Collection API Improvements, tags: Collection API Improvements <URL:#tn=        14.8.6 Collection API Improvements, tags: Collection API Improvements>
        14.8.7 Java IO Improvements <URL:#tn=        14.8.7 Java IO Improvements>
        14.8.8 Miscellaneous Core API Improvements <URL:#tn=        14.8.8 Miscellaneous Core API Improvements>
        14.8.9 Base64 Encode Decode <URL:#tn=        14.8.9 Base64 Encode Decode>
            14.8.9.1 GTP example <URL:#tn=            14.8.9.1 GTP example>
            14.8.9.2 my demo <URL:#tn=            14.8.9.2 my demo>
            14.8.9.3 <URL:#tn=            14.8.9.3>
        14.8.10 <URL:#tn=        14.8.10>
    14.10  Java version 9, tags: Java version 9 <URL:#tn=    14.10  Java version 9, tags: Java version 9>
        14.10.1  REPL, jshell, tags: REPL, jshell <URL:#tn=        14.10.1  REPL, jshell, tags: REPL, jshell>
        14.10.2 Factory Methods for Immutable List, Set, Map and Map.Entry, tags: Factory Methods for Immutable List <URL:#tn=        14.10.2 Factory Methods for Immutable List, Set, Map and Map.Entry, tags: Factory Methods for Immutable List>
        14.10.3 Private methods in Interfaces <URL:#tn=        14.10.3 Private methods in Interfaces>
        14.10.4 Java 9 Module System <URL:#tn=        14.10.4 Java 9 Module System>
            14.10.4.1 GPT explanation <URL:#tn=            14.10.4.1 GPT explanation>
            14.10.4.2 https://www.baeldung.com/java-9-modularity <URL:#tn=            14.10.4.2 https://www.baeldung.com/java-9-modularity>
                14.10.4.2.1 Packages <URL:#tn=                14.10.4.2.1 Packages>
                14.10.4.2.2 resources <URL:#tn=                14.10.4.2.2 resources>
                14.10.4.2.3 Module Descriptor <URL:#tn=                14.10.4.2.3 Module Descriptor>
                14.10.4.2.4 java list-modules command <URL:#tn=                14.10.4.2.4 java list-modules command>
                14.10.4.2.5 Module Types <URL:#tn=                14.10.4.2.5 Module Types>
                14.10.4.2.6 Distribution <URL:#tn=                14.10.4.2.6 Distribution>
                14.10.4.2.7 Default Modules <URL:#tn=                14.10.4.2.7 Default Modules>
                14.10.4.2.8 Module Declarations <URL:#tn=                14.10.4.2.8 Module Declarations>
                    14.10.4.2.8.1 Requires <URL:#tn=                    14.10.4.2.8.1 Requires>
                    14.10.4.2.8.2 Requires Static <URL:#tn=                    14.10.4.2.8.2 Requires Static>
                    14.10.4.2.8.3 Requires Transitive <URL:#tn=                    14.10.4.2.8.3 Requires Transitive>
                    14.10.4.2.8.4 Exports <URL:#tn=                    14.10.4.2.8.4 Exports>
                    14.10.4.2.8.5 Exports … To <URL:#tn=                    14.10.4.2.8.5 Exports … To>
                    14.10.4.2.8.6 Uses <URL:#tn=                    14.10.4.2.8.6 Uses>
                    14.10.4.2.8.7 Provides … With <URL:#tn=                    14.10.4.2.8.7 Provides … With>
                    14.10.4.2.8.8 Open <URL:#tn=                    14.10.4.2.8.8 Open>
                    14.10.4.2.8.9 Opens <URL:#tn=                    14.10.4.2.8.9 Opens>
                    14.10.4.2.8.10 Opens … To <URL:#tn=                    14.10.4.2.8.10 Opens … To>
                    14.10.4.2.8.11 <URL:#tn=                    14.10.4.2.8.11>
                14.10.4.2.9 Command Line Options <URL:#tn=                14.10.4.2.9 Command Line Options>
                14.10.4.2.10 Visibility <URL:#tn=                14.10.4.2.10 Visibility>
                14.10.4.2.11 Putting It All Together - java modules demo, tags: Putting It All Together - java modules demo <URL:#tn=                14.10.4.2.11 Putting It All Together - java modules demo, tags: Putting It All Together - java modules demo>
                    14.10.4.2.11.1 directory structure <URL:#tn=                    14.10.4.2.11.1 directory structure>
                    14.10.4.2.11.2 first module <URL:#tn=                    14.10.4.2.11.2 first module>
                    14.10.4.2.11.3 second module <URL:#tn=                    14.10.4.2.11.3 second module>
                    14.10.4.2.11.4 build <URL:#tn=                    14.10.4.2.11.4 build>
                    14.10.4.2.11.5 Run <URL:#tn=                    14.10.4.2.11.5 Run>
                    14.10.4.2.11.6 Adding a Service <URL:#tn=                    14.10.4.2.11.6 Adding a Service>
                14.10.4.2.12 Final demo structure and code <URL:#tn=                14.10.4.2.12 Final demo structure and code>
                14.10.4.2.13 Adding Modules to the Unnamed Module <URL:#tn=                14.10.4.2.13 Adding Modules to the Unnamed Module>
                14.10.4.2.14 <URL:#tn=                14.10.4.2.14>
            14.10.4.3 <URL:#tn=            14.10.4.3>
            14.10.4.4 <URL:#tn=            14.10.4.4>
        14.10.5 Process API Improvements <URL:#tn=        14.10.5 Process API Improvements>
            14.10.5.1  chatgpt <URL:#tn=            14.10.5.1  chatgpt>
            14.10.5.2 demo <URL:#tn=            14.10.5.2 demo>
            14.10.5.3  try-with-resources statement <URL:#tn=            14.10.5.3  try-with-resources statement>
                14.10.5.3.1   explanation <URL:#tn=                14.10.5.3.1   explanation>
                14.10.5.3.2 demo <URL:#tn=                14.10.5.3.2 demo>
                14.10.5.3.3 <URL:#tn=                14.10.5.3.3>
        14.10.6 CompletableFuture API Improvements in java 9 <URL:#tn=        14.10.6 CompletableFuture API Improvements in java 9>
            14.10.6.1  GPT <URL:#tn=            14.10.6.1  GPT>
            14.10.6.2 GTP demo <URL:#tn=            14.10.6.2 GTP demo>
            14.10.6.3 my demo <URL:#tn=            14.10.6.3 my demo>
            14.10.6.4 <URL:#tn=            14.10.6.4>
        14.10.7 java 9 reactive streams <URL:#tn=        14.10.7 java 9 reactive streams>
            14.10.7.1 https://www.baeldung.com/java-9-reactive-streams <URL:#tn=            14.10.7.1 https://www.baeldung.com/java-9-reactive-streams>
                14.10.7.1.1 Overview <URL:#tn=                14.10.7.1.1 Overview>
                14.10.7.1.2 Reactive API Overview <URL:#tn=                14.10.7.1.2 Reactive API Overview>
                14.10.7.1.3 Publishing and Consuming Messages <URL:#tn=                14.10.7.1.3 Publishing and Consuming Messages>
                14.10.7.1.4 <URL:#tn=                14.10.7.1.4>
            14.10.7.2 chatgpt <URL:#tn=            14.10.7.2 chatgpt>
            14.10.7.3 <URL:#tn=            14.10.7.3>
        14.10.8 Diamond Operator for Anonymous Inner Class <URL:#tn=        14.10.8 Diamond Operator for Anonymous Inner Class>
        14.10.9 Optional Class Improvements <URL:#tn=        14.10.9 Optional Class Improvements>
        14.10.10 Stream API Improvements <URL:#tn=        14.10.10 Stream API Improvements>
        14.10.11 Enhanced @Deprecated annotation <URL:#tn=        14.10.11 Enhanced @Deprecated annotation>
        14.10.12 HTTP 2 Client <URL:#tn=        14.10.12 HTTP 2 Client>
        14.10.13 Multi-Resolution Image API <URL:#tn=        14.10.13 Multi-Resolution Image API>
        14.10.14 Miscellaneous Java 9 Features <URL:#tn=        14.10.14 Miscellaneous Java 9 Features>
        14.10.15 <URL:#tn=        14.10.15>
    14.11  Java version 10, tags: Java version 10 <URL:#tn=    14.11  Java version 10, tags: Java version 10>
    14.11  Java version 11 <URL:#tn=    14.11  Java version 11>
    14.12  Java version 12 <URL:#tn=    14.12  Java version 12>
    14.13  Java version 13 <URL:#tn=    14.13  Java version 13>
    14.14  Java version 14 <URL:#tn=    14.14  Java version 14>
    14.15  Java version 15 <URL:#tn=    14.15  Java version 15>
    14.16  Java version 16 <URL:#tn=    14.16  Java version 16>
    14.17  Java version 17 <URL:#tn=    14.17  Java version 17>
        14.17.1  Java 17 vs Java 8 <URL:#tn=        14.17.1  Java 17 vs Java 8>
            14.17.1.1  https://pretius.com/blog/java-17-features/ <URL:#tn=            14.17.1.1  https://pretius.com/blog/java-17-features/>
            14.17.1.2 <URL:#tn=            14.17.1.2>
        14.17.2 <URL:#tn=        14.17.2>
    14.18  Java version 18 <URL:#tn=    14.18  Java version 18>
    14.19  Java version 19 <URL:#tn=    14.19  Java version 19>
    14.20  Java version 20 <URL:#tn=    14.20  Java version 20>
    14.21  Java version 21 <URL:#tn=    14.21  Java version 21>
    14.22  Java version 22 <URL:#tn=    14.22  Java version 22>
    14.23  Java version 23 <URL:#tn=    14.23  Java version 23>
    14.24  Java version 24 <URL:#tn=    14.24  Java version 24>
    14.25  Java version 25 <URL:#tn=    14.25  Java version 25>
    14.26  Java version 26 <URL:#tn=    14.26  Java version 26>
    14.27  Java version 27 <URL:#tn=    14.27  Java version 27>
    14.28  Java version 28 <URL:#tn=    14.28  Java version 28>
    14.29  Java version 29 <URL:#tn=    14.29  Java version 29>
    14.30  Java version 30 <URL:#tn=    14.30  Java version 30>
    14.31  Java version 31 <URL:#tn=    14.31  Java version 31>
    14.32  Java version 32 <URL:#tn=    14.32  Java version 32>
    14.33  Java version 33 <URL:#tn=    14.33  Java version 33>
    14.34  Java version 34 <URL:#tn=    14.34  Java version 34>
    14.35  Java version 35 <URL:#tn=    14.35  Java version 35>
    14.36  Java version 36 <URL:#tn=    14.36  Java version 36>
    14.37  Java version 37 <URL:#tn=    14.37  Java version 37>
    14.38  Java version 38 <URL:#tn=    14.38  Java version 38>
    14.39  Java version 39 <URL:#tn=    14.39  Java version 39>
    14.40  Java version 40 <URL:#tn=    14.40  Java version 40>
    14.41  Java version 41 <URL:#tn=    14.41  Java version 41>
15. multithreading, tags: multithreading <URL:#tn=15. multithreading, tags: multithreading>
    15.1 Multithreading in java , threading, threads, parallelization, concurrency , tags: Multithreading in java , threading, threads, parallelization, concurrency <URL:#tn=    15.1 Multithreading in java , threading, threads, parallelization, concurrency , tags: Multithreading in java , threading, threads, parallelization, concurrency>
        15.1.1 https://www.geeksforgeeks.org/java-multithreading-tutorial/ <URL:#tn=        15.1.1 https://www.geeksforgeeks.org/java-multithreading-tutorial/>
            15.1.1.1 Using Thread Class <URL:#tn=            15.1.1.1 Using Thread Class>
            15.1.1.2 Using Runnable Interface <URL:#tn=            15.1.1.2 Using Runnable Interface>
            15.1.1.3 Thread methods <URL:#tn=            15.1.1.3 Thread methods>
                15.1.1.3.1  Sleep <URL:#tn=                15.1.1.3.1  Sleep>
                15.1.1.3.2 start <URL:#tn=                15.1.1.3.2 start>
                15.1.1.3.3 suspend <URL:#tn=                15.1.1.3.3 suspend>
                15.1.1.3.4 stop <URL:#tn=                15.1.1.3.4 stop>
                15.1.1.3.5 wait() <URL:#tn=                15.1.1.3.5 wait()>
                15.1.1.3.6 notify, notifyAll <URL:#tn=                15.1.1.3.6 notify, notifyAll>
                15.1.1.3.7 <URL:#tn=                15.1.1.3.7>
            15.1.1.4 Priorities in threads, , tags: Priorities in threads <URL:#tn=            15.1.1.4 Priorities in threads, , tags: Priorities in threads>
            15.1.1.5 daemon threads <URL:#tn=            15.1.1.5 daemon threads>
            15.1.1.6 <URL:#tn=            15.1.1.6>
        15.1.2 Thread lifecycle and state-machine <URL:#tn=        15.1.2 Thread lifecycle and state-machine>
        15.1.3 <URL:#tn=        15.1.3>
    15.2 <URL:#tn=    15.2>
16. jackson <URL:#tn=16. jackson>
    16.1 highlevel overview <URL:#tn=    16.1 highlevel overview>
    16.2 ObjectMapper <URL:#tn=    16.2 ObjectMapper>
        16.2.1 valueToTree <URL:#tn=        16.2.1 valueToTree>
        16.2.2 JsonNode traversal <URL:#tn=        16.2.2 JsonNode traversal>
        16.2.3 DFS traversal of JsonNode <URL:#tn=        16.2.3 DFS traversal of JsonNode>
        16.2.4 <URL:#tn=        16.2.4>
    16.3 <URL:#tn=    16.3>
17. java collections, tags:  java collections <URL:#tn=17. java collections, tags:  java collections>
    17.1 java Collections.singletonList <URL:#tn=    17.1 java Collections.singletonList>
    17.2 <URL:#tn=    17.2>
18. <URL:#tn=18.>
.................................................END TOC..............................................

















Description: 	Java related knowledge.
Author:		Yosi Izaq.

1. spring 

    1.1 tutorial

        1.1.1  IDE, intellij

        1.1.2 Key concepts / files

            1.1.2.1 dependency Injection
decouples the dependencies between classes so that spring Framework would be responsibile for constructing required java classes (beans)

            1.1.2.2 Spring configuration file, usually spring.xml
ex:


<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"
       default-init-method="myInit" default-destroy-method="myDestroy">
    <!-- define the default init/destroy methods for all beans. if they are implemented they will be called -->

    <!-- note that by defaults all beans have singelton scope. meaning appCtxt.getBean()
    will return reference to same singelton instance (that was created when app context is created)
    another scope is 'prototype', in which case getBean() will create and return a new instance every time it is called
    (lazy initialization)
    There also web scopes. Request (new bean per HTTP req) / Session (new bean per HTTP session) / Global session (new bean per global session)
    singelton is the default


    -->
    <bean id="demoRootBean"  class="com.example.springbootdemo.DemoBean"  > <!-- demonstrate bean inheritance -->
        <property name="id" value="999" /> <!-- invoke setter -->
    </bean>
    <bean id="demoBean" class="com.example.springbootdemo.DemoBean" scope="prototype">
        <property name="id" value="999" /> <!-- invoke setter -->
        <constructor-arg value="A_Bean" /> <!-- provide CTOR w/ 1st args vals -->
        <constructor-arg type="int" value="10" /> <!-- provide CTOR w/ 2nd arg. use type to specify type -->
        <constructor-arg index="2" value=", that demonstrate spring beans creation" /> <!-- provide CTOR w/ 3rd arg.
        use index to specify index in argument list -->
    </bean>
    <bean id="demoChildBean" class="com.example.springbootdemo.DemoBean" parent="demoRootBean">
        <constructor-arg value="A_Bean" /> <!-- provide CTOR w/ 1st args vals -->
        <constructor-arg type="int" value="10" /> <!-- provide CTOR w/ 2nd arg. use type to specify type -->
        <constructor-arg index="2" value=", that demonstrate spring beans creation" /> <!-- provide CTOR w/ 3rd arg.
        use index to specify index in argument list -->
    </bean>
    <bean id="triangle" class="com.example.springbootdemo.Triangle" name="triangle3" init-method="myInit" destroy-method="myDestroy"> <!-- call CTOR w/ references to Point instance beans
    that are defined below
    also note name serves as another alias
    register init method -->
         <property name="point1" ref="point1Ref" /> <!--ref can refer to an id a name or an alias -->
        <property name="point2" >
            <bean class="com.example.springbootdemo.Point" >
                <property name="x" value="-20"/>
                <property name="y" value="0"/>
            </bean>
        </property>
        <property name="point3" ref="point3Ref" />
    </bean>

    <!-- demonstrate inheritence of container members. and the merge flag for adding to parent list
    rather than overwriting the list
    -->
    <bean id="pointsListParent" class="com.example.springbootdemo.Points" abstract="true"> <!-- abstract means
    that this only serves as base definition but can't be instantiated
    -->
        <property name="points">
            <list>
                <ref bean="point1Ref"/>
            </list>
        </property>
    </bean>
    <bean id="pointsListChild" class="com.example.springbootdemo.Points" parent="pointsListParent">
        <property name="points">
            <list merge="true">
                <ref bean="point2Ref"/>
                <ref bean="point3Ref"/>
            </list>
        </property>
    </bean>


    <bean id="pointsList" class="com.example.springbootdemo.Points">
        <!-- when commented out the @Required will have RequiredAnnotationBeanPostProcessor throw exception
       Caused by: org.springframework.beans.factory.BeanInitializationException: Property 'points' is required for bean 'pointsList'
        <property name="points">
            <list>
                <ref bean="point1Ref"/>
                <ref bean="point2Ref"/>
                <ref bean="point3Ref"/>
            </list>
        </property>
        -->
        <property name="points">
            <list>
                <ref bean="point1Ref"/>
                <ref bean="point2Ref"/>
                <ref bean="point3Ref"/>
            </list>
        </property>
    </bean>

    <alias name="triangle" alias="triangle2" /> <!-- alias to a bean (like a reference) -->

    <bean id="point1Ref" class="com.example.springbootdemo.Point" > <!-- external bean, can be used by any bean-->
        <property name="x" value="0"/>
        <property name="y" value="0"/>
    </bean>
    <bean id="point2Ref" class="com.example.springbootdemo.Point" >
        <property name="x" value="-20"/>
        <property name="y" value="0"/>
    </bean>
    <bean id="point3Ref" class="com.example.springbootdemo.Point" >
        <property name="x" value="+20"/>
        <property name="y" value="0"/>
    </bean>

    <!-- demonstrate auto-wiring. inject the dependencies when bean names match member variable names -->
    <bean id="triangle4" class="com.example.springbootdemo.Triangle" autowire="byName"> <!-- call CTOR w/ references to Point instance beans
    that are autotmatically populated so long as spring finds beans names that match class Triangle members
    it also possible to set autoWire "byType" which will inject a ref so long as there's one member of that type
    that matches one bean definition of matchine type
    Another option is "constructor" which is similar to byType w/ the difference that spring would try to match
    to a CTOR by type (so multiple beans of same type will not work)
    -->
    </bean>

    <bean id="point1" class="com.example.springbootdemo.Point" > <!-- external bean, can be used by any bean-->
        <property name="x" value="1"/>
        <property name="y" value="2"/>
    </bean>
    <bean id="point2" class="com.example.springbootdemo.Point" >
        <property name="x" value="3"/>
        <property name="y" value="4"/>
    </bean>
    <bean id="point3" class="com.example.springbootdemo.Point" >
        <property name="x" value="5"/>
        <property name="y" value="6"/>
    </bean>
    <bean id="point4" class="com.example.springbootdemo.Point" >
        <!-- placeholder for populating values taken from properties file -->
        <property name="x" value="${point4.x_cfg}"/>
        <property name="y" value="${point4.y_cfg}"/>
    </bean>
    <bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" >
        <property name="locations" value="application.properties" />
    </bean>
    <!-- this is a special
    BeanFactoryPostProcessor that reads from properties file and populates the placeholders w/ values
    -->

    <!-- demonstrate auto-wiring. inject the dependencies when bean names match member variable names -->


    <bean class="com.example.springbootdemo.DisplayNameBeanPostProcessor" /> <!-- spring will create an instance
    of this class so that it can function a post processor
    -->
    <bean class="com.example.springbootdemo.DemoBeanFactoryPostProcessor" />

    <!-- note that its possible to add all annotations post processors beans by adding line
    <context:annotation-config />
    -->
    <context:annotation-config />

    <!-- with <context:annotation-config /> there's no need to manually add each annotation post processor -->
    <!-- <bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor" /> --> <!-- check for
    required annotations -->
    <!-- <bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor" /> --> <!-- wire values to
    setters marked w/ @Autowire
    -->
    <!-- note that @Autowire annotation is by type => so long as there's one bean of this type
    in the spring config it will be wired correctly!
    -->


    <!-- <bean id="msgFormatter" class="com.example.springbootdemo.msgFormatter"/>  --> <!-- match by name -->
    <bean id="msgFormatter" class="com.example.springbootdemo.msgFormatter">  <!-- match by qualifier -->
        <qualifier value="PointsRelated" />
    </bean>
    <!-- note that in case of multiple
    beans w/ same type an dependancy injection failed exception is thrown. ex:
   Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'com.example.springbootdemo.msgFormatter' available: expected single matching bean but found 2: msgFmt,msgFmt1
   So, the injection algorithm for @Autowire annotation starts by injecting when single match to type exists
   otherwise it will try to match by member name if possible.
   Another way to tie the dependancy is by using a qualifier.
    -->
    <bean id="msgFmt1" class="com.example.springbootdemo.msgFormatter"/>

    <!-- demonstrating coding to interface technique in spring -->
    <bean id="horsi" class="com.example.springbootdemo.horse" >
       <property name="sound" value="${horse.sound}" />
    </bean>
    <bean id="bell" class="com.example.springbootdemo.dog" >
        <property name="sound" value="${dog.sound}" />
    </bean>
    <!-- demonstrating coding to interface technique in spring -->

    <!-- tell spring to scan for @Component annotated classes so that they would be
        loaded as beans
        Unfortunately I get an exception Caused by: javax.management.InstanceAlreadyExistsException: org.springframework.boot:type=Admin,name=SpringApplication
        so for now skip
        -->
<!--     <context:component-scan base-package="com.example.springbootdemo" /> -->

    <!-- support for i8n via class="org.springframework.context.support.ResourceBundleMessageSource"
    The ResourceBundleMessageSource will load a properties file that contains the messages
    -->
    <bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource"  >

        <property name="basenames">
           <list>
               <value> messages</value>

           </list>
        </property>
    </bean>

    <!-- register event listener bean -->
    <bean id="GeneralEvtListener" class="com.example.springbootdemo.GeneralEvtListener" >

    </bean>
</beans>



            1.1.2.3 main application

                1.1.2.3.1 example of BeanFactory, ApplicationContext, AbstractApplicationContext, getting beans and wiring to HTTP requests 
package com.example.springbootdemo;

import org.springframework.context.ApplicationContext;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.FileSystemResource;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class SpringbootDemoApplication {

    public static void main(String[] args) {

        //BeanFactory bFactory = new XmlBeanFactory( new FileSystemResource("src/main/resources/spring.xml"));
        // Note that even though there is no BeanFactory still the DemoBeanFactoryPostProcessor get called.
        //The reason is that an ApplicationContext is also a BeanFactory
        ApplicationContext  appCtxt  = new ClassPathXmlApplicationContext( "spring.xml");
        //DemoBean dBean = (DemoBean) bFactory.getBean("demoBean");
        DemoBean dBean = (DemoBean) appCtxt.getBean("demoBean");
        System.out.println(dBean.toString());

        SpringApplication.run(SpringbootDemoApplication.class, args);
        System.out.println( appCtxt.getMessage("msg1", null, "msg1 not found", null) );


    }

    @RequestMapping("hello")
    public String sayHello()
    {
        //Note that ApplicationContext is autoclosed when deployed as webapp. For desktop
        // app or when explicit shutdown handling is required use AbstractApplicationContext
        //ApplicationContext  appCtxt  = new ClassPathXmlApplicationContext( "spring.xml");
        AbstractApplicationContext appCtxt  = new ClassPathXmlApplicationContext( "spring.xml");
        appCtxt.registerShutdownHook();
        //DemoBean dBean = (DemoBean) bFactory.getBean("demoBean");
        DemoBean dBean = (DemoBean) appCtxt.getBean("demoBean");
        DemoBean dcBean = (DemoBean) appCtxt.getBean("demoChildBean");

        //Triangle triangle = (Triangle) appCtxt.getBean("triangle"); //note that all triangle dependecies (points)
        // will be initialized by spring according to spring.xml config
        Triangle triangle = (Triangle) appCtxt.getBean("triangle2"); //note that we are using an alias to triangle
        Triangle triangle4 = (Triangle) appCtxt.getBean("triangle4"); //get an auto-wired bean
        triangle.publishDemoEvent();

        Points pointsList = (Points) appCtxt.getBean("pointsList");
        Points pointsListChild = (Points) appCtxt.getBean("pointsListChild");

        //coding dependendant on implementation. not advisable!
        //horse horsi = (horse) appCtxt.getBean("horsi");
        //dog bell = (dog) appCtxt.getBean("bell");
        //coding to implementation. advisable!
        animal horsi = (animal) appCtxt.getBean("horsi");
        horse realHorse = (horse) horsi ;
        animal bell = (animal) appCtxt.getBean("bell");
        //animal mitzi = (animal) appCtxt.getBean("cat");
        //cat derivedMitzi = (cat) mitzi ;

        return  String.format("<p>Hello Spring Boot App%nDemo Bean: %s</p>%n<p>Spring Inheriting Bean= %s</p>%n" +
                        "<p>Manually defined Triangle: %s</p>%nAut0-wired Triangle: %s</p>%n" +
                        "<p>Points: %s%n Points  %s</p>%n" +
                        "<p>Points Child Bean=%s</p>%n" +
                        "<p>Animal %s . message %s</p>%n" + //horse
                        //"<p>Animal %s . message %s</p>%n" + //cat
                        "<p>Animal %s </p>%n", //dog
                dBean.toString(), dcBean.toString(),
                triangle.toString(),
                triangle4.toString(),
                pointsList.toString(),
                pointsList.getMsgFormatter().formatMsg("formated message"),
                pointsListChild.toString(),
                horsi.Classification(),
                realHorse.getMsgFormatter().formatMsg("I'm derived class, the msg formatter was injected using java @Resource annotation"),
                //mitzi.Classification(),
                //derivedMitzi.getMsgFormatter().formatMsg("I'm an annotated bean"),
                bell.Classification()
        );


    }
}


                1.1.2.3.2

            1.1.2.4 beans

                1.1.2.4.1 example, simple bean
package com.example.springbootdemo;

public class DemoBean {


    //private static int id = 0;

    private int id;
    private  String name;
    private  String message;

    public  int getId()
    {
        return  id;
    }

    public  void  setId(int id)
    {
        this.id = id;
    }

    public DemoBean()
    {
        this.name = "uninitialized";
        this.id = -1;
        this.message="uninitialized bean";
    }
    public  DemoBean(String name)
    {
        //id++;
        //m_id = id;
        this.name = name;
        System.out.printf("Created DemoBean [%s] instance [%d]%n", name, id);
    }

    public  DemoBean(String name, int id)
    {
        this.name = name;
        this.id = id;
    }

    public  DemoBean(String name, int id, String message)
    {
        this.name = name;
        this.id = id;
        this.message = message;
    }


    public String toString(){

        return  String.format("I am DemoBean [%s], instance [%d]%nMy message is %s", name, id, message);
    }
}


                1.1.2.4.2 Bean that is ApplicationContext and name aware , also has init and cleanup callbacks
package com.example.springbootdemo;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanNameAware;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
//import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.ApplicationEventPublisherAware;

//yosi.izaq. demo of using spring dependancy injection.
//Triangle will not init (new) Points.
// Neither will main init Triangle/Points
//Spring will take care of init
public class Triangle implements ApplicationEventPublisherAware, ApplicationContextAware, BeanNameAware { //this bean is now aware of spring app context

    private Point point1;
    private ApplicationContext appCtxt;
    private String beanName;

    public Point getPoint1() {
        return point1;
    }

    public void setPoint1(Point point1) {
        this.point1 = point1;
    }

    public Point getPoint2() {
        return point2;
    }

    public void setPoint2(Point point2) {
        this.point2 = point2;
    }

    public Point getPoint3() {
        return point3;
    }

    public void setPoint3(Point point3) {
        this.point3 = point3;
    }

    private Point point2;
    private Point point3;

    public Point getPoint4() {
        return point4;
    }

    public void setPoint4(Point point4) {
        this.point4 = point4;
    }

    private Point point4; //just for demo of place holders

    @Override
    public String toString() {
        return "Triangle{" +
                "point1=" + point1 +
                ", point2=" + point2 +
                ", point3=" + point3 +
                ", point4=" + point4 +
                ", beanName=" + beanName +
                '}';
    }


    public void publishDemoEvent()
    {
        //publish a toString method called event
        ToStringEvt toStringEvt = new ToStringEvt(this);
        appEvtPub.publishEvent(toStringEvt);
    }

    @Override
    public  void setApplicationContext(ApplicationContext ctxt)
            throws BeansException
    {
        appCtxt = ctxt;
    }

    @Override
public void setBeanName(String name)
    {
        beanName = name;

    }

    public  void  myInit(){
        System.out.printf("My manual init method, registerd to be called for bean initialization in spring.xml%n" );
    }

    public  void myDestroy(){
        System.out.printf("My manual cleanyp method, registerd to be called for bean destruction in spring.xml%n" );
    }

    private ApplicationEventPublisher appEvtPub;

    //Note that actually spring passes the ApplicationContext (which implements the publisher
    // interface). The consumer class uses the interface and the concrete class
    //This complies w/ Spring concept of coding to interface (thus reducing concrete dependencies)
    @Override
    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {
        appEvtPub = applicationEventPublisher;

    }
}

                1.1.2.4.3 Bean that is InitializingBean and DisposableBean, also contains a container member field
package com.example.springbootdemo;

import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Required;
import org.springframework.context.MessageSource;

import java.util.List;
import java.util.Locale;

public class Points implements InitializingBean, DisposableBean { //InitializingBean interface allow to register bean init callback
    //so afterPropertiesSet will be called upon bean init
    // DisposableBean is for bean destruction
    public List<Point> getPoints() {
        return points;
    }

    @Required //instruct spring to validate that setPoints is called, otherwise BeanPostProcessor will throw an exception
    // org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor must be registered
    //in spring config file as it is actually doing the check
    public void setPoints(List<Point> points) {
        this.points = points;
    }

    @Override
    public String toString() {
        return this.msgSrc.getMessage("pointsMsg1", null, "Points I8N intro message not found!", null)+
                //this.msgSrc.getMessage("pointsMsg2", new  Object[]  {points} ,"Points I8N intro message not found!", null ) +
                this.msgSrc.getMessage("pointsMsg2", points.toArray(new Object[0]),"Points I8N intro message not found!", Locale.GERMANY ) +
                "I8N msg: "+ this.msgSrc.getMessage("msg1", null, "I8N message not found!", null)+
                '}';
    }

    @Override
    public void afterPropertiesSet() throws Exception {

        System.out.printf("Bean Points init callback was called%n");
    }

    @Override
    public void destroy() throws Exception {
        System.out.printf("Bean Points shutdown callback was called%n");
    }

    private List<Point> points;



    public com.example.springbootdemo.msgFormatter getMsgFormatter() {
        return msgFormatter;
    }

    @Autowired
    @Qualifier("PointsRelated") //inject the bean that has this qualifier. only required when @Autowired
   // can't match by type (multiple defined) or name (none exists)
    public void setMsgFormatter(com.example.springbootdemo.msgFormatter msgFormatter) {
        this.msgFormatter = msgFormatter;
    }

    private msgFormatter msgFormatter; //just to demo @AutoWired...

    public MessageSource getMsgSrc() {
        return msgSrc;
    }

    public void setMsgSrc(MessageSource msgSrc) {
        this.msgSrc = msgSrc;
    }

    @Autowired
    private MessageSource msgSrc;
}


                1.1.2.4.4 BeanPostProcessor
package com.example.springbootdemo;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

/**
 *
implement a post process method before and after every
bean initialization
need to be registered in spring.xml
 */
public class DisplayNameBeanPostProcessor implements BeanPostProcessor {

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.printf("postProcessBeforeInitialization(Object() called for bean %s%n ", beanName);
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.printf("postProcessAfterInitialization(Object() called for bean %s%n ", beanName) ;
        return bean;
    }
}

package com.example.springbootdemo;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanFactoryPostProcessor;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;

public class DemoBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {
        System.out.printf("DemoBeanFactoryPostProcessor:postProcessBeanFactory() was called%n ");
    }
}

                1.1.2.4.5 code to interface example

                    1.1.2.4.5.1  animal interface


package com.example.springbootdemo;

/*
This interface is meant for demonstrating coding to interface technique in spring
 */
public interface animal {
    public String Classification() ; //what kind of animal are you
}

                    1.1.2.4.5.2 animals: cat, dog, horse
package com.example.springbootdemo;

import org.springframework.stereotype.Component;
import org.springframework.stereotype.Controller;
import org.springframework.stereotype.Repository;
import org.springframework.stereotype.Service;

//Component annotation tells spring to treat this class as a bean
// its equivalent to <bean></bean> clause
//however , when using this annotation, its not possible to have multiple instances of a bean of same class
@Component //bean
//MVC beans annotations
//@Service // BL (view) bean
//@Repository //data (model) bean
//@Controller //controller bean
public class cat implements animal{

    private static String classification="felis catus";

    public com.example.springbootdemo.msgFormatter getMsgFormatter() {
        return msgFormatter;
    }

    public void setMsgFormatter(com.example.springbootdemo.msgFormatter msgFormatter) {
        this.msgFormatter = msgFormatter;
    }

    private  msgFormatter msgFormatter; //note that message formatter bean will be injected according to spring config

    public String getClassification() {
        return classification;
    }

    public void setClassification(String classification) {
        this.classification = classification;
    }

    @Override
    public String Classification() {
        return classification;
    }
}

package com.example.springbootdemo;

public class dog implements  animal{
    private static  final String   classification = "canis lupus familaris";

    public String getSound() {
        return sound;
    }

    public void setSound(String sound) {
        this.sound = sound;
    }

    private String sound;

    @Override
    public String Classification() {
        return  String.format("dog classificatio is %s. %s%n", classification, sound);
    }

}

package com.example.springbootdemo;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.annotation.Resource;

public class horse implements animal{
   private static  final String   classification = "Equus caballus";

   public String getSound() {
      return sound;
   }

   public void setSound(String sound) {
      this.sound = sound;
   }

   private String sound;


   public com.example.springbootdemo.msgFormatter getMsgFormatter() {
      return msgFormatter;
   }


   //@Resource(name = "msgFormatter") //use standard java annotations to inject dependancy
   //Note that @Resource alone (w/o name) will try inject a bean that has name that matches
   // the member name. since they are same in our case we shall omit the name
   @Resource
   public void setMsgFormatter(com.example.springbootdemo.msgFormatter msgFormatter) {
      this.msgFormatter = msgFormatter;
   }

   private msgFormatter msgFormatter;

   @Override
   public String Classification() {
      return  String.format("horse classificatio is %s. %s%n", classification, sound);
   }

   //use java annotations to wire init/destroy callback
   //rather than using spring InitializingBean, DisposableBean  interfaces or specifying these callbacks
   //in spring config file
    @PostConstruct
   public void initHorse(){
       System.out.printf("horse::initHorse() called%n");
   }

   @PreDestroy
   public void destroyHorse(){
      System.out.printf("horse::destroyHorse() called%n");
   }
}

                1.1.2.4.6 Internationalization and application resources 
                application.properties:
point4.x_cfg=0
point4.y_cfg=1
horse.sound="hihiheeeeeee!"
dog.sound="woof woof!"

messages.properties, 
msg1=This is I8N message 1
pointsMsg1=This is points I8N intro!
pointsMsg2=The actual points are {0} {1}

load in spring.xml :
    <bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource"  >

wire to beans as in:
    @Autowired
    private MessageSource msgSrc;

                1.1.2.4.7 Events

                    1.1.2.4.7.1 GeneralEvtListener
package com.example.springbootdemo;

import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

//@Component
//ToDo, talk to yan. Fix the double app ctxt init error...
public class GeneralEvtListener implements ApplicationListener {

    @Override
    public void onApplicationEvent(ApplicationEvent applicationEvent) {
        System.out.println("GeneralEvtListener::onApplicationEvent() got event  "+applicationEvent.toString());
    }
}


                    1.1.2.4.7.2 ToStringEvt
package com.example.springbootdemo;

import org.springframework.context.ApplicationEvent;

public class ToStringEvt extends ApplicationEvent {

    public ToStringEvt(Object source) {
        super(source);
    }

    @Override
    public String toString() {
        return "ToStringEvt{" +
                "super toString=" + source +
                "ToStringEvt toString="+" this is a toString() called event!"+
                '}';
    }
}

                    1.1.2.4.7.3 publish custom events
                    snip:
    public void publishDemoEvent()
    {
        //publish a toString method called event
        ToStringEvt toStringEvt = new ToStringEvt(this);
        appEvtPub.publishEvent(toStringEvt);
    }

                    1.1.2.4.7.4

                1.1.2.4.8

            1.1.2.5


        1.1.3



    1.2 database

        1.2.1  database connections

            1.2.1.1    database connections pools
https://www.baeldung.com/java-connection-pooling

                1.2.1.1.1    Apache Commons DBCP
 -> Configure data source
               public class DBCPDataSource {
    
    private static BasicDataSource ds = new BasicDataSource();
    
    static {
        ds.setUrl("jdbc:h2:mem:test");
        ds.setUsername("user");
        ds.setPassword("password");
        ds.setMinIdle(5);
        ds.setMaxIdle(10);
        ds.setMaxOpenPreparedStatements(100);
    }
    
    public static Connection getConnection() throws SQLException {
        return ds.getConnection();
    }
    
    private DBCPDataSource(){ } 

    -> to get connection:
    Connection con = DBCPDataSource.getConnection();

                1.2.1.1.2 HikariCP
Performant Connection-Pool
-> Configure
public class HikariCPDataSource {
    
    private static HikariConfig config = new HikariConfig();
    private static HikariDataSource ds;
    
    static {
        config.setJdbcUrl("jdbc:h2:mem:test");
        config.setUsername("user");
        config.setPassword("password");
        config.addDataSourceProperty("cachePrepStmts", "true");
        config.addDataSourceProperty("prepStmtCacheSize", "250");
        config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048");
        ds = new HikariDataSource(config);
    }
    
    public static Connection getConnection() throws SQLException {
        return ds.getConnection();
    }
    
    private HikariCPDataSource(){}
}

-> get connection:
Connection con = HikariCPDataSource.getConnection();

                1.2.1.1.3 C3PO
Last in this review is C3PO, a powerful JDBC4 connection and statement pooling framework developed by Steve Waldman:
-> Configure data source:
public class C3poDataSource {

    private static ComboPooledDataSource cpds = new ComboPooledDataSource();

    static {
        try {
            cpds.setDriverClass("org.h2.Driver");
            cpds.setJdbcUrl("jdbc:h2:mem:test");
            cpds.setUser("user");
            cpds.setPassword("password");
        } catch (PropertyVetoException e) {
            // handle the exception
        }
    }
    
    public static Connection getConnection() throws SQLException {
        return cpds.getConnection();
    }
    
    private C3poDataSource(){}
}
-> get connection:
Connection con = C3poDataSource.getConnection();

                1.2.1.1.4 A Simple Implementation
To better understand the underlying logic of connection pooling, let's create a simple implementation.

Let's start out with a loosely-coupled design, based on just one single interface:

public interface ConnectionPool {
    Connection getConnection();
    boolean releaseConnection(Connection connection);
    String getUrl();
    String getUser();
    String getPassword();
}
The ConnectionPool interface defines the public API of a basic connection pool.

Now, let's create an implementation, which provides some basic functionality, including getting and releasing a pooled connection:


freestar
public class BasicConnectionPool 
  implements ConnectionPool {

    private String url;
    private String user;
    private String password;
    private List<Connection> connectionPool;
    private List<Connection> usedConnections = new ArrayList<>();
    private static int INITIAL_POOL_SIZE = 10;
    
    public static BasicConnectionPool create(
      String url, String user, 
      String password) throws SQLException {
 
        List<Connection> pool = new ArrayList<>(INITIAL_POOL_SIZE);
        for (int i = 0; i < INITIAL_POOL_SIZE; i++) {
            pool.add(createConnection(url, user, password));
        }
        return new BasicConnectionPool(url, user, password, pool);
    }
    
    // standard constructors
    
    @Override
    public Connection getConnection() {
        Connection connection = connectionPool
          .remove(connectionPool.size() - 1);
        usedConnections.add(connection);
        return connection;
    }
    
    @Override
    public boolean releaseConnection(Connection connection) {
        connectionPool.add(connection);
        return usedConnections.remove(connection);
    }
    
    private static Connection createConnection(
      String url, String user, String password) 
      throws SQLException {
        return DriverManager.getConnection(url, user, password);
    }
    
    public int getSize() {
        return connectionPool.size() + usedConnections.size();
    }

    // standard getters
}
While pretty naive, the BasicConnectionPool class provides the minimal functionality that we'd expect from a typical connection pooling implementation.

In a nutshell, the class initializes a connection pool based on an ArrayList that stores 10 connections, which can be easily reused.

It's possible to create JDBC connections with the DriverManager class and with Datasource implementations.

As it's much better to keep the creation of connections database agnostic, we've used the former, within the create() static factory method.

In this case, we've placed the method within the BasicConnectionPool, because this is the only implementation of the interface.

In a more complex design, with multiple ConnectionPool implementations, it'd be preferable to place it in the interface, therefore getting a more flexible design and a greater level of cohesion.

The most relevant point to stress here is that once the pool is created, connections are fetched from the pool, so there's no need to create new ones.

Furthermore, when a connection is released, it's actually returned back to the pool, so other clients can reuse it.

There's no any further interaction with the underlying database, such as an explicit call to the Connection's close() method.

->  Using the BasicConnectionPool Class
As expected, using our BasicConnectionPool class is straightforward.

Let's create a simple unit test and get a pooled in-memory H2 connection:

@Test
public whenCalledgetConnection_thenCorrect() {
    ConnectionPool connectionPool = BasicConnectionPool
      .create("jdbc:h2:mem:test", "user", "password");
 
    assertTrue(connectionPool.getConnection().isValid(1));
}
-> Further Improvements and Refactoring
Of course, there's plenty of room to tweak/extend the current functionality of our connection pooling implementation.

For instance, we could refactor the getConnection() method, and add support for maximum pool size. If all available connections are taken, and the current pool size is less than the configured maximum, the method will create a new connection.

Also, we could additionally verify whether the connection obtained from the pool is still alive, before passing it to the client.

@Override
public Connection getConnection() throws SQLException {
    if (connectionPool.isEmpty()) {
        if (usedConnections.size() < MAX_POOL_SIZE) {
            connectionPool.add(createConnection(url, user, password));
        } else {
            throw new RuntimeException(
              "Maximum pool size reached, no available connections!");
        }
    }

    Connection connection = connectionPool
      .remove(connectionPool.size() - 1);

    if(!connection.isValid(MAX_TIMEOUT)){
        connection = createConnection(url, user, password);
    }

    usedConnections.add(connection);
    return connection;
}
Note that the method now throws SQLException, meaning we'll have to update the interface signature as well.

Or, we could add a method to gracefully shut down our connection pool instance:

public void shutdown() throws SQLException {
    usedConnections.forEach(this::releaseConnection);
    for (Connection c : connectionPool) {
        c.close();
    }
    connectionPool.clear();
}
In production-ready implementations, a connection pool should provide a bunch of extra features, such as the ability for tracking the connections that are currently in use, support for prepared statement pooling, and so forth.

As we'll keep things simple, we'll omit how to implement these additional features and keep the implementation non-thread-safe for the sake of clarity.


-> Configure data source:
-> get connection:
Spring Framework JPA
            1.2.1.2

        1.2.2

    1.3 chatgpt


        1.3.1  q. what is spring-boot-starter-webflux
a. 
spring-boot-starter-webflux is a Spring Boot starter dependency that provides a set of libraries for building reactive web applications using Spring WebFlux.

Spring WebFlux is a module of the Spring Framework that provides support for building reactive web applications. Reactive programming is a programming paradigm that focuses on building asynchronous, non-blocking, and event-driven systems. With Spring WebFlux, you can build web applications that are capable of handling a large number of concurrent requests with low resource consumption.

The spring-boot-starter-webflux dependency includes the following libraries:

Spring WebFlux: Provides support for building reactive web applications.
Reactor Core: A reactive library that provides a set of classes for building asynchronous and non-blocking systems.
Jackson JSON: Provides support for working with JSON data.
Spring Boot Actuator: Provides support for monitoring and managing your application.
By including spring-boot-starter-webflux in your Spring Boot application, you can quickly set up a reactive web application with all the necessary dependencies and configurations.

        1.3.2 q. explain the basics of setting up a reactive web application using 
a.
Sure, here are the basics of setting up a reactive web application using Spring WebFlux:

Add the necessary dependencies: To build a reactive web application using Spring WebFlux, you will need to add the spring-boot-starter-webflux dependency to your project. You can add this dependency using your build tool of choice (Maven or Gradle).

Create a Controller: A Controller is a class that handles HTTP requests and returns a response. In Spring WebFlux, you can create a Controller by annotating a class with @RestController.

Define the Routes: To define the routes for your web application, you can use the @RequestMapping annotation. This annotation specifies the HTTP method and the path for each endpoint.

Define the Request and Response Objects: You will need to define the objects that represent the request and response for each endpoint. In Spring WebFlux, you can define these objects as Java classes.

Implement the Business Logic: In the Controller method, you can implement the business logic for handling the request and returning the response.

Here's an example of a simple Spring WebFlux Controller:
@RestController
public class MyController {

  @GetMapping("/hello")
  public Mono<String> sayHello() {
    return Mono.just("Hello World!");
  }

}

In this example, we have defined a Controller that handles GET requests to the /hello endpoint. The sayHello() method returns a Mono object, which represents a single asynchronous result.

That's a basic overview of setting up a reactive web application using Spring WebFlux. Of course, there are many more features and capabilities of Spring WebFlux, but this should give you a good starting point.

        1.3.3 q. example using maven and postgress DB 


Sure, here's an example of setting up a Spring Boot application with Maven and PostgreSQL as the database:

Create a new Maven project: You can create a new Maven project using the following command in the terminal or command prompt:
mvn archetype:generate -DgroupId=com.example -DartifactId=myproject -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false

Add the necessary dependencies: To use PostgreSQL as the database in your Spring Boot application, you will need to add the following dependencies to your pom.xml file:
<dependencies>
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
  </dependency>
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
  </dependency>
  <dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <version>42.2.23</version>
  </dependency>
</dependencies>

The spring-boot-starter-web dependency provides support for building web applications, while the spring-boot-starter-data-jpa dependency provides support for working with databases. The postgresql dependency provides the PostgreSQL driver for Spring Boot to connect to the database.

Configure the database connection: In the application.properties file, you can configure the connection to the PostgreSQL database:
spring.datasource.url=jdbc:postgresql://localhost:5432/mydb
spring.datasource.username=postgres
spring.datasource.password=postgres

Replace mydb, postgres, and postgres with the name of your database, username, and password, respectively.

Create a JPA Entity: A JPA Entity is a Java class that maps to a table in the database. Here's an example of a simple JPA Entity:
@Entity
public class User {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  private String name;

  private String email;

  // Getters and Setters
}

In this example, we have defined a JPA Entity that represents a User table in the database. The @Id annotation specifies the primary key, while the @GeneratedValue annotation generates a unique identifier automatically.

Create a Repository: A Repository is an interface that defines methods for accessing and manipulating data in the database. Here's an example of a simple Repository:
@Repository
public interface UserRepository extends JpaRepository<User, Long> {

}

In this example, we have defined a Repository that extends the JpaRepository interface, which provides a set of methods for working with data in the database.

Create a Controller: A Controller is a class that handles HTTP requests and returns a response. Here's an example of a simple Controller:
@RestController
public class UserController {

  @Autowired
  private UserRepository userRepository;

  @GetMapping("/users")
  public List<User> getUsers() {
    return userRepository.findAll();
  }

  @PostMapping("/users")
  public User createUser(@RequestBody User user) {
    return userRepository.save(user);
  }

}

In this example, we have defined a Controller that handles GET and POST requests to the /users endpoint. The @Autowired annotation injects the UserRepository dependency, which we can use to access and manipulate data in the database.

That's a basic example of setting up a Spring Boot application with Maven and PostgreSQL as the database. Of course, there are many more features and configurations that you can add to this setup,

        1.3.4 use JDBC instead of JPA
Sure, here's an example of setting up a Spring Boot application with Maven and PostgreSQL as the database using JDBC instead of JPA:

Create a new Maven project: You can create a new Maven project using the following command in the terminal or command prompt:
mvn archetype:generate -DgroupId=com.example -DartifactId=myproject -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false

Add the necessary dependencies: To use PostgreSQL as the database in your Spring Boot application with JDBC, you will need to add the following dependencies to your pom.xml file:
<dependencies>
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
  </dependency>
  <dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <version>42.2.23</version>
  </dependency>
</dependencies>

The spring-boot-starter-web dependency provides support for building web applications, while the postgresql dependency provides the PostgreSQL driver for Spring Boot to connect to the database.

Configure the database connection: In the application.properties file, you can configure the connection to the PostgreSQL database:
spring.datasource.url=jdbc:postgresql://localhost:5432/mydb
spring.datasource.username=postgres
spring.datasource.password=postgres

Replace mydb, postgres, and postgres with the name of your database, username, and password, respectively.

Create a DAO: A DAO (Data Access Object) is a class that encapsulates the logic for accessing and manipulating data in the database. Here's an example of a simple DAO:
@Repository
public class UserDao {

  @Autowired
  private JdbcTemplate jdbcTemplate;

  public List<User> getUsers() {
    String sql = "SELECT * FROM users";
    return jdbcTemplate.query(sql, new UserRowMapper());
  }

  public User createUser(User user) {
    String sql = "INSERT INTO users(name, email) VALUES (?, ?)";
    jdbcTemplate.update(sql, user.getName(), user.getEmail());
    return user;
  }

}

In this example, we have defined a DAO that uses the JdbcTemplate class to interact with the database. The getUsers() method executes a SELECT statement to retrieve a list of users from the database, while the createUser() method executes an INSERT statement to insert a new user into the database.

Create a RowMapper: A RowMapper is an interface that maps a row of data from the database to a Java object. Here's an example of a simple RowMapper:
public class UserRowMapper implements RowMapper<User> {

  @Override
  public User mapRow(ResultSet rs, int rowNum) throws SQLException {
    User user = new User();
    user.setId(rs.getLong("id"));
    user.setName(rs.getString("name"));
    user.setEmail(rs.getString("email"));
    return user;
  }

}

In this example, we have defined a RowMapper that maps a row of data from the users table in the database to a User object.

Create a Controller: A Controller is a class that handles HTTP requests and returns a response. Here's an example of a simple Controller:
@RestController
public class UserController {

  @Autowired
  private UserDao userDao;

  @GetMapping("/users")
  public List<User> getUsers() {
    return userDao.getUsers();
  }

  @PostMapping("/users")
  public User createUser(@RequestBody User user) {
    return userDao.createUser(user);
  }

}

q. why JdbcTemplate is @Autowired
a. In the example I provided earlier, the JdbcTemplate object is autowired into the UserDao class using the @Autowired annotation. This is because the JdbcTemplate class is a Spring framework class that provides a convenient way to interact with a JDBC datasource.

By autowiring the JdbcTemplate object, Spring takes care of creating an instance of the JdbcTemplate class and injecting it into the UserDao class at runtime. This makes it easier to use the JdbcTemplate object without having to manually create an instance of the class or worry about managing its lifecycle.

In addition, the @Autowired annotation is used in conjunction with Spring's IoC (Inversion of Control) container, which is responsible for managing the lifecycle of objects and their dependencies in a Spring application. By using @Autowired, the JdbcTemplate object is automatically wired up by the IoC container, which reduces the amount of boilerplate code that would be required if we had to create and manage the JdbcTemplate object manually.


        1.3.5 explain java org.springframework.context.annotation.Profile
In Java and the Spring Framework, the `@Profile` annotation is used to define different configurations and beans based on specific runtime environments or application profiles. It allows you to selectively activate or deactivate certain parts of your application's configuration based on the specified profile.

Here's how the `@Profile` annotation works:

1. Defining Profiles: Profiles are defined using the `@Profile` annotation at the class or method level. You can assign one or more profile names to the annotation. For example:

```java
@Configuration
@Profile("development")
public class DevelopmentConfig {
    // Configuration for development profile
}

@Configuration
@Profile("production")
public class ProductionConfig {
    // Configuration for production profile
}
```

In this example, two configuration classes are defined, each associated with a different profile. The `DevelopmentConfig` class is active only when the "development" profile is active, and the `ProductionConfig` class is active only when the "production" profile is active.

2. Activating Profiles: Profiles can be activated in various ways, depending on your application's setup. Here are a few common methods:

   - Via Configuration: You can set the active profiles using configuration properties, such as in the `application.properties` or `application.yml` file:

     ```
     spring.profiles.active=development,anotherProfile
     ```

   - Programmatically: You can programmatically activate profiles during application startup by using the `ConfigurableEnvironment` or `SpringApplication` APIs:

     ```java
     SpringApplication app = new SpringApplication(MyApplication.class);
     ConfigurableEnvironment environment = app.getEnvironment();
     environment.setActiveProfiles("development");
     app.run(args);
     ```

   - Using Command Line Arguments: You can specify active profiles as command line arguments:

     ```
     java -jar myapp.jar --spring.profiles.active=development
     ```

3. Conditional Bean Creation: The `@Profile` annotation can also be used to conditionally create beans based on profiles. By annotating a bean definition or `@Configuration` class with `@Profile`, the bean(s) will only be created when the specified profile is active. For example:

```java
@Configuration
public class MyConfig {
    @Bean
    @Profile("development")
    public DataSource developmentDataSource() {
        // Configuration for development data source
    }

    @Bean
    @Profile("production")
    public DataSource productionDataSource() {
        // Configuration for production data source
    }
}
```

In this case, the `developmentDataSource` bean will be created and used when the "development" profile is active, while the `productionDataSource` bean will be created and used when the "production" profile is active.

The `@Profile` annotation provides a powerful way to manage different configurations and beans based on specific profiles or runtime environments. It allows you to easily switch between different configurations during development, testing, and production, providing flexibility and maintainability in your Spring applications.

        1.3.6 is there a spring framework DataSource class or interface
Yes, in the Spring Framework, there is a `DataSource` interface provided that represents a database connection pool. The `DataSource` interface defines a set of methods to obtain and manage database connections, allowing you to interact with a database in a standardized way.

Here's an example of how the `DataSource` interface can be used in the Spring Framework:

```java
import org.springframework.jdbc.datasource.DriverManagerDataSource;

DataSource dataSource = new DriverManagerDataSource();
((DriverManagerDataSource) dataSource).setDriverClassName("com.mysql.jdbc.Driver");
((DriverManagerDataSource) dataSource).setUrl("jdbc:mysql://localhost:3306/mydb");
((DriverManagerDataSource) dataSource).setUsername("username");
((DriverManagerDataSource) dataSource).setPassword("password");

// Use the dataSource in your application
```

In this example, the `DriverManagerDataSource` class is used to create an instance of the `DataSource` interface. The `DriverManagerDataSource` is a basic implementation of the `DataSource` interface provided by Spring, and it allows you to configure the necessary database connection details such as driver class name, URL, username, and password.

Spring provides several other implementations of the `DataSource` interface, such as `TomcatDataSource`, `HikariDataSource`, and more. These implementations offer advanced features like connection pooling, connection management, and performance optimizations.

You can also configure a `DataSource` bean in your Spring application context XML or using annotations such as `@Bean`. By declaring a `DataSource` bean, you can inject it into your application's components, such as `JdbcTemplate`, `JPA`, or other data access frameworks provided by Spring, to interact with the database.

Using the `DataSource` interface in conjunction with Spring's data access frameworks helps to abstract away the underlying database connection details and provides a consistent and convenient way to work with databases in your Spring applications.

        1.3.7 explain org.springframework.jdbc.core.JdbcTemplate
The `JdbcTemplate` class in the `org.springframework.jdbc.core` package is a central class in the Spring Framework's JDBC support. It simplifies the process of working with relational databases using JDBC by providing a higher-level abstraction and a set of convenient methods.

The `JdbcTemplate` class encapsulates the boilerplate code required to manage database connections, execute SQL statements or queries, handle exceptions, and process the results. It helps to reduce repetitive JDBC-related code and promotes cleaner and more concise database access code.

Here are some key features and functionalities of the `JdbcTemplate` class:

1. Database Operations: The `JdbcTemplate` class provides methods for executing various types of SQL operations, such as updates, inserts, deletes, and selects. These methods handle all the necessary details, including acquiring and releasing database connections, executing SQL statements, binding parameters, and processing result sets.

2. Exception Handling: The `JdbcTemplate` class handles SQLExceptions that occur during database operations and wraps them in more meaningful and standardized Spring exceptions, such as `DataAccessException`. This simplifies error handling and allows for consistent exception handling across different database operations.

3. PreparedStatement Creation: The `JdbcTemplate` class can create `PreparedStatement` objects for executing SQL statements with bound parameters. It automatically handles the preparation of the statement and sets the appropriate parameter values based on the provided arguments.

4. ResultSet Processing: The `JdbcTemplate` class provides methods for processing `ResultSet` objects returned from SELECT queries. It simplifies the process of iterating over the result set, extracting data, and mapping it to Java objects or data structures.

5. Batch Updates: The `JdbcTemplate` class supports batch updates, allowing you to execute multiple SQL statements as a single batch. This can significantly improve performance when dealing with multiple database operations.

6. Exception Translation: The `JdbcTemplate` class integrates with Spring's `SQLExceptionTranslator` mechanism, which translates database-specific SQL exceptions into Spring's standardized `DataAccessException` hierarchy. This helps to abstract away the database-specific exception handling and provides a consistent exception model.

7. Callback Mechanism: The `JdbcTemplate` class supports a callback mechanism through the use of various callback interfaces. These interfaces, such as `PreparedStatementCreator`, `PreparedStatementSetter`, `RowMapper`, and others, allow you to customize the behavior of database operations and provide more flexibility in handling SQL statements and result sets.

Overall, the `JdbcTemplate` class simplifies and streamlines database access code by encapsulating the complexity of JDBC operations. It promotes best practices, such as using prepared statements, handling exceptions, and separating concerns, resulting in cleaner and more maintainable code when working with relational databases in Spring applications.

        1.3.8 explain  org.springframework.beans.factory.annotation.Qualifier
The `@Qualifier` annotation in the `org.springframework.beans.factory.annotation` package is used in the Spring Framework to disambiguate bean dependencies when multiple beans of the same type are present in the application context. It helps to resolve the issue of having multiple candidates for autowiring by specifying a unique qualifier value.

When autowiring dependencies using `@Autowired` or other similar annotations, Spring attempts to match the required dependency with a bean of the same type in the application context. However, if there are multiple beans of the same type, Spring cannot determine which one to use by default. This is where the `@Qualifier` annotation comes into play.

Here's how the `@Qualifier` annotation is used:

1. Define Bean Qualifiers: In the application context, when defining multiple beans of the same type, you can assign a unique qualifier value using the `@Qualifier` annotation. For example:

```java
@Component
@Qualifier("foo")
public class FooService implements SomeService {
    // ...
}

@Component
@Qualifier("bar")
public class BarService implements SomeService {
    // ...
}
```

In this example, two beans of type `SomeService` are defined with different qualifiers: `"foo"` and `"bar"`. These qualifiers help to differentiate between the beans during autowiring.

2. Use `@Qualifier` for Dependency Injection: In the dependent class or component, you can use the `@Qualifier` annotation along with `@Autowired` to specify which bean should be injected. For example:

```java
@Component
public class MyComponent {
    @Autowired
    @Qualifier("foo")
    private SomeService someService;

    // ...
}
```

In this case, the `@Qualifier("foo")` annotation specifies that the bean with the qualifier `"foo"` should be injected into the `someService` field. This resolves the ambiguity when multiple beans of type `SomeService` are available.

The `@Qualifier` annotation works in conjunction with the bean name or other custom qualifier annotations. If you use the default bean names as qualifiers, you can omit the `@Qualifier` annotation and rely on Spring's default behavior of matching by bean name.

By using `@Qualifier`, you can explicitly specify which bean should be injected when multiple beans of the same type are present. It provides fine-grained control over dependency injection and helps to resolve conflicts in cases where the default autowiring mechanism is not sufficient.
        1.3.9
    1.4
2. general
    2.1. manipulate jar files.
	help:
	$jar 

	list files in archive
	$jar -tvf <file>.jar
	
	searh for a specific class (in sh, bash ...)
	$for jar in *.jar;  do echo  $jar; jar tvf $jar | grep <class>; done
	
    2.2. remote debug java application.

first run jvm (java) with extra flags to open listen socket:
-Xdebug -Xnoagent -Djava.compiler=none -Xrunjdwp:transport=dt_socket,server=y,suspend=y

then connect via
jdb -connect com.sun.jdi.SocketAttach:hostname=localhost,port=XXXX

In case of C++ application with java parts, make sure the C++ app is running after socket is opened (like press enter in prompt).

For Eclipse connect to the port then switch to debug prespective.
Also make sure the code is compiled with debug flag:
 -g or for ant set <property name="javac.debug" value="on" /> and in the <javac> command add
  debug="on" property.
  
    2.3. deploy JSP pages to web container.
deploy war file reccomended but can deploy the whole dir instead.
project dir must contain WEB-INF,  WEB-INF/lib, WEB-INF/classes libs.
To include classes use the <import> directive.
If needed edit web server configuration to specify needed classpath ( for TOMCAT, config/web.xml, classpath).
x
    2.4. Tomcat
	1. listen port and shutdown port are defined in server.xml. 

    2.5.  Reverse engineer.
	$ use javap -c (that comes with java installation)
	$ also eclispse will do that.
	$ there are commercial tools. like DJ java. 

    2.6 Set java version, toggle java versions, switch jdk versions 

        2.6.1 mac, OS X
TLDR, use my aliases
[i500695@C02X632CJGH6:2020-10-25 16:13:31:~/work/SAP/git/portal-cf-provisioning-service:]2077$ java_versions 
Matching Java Virtual Machines (4):
    14.0.2, x86_64:	"OpenJDK 14.0.2"	/Library/Java/JavaVirtualMachines/openjdk-14.0.2.jdk/Contents/Home
    10.0.2, x86_64:	"Java SE 10.0.2"	/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home
    1.8.0_265, x86_64:	"AdoptOpenJDK 8"	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home
    1.8.0_241, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home

/Library/Java/JavaVirtualMachines/openjdk-14.0.2.jdk/Contents/Home
[i500695@C02X632CJGH6:2020-10-25 16:13:35:~/work/SAP/git/portal-cf-provisioning-service:]2078$ java_set1_8 
[i500695@C02X632CJGH6:2020-10-25 16:13:39:~/work/SAP/git/portal-cf-provisioning-service:]2079$ echo $JAVA_HOME 
/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home

long read:

Setting v 1.8 on my Mac:
$ /usr/libexec/java_home -V
Matching Java Virtual Machines (4):
    13.0.1, x86_64:	"OpenJDK 13.0.1"	/Library/Java/JavaVirtualMachines/openjdk-13.0.1.jdk/Contents/Home
    10.0.2, x86_64:	"Java SE 10.0.2"	/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home
    1.8.0_241, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home
    1.8.0_232, x86_64:	"AdoptOpenJDK 8"	/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home

/Library/Java/JavaVirtualMachines/openjdk-13.0.1.jdk/Contents/Home
[i500695@C02X632CJGH6:2020-03-05 13:55:26:~/work/SAP/git/portal-cf-provisioning-service:]2117$ export JAVA_HOME=`/usr/libexec/java_home -v 1.8.0_232`


https://stackoverflow.com/questions/21964709/how-to-set-or-change-the-default-java-jdk-version-on-os-x

| First run /usr/libexec/java_home -V which will output something like the following:
| Matching Java Virtual Machines (3):
| 1.8.0_05, x86_64:   "Java SE 8" /Library/Java/JavaVirtualMachines/jdk1.8.0_05.jdk/Contents/Home
| 1.6.0_65-b14-462, x86_64:   "Java SE 6" /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home
| 1.6.0_65-b14-462, i386: "Java SE 6" /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home

/Library/Java/JavaVirtualMachines/jdk1.8.0_05.jdk/Contents/Home
Pick the version you want to be the default (1.6.0_65-b14-462 for arguments sake) then:
export JAVA_HOME=`/usr/libexec/java_home -v 1.6.0_65-b14-462`
or you can specify just the major version, like:
export JAVA_HOME=`/usr/libexec/java_home -v 1.8`
Now when you run java -version you will see:
java version "1.6.0_65"
Java(TM) SE Runtime Environment (build 1.6.0_65-b14-462-11M4609)
Java HotSpot(TM) 64-Bit Server VM (build 20.65-b04-462, mixed mode)
Add the export JAVA_HOME… line to your shell’s init file.
For Bash (as stated by antonyh):
export JAVA_HOME=$(/usr/libexec/java_home -v 1.8)
    
    2.7 chatgpt

        2.7.1 java set data structure, tags: java set data structure
In Java, the `Set` data structure is part of the Java Collections Framework and is used to store a collection of unique elements. It does not allow duplicate elements, and it does not guarantee the order of elements.

There are several classes in Java that implement the `Set` interface. Some commonly used implementations include:

|  1. `HashSet`: This implementation uses a hash table to store the elements. It provides constant-time performance for basic operations like add, remove, and contains, assuming a good hash function is used for the objects being stored.
|  
|  2. `TreeSet`: This implementation stores elements in a sorted tree structure. It maintains the elements in ascending order or according to a custom `Comparator` provided during creation. The add, remove, and contains operations have a time complexity of O(log n).
|  
|  3. `LinkedHashSet`: This implementation maintains a doubly-linked list of the elements in addition to using a hash table. It guarantees that the elements will be iterated in the order they were inserted. The time complexity for basic operations is similar to `HashSet`.
|  
|  Here's an example that demonstrates how to use the `HashSet` class:
|  
|  ```java
|  import java.util.HashSet;
|  import java.util.Set;
|  
|  public class SetExample {
|      public static void main(String[] args) {
|          Set<String> set = new HashSet<>();
|  
|          // Adding elements to the set
|          set.add("apple");
|          set.add("banana");
|          set.add("orange");
|  
|          // Adding a duplicate element (it will be ignored)
|          set.add("apple");
|  
|          // Printing the set
|          System.out.println(set); // Output: [orange, banana, apple]
|  
|          // Checking if an element exists in the set
|          boolean containsOrange = set.contains("orange");
|          System.out.println(containsOrange); // Output: true
|  
|          // Removing an element from the set
|          set.remove("banana");
|  
|          // Printing the set after removal
|          System.out.println(set); // Output: [orange, apple]
|  
|          // Getting the size of the set
|          int size = set.size();
|          System.out.println(size); // Output: 2
|      }
|  }
|  ```

This example demonstrates basic operations such as adding elements, checking for element existence, removing elements, and retrieving the size of the set using a `HashSet`.

        2.7.2  java Files  , tags: java Files  
In Java, the `java.nio.file.Files` class provides a set of static methods for working with files and directories. It is part of the Java NIO (New I/O) package and introduced in Java 7. The `Files` class provides various methods for common file operations such as creating, deleting, copying, moving, and reading files.

Here are some commonly used methods of the `Files` class:

| 1. `createFile(Path path, FileAttribute<?>... attrs)`: Creates a new empty file at the specified path.
| 
| 2. `createDirectory(Path dir, FileAttribute<?>... attrs)`: Creates a new directory at the specified path.
| 
| 3. `delete(Path path)`: Deletes a file or an empty directory at the specified path.
| 
| 4. `copy(Path source, Path target, CopyOption... options)`: Copies a file or a directory from the source path to the target path. The `CopyOption` parameter allows specifying options like replacing existing files or preserving file attributes.
| 
| 5. `move(Path source, Path target, CopyOption... options)`: Moves a file or a directory from the source path to the target path. This method can also be used for renaming files.
| 
| 6. `readAllLines(Path path, Charset cs)`: Reads all lines from a file and returns them as a `List` of strings.
| 
| 7. `write(Path path, byte[] bytes, OpenOption... options)`: Writes the specified byte array to a file.
| 
| 8. `isDirectory(Path path)`: Checks if the specified path represents a directory.
| 
| 9. `isRegularFile(Path path, LinkOption... options)`: Checks if the specified path represents a regular file.

These are just a few examples of the methods provided by the `Files` class. There are more methods available for various file operations. To use these methods, you need to import the `java.nio.file.Files` class and work with `java.nio.file.Path` objects to represent file and directory paths.

Here's an example that demonstrates the usage of some `Files` methods:

```java
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.charset.StandardCharsets;
import java.io.IOException;
import java.util.List;

public class FilesExample {
    public static void main(String[] args) {
        try {
            // Creating a new directory
            Path directoryPath = Paths.get("mydirectory");
            Files.createDirectory(directoryPath);

            // Creating a new file
            Path filePath = Paths.get("mydirectory/myfile.txt");
            Files.createFile(filePath);

            // Writing content to the file
            String content = "Hello, World!";
            Files.write(filePath, content.getBytes(StandardCharsets.UTF_8));

            // Reading all lines from the file
            List<String> lines = Files.readAllLines(filePath, StandardCharsets.UTF_8);
            for (String line : lines) {
                System.out.println(line);
            }

            // Deleting the file
            Files.delete(filePath);

            // Deleting the directory
            Files.delete(directoryPath);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

In this example, we create a directory called "mydirectory," create a file called "myfile.txt" inside the directory, write some content to the file, read the content back, and finally delete the file and directory.

        2.7.3 java Objects.requireNonNull , tags: java Objects.requireNonNull 
In Java, `Objects.requireNonNull` is a utility method provided by the `java.util.Objects` class. It is commonly used to check if an object reference is null and throw a `NullPointerException` if it is.

The `requireNonNull` method has the following signature:

```java
public static <T> T requireNonNull(T obj)
```

It takes an object reference `obj` as a parameter and returns the reference if it is not null. If `obj` is null, it throws a `NullPointerException`.

Here's an example to illustrate the usage of `Objects.requireNonNull`:

```java
import java.util.Objects;

public class Example {
    public static void main(String[] args) {
        String name = null;

        // Using Objects.requireNonNull to check if the reference is null
        String nonNullName = Objects.requireNonNull(name);

        System.out.println(nonNullName);
    }
}
```

In this example, the variable `name` is assigned a null value. When we pass `name` to `Objects.requireNonNull`, it will throw a `NullPointerException` because the reference is null.

If you want to provide a custom error message when a null value is encountered, you can use the overloaded version of `requireNonNull` that takes a message as the second parameter:

```java
public static <T> T requireNonNull(T obj, String message)
```

Here's an example using the overloaded `requireNonNull` method:

```java
import java.util.Objects;

public class Example {
    public static void main(String[] args) {
        String name = null;

        try {
            String nonNullName = Objects.requireNonNull(name, "Name cannot be null");
            System.out.println(nonNullName);
        } catch (NullPointerException e) {
            System.out.println(e.getMessage()); // Output: Name cannot be null
        }
    }
}
```

In this example, we pass the custom error message "Name cannot be null" as the second argument to `requireNonNull`. If the reference is null, it will throw a `NullPointerException` with the specified message.

        2.7.4 java File.toPath() , tags: java File.toPath() 
In Java, the `File` class represents a file or directory on the file system. Starting from Java 7, the `File` class has a method called `toPath()` which returns a `java.nio.file.Path` object representing the abstract path of the `File`.

The `toPath()` method has the following signature:

```java
public Path toPath()
```

Here's an example that demonstrates the usage of `toPath()`:

```java
import java.io.File;
import java.nio.file.Path;

public class Example {
    public static void main(String[] args) {
        File file = new File("path/to/file.txt");

        // Converting File to Path
        Path path = file.toPath();

        // Printing the Path
        System.out.println(path);
    }
}
```

In this example, we create a `File` object representing a file path "path/to/file.txt". We then call the `toPath()` method on the `File` object to convert it to a `Path` object. Finally, we print the `Path` object.

Note that `toPath()` is available starting from Java 7. If you are using an older version of Java, you can still convert a `File` to a `Path` by using the `Paths.get(String)` method, as shown below:

```java
import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;

public class Example {
    public static void main(String[] args) {
        File file = new File("path/to/file.txt");

        // Converting File to Path
        Path path = Paths.get(file.getPath());

        // Printing the Path
        System.out.println(path);
    }
}
```

In this example, we use the `Paths.get(String)` method and pass the file's path obtained from `file.getPath()` to convert the `File` object to a `Path`.

        2.7.5 java use class loader to read a file that contains a sql statement and then run it on a PG DB , tags: java use class loader to read a file that contains a sql statement and then run it on a PG DB 
To read a file containing an SQL statement using a class loader and execute it on a PostgreSQL database in Java, you can follow these steps:

| 1. Place the SQL file in the appropriate location within your project's resources. For example, you can create a folder called `sql` in the `src/main/resources` directory and place the SQL file there.
| 
| 2. Use the class loader to read the file as an input stream. Here's an example:

```java
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;

public class SQLRunner {
    public static void main(String[] args) {
        // Load the SQL file using the class loader
        InputStream inputStream = SQLRunner.class.getClassLoader().getResourceAsStream("sql/myquery.sql");

        if (inputStream != null) {
            try {
                // Read the SQL file content as a string
                String sql = new String(inputStream.readAllBytes(), StandardCharsets.UTF_8);

                // Establish a connection to the PostgreSQL database
                Connection connection = DriverManager.getConnection("jdbc:postgresql://localhost:5432/mydb", "username", "password");

                // Create a statement
                Statement statement = connection.createStatement();

                // Execute the SQL statement
                statement.executeUpdate(sql);

                // Close the statement and connection
                statement.close();
                connection.close();

                System.out.println("SQL statement executed successfully.");
            } catch (IOException | SQLException e) {
                e.printStackTrace();
            }
        } else {
            System.out.println("SQL file not found.");
        }
    }
}
```

In this example, the SQL file `myquery.sql` is located in the `sql` folder under `src/main/resources`. The class loader is used to read the file as an input stream. The content of the SQL file is then converted to a string.

Next, a connection is established to the PostgreSQL database using the appropriate JDBC URL, username, and password. A `Statement` object is created from the connection, and the SQL statement is executed using `statement.executeUpdate(sql)`.

Finally, the statement and connection are closed, and a message is printed indicating the successful execution of the SQL statement.

Make sure to replace the JDBC URL, username, and password with the appropriate values for your PostgreSQL database.



        2.7.6 java org.stringtemplate.v4.ST , tags: java org.stringtemplate.v4.ST 
The `org.stringtemplate.v4.ST` class is part of the StringTemplate library, which is a powerful template engine for generating text-based output such as code, HTML, XML, etc., from templates. StringTemplate is available for Java and several other programming languages.

The `ST` class represents a single template and provides methods for setting template attributes, rendering the template, and retrieving the generated output. It allows you to dynamically populate placeholders in the template with values.

Here's an example that demonstrates the basic usage of `ST`:

```java
import org.stringtemplate.v4.ST;

public class STExample {
    public static void main(String[] args) {
        // Create a template with a placeholder
        ST template = new ST("Hello, <name>!");

        // Set the value for the placeholder
        template.add("name", "John");

        // Render the template and get the output
        String output = template.render();

        // Print the generated output
        System.out.println(output);
    }
}
```

In this example, we create an `ST` object with the template "Hello, \<name>!". The `<name>` part is a placeholder that will be dynamically replaced with a value. We set the value for the "name" placeholder using `template.add("name", "John")`. Finally, we call `template.render()` to generate the output, which is then printed to the console.

StringTemplate supports more advanced features like conditionals, loops, and template inheritance. You can define templates with more complex structures and use them to generate dynamic text output.

To use StringTemplate in your project, you need to include the StringTemplate library in your project dependencies. You can find the StringTemplate library and its documentation on the official website: http://www.stringtemplate.org/

        2.7.7 java StringBuilder, tags: java StringBuilder
In Java, `StringBuilder` is a class that provides a mutable sequence of characters. It is commonly used when you need to efficiently build or manipulate strings that can change frequently, especially when concatenating multiple strings or performing frequent modifications.

Here's an example of how to use `StringBuilder` in Java:

```java
StringBuilder sb = new StringBuilder();

// Appending strings
sb.append("Hello");
sb.append(" ");
sb.append("World");

// Inserting strings at a specific position
sb.insert(5, ","); // Output: Hello, World

// Replacing a portion of the string
sb.replace(7, 12, "There"); // Output: Hello, There

// Deleting characters from the string
sb.delete(5, 7); // Output: Hello There

// Getting the final string
String result = sb.toString();
System.out.println(result); // Output: Hello There
```

In this example, we create a `StringBuilder` object named `sb`. We then use various methods of the `StringBuilder` class to append, insert, replace, and delete characters or portions of the string. Finally, we convert the `StringBuilder` object to a regular `String` using the `toString()` method and store it in the `result` variable. The resulting string is then printed to the console.

`StringBuilder` provides efficient string manipulation operations because it internally maintains a mutable character array. This avoids unnecessary memory allocations and copying when performing concatenation or modifications. It is generally preferred over `String` concatenation using the `+` operator when you need to build or modify strings dynamically.

Note: `StringBuilder` is not thread-safe. If you require thread safety, you can use the `StringBuffer` class, which provides similar functionality but with thread-safe operations.


        2.7.8 java jackson @JsonCreator annotation, tags: java jackson @JsonCreator annotation
In Java with Jackson, the `@JsonCreator` annotation is used to mark a constructor or a static factory method as a creator for deserialization. It is used to specify how Jackson should create an instance of a class when deserializing JSON into Java objects.

Here's how the `@JsonCreator` annotation can be used:

|  1. Constructor-based deserialization:
|  ```java
|  public class MyClass {
|      private String property;
|  
|      @JsonCreator
|      public MyClass(@JsonProperty("property") String property) {
|          this.property = property;
|      }
|  }
|  ```
|  In this example, the `@JsonCreator` annotation is applied to the constructor of the `MyClass` class. It indicates that this constructor should be used during deserialization. The `@JsonProperty("property")` annotation is used to map the JSON property named "property" to the corresponding constructor parameter.
|  
|  2. Static factory method-based deserialization:
|  ```java
|  public class MyClass {
|      private String property;
|  
|      private MyClass(String property) {
|          this.property = property;
|      }
|  
|      @JsonCreator
|      public static MyClass createInstance(@JsonProperty("property") String property) {
|          return new MyClass(property);
|      }
|  }
|  ```
In this example, the `@JsonCreator` annotation is applied to a static factory method `createInstance()`. It specifies that this method should be used for deserialization. The `@JsonProperty("property")` annotation is used to map the JSON property named "property" to the corresponding method parameter.

Both approaches allow Jackson to create instances of the annotated class during deserialization by matching the JSON properties with the constructor parameters or factory method arguments based on their names.

The `@JsonCreator` annotation provides flexibility in deserialization, allowing you to customize how JSON data is converted into Java objects.

        2.7.9 how to read an array property into a List<String> in a @JsonCreator annotated class constructor, tags: how to read an array property into a List<String> in a @JsonCreator annotated class constructor
To read an array property into a `List<String>` in a `@JsonCreator` annotated class constructor, you can use the `@JsonProperty` annotation along with the `List` type.

Here's an example:

```java
public class MyClass {
    private List<String> values;

    @JsonCreator
    public MyClass(@JsonProperty("values") List<String> values) {
        this.values = values;
    }

    // Getter and Setter for values
}
```

In this example, the `MyClass` constructor is annotated with `@JsonCreator`, indicating that it should be used for deserialization. The `@JsonProperty("values")` annotation is applied to the constructor parameter `values`, specifying that the JSON property with the name "values" should be mapped to this parameter.

During deserialization, Jackson will automatically convert the JSON array property named "values" into a `List<String>` and pass it to the constructor.

Here's an example JSON that can be deserialized using the `MyClass` constructor:

```json
{
  "values": ["value1", "value2", "value3"]
}
```

When you deserialize this JSON using Jackson, the `values` property will be mapped to a `List<String>` in the `MyClass` instance, with each element of the JSON array becoming an element in the list.

Remember to include the necessary Jackson dependencies in your project for JSON serialization and deserialization, such as `jackson-core`, `jackson-databind`, and `jackson-annotations`.

        2.7.10
    2.8
3.  IDE, intellij 

    3.1   VIM plugin
    IdeaVim

install
Preferences -> plugins -> IdeaVim

    3.2   Code generation

        3.2.1    generate getters and setters
write code for fields. e.g.

   private int x;
    private int y;
    
hit cmd+N
choose generate setters and getters

        3.2.2

    3.3

4. Build java projects

    4.1 Build java projects with maven

        4.1.1 Build java projects with maven spring tutorial
https://spring.io/guides/gs/maven/

Create the directory structure

In a project directory of your choosing, create the following subdirectory structure; for example, with mkdir -p src/main/java/hello on *nix systems:
[i500695@C02X632CJGH6:2020-01-19 17:42:28:~/work/code/java/helloWorld:]2038$ mkdir -p src/main/java/hello 
create these two classes: HelloWorld.java and Greeter.java.

src/main/java/hello/HelloWorld.java

package hello;

public class HelloWorld {
  public static void main(String[] args) {
    Greeter greeter = new Greeter();
    System.out.println(greeter.sayHello());
  }
}

src/main/java/hello/Greeter.java

package hello;

public class Greeter {
  public String sayHello() {
    return "Hello world!";
  }
}

Now that you have a project that is ready to be built with Maven, the next step is to install Maven.

(already done)
[i500695@C02X632CJGH6:2020-01-19 17:45:24:~/work/code/java/helloWorld:]2042$ mvn -v
Apache Maven 3.6.2 (40f52333136460af0dc0d7232c0dc0bcf0d9e117; 2019-08-27T18:06:16+03:00)
Maven home: /usr/local/Cellar/maven/3.6.2/libexec
Java version: 13.0.1, vendor: Oracle Corporation, runtime: /Library/Java/JavaVirtualMachines/openjdk-13.0.1.jdk/Contents/Home
Default locale: en_IL, platform encoding: UTF-8
OS name: "mac os x", version: "10.15.2", arch: "x86_64", family: "mac"

Define a simple Maven build

Now that Maven is installed, you need to create a Maven project definition. Maven projects are defined with an XML file named pom.xml. Among other things, this file gives the project’s name, version, and dependencies that it has on external libraries.

Create a file named pom.xml at the root of the project (i.e. put it next to the src folder) and give it the following contents:

pom.xml

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.springframework</groupId>
    <artifactId>gs-maven</artifactId>
    <packaging>jar</packaging>
    <version>0.1.0</version>

    <properties>
        <maven.compiler.source>1.8</maven.compiler.source>
        <maven.compiler.target>1.8</maven.compiler.target>
    </properties>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>2.1</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                        <configuration>
                            <transformers>
                                <transformer
                                    implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                                    <mainClass>hello.HelloWorld</mainClass>
                                </transformer>
                            </transformers>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>

With the exception of the optional <packaging> element, this is the simplest possible pom.xml file necessary to build a Java project. It includes the following details of the project configuration:

<modelVersion>. POM model version (always 4.0.0).
<groupId>. Group or organization that the project belongs to. Often expressed as an inverted domain name.
<artifactId>. Name to be given to the project’s library artifact (for example, the name of its JAR or WAR file).
<version>. Version of the project that is being built.
<packaging> - How the project should be packaged. Defaults to "jar" for JAR file packaging. Use "war" for WAR file packaging.
When it comes to choosing a versioning scheme, Spring recommends the semantic versioning approach.
At this point you have a minimal, yet capable Maven project defined.

[i500695@C02X632CJGH6:2020-01-19 17:48:26:~/work/code/java/helloWorld:]2046$ mvn compile
[INFO] Scanning for projects...
[INFO] 
[INFO] --------------------< org.springframework:gs-maven >--------------------
[INFO] Building gs-maven 0.1.0
[INFO] --------------------------------[ jar ]---------------------------------
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ gs-maven ---
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] skip non existing resourceDirectory /Users/i500695/work/code/java/helloWorld/src/main/resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ gs-maven ---
[INFO] Changes detected - recompiling the module!
[WARNING] File encoding has not been set, using platform encoding UTF-8, i.e. build is platform dependent!
[INFO] Compiling 2 source files to /Users/i500695/work/code/java/helloWorld/target/classes
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  1.082 s
[INFO] Finished at: 2020-01-19T17:48:34+02:00
[INFO] ------------------------------------------------------------------------
[i500695@C02X632CJGH6:2020-01-19 17:48:34:~/work/code/java/helloWorld:]2047$ find . -name '*.class'
./target/classes/hello/HelloWorld.class
./target/classes/hello/Greeter.class

$ mvn package
[i500695@C02X632CJGH6:2020-01-19 17:51:00:~/work/code/java/helloWorld:]2051$ java -jar target/HelloWorld-0.1.0.jar 
Hello world!

Maven also maintains a repository of dependencies on your local machine (usually in a .m2/repository directory in your home directory) for quick access to project dependencies. If you’d like to install your project’s JAR file to that local repository, then you should invoke the install goal:

mvn install
The install goal will compile, test, and package your project’s code and then copy it into the local dependency repository, ready for another project to reference it as a dependency.

Speaking of dependencies, now it’s time to declare dependencies in the Maven build.

Declare Dependencies

The simple Hello World sample is completely self-contained and does not depend on any additional libraries. Most applications, however, depend on external libraries to handle common and complex functionality.

For example, suppose that in addition to saying "Hello World!", you want the application to print the current date and time. While you could use the date and time facilities in the native Java libraries, you can make things more interesting by using the Joda Time libraries.

First, change HelloWorld.java to look like this:

src/main/java/hello/HelloWorld.java

package hello;

import org.joda.time.LocalTime;

public class HelloWorld {
  public static void main(String[] args) {
    LocalTime currentTime = new LocalTime();
    System.out.println("The current local time is: " + currentTime);
    Greeter greeter = new Greeter();
    System.out.println(greeter.sayHello());
  }
}
Here HelloWorld uses Joda Time’s LocalTime class to get and print the current time.

If you were to run mvn compile to build the project now, the build would fail because you’ve not declared Joda Time as a compile dependency in the build.
ex:
[i500695@C02X632CJGH6:2020-01-19 17:54:17:~/work/code/java/helloWorld:]2053$ mvn compile
[INFO] Scanning for projects...
[INFO] 
[INFO] -------------------------< com.sap:HelloWorld >-------------------------
[INFO] Building HelloWorld 0.1.0
[INFO] --------------------------------[ jar ]---------------------------------
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ HelloWorld ---
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] skip non existing resourceDirectory /Users/i500695/work/code/java/helloWorld/src/main/resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ HelloWorld ---
[INFO] Changes detected - recompiling the module!
[WARNING] File encoding has not been set, using platform encoding UTF-8, i.e. build is platform dependent!
[INFO] Compiling 2 source files to /Users/i500695/work/code/java/helloWorld/target/classes
[INFO] -------------------------------------------------------------
[ERROR] COMPILATION ERROR : 
[INFO] -------------------------------------------------------------
[ERROR] /Users/i500695/work/code/java/helloWorld/src/main/java/hello/HelloWorld.java:[3,21] package org.joda.time does not exist
[ERROR] /Users/i500695/work/code/java/helloWorld/src/main/java/hello/HelloWorld.java:[7,5] cannot find symbol
...


You can fix that by adding the following lines to pom.xml (within the <project> element):

<dependencies>
		<dependency>
			<groupId>joda-time</groupId>
			<artifactId>joda-time</artifactId>
			<version>2.9.2</version>
		</dependency>
</dependencies>
This block of XML declares a list of dependencies for the project. Specifically, it declares a single dependency for the Joda Time library. Within the <dependency> element, the dependency coordinates are defined by three sub-elements:

<groupId> - The group or organization that the dependency belongs to.
<artifactId> - The library that is required.
<version> - The specific version of the library that is required.
By default, all dependencies are scoped as compile dependencies. That is, they should be available at compile-time (and if you were building a WAR file, including in the /WEB-INF/libs folder of the WAR). Additionally, you may specify a <scope> element to specify one of the following scopes:

provided - Dependencies that are required for compiling the project code, but that will be provided at runtime by a container running the code (e.g., the Java Servlet API).
test - Dependencies that are used for compiling and running tests, but not required for building or running the project’s runtime code.
Now if you run mvn compile or mvn package, Maven should resolve the Joda Time dependency from the Maven Central repository and the build will be successful.

Write a Test

First add JUnit as a dependency to your pom.xml, in the test scope:

<dependency>
	<groupId>junit</groupId>
	<artifactId>junit</artifactId>
	<version>4.12</version>
	<scope>test</scope>
</dependency>

Note that junit depends on hamcrest, in my case mvn did not resolve that
dependancy b/c I accidently put the test file in src dir.
dependancey, (
$mvn install
...
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (default-compile) on project HelloWorld: Compilation failure: Compilation failure: 
[ERROR] /Users/i500695/work/code/java/helloWorld/src/main/java/hello/GreeterTest.java:[3,27] package org.hamcrest does not exist
)
putting the test file in test/... dir fixes the issue

Then create a test case like this:

src/test/java/hello/GreeterTest.java

package hello;

import static org.hamcrest.CoreMatchers.containsString;
import static org.junit.Assert.*;

import org.junit.Test;

public class GreeterTest {

  private Greeter greeter = new Greeter();

  @Test
  public void greeterSaysHello() {
    assertThat(greeter.sayHello(), containsString("Hello"));
  }

}
Maven uses a plugin called "surefire" to run unit tests. The default configuration of this plugin compiles and runs all classes in src/test/java with a name matching *Test. You can run the tests on the command line like this

mvn test
or just use mvn install step as we already showed above (there is a lifecycle definition where "test" is included as a stage in "install").


        4.1.2 maven 

            4.1.2.1 getting started

                4.1.2.1.1  Create project
Create Java project with below maven command:
mvn archetype:generate
-DgroupId=org.yourcompany.project
-DartifactId=application
Create web project with below maven command:
mvn archetype:generate
-DgroupId=org.yourcompany.project
-DartifactId=application
-DarchetypeArtifactId=maven-archetype-webapp
Create archetype from existing project
mvn archetype:create-from-project

                4.1.2.1.2 . Main phases
clean — delete target directory
validate — validate, if the project is correct
compile — compile source code, classes stored in target/classes
test — run tests
package — take the compiled code and package it in its distributable format, e.g. JAR, WAR
verify — run any checks to verify the package is valid and meets quality criteria
install — install the package into the local repository
deploy — copies the final package to the remote repository


                4.1.2.1.3 . Maven phase commands(Project Build Commands)
clean project: This command will delete target directory
mvn clean
validate project: validate the project is correct and all necessary information is available
mvn validate
compile project: compile source code, classes stored in target/classes
mvn compile
test project: run tests using a suitable unit testing framework
mvn test
package project: take the compiled code and package it in its distributable format, such as a JAR /WAR
mvn package
verify project: run any checks to verify the package is valid and meets quality criteria
mvn verify
install project: install the package into the local repository, for use as a dependency in other projects locally
mvn install
deploy project: done in an integration or release environment, copies the final package to the remote repository for sharing with other developers and projects
mvn deploy

                4.1.2.1.4  Skip running tests
Compiles the tests, but skips running them.
mvn install -DskipTests=true 
Skips compiling the tests and does not run them.
mvn install -Dmaven.test.skip=true 

                4.1.2.1.5 Project Site Generation
Generate site without tests reports (tests are not executed):
mvn site:site
Generate site with unit tests reports:
mvn test site:site
Generate site with unit and integration tests reports:
mvn verify site:site

                4.1.2.1.6 Code quality analysis
Analyse code quality with Sonar:
mvn clean install -DskipTests=true
mvn sonar:sonar
Read Sonar configuration guide.

                4.1.2.1.7 Code coverage reporting
Notice:
It is much more feasible to generate code coverage reports directly from IDE than from Maven. Write test, write code, run coverage for separated test, and check that all important branches are covered.
Generate Clover reports for unit tests:
mvn clover2:setup test clover2:aggregate clover2:clover
Generate clover reports for unit and integration tests:
mvn clover2:setup verify clover2:aggregate clover2:clover
Read Clover configuration guide.

                4.1.2.1.8 Dependency Management
Check dependencies for newer versions:
mvn versions:display-dependency-updates
Check plugins for newer versions:
mvn versions:display-plugin-updates
Check for newer versions defined as properties:
mvn versions:display-property-updates
Display project dependencies:
mvn dependency:tree
Analyze project dependencies:
mvn dependency:analyze

                4.1.2.1.9 Getting Help
Display effective Maven settings:
mvn help:effective-settings
Display effective POM:
mvn help:effective-pom
Display all profiles (from settings.xml and POMs hierarchy):
mvn help:active-profiles
Display plugin goals (for m-compiler-p in the example below):
mvn compiler:help
Display plugin's goal description (for goal compile in m-compiler-p in the example below):
mvn compiler:help -Dgoal=compile -Ddetail

            4.1.2.2 commonly use CLI

generate dependancey tree:  mvn dependency:tree
check updated versions: mvn versions:display-dependency-updates
            4.1.2.3

        4.1.3

    4.2

5. Java basics

    5.1 


6. JDK 5,6

	6.1 Annotations
	Based on: http://java.sun.com/docs/books/tutorial/java/javaOO/annotations.html
		
		6.1.1 Description

    Annotations provide data about a program that is not part of the program itself. They have no direct effect on the operation of the code they annotate.

    Annotations have a number of uses, among them:

        * Information for the compiler  Annotations can be used by the compiler to detect errors or suppress warnings.

        * Compiler-time and deployment-time processing  Software tools can process annotation information to generate code, XML files, and so forth.

        * Runtime processing  Some annotations are available to be examined at runtime.

    Annotations can be applied to a program's declarations of classes, fields, methods, and other program elements.

    The annotation appears first, often (by convention) on its own line, and may include elements with named or unnamed values:

        @Author(
           name = "Benjamin Franklin",
           date = "3/27/2003"
        )
        class MyClass() { }

    or

        @SuppressWarnings(value = "unchecked")
        void myMethod() { }

    If there is just one element named "value," then the name may be omitted, as in:

        @SuppressWarnings("unchecked")
        void myMethod() { }

    Also, if an annotation has no elements, the parentheses may be omitted, as in:

        @Override
        void mySuperMethod() { }

		6.1.2 Usage
			
			6.1.2.1 Documentation
    Many annotations replace what would otherwise have been comments in code.

    Suppose that a software group has traditionally begun the body of every class with comments providing important information:

        public class Generation3List extends Generation2List {

           // Author: John Doe
           // Date: 3/17/2002
           // Current revision: 6
           // Last modified: 4/12/2004
           // By: Jane Doe
           // Reviewers: Alice, Bill, Cindy

           // class code goes here

        }

    To add this same metadata with an annotation, you must first define the annotation type. The syntax for doing this is:

        @interface ClassPreamble {
           String author();
           String date();
           int currentRevision() default 1;
           String lastModified() default "N/A";
           String lastModifiedBy() default "N/A";
           String[] reviewers();  // Note use of array
        }

    The annotation type definition looks somewhat like an interface definition where the keyword interface is preceded by the @ character (@ = "AT" as in Annotation Type). Annotation types are, in fact, a form of interface, which will be covered in a later lesson. For the moment, you do not need to understand interfaces.

    The body of the annotation definition above contains annotation type element declarations, which look a lot like methods. Note that they may define optional default values.

    Once the annotation type has been defined, you can use annotations of that type, with the values filled in, like this:

        @ClassPreamble (
           author = "John Doe",
           date = "3/17/2002",
           currentRevision = 6,
           lastModified = "4/12/2004",
           lastModifiedBy = "Jane Doe"
           reviewers = {"Alice", "Bob", "Cindy"} // Note array notation
        )
        public class Generation3List extends Generation2List {

        // class code goes here

        }

        Note: To make the information in @ClassPreamble appear in Javadoc-generated documentation, you must annotate the @ClassPreamble definition itself with the @Documented annotation:

            import java.lang.annotation.*; // import this to use @Documented

            @Documented
            @interface ClassPreamble {

               // Annotation element definitions
               
            }

    Annotations Used by the Compiler
    There are three annotation types that are predefined by the language specification itself: @Deprecated, @Override, and @SuppressWarnings.

    @Deprecatedthe @Deprecated annotation indicates that the marked element is deprecated and should no longer be used. The compiler generates a warning whenever a program uses a method, class, or field with the @Deprecated annotation. When an element is deprecated, it should also be documented using the Javadoc @deprecated tag, as shown in the following example. The use of the "@" symbol in both Javadoc comments and in annotations is not coincidentalthey are related conceptually. Also, note that the Javadoc tag starts with a lowercase "d" and the annotation starts with an uppercase "D".

           // Javadoc comment follows
            /**
             * @deprecated
             * explanation of why it was deprecated
             */
            @Deprecated
            static void deprecatedMethod() { }
        }

    @Overridethe @Override annotation informs the compiler that the element is meant to override an element declared in a superclass (overriding methods will be discussed in the the lesson titled "Interfaces and Inheritance").

           // mark method as a superclass method
           // that has been overridden
           @Override 
           int overriddenMethod() { }

    While it's not required to use this annotation when overriding a method, it helps to prevent errors. If a method marked with @Override fails to correctly override a method in one of its superclasses, the compiler generates an error.

    @SuppressWarningsthe @SuppressWarnings annotation tells the compiler to suppress specific warnings that it would otherwise generate. In the example below, a deprecated method is used and the compiler would normally generate a warning. In this case, however, the annotation causes the warning to be suppressed.

           // use a deprecated method and tell 
           // compiler not to generate a warning
           @SuppressWarnings("deprecation")
            void useDeprecatedMethod() {
                objectOne.deprecatedMethod(); //deprecation warning - suppressed
            }

    Every compiler warning belongs to a category. The Java Language Specification lists two categories: "deprecation" and "unchecked." The "unchecked" warning can occur when interfacing with legacy code written before the advent of generics (discussed in the lesson titled "Generics"). To suppress more than one category of warnings, use the following syntax:

        @SuppressWarnings({"unchecked", "deprecation"})

			6.1.2.2 Annotation Processing

    The more advanced uses of annotations include writing an annotation processor that can read a Java program and take actions based on its annotations. It might, for example, generate auxiliary source code, relieving the programmer of having to create boilerplate code that always follows predictable patterns. To facilitate this task, release 5.0 of the JDK includes an annotation processing tool, called apt. In release 6 of the JDK, the functionality of apt is a standard part of the Java compiler.

    To make annotation information available at runtime, the annotation type itself must be annotated with @Retention(RetentionPolicy.RUNTIME), as follows:

        import java.lang.annotation.*; 

        @Retention(RetentionPolicy.RUNTIME)
        @interface AnnotationForRuntime {

           // Elements that give information
           // for runtime processing
           
        }

	6.2 Enums, enumaration
	An enum type is a type whose fields consist of a fixed set of constants. Common examples include compass directions (values of NORTH, SOUTH, EAST, and WEST) and the days of the week.

Because they are constants, the names of an enum type's fields are in uppercase letters.

In the Java programming language, you define an enum type by using the enum keyword. For example, you would specify a days-of-the-week enum type as:

    public enum Day {
        SUNDAY, MONDAY, TUESDAY, WEDNESDAY, 
        THURSDAY, FRIDAY, SATURDAY 
    }

You should use enum types any time you need to represent a fixed set of constants. That includes natural enum types such as the planets in our solar system and data sets where you know all possible values at compile timefor example, the choices on a menu, command line flags, and so on.

Here is some code that shows you how to use the Day enum defined above:

    public class EnumTest {
    	Day day;
    	
    	public EnumTest(Day day) {
    		this.day = day;
    	}
    	
    	public void tellItLikeItIs() {
    		switch (day) {
    			case MONDAY: System.out.println("Mondays are bad.");
    					     break;
    					
    			case FRIDAY: System.out.println("Fridays are better.");
    					     break;
    					     
    			case SATURDAY:
    			case SUNDAY: System.out.println("Weekends are best.");
    					     break;
    					     
    			default:	 System.out.println("Midweek days are so-so.");
    					     break;
    		}
    	}
    	
    	public static void main(String[] args) {
    		EnumTest firstDay = new EnumTest(Day.MONDAY);
    		firstDay.tellItLikeItIs();
    		EnumTest thirdDay = new EnumTest(Day.WEDNESDAY);
    		thirdDay.tellItLikeItIs();
    		EnumTest fifthDay = new EnumTest(Day.FRIDAY);
    		fifthDay.tellItLikeItIs();
    		EnumTest sixthDay = new EnumTest(Day.SATURDAY);
    		sixthDay.tellItLikeItIs();
    		EnumTest seventhDay = new EnumTest(Day.SUNDAY);
    		seventhDay.tellItLikeItIs();
    		
    		
    	}
    }


The output is:

    Mondays are bad.
    Midweek days are so-so.
    Fridays are better.
    Weekends are best.
    Weekends are best.

Java programming language enum types are much more powerful than their counterparts in other languages. The enum declaration defines a class (called an enum type). The enum class body can include methods and other fields. The compiler automatically adds some special methods when it creates an enum. For example, they have a static values method that returns an array containing all of the values of the enum in the order they are declared. This method is commonly used in combination with the for-each construct to iterate over the values of an enum type. For example, this code from the Planet class example below iterates over all the planets in the solar system.

    for (Planet p : Planet.values()) {
        System.out.printf("Your weight on %s is %f%n",
                              p, p.surfaceWeight(mass));
    }

    Note: All enums implicitly extend java.lang.Enum. Since Java does not support multiple inheritance, an enum cannot extend anything else. 

In the following example, Planet is an enum type that represents the planets in the solar system. They are defined with constant mass and radius properties.

Each enum constant is declared with values for the mass and radius parameters. These values are passed to the constructor when the constant is created. Java requires that the constants be defined first, prior to any fields or methods. Also, when there are fields and methods, the list of enum constants must end with a semicolon.

    Note: The constructor for an enum type must be package-private or private access. It automatically creates the constants that are defined at the beginning of the enum body. You cannot invoke an enum constructor yourself. 

In addition to its properties and constructor, Planet has methods that allow you to retrieve the surface gravity and weight of an object on each planet. Here is a sample program that takes your weight on earth (in any unit) and calculates and prints your weight on all of the planets (in the same unit):

    public enum Planet {
        MERCURY (3.303e+23, 2.4397e6),
        VENUS   (4.869e+24, 6.0518e6),
        EARTH   (5.976e+24, 6.37814e6),
        MARS    (6.421e+23, 3.3972e6),
        JUPITER (1.9e+27,   7.1492e7),
        SATURN  (5.688e+26, 6.0268e7),
        URANUS  (8.686e+25, 2.5559e7),
        NEPTUNE (1.024e+26, 2.4746e7);

        private final double mass;   // in kilograms
        private final double radius; // in meters
        Planet(double mass, double radius) {
            this.mass = mass;
            this.radius = radius;
        }
        private double mass()   { return mass; }
        private double radius() { return radius; }

        // universal gravitational constant  (m3 kg-1 s-2)
        public static final double G = 6.67300E-11;

        double surfaceGravity() {
            return G * mass / (radius * radius);
        }
        double surfaceWeight(double otherMass) {
            return otherMass * surfaceGravity();
        }
        public static void main(String[] args) {
            double earthWeight = Double.parseDouble(args[0]);
            double mass = earthWeight/EARTH.surfaceGravity();
            for (Planet p : Planet.values())
               System.out.printf("Your weight on %s is %f%n",
                                 p, p.surfaceWeight(mass));
        }
    }

If you run Planet.class from the command line with an argument of 175, you get this output:

    $ java Planet 175
    Your weight on MERCURY is 66.107583
    Your weight on VENUS is 158.374842
    Your weight on EARTH is 175.000000
    Your weight on MARS is 66.279007
    Your weight on JUPITER is 442.847567
    Your weight on SATURN is 186.552719
    Your weight on URANUS is 158.397260
    Your weight on NEPTUNE is 199.207413

    6.3 Nested Classes

    The Java programming language allows you to define a class within another class. Such a class is called a nested class and is illustrated here:

        class OuterClass {
            ...
            class NestedClass {
                ...
            }
        }

    A nested class is a member of its enclosing class and, as such, has access to other members of the enclosing class, even if they are declared private. As a member of OuterClass, a nested class can be declared private, public, protected, or package private. (Recall that outer classes can only be declared public or package private.)

        Terminology: Nested classes are divided into two categories: static and non-static. Nested classes that are declared static are simply called static nested classes. Non-static nested classes are called inner classes. 

        class OuterClass {
            ...
            static class StaticNestedClass {
                ...
            }
            class InnerClass {
                ...
            }
        }

    Why Use Nested Classes?
    There are several compelling reasons for using nested classes, among them:

        * It is a way of logically grouping classes that are only used in one place.
        * It increases encapsulation.
        * Nested classes can lead to more readable and maintainable code.

    Logical grouping of classesIf a class is useful to only one other class, then it is logical to embed it in that class and keep the two together. Nesting such "helper classes" makes their package more streamlined.

    Increased encapsulationConsider two top-level classes, A and B, where B needs access to members of A that would otherwise be declared private. By hiding class B within class A, A's members can be declared private and B can access them. In addition, B itself can be hidden from the outside world.

    More readable, maintainable codeNesting small classes within top-level classes places the code closer to where it is used.
    Static Nested Classes
    As with class methods and variables, a static nested class is associated with its outer class. And like static class methods, a static nested class cannot refer directly to instance variables or methods defined in its enclosing class  it can use them only through an object reference.

        Note: A static nested class interacts with the instance members of its outer class (and other classes) just like any other top-level class. In effect, a static nested class is behaviorally a top-level class that has been nested in another top-level class for packaging convenience. 

    Static nested classes are accessed using the enclosing class name:

        OuterClass.StaticNestedClass

    For example, to create an object for the static nested class, use this syntax:

        OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();

    Inner Classes
    As with instance methods and variables, an inner class is associated with an instance of its enclosing class and has direct access to that object's methods and fields. Also, because an inner class is associated with an instance, it cannot define any static members itself.

    Objects that are instances of an inner class exist within an instance of the outer class. Consider the following classes:

        class OuterClass {
            ...
            class InnerClass {
                ...
            }
        }


    An instance of InnerClass can exist only within an instance of OuterClass and has direct access to the methods and fields of its enclosing instance. The next figure illustrates this idea.

    An InnerClass Exists Within an Instance of OuterClass.

    An InnerClass Exists Within an Instance of OuterClass

    To instantiate an inner class, you must first instantiate the outer class. Then, create the inner object within the outer object with this syntax:

        OuterClass.InnerClass innerObject = outerObject.new InnerClass();

    Additionally, there are two special kinds of inner classes: local classes and anonymous classes (also called anonymous inner classes). Both of these will be discussed briefly in the next section. 


	6.2.1 Inner Class Example

    To see an inner class in use, consider a simple stack of integers. Stacks, which are a common data structure in programming, are well-named they are like a "stack" of dishes. When you add a dish to the stack, you put it on top; when you remove one, you remove it from the top. The acronym for this is LIFO (last in, first out). Dishes on the bottom of the stack may stay there quite a long time while the upper dishes come and go.

    The StackOfInts class below is implemented as an array. When you add an integer (called "pushing"), it goes into the first available empty element. When you remove an integer (called "popping"), you remove the last integer in the array.

    The StackOfInts class below (an application) consists of:

        * The StackOfInts outer class, which includes methods to push an integer onto the stack, pop an integer off the stack, and test to see if the stack is empty.
        * The StepThrough inner class, which is similar to a standard Java iterator. Iterators are used to step through a data structure and typically have methods to test for the last element, retrieve the current element, and move to the next element.
        * A main method that instantiates a StackOfInts array (stackOne) and fills it with integers (0, 2, 4, etc.), then instantiates a StepThrough object (iterator) and uses it to print out the contents of stackOne.

        public class StackOfInts {
        	
        	private int[] stack;
        	private int next = 0;  // index of last item in stack + 1
        	
        	public StackOfInts(int size) {
        		//create an array large enough to hold the stack
        		stack = new int[size];
        	}
        	
        	public void push(int on) {
        		if (next < stack.length)
        		   stack[next++] = on;
        	}
        	public boolean isEmpty() {
        		return (next == 0);
        	}
        	
        	public int pop(){
        		if (!isEmpty()) 
        		   return stack[--next]; // top item on stack
        		else
        		   return 0;
        	}
        	
        	public int getStackSize() {
        		return next;
        	}
        	
        	private class StepThrough { 		
        		// start stepping through at i=0
        		private int i = 0; 
        		
        		// increment index
        		public void increment() {
        			if ( i < stack.length)
        			   i++;
        		}
        		
        		// retrieve current element
        		public int current() {
        			return stack[i];
        		}
        		
        		// last element on stack?
        		public boolean isLast(){
        			if (i == getStackSize() - 1)
        			   return true;
        			else
        			   return false;
        		}
        	}
        	
        	public StepThrough stepThrough() {
        		return new StepThrough();
        	}
        	
        	public static void main(String[] args) {
        		
        		// instantiate outer class as "stackOne"
        		StackOfInts stackOne = new StackOfInts(15);
        		
        		// populate stackOne
        		for (int j = 0 ; j < 15 ; j++) {
        			stackOne.push(2*j);
        		}
        		
        		// instantiate inner class as "iterator"
        		StepThrough iterator = stackOne.stepThrough();
        		
        		// print out stackOne[i], one per line
        		while(!iterator.isLast()) {
        			System.out.print(iterator.current() + " ");
        			iterator.increment();
        		}
        		System.out.println();
        		
        	}
        	
        }

    The output is:

        0 2 4 6 8 10 12 14 16 18 20 22 24 26 

    Note that the StepThrough class refers directly to the stack instance variable of StackOfInts.

    Inner classes are used primarily to implement helper classes like the one shown in this example. If you plan on handling user-interface events, you'll need to know about using inner classes because the event-handling mechanism makes extensive use of them.

    Local and Anonymous Inner Classes
    There are two additional types of inner classes. You can declare an inner class within the body of a method. Such a class is known as a local inner class. You can also declare an inner class within the body of a method without naming it. These classes are known as anonymous inner classes. You will encounter such classes in advanced Java programming.

    Modifiers
    You can use the same modifiers for inner classes that you use for other members of the outer class. For example, you can use the access specifiers  private, public, and protected  to restrict access to inner classes, just as you do to other class members. 

    6.4 generics

	6.4.1 Article: Using and Programming Generics in J2SE 5.0
	 
By Qusay H. Mahmoud, October 2004 	  	

A Java collection is a flexible data structure that can hold heterogeneous objects where the elements may have any reference type. It is your responsibility, however, to keep track of what types of objects your collections contain. As an example, consider adding an int to a collection; since you cannot have collections of primitive data types you must convert the int to the corresponding reference type (i.e. Integer) before storing it in the collection. Now, when the element is extracted from the collection an Object is returned that must be cast to an Integer in order to ensure type safety. All this makes Java programs unnecessarily hard to read and maintain, and are more likely to fail with runtime errors.

If the compiler could keep track of the element type, you do not need to keep track of what collections you have and the need for casting would be eliminated. This would make programs easier to read and maintain, and less likely to fail at runtime. J2SE 5.0 has added a new core language feature known as generics (also known as parameterized types), that provides compile-time type safety for collections and eliminate the drudgery of casting. The effort of adding generics to Java is led by Sun Microsystems as JSR 14 under the Java Community Process (JCP).

Generics are one of the most frequently requested language extensions to Java, and they have been finally added in J2SE 5.0. This article provides an introduction to programming with generics.
The Need for Generics

The motivation for adding generics to the Java programming language stems from the lack of information about a collection's element type, the need for developers to keep track of what type of elements collections contain, and the need for casts all over the place. Using generics, a collection is no longer treated as a list of Object references, but you would be able to differentiate between a collection of references to Integers and collection of references to Bytes. A collection with a generic type has a type parameter that specifies the element type to be stored in the collection.

As an example, consider the following segment of code that creates a linked list and adds an element to the list:

LinkedList list = new LinkedList();
list.add(new Integer(1));
Integer num = (Integer) list.get(0);


As you can see, when an element is extracted from the list it must be cast. The casting is safe as it will be checked at runtime, but if you cast to a type that is different from, and not a supertype of, the extracted type then a runtime exception, ClassCastException will be thrown.

Using generic types, the previous segment of code can be written as follows:

LinkedList<Integer> list = new LinkedList<Integer>();
list.add(new Integer(1));
Integer num = list.get(0);


Here we say that LinkedList is a generic class that takes a type parameter, Integer in this case.

As you can see, you no longer need to cast to an Integer since the get() method would return a reference to an object of a specific type (Integer in this case). If you were to assign an extracted element to a different type, the error would be at compile-time instead of run-time. This early static checking increases the type safety of the Java language.

To reduce the clutter, the above example can be rewritten as follows...using autoboxing:

LinkedList<Integer> list = new LinkedList<Integer>();
list.add(1);
int num = list.get(0);


As a complete example, consider the following class, Ex1, which creates a collection of two Strings and one Integer, and then prints out the collection:

Ex1.java

import java.util.*;

public class Ex1 {

  private void testCollection() {
    List list = new ArrayList();
    list.add(new String("Hello world!"));
    list.add(new String("Good bye!"));
    list.add(new Integer(95));
    printCollection(list);
  }

  private void printCollection(Collection c) {
    Iterator i = c.iterator();
    while(i.hasNext()) {
      String item = (String) i.next();
      System.out.println("Item: "+item);
    }
  }

  public static void main(String argv[]) {
    Ex1 e = new Ex1();
    e.testCollection();
  }
}


Again, an explicit cast is required in the printCollection method. This class compiles fine, but throws a CLassCastException at runtime as it attempts to cast an Integer to a String:

Item: Hello world!
Item: Good bye!
Exception in thread "main" java.lang.ClassCastException: java.lang.Integer
        at Ex1.printCollection(Ex1.java:16)
        at Ex1.testCollection(Ex1.java:10)
        at Ex1.main(Ex1.java:23)


Using Generics

Using generics, the Ex1 class above can be written as follows:

Ex2.java

import java.util.*;

public class Ex2 {

  private void testCollection() {
    List<String> list = new ArrayList<String>();
    list.add(new String("Hello world!"));
    list.add(new String("Good bye!"));
    list.add(new Integer(95));
    printCollection(list);
  }

  private void printCollection(Collection c) {
    Iterator<String> i = c.iterator();
    while(i.hasNext()) {
      System.out.println("Item: "+i.next());
    }
  }

  public static void main(String argv[]) {
    Ex2 e = new Ex2();
    e.testCollection();
  }
}


Now, if you try to compile this code, a compile-time error will be produced informing you that you cannot add an Integer to a collection of Strings. Therefore, generics enable more compile-time type checking and therefore mismatch errors are caught at compile-time rather than at run-time.

You may have already noticed the new syntax used to create an instance of ArrayList (List<String> list = new ArrayList<String>()). ArrayList is now a parameterized type. A parameterized type consists of a class or interface name E and a parameter section <T1, T2, ..., Tn>, which must match the number of declared parameters of E, and each actual parameter must be a subtype of the formal parameter's bound types. The following segment of code shows parts of the new class definition for ArrayList:

public class ArrayList<E> extends AbstractList<E> implements List<E>, 
    RandomAccess, Cloneable, Serializable {
   // ...
}


Here E is a type variable, which is an unqualified identifier. It simply acts as a placeholder for a type to be defined when the list is used.
Implementing Generic Types

In addition to using generic types, you can implement your own. A generic type has one or more type parameters. Here is an example with only one type parameter called E. A parameterized type must be a reference type, and therefore primitive types are not allowed to be parameterized types.

interface List<E> {
   void add(E x);
   Iterator<E> iterator();
}

interface Iterator<E> {
   E next();
   boolean hasNext();
}


class LinkedList<E> implements List<E> {
   // implementation   
}


Here, E represents the type of elements contained in the collection. Think of E as a placeholder that will be replaced by a concrete type. For example, if you write LinkedList<String> then E will be replaced by String.

In some of your code you may need to invoke methods of the element type, such as Object's hashCode() and equals(). Here is an example that takes two type parameters:

class HashMap<K, V> extends AbstractMap<K, V> implements Map<K, V> {

   // ...

   public V get(Object k) {
      ...
      int hash = k.hashCode();  
      ...
   }
   // ...   
}


The important thing to note is that you are required to replace the type variables K and V by concrete types that are subtypes of Object.
Generic Methods

Genericity is not limited to classes and interfaces, you can define generic methods. Static methods, nonstatic methods, and constructors can all be parameterized in almost the same way as for classes and interfaces, but the syntax is a bit different. Generic methods are also invoked in the same way as non-generic methods.

Before we see an example of a generics method, consider the following segment of code that prints out all the elements in a collection:

public void printCollection(Collection c) {
   Iterator i = c.iterator();
   for(int k = 0;k<c.size();k++) {
     System.out.println(i.next());
   }
}


Using generics, this can be re-written as follows. Note that the Collection<?> is the collection of an unknown type.

void printCollection(Collection<?> c) {
   for(Object o:c) {
      System.out.println(o);
   }
}


This example uses a feature of generics known as wildcards.
Wildcards

There are three types of wildcards:

   1. "? extends Type": Denotes a family of subtypes of type Type. This is the most useful wildcard
   2. "? super Type": Denotes a family of supertypes of type Type
   3. "?": Denotes the set of all types or any 

As an example of using wildcards, consider a draw() method that should be capable of drawing any shape such as circle, rectangle, and triangle. The implementation may look something like this. Here Shape is an abstract class with three subclasses: Circle, Rectangle, and Triangle.

public void draw(List<Shape> shape) {
  for(Shape s: shape) {
    s.draw(this);
  }
}


It is worth noting that the draw() method can only be called on lists of Shape and cannot be called on a list of Circle, Rectangle, and Triangle for example. In order to have the method accept any kind of shape, it should be written as follows:

public void draw(List<? extends Shape> shape) {
   // rest of the code is the same
}


Here is another example of a generics method that uses wildcards to sort a list into ascending order. Basically, all elements in the list must implement the Comparable interface.

public static <T extends Comparable<? super T>> void sort(List<T> list) {
   Object a[] = list.toArray();
   Arrays.sort(a);
   ListIterator<T> i = list.listIterator();
   for(int j=0; j<a.length; j++) {
      i.index();
      i.set((T)a[j]);
   }
}


Changes to the Java Specification, JVM, and APIs

In order to support generic types, some modifications are necessary to the Java programming language, the Java virtual machine1, and the Java APIs. The notable changes to the Java APIs are related to the Collection hierarchy in the java.util package, changes to the java.lang.Class class, and the java.lang.reflect package so that it is possible to examine a type, method, constructor or field declaration and obtain generic type information. If you like to learn about the exact changes, please see JSR 14: Adding Generics to the Java Programming Language.
Behind the Scenes

Generics are implemented by the Java compiler as a front-end conversion called erasure, which is the process of translating or rewriting code that uses generics into non-generic code (that is, maps the new syntax to the current JVM specification). In other words, this conversion erases all generic type information; all information between angle brackets is erased. For example, LinkedList<Integer> will become LinkedList. Uses of other type variables are replaced by the upper bound of the type variable (for example, Object), and when the resulting code is not type correct, a cast to the appropriate type is inserted.
Java Generics vs. C++ Templates

While generics look like the C++ templates, it is important to note that they are not the same. Generics simply provide compile-time type safety and eliminate the need for casts. The main difference is encapsulation: errors are flagged where they occur and not later at some use site, and source code is not exposed to clients. Generics use a technique known as type erasure as described above, and the compiler keeps track of the generics internally, and all instances use the same class file at compile/run time.

A C++ template on the other hand is just a fancy macro processor; whenever a template class is instantiated with a new class, the entire code for the class is reproduced and recompiled for the new class.
Conclusion

Generics are a new core feature in J2SE 5.0, and a major addition to the core language. This feature provides a useful abstract and compile-time type safety for collections and eliminates the drudgery of casting. This article provided an overview and introduction to Java generics, and showed how to use generics as well as write your own. The examples provided in this article demonstrate how useful this new core feature is. 

7. Install

	7.1 Linux
a. http://www.oracle.com/technetwork/java/javase/install-linux-self-extracting-138783.html
Installation Instructions
This procedure installs the Java Development Kit (JDK) for 32-bit Linux, using a self-extracting binary file. The JDK download includes the Java SE Runtime Environment (JRE) – you do not have to download the JRE separately.

For RPM-based Linux distributions, like Red Hat or SuSE, refer to the RPM installation instructions.

The name of the downloaded file has the following format:

    jdk-6u
            
<version>-linux-i586.bin
          
<version>
    jdk-6u18-linux-i586.bin
To install, download this file and use the following instructions.


a1. Download and check the download file size. 
You can download to any directory that you can write to.

This bundle can be installed by anyone (not only root users), in any location that the user can write to. However, only the root user can displace the system version of the Java platform supplied by Linux.

a2. Make sure that execute permissions are set
Run this command: 
% chmod a+x jdk-6u <version>-linux-i586.bin
a3. Change directory to the location where you would like the files to be installed.

The next step installs the JDK into the current directory.
Note, on my box its /usr/java

a4. Run the self-extracting binary.

Execute the downloaded file, prepended by the path to it. For example, if the file is in the current directory, prepend it with " ./" (necessary if " ." is not in the PATH environment variable):
% ./jdk-6u <version>-linux-i586.bin

b. create symbolic links
[yizaq@yizaq-lnx:Thu Dec 02:/usr/java]$ sudo rm /usr/bin/java /usr/bin/javac
[yizaq@yizaq-lnx:Thu Dec 02:/usr/java]$ sudo ln -s /usr/java/jdk1.6.0_22/bin/java   /usr/bin/java
[yizaq@yizaq-lnx:Thu Dec 02:/usr/java]$ ls -l /usr/bin/java
lrwxrwxrwx  1 root root 30 Dec  2 17:46 /usr/bin/java -> /usr/java/jdk1.6.0_22/bin/java*
[yizaq@yizaq-lnx:Thu Dec 02:/usr/java]$ sudo ln -s /usr/java/jdk1.6.0_22/bin/javac   /usr/bin/javac
[yizaq@yizaq-lnx:Thu Dec 02:/usr/java]$ java -version
java version "1.6.0_22"
Java(TM) SE Runtime Environment (build 1.6.0_22-b04)
Java HotSpot(TM) Server VM (build 17.1-b03, mixed mode)

c. modify Environment variables
[yizaq@yizaq-lnx:Thu Dec 02:/view/yizaq__yizaq.PI_Rest.int.acs5_0.lx/vob/nm_acs/acs/mgmt]$ grep JAVA_HOME ~/.bashrc 
PATH=${PATH}:/auto/cwtools/perl/focus/bin/lnx/:/usr/atria/bin/:/sbin/:/vob/enm_jdk/maven-2.0.9/bin:JAVA_HOME/:auto/cwtools/perl/focus/bin/lnx:/usr/atria/bin:
JAVA_HOME=/usr/java/jdk1.5.0_10; export JAVA_HOME;
[yizaq@yizaq-lnx:Thu Dec 02:/view/yizaq__yizaq.PI_Rest.int.acs5_0.lx/vob/nm_acs/acs/mgmt]$ ed !$
ed ~/.bashrc
1510
/jdk1.5.0_10
JAVA_HOME=/usr/java/jdk1.5.0_10; export JAVA_HOME;
s/jdk1.5.0_10/jdk1.6.0_22/
p
JAVA_HOME=/usr/java/jdk1.6.0_22; export JAVA_HOME;
w
q
1510

d.  Fix GTK fonts issue
[yizaq@yizaq-lnx:Sun Dec 05:/usr/share/fonts]$ eclipse

** (Eclipse:8821): WARNING **: Cannot open font file for font Lucida Sans 10

** (Eclipse:8821): WARNING **: Cannot open fallback font, nothing to do
[yizaq@yizaq-lnx:Sun Dec 05:/usr/share/fonts]$ locate Lucida
/usr/java/jdk1.6.0_22/jre/lib/fonts/LucidaSansDemiBold.ttf
/usr/java/jdk1.6.0_22/jre/lib/fonts/LucidaTypewriterBold.ttf
/usr/java/jdk1.6.0_22/jre/lib/fonts/LucidaBrightDemiItalic.ttf
/usr/java/jdk1.6.0_22/jre/lib/fonts/LucidaBrightDemiBold.ttf
/usr/java/jdk1.6.0_22/jre/lib/fonts/LucidaTypewriterRegular.ttf
/usr/java/jdk1.6.0_22/jre/lib/fonts/LucidaBrightRegular.ttf
/usr/java/jdk1.6.0_22/jre/lib/fonts/LucidaBrightItalic.ttf
/usr/java/jdk1.6.0_22/jre/lib/fonts/LucidaSansRegular.ttf
/usr/java/jdk1.6.0_22/jre/lib/oblique-fonts/LucidaSansDemiOblique.ttf
/usr/java/jdk1.6.0_22/jre/lib/oblique-fonts/LucidaTypewriterOblique.ttf
/usr/java/jdk1.6.0_22/jre/lib/oblique-fonts/LucidaTypewriterBoldOblique.ttf
/usr/java/jdk1.6.0_22/jre/lib/oblique-fonts/LucidaSansOblique.ttf
[yizaq@yizaq-lnx:Sun Dec 05:/usr/share/fonts]$ sudo mkdir /usr/java/jdk1.5.0_10/
Password:
[yizaq@yizaq-lnx:Sun Dec 05:/usr/share/fonts]$ sudo mkdir /usr/java/jdk1.5.0_10/jre
[yizaq@yizaq-lnx:Sun Dec 05:/usr/share/fonts]$ sudo mkdir /usr/java/jdk1.5.0_10/jre/lib
[yizaq@yizaq-lnx:Sun Dec 05:/usr/share/fonts]$ sudo cp -r /usr/java/jdk1.6.0_22/jre/lib/fonts/ /usr/java/jdk1.5.0_10/jre/lib/

e. Fix vnc server issue (somehow depends on previous jre)
[yizaq@yizaq-lnx:Mon Dec 06:/usr/java/jdk1.5.0_10]$ ln -s ../jdk1.6.0_22/jre/ jre

	7.2 Mac. tags: install java MAC OSX
install via brew:
 brew tap adoptopenjdk/openjdk
 brew install --cask adoptopenjdk8

	7.3
8. Code Snipplets

	8.1 Encoding, utf-8, utf-16
import java.io.ByteArrayInputStream;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;


public class EncodingTester {

	/**
	Name: 
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		String original = new String("A" + "\u00ea" + "\u00f1" + "\u00fc" + "C");
		System.out.println("UTF-16 string:"+original);
		
		try {
			byte[] utf8bytes = original.getBytes("UTF8");
			String utf8str = new String(utf8bytes, "UTF8");
			System.out.println("UTF-8 string:"+utf8str);
			
			InputStreamReader isr = new InputStreamReader(new ByteArrayInputStream(original.getBytes()));
			System.out.println("String enoding is:"+isr.getEncoding());
			isr = new InputStreamReader(new ByteArrayInputStream(utf8str.getBytes()));
			System.out.println("String enoding is:"+isr.getEncoding());
			
		} catch (UnsupportedEncodingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		

	}

}

	8.2

9. Cookbook

	9.1  Files


		9.1.1   read file content java

			9.1.1.1   Reading and writing text files

When reading and writing text files :

    it's almost always a good idea to use buffering (default size is 8K)
    it's often possible to use references to abstract base classes, instead of references to specific concrete classes
    there is always a need to pay attention to exceptions (in particular, IOException and FileNotFoundException)

The close method :

    always needs to be called, or else resources will leak
    will automatically flush the stream, if necessary
    calling close on a "wrapper" stream will automatically call close on its underlying stream
    closing a stream a second time has no consequence
    when called on a Scanner, the close operation only works if the item passed to its constructor implements Closeable. Warning: if you pass a File to a Scanner, you will not be able to close it! Try using a FileReader instead. 

Commonly used items :

    Scanner - allows reading files in a compact way
    BufferedReader - readLine
    BufferedWriter - write + newLine

The FileReader and FileWriter classes are a bit tricky, since they implicitly use the system's default character encoding. If this default is not appropriate (for example, when reading an XML file which specifies its own encoding), the recommended alternatives are, for example :

FileInputStream fis = new FileInputStream("test.txt");
InputStreamReader in = new InputStreamReader(fis, "UTF-8");

FileOutputStream fos = new FileOutputStream("test.txt");
OutputStreamWriter out = new OutputStreamWriter(fos, "UTF-8");

Scanner scanner = new Scanner(file, "UTF-8");

Example 1

Here is a fairly compact example (for JDK 1.5) of reading and writing a text file, using an explicit encoding. If you remove all references to encoding from this class, it will still work -- the system's default encoding will simply be used instead.

import java.io.*;
import java.util.Scanner;

/** 
 Read and write a file using an explicit encoding.
 Removing the encoding from this code will simply cause the 
 system's default encoding to be used instead.  
*/
public final class ReadWriteTextFileWithEncoding {

  /** Requires two arguments - the file name, and the encoding to use.  */
  public static void main(String... aArgs) throws IOException {
    String fileName = aArgs[0];
    String encoding = aArgs[1];
    ReadWriteTextFileWithEncoding test = new ReadWriteTextFileWithEncoding(
      fileName, encoding
    );
    test.write();
    test.read();
  }
  
  /** Constructor. */
  ReadWriteTextFileWithEncoding(String aFileName, String aEncoding){
    fEncoding = aEncoding;
    fFileName = aFileName;
  }
  
  /** Write fixed content to the given file. */
  void write() throws IOException  {
    log("Writing to file named " + fFileName + ". Encoding: " + fEncoding);
    Writer out = new OutputStreamWriter(new FileOutputStream(fFileName), fEncoding);
    try {
      out.write(FIXED_TEXT);
    }
    finally {
      out.close();
    }
  }
  
  /** Read the contents of the given file. */
  void read() throws IOException {
    log("Reading from file.");
    StringBuilder text = new StringBuilder();
    String NL = System.getProperty("line.separator");
    Scanner scanner = new Scanner(new FileInputStream(fFileName), fEncoding);
    try {
      while (scanner.hasNextLine()){
        text.append(scanner.nextLine() + NL);
      }
    }
    finally{
      scanner.close();
    }
    log("Text read in: " + text);
  }
  
  // PRIVATE 
  private final String fFileName;
  private final String fEncoding;
  private final String FIXED_TEXT = "But soft! what code in yonder program breaks?";
  
  private void log(String aMessage){
    System.out.println(aMessage);
  }
}
 



Example 2

This example uses FileReader and FileWriter, which implicitly use the system's default encoding. To make this example compatible with JDK 1.4, just change StringBuilder to StringBuffer:

import java.io.*;

public class ReadWriteTextFile {

  /**
  * Fetch the entire contents of a text file, and return it in a String.
  * This style of implementation does not throw Exceptions to the caller.
  *
  * @param aFile is a file which already exists and can be read.
  */
  static public String getContents(File aFile) {
    //...checks on aFile are elided
    StringBuilder contents = new StringBuilder();
    
    try {
      //use buffering, reading one line at a time
      //FileReader always assumes default encoding is OK!
      BufferedReader input =  new BufferedReader(new FileReader(aFile));
      try {
        String line = null; //not declared within while loop
        /*
        * readLine is a bit quirky :
        * it returns the content of a line MINUS the newline.
        * it returns null only for the END of the stream.
        * it returns an empty String if two newlines appear in a row.
        */
        while (( line = input.readLine()) != null){
          contents.append(line);
          contents.append(System.getProperty("line.separator"));
        }
      }
      finally {
        input.close();
      }
    }
    catch (IOException ex){
      ex.printStackTrace();
    }
    
    return contents.toString();
  }

  /**
  * Change the contents of text file in its entirety, overwriting any
  * existing text.
  *
  * This style of implementation throws all exceptions to the caller.
  *
  * @param aFile is an existing file which can be written to.
  * @throws IllegalArgumentException if param does not comply.
  * @throws FileNotFoundException if the file does not exist.
  * @throws IOException if problem encountered during write.
  */
  static public void setContents(File aFile, String aContents)
                                 throws FileNotFoundException, IOException {
    if (aFile == null) {
      throw new IllegalArgumentException("File should not be null.");
    }
    if (!aFile.exists()) {
      throw new FileNotFoundException ("File does not exist: " + aFile);
    }
    if (!aFile.isFile()) {
      throw new IllegalArgumentException("Should not be a directory: " + aFile);
    }
    if (!aFile.canWrite()) {
      throw new IllegalArgumentException("File cannot be written: " + aFile);
    }

    //use buffering
    Writer output = new BufferedWriter(new FileWriter(aFile));
    try {
      //FileWriter always assumes default encoding is OK!
      output.write( aContents );
    }
    finally {
      output.close();
    }
  }

  /** Simple test harness.   */
  public static void main (String... aArguments) throws IOException {
    File testFile = new File("C:\\Temp\\blah.txt");
    System.out.println("Original file contents: " + getContents(testFile));
    setContents(testFile, "The content of this file has been overwritten...");
    System.out.println("New file contents: " + getContents(testFile));
  }
} 



Example 3

This example demonstrates using Scanner to read a file containing lines of structured data. Each line is then parsed using a second Scanner and a simple delimiter character, used to separate each line into a name-value pair. The Scanner class is used only for reading, not for writing.

import java.io.*;
import java.util.Scanner;

public class ReadWithScanner {

  public static void main(String... aArgs) throws FileNotFoundException {
    ReadWithScanner parser = new ReadWithScanner("C:\\Temp\\test.txt");
    parser.processLineByLine();
    log("Done.");
  }
  
  /**
   Constructor.
   @param aFileName full name of an existing, readable file.
  */
  public ReadWithScanner(String aFileName){
    fFile = new File(aFileName);  
  }
  
  /** Template method that calls {@link #processLine(String)}.  */
  public final void processLineByLine() throws FileNotFoundException {
    //Note that FileReader is used, not File, since File is not Closeable
    Scanner scanner = new Scanner(new FileReader(fFile));
    try {
      //first use a Scanner to get each line
      while ( scanner.hasNextLine() ){
        processLine( scanner.nextLine() );
      }
    }
    finally {
      //ensure the underlying stream is always closed
      //this only has any effect if the item passed to the Scanner
      //constructor implements Closeable (which it does in this case).
      scanner.close();
    }
  }
  
  /** 
   Overridable method for processing lines in different ways.
    
   <P>This simple default implementation expects simple name-value pairs, separated by an 
   '=' sign. Examples of valid input : 
   <tt>height = 167cm</tt>
   <tt>mass =  65kg</tt>
   <tt>disposition =  "grumpy"</tt>
   <tt>this is the name = this is the value</tt>
  */
  protected void processLine(String aLine){
    //use a second Scanner to parse the content of each line 
    Scanner scanner = new Scanner(aLine);
    scanner.useDelimiter("=");
    if ( scanner.hasNext() ){
      String name = scanner.next();
      String value = scanner.next();
      log("Name is : " + quote(name.trim()) + ", and Value is : " + quote(value.trim()) );
    }
    else {
      log("Empty or invalid line. Unable to process.");
    }
    //no need to call scanner.close(), since the source is a String
  }
  
  // PRIVATE 
  private final File fFile;
  
  private static void log(Object aObject){
    System.out.println(String.valueOf(aObject));
  }
  
  private String quote(String aText){
    String QUOTE = "'";
    return QUOTE + aText + QUOTE;
  }
} 



Example run of this class :

Name is : 'height', and Value is : '167cm'
Name is : 'mass', and Value is : '65kg'
Name is : 'disposition', and Value is : '"grumpy"'
Name is : 'this is the name', and Value is : 'this is the value'
Done.


			9.1.1.2 BufferedReader

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class SimpleFileReader {
	public static void main(String[] args) {
		 
		BufferedReader br = null;
 
		try {
 
			String sCurrentLine;
 
			br = new BufferedReader(new FileReader("C:\\license"));
 
			while ((sCurrentLine = br.readLine()) != null) {
				System.out.println(sCurrentLine);
			}
 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				if (br != null)br.close();
			} catch (IOException ex) {
				ex.printStackTrace();
			}
		}
 
	}
}
			9.1.1.3

		9.1.2 Edit files


			9.1.2.1 Java – Edit File Example, Modify File java

File can be appended by File class and other input output stream. To write content in a file in java we need to use java.io package. File class is used to create a file at specific path. We can use either StringBuffer for text and content to store in file. In java we can write file with FileWriter class with BufferedWriter class. write() method is used to create file and write the content in file.

To edit file in java we need to search text which replace with new text. indexOf() method will search text in java and append() method will modify old content in string.

This example will explain how to edit file in java and modify text in file by java.

text file in c drive

Content in this text, abc change xyz with new content by java io package

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;

public class JavaIOEditFileExample {

    public static void main(String[] args) {

        File f=new File("c:\\appendOldFile.txt");

        FileInputStream fs = null;
        InputStreamReader in = null;
        BufferedReader br = null;

        StringBuffer sb = new StringBuffer();

        String textinLine;

        try {
             fs = new FileInputStream(f);
             in = new InputStreamReader(fs);
             br = new BufferedReader(in);

            while(true)
            {
                textinLine=br.readLine();
                if(textinLine==null)
                    break;
                sb.append(textinLine);
            }
              String textToEdit1 = "abc";
              int cnt1 = sb.indexOf(textToEdit1);
              sb.replace(cnt1,cnt1+textToEdit1.length(),"New Append text");

              String textToEdit2 = "xyz";
              int cnt2 = sb.indexOf(textToEdit2);
              sb.replace(cnt2,cnt2+textToEdit2.length(),"Second new edit text");

              fs.close();
              in.close();
              br.close();

            } catch (FileNotFoundException e) {
              e.printStackTrace();
            } catch (IOException e) {
              e.printStackTrace();
            }

            try{
                FileWriter fstream = new FileWriter(f);
                BufferedWriter outobj = new BufferedWriter(fstream);
                outobj.write(sb.toString());
                outobj.close();

            }catch (Exception e){
              System.err.println("Error: " + e.getMessage());
            }
    }
}

Output

Content in this text, New Append text change Second new edit text with new content by java io package

			9.1.2.2

		9.1.3
	9.2


10. IDEs

	10.1 Eclipse

		10.1.1 Quick references

			10.1.1.1 official
Keyboard Shortcuts Eclipse 3.1
Emacs configuration

Edit
Content Assist		Alt+/	In Dialogs and Windows
Context Information		Alt+?		In Windows
Context Information		Shift+Alt+?	In Windows
Context Information		Shift+Ctrl+Space	In Windows
Copy			Alt+W	In Dialogs and Windows
Copy			Ctrl+C	In Dialogs and Windows
Copy			Ctrl+Insert	In Dialogs and Windows
Copy			Esc W	In Dialogs and Windows
Cut			Ctrl+W	In Dialogs and Windows
Cut			Ctrl+X	In Dialogs and Windows
Cut			Shift+Del	In Dialogs and Windows
Delete			Delete		In Windows
Find Previous		Shift+Ctrl+K	Editing Text
Find and Replace		Alt+R		In Windows
Find and Replace		Esc R		In Windows
Incremental Find		Ctrl+J		Editing Text
Incremental Find		Ctrl+S		Editing Text
Incremental Find Reverse	Ctrl+R		Editing Text
Incremental Find Reverse	Shift+Ctrl+J	Editing Text
Paste			Ctrl+Y	In Dialogs and Windows
Paste			Shift+Ins	In Dialogs and Windows
Quick Diff Toggle		Shift+Ctrl+Q	Editing Text
Quick Fix			Ctrl+1		In Windows
Redo			Ctrl+X R		In Windows
Redo			F10		In Windows
Redo			Shift+Ctrl++	In Windows
Restore Last Selection	Shift+Alt+Down	Editing Java Source
Select All			Ctrl+X H	In Dialogs and Windows
Select Enclosing Element	Shift+Alt+Up	Editing Java Source
Select Next Element		Shift+Alt+Right	Editing Java Source
Select Previous Element	Shift+Alt+Left	Editing Java Source
Show Tooltip Description	F2		Editing Java Source
Toggle Insert Mode		Shift+Ctrl+Insert	Editing Text
Undo			Ctrl+X U		In Windows
Undo			F9		In Windows
Undo			Shift+Ctrl+-	In Windows






© 2005 Carsten Ullrich.
Creative Commons Attribution-ShareAlike 2.5 License
http://creativecommons.org/licenses/by-sa/2.5/


File
Close			Ctrl+F4		In Windows
Close			Ctrl+X K		In Windows
Close All			Ctrl+X Ctrl+C	In Windows
Close All			Shift+Ctrl+F4	In Windows
Close All			Shift+Ctrl+W	In Windows
New menu			Shift+Alt+N	In Windows
Print			Alt+F9		In Windows
Print			Esc F9		In Windows
Properties			Alt+Enter		In Windows
Refresh			F5		In Windows
Rename			F2		In Windows
Save			Ctrl+X Ctrl+S	In Windows
Save All			Ctrl+X S		In Windows
Save All			Shift+Ctrl+S	In Windows

Navigate
Backward History		Alt+Left		In Windows
Forward History		Alt+Right		In Windows
Go to Line			Ctrl+L		Editing Text
Go to Line			Ctrl+X G		Editing Text
Go to Matching Bracket	Shift+Ctrl+P	Editing Java Source
Go to Next Member		Shift+Ctrl+Down	Editing Java Source
Go to Previous Member	Shift+Ctrl+Up	Editing Java Source
Last Edit Location		Ctrl+Q		In Windows
Next			Ctrl+.		In Windows
Open Call Hierarchy		Ctrl+Alt+H		In Windows
Open Declaration		F3		In Windows
Open External Javadoc	Shift+F2		In Windows
Open Resource		Shift+Ctrl+R	In Windows
Open Structure		Ctrl+F3		Editing Java Source
Open Type			Shift+Ctrl+T	In Windows
Open Type Hierarchy		F4		In Windows
Open Type in Hierarchy	Shift+Ctrl+H	In Windows
Previous			Ctrl+		In Windows
Quick Hierarchy		Ctrl+T		Editing Java Source
Quick Outline		Ctrl+O		Editing Java Source
Show In menu		Shift+Alt+W	In Windows

Refactor - Java
Change Method Signature	Shift+Alt+C	In Windows
Convert Local Variable to Field	Shift+Alt+F	Editing Java Source
Extract Local Variable		Shift+Alt+L	In Windows
Extract Method		Shift+Alt+M	In Windows
Inline			Shift+Alt+I		In Windows
Move - Refactoring 		Shift+Alt+V	In Windows
Redo - Refactoring 		Shift+Alt+Y	In Windows
Rename - Refactoring 	Shift+Alt+R	In Windows
Show Refactor Quick Menu	Shift+Alt+T	In Windows
Undo - Refactoring		Shift+Alt+Z	In Windows



Run/Debug
Debug Ant Build		Shift+Alt+D Q	In Windows
Debug Eclipse Application	Shift+Alt+D E	In Windows
Debug JUnit Plug-in Test	Shift+Alt+D P	In Windows
Debug JUnit Test		Shift+Alt+D T	In Windows
Debug Java Applet		Shift+Alt+D A	In Windows
Debug Java Application	Shift+Alt+D J	In Windows
Debug Last Launched		F11		In Windows
Debug SWT Application	Shift+Alt+D S	In Windows
Display			Shift+Ctrl+D	In Dialogs&Windows
Display			Shift+Ctrl+V	In Dialogs&Windows
Execute			Ctrl+U		In Windows
Inspect			Shift+Ctrl+I	In Dialogs&Windows
Resume			F8		Debugging
Run Ant Build		Shift+Alt+X Q	In Windows
Run Eclipse Application	Shift+Alt+X E	In Windows
Run JUnit Plug-in Test	Shift+Alt+X P	In Windows
Run JUnit Test		Shift+Alt+X T	In Windows
Run Java Applet		Shift+Alt+X A	In Windows
Run Java Application		Shift+Alt+X J	In Windows
Run Last Launched		Ctrl+F11		In Windows
Run SWT Application		Shift+Alt+X S	In Windows
Step Into			F5		Debugging
Step Into Selection		Ctrl+F5		Debugging
Step Over			F6		Debugging
Step Return		F7		Debugging
Toggle Line Breakpoint	Shift+Ctrl+B	In Windows
Toggle Step Filters		Shift+F5		In Windows

Search
Open Search Dialog		Ctrl+H		In Windows
References in Workspace	Shift+Ctrl+G	In Windows
Show Occurrences in File Quick Menu	Shift+Ctrl+U In Windows


















Source
Add Block Comment		Shift+Ctrl+/	Editing Java Source
Add Import			Shift+Ctrl+M	Editing Java Source
Add Javadoc Comment	Shift+Alt+J	In Windows
Format			Esc Ctrl+F		Editing Java Source
Format			Shift+Ctrl+F	Editing Ant Buildfiles
Indent Line			Ctrl+I		Editing Java Source
Open External Documentation	Shift+F2		Editing Ant Buildfiles
Organize Imports		Shift+Ctrl+O	In Windows
Quick Assist - Assign to field	Ctrl+2 F		Editing Java Source
Quick Assist - Assign to local variable Ctrl+2 L	Editing Java Source
Quick Assist - Rename in file	Ctrl+2 R		Editing Java Source
Remove Block Comment	Shift+Ctrl+\	Editing Java Source
Remove Occurrence Annotations	Shift+Alt+U	Editing Java Source
Rename In File		Shift+Alt+R	Editing Ant Buildfiles
Show Source Quick Menu	Shift+Alt+S	In Windows
Show Tooltip Description	F2		Editing Ant Buildfiles
Toggle Ant Mark Occurrences	Shift+Alt+O	Editing Ant Buildfiles
Toggle Comment		Ctrl+/		Editing Java Source
Toggle Comment		Ctrl+7		Editing Java Source
Toggle Comment		Esc Ctrl+C	Editing Java Source
Toggle Mark Occurrences	Shift+Alt+O	Editing Java Source


Text Editing
Clear Mark			Ctrl+G		Editing Text
Collapse			Ctrl+Numpad_SubtractEditing Text
Copy Lines			Ctrl+Alt+Down	Editing Text
Cut to Beginning of Line	Alt+0 Ctrl+K	Editing Text
Cut to Beginning of Line	Esc 0 Ctrl+K	Editing Text
Cut to End of Line		Ctrl+K		Editing Text
Delete Next		Ctrl+D		Editing Text
Delete Next Word		Alt+D		Editing Text
Delete Next Word		Ctrl+Delete	Editing Text
Delete Next Word		Esc D		Editing Text
Delete Previous Word		Alt+Backspace	Editing Text
Delete Previous Word		Ctrl+Backspace	Editing Text
Delete Previous Word		Esc Backspace	Editing Text
Delete to End of Line		Shift+Ctrl+Delete	Editing Text
Duplicate Lines		Ctrl+Alt+Up	Editing Text
Expand			Ctrl+Numpad_Add	Editing Text
Expand All			Ctrl+Numpad_Multiply Editing Text
Insert Line Above Current Line	Shift+Ctrl+Enter	Editing Text
Insert Line Below Current Line	Shift+Enter	Editing Text
Line Down			Ctrl+N		Editing Text
Line End			Ctrl+E		Editing Text
Line Start			Ctrl+A		Editing Text
Line Up			Ctrl+P		Editing Text
Move Lines Down		Alt+Down		Editing Text
Move Lines Up		Alt+Up		Editing Text
Next Column		Ctrl+F		Editing Text
Next Word			Alt+F		Editing Text
Next Word			Ctrl+Right		Editing Text
Next Word			Esc F		Editing Text
Page Down		Ctrl+V		Editing Text
Page Up			Alt+V		Editing Text
Page Up			Esc V		Editing Text
Previous Column		Ctrl+B		Editing Text
Previous Word		Alt+B		Editing Text
Previous Word		Ctrl+Left		Editing Text
Previous Word		Esc B		Editing Text
Scroll Line Down		Ctrl+Down		Editing Text
Scroll Line Down		Ctrl+Z		Editing Text
Scroll Line Up		Alt+Z		Editing Text
Scroll Line Up		Ctrl+Up		Editing Text
Scroll Line Up		Esc Z		Editing Text
Select Next Word		Shift+Ctrl+Right	Editing Text
Select Previous Word		Shift+Ctrl+Left	Editing Text
Set Mark			Ctrl+2		Editing Text
Set Mark			Ctrl+Space	Editing Text
Swap Mark			Ctrl+X Ctrl+X	Editing Text
Text End			Alt+>		Editing Text
Text End			Ctrl+X ]		Editing Text
Text End			Esc >		Editing Text
Text End			Esc Shift+>	Editing Text
Text End			Shift+Alt+>	Editing Text
Text Start			Alt+<		Editing Text
Text Start			Ctrl+X [		Editing Text
Text Start			Esc <		Editing Text
Text Start			Esc Shift+<	Editing Text
Text Start			Shift+Alt+<	Editing Text
To Lower Case		Shift+Ctrl+Y	Editing Text
To Upper Case		Shift+Ctrl+X	Editing Text
Toggle Folding		Ctrl+Numpad_Divide	Editing Text
Toggle Overwrite		Insert		Editing Text




















Views
Breakpoints		Shift+Alt+Q B	In Windows
Cheat Sheets		Shift+Alt+Q H	In Windows
Console			Shift+Alt+Q C	In Windows
Java Declaration		Shift+Alt+Q D	In Windows
Java Package Explorer	Shift+Alt+Q P	In Windows
Java Type Hierarchy		Shift+Alt+Q T	In Windows
Javadoc			Shift+Alt+Q J	In Windows
Search			Shift+Alt+Q S	In Windows
Show View (View: Outline)	Shift+Alt+Q O	In Windows
Show View (View: Problems)	Shift+Alt+Q X	In Windows
Synchronize		Shift+Alt+Q Y	In Windows
Variables			Shift+Alt+Q V	In Windows

Window
Activate Editor		F12		In Windows
Maximize Active View or Editor	Ctrl+M		In Windows
Next Editor			Ctrl+F6		In Windows
Next Perspective		Ctrl+F8		In Windows
Next View			Ctrl+F7		In Windows
Open Editor Drop Down	Ctrl+X B		In Windows
Previous Editor		Shift+Ctrl+F6	In Windows
Previous Perspective		Shift+Ctrl+F8	In Windows
Previous View		Shift+Ctrl+F7	In Windows
Show Key Assist		Shift+Ctrl+L	In Dialogs&Windows
Show Ruler Context Menu	Ctrl+F10		Editing Text
Show System Menu		Alt+-		In Windows
Show View Menu		Ctrl+F10		In Windows
Switch to Editor		Ctrl+X Ctrl+B	In Windows
Switch to Editor		Esc Ctrl+E	In Windows

			10.1.1.2

		10.1.2 FAQ

			10.1.2.1 error log

[yizaq@cow1:Wed Jun 12:1065:70:/ws/yizaq-csi/eclipse]$ eclipse   -consolelog
!SESSION 2013-06-12 13:50:24.032 -----------------------------------------------
eclipse.buildId=M20120208-0800
java.version=1.6.0_21
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=linux, ARCH=x86, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os linux -ws gtk -arch x86 -product org.eclipse.epp.package.jee.product -consolelog

!ENTRY org.eclipse.osgi 4 0 2013-06-12 13:50:25.772
!MESSAGE Application error
!STACK 1
java.lang.UnsatisfiedLinkError: Cannot load 32-bit SWT libraries on 64-bit JVM
        at org.eclipse.swt.internal.Library.loadLibrary(Library.java:217)
        at org.eclipse.swt.internal.Library.loadLibrary(Library.java:194)
        at org.eclipse.swt.internal.C.<clinit>(C.java:21)
        at org.eclipse.swt.internal.Converter.wcsToMbcs(Converter.java:63)
        at org.eclipse.swt.internal.Converter.wcsToMbcs(Converter.java:54)
        at org.eclipse.swt.widgets.Display.<clinit>(Display.java:132)
        at org.eclipse.ui.internal.Workbench.createDisplay(Workbench.java:695)
        at org.eclipse.ui.PlatformUI.createDisplay(PlatformUI.java:161)
        at org.eclipse.ui.internal.ide.application.IDEApplication.createDisplay(IDEApplication.java:153)
        at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:95)
        at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
        at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
        at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
        at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
        at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
        at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
        at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
        at org.eclipse.equinox.launcher.Main.main(Main.java:1386)

			10.1.2.2 java.lang.UnsatisfiedLinkError: Cannot load 32-bit SWT libraries on 64-bit JVM 
- debug:
[yizaq@cow1:Thu Jun 13:1142:149:/ws/yizaq-csi/cpp_eclipse/eclipse]$ ./eclipse  -consolelog -debug
- fix 
: yum install libswt3-gtk2.x86_64
: mv /usr/share/eclipse /usr/share/eclipse-bak

			10.1.2.3
		10.1.3

	10.2

11. Server side programming

	11.1 Servlet

		11.1.1 Basic example & walkthrough

			11.1.1.1 Eclipse
- DL + deploy Eclipse (I use "Luna")
- Run it -> New "dynamic web project" -> Name it, say "test"

- Copy Servlet.jar:
[yizaq@pmbu-dev-vm58:Thu Oct 23:803:126:/ws/yizaq-csi/apps/apache-tomcat-7.0.56]$ cp /usr/share/java/servlet.jar /ws/yizaq-csi/workspace/test/WebContent/WEB-INF/lib/

-  Under Java Resources, src
default package create new servlet. say "myservlet.java"

code:

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class myservlet
 */
//@WebServlet("/myservlet")
public class myservlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

    /**
     * Default constructor. 
     */
    public myservlet() {
        // TODO Auto-generated constructor stub
    }

	/**
	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	
	      response.setContentType("text/html");

	      // Actual logic goes here.
	      PrintWriter out = response.getWriter();
	      out.println("{AD:\"AD1\"}");
	}

	/**
	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
	}

}

This code handles get. Can add code to handle post.

-  Edit WEB-INF/lib/web.xml to include the servlet
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0">
  <display-name>test</display-name>
  <welcome-file-list>
    <welcome-file>index.html</welcome-file>
    <welcome-file>index.htm</welcome-file>
    <welcome-file>index.jsp</welcome-file>
    <welcome-file>default.html</welcome-file>
    <welcome-file>default.htm</welcome-file>
    <welcome-file>default.jsp</welcome-file>
  </welcome-file-list>




 <servlet>
        <servlet-name>myservlet</servlet-name>
        <servlet-class>myservlet</servlet-class>
    </servlet>

    <servlet-mapping>
        <servlet-name>myservlet</servlet-name>
        <url-pattern>/myservlet</url-pattern>
    </servlet-mapping>
</web-app>

- Add index.html w/ jquery javasript code:
<!DOCTYPE html>
<html>
<head>

<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.2.6/jquery.js"></script>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<script type="text/javascript">
 
$(document).ready(function(){
 $("#msgid").html("This is Hello World by JQuery");
 
 
 $.ajax({
	   url: '  http://pmbu-dev-vm58:8080/test/myservlet',
	   
		 
	   data: {
	        id: 123
	    },
	 
	    // whether this is a POST or GET request
	    type: "GET",
	 
	    // the type of data we expect back
	    dataType : "json",
	 
	    // code to run if the request succeeds;
	    // the response is passed to the function
	    success: function( json ) {
	    	 alert( json );
	    },
	 
	    // code to run if the request fails; the raw request and
	    // status codes are passed to the function
	    error: function( xhr, status, errorThrown ) {
	        alert( "Sorry, there was a problem!" );
	        
	    },
	 
	    // code to run regardless of success or failure
	    complete: function( xhr, status ) {
	        alert( "The request is complete!" );
	    }
 
});
});

</script>
 
This is Hello World by HTML
 
<div id="msgid">
</div>
 
 
</body>
</html>
			11.1.1.2

		11.1.2

	11.2

12. My snippets, examples, demos

    12.1 Performance tests

        12.1.1 HashMap vs array contains
code:
[i500695@C02X632CJGH6:2021-03-22 18:35:33:~/work/code/java/perfTestSnippets/arrayVsHashMap:]2013$ cat !$ | pbcopy 
cat arrayVsHashMapPerfTest.java | pbcopy 

import java.util.HashMap;
import java.util.concurrent.TimeUnit;

public class arrayVsHashMapPerfTest {

    public static void main(String[] args) {
        // Test which is more efficient for get key value
        // when there are multiple keys and only two values
        // #keys<=10
        HashMap<String, String> kvMap = new HashMap<String, String>();
        kvMap.put("k1", "v1");
        kvMap.put("k2", "v2");
        kvMap.put("k3", "v1");
        kvMap.put("k4", "v2");
        kvMap.put("k5", "v1");
        kvMap.put("k6", "v2");
        kvMap.put("k7", "v1");
        kvMap.put("k8", "v2");
        kvMap.put("k9", "v1");
        kvMap.put("k10", "v2");
        kvMap.put("k11", "v1");

        String[] val1Arr = {"k1", "k3", "k5", "k7", "k9", "k11"  };
        String[] val2Arr = {"k2", "k4", "k6", "k8", "k10"};

        long startTime = System.nanoTime();
        final int times = 100000000;
        System.out.println("Test "+times+" times test get map value");
        for (int i = 0; i < times; i++) {
            kvMap.containsKey("k1");
        }
        long endTime = System.nanoTime();

        long timeElapsed = endTime - startTime;
        System.out.println("HashMap Contains Run time "+timeElapsed/1000000000+" seconds, "+timeElapsed/1000000+" milliseconds");

        startTime = System.nanoTime();
        System.out.println("Test "+times+" times test get array value");
        boolean found = false;
        for (int i = 0; i < times; i++) {
            for (int j = 0; j < val1Arr.length; j++) {
                if (val1Arr[j].equals("k7")) {
                    found = true;
                }
            }
        }
        endTime = System.nanoTime();

        timeElapsed = endTime - startTime;
        System.out.println("Array Contains Run time "+timeElapsed/1000000000+" seconds, "+timeElapsed/1000000+" milliseconds");

    }
}

test:
[i500695@C02X632CJGH6:2021-03-22 18:21:30:~/work/code/java/perfTestSnippets/arrayVsHashMap:]2025$ javac arrayVsHashMapPerfTest.java 
[i500695@C02X632CJGH6:2021-03-22 18:21:52:~/work/code/java/perfTestSnippets/arrayVsHashMap:]2026$ java arrayVsHashMapPerfTest
Test 100000000 times test get map value
HashMap Contains Run time 0 seconds, 210 milliseconds
Test 100000000 times test get array value
Array Contains Run time 0 seconds, 522 milliseconds

        12.1.2

    12.2

13.  Memory Management

    13.1  memsize equivalent - How to Get the Size of an Object


        13.1.1  https://www.baeldung.com/java-size-of-object
Unlike C/C++ where we can use sizeof() method to get an object size in bytes, there's no true equivalent of such method in Java.

In this article, we'll demonstrate how we can still get the size of a particular object.

Memory Consumption in Java
Although there is no sizeof operator in Java, we actually don't need one. All primitive types have a standard size, and there are typically no pad or alignment bytes. Still, this isn't always straightforward.

Although primitives must behave as if they have the official sizes, a JVM can store data in any way it pleases internally, with any amount of padding or overhead. It can choose to store a boolean[] in 64-bit long chunks like BitSet, allocate some temporary Objects on the stack or optimize some variables or method calls totally out of existence replacing them with constants, etc… But, as long as the program gives the same result, it's perfectly fine.

Taking also into the account hardware and OS caches impact (our data could be duplicated on every cache level), it means that we can only roughly predict RAM consumptionUnlike C/C++ where we can use sizeof() method to get an object size in bytes, there's no true equivalent of such method in Java.

In this article, we'll demonstrate how we can still get the size of a particular object.

2. Memory Consumption in Java
Although there is no sizeof operator in Java, we actually don't need one. All primitive types have a standard size, and there are typically no pad or alignment bytes. Still, this isn't always straightforward.

Although primitives must behave as if they have the official sizes, a JVM can store data in any way it pleases internally, with any amount of padding or overhead. It can choose to store a boolean[] in 64-bit long chunks like BitSet, allocate some temporary Objects on the stack or optimize some variables or method calls totally out of existence replacing them with constants, etc… But, as long as the program gives the same result, it's perfectly fine.

Taking also into the account hardware and OS caches impact (our data could be duplicated on every cache level), it means that we can only roughly predict RAM consumption..


Minimum object size is 16 bytes for modern 64-bit JDK since the object has 12-byte header, padded to a multiple of 8 bytes. In 32-bit JDK, the overhead is 8 bytes, padded to a multiple of 4 bytes.

References have a typical size of 4 bytes on 32-bit platforms and on 64-bits platforms with heap boundary less than 32Gb (-Xmx32G), and 8 bytes for this boundary above 32Gb.

This means that a 64-bit JVM usually requires 30-50% more heap space.

Especially relevant is to note that boxed types, arrays, Strings and other containers like multidimensional arrays are memory costly since they add certain overhead. For example, when we compare int primitive (which consumes only 4 bytes) to the Integer object which takes 16 bytes, we see that there is 300% memory overhead.


 Estimating Object Size Using Instrumentation
One way to get an estimate of an object's size in Java is to use getObjectSize(Object) method of the Instrumentation interface introduced in Java 5.


freestar
As we could see in Javadoc documentation, the method provides “implementation-specific approximation” of the specified object's size. It's noteworthy that a potential inclusion of overhead in the size exists and values can be different during single JVM invocation.

This approach only supports size estimation of the considered object itself and not the sizes of objects it references. To estimate a total size of the object, we would need a code that would go over those references and calculate the estimated size.

 Creating Instrumentation Agent
In order to call Instrumentation.getObjectSize(Object) to get object's size, we need to be able to access the instance of Instrumentation first. We need to use the instrumentation agent and there are two ways to do it, as described in the documentation for the java.lang.instrument package.

Instrumentation agent can be specified via the command-line or we can use it with an already running JVM. We'll focus on the first one.

To specify the instrumentation agent via the command-line, we'll need the implementation of the overloaded premain method that will be first invoked by the JVM when using instrumentation. Besides that, we need to expose a static method to be able to access Instrumentation.getObjectSize(Object).


freestar
Let's now create the InstrumentationAgent class:

public class InstrumentationAgent {
    private static volatile Instrumentation globalInstrumentation;

    public static void premain(final String agentArgs, final Instrumentation inst) {
        globalInstrumentation = inst;
    }

    public static long getObjectSize(final Object object) {
        if (globalInstrumentation == null) {
            throw new IllegalStateException("Agent not initialized.");
        }
        return globalInstrumentation.getObjectSize(object);
    }
}
Before we create a JAR for this agent, we need to make sure that a simple metafile, MANIFEST.MF is included in it:

Premain-class: com.baeldung.objectsize.InstrumentationAgent
Now we can make an Agent JAR with the MANIFEST.MF file included. One way is via command-line:

javac InstrumentationAgent.java
jar cmf MANIFEST.MF InstrumentationAgent.jar InstrumentationAgent.class

3.2. Example Class
Let's see this in action by creating a class with sample objects that will make use of our agent class:

public class InstrumentationExample {

    public static void printObjectSize(Object object) {
        System.out.println("Object type: " + object.getClass() +
          ", size: " + InstrumentationAgent.getObjectSize(object) + " bytes");
    }

    public static void main(String[] arguments) {
        String emptyString = "";
        String string = "Estimating Object Size Using Instrumentation";
        String[] stringArray = { emptyString, string, "com.baeldung" };
        String[] anotherStringArray = new String[100];
        List<String> stringList = new ArrayList<>();
        StringBuilder stringBuilder = new StringBuilder(100);
        int maxIntPrimitive = Integer.MAX_VALUE;
        int minIntPrimitive = Integer.MIN_VALUE;
        Integer maxInteger = Integer.MAX_VALUE;
        Integer minInteger = Integer.MIN_VALUE;
        long zeroLong = 0L;
        double zeroDouble = 0.0;
        boolean falseBoolean = false;
        Object object = new Object();

        class EmptyClass {
        }
        EmptyClass emptyClass = new EmptyClass();

        class StringClass {
            public String s;
        }
        StringClass stringClass = new StringClass();

        printObjectSize(emptyString);
        printObjectSize(string);
        printObjectSize(stringArray);
        printObjectSize(anotherStringArray);
        printObjectSize(stringList);
        printObjectSize(stringBuilder);
        printObjectSize(maxIntPrimitive);
        printObjectSize(minIntPrimitive);
        printObjectSize(maxInteger);
        printObjectSize(minInteger);
        printObjectSize(zeroLong);
        printObjectSize(zeroDouble);
        printObjectSize(falseBoolean);
        printObjectSize(Day.TUESDAY);
        printObjectSize(object);
        printObjectSize(emptyClass);
        printObjectSize(stringClass);
    }

    public enum Day {
        MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
    }
}
For this to work, we need to include –javaagent option with the path to agent JAR when running our application:

VM Options: -javaagent:"path_to_agent_directory\InstrumentationAgent.jar"
The output of running our class will show us estimated object sizes:

Object type: class java.lang.String, size: 24 bytes
Object type: class java.lang.String, size: 24 bytes
Object type: class [Ljava.lang.String;, size: 32 bytes
Object type: class [Ljava.lang.String;, size: 416 bytes
Object type: class java.util.ArrayList, size: 24 bytes
Object type: class java.lang.StringBuilder, size: 24 bytes
Object type: class java.lang.Integer, size: 16 bytes
Object type: class java.lang.Integer, size: 16 bytes
Object type: class java.lang.Integer, size: 16 bytes
Object type: class java.lang.Integer, size: 16 bytes
Object type: class java.lang.Long, size: 24 bytes
Object type: class java.lang.Double, size: 24 bytes
Object type: class java.lang.Boolean, size: 16 bytes
Object type: class com.baeldung.objectsize.InstrumentationExample$Day, size: 24 bytes
Object type: class java.lang.Object, size: 16 bytes
Object type: class com.baeldung.objectsize.InstrumentationExample$1EmptyClass, size: 16 bytes
Object type: class com.baeldung.objectsize.InstrumentationExample$1StringClass, size: 16 bytes

        13.1.2

    13.2

14. Java versions main features and tools, tags: Java versions main features and tools, tags: versions main features and tools
https://pianalytix.com/java-versions-its-features/

    14.1   Java version 1 
1995( JDK Alpha-Beta Version): 
It Consisted Of An Unstable API. It Is Not A Stable Version.


1995( JDK Alpha-Beta Version): 
Oak Changed To Java.
First Stable Version. 
Access Specifiers Were Added.

February 1997 (JDK 1.1) Java Versions:  
Language Changes: Inner Classes, JavaBeans.
Library Changes: AWT Event Changes, JDBC, And RMI( Remote Method Invocation), JIT(Just In Time Compiler For Microsoft Windows Platforms).

    14.2   Java version 2 
J2SE 1.2 December 1998 Playground: 
Language Changes: The Strictfp Keyword.
Library Changes: Swing As A New UI-System On Top Of AWT. JVM Was Added With JIT Compiler, Java Plugins, And Java IDL (Technology For Distributed Objects, Similar To RMI But It Can Interact Regardless Of The Objects Written In Java Or C Or C++ Or COBOL, Etc). 

    14.3   Java version 3 
    J2SE 1.3 May 2000 Kestral: 
Platform Changes: Hotspot JVM Included. RMI Was Modified To Be Compatible With CORBA (Design Specification For ORB (Object Request Broker)). 
Also, Language Changes: Java Naming And Directory Interface Added To The Core Libraries.
Library Changes:  Java Platform Debugger Architecture (JPDA), Java Sound, And Synthetic Proxy Classes Got Added.

    14.4   Java version 4 
J2SE 1.4 February 2002 Merlin: 
Language Changes: The Assert Keyword. 
Library Changes: Regular Expressions, Exception Chaining, IPV6 Support, Non-Blocking IO, Logging API, Image I/O API, Integrated XML Parser, And XSLT(EXtensible Stylesheet Language Transformations) Processor, Integrated Security And Also Cryptography Extensions(JCE, JSSE, JAAS), Java Web Start Included, Java.Util.Prefs.

    14.5   Java version 5 
 J2SE 5.0 September 2004 Tiger: 
Language Changes: Generics, Annotations, Enum Types.Var-Args, Enhanced For Loops. 
Library Changes: Concurrent Utilities In Java.Util.Concurrent. Scanner Class Joins For Parsing Data Thus From Different Input Streams And Buffers.

    14.6   Java version 6 
Java SE6 December 2006 Mustang: 
Scripting Language Support I.E., Generic API For Tight Integration With Scripting Languages. JDBC 4.0 Support. Here, Improvements To The Existing Libraries No Extra Language Features Adds Up Except @Override.

    14.7   Java version 7 
Java SE 7 July 2011 Dolphin: 
Language Changes: Project Coin(Small Changes/Enhancements And Bug Releases). Try-With-Resources, The Diamond Operator(“<TypeName>:  To Simplify The Use Of Generics ”).
Library Changes:  A New Abstracted File-System API With Support For Virtual File Systems. Improved Concurrency Libraries And Elliptic Curve Encryption.
Platform Changes: Support For Dynamic Languages.

    14.8   Java version 8 
Java SE 8 (LTS) March 2014 Spider (Older But Maintained): 
Language Changes: Lambda Expressions, Annotation On Java Types. Improvements Or Development In Project Coin( Small Language Improvements).
Library Changes: Improved Data And Time API.

        14.8.1    functional interfaces, tags: functional interfaces

          14.8.1.1    chatgpt, lambda expressions and functional interfaces

lambda's are Java's anonymous functions. they are a Shortcut syntax for Functional interfaces.
syntax: (p1,p2,...,pn) -> { expression }
where expression will usually run a calculation on the passed params and return a result

In Java, a functional interface is an interface that contains only one abstract method. Functional interfaces are often used in conjunction with lambda expressions and method references to provide a concise way to define behavior for functions or operations.

Here's an example of a functional interface and its usage:

```java
// Define a functional interface with a single abstract method
@FunctionalInterface
interface Calculator {
    double calculate(double num1, double num2);
}

public class FunctionalInterfaceExample {
    public static void main(String[] args) {
        // Using a lambda expression to implement the Calculator functional interface
        Calculator addition = (a, b) -> a + b;
        Calculator subtraction = (a, b) -> a - b;
        Calculator multiplication = (a, b) -> a * b;
        Calculator division = (a, b) -> {
            if (b == 0) {
                throw new ArithmeticException("Division by zero is not allowed");
            }
            return a / b;
        };

        // Using the functional interfaces to perform calculations
        double result1 = addition.calculate(10, 5);
        double result2 = subtraction.calculate(10, 5);
        double result3 = multiplication.calculate(10, 5);
        double result4 = division.calculate(10, 5);

        System.out.println("Addition: " + result1);
        System.out.println("Subtraction: " + result2);
        System.out.println("Multiplication: " + result3);
        System.out.println("Division: " + result4);
    }
}
```

In this example:

|1. We define a functional interface called `Calculator` with a single abstract method `calculate`. We annotate it with `@FunctionalInterface` to indicate that it is a functional interface (though this annotation is optional).
|
|2. Inside the `main` method, we create lambda expressions to implement the `Calculator` functional interface for addition, subtraction, multiplication, and division operations.
|
|3. We then use these lambda expressions to perform calculations with different operations and print the results.

Functional interfaces are widely used in Java to work with lambdas and provide a more functional programming style when working with APIs that require passing behavior as parameters, such as the `java.util.function` package used in streams and functional programming constructs in Java.


my example:
code: 
[i500695@WYLQRXL9LQ:2023-09-05 22:08:38:~/work/code/java/features/java_8/functional_interfaces:]2022$ cat FunctionalInterfaceExample.java 
// Define a functional interface with a single abstract method
@FunctionalInterface
interface Calculator {
    double calculate(double num1, double num2);
}

public class FunctionalInterfaceExample {
    public static void main(String[] args) {
        // Using a lambda expression to implement the Calculator functional interface
        Calculator addition = (a, b) -> a + b;
        Calculator subtraction = (a, b) -> a - b;
        Calculator multiplication = (a, b) -> a * b;
        Calculator division = (a, b) -> {
            if (b == 0) {
                throw new ArithmeticException("Division by zero is not allowed");
            }
            return a / b;
        };
        Calculator exponent = (a, b) -> {
            double ret = 1;
            if (b==0) {
                ret = 1;
            }
            else if (b >0) {
                ret = 1;
                for (int i = 0; i < b; i++) {
                    ret *= a;
                }
            }
            else {
                ret = 1;
                for (int i = 0; i < -b; i++) {
                    ret *= a;
                }
                ret = 1/a;
            }
            return ret;
        };

        // Using the functional interfaces to perform calculations
        double result1 = addition.calculate(10, 5);
        double result2 = subtraction.calculate(10, 5);
        double result3 = multiplication.calculate(10, 5);
        double result4 = division.calculate(10, 5);
        double result5 = exponent.calculate(10, 5);
        double result6 = exponent.calculate(3, 0);
        double result7 = exponent.calculate(2, -2);

        System.out.println("Addition: " + result1);
        System.out.println("Subtraction: " + result2);
        System.out.println("Multiplication: " + result3);
        System.out.println("Division: " + result4);
        System.out.println("Exponent: " + result5);
        System.out.println("Exponent: " + result6);
        System.out.println("Exponent: " + result7);
    }
}

run:
[i500695@WYLQRXL9LQ:2023-09-05 22:08:32:~/work/code/java/features/java_8/functional_interfaces:]2021$ java FunctionalInterfaceExample
Addition: 15.0
Subtraction: 5.0
Multiplication: 50.0
Division: 2.0
Exponent: 100000.0
Exponent: 1.0
Exponent: 0.5

        14.8.2 forEach
[i500695@WYLQRXL9LQ:2023-09-06 18:19:46:~/work/code/java/features/java_8/forEach:]2036$ cat ForEach.java 
import java.util.ArrayList;
import java.util.List;

/**
 * ForEach
 */
public class ForEach {

        public static void main(String[] args) {
            List<String> myList = new ArrayList<String>();
            myList.add("Deby");
            myList.add("May");
            myList.add("Itay");
            myList.add("Kay");
            myList.add("Aimy");
            System.out.println("Family members names");
            myList.forEach(name -> System.out.println(name));
            System.out.println("Family members upper case");
            myList.forEach((name) -> System.out.println(name.toUpperCase()));
        }
}
[i500695@WYLQRXL9LQ:2023-09-06 18:19:45:~/work/code/java/features/java_8/forEach:]2035$ java ForEach
Family members names
Deby
May
Itay
Kay
Aimy
Family members upper case
DEBY
MAY
ITAY
KAY
AIMY

        14.8.3 optional class , tags: optional class 
In Java 8, the “java.util” package included an optional class. The public final class “Optional” is used to handle NullPointerException in a Java program. You may give other code or values to execute using Optional. Thus, optional reduces the number of null checks required to avoid a nullPointerException.

You may use the Optional class to prevent the application from crashing and terminating unexpectedly. The Optional class has methods for checking the existence of a value for a given variable.

`Optional.ofNullable` is a method provided by the `java.util.Optional` class in Java. It's used to create an `Optional` instance that may or may not contain a non-null value. The purpose of `Optional.ofNullable` is to handle cases where you have a potentially nullable value, and you want to wrap it in an `Optional` to work with it more safely and conveniently.

Here's how `Optional.ofNullable` works:

|1. If the provided value is not null, it creates an `Optional` containing that value.
|2. If the provided value is null, it creates an empty `Optional` (an `Optional` instance with no value).

Example:

```java
String value = "Hello, Optional!";
Optional<String> optionalWithValue = Optional.ofNullable(value);

String nullValue = null;
Optional<String> optionalWithNull = Optional.ofNullable(nullValue);
```

In the example above:

- `optionalWithValue` will contain an `Optional` with the value "Hello, Optional!" because the `value` variable is not null.
- `optionalWithNull` will contain an empty `Optional` because the `nullValue` variable is null.

Using `Optional.ofNullable` is especially useful when working with methods or APIs that may return null values. It allows you to avoid null checks and null pointer exceptions by providing a more structured and safe way to handle the absence of a value.

You can then use methods like `isPresent`, `ifPresent`, `orElse`, and others to work with the value or handle the absence of a value in a more controlled manner.

my demo:
[i500695@WYLQRXL9LQ:2023-09-07 18:26:29:~/work/code/java/features/java_8/optional:]2051$ cat OptionalDemo.java 
import java.util.Optional;

public class OptionalDemo{ 
 
   public static void main(String[] args) { 
        String[] str = new String[10]; 
        Optional<String> checkNull =
                       Optional.ofNullable(str[5]); 
        if (checkNull.isPresent()) { 
            String word = str[5].toLowerCase(); 
            System.out.print(str); 
         } else
           System.out.println("string is null"); 

          String nullVal = null;
          Optional<String> optionalStrWithNull = Optional.ofNullable(nullVal);

          if (optionalStrWithNull.isPresent()) {
            System.out.println("found non null value");
          }
          else {
            System.out.println("found null value");
          }
    } 
}[i500695@WYLQRXL9LQ:2023-09-07 18:26:38:~/work/code/java/features/java_8/optional:]2052$ javac OptionalDemo.java 
[i500695@WYLQRXL9LQ:2023-09-07 18:26:41:~/work/code/java/features/java_8/optional:]2053$ java OptionalDemo
string is null
found null value

        14.8.4 Default And Static Methods In Interfaces, tags: Default And Static Methods In Interfaces
In Java 8, you may add non-abstract methods to interfaces, allowing you to create interfaces with method implementation. To construct interfaces with method implementation, use the Default and Static keywords. Lambda Expression functionality is mostly enabled through default approaches.

You may extend the functionality of your libraries’ interfaces by using default methods. This ensures that the code created for previous versions is compatible with the newer interfaces (binary compatibility).
Default methods and static methods in interfaces were introduced in Java 8 to allow for the addition of new methods to existing interfaces without breaking backward compatibility. Here's an example of both default and static methods in interfaces:

```java
// Define an interface with a default and a static method
interface MyInterface {
    // Abstract method (no implementation required)
    void regularMethod();

    // Default method with implementation
    default void defaultMethod() {
        System.out.println("This is a default method.");
    }

    // Static method with implementation
    static void staticMethod() {
        System.out.println("This is a static method.");
    }
}

// Implement the interface in a class
class MyClass implements MyInterface {
    @Override
    public void regularMethod() {
        System.out.println("This is the regular method implementation.");
    }
}

public class InterfaceExample {
    public static void main(String[] args) {
        MyClass myClass = new MyClass();

        // Calling regularMethod from the implemented class
        myClass.regularMethod();

        // Calling defaultMethod from the interface
        myClass.defaultMethod();

        // Calling staticMethod from the interface
        MyInterface.staticMethod();
    }
}
```

In this example:

- `MyInterface` is an interface that defines three methods:
  - `regularMethod`: An abstract method that must be implemented by any class that implements `MyInterface`.
  - `defaultMethod`: A default method with a default implementation.
  - `staticMethod`: A static method with a static implementation.

- `MyClass` is a class that implements `MyInterface`. It provides an implementation for the `regularMethod` as required by the interface.

- In the `main` method of `InterfaceExample`, we create an instance of `MyClass` and demonstrate the usage of these methods:
  - We call `regularMethod`, which is implemented in `MyClass`.
  - We call `defaultMethod`, which is provided by the default implementation in the interface.
  - We call `staticMethod` directly on the interface itself.

Default methods provide a way to add new methods to existing interfaces without breaking the classes that already implement those interfaces. Static methods in interfaces can be used to provide utility methods that are associated with the interface but don't depend on an instance of the implementing class.

my demo:
[i500695@WYLQRXL9LQ:2023-09-07 18:43:03:~/work/code/java/features/java_8/default_static_methods_in_intefaces:]2062$ cat InterfaceExample.java 
interface MyInterface {
    // Abstract method (no implementation required)
    void regularMethod();

    // Default method with implementation
    default void defaultMethod() {
        System.out.println("This is a default method.");
    }

    // Static method with implementation
    static void staticMethod() {
        System.out.println("This is a static method.");
    }
}

// Implement the interface in a class
class MyClass implements MyInterface {
    @Override
    public void regularMethod() {
        System.out.println("This is the regular method implementation.");
    }
}

// // Implement the interface in a class
// // uncomment will yeild error: InterfaceExample.java:25: error: MyClass2 is not abstract and does not override abstract method regularMethod() in MyInterface
// class MyClass2 implements MyInterface {
// }

public class InterfaceExample {
    public static void main(String[] args) {
        MyClass myClass = new MyClass();
        //MyClass2 myClass2 = new MyClass2();

        System.out.println("calling myClass methods:");
        // Calling regularMethod from the implemented class
        myClass.regularMethod();

        // Calling defaultMethod from the interface
        myClass.defaultMethod();

        // Calling staticMethod from the interface
        MyInterface.staticMethod();

        // System.out.println("calling myClass2 methods:");
        // myClass2.regularMethod();
        // myClass2.defaultMethod();
        // myClass2.staticMethod();
    }
}
[i500695@WYLQRXL9LQ:2023-09-07 18:43:10:~/work/code/java/features/java_8/default_static_methods_in_intefaces:]2063$ javac InterfaceExample.java 
[i500695@WYLQRXL9LQ:2023-09-07 18:43:15:~/work/code/java/features/java_8/default_static_methods_in_intefaces:]2064$ java InterfaceExample
calling myClass methods:
This is the regular method implementation.
This is a default method.
This is a static method.

        14.8.4 Java Stream API For Bulk Data Operations On Collections , tags: Java Stream API For Bulk Data Operations On Collections 
In Java, the Stream API and bulk data operations provide a powerful and concise way to perform operations on collections of data. They were introduced in Java 8 and have since become an integral part of Java's functional programming features. The Stream API allows you to process collections of data in a more declarative and functional style, making your code more readable and efficient.

Here's an overview of the Stream API and some common bulk data operations:

| 1. **Stream API**:
|    - A `Stream` in Java represents a sequence of elements that can be processed in a functional style.
|    - You can create a Stream from various data sources, including collections, arrays, or by generating elements dynamically.
|    - Streams can be processed in a chain of operations like filtering, mapping, and reducing, without modifying the original data source.
| 
| 2. **Common Bulk Data Operations**:
   - **Filtering**: Use the `filter` operation to select elements from a Stream that satisfy a given condition.
   - **Mapping**: Use the `map` operation to transform elements in a Stream to another form.
   - **Reducing**: Use the `reduce` operation to combine elements of a Stream into a single result, such as summing all elements.
   - **Collecting**: Use the `collect` operation to accumulate elements from a Stream into a collection or other data structure.
   - **Sorting**: Use the `sorted` operation to sort elements in a Stream based on a specified comparator.

Here are some usage examples:

```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class StreamExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // Example 1: Filtering
        List<Integer> evenNumbers = numbers.stream()
                .filter(n -> n % 2 == 0)
                .collect(Collectors.toList());
        System.out.println("Even numbers: " + evenNumbers);

        // Example 2: Mapping
        List<String> squareStrings = numbers.stream()
                .map(n -> n * n)
                .map(Object::toString)
                .collect(Collectors.toList());
        System.out.println("Square strings: " + squareStrings);

        // Example 3: Reducing
        int sum = numbers.stream()
                .reduce(0, Integer::sum);
        System.out.println("Sum of numbers: " + sum);

        // Example 4: Sorting
        List<Integer> sortedNumbers = numbers.stream()
                .sorted((a, b) -> b.compareTo(a)) // Descending order
                .collect(Collectors.toList());
        System.out.println("Sorted numbers (descending): " + sortedNumbers);
    }
}
```

In this example, we have a list of numbers, and we use various Stream operations to filter, map, reduce, and sort the data. These operations allow you to express your intentions concisely and readably while performing complex data manipulations on collections.

my demo:
[i500695@WYLQRXL9LQ:2023-09-11 18:26:55:~/work/code/java/features/java_8/streams:]2017$ javac StreamExample.java 
[i500695@WYLQRXL9LQ:2023-09-11 18:28:04:~/work/code/java/features/java_8/streams:]2018$ java StreamExample
Even numbers: [2, 4, 6, 8, 10]
Square strings: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
Sum of numbers: 55
Sorted numbers (descending): [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
Sorted numbers (ascending): [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Unique list of numbers is:
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 
[i500695@WYLQRXL9LQ:2023-09-11 18:28:05:~/work/code/java/features/java_8/streams:]2019$ cat StreamExample.java 
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.stream.Collector;
import java.util.stream.Collectors;

public class StreamExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // Example 1: Filtering
        List<Integer> evenNumbers = numbers.stream()
                .filter(n -> n % 2 == 0)
                .collect(Collectors.toList());
        System.out.println("Even numbers: " + evenNumbers);

        // Example 2: Mapping
        List<String> squareStrings = numbers.stream()
                .map(n -> n * n)
                .map(Object::toString)
                .collect(Collectors.toList());
        System.out.println("Square strings: " + squareStrings);

        // Example 3: Reducing
        int sum = numbers.stream()
                .reduce(0, Integer::sum);
        System.out.println("Sum of numbers: " + sum);

        // Example 4: Sorting
        List<Integer> sortedNumbers = numbers.stream()
                .sorted((a, b) -> b.compareTo(a)) // Descending order
                .collect(Collectors.toList());
        System.out.println("Sorted numbers (descending): " + sortedNumbers);

        // Example 4: Sorting ascending
        List<Integer> sortedNumbersAsc = numbers.stream()
                .sorted((a, b) -> a.compareTo(b)) // Descending order
                .collect(Collectors.toList());
        System.out.println("Sorted numbers (ascending): " + sortedNumbersAsc);

        List<Integer> numbers2 = Arrays.asList(1, 2,2,2, 3, 4, 5, 6, 6,7, 8, 8,8, 9, 10);
        Set<Integer> uniqNumbers = numbers.stream()
                .collect(Collectors.toSet());
                System.out.println("Unique list of numbers is:");
                uniqNumbers.forEach( elem -> System.out.printf("%d, ", elem));
                System.out.println("");
    }
}

        14.8.5 java data time API usage, tags: java data time API usage

            14.8.5.1 gpt
The Java Date and Time API, introduced in Java 8, provides a comprehensive and robust way to handle date and time operations. It's located in the `java.time` package. Here's an example of how to use the Java Date and Time API:

```java
import java.time.*;
import java.time.format.DateTimeFormatter;

public class DateTimeExample {
    public static void main(String[] args) {
        // Getting the current date and time
        LocalDateTime now = LocalDateTime.now();
        System.out.println("Current Date and Time: " + now);

        // Creating a specific date and time
        LocalDate date = LocalDate.of(2023, Month.JANUARY, 15);
        LocalTime time = LocalTime.of(14, 30);
        LocalDateTime dateTime = LocalDateTime.of(date, time);
        System.out.println("Specific Date and Time: " + dateTime);

        // Formatting date and time
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String formattedDateTime = dateTime.format(formatter);
        System.out.println("Formatted Date and Time: " + formattedDateTime);

        // Adding and subtracting time
        LocalDateTime futureDateTime = dateTime.plusDays(7).minusHours(2);
        System.out.println("Future Date and Time: " + futureDateTime);

        // Duration between two times
        Duration duration = Duration.between(dateTime, futureDateTime);
        System.out.println("Duration: " + duration.toHours() + " hours");

        // Working with time zones
        ZoneId newYorkZone = ZoneId.of("America/New_York");
        ZonedDateTime newYorkTime = ZonedDateTime.of(dateTime, newYorkZone);
        System.out.println("New York Time: " + newYorkTime);

        // Checking for leap years
        boolean isLeapYear = Year.of(2024).isLeap();
        System.out.println("Is 2024 a leap year? " + isLeapYear);
    }
}
```

In this example:

| 1. We get the current date and time using `LocalDateTime.now()`.
| 
| 2. We create a specific date and time using `LocalDate.of()` and `LocalTime.of()`.
| 
| 3. We format the date and time using `DateTimeFormatter`.
| 
| 4. We add and subtract time from a date and time using methods like `plusDays()` and `minusHours()`.
| 
| 5. We calculate the duration between two times using `Duration.between()`.
| 
| 6. We work with time zones using `ZoneId` and `ZonedDateTime`.
| 
| 7. We check if a year is a leap year using the `Year` class.

Make sure you have Java 8 or a later version installed to run this code because the Java Date and Time API was introduced in Java 8.

            14.8.5.2 my demo
[i500695@WYLQRXL9LQ:2023-09-11 18:35:52:~/work/code/java/features/java_8/DateTime:]2026$ javac DateTimeExample.java
[i500695@WYLQRXL9LQ:2023-09-11 18:36:57:~/work/code/java/features/java_8/DateTime:]2027$ java DateTimeExample
Current Date and Time: 2023-09-11T18:36:58.252988
Demo Creation Specific Date and Time: 2023-09-11T18:37
Formatted Date and Time: 2023-09-11 18:37:00
Future Date and Time: 2024-09-18T16:37
Duration: 372 days
Duration: 8950 hours
Duration: 32220000 seconds
Duration: 32220000000 milliseconds
New York Time: 2023-09-11T18:37-04:00[America/New_York]
Is 2024 a leap year? true
[i500695@WYLQRXL9LQ:2023-09-11 18:36:58:~/work/code/java/features/java_8/DateTime:]2028$ cat DateTimeExample.java 
import java.time.*;
import java.time.format.DateTimeFormatter;

public class DateTimeExample {
    public static void main(String[] args) {
        // Getting the current date and time
        LocalDateTime now = LocalDateTime.now();
        System.out.println("Current Date and Time: " + now);

        // Creating a specific date and time
        LocalDate date = LocalDate.of(2023, Month.SEPTEMBER, 11); //the day this demo was created...
        LocalTime time = LocalTime.of(18, 37);
        LocalDateTime dateTime = LocalDateTime.of(date, time);
        System.out.println("Demo Creation Specific Date and Time: " + dateTime);

        // Formatting date and time
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String formattedDateTime = dateTime.format(formatter);
        System.out.println("Formatted Date and Time: " + formattedDateTime);

        // Adding and subtracting time
        LocalDateTime futureDateTime = dateTime.plusYears(1).plusDays(7).minusHours(2);
        System.out.println("Future Date and Time: " + futureDateTime);

        // Duration between two times
        Duration duration = Duration.between(dateTime, futureDateTime);
        System.out.println("Duration: " + duration.toDays() + " days");
        System.out.println("Duration: " + duration.toHours() + " hours");
        System.out.println("Duration: " + duration.toSeconds() + " seconds");
        System.out.println("Duration: " + duration.toMillis() + " milliseconds");

        // Working with time zones
        ZoneId newYorkZone = ZoneId.of("America/New_York");
        ZonedDateTime newYorkTime = ZonedDateTime.of(dateTime, newYorkZone);
        System.out.println("New York Time: " + newYorkTime);

        // Checking for leap years
        boolean isLeapYear = Year.of(2024).isLeap();
        System.out.println("Is 2024 a leap year? " + isLeapYear);
    }
}


            14.8.5.3 




        14.8.6 Collection API Improvements, tags: Collection API Improvements
The Collection API in Java 8 now includes the following new methods. A few of them are listed below.  

This is a default method for the Iterator. forEachRemaining (Consumer action): This is a default method for the Iterator. It repeats the “action” for the remaining items until all of them have been processed, or the “action” throws an exception.
The default technique for removing items from a collection is removed (Predicate filter). This removes all objects from the collection that satisfy the supplied “filter.”
Spliterator () This collection method returns a spliterator object that may be used to traverse the items sequentially or in parallel.
ReplaceAll (), calculate(), and merge() are methods in the Map collection.
The performance of the HashMap class with Key collisions has been enhanced etc.

        14.8.7 Java IO Improvements
The following are some of the IO enhancements made in Java 8:

Files.list (Path dir): Returns a lazily filled stream, each element of which represents a directory entry.
Files.lines (Path path): Reads all the lines from a stream.
Files.find (): Returns a stream filled by a path after searching for files in the file tree rooted at a provided beginning file and many more. 
BufferedReader.lines (): Returns a stream containing all of the elements of BufferedReader’s lines and much more
Buffered

        14.8.8 Miscellaneous Core API Improvements
 ThreadLocal’s static function with initial (Supplier supplier) allows you to build an instance quickly.
The default and static methods for natural ordering, reverse order, and other operations have been added to the “Comparator” interface.
The min (), max (), and sum () methods are available in the Integer, Long, and Double wrapper classes.
The logicalAnd (), logicalOr (), and logicalXor () methods have been added to the Boolean class.
The Math class introduces a number of useful techniques.
The JDBC-ODBC Bridge has been deactivated.
The memory space used by PermGen is no longer available.

        14.8.9 Base64 Encode Decode 
For Base64 encoding, Java 8 has built-in encode and decode functions. The Base64 encoding class in Java.util.Base64.

Three Base64 encoders and decoders are provided in this class:

The output is mapped to a set of characters between A-Za-z0-9+/ in this version. The encoder does not add a line feed to the output, and the decoder rejects any character other than the above.
The filename safe is mapped to the set of characters between A-Za-z0-9+/, and the output is the URL.
The output of this sort of encoder is mapped to a MIME-friendly format.

            14.8.9.1 GTP example
In Java, you can encode and decode data in Base64 using the `java.util.Base64` class, which was introduced in Java 8. Here's an example of how to do that:

**Encoding to Base64:**

```java
import java.util.Base64;

public class Base64Example {
    public static void main(String[] args) {
        // The string to be encoded
        String originalText = "Hello, World!";

        // Encoding to Base64
        byte[] encodedBytes = Base64.getEncoder().encode(originalText.getBytes());

        String encodedText = new String(encodedBytes);
        System.out.println("Encoded Text: " + encodedText);
    }
}
```

In this example, we use `Base64.getEncoder().encode()` to encode the string "Hello, World!" into Base64. The result is stored as a byte array, and we convert it back to a string for printing.

**Decoding from Base64:**

```java
import java.util.Base64;

public class Base64Example {
    public static void main(String[] args) {
        // The Base64 encoded string
        String encodedText = "SGVsbG8sIFdvcmxkIQ==";

        // Decoding from Base64
        byte[] decodedBytes = Base64.getDecoder().decode(encodedText);

        String decodedText = new String(decodedBytes);
        System.out.println("Decoded Text: " + decodedText);
    }
}
```

In this example, we use `Base64.getDecoder().decode()` to decode the Base64 encoded string "SGVsbG8sIFdvcmxkIQ==". The result is stored as a byte array, and we convert it back to a string for printing.

When you run these examples, you should see the original text "Hello, World!" after decoding the Base64-encoded string.

            14.8.9.2 my demo
[i500695@WYLQRXL9LQ:2023-09-12 18:29:42:~/work/code/java/features/java_8/base64:]2049$ javac Base64Demo.java
[i500695@WYLQRXL9LQ:2023-09-12 18:31:11:~/work/code/java/features/java_8/base64:]2050$ java Base64Demo
Text: base64 demo, encode: [B@6b95977
Decoded Text: base64 demo
[i500695@WYLQRXL9LQ:2023-09-12 18:31:12:~/work/code/java/features/java_8/base64:]2051$ cat Base64Demo.java 
import java.util.Base64;

public class Base64Demo {
    public static void main(String[] args) {
        String text = "base64 demo";
        byte[] encoded_text = Base64.getEncoder().encode(text.getBytes());
        System.out.printf("Text: %s, encode: %s\n", text, encoded_text);
        byte[] decoded_text = Base64.getDecoder().decode(encoded_text);
        System.out.printf("Decoded Text: %s\n", text, decoded_text);
    }
}
            14.8.9.3
        14.8.10
    14.10  Java version 9, tags: Java version 9

        14.10.1  summary 9-17

Java 9 (2017):
Module System (Project Jigsaw): Java 9 introduced the module system, which allows developers to create modular applications, making it easier to manage dependencies and encapsulate code.

JShell (Interactive REPL): The JShell tool provides an interactive Read-Eval-Print Loop (REPL) for Java, making it easier to experiment with code snippets and learn the language.

Improved Stream API: Java 9 enhanced the Stream API with additional methods for processing and transforming streams of data.

Private Methods in Interfaces: Interfaces could now have private methods, which can be used for code reuse and organization.

Java 10 (2018):
Local-Variable Type Inference (var): Java 10 introduced the var keyword, allowing type inference for local variables, reducing verbosity in code.

Application Class-Data Sharing: This feature enables the sharing of class metadata and can lead to improved application startup times.

Experimental JIT Compiler (Graal): The GraalVM Just-In-Time (JIT) compiler was made available for experimentation.

Java 11 (2018):
HTTP Client (Standard): Java 11 introduced a new, standardized HTTP client library, making it easier to make HTTP requests.

Local-Variable Syntax for Lambda Parameters: It extended the use of var for lambda parameters.

Epsilon Garbage Collector: This is a no-op garbage collector for performance testing and diagnostic purposes.

Java 12 (2019):
Switch Expressions (Preview): The switch statement was enhanced to be used as an expression, making code more concise and readable.

Shenandoah Garbage Collector (Experimental): Shenandoah is a low-pause-time garbage collector that was introduced as an experimental feature.

Java 13 (2019):
Text Blocks: Java 13 introduced text blocks, making it easier to write multi-line string literals in a more readable and maintainable way.

Dynamic CDS Archives: This feature extended the class-data sharing (CDS) functionality to allow dynamic archiving of classes at runtime.

Java 14 (2020):
Pattern Matching (Preview): This preview feature introduced the instanceof pattern matching for more concise and safer code.

Records (Preview): Records are a preview feature that simplifies the creation of immutable data classes.

Java 15 (2020):
Sealed Classes (Preview): Sealed classes and interfaces were introduced as a preview feature, restricting which classes can extend or implement a given type.

Text Blocks (Standard): Text blocks became a standard feature, making it easier to work with multi-line strings.

Java 16 (2021):
Records (Standard): Records were finalized as a standard feature, providing a concise way to define data classes.

Pattern Matching (Standard): The pattern matching feature was finalized, including the instanceof pattern matching and the switch expression.

Java 17 (2021):
Pattern Matching (Continued): Java 17 continued the pattern matching feature and introduced the "patterns" keyword.

Sealed Classes (Standard): Sealed classes and interfaces were finalized as a standard feature.

Strong encapsulation (Incubator): Strong encapsulation was introduced as an incubator feature, aiming to improve security and reliability.

Foreign Function and Memory API (Incubator): The Foreign Function and Memory API was introduced as an incubator feature for interaction with native code and memory.a

https://www.digitalocean.com/community/tutorials/java-9-features-with-examples


            14.10.1.1   other


        14.10.1  REPL, jshell, tags: REPL, jshell
example:
jshell> String s = "hello";
s ==> "hello"

jshell> import java.util.Base64;

jshell> Base64.GetEncoder().encode(s)
|  Error:
|  cannot find symbol
|    symbol:   method GetEncoder()
|  Base64.GetEncoder().encode(s)
|  ^---------------^

jshell> Base64.getEncoder().encode(s.getBytes())
$3 ==> byte[8] { 97, 71, 86, 115, 98, 71, 56, 61 }

jshell> System.out.pr
print(     printf(    println(   
jshell> System.out.println(s)
hello

jshell> byte[] s_enc = Base64.getEncoder().encode(s.getBytes())
s_enc ==> byte[8] { 97, 71, 86, 115, 98, 71, 56, 61 }

jshell> System.out.println(s_enc)
[B@1b2c6ec2

        14.10.2 Factory Methods for Immutable List, Set, Map and Map.Entry, tags: Factory Methods for Immutable List
Oracle Corp has introduced some convenient factory methods to create Immutable List, Set, Map and Map.Entry objects. These utility methods are used to create empty or non-empty Collection objects. In Java SE 8 and earlier versions, We can use Collections class utility methods like unmodifiableXXX to create Immutable Collection objects. For instance, if we want to create an Immutable List, then we can use Collections.unmodifiableList method. However, these Collections.unmodifiableXXX methods are a tedious and verbose approach. To overcome those shortcomings, Oracle Corp has added a couple of utility methods to List, Set and Map interfaces. List and Set interfaces have “of()” methods to create an empty or no-empty Immutable List or Set objects 

List immutableList = List.of();
Non-Empty List Example

List immutableList = List.of("one","two","three");
The Map has two sets of methods: of() methods and ofEntries() methods to create an Immutable Map object and an Immutable Map.Entry object respectively. Empty Map Example

jshell> Map emptyImmutableMap = Map.of()
emptyImmutableMap ==> {}
Non-Empty Map Example

jshell> Map nonemptyImmutableMap = Map.of(1, "one", 2, "two", 3, "three")
nonemptyImmutableMap ==> {2=two, 3=three, 1=one}

        14.10.3 Private methods in Interfaces
In Java 8, we can provide method implementation in Interfaces using Default and Static methods. However we cannot create private methods in Interfaces. To avoid redundant code and more re-usability, Oracle Corp is going to introduce private methods in Java SE 9 Interfaces. From Java SE 9 onwards, we can write private and private static methods too in an interface using a ‘private’ keyword. These private methods are like other class private methods only, there is no difference between them.

public interface Card{

  private Long createCardID(){
    // Method implementation goes here.
  }

  private static void displayCardDetails(){
    // Method implementation goes here.
  }

}
If you want to read more about this new feature, please go through this link: Java 9 Private methods in Interface.

        14.10.4 Java 9 Module System
One of the big changes or java 9 feature is the Module System. Oracle Corp is going to introduce the following features as part of Jigsaw Project.

Modular JDK
Modular Java Source Code
Modular Run-time Images
Encapsulate Java Internal APIs
Java Platform Module System
Before Java SE 9 versions, we are using Monolithic Jars to develop Java-Based applications. This architecture has a lot of limitations and drawbacks. To avoid all these shortcomings, Java SE 9 is coming with the Module System. JDK 9 is coming with 92 modules (may change in final release). We can use JDK Modules and also we can create our own modules as shown below

            14.10.4.1 GPT explanation

As of my last knowledge update in September 2021, Java introduced a module system in Java 9 as part of the Java Platform Module System (JPMS). Modules help you modularize your Java applications by explicitly declaring dependencies, encapsulating code, and improving maintainability. Here's a basic example of how to create and use modules in Java:

Let's assume we have a simple Java application with two modules:

|1. **Module A (com.example.moduleA)**: This module contains a single class, `HelloA`, with a method that prints a message.
|
|2. **Module B (com.example.moduleB)**: This module depends on Module A and uses the `HelloA` class to print a message.

**Step 1: Create the Module A**

Create a directory structure like this:

```
module-example/
   ├── moduleA/
   │     ├── module-info.java
   │     └── com/
   │          └── example/
   │               └── moduleA/
   │                    └── HelloA.java
```

In `module-info.java` for Module A:

```java
module com.example.moduleA {
}
```

In `HelloA.java`:

```java
package com.example.moduleA;

public class HelloA {
    public void sayHello() {
        System.out.println("Hello from Module A!");
    }
}
```

**Step 2: Create Module B**

Create a directory structure like this:

```
module-example/
   ├── moduleA/
   ├── moduleB/
   │     ├── module-info.java
   │     └── com/
   │          └── example/
   │               └── moduleB/
   │                    └── HelloB.java
```

In `module-info.java` for Module B:

```java
module com.example.moduleB {
    requires com.example.moduleA;
}
```

In `HelloB.java`:

```java
package com.example.moduleB;

import com.example.moduleA.HelloA;

public class HelloB {
    public static void main(String[] args) {
        HelloA helloA = new HelloA();
        helloA.sayHello();
        System.out.println("Hello from Module B!");
    }
}
```

**Step 3: Compile and Run**

Compile the modules using the `javac` command:

```bash
javac -d out moduleA/module-info.java moduleA/com/example/moduleA/HelloA.java
javac --module-path out -d out moduleB/module-info.java moduleB/com/example/moduleB/HelloB.java
```

Run the `HelloB` class:

```bash
java --module-path out -m com.example.moduleB/com.example.moduleB.HelloB
```

You'll see the following output:

```
Hello from Module A!
Hello from Module B!
```

This example demonstrates a simple use case of creating and using modules in Java. Module A contains a class that Module B depends on, and the modules are compiled and run using the `--module-path` and `-m` options.

Please note that the module system is particularly useful for larger projects where you need to manage dependencies and encapsulate code more effectively. In smaller projects, traditional package organization may suffice. Additionally, Java may have introduced changes or improvements to the module system in versions beyond Java 9, so be sure to check the documentation for the latest updates.

            14.10.4.2 https://www.baeldung.com/java-9-modularity
Java 9 introduces a new level of abstraction above packages, formally known as the Java Platform Module System (JPMS), or “Modules” for short.
In this tutorial, we’ll go through the new system and discuss its various aspects.

We’ll also build a simple project to demonstrate all concepts we’ll be learning in this guide.
First of all, we need to understand what a module is before we can understand how to use them.
A Module is a group of closely related packages and resources along with a new module descriptor file.
In other words, it’s a “package of Java Packages” abstraction that allows us to make our code even more reusable.

                14.10.4.2.1 Packages
The packages inside a module are identical to the Java packages we’ve been using since the inception of Java.

When we create a module, we organize the code internally in packages just like we previously did with any other project.

Aside from organizing our code, packages are used to determine what code is publicly accessible outside of the module. We’ll spend more time talking about this later in the article.


                14.10.4.2.2 resources
                Each module is responsible for its resources, like media or configuration files.
Previously we’d put all resources into the root level of our project and manually manage which resources belonged to different parts of the application.
With modules, we can ship required images and XML files with the module that needs it, making our projects much easier to manage.

                14.10.4.2.3 Module Descriptor
When we create a module, we include a descriptor file that defines several aspects of our new module:

Name – the name of our module
Dependencies – a list of other modules that this module depends on
Public Packages – a list of all packages we want accessible from outside the module
Services Offered – we can provide service implementations that can be consumed by other modules
Services Consumed – allows the current module to be a consumer of a service
Reflection Permissions – explicitly allows other classes to use reflection to access the private members of a package
The module naming rules are similar to how we name packages (dots are allowed, dashes are not). It’s very common to do either project-style (my.module) or Reverse-DNS (com.baeldung.mymodule) style names. We’ll use project-style in this guide.

We need to list all packages we want to be public because by default all packages are module private.


The same is true for reflection. By default, we cannot use reflection on classes we import from another module.

Later in the article, we’ll look at examples of how to use the module descriptor file.


                14.10.4.2.4 java list-modules command
The `java list-modules` command is used to list the modules available in a Java application. It is available starting from Java 9 and is a part of the Java Platform Module System (JPMS), which was introduced in Java 9 to improve modularity in Java applications.

Here's how you can use the `java list-modules` command:

a. Open your command prompt or terminal.

b. Run the `java list-modules` command followed by the options and arguments you want to use. The basic syntax is as follows:

```shell
java --list-modules
```

This command will list all the modules available in your Java installation.

You can also specify additional options to filter the list or get more detailed information about the modules. For example:

- To list only the non-system modules (modules not part of the Java SE Platform), you can use the `--limit-modules` option:

  ```shell
  java --list-modules --limit-modules java.se
  ```

- To get more detailed information about a specific module, you can use the `--describe-module` option followed by the module name. For example:

  ```shell
  java --describe-module java.base
  ```

The `java list-modules` command is useful for exploring the module system in Java, especially when you want to understand which modules are available and how they are structured in your Java runtime environment. It's commonly used in conjunction with Java 9 and later versions to work with modular Java applications.


                14.10.4.2.5 Module Types
There are four types of modules in the new module system:

System Modules – These are the modules listed when we run the list-modules command above. They include the Java SE and JDK modules.
Application Modules – These modules are what we usually want to build when we decide to use Modules. They are named and defined in the compiled module-info.class file included in the assembled JAR.
Automatic Modules – We can include unofficial modules by adding existing JAR files to the module path. The name of the module will be derived from the name of the JAR. Automatic modules will have full read access to every other module loaded by the path.
Unnamed Module – When a class or JAR is loaded onto the classpath, but not the module path, it’s automatically added to the unnamed module. It’s a catch-all module to maintain backward compatibility with previously-written Java code.

                14.10.4.2.6 Distribution
Modules can be distributed one of two ways: as a JAR file or as an “exploded” compiled project. This, of course, is the same as any other Java project so it should come as no surprise.

We can create multi-module projects comprised of a “main application” and several library modules.

We have to be careful though because we can only have one module per JAR file.

When we set up our build file, we need to make sure to bundle each module in our project as a separate jar.


                14.10.4.2.7 Default Modules
When we install Java 9, we can see that the JDK now has a new structure.


They have taken all the original packages and moved them into the new module system.

We can see what these modules are by typing into the command line:

$java --list-modules
These modules are split into four major groups: java, javafx, jdk, and Oracle.

java modules are the implementation classes for the core SE Language Specification.

javafx modules are the FX UI libraries.

Anything needed by the JDK itself is kept in the jdk modules.

And finally, anything that is Oracle-specific is in the oracle modules.

                14.10.4.2.8 Module Declarations
To set up a module, we need to put a special file at the root of our packages named module-info.java.
This file is known as the module descriptor and contains all of the data needed to build and use our new module.

We construct the module with a declaration whose body is either empty or made up of module directives:

module myModuleName {
    // all directives are optional
}
We start the module declaration with the module keyword, and we follow that with the name of the module.

The module will work with this declaration, but we’ll commonly need more information.

That is where the module directives come in.

                    14.10.4.2.8.1 Requires
Our first directive is requires. This module directive allows us to declare module dependencies:

module my.module {
    requires module.name;
}
Now, my.module has both a runtime and a compile-time dependency on module.name.

And all public types exported from a dependency are accessible by our module when we use this directive.

                    14.10.4.2.8.2 Requires Static
Sometimes we write code that references another module, but that users of our library will never want to use.

For instance, we might write a utility function that pretty-prints our internal state when another logging module is present. But, not every consumer of our library will want this functionality, and they don’t want to include an extra logging library.

In these cases, we want to use an optional dependency. By using the requires static directive, we create a compile-time-only dependency:

module my.module {
    requires static module.name;
}

                    14.10.4.2.8.3 Requires Transitive
We commonly work with libraries to make our lives easier.

But, we need to make sure that any module that brings in our code will also bring in these extra ‘transitive’ dependencies or they won’t work.

Luckily, we can use the requires transitive directive to force any downstream consumers also to read our required dependencies:

module my.module {
    requires transitive module.name;
}
Now, when a developer requires my.module, they won’t also have also to say requires module.name for our module to still work.

                    14.10.4.2.8.4 Exports
By default, a module doesn’t expose any of its API to other modules. This strong encapsulation was one of the key motivators for creating the module system in the first place.

Our code is significantly more secure, but now we need to explicitly open our API up to the world if we want it to be usable.

We use the exports directive to expose all public members of the named package:

module my.module {
    exports com.my.package.name;
}
Now, when someone does requires my.module, they will have access to the public types in our com.my.package.name package, but not any other package.

                    14.10.4.2.8.5 Exports … To
We can use exports…to to open up our public classes to the world.

But, what if we don’t want the entire world to access our API?

We can restrict which modules have access to our APIs using the exports…to directive.

Similar to the exports directive, we declare a package as exported. But, we also list which modules we are allowing to import this package as a requires. Let’s see what this looks like:

module my.module {
    export com.my.package.name to com.specific.package;
}

                    14.10.4.2.8.6 Uses
A service is an implementation of a specific interface or abstract class that can be consumed by other classes.
We designate the services our module consumes with the uses directive.

Note that the class name we use is either the interface or abstract class of the service, not the implementation class:

module my.module {
    uses class.name;
}
We should note here that there’s a difference between a requires directive and the uses directive.

We might require a module that provides a service we want to consume, but that service implements an interface from one of its transitive dependencies.

Instead of forcing our module to require all transitive dependencies just in case, we use the uses directive to add the required interface to the module path.

                    14.10.4.2.8.7 Provides … With
A module can also be a service provider that other modules can consume.

The first part of the directive is the provides keyword. Here is where we put the interface or abstract class name.

Next, we have the with directive where we provide the implementation class name that either implements the interface or extends the abstract class.
Here’s what it looks like put together:

module my.module {
    provides MyInterface with MyInterfaceImpl;
}

                    14.10.4.2.8.8 Open
We mentioned earlier that encapsulation was a driving motivator for the design of this module system.

Before Java 9, it was possible to use reflection to examine every type and member in a package, even the private ones. Nothing was truly encapsulated, which can open up all kinds of problems for developers of the libraries.

Because Java 9 enforces strong encapsulation, we now have to explicitly grant permission for other modules to reflect on our classes.

If we want to continue to allow full reflection as older versions of Java did, we can simply open the entire module up:

open module my.module {
}

                    14.10.4.2.8.9 Opens
If we need to allow reflection of private types, but we don’t want all of our code exposed, we can use the opens directive to expose specific packages.

But remember, this will open the package up to the entire world, so make sure that is what you want:

module my.module {
  opens com.my.package;
}

                    14.10.4.2.8.10 Opens … To
Okay, so reflection is great sometimes, but we still want as much security as we can get from encapsulation. We can selectively open our packages to a pre-approved list of modules, in this case, using the opens…to directive:

module my.module {
    opens com.my.package to moduleOne, moduleTwo, etc.;
}

                    14.10.4.2.8.11
                14.10.4.2.9 Command Line Options
By now, support for Java 9 modules has been added to Maven and Gradle, so you won’t need to do a lot of manual building of your projects. However, it’s still valuable to know how to use the module system from the command line.

We’ll be using the command line for our full example down below to help solidify how the entire system works in our minds.

module-path – We use the –module-path option to specify the module path. This is a list of one or more directories that contain your modules.
add-reads – Instead of relying on the module declaration file, we can use the command line equivalent of the requires directive; –add-reads.
add-exports – Command line replacement for the exports directive.
add-opens – Replace the open clause in the module declaration file.
add-modules – Adds the list of modules into the default set of modules
list-modules – Prints a list of all modules and their version strings
patch-module – Add or override classes in a modules
illegal-access=permit|warn|deny – Either relax strong encapsulation by showing a single global warning, shows every warning, or fails with errors. The default is permit.

                14.10.4.2.10 Visibility
We should spend a little time talking about the visibility of our code.

A lot of libraries depend on reflection to work their magic (JUnit and Spring come to mind).

By default in Java 9, we will only have access to public classes, methods, and fields in our exported packages. Even if we use reflection to get access to non-public members and call setAccessible(true), we won’t be able to access these members.

We can use the open, opens, and opens…to options to grant runtime-only access for reflection. Note, this is runtime-only!

We won’t be able to compile against private types, and we should never need to anyway.

If we must have access to a module for reflection, and we’re not the owner of that module (i.e., we can’t use the opens…to directive), then it’s possible to use the command line –add-opens option to allow own modules reflection access to the locked down module at runtime.


The only caveat here’s that you need to have access to the command line arguments that are used to run a module for this to work.

                14.10.4.2.11 Putting It All Together - java modules demo, tags: Putting It All Together - java modules demo
Now that we know what a module is and how to use them let’s go ahead and build a simple project to demonstrate all the concepts we just learned.

To keep things simple, we won’t be using Maven or Gradle. Instead, we’ll rely on the command line tools to build our modules.

                    14.10.4.2.11.1 directory structure
[i500695@WYLQRXL9LQ:2023-09-18 15:54:36:~/work/code/java/features/java_8/modules:]2144$ mkdir simple-modules
[i500695@WYLQRXL9LQ:2023-09-18 15:56:50:~/work/code/java/features/java_8/modules:]2145$ mkdir simple-modules/hello.modules
[i500695@WYLQRXL9LQ:2023-09-18 15:57:02:~/work/code/java/features/java_8/modules:]2146$ mkdir simple-modules/hello.modules/com
[i500695@WYLQRXL9LQ:2023-09-18 15:57:17:~/work/code/java/features/java_8/modules:]2147$ mkdir simple-modules/hello.modules/com/baeldung
[i500695@WYLQRXL9LQ:2023-09-18 15:57:32:~/work/code/java/features/java_8/modules:]2148$ mkdir simple-modules/hello.modules/com/baeldung/modules
[i500695@WYLQRXL9LQ:2023-09-18 15:57:42:~/work/code/java/features/java_8/modules:]2149$ mkdir simple-modules/hello.modules/com/baeldung/modules/hello
[i500695@WYLQRXL9LQ:2023-09-18 15:57:45:~/work/code/java/features/java_8/modules:]2150$ mkdir simple-modules/main.app
[i500695@WYLQRXL9LQ:2023-09-18 15:57:54:~/work/code/java/features/java_8/modules:]2151$ mkdir simple-modules/main.app/com
[i500695@WYLQRXL9LQ:2023-09-18 15:57:57:~/work/code/java/features/java_8/modules:]2152$ mkdir simple-modules/main.app/com/baeldung
[i500695@WYLQRXL9LQ:2023-09-18 15:58:02:~/work/code/java/features/java_8/modules:]2153$ mkdir simple-modules/main.app/com/baeldung/modules
[i500695@WYLQRXL9LQ:2023-09-18 15:58:06:~/work/code/java/features/java_8/modules:]2154$ mkdir simple-modules/main.app/com/baeldung/modules/main
[i500695@WYLQRXL9LQ:2023-09-18 15:58:08:~/work/code/java/features/java_8/modules:]2155$ dir_tree 
   |-simple-modules
   |---hello.modules
   |-----com
   |-------baeldung
   |---------modules
   |-----------hello
   |---main.app
   |-----com
   |-------baeldung
   |---------modules
   |-----------main

                    14.10.4.2.11.2 first module
package:com.baeldung.modules.hello 
class: HelloModules.java 
package com.baeldung.modules.hello;

public class HelloModules {
    public static void doSomething() {
        System.out.println("Hello, Modules!");
    }
}

descriptor: module-info.java
module hello.modules {
    exports com.baeldung.modules.hello;
}
Note that this means we export all public members

all together:
[i500695@WYLQRXL9LQ:2023-09-18 15:58:27:~/work/code/java/features/java_8/modules:]2156$ ed simple-modules/hello.modules/com/baeldung/HelloModules.java 
simple-modules/hello.modules/com/baeldung/HelloModules.java: No such file or directory
a
package com.baeldung.modules.hello;

public class HelloModules {
    public static void doSomething() {
        System.out.println("Hello, Modules!");
    }
}
.
w
159
q
[i500695@WYLQRXL9LQ:2023-09-18 17:53:46:~/work/code/java/features/java_8/modules:]2157$ ed simple-modules/hello.modules/module-info.java
simple-modules/hello.modules/module-info.java: No such file or directory
a
module hello.modules {
    exports com.baeldung.modules.hello;
}
.
w
65
q


                    14.10.4.2.11.3 second module
- create module descriptor, note we don't export anything (no need), just importing hello.modules
[i500695@WYLQRXL9LQ:2023-09-18 17:54:49:~/work/code/java/features/java_8/modules:]2158$ ed simple-modules/main.app/module-info.java
simple-modules/main.app/module-info.java: No such file or directory
a
module main.app {
    requires hello.modules;
}
.
w
48
q

- create the using app
[i500695@WYLQRXL9LQ:2023-09-18 17:56:40:~/work/code/java/features/java_8/modules:]2159$ ed simple-modules/main.app/com/baeldung/MainApp.java
simple-modules/main.app/com/baeldung/MainApp.java: No such file or directory
a
package com.baeldung.modules.main;

import com.baeldung.modules.hello.HelloModules;

public class MainApp {
    public static void main(String[] args) {
        HelloModules.doSomething();
    }
}
.
w
197
q


                    14.10.4.2.11.4 build
[i500695@WYLQRXL9LQ:2023-09-18 17:59:43:~/work/code/java/features/java_8/modules:]2161$ ed compile-simple-modules.sh
compile-simple-modules.sh: No such file or directory
a
#!/usr/bin/env bash
javac -d outDir --module-source-path simple-modules $(find simple-modules -name "*.java")
.
w
110
q
[i500695@WYLQRXL9LQ:2023-09-18 18:00:13:~/work/code/java/features/java_8/modules:]2162$ . !$
. compile-simple-modules.sh
[i500695@WYLQRXL9LQ:2023-09-18 18:00:16:~/work/code/java/features/java_8/modules:]2163$ ls outDir/
hello.modules/	main.app/

                    14.10.4.2.11.5 Run
[i500695@WYLQRXL9LQ:2023-09-18 18:00:22:~/work/code/java/features/java_8/modules:]2164$ ed run-simple-module-app.sh
run-simple-module-app.sh: No such file or directory
a
#!/usr/bin/env bash
java --module-path outDir -m main.app/com.baeldung.modules.main.MainApp
.
w
92
q
[i500695@WYLQRXL9LQ:2023-09-18 18:01:30:~/work/code/java/features/java_8/modules:]2165$ . !$
. run-simple-module-app.sh
Hello, Modules!


                    14.10.4.2.11.6 Adding a Service
Now that we have a basic understanding of how to build a module, let’s make it a little more complicated.
We’re going to see how to use the provides…with and uses directives.
Start by defining a new file in the hello.modules module named HelloInterface.java, and adapting HelloModules class to implement it...
[i500695@WYLQRXL9LQ:2023-09-18 18:01:43:~/work/code/java/features/java_8/modules:]2166$ ed simple-modules/hello.modules/com/baeldung/HelloInterface.java
simple-modules/hello.modules/com/baeldung/HelloInterface.java: No such file or directory
a
public interface HelloInterface {
    void sayHello();
}
.
w
57
q
[i500695@WYLQRXL9LQ:2023-09-18 18:03:39:~/work/code/java/features/java_8/modules:]2167$ ed simple-modules/hello.modules/com/baeldung/HelloModules.java 
159
%d
a
public class HelloModules implements HelloInterface {
    public static void doSomething() {
        System.out.println("Hello, Modules!");
    }

    public void sayHello() {
        System.out.println("Hello!");
    }
}
.
w
222
q

That is all we need to do to create a service.
Now, we need to tell the world that our module provides this service.
Add the following to our module-info.java:
provides com.baeldung.modules.hello.HelloInterface with com.baeldung.modules.hello.HelloModules;
As we can see, we declare the interface and which class implements it.
$ cat simple-modules/hello.modules/module-info.java
module hello.modules {
    exports com.baeldung.modules.hello;
    provides com.baeldung.modules.hello.HelloInterface with com.baeldung.modules.hello.HelloModules;
}

As we can see, we declare the interface and which class implements it.

Next, we need to consume this service. In our main.app module, let’s add the following to our module-info.java:

uses com.baeldung.modules.hello.HelloInterface;

$ cat simple-modules/main.app/module-info.java
module main.app {
    requires hello.modules;
    uses com.baeldung.modules.hello.HelloInterface;
}

Finally, in our main method we can use this service via a ServiceLoader:
Iterable<HelloInterface> services = ServiceLoader.load(HelloInterface.class);
HelloInterface service = services.iterator().next();
service.sayHello();

$cat simple-modules/main.app/com/baeldung/modules/main/MainApp.java
package com.baeldung.modules.main;

import com.baeldung.modules.hello.HelloModules;

public class MainApp {
    public static void main(String[] args) {
        // HelloModules.doSomething();
        Iterable<HelloInterface> services = ServiceLoader.load(HelloInterface.class);
        HelloInterface service = services.iterator().next();
        service.sayHello();
    }
}

                14.10.4.2.12 Final demo structure and code
[i500695@WYLQRXL9LQ:2023-09-18 18:27:23:~/work/code/java/features/java_8/modules:]2199$ dir_tree 
   |-outDir
   |---hello.modules
   |-----com
   |-------baeldung
   |---------modules
   |-----------hello
   |---main.app
   |-----com
   |-------baeldung
   |---------modules
   |-----------main
   |-simple-modules
   |---hello.modules
   |-----com
   |-------baeldung
   |---------modules
   |-----------hello
   |---main.app
   |-----com
   |-------baeldung
   |---------modules
   |-----------main
[i500695@WYLQRXL9LQ:2023-09-18 18:27:45:~/work/code/java/features/java_8/modules:]2200$ for file in $(find . -name '*.java'); do echo $file; cat $file; echo "--------"; done
./simple-modules/hello.modules/module-info.java
module hello.modules {
    exports com.baeldung.modules.hello;
    provides com.baeldung.modules.hello.HelloInterface with com.baeldung.modules.hello.HelloModules;
}
--------
./simple-modules/hello.modules/com/baeldung/modules/hello/HelloModules.java
package com.baeldung.modules.hello;
public class HelloModules implements HelloInterface {
    public static void doSomething() {
        System.out.println("Hello, Modules!");
    }

    public void sayHello() {
        System.out.println("Hello!");
    }
}
--------
./simple-modules/hello.modules/com/baeldung/modules/hello/HelloInterface.java
package com.baeldung.modules.hello;
public interface HelloInterface {
    void sayHello();
}
--------
./simple-modules/main.app/module-info.java
module main.app {
    requires hello.modules;
    uses com.baeldung.modules.hello.HelloInterface;
}
--------
./simple-modules/main.app/com/baeldung/modules/main/MainApp.java
package com.baeldung.modules.main;

import java.util.ServiceLoader;

import com.baeldung.modules.hello.HelloInterface;

public class MainApp {
    public static void main(String[] args) {
        // HelloModules.doSomething();
        Iterable<HelloInterface> services = ServiceLoader.load(HelloInterface.class);
        HelloInterface service = services.iterator().next();
        service.sayHello();
    }
}
--------
[i500695@WYLQRXL9LQ:2023-09-18 18:27:47:~/work/code/java/features/java_8/modules:]2201$ . compile-simple-modules.sh
[i500695@WYLQRXL9LQ:2023-09-18 18:28:05:~/work/code/java/features/java_8/modules:]2202$ . run-simple-module-app.sh
Hello!

                14.10.4.2.13 Adding Modules to the Unnamed Module
The unnamed module concept is similar to the default package. Therefore, it’s not considered a real module, but can be viewed as the default module.

If a class is not a member of a named module, then it will be automatically considered as part of this unnamed module.

Sometimes, to ensure specific platform, library, or service-provider modules in the module graph, we need to add modules to the default root set. For example, when we try to run Java 8 programs as-is with Java 9 compiler we may need to add modules.

In general, the option to add the named modules to the default set of root modules is –add-modules <module>(,<module>)* where <module> is a module name.

For example, to provide access to all java.xml.bind modules the syntax would be:

--add-modules java.xml.bind
Copy
To use this in Maven, we can embed the same to the maven-compiler-plugin:

<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>3.8.0</version>
    <configuration>
        <source>9</source>
        <target>9</target>
        <compilerArgs>
            <arg>--add-modules</arg>
            <arg>java.xml.bind</arg>
        </compilerArgs>
    </configuration>
</plugin>

                14.10.4.2.14
            14.10.4.3
            14.10.4.4
        14.10.5 Process API Improvements
Java SE 9 is coming with some improvements in Process API. They have added couple new classes and methods to ease the controlling and managing of OS processes. Two new interfcase in Process API:

java.lang.ProcessHandle
java.lang.ProcessHandle.Info

            14.10.5.1  chatgpt

Java 9 introduced several improvements to the Process API to enhance the interaction between Java applications and native processes, making it easier to manage and control external processes. These improvements include the introduction of the `ProcessHandle` interface and related methods. Here are some of the key enhancements:

| 1. **Introduction of `ProcessHandle` Interface**: Java 9 introduced the `java.lang.ProcessHandle` interface, which represents a native process. This interface provides methods for inspecting and controlling processes.
| 
| 2. **Listing All Processes**: You can use the `ProcessHandle.allProcesses()` method to obtain a stream of all currently running processes on the system. This allows you to inspect and interact with each process.
| 
| ```java
| ProcessHandle.allProcesses().forEach(process -> {
|     System.out.println("PID: " + process.pid());
|     System.out.println("Command: " + process.info().command().orElse("N/A"));
|     System.out.println("Arguments: " + String.join(" ", process.info().arguments().orElse(new String[] {})));
| });
| ```
| 
| 3. **Accessing Process Information**: The `ProcessHandle` interface provides methods to retrieve information about a process, such as its PID (Process ID), command, arguments, start time, user, and more.

```java
ProcessHandle process = ... // Obtain a ProcessHandle
System.out.println("PID: " + process.pid());
System.out.println("Command: " + process.info().command().orElse("N/A"));
System.out.println("Arguments: " + String.join(" ", process.info().arguments().orElse(new String[] {})));
System.out.println("Start Time: " + process.info().startInstant().orElse(null));
System.out.println("User: " + process.info().user().orElse("N/A"));
```

|4. **Destroying and Monitoring Processes**: You can use the `destroy()` and `destroyForcibly()` methods to terminate a process. Additionally, you can use the `isAlive()` method to check if a process is still running. These methods make it easier to manage external processes from Java.

```java
ProcessHandle process = ... // Obtain a ProcessHandle
boolean destroyed = process.destroy();
boolean forciblyDestroyed = process.destroyForcibly();
boolean isAlive = process.isAlive();
```

|5. **OnExit Callbacks**: You can register an `onExit` callback with a `ProcessHandle` to perform actions when a process exits. This allows you to respond to process termination events.

```java
ProcessHandle process = ... // Obtain a ProcessHandle
process.onExit().thenAccept(p -> System.out.println("Process exited with PID: " + p.pid()));
```

These enhancements to the Process API in Java 9 make it more powerful and versatile for managing external processes, inspecting process information, and responding to process events, improving the overall interaction between Java applications and the underlying operating system.


            14.10.5.2 demo
[i500695@WYLQRXL9LQ:2023-09-19 18:30:02:~/work/code/java/features/java_9/process_handle:]2226$ cat ProcessHandleDemo.java 
class ProcessHandleDemo {
    public static void main(String[] args) {
        ProcessHandle.allProcesses().forEach(process -> {
            String user = process.info().user().orElse("N/A");
            if (user.equals("i500695")) { //print my processes 
                System.out.printf("PID=%d, Command=%s, Arguments=%s, Start time=%s, user=%s \n", process.pid(),
                        process.info().command().orElse("N/A"),
                        String.join(" ", process.info().arguments().orElse(new String[] {})),
                        process.info().startInstant().orElse(null),
                        process.info().user().orElse("N/A"));

            }
        });

    }
}[i500695@WYLQRXL9LQ:2023-09-19 18:30:49:~/work/code/java/features/java_9/process_handle:]2227$ javac ProcessHandleDemo.java 
[i500695@WYLQRXL9LQ:2023-09-19 18:30:52:~/work/code/java/features/java_9/process_handle:]2228$ java ProcessHandleDemo | head -n 4
PID=27795, Command=/opt/homebrew/Cellar/openjdk/20.0.2/libexec/openjdk.jdk/Contents/Home/bin/java, Arguments=ProcessHandleDemo, Start time=2023-09-19T15:30:58.289Z, user=i500695 
PID=27796, Command=/usr/bin/head, Arguments=-n 4, Start time=2023-09-19T15:30:58.291Z, user=i500695 
PID=27745, Command=/System/Library/Frameworks/CoreServices.framework/Frameworks/Metadata.framework/Versions/A/Support/mdworker_shared, Arguments=-s mdworker -c MDSImporterWorker -m com.apple.mdworker.shared, Start time=2023-09-19T15:30:15.186Z, user=i500695 
PID=27722, Command=/System/Library/PrivateFrameworks/HelpData.framework/Versions/A/Resources/helpd, Arguments=, Start time=2023-09-19T15:30:02.319Z, user=i500695 

            14.10.5.3  try-with-resources statement 

                14.10.5.3.1   explanation


The try-with-resources statement is a try statement with one or more resources duly declared. Here resource is an object which should be closed once it is no more required. The try-with-resources statement ensures that each resource is closed after the requirement finishes. Any object implementing java.lang.AutoCloseable or java.io.Closeable, interface can be used as a resource.

Prior to Java 9, resources are to be declared before try or inside try statement as shown below in given example. In this example, we'll use BufferedReader as resource to read a string and then BufferedReader is to be closed.

Tester.java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;

public class Tester {
   public static void main(String[] args) throws IOException {
      System.out.println(readData("test"));
   } 
   static String readData(String message) throws IOException {
      Reader inputString = new StringReader(message);
      BufferedReader br = new BufferedReader(inputString);
      try (BufferedReader br1 = br) {
         return br1.readLine();
      }
   }
}

Output
test
Here we need to declare a resource br1 within try statment and then use it. In Java9, we don't need to declare br1 anymore and following program will give the same result.

Tester.java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;

public class Tester {
   public static void main(String[] args) throws IOException {
      System.out.println(readData("test"));
   } 
   static String readData(String message) throws IOException {
      Reader inputString = new StringReader(message);
      BufferedReader br = new BufferedReader(inputString);
      try (br) {
         return br.readLine();
      }
   }
}

Output
test

                14.10.5.3.2 demo
[i500695@WYLQRXL9LQ:2023-09-19 18:39:10:~/work/code/java/features/java_9/try_with_resource:]2237$ cat TryWithResourceDemo.java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;

public class TryWithResourceDemo{
   public static void main(String[] args) throws IOException {
      System.out.println(readData("Try-With-Resource demo. resource will auto close after try clause"));
   } 

   static String readData(String message) throws IOException {
      Reader inputString = new StringReader(message);
      BufferedReader br = new BufferedReader(inputString);
      try (br) {
         return br.readLine();
      }
   }
}
[i500695@WYLQRXL9LQ:2023-09-19 18:39:19:~/work/code/java/features/java_9/try_with_resource:]2238$ javac TryWithResourceDemo.java 
[i500695@WYLQRXL9LQ:2023-09-19 18:39:20:~/work/code/java/features/java_9/try_with_resource:]2239$ java TryWithResourceDemo
Try-With-Resource demo. resource will auto close after try clause

                14.10.5.3.3

        14.10.6 CompletableFuture API Improvements in java 9

            14.10.6.1  GPT
Java 9 introduced several improvements to the `CompletableFuture` class, which is part of the Java Concurrency framework and is used for asynchronous and concurrent programming. These improvements aimed to enhance the usability and flexibility of the `CompletableFuture` API. Here are some of the key improvements:

**1. Factory Methods for `CompletableFuture`**

Java 9 introduced factory methods for creating instances of `CompletableFuture`. These methods simplify the creation of completed, exceptionally completed, and incomplete futures:

- `CompletableFuture.completedFuture(T value)`: Returns a new `CompletableFuture` that is already completed with the given value.
- `CompletableFuture.failedFuture(Throwable ex)`: Returns a new `CompletableFuture` that is already exceptionally completed with the given exception.
- `new CompletableFuture().obtrudeValue(T value)`: Explicitly sets the value of a `CompletableFuture`, making it completed.
- `new CompletableFuture().obtrudeException(Throwable ex)`: Explicitly sets an exception for a `CompletableFuture`, making it exceptionally completed.

**2. Improved `thenAccpet`, `thenApply`, and `thenRun` Variants**

In Java 9, the `thenAccept`, `thenApply`, and `thenRun` methods were enhanced to include async variants that allow you to specify an executor for the dependent action. This provides more control over the execution context:

- `thenAcceptAsync(Consumer<? super T> action, Executor executor)`: Executes the action asynchronously using the specified executor when the source `CompletableFuture` completes.
- `thenApplyAsync(Function<? super T,? extends U> fn, Executor executor)`: Applies the function asynchronously using the specified executor when the source `CompletableFuture` completes.
- `thenRunAsync(Runnable action, Executor executor)`: Runs the action asynchronously using the specified executor when the source `CompletableFuture` completes.

**3. `or` and `completeOnTimeout` Methods**

- `or`: Introduced as an alternative to `applyToEither` and `acceptEither`, `or` returns a new `CompletableFuture` that is completed with the result of the first of the given CompletableFutures to complete.
- `completeOnTimeout`: Allows you to complete a `CompletableFuture` with a default value if it hasn't completed within a specified timeout.

**4. `completeAsync` and `obtrudeAsync` Methods**

- `completeAsync`: Completes a `CompletableFuture` asynchronously using a supplied supplier or future supplier.
- `obtrudeAsync`: Similar to `obtrudeValue` and `obtrudeException`, but performs the operation asynchronously.

**5. `delayedExecutor` Method**

Introduced the `delayedExecutor` method in the `Executor` interface, which returns an executor that introduces a delay between submission and execution of tasks.

These improvements in Java 9 make working with `CompletableFuture` more powerful and flexible, allowing developers to write asynchronous and concurrent code more efficiently and effectively. They provide better control over execution contexts, handling exceptional cases, and specifying timeout behavior.
            14.10.6.2 GTP demo
Certainly! Let's create a simple demo that showcases some of the `CompletableFuture` API improvements introduced in Java 9.

In this example, we'll cover the following features:
|1. Factory methods for `CompletableFuture`.
|2. Improved `thenAcceptAsync`, `thenApplyAsync`, and `thenRunAsync`.
|3. `or` method for handling the first completed future.
|4. `completeOnTimeout` for setting a timeout.
|5. `delayedExecutor` for introducing a delay.

```java
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class CompletableFutureDemo {
    public static void main(String[] args) throws Exception {
        // Factory methods
        CompletableFuture<Integer> completedFuture = CompletableFuture.completedFuture(42);
        CompletableFuture<String> failedFuture = CompletableFuture.failedFuture(new RuntimeException("Failed!"));

        // thenAcceptAsync with a custom executor
        Executor customExecutor = Executors.newSingleThreadExecutor();
        CompletableFuture<Void> thenAcceptAsyncDemo = completedFuture.thenAcceptAsync(result -> {
            System.out.println("Received result: " + result);
            System.out.println("Thread: " + Thread.currentThread().getName());
        }, customExecutor);

        // or method to handle the first completed future
        CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "Result from Future 1");
        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> "Result from Future 2");
        CompletableFuture<String> firstCompleted = future1.or(() -> future2);

        // completeOnTimeout to handle a timeout
        CompletableFuture<Integer> delayedFuture = CompletableFuture.supplyAsync(() -> {
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return 100;
        });

        CompletableFuture<Integer> result = delayedFuture.completeOnTimeout(42, 1, TimeUnit.SECONDS);

        // delayedExecutor to introduce a delay
        Executor delayedExecutor = Executors.newScheduledThreadPool(1);
        CompletableFuture<Void> delayedDemo = CompletableFuture.runAsync(() -> {
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Task executed after a delay.");
        }, delayedExecutor);

        // Wait for completion
        thenAcceptAsyncDemo.get();
        System.out.println("First completed: " + firstCompleted.join());
        System.out.println("Timeout result: " + result.join());
        delayedDemo.get();
    }
}
```

In this demo:

- We use factory methods to create completed and failed futures.
- `thenAcceptAsync` demonstrates asynchronous execution with a custom executor.
- `or` method allows us to choose the result from the first completed future.
- `completeOnTimeout` demonstrates setting a timeout for a future.
- `delayedExecutor` is used to introduce a delay in the execution of a task.

Make sure to replace the custom executor and file paths with appropriate values for your environment.


            14.10.6.3 my demo
[i500695@WYLQRXL9LQ:2023-09-26 19:02:13:~/work/code/java/features/java_9/CompletableFuture:]2023$ cat CompletableFutureDemo.java 
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class CompletableFutureDemo {
    public static void main(String[] args) throws Exception {
        
        // Factory methods
        CompletableFuture<Integer> completedFuture = CompletableFuture.completedFuture(42);
        CompletableFuture<String> failedFuture = CompletableFuture.failedFuture(new RuntimeException("Failed!"));

        // thenAcceptAsync with a custom executor
        Executor customExecutor = Executors.newSingleThreadExecutor();
        CompletableFuture<Void> thenAcceptAsyncDemo = completedFuture.thenAcceptAsync(result -> {
            System.out.println("Received result: " + result);
            System.out.println("Thread: " + Thread.currentThread().getName());
        }, customExecutor);

        // or method to handle the first completed future
        CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "Result from Future 1");
        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> "Result from Future 2");
        CompletableFuture<String> firstCompleted = future1.thenCombine(future2, (res1, res2) -> res1+" | "+res2);
        firstCompleted.thenAccept( res3 -> System.out.println("Combined result of two futures: " + res3));

        // completeOnTimeout to handle a timeout
        CompletableFuture<Integer> delayedFuture = CompletableFuture.supplyAsync(() -> {
            try {
                TimeUnit.SECONDS.sleep(2); //simulate long running task
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return 100; //return value
        });

        CompletableFuture<Integer> result = delayedFuture.completeOnTimeout(42, 1, TimeUnit.SECONDS); // 42 is value to return on TO, 1 is TO, in seconds

        // delayedExecutor to introduce a delay
        Executor delayedExecutor = Executors.newScheduledThreadPool(1); // 1 thread in executor thread pool
        CompletableFuture<Void> delayedDemo = CompletableFuture.runAsync(() -> {
            try {
                TimeUnit.SECONDS.sleep(2); // this is the delay
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Task executed after a delay."); // this is the task
        }, delayedExecutor);

        // Wait for completion
        thenAcceptAsyncDemo.get();
        System.out.println("First completed: " + firstCompleted.join());
        System.out.println("Timeout result: " + result.join());
        delayedDemo.get();
    }
}
[i500695@WYLQRXL9LQ:2023-09-26 19:02:51:~/work/code/java/features/java_9/CompletableFuture:]2024$ javac CompletableFutureDemo.java 
[i500695@WYLQRXL9LQ:2023-09-26 19:02:57:~/work/code/java/features/java_9/CompletableFuture:]2025$ java CompletableFutureDemo
Received result: 42
Thread: pool-1-thread-1
Combined result of two futures: Result from Future 1 | Result from Future 2
First completed: Result from Future 1 | Result from Future 2
Timeout result: 42
Task executed after a delay.
            14.10.6.4

        14.10.7 java 9 reactive streams 

            14.10.7.1 https://www.baeldung.com/java-9-reactive-streams

                14.10.7.1.1 Overview
In this article, we’ll be looking at the Java 9 Reactive Streams. Simply put, we’ll be able to use the Flow class, which encloses the primary building blocks for building reactive stream processing logic.

Reactive Streams is a standard for asynchronous stream processing with non-blocking back pressure. This specification is defined in the Reactive Manifesto, and there are various implementations of it, for example, RxJava or Akka-Streams.

                14.10.7.1.2 Reactive API Overview
To build a Flow, we can use three main abstractions and compose them into asynchronous processing logic.

Every Flow needs to process events that are published to it by a Publisher instance; the Publisher has one method – subscribe().

If any of the subscribers want to receive events published by it, they need to subscribe to the given Publisher.


The receiver of messages needs to implement the Subscriber interface. Typically this is the end for every Flow processing because the instance of it does not send messages further.

We can think about Subscriber as a Sink. This has four methods that need to be overridden – onSubscribe(), onNext(), onError(), and onComplete(). We’ll be looking at those in the next section.

If we want to transform incoming message and pass it further to the next Subscriber, we need to implement the Processor interface. This acts both as a Subscriber because it receives messages, and as the Publisher because it processes those messages and sends them for further processing.

                14.10.7.1.3 Publishing and Consuming Messages
Let’s say we want to create a simple Flow, in which we have a Publisher publishing messages, and a simple Subscriber consuming messages as they arrive – one at the time.

Let’s create an EndSubscriber class. We need to implement the Subscriber interface. Next, we’ll override the required methods.
The onSubscribe() method is called before processing starts. The instance of the Subscription is passed as the argument. It is a class that is used to control the flow of messages between Subscriber and the Publisher:
public class EndSubscriber<T> implements Subscriber<T> {
    private Subscription subscription;
    public List<T> consumedElements = new LinkedList<>();

    @Override
    public void onSubscribe(Subscription subscription) {
        this.subscription = subscription;
        subscription.request(1);
    }
}
We also initialized an empty List of consumedElements that’ll be utilized in the tests.

Now, we need to implement the remaining methods from the Subscriber interface. The main method here is onNext() – this is called whenever the Publisher publishes a new message:
@Override
public void onNext(T item) {
    System.out.println("Got : " + item);
    consumedElements.add(item);
    subscription.request(1);
}
Note that when we started the subscription in the onSubscribe() method and when we processed a message we need to call the request() method on the Subscription to signal that the current Subscriber is ready to consume more messages.

Lastly, we need to implement onError() – which is called whenever some exception will be thrown in the processing, as well as onComplete() – called when the Publisher is closed:
@Override
public void onError(Throwable t) {
    t.printStackTrace();
}

@Override
public void onComplete() {
    System.out.println("Done");
}

Let’s write a test for the Processing Flow. We’ll be using the SubmissionPublisher class – a construct from the java.util.concurrent – which implements the Publisher interface.

We’re going to be submitting N elements to the Publisher – which our EndSubscriber will be receiving:
@Test
public void whenSubscribeToIt_thenShouldConsumeAll() 
  throws InterruptedException {
 
    // given
    SubmissionPublisher<String> publisher = new SubmissionPublisher<>();
    EndSubscriber<String> subscriber = new EndSubscriber<>();
    publisher.subscribe(subscriber);
    List<String> items = List.of("1", "x", "2", "x", "3", "x");

    // when
    assertThat(publisher.getNumberOfSubscribers()).isEqualTo(1);
    items.forEach(publisher::submit);
    publisher.close();

    // then
     await().atMost(1000, TimeUnit.MILLISECONDS)
       .until(
         () -> assertThat(subscriber.consumedElements)
         .containsExactlyElementsOf(items)
     );
}
                14.10.7.1.4

            14.10.7.2 chatgpt
Java 9 introduced the Reactive Streams API as part of the `java.util.concurrent.Flow` package. Reactive Streams are a standard for asynchronous stream processing in Java, designed to handle asynchronous and backpressure-aware stream processing. Here's a simple example of using the Reactive Streams API in Java 9:

```java
import java.util.concurrent.Flow.*;
import java.util.concurrent.SubmissionPublisher;
import java.util.concurrent.TimeUnit;

public class ReactiveStreamsExample {
    public static void main(String[] args) throws InterruptedException {
        // Create a SubmissionPublisher
        SubmissionPublisher<Integer> publisher = new SubmissionPublisher<>();

        // Create a Subscriber
        Subscriber<Integer> subscriber = new Subscriber<Integer>() {
            private Subscription subscription;

            @Override
            public void onSubscribe(Subscription subscription) {
                this.subscription = subscription;
                subscription.request(1); // Request the first item
            }

            @Override
            public void onNext(Integer item) {
                System.out.println("Received: " + item);
                subscription.request(1); // Request the next item
            }

            @Override
            public void onError(Throwable throwable) {
                throwable.printStackTrace();
            }

            @Override
            public void onComplete() {
                System.out.println("Done");
            }
        };

        // Subscribe the subscriber to the publisher
        publisher.subscribe(subscriber);

        // Publish some items
        for (int i = 1; i <= 5; i++) {
            publisher.submit(i);
            TimeUnit.MILLISECONDS.sleep(500); // Sleep to simulate asynchronous processing
        }

        // Close the publisher (important to avoid resource leaks)
        publisher.close();

        // Wait for a while to let the processing complete
        TimeUnit.SECONDS.sleep(2);
    }
}
```

In this example:

|1. We create a `SubmissionPublisher<Integer>` to publish integer items.
|
|2. We create a `Subscriber<Integer>` to subscribe to the publisher.
|
|3. In the `onSubscribe()` method of the subscriber, we request the first item to start the flow.
|
|4. In the `onNext()` method, we process received items and request the next one.
|
|5. In the `onError()` method, we handle errors if they occur.
|
|6. In the `onComplete()` method, we handle the completion of the stream.
|
|7. We subscribe the subscriber to the publisher.
|
|8. We publish integer items from 1 to 5 to the publisher with a 500ms delay between each item to simulate asynchronous processing.
|
|9. Finally, we close the publisher and wait for a while to ensure that all items are processed.

This example demonstrates the basic usage of the Reactive Streams API in Java 9, including publishing, subscribing, and handling items in a reactive and backpressure-aware manner.

            14.10.7.3

        14.10.8 Diamond Operator for Anonymous Inner Class
We know, Java SE 7 has introduced one new feature: Diamond Operator to avoid redundant code and verbosity, to improve readability. However, in Java SE 8, Oracle Corp (Java Library Developer) has found that some limitations in the use of Diamond operator with Anonymous Inner Class. They have fixed those issues and going to release them as part of Java 9.

  public List getEmployee(String empid){
     // Code to get Employee details from Data Store
     return new List(emp){ };
  }
Here we are using just “List” without specifying the type parameter.


        14.10.9 Optional Class Improvements
In Java SE 9, Oracle Corp has added some useful new methods to java.util.Optional class. Here I’m going to discuss about one of those methods with some simple example: stream method If a value present in the given Optional object, this stream() method returns a sequential Stream with that value. Otherwise, it returns an empty Stream. They have added “stream()” method to work on Optional objects lazily as shown below:

Stream<Optional> emp = getEmployee(id)
Stream empStream = emp.flatMap(Optional::stream)
Here Optional.stream() method is used to convert a Stream of Optional of Employee object into a Stream of Employee so that we can work on this result lazily in the result code.

        14.10.10 Stream API Improvements
In Java SE 9, Oracle Corp has added four useful new methods to java.util.Stream interface. As Stream is an interface, all those new implemented methods are default methods. Two of them are very important: dropWhile and takeWhile methods If you are familiar with Scala Language or any Functions programming language, you will definitely know about these methods. These are very useful methods in writing some functional style code. Let us discuss the takeWhile utility method here. This takeWhile() takes a predicate as an argument and returns a Stream of the subset of the given Stream values until that Predicate returns false for the first time. If the first value does NOT satisfy that Predicate, it just returns an empty Stream.

jshell> Stream.of(1,2,3,4,5,6,7,8,9,10).takeWhile(i -> i < 5 )
                 .forEach(System.out::println);

        14.10.11 Enhanced @Deprecated annotation
In Java SE 8 and earlier versions, @Deprecated annotation is just a Marker interface without any methods. It is used to mark a Java API that is a class, field, method, interface, constructor, enum etc. In Java SE 9, Oracle Corp has enhanced @Deprecated annotation to provide more information about deprecated API and also provide a Tool to analyze an application’s static usage of deprecated APIs. They have add two methods to this Deprecated interface: forRemoval and since to serve this information

        14.10.12 HTTP 2 Client
In Java SE 9, Oracle Corp is going to release New HTTP 2 Client API to support HTTP/2 protocol and WebSocket features. As existing or Legacy HTTP Client API has numerous issues (like supports HTTP/1.1 protocol and does not support HTTP/2 protocol and WebSocket, works only in Blocking mode and lot of performance issues.), they are replacing this HttpURLConnection API with new HTTP client. They are going to introduce a new HTTP 2 Client API under the “java.net.http” package. It supports both HTTP/1.1 and HTTP/2 protocols. It supports both Synchronous (Blocking Mode) and Asynchronous Modes. It supports Asynchronous Mode using the WebSocket API. We can see this new API at https://download.java.net/java/jdk9/docs/api/java/net/http/package-summary.html HTTP 2 Client Example

jshell> import java.net.http.*

jshell> import static java.net.http.HttpRequest.*

jshell> import static java.net.http.HttpResponse.*

jshell> URI uri = new URI("https://rams4java.blogspot.co.uk/2016/05/java-news.html")
uri ==> https://rams4java.blogspot.co.uk/2016/05/java-news.html

jshell> HttpResponse response = HttpRequest.create(uri).body(noBody()).GET().response()
response ==> java.net.http.HttpResponseImpl@79efed2d

jshell> System.out.println("Response was " + response.body(asString()))


        14.10.13 Multi-Resolution Image API
In Java SE 9, Oracle Corp is going to introduce a new Multi-Resolution Image API. Important interface in this API is MultiResolutionImage . It is available in java.awt.image package. MultiResolutionImage encapsulates a set of images with different Height and Widths (that is different resolutions) and allows us to query them with our requirements.

        14.10.14 Miscellaneous Java 9 Features
In this section, I will just list out some miscellaneous Java SE 9 New Features. I’m NOT saying these are less important features. They are also important and useful to understand them very well with some useful examples. As of now, I did not get enough information about these features. That’s why I am going to list them here for a brief understanding. I will pick up these features one by one and add to the above section with a brief discussion and example. And finally write a separate tutorial later.

GC (Garbage Collector) Improvements
Stack-Walking API
Filter Incoming Serialization Data
Deprecate the Applet API
Indify String Concatenation
Enhanced Method Handles
Java Platform Logging API and Service
Compact Strings
Parser API for Nashorn
Javadoc Search
HTML5 Javadoc

        14.10.15
    14.11  Java version 10, tags: Java version 10
Language Changes: Local Variable Type Inference(Var Keyword), Garbage Collector Interface.

        14.11.1   https://javagoal.com/java-10-features/

            14.11.1.1   Java 10 Features
Java 10 was released on March 20, 2018, The JDK 10 is an implementation of JAVA SE 10. As we know, Java is slow in growth and evolution as compared to other languages.  But Java 10 was quick to release after Java 9. With this release, the six-month release cycle has begun. You must think about why I am saying the six-month release cycle. I will explain it below in detail. To understand this concept, we have to understand LTS (Long Term Support model). In this post, we will read the most common and useful Java 10 Features and Java 10 tutorial.


            14.11.1.2 Local Variable Type Inference
Local variable type inference was the biggest feature of Java 10. As we know we have to define a variable with its data type but from Java 10 onward we can use the var keyword to declare the local variables. We don’t need to specify the data type with the variable name. Now it’s the compiler’s responsibility to infer the type of the variable using the value provided. We will discuss it in a separate post with various types of examples and what will be restrictions and rules. You can read it here.

// Declaring and initlizing an int variable with value
int i = 5;
// Declaring and initlizing an String variable with value
String hello = "Hello world!";
// Creating an ArrayList
ArrayList<String> list = new ArrayList<String>();
// Creating a HashMap 
HashMap<Integer, String> hashMap = new HashMap<Integer, String>()
// Declaring and initlizing variable with value
var i = 5;
// Declaring and initlizing variable with value
var hello = "Hello world!";
// Creating an ArrayList
var list = new ArrayList<String>();
// Creating a HashMap 
HashMap<Integer, String> hashMap = new HashMap<Integer, String>()

            14.11.1.3
        14.11.2

    14.11  Java version 11
    Language Changes: The Local Variable Syntax Adds Up For Lambda Parameters.

Library Changes: JEP 321 HTTP Client Standardized.

    14.12  Java version 12
    14.13  Java version 13
    14.14  Java version 14
    14.15  Java version 15
    14.16  Java version 16
    14.17  Java version 17

        14.17.1  Java 17 vs Java 8

            14.17.1.1  https://pretius.com/blog/java-17-features/
A few months from now – in March 2022 – Java 8 will lose its Oracle Premier Support. It doesn’t mean that it won’t receive any new updates, but Oracle’s effort put into maintaining it will likely be significantly smaller than it is right now.

That means there’ll be a good reason to make the move to a new version. Especially since just a month ago – on September 14th, 2021 – Java 17 was released. It’s the new Long Term Support version, with Oracle Premier Support to last until September 2026 (at least). What does Java 17 bring? How difficult will the migration be? Is it worth it? I’ll try to answer those questions in this article.

The popularity of Java 8 – a little bit of history
A screen showing Java logo with a looking glass.
Let’s take a look at some of the features.
Java 8, which was released in March 2014, is currently used by 69% of programmers in their main application. Why is it, after more than 7 years, still the most commonly used version? There are many reasons for that.

Java 8 provided lots of language features that made developers want to switch from previous versions. Lambdas, streams, functional programming, extensive API extensions – not to mention MetaSpace or G1 extensions. It was the Java version to use.

Java 9 appeared 3 years later, in September 2017, and for a typical developer, it changed next to nothing. A new HTTP client, process API, minor diamond operator and try-with-resources improvements. 

Sure, Java 9 did bring one significant change, groundbreaking even – the Jigsaw Project. It changed a lot, a great lot of things – but internally. Java modularization gives great possibilities, solves lots of technical problems, and applies to everyone, but only a relatively small group of users actually needed to deeply understand the changes. Due to the changes introduced with the Jigsaw Project lots of libraries required additional modifications, new versions were released, some of them did not work properly. 

Java 9 migration – in particular for large, corporate applications – was often difficult, time-consuming, and caused regression problems. So why do it, if there is little to gain and it costs a lot of time and money?

This brings us to the current day, October 2021. Java Development Kit 17 (JDK 17) was released just a month ago. Is it a good time to move on from the 7-year-old Java 8? First, let’s see what’s in Java 17. What does it bring to the programmer and admin or SRE, when compared to Java 8?

Java 17 vs Java 8 – the changes
This article covers only the changes that I deemed important enough or interesting enough to mention. They are not everything that was changed, improved, optimized in all the years of Java evolution. If you want to see a full list of changes to JDK, you should know that they are tracked as JEPs (JDK Enhancement Proposals). The list can be found in JEP-0.

Also, if you want to compare Java APIs between versions, there is a great tool called Java Version Almanac. There were many useful, small additions to Java APIs, and checking this website is likely the best option if someone wants to learn about all these changes.

As for now, let’s analyze the changes and new features in each iteration of Java, that are most important from the perspective of most of us Java Developers.

New var keyword
A new var keyword was added that allows local variables to be declared in a more concise manner. Consider this code:

// java 8 way
Map<String, List<MyDtoType>> myMap = new HashMap<String, List<MyDtoType>>();
List<MyDomainObjectWithLongName> myList = aDelegate.fetchDomainObjects();
// java 10 way
var myMap = new HashMap<String, List<MyDtoType>>();
var myList = aDelegate.fetchDomainObjects()
When using var, the declaration it’s much, much shorter and, perhaps, a bit more readable than before. One must make sure to take the readability into account first, so in some cases, it may be wrong to hide the type from the programmer. Take care to name the variables properly.

Unfortunately, it is not possible to assign a lambda to a variable using var keyword:

// causes compilation error: 
//   method reference needs an explicit target-type
var fun = MyObject::mySpecialFunction;
It is, however, possible to use the var in lambda expressions. Take a look at the example below:

boolean isThereAneedle = stringsList.stream()
  .anyMatch((@NonNull var s) -> s.equals(“needle”));
Using var in lambda arguments, we can add annotations to the arguments. 

Records
One may say Records are Java’s answer to Lombok. At least partly, that is. Record is a type designed to store some data. Let me quote a fragment of JEP 395 that describes it well: 

[…] a record acquires many standard members automatically:

A private final field for each component of the state description;
A public read accessor method for each component of the state description, with the same name and type as the component;
A public constructor, whose signature is the same as the state description, which initializes each field from the corresponding argument;
Implementations of equals and hashCode that say two records are equal if they are of the same type and contain the same state; and
An implementation of toString that includes the string representation of all the record components, with their names.
In other words, it’s roughly equivalent to Lombok’s @Value. In terms of language, it’s kind of similar to an enum. However, instead of declaring possible values, you declare the fields. Java generates some code based on that declaration and is capable of handling it in a better, optimized way. Like enum, it can’t extend or be extended by other classes, but it can implement an interface and have static fields and methods. Contrary to an enum, a record can be instantiated with the new keyword.

A record may look like this:

record BankAccount (String bankName, String accountNumber) implements HasAccountNumber {}
And this is it. Pretty short. Short is good!

Any automatically generated methods can be declared manually by the programmer. A set of constructors can be also declared. Moreover, in constructors, all fields that are definitely unassigned are implicitly assigned to their corresponding constructor parameters. It means that the assignment can be skipped entirely in the constructor!

record BankAccount (String bankName, String accountNumber) implements HasAccountNumber {
  public BankAccount { // <-- this is the constructor! no () !
    if (accountNumber == null || accountNumber.length() != 26) {
      throw new ValidationException(“Account number invalid”);
    }
    // no assignment necessary here!
  }
}
For all the details like formal grammar, notes on usage and implementation, make sure to consult the JEP 359. You could also check StackOverflow for the most upvoted questions on Java Records.

Extended switch expressions
Switch is present in a lot of languages, but over the years it got less and less useful because of the limitations it had. Other parts of Java grew, switch did not. Nowadays switch cases can be grouped much more easily and in a more readable manner (note there’s no break!) and the switch expression itself actually returns a result.

DayOfWeek dayOfWeek = LocalDate.now().getDayOfWeek();
boolean freeDay = switch (dayOfWeek) {
    case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -> false;
    case SATURDAY, SUNDAY -> true;
};
Even more can be achieved with the new yield keyword that allows returning a value from inside a code block. It’s virtually a return that works from inside a case block and sets that value as a result of its switch. It can also accept an expression instead of a single value. Let’s take a look at an example:

DayOfWeek dayOfWeek = LocalDate.now().getDayOfWeek();
boolean freeDay = switch (dayOfWeek) {
    case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -> {
      System.out.println("Work work work");
      yield false;
    }
    case SATURDAY, SUNDAY -> {
      System.out.println("Yey, a free day!");
      yield true;
    }
};
Instanceof pattern matching
While not a groundbreaking change, in my opinion, instanceof solves one of the more irritating problems with the Java language. Did you ever have to use such syntax?

if (obj instanceof MyObject) {
  MyObject myObject = (MyObject) obj;
  // … further logic
}
Now, you won’t have to. Java can now create a local variable inside the if, like this:

if (obj instanceof MyObject myObject) {
  // … the same logic
}
It is just one line removed, but it was a totally unnecessary line in terms of the code flow. Moreover, the declared variable can be used in the same if condition, like this:

if (obj instanceof MyObject myObject && myObject.isValid()) {
  // … the same logic
}
 

Are you looking for Java developers?
Schedule a call
Sealed classes
This is a tricky one to explain. Let’s start with this – did the “no default” warning in switch ever annoy you? You covered all the options that the domain accepted, but still, the warning was there. Sealed classes let you get rid of such a warning for the instanceof type checks.

If you have a hierarchy like this:

public abstract sealed class Animal
    permits Dog, Cat {
}
public final class Dog extends Animal {
}
public final class Cat extends Animal {
}
You will now be able to do this:

if (animal instanceof Dog d) {
    return d.woof();
} 
else if (animal instanceof Cat c) {
    return c.meow();
}
And you won’t get a warning. Well, let me rephrase that: if you get a warning with a similar sequence, that warning will be meaningful! And more information is always good.

I have mixed feelings about this change. Introducing a cyclic reference does not seem like a good practice. If I used this in my production code, I’d do my best to hide it somewhere deep and never show it to the outside world – I mean, never expose it through an API, not that I would be ashamed of using it in a valid situation.

TextBlocks
Declaring long strings does not often happen in Java programming, but when it does, it is tiresome and confusing. Java 13 came up with a fix for that, further improved in later releases. A multiline text block can now be declared as follows:

String myWallOfText = ”””
______         _   _           
| ___ \       | | (_)          
| |_/ / __ ___| |_ _ _   _ ___ 
|  __/ '__/ _ \ __| | | | / __|
| |  | | |  __/ |_| | |_| \__ \
\_|  |_|  \___|\__|_|\__,_|___/
”””
There is no need for escaping quotes or newlines. It is possible to escape a newline and keep the string a one-liner, like this:

String myPoem = ”””
Roses are red, violets are blue - \
Pretius makes the best software, that is always true
”””
Which is the equivalent of:

String myPoem = ”Roses are red, violets are blue - Pretius makes the best software, that still is true”.
Text blocks can be used to keep a reasonably readable json or xml template in your code. External files are still likely a better idea, but it’s still a nice option to do it in pure Java if necessary.

Better NullPointerExceptions
So, I had this chain of calls in my app once. And I think it may look familiar to you too:

company.getOwner().getAddress().getCity();
And I got an NPE that told me precisely in which line the null was encountered. Yes, it was that line. Without a debugger I couldn’t tell which object was null, or rather, which invoke operation has actually caused the problem. Now the message will be specific and it’ll tell us that the JVM “cannot invoke Person.getAddress()”. 

Actually, this is more of a JVM change than a Java one – as the bytecode analysis to build the detailed message is performed at runtime JVM – but it does appeal to programmers a lot.

New HttpClient
There are many libraries that do the same thing, but it is nice to have a proper HTTP client in Java itself. You can find a nice introduction to the new APIs in Baeldung.

New Optional.orElseThrow() method
A get() method on Optional is used to get the value under the Optional. If there is no value, this method throws an exception. Like in the code below.

MyObject myObject = myList.stream()
  .filter(MyObject::someBoolean)
  .filter((b) -> false)
  .findFirst()
  .get();
Java 10 introduced a new method in Optional, called orElseThrow(). What does it do? Exactly the same! But consider the readability change for the programmer.

MyObject myObject = myList.stream()
  .filter(MyObject::someBoolean)
  .filter((b) -> false)
  .findFirst()
  .orElseThrow();
Now, the programmer knows exactly what will happen when the object is not found. In fact, using this method is recommended instead of the simple – albeit ubiquitous – get().

Other small but nice API changes
Talk is cheap, this is the code. In bold are the new things.

// invert a Predicate, will be even shorter with static import
collection.stream()
  .filter(Predicate.not(MyObject::isEmpty))
  .collect(Collectors.toList());
// String got some new stuff too
“\nPretius\n rules\n  all!”.repeat(10).lines().
  .filter(Predictions.not(String::isBlank))
  .map(String::strip)
  .map(s -> s.indent(2))
  .collect(Collectors.toList());
// no need to have an instance of array passed as an argument
String[] myArray= aList.toArray(String[]::new);
// read and write to files quickly!
// remember to catch all the possible exceptions though
Path path = Files.writeString(myFile, "Pretius Rules All !");
String fileContent = Files.readString(path);
// .toList() on a stream()
String[] arr={"a", "b", "c"};
var list = Arrays.stream(arr).toList();
JVM 17 vs JVM 8 changes
Project Jigsaw
A screen showing a jigsaw puzzle.
Project Jigsaw turned some things on their heads, but now everything works well.
JDK 9’s Project Jigsaw significantly altered the internals of JVM. It changed both JLS and JVMS, added several JEPs (list available in the Project Jigsaw link above), and, most importantly, introduced some breaking changes, alterations that were incompatible with previous Java versions.

Java 9 modules were introduced, as an additional, highest level of jar and class organization. There’s lots of introductory content on this topic, like this one on Baeldung or these slides from Yuichi Sakuraba. 

The gains were significant, though not visible to the naked eye. So-called JAR hell is no more (have you been there? I was… and it was really a hell), though a module hell is now a possibility.

From the point of view of a typical programmer, these changes are now almost invisible. Only the biggest and the most complex projects may somehow be impacted. New versions of virtually all commonly used libraries adhere to the new rules and take them into account internally.

Garbage Collectors
As of Java 9, the G1 is the default garbage collector. It reduces the pause times in comparison with the Parallel GC, though it may have lower throughput overall. It has undergone some changes since it was made default, including the ability to return unused committed memory to the OS (JEP 346).

A ZGC garbage collector has been introduced in Java 11 and has reached product state in Java 15 (JEP 377). It aims to reduce the pauses even further. As of Java 13, it’s also capable of returning unused committed memory to the OS (JEP 351).

A Shenandoah GC has been introduced in JDK 14 and has reached product state in Java 15 (JEP 379). It aims to keep the pause times low and independent of the heap size.

Note that in Java 8 you had much fewer options, and if you did not change your GC manually, you still used the Parallel GC. Simply switching to Java 17 may cause your application to work faster and have more consistent method run times. Switching to, then unavailable, ZGC or Shenandoah may give even better results.

Finally, there’s a new No-Op Garbage Collector available (JEP 318), though it’s an experimental feature. This garbage collector does not actually do any work – thus allowing you to precisely measure your application’s memory usage. Useful, if you want to keep your memory operations throughput as low as possible.

If you want to learn more about available options, I recommend reading a great series of articles by Marko Topolnik that compares the GCs. 

Container awareness
In case you didn’t know, there was a time that Java was unaware that it was running in a container. It didn’t take into account the memory restrictions of a container and read available system memory instead. So, when you had a machine with 16 GB of RAM, set your container’s max memory to 1 GB, and had a Java application running on it, then often the application would fail as it would try to allocate more memory than was available on the container. A nice article from Carlos Sanchez explains this in more detail.

These problems are in the past now. As of Java 10, the container integration is enabled by default. However, this may not be a noticeable improvement for you, as the same change was introduced in Java 8 update 131, though it required enabling experimental options and using -XX:+UseCGroupMemoryLimitForHeap. 

PS: It’s often a good idea to specify the max memory for Java using an -Xmx parameter. The problem does not appear in such cases.

CDS Archives
In an effort to make the JVM start faster, the CDS Archives have undergone some changes in the time that passed since the Java 8 release. Starting from JDK 12, creating CDS Archives during the build process is enabled by default (JEP 341). An enhancement in JDK 13 (JEP 350) allowed the archives to be updated after each application run.

A great article from Nicolai Parlog demonstrates how to use this feature to improve startup time for your application.

Java Flight Recorder and Java Mission Control
Java Flight Recorder (JEP 328) allows monitoring and profiling of a running Java application at a low (target 1%) performance cost. Java Mission Control allows ingesting and visualizing JFR data. See Baeldung’s tutorial to get a general idea of how to use it and what one can get from it. 

Should you migrate from Java 8 to Java 17?
To keep it short: yes, you should. If you have a large, high-load enterprise application and still use Java 8, you will definitely see better performance, faster startup time, lower memory footprint after migrating. Programmers working on that application should also be happier, as there are many improvements to the language itself.

The cost of doing so, however, is difficult to estimate and varies greatly depending on used application servers, libraries, and the complexity of the application itself (or rather the number of low-level features it uses/reimplements).

If your applications are microservices, it’s likely that all you will need to do is to change the base docker image to 17-alpine, code version in maven to 17, and everything will work just fine. Some frameworks or library updates may come in handy (but you’re doing them periodically anyway, right?).

All popular servers and frameworks have the Java 9’s Jigsaw Project support by now. It’s production-grade, it has been heavily tested, and bugfixed over the years. Many products offer migration guides or at least extensive release notes for the Java 9-compatible version. See a nice article from OSGI or some release notes for Wildfly 15 mentioning modules support.

If you use Spring Boot as your framework, there are some articles available with migration tips, like this one in the spring-boot wiki, this one on Baeldung, and yet another one on DZone. There’s also an interesting case study from infoq. Migrating Spring Boot 1 to Spring Boot 2 is a different topic, it might be worth considering too. There’s a tutorial from Spring Boot itself, and an article on Baeldung covering this topic.

If your application didn’t have custom classloaders, didn’t heavily rely on Unsafe, lots of sun.misc or sun.security usages – you’re likely to be fine. Consult this article from JDEP on Java Dependency Analysis Tool, for some changes you may have to make.

Some things were removed from Java since version 8, including Nashorn JS Engine, Pack200 APIs and Tools, Solaris/Sparc ports, AOT and JIT compilers, Java EE, and Corba modules. Some things still remain but are deprecated for removal, like Applet API or Security Manager. And since there are good reasons for their removal, you should reconsider their use in your application anyway.

I asked our Project technical Leaders at Pretius about their experiences with Java 8 to Java 9+ migrations. There were several examples and none were problematic. Here, a library did not work and had to be updated;, there, some additional library or configuration was required but overall, it wasn’t a bad experience at all.

Conclusion
Java 17 LTS is out now, and it’s going to be supported for years to come. On the other hand, Java 8’s support is going to run out in just a few months. It’s certainly a solid reason to consider moving to the newest version of Java. In this article, I covered the most important language and JVM changes between versions 8 and 17 (including some information about the Java 8 to Java 9+ migration process), so that it’s easier to understand the differences between them – as well as to assess the risks and gains of migration.

If you happen to be a decision maker in your company, the question to ask yourself is this: will there ever be “a good time” to leave Java 8 behind? Some money will always have to be spent, some time will always have to be consumed and the risk of some additional work that needs to be done will always exist. If there’s never “a good time”, this particular window – the few months between Java 17 release and Java 8 losing Premier Support – is likely the best there’s ever going to be.
            14.17.1.2

        14.17.2

    14.18  Java version 18
    14.19  Java version 19
    14.20  Java version 20
    14.21  Java version 21
    14.22  Java version 22
    14.23  Java version 23
    14.24  Java version 24
    14.25  Java version 25
    14.26  Java version 26
    14.27  Java version 27
    14.28  Java version 28
    14.29  Java version 29
    14.30  Java version 30
    14.31  Java version 31
    14.32  Java version 32
    14.33  Java version 33
    14.34  Java version 34
    14.35  Java version 35
    14.36  Java version 36
    14.37  Java version 37
    14.38  Java version 38
    14.39  Java version 39
    14.40  Java version 40
    14.41  Java version 41


15. multithreading, tags: multithreading

    15.1 Multithreading in java , threading, threads, parallelization, concurrency , tags: Multithreading in java , threading, threads, parallelization, concurrency 

        15.1.1 https://www.geeksforgeeks.org/java-multithreading-tutorial/

            15.1.1.1 Using Thread Class
Java provides Thread class to achieve programming invoking threads thereby some major methods of thread class are shown below in the tabular format with which we deal frequently along the action performed by them.
Methods	Action Performed
isDaemon()	It checks whether the current thread is daemon or not
start()	It starts the execution of the thread
run()	It does the executable operations statements in the body of this method over a thread
sleep()	It is a static method that puts the thread to sleep for a certain time been passed as an argument to it
wait()	It sets the thread back in waiting state.
notify()	It gives out a notification to one thread that is in waiting state
notifyAll()	It gives out a notification to all the thread in the waiting state
setDaemon()	It set the current thread as Daemon thread
stop()	It is used to stop the execution of the thread
resume()	It is used to resume the suspended thread.
Pre-requisites: Basic syntax and methods to deal with threads
Now let us come up with how to set the name of the thread. By default, threads are named thread-0, thread-1, and so on. But there is also a method that is often used  as setName() method. Also corresponding to it there is a method getName() which returns the name of the thread be it default or settled already by using setName() method. The syntax is as follows:
Syntax: 
(a) Returning the name of the thread
public String getName() ;
(b) Changing the name of the thread
 public void setName(String name);
My demo, 2 worker threads:
Run:
[i500695@WYLQRXL9LQ:2023-02-16 18:49:00:~/work/code/java/multithreading:]2013$ javac HelloWorldThreads.java 
[i500695@WYLQRXL9LQ:2023-02-16 18:50:01:~/work/code/java/multithreading:]2014$ java HelloWorldThreads
Thread 1 crunching input 0
Thread 2 crunching input 0
Thread 1 crunching input 1
Thread 2 crunching input 1
Thread 1 crunching input 2
Thread 2 crunching input 2
Thread 2 crunching input 3
Thread 1 crunching input 3
Thread 1 crunching input 4
…

Code:
[i500695@WYLQRXL9LQ:2023-02-16 18:51:47:~/work/code/java/multithreading:]2017$ for f in *.java; do echo $f; cat $f;echo "";  echo "------"; done
HelloWorldThreads.java

public class HelloWorldThreads extends Thread{

    public static void main(String[] args) {
        Thread1 myThread1 = new Thread1();
        Thread2 myThread2 = new Thread2();
        myThread1.start();
        myThread2.start();
        
    }
}
------
Thread1.java
public class Thread1 extends Thread{

    public void run(){
        for (int i=0; i<100; i++) {
            System.out.println(String.format("Thread 1 crunching input %d", i));
        }
    }

}
------
Thread2.java
public class Thread2 extends Thread{

    public void run(){
        for (int i=0; i<100; i++) {
            System.out.println(String.format("Thread 2 crunching input %d", i));
        }
    }

}
------


            15.1.1.2 Using Runnable Interface 
Another way to achieve multithreading in java is via the Runnable interface. Here as we have seen in the above example in way 1 where Thread class is extended. Here Runnable interface being a functional interface has its own run() method. Here classes are implemented to the Runnable interface. Later on, in the main() method, Runnable reference is created for the classes that are implemented in order to make bondage with Thread class to run our own corresponding run() methods. Further, while creating an object of Thread class we will pass these references in Thread class as its constructor allows only one runnable object, which is passed as a parameter while creating Thread class object in a main() method. Now lastly just like what we did in Thread class, start() method is invoked over the runnable object who are now already linked with Thread class objects, so the execution begins for our run() methods in case of Runnable interface. It is shown in the program below as follows:
[i500695@WYLQRXL9LQ:2023-02-19 18:10:09:~/work/code/java/multithreading:]2026$ cat RunnableThread1.java RunnableThread2.java  HelloWorldThreads.java 
public class RunnableThread1 implements Runnable{

    public void run(){
        for (int i=0; i<4; i++) {
            System.out.println(String.format("RunnableThread 1 crunching input %d", i));
        }
    }

}public class RunnableThread2 implements Runnable{

    public void run(){
        for (int i=0; i<4; i++) {
            System.out.println(String.format("RunnableThread 2 crunching input %d", i));
        }
    }
}
public class HelloWorldThreads extends Thread{

    public static void main(String[] args) {
        System.out.println("Running two threads to crunch some numbers...");
        Thread1 myThread1 = new Thread1();
        Thread2 myThread2 = new Thread2();
        myThread1.start();
        myThread2.start();

        System.out.println("Running two more threads to crunch some more numbers, this time the threads CTOR is passed a Runnable implementing class...");
        RunnableThread1 rt1 = new RunnableThread1();
        RunnableThread2 rt2 = new RunnableThread2();
        Thread t1 = new Thread(rt1);
        Thread t2 = new Thread(rt2);
        t1.start();
        t2.start();

    }
}


            15.1.1.3 Thread methods

                15.1.1.3.1  Sleep
[i500695@WYLQRXL9LQ:2023-02-19 18:10:19:~/work/code/java/multithreading:]2027$ cat Thread1.java Thread2.java 
public class Thread1 extends Thread {

    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(String.format("Thread 1 crunching input %d", i));
            try {
                Thread.sleep(1000); // slow thread
            }
            catch (Exception e) {
                System.out.println("Caught exception "+ e);
            }
        }
    }

}public class Thread2 extends Thread{

    public void run(){
        for (int i=0; i<100; i++) {
            System.out.println(String.format("Thread 2 crunching input %d", i));
            try {
                Thread.sleep(200); //faster thread, sleeps 200 ms
            }
            catch (Exception e) {
                System.out.println("Caught exception " + e);
            }
        }
    }

}
Observe T2 faster than T1:
[i500695@WYLQRXL9LQ:2023-02-19 18:29:28:~/work/code/java/multithreading:]2029$ java HelloWorldThreads
Running two threads to crunch some numbers...
Running two more threads to crunch some more numbers, this time the threads CTOR is passed a Runnable implementing class...
RunnableThread 1 crunching input 0
Thread 1 crunching input 0
Thread 2 crunching input 0
RunnableThread 2 crunching input 0
RunnableThread 2 crunching input 1
RunnableThread 1 crunching input 1
RunnableThread 2 crunching input 2
RunnableThread 1 crunching input 2
RunnableThread 1 crunching input 3
RunnableThread 2 crunching input 3
Thread 2 crunching input 1
Thread 2 crunching input 2
Thread 2 crunching input 3
Thread 2 crunching input 4
Thread 1 crunching input 1
Thread 2 crunching input 5
Thread 2 crunching input 6
Thread 2 crunching input 7
Thread 2 crunching input 8
Thread 2 crunching input 9
Thread 1 crunching input 2
Thread 2 crunching input 10
Thread 2 crunching input 11
Thread 2 crunching input 12
...

For more information see: https://www.geeksforgeeks.org/thread-sleep-method-in-java-with-examples/
in short, calling it from main thread will put it to sleep.
ex:
// Java Program for sleeping the main thread.
import java.io.*;
import java.lang.Thread;
class GFG {
	public static void main(String[] args)
	{
		// we can also use throws keyword followed by
		// exception name for throwing the exception
	
		try {
			for (int i = 0; i < 5; i++) {
			
				// it will sleep the main thread for 1 sec
				// ,each time the for loop runs
				Thread.sleep(1000);
			
				// printing the value of the variable
				System.out.println(i);
			}
		}
		catch (Exception e) {
		
			// catching the exception
			System.out.println(e);
		}
	}
}

Calling it from thread will sleep the thread. 
Example, see above code. 

Flavors:
|1. public static void sleep(long millis)throws InterruptedException
|2. public static void sleep(long millis)throws IllegalArguementException
|3. public static void sleep(long millis, int nanos)throws InterruptedException
|4. public static void sleep(long millis, int nanos)throws  IllegalArguementException

                15.1.1.3.2 start
https://www.geeksforgeeks.org/start-function-multithreading-java/
 Java threads are typically created using one of the two methods : (1) Extending thread class. (2) Implementing Runnable
In both the approaches, we override the run() function, but we start a thread by calling the start() function. So why don’t we directly call the overridden run() function? Why always the start function is called to execute a thread?
What happens when a function is called? 
When a function is called the following operations take place: 
 

The arguments are evaluated.
A new stack frame is pushed into the call stack.
Parameters are initialized.
Method body is executed.
Value is returned and current stack frame is popped from the call stack.
The purpose of start() is to create a separate call stack for the thread. A separate call stack is created by it, and then run() is called by JVM.
Let us see what happens if we don’t call start() and rather call run() directly. We have modified the first program discussed here. 

demo:
Illustrate that we cant call run directly. We need to call start to allocate a new call stuck and JVM calls run()
Thread 1 crunching input 0
Thread 1 crunching input 1
Thread 1 crunching input 2
Thread 1 crunching input 3
Thread 1 crunching input 4
Thread 1 crunching input 5
Thread 1 crunching input 6

code:
public class Thread3 extends Thread {

    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(String.format("Thread %d crunching input %d", Thread.currentThread().getId(), i));
            try {
                Thread.sleep(1000); // slow thread
            }
            catch (Exception e) {
                System.out.println("Caught exception "+ e);
            }
        }
    }

}public class HelloWorldThreads extends Thread{

    public static void main(String[] args) {
        System.out.println("Running two threads to crunch some numbers...");
        Thread1 myThread1 = new Thread1();
        Thread2 myThread2 = new Thread2();
        myThread1.start();
        myThread2.start();

        System.out.println("Running two more threads to crunch some more numbers, this time the threads CTOR is passed a Runnable implementing class...");
        RunnableThread1 rt1 = new RunnableThread1();
        RunnableThread2 rt2 = new RunnableThread2();
        Thread t1 = new Thread(rt1);
        Thread t2 = new Thread(rt2);
        t1.start();
        t2.start();

        System.out.println("Illustrate that we cant call run directly. We need to call start to allocate a new call stuck and JVM calls run()");
        Thread3 myThread3 = new Thread3();
        myThread3.run();
    }
}
                15.1.1.3.3 suspend 
https://www.geeksforgeeks.org/how-to-temporarily-stop-a-thread-in-java/
The suspend() method of thread class puts the thread from running to waiting state. This method is employed if you would like to prevent the thread execution and begin it again when a particular event occurs. This method allows a thread to temporarily cease execution. The suspended thread is often resumed using the resume() method. If the present thread cannot modify the target thread then it’ll throw Security Exception.
Note: suspend() method is deprecated in the latest Java version.

code:
// Java program to demonstrate suspend() method
// of Thread class

import java.io.*;

class GFG extends Thread {
	public void run()
	{
		for (int i = 1; i < 5; i++) {
			try {
				
				// thread to sleep for 500 milliseconds
				sleep(5);
				System.out.println(
					"Currently running - "
					+ Thread.currentThread().getName());
			}
			catch (InterruptedException e) {
				System.out.println(e);
			}
			System.out.println(i);
		}
	}
	public static void main(String args[])
	{
		// creating three threads
		GFG t1 = new GFG();
		GFG t2 = new GFG();
		GFG t3 = new GFG();
		
		// call run() method
		t1.start();
		t2.start();
		
		// suspend t2 thread
		t2.suspend();
		
		// call run() method
		t3.start();
	}
}

Note: Thread t2 can be resumed by resume() method.
t2.resume() 

                15.1.1.3.4 stop

A thread is automatically destroyed when the run() method has completed. But it might be required to kill/stop a thread before it has completed its life cycle. Previously, methods suspend(), resume() and stop() were used to manage the execution of threads. But these methods were deprecated by Java 2 because they could result in system failures. Modern ways to suspend/stop a thread are by using a boolean flag and Thread.interrupt() method.
 

Using a boolean flag: We can define a boolean variable which is used for stopping/killing threads say ‘exit’. Whenever we want to stop a thread, the ‘exit’ variable will be set to true. 

 Using a volatile boolean flag: We can also use a volatile boolean flag to make our code thread safe. A volatile variable is directly stored in the main memory so that threads cannot have locally cached values of it. A situation may arise when more than one threads are accessing the same variable and the changes made by one might not be visible to other threads. In such a situation, we can use a volatile boolean flag. 

demo issue:
[i500695@WYLQRXL9LQ:2023-02-23 17:43:16:~/work/code/java/multithreading/killing_threads:]2032$ cat  KillThreadWrongWay.java
public class KillThreadWrongWay{

    static boolean exit = false; // We need static scope since main is static
                                 // and we want to access exit from main
                                 
    public static void main(String[] args) {
        System.out.println("Main thread starting...");
        new Thread() {
            public void run(){
                System.out.println("In thread run()");
                while (!exit){
                    System.out.println("Thread working. waiting for exit flag to finish");
                }
                System.out.println("Thread got exit flag. quitting.");
            }
        }.start();

        try {
            Thread.sleep(500);
        } catch(InterruptedException e){
            e.printStackTrace();
        }
        
        exit = true;
        System.out.println("Exiting main thread");
    }

}
[i500695@WYLQRXL9LQ:2023-02-23 17:43:22:~/work/code/java/multithreading/killing_threads:]2033$ javac KillThreadWrongWay.java
[i500695@WYLQRXL9LQ:2023-02-23 17:43:03:~/work/code/java/multithreading/killing_threads:]2032$ java KillThreadWrongWay
Thread working. waiting for exit flag to finish
Thread working. waiting for exit flag to finish
Thread working. waiting for exit flag to finish
...

Fix:
[i500695@WYLQRXL9LQ:2023-02-23 17:46:03:~/work/code/java/multithreading/killing_threads:]2040$ cat KillThread.java
public class KillThread{

    static volatile boolean exit = false; // We need static scope since main is static
                                 // and we want to access exit from main
                                 
    public static void main(String[] args) {
        System.out.println("Main thread starting...");
        new Thread() {
            public void run(){
                System.out.println("In thread run()");
                while (!exit){
                    System.out.println("Thread working. waiting for exit flag to finish");
                }
                System.out.println("Thread got exit flag. quitting.");
            }
        }.start();

        try {
            Thread.sleep(500);
        } catch(InterruptedException e){
            e.printStackTrace();
        }
        
        exit = true;
        System.out.println("Exiting main thread");
    }

}

Using Thread.interrupt() method: Whenever an interrupt has been sent to a thread, it should stop whatever task it is performing. It is very likely that whenever the thread receives an interrupt, it is to be terminated. This action can be done by using the interrupt() method. Whenever Thread.interrupt() is called, it sets a flag known as the interrupt status to true. This means that the thread has to stop performing further execution. The default value of this flag is false.
// Java program to illustrate
// stopping a thread
// using the interrupt() method

class MyThread implements Runnable {

	Thread t;

	MyThread()
	{
		t = new Thread(this);
		System.out.println("New thread: " + t);
		t.start(); // Starting the thread
	}

	// execution of thread starts from run() method
	public void run()
	{
		while (!Thread.interrupted()) {
			System.out.println("Thread is running");
		}
		System.out.println("Thread has stopped.");
	}
}

// Main class
public class Main {
	public static void main(String args[])
	{
		// creating objects t1 of MyThread
		MyThread t1 = new MyThread();

		try {
			Thread.sleep(1);

			// t1 is an object of MyThread
			// which has an object t
			// which is of type Thread
			t1.t.interrupt();

			Thread.sleep(5);
		}
		catch (InterruptedException e) {
			System.out.println("Caught:" + e);
		}
		System.out.println("Exiting the main Thread");
	}
}

source: https://www.geeksforgeeks.org/killing-threads-in-java/


                15.1.1.3.5 wait()
The wait() and join() methods are used to pause the current thread. The wait() is used in with notify() and notifyAll() methods, but join() is used in Java to wait until one thread finishes its execution. wait() is mainly used for shared resources, a thread notifies other waiting thread when a resource becomes free. On the other hand join() is used for waiting a thread to die.
Similarities between wait() and join()

The method wait() and join() both are used to pause the current thread in Java.
Both wait() and join() can be interrupted by calling interrupt() method in Java.
Both wait() and join() are a non-static method.
Both wait() and join() are overloaded in Java. wait() and join() which without timeout as well as accepts a timeout parameter.
Difference between wait() and join() method

Most obvious difference, both are present different packages, the wait() method is declared in java.lang.Object class while join() is declared in java.lang.Thread class.
The wait() is used for inter-thread communication while the join() is used for adding sequencing between multiple threads, one thread starts execution after first thread execution finished.
We can start a waiting thread (went into this state by calling wait()) by using notify() and notifyAll() method but we can not break the waiting imposed by join without unless or interruption the thread on which join is called has execution finished.
One most important difference between wait() and join() that is wait() must be called from synchronized context i.e. synchronized block or method otherwise it will throw IllegalMonitorStateException but On the other hand, we can call join() method with and without synchronized context in Java.

                15.1.1.3.6 notify, notifyAll 
The notify() and notifyAll() methods with wait() methods are used for communication between the threads. A thread that goes into waiting for state by calling the wait() method will be in waiting for the state until any other thread calls either notify() or notifyAll() method on the same object. 

notify(): The notify() method is defined in the Object class, which is Java’s top-level class. It’s used to wake up only one thread that’s waiting for an object, and that thread then begins execution. The thread class notify() method is used to wake up a single thread.

notifyAll(): The notifyAll() wakes up all threads that are waiting on this object’s monitor. A thread waits on an object’s monitor by calling one of the wait methods. The awakened threads will not be able to proceed until the current thread relinquishes the lock on this object.




Now the question is both notify() and notifyAll() the method is used to give notification to the waiting thread, then what is the difference between them or where we should use notify() method and where we should go for the notifyAll() method? 

Sr. No.	Key	notify()	notifyAll() 
1	Notifications	In the case of the multiThreading, notify() method sends the notification to only one thread among the multiple waiting threads which are waiting for the send lock.	While notifyAll() methods in the same context send notifications to all waiting threads instead of a single thread.
2	Thread identifications	As in the case of notify() method, the notification is sent to a single thread among the multiple waiting threads, so it is sure that which of those waiting threads is going to receive the lock.	On the other hand, notifyAll() sends a notification to all waiting threads. Hence, it is not clear which of the thread is going to receive the lock.
3	Risk factor	In the case of notify() method, the risk of thread missing is high as notification is sent only a single thread, and if it misses that, then no other thread would get a notification and hence the lock.	While in the case of notifyAll(), it sends a notification to all the waiting threads, and hence if any thread misses the notification, there are other threads to do the job. Hence the risk is less.
4	Performance	Memory and CPU drain is less in notify() method as compared to notifyAll() method as notification is sent to single one thread so performance is better as compared to notifyAll().	On the other hand, the cost of no notification is dropped and notification is sent to all waiting threads, the memory and CPU drain is more as compared to notify() and hence performance of notifyAll() is lesser.
5	Interchangeable	In the case of the notify() method, only a single thread is in the picture hence no concept of thread Interchangeable is possible.	While we should go for notifyAll() if all your waiting threads are interchangeable (the order they wake up doesn’t matter).
Let’s understand how the notify() method behaves:

Java
// Java program to illustrate the
// behaviour of notify() method
class Geek1 extends Thread {
    public void run()
    {
        synchronized (this)
        {
            System.out.println(
                Thread.currentThread().getName()
                + "...starts");
            try {
                this.wait();
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(
                Thread.currentThread().getName()
                + "...notified");
        }
    }
}
class Geek2 extends Thread {
    Geek1 geeks1;
   
    Geek2(Geek1 geeks1){
      this.geeks1 = geeks1;
    }
   
    public void run()
    {
        synchronized (this.geeks1)
        {
            System.out.println(
                Thread.currentThread().getName()
                + "...starts");
 
            try {
                this.geeks1.wait();
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(
                Thread.currentThread().getName()
                + "...notified");
        }
    }
}
class Geek3 extends Thread {
    Geek1 geeks1;
    Geek3(Geek1 geeks1) { this.geeks1 = geeks1; }
    public void run()
    {
        synchronized (this.geeks1)
        {
            System.out.println(
                Thread.currentThread().getName()
                + "...starts");
            this.geeks1.notify();
            System.out.println(
                Thread.currentThread().getName()
                + "...notified");
        }
    }
}
class MainClass {
    public static void main(String[] args)
        throws InterruptedException
    {
 
        Geek1 geeks1 = new Geek1();
        Geek2 geeks2 = new Geek2(geeks1);
        Geek3 geeks3 = new Geek3(geeks1);
        Thread t1 = new Thread(geeks1, "Thread-1");
        Thread t2 = new Thread(geeks2, "Thread-2");
        Thread t3 = new Thread(geeks3, "Thread-3");
        t1.start();
        t2.start();
        Thread.sleep(100);
        t3.start();
    }
}
Output: 

Thread-1...start
Thread-2...starts
Thread-3...starts
Thread-3...notified
Thread-1...notified
Lets understand how notifyAll() method behaves:  

Java

// Java program to illustrate the
// behavior of notifyAll() method
 
class Geek1 extends Thread {
    public void run()
    {
        synchronized (this)
        {
            System.out.println(
                Thread.currentThread().getName()
                + "...starts");
            try {
                this.wait();
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(
                Thread.currentThread().getName()
                + "...notified");
        }
    }
}
class Geek2 extends Thread {
    Geek1 geeks1;
   
    Geek2(Geek1 geeks1){
      this.geeks1 = geeks1;
    }
   
    public void run()
    {
        synchronized (this.geeks1)
        {
            System.out.println(
                Thread.currentThread().getName()
                + "...starts");
 
            try {
                this.geeks1.wait();
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(
                Thread.currentThread().getName()
                + "...notified");
        }
    }
}
class Geek3 extends Thread {
    Geek1 geeks1;
    Geek3(Geek1 geeks1) { this.geeks1 = geeks1; }
    public void run()
    {
        synchronized (this.geeks1)
        {
            System.out.println(
                Thread.currentThread().getName()
                + "...starts");
 
            this.geeks1.notifyAll();
            System.out.println(
                Thread.currentThread().getName()
                + "...notified");
        }
    }
}
class MainClass {
    public static void main(String[] args)
        throws InterruptedException
    {
 
        Geek1 geeks1 = new Geek1();
        Geek2 geeks2 = new Geek2(geeks1);
        Geek3 geeks3 = new Geek3(geeks1);
        Thread t1 = new Thread(geeks1, "Thread-1");
        Thread t2 = new Thread(geeks2, "Thread-2");
        Thread t3 = new Thread(geeks3, "Thread-3");
        t1.start();
        t2.start();
        Thread.sleep(100);
        t3.start();
    }
}
Output
Thread-1...starts
Thread-2...starts
Thread-3...starts
Thread-3...notified
Thread-1...notified
Thread-2...notified
When to Use notify() method and notifyAll()?
In the case of mutually exclusive locking, only one of the waiting threads can do something useful after being notified (in this case acquire the lock). In such a case, you would rather use notify(). Properly implemented, you could use notifyAll() in this situation as well, but you would unnecessarily wake threads that can’t do anything anyway.
In some cases, all waiting threads can take useful action once the wait finishes. An example would be a set of threads waiting for a certain task to finish; once the task has finished, all waiting threads can continue with their business. In such a case you would use notifyAll() to wake up all waiting threads at the same time.
Applications of notify() and notifyAll()
A maintenance operation on a shared resource, where multiple threads are waiting for the operation to complete before accessing the resource; for these, we should go for notifyAll().
Let’s say we have a producer thread and a consumer thread. Each “packet” produced by the producer should be consumed by a consumer. The consumer puts something in a queue and then calls notify().
We want to have a notification when a lengthy process has finished. You want a beep and a screen update. The process performs notifyAll() to notify both the beeping thread and the screen-update-thread.

                15.1.1.3.7
            15.1.1.4 Priorities in threads, , tags: Priorities in threads
Impact of Thread Priorities
Thread priorities influence how the JVM schedules and allocates resources to threads. A higher priority thread has a better chance of being executed before lower priority threads. However, it’s important to remember that priority alone does not determine the order of thread execution. The JVM’s thread scheduler takes other factors, such as the underlying operating system and thread states, into account.

Thread priority is useful when certain threads require more processing time or have critical tasks. By giving such threads a higher priority, developers can ensure that they receive enough CPU time to complete their tasks on time. It is not, however, recommended to rely solely on thread priorities to achieve specific execution behavior.
Priorities in threads is a concept where each thread is having a priority which is represented by numbers ranging from 1 to 10. 

The default priority is set to 5 as excepted.
Minimum priority is set to 0.
Maximum priority is set to 10.
Here 3 constants are defined in it namely as follows:

public static int NORM_PRIORITY
public static int MIN_PRIORITY
public static int MAX_PRIORITY
Let us discuss it with an example to get how internally the work is getting executed. Here we will be using the knowledge gathered above as follows:

We will use currentThread() method to get the name of the current thread. User can also use setName() method if he/she wants to make names of thread as per choice for understanding purposes.
getName() method will be used to get the name of the thread.

demo and code:
[i500695@WYLQRXL9LQ:2023-02-23 18:09:07:~/work/code/java/multithreading/thread_priorities:]2069$ cat ThreadPriority.java 
// Java Program to illustrate Priority Threads
// Case 1: No priority is assigned (Default priority)

// Importing input output thread class
import java.io.*;
// Importing Thread class from java.util package
import java.util.*;

// Class 1
// Helper Class (Our thread class)
class MyThread extends Thread {

	public void run()
	{

		// Printing the current running thread via getName()
		// method using currentThread() method
		System.out.println("Running Thread : "
						+ currentThread().getName());

		// Print and display the priority of current thread
		// via currentThread() using getPriority() method
		System.out.println("Running Thread Priority : "
						+ currentThread().getPriority());
	}
}

class DefaultPriority {

	// Main driver method
	public static void main(String[] args)
	{

		// Creating objects of MyThread(above class)
		// in the main() method
		MyThread t1 = new MyThread();
		MyThread t2 = new MyThread();

		t1.start();
		t2.start();
	}
}

class NormalPriority {

	// Main driver method
	public static void main(String[] args)
	{

		// Creating objects of MyThread(above class)
		// in the main() method
		MyThread t1 = new MyThread();
		MyThread t2 = new MyThread();

       // Setting priority to thread via NORM_PRIORITY
        // which set priority to 5 as default thread
        t1.setPriority(Thread.NORM_PRIORITY);
        t2.setPriority(Thread.NORM_PRIORITY);

		// Case 1: Default Priority no setting
		t1.start();
		t2.start();
	}
}

class MinPriority {

	// Main driver method
	public static void main(String[] args)
	{

		// Creating objects of MyThread(above class)
		// in the main() method
		MyThread t1 = new MyThread();
		MyThread t2 = new MyThread();

       // Setting priority to thread via NORM_PRIORITY
        // which set priority to 5 as default thread
        t1.setPriority(Thread.MIN_PRIORITY);
        t2.setPriority(Thread.MIN_PRIORITY);

		// Case 1: Default Priority no setting
		t1.start();
		t2.start();
	}
}

class MaxPriority {

	// Main driver method
	public static void main(String[] args)
	{

		// Creating objects of MyThread(above class)
		// in the main() method
		MyThread t1 = new MyThread();
		MyThread t2 = new MyThread();

       // Setting priority to thread via NORM_PRIORITY
        // which set priority to 5 as default thread
        t1.setPriority(Thread.MAX_PRIORITY);
        t2.setPriority(Thread.MAX_PRIORITY);

		// Case 1: Default Priority no setting
		t1.start();
		t2.start();
	}
}

[i500695@WYLQRXL9LQ:2023-02-23 18:09:19:~/work/code/java/multithreading/thread_priorities:]2070$ for f in *.class; do echo "Running ${f%.*}"; java "${f%.*}" ; echo "---------"; done
Running DefaultPriority
Running Thread : Thread-0
Running Thread : Thread-1
Running Thread Priority : 5
Running Thread Priority : 5
---------
Running MaxPriority
Running Thread : Thread-0
Running Thread : Thread-1
Running Thread Priority : 10
Running Thread Priority : 10
---------
Running MinPriority
Running Thread : Thread-0
Running Thread : Thread-1
Running Thread Priority : 1
Running Thread Priority : 1
---------
Running MyThread
Error: Main method not found in class MyThread, please define the main method as:
   public static void main(String[] args)
or a JavaFX application class must extend javafx.application.Application
---------
Running NormalPriority
Running Thread : Thread-0
Running Thread : Thread-1
Running Thread Priority : 5
Running Thread Priority : 5
---------

            15.1.1.5 daemon threads

            15.1.1.6
        15.1.2 Thread lifecycle and state-machine
https://www.geeksforgeeks.org/lifecycle-and-states-of-a-thread-in-java/
A thread in Java at any point of time exists in any one of the following states. A thread lies only in one of the shown states at any instant: 
New
Runnable
Blocked
Waiting
Timed Waiting
Terminated
Life Cycle of a thread
New Thread: When a new thread is created, it is in the new state. The thread has not yet started to run when the thread is in this state. When a thread lies in the new state, its code is yet to be run and hasn’t started to execute.
Runnable State: A thread that is ready to run is moved to a runnable state. In this state, a thread might actually be running or it might be ready to run at any instant of time. It is the responsibility of the thread scheduler to give the thread, time to run. 
A multi-threaded program allocates a fixed amount of time to each individual thread. Each and every thread runs for a short while and then pauses and relinquishes the CPU to another thread so that other threads can get a chance to run. When this happens, all such threads that are ready to run, waiting for the CPU and the currently running thread lie in a runnable state.
Blocked/Waiting state: When a thread is temporarily inactive, then it’s in one of the following states: 
Blocked
Waiting
Timed Waiting: A thread lies in a timed waiting state when it calls a method with a time-out parameter. A thread lies in this state until the timeout is completed or until a notification is received. For example, when a thread calls sleep or a conditional wait, it is moved to a timed waiting state.
Terminated State: A thread terminates because of either of the following reasons: 
Because it exits normally. This happens when the code of the thread has been entirely executed by the program.
Because there occurred some unusual erroneous event, like segmentation fault or an unhandled exception.

| 1. New 
| Declaration: public static final Thread.State NEW
| Description: Thread state for a thread that has not yet started. 
| 
| 2. Runnable 
| Declaration: public static final Thread.State RUNNABLE
| Description: Thread state for a runnable thread. A thread in the runnable state is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as a processor. 
| 
| 3. Blocked 
| Declaration: public static final Thread.State BLOCKED
| Description: Thread state for a thread blocked waiting for a monitor lock. A thread in the blocked state is waiting for a monitor lock to enter a synchronized block/method or reenter a synchronized block/method after calling Object.wait(). 
| 4. Waiting 
| Declaration: public static final Thread.State WAITING
| Description: Thread state for a waiting thread. A thread is in the waiting state due to calling one of the following methods: 
| 
| Object.wait with no timeout
| Thread.join with no timeout
| LockSupport.park
| 5. Timed Waiting 
| Declaration: public static final Thread.State TIMED_WAITING
| Description: Thread state for a waiting thread with a specified waiting time. A thread is in the timed waiting state due to calling one of the following methods with a specified positive waiting time: 
| 
| Thread.sleep
| Object.wait with timeout
| Thread.join with timeout
| LockSupport.parkNanos
| LockSupport.parkUntil
| 6. Terminated 
| Declaration: public static final Thread.State TERMINATED

demo:
[i500695@WYLQRXL9LQ:2023-02-21 18:19:18:~/work/code/java/multithreading/thread_states_demo:]2011$ cat Test.java 
// Java program to demonstrate thread states
class thread implements Runnable {
	public void run()
	{
		// moving thread2 to timed waiting state
		try {
			Thread.sleep(1500);
		}
		catch (InterruptedException e) {
			e.printStackTrace();
		}

		System.out.println(
			"State of thread1 while it called join() method on thread2 -"
			+ Test.thread1.getState());
		try {
			Thread.sleep(200);
		}
		catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}

public class Test implements Runnable {
	public static Thread thread1;
	public static Test obj;

	public static void main(String[] args)
	{
		obj = new Test();
		thread1 = new Thread(obj);

		// thread1 created and is currently in the NEW
		// state.
		System.out.println(
			"State of thread1 after creating it - "
			+ thread1.getState());
		thread1.start();

		// thread1 moved to Runnable state
		System.out.println(
			"State of thread1 after calling .start() method on it - "
			+ thread1.getState());
	}

	public void run()
	{
		thread myThread = new thread();
		Thread thread2 = new Thread(myThread);

		// thread1 created and is currently in the NEW
		// state.
		System.out.println(
			"State of thread2 after creating it - "
			+ thread2.getState());
		thread2.start();

		// thread2 moved to Runnable state
		System.out.println(
			"State of thread2 after calling .start() method on it - "
			+ thread2.getState());

		// moving thread1 to timed waiting state
		try {
			// moving thread1 to timed waiting state
			Thread.sleep(200);
		}
		catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println(
			"State of thread2 after calling .sleep() method on it - "
			+ thread2.getState());

		try {
			// waiting for thread2 to die
			thread2.join();
		}
		catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println(
			"State of thread2 when it has finished it's execution - "
			+ thread2.getState());
	}
}

[i500695@WYLQRXL9LQ:2023-02-21 18:19:32:~/work/code/java/multithreading/thread_states_demo:]2012$ javac Test.java
[i500695@WYLQRXL9LQ:2023-02-21 18:19:36:~/work/code/java/multithreading/thread_states_demo:]2013$ java Test
State of thread1 after creating it - NEW
State of thread1 after calling .start() method on it - RUNNABLE
State of thread2 after creating it - NEW
State of thread2 after calling .start() method on it - RUNNABLE
State of thread2 after calling .sleep() method on it - TIMED_WAITING
State of thread1 while it called join() method on thread2 -WAITING
State of thread2 when it has finished it's execution - TERMINATED

        15.1.3
    15.2


16. jackson

    16.1 highlevel overview
Jackson is a popular Java library for working with JSON data. It provides functionality to serialize Java objects to JSON and deserialize JSON to Java objects.

The core component of the Jackson library is the `ObjectMapper` class, which provides methods for converting between Java objects and JSON data. Here's an example of how to use `ObjectMapper` to serialize a Java object to JSON:

```java
import com.fasterxml.jackson.databind.ObjectMapper;

public class MyObject {
    private String name;
    private int age;
    
    public MyObject(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Getters and setters
    
    public static void main(String[] args) throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        MyObject obj = new MyObject("John Doe", 30);
        String json = mapper.writeValueAsString(obj);
        System.out.println(json); // {"name":"John Doe","age":30}
    }
}
```

In this example, we create a `MyObject` class with a name and age field, and then create an instance of this class with the name "John Doe" and age 30. We then create an `ObjectMapper` instance and use the `writeValueAsString()` method to serialize the `MyObject` instance to a JSON string.

Here's another example that demonstrates how to deserialize a JSON string to a Java object:

```java
import com.fasterxml.jackson.databind.ObjectMapper;

public class MyObject {
    private String name;
    private int age;
    
    public MyObject() {
        // Default constructor required for deserialization
    }
    
    // Getters and setters
    
    public static void main(String[] args) throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        String json = "{\"name\":\"John Doe\",\"age\":30}";
        MyObject obj = mapper.readValue(json, MyObject.class);
        System.out.println(obj.getName()); // John Doe
        System.out.println(obj.getAge()); // 30
    }
}
```

In this example, we create a `MyObject` class with a default constructor (required for deserialization), and then create a JSON string representing a `MyObject` instance with the name "John Doe" and age 30. We then use the `readValue()` method of `ObjectMapper` to deserialize the JSON string to a `MyObject` instance.

Jackson also provides many annotations for customizing the serialization and deserialization of Java objects, such as `@JsonProperty`, `@JsonFormat`, and `@JsonIgnore`. You can find more information on how to use Jackson in the official documentation: https://github.com/FasterXML/jackson-databind.

    16.2 ObjectMapper 

        16.2.1 valueToTree
`ObjectMapper`'s `valueToTree` method is used to convert a Java object to a JSON tree representation. The resulting `JsonNode` object can be used to traverse and manipulate the JSON structure programmatically, which can be useful in certain scenarios.

Here's an example of using `ObjectMapper` to convert a Java object to a `JsonNode` object:

```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class MyObject {
    private String name;
    private int age;
    
    public MyObject(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Getters and setters
    
    public static void main(String[] args) throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        MyObject obj = new MyObject("John Doe", 30);
        JsonNode jsonNode = mapper.valueToTree(obj);
        System.out.println(jsonNode.toString()); // {"name":"John Doe","age":30}
    }
}
```

In this example, we create a `MyObject` class with a name and age field, and then create an instance of this class with the name "John Doe" and age 30. We then create an `ObjectMapper` instance and use the `valueToTree()` method to convert the `MyObject` instance to a `JsonNode` object. Finally, we print the JSON string representation of the `JsonNode` object.

The resulting `JsonNode` object can be further manipulated using the `JsonNode` API to extract or modify specific parts of the JSON structure. This can be useful when working with complex JSON structures that require programmatic manipulation.

        16.2.2 JsonNode traversal
Sure! Here's an example of how to traverse a `JsonNode` object using Jackson's `JsonNode` API:

```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class JsonTraversalExample {
    public static void main(String[] args) throws Exception {
        String json = "{\"name\":\"John Doe\",\"age\":30,\"address\":{\"street\":\"123 Main St\",\"city\":\"Anytown\",\"state\":\"CA\",\"zip\":\"12345\"}}";
        ObjectMapper mapper = new ObjectMapper();
        JsonNode rootNode = mapper.readTree(json);
        JsonNode nameNode = rootNode.get("name");
        String name = nameNode.asText();
        System.out.println("Name: " + name); // Name: John Doe
        JsonNode ageNode = rootNode.get("age");
        int age = ageNode.asInt();
        System.out.println("Age: " + age); // Age: 30
        JsonNode addressNode = rootNode.get("address");
        String street = addressNode.get("street").asText();
        System.out.println("Street: " + street); // Street: 123 Main St
        String city = addressNode.get("city").asText();
        System.out.println("City: " + city); // City: Anytown
        String state = addressNode.get("state").asText();
        System.out.println("State: " + state); // State: CA
        String zip = addressNode.get("zip").asText();
        System.out.println("ZIP: " + zip); // ZIP: 12345
    }
}
```

In this example, we create a JSON string representing a person with a name, age, and address, and then parse it into a `JsonNode` object using `ObjectMapper`'s `readTree()` method. We then use the `get()` method of the `JsonNode` object to retrieve specific parts of the JSON structure, and use the `asText()` and `asInt()` methods to convert the values to Java strings and integers, respectively.

To traverse the nested `address` object, we first retrieve the `address` node using `get()`, and then use `get()` again to retrieve the individual fields within the `address` object.

Note that `JsonNode` also provides other methods for traversing JSON structures, such as `iterator()` and `fields()`, which can be useful in certain scenarios.

        16.2.3 DFS traversal of JsonNode
To perform a depth-first traversal of a `JsonNode` object using recursion, you can create a helper method that takes a `JsonNode` object as a parameter and then recursively calls itself for each child node. Here's an example:

```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class JsonDfsTraversalExample {
    public static void main(String[] args) throws Exception {
        String json = "{\"name\":\"John Doe\",\"age\":30,\"address\":{\"street\":\"123 Main St\",\"city\":\"Anytown\",\"state\":\"CA\",\"zip\":\"12345\"}}";
        ObjectMapper mapper = new ObjectMapper();
        JsonNode rootNode = mapper.readTree(json);
        traverse(rootNode);
    }
    
    private static void traverse(JsonNode node) {
        if (node.isObject()) {
            System.out.println("Object: " + node);
            node.fields().forEachRemaining(entry -> traverse(entry.getValue()));
        } else if (node.isArray()) {
            System.out.println("Array: " + node);
            node.elements().forEachRemaining(JsonDfsTraversalExample::traverse);
        } else if (node.isValueNode()) {
            System.out.println("Value: " + node);
        } else if (node.isNull()) {
            System.out.println("Null: " + node);
        }
    }
}
```

In this example, we create a `traverse()` method that takes a `JsonNode` object as a parameter. If the node is an object, we print a message indicating that it's an object and then iterate over its fields using the `fields()` method, calling `traverse()` recursively for each value in the field. If the node is an array, we print a message indicating that it's an array and then iterate over its elements using the `elements()` method, again calling `traverse()` recursively for each element. If the node is a value node, we print a message indicating that it's a value node, and if it's null, we print a message indicating that it's null.

When we call the `traverse()` method on the root node of a JSON structure, it will recursively traverse the entire structure in a depth-first manner, printing out messages for each node type as it encounters them.

        16.2.4
    16.3
17. java collections, tags:  java collections

    17.1 java Collections.singletonList
`Collections.singletonList()` is a method in the Java Collections Framework that returns an immutable list containing only the specified object. 

Here is an example of how to use `Collections.singletonList()`:

```java
import java.util.Collections;
import java.util.List;

public class SingletonListExample {
    public static void main(String[] args) {
        String fruit = "apple";
        List<String> fruitList = Collections.singletonList(fruit);
        System.out.println(fruitList);
    }
}
```

In this example, we use `Collections.singletonList()` to create an immutable list containing a single string object `"apple"`. The `singletonList()` method takes a single argument that represents the object to be added to the list. 

The resulting list is immutable, meaning that its size cannot be modified, and any attempt to add or remove elements will result in an `UnsupportedOperationException`. This method is useful when you need to pass a single object as a list to a method or API that expects a list as input.

Yes, here are a few other use cases where `Collections.singletonList()` can be helpful:

|1. As a return value: If you have a method that returns a list containing a single element, using `Collections.singletonList()` can be a clean and simple way to create and return that list.
|
|2. As a parameter: If you have a method that takes a list as a parameter, and you only need to pass a single element to that method, you can use `Collections.singletonList()` to create a temporary list containing that element.
|
|3. As an optimization: If you have a situation where you know that a list will only ever contain a single element, using `Collections.singletonList()` can be more memory-efficient than creating a regular ArrayList or other list implementation.

Overall, `Collections.singletonList()` is a useful utility method that can simplify your code and make it more efficient in certain situations where you only need to work with a list containing a single element.

    17.2

18.  chatgpt, tags: chatgpt

    18.1   java 17 load integer env var , tags: java 17 load integer env var 
To load an integer environment variable in Java, you can use the `System.getenv()` method to retrieve the value as a string and then parse it into an integer. Here's an example:

```java
public class LoadIntegerEnvVar {
    public static void main(String[] args) {
        // Specify the name of the environment variable
        String envVarName = "YOUR_ENV_VAR_NAME";

        // Get the value of the environment variable
        String envVarValue = System.getenv(envVarName);

        if (envVarValue != null) {
            try {
                // Parse the string value into an integer
                int intValue = Integer.parseInt(envVarValue);
                
                // Now you can use intValue as an integer
                System.out.println("Integer value of " + envVarName + ": " + intValue);
            } catch (NumberFormatException e) {
                System.err.println("Error parsing integer value for " + envVarName);
                e.printStackTrace();
            }
        } else {
            System.err.println("Environment variable " + envVarName + " not found");
        }
    }
}
```

Replace `"YOUR_ENV_VAR_NAME"` with the name of your environment variable. If the environment variable is not found or if there's an error parsing the integer value, appropriate error messages will be printed. Make sure to handle exceptions appropriately based on your application's requirements.

    18.2

19. SSL and TLS, tags: and TLS

    19.1 chatgpt

        19.1.1 java establish ssl client connection with sslmode verify-full  also explain how to send client certificate and key and validate server certificate
| When establishing an SSL/TLS connection with mutual authentication (both the client and server authenticate each other), you need to provide a client certificate and key in addition to validating the server certificate. The PostgreSQL JDBC driver supports this by allowing you to specify client certificate-related properties.
| 
| Below is an example Java code snippet demonstrating how to send a client certificate and key while also validating the server certificate:
| 
| ```java
| import java.sql.Connection;
| import java.sql.DriverManager;
| import java.sql.SQLException;
| import java.util.Properties;
| 
| public class SSLClientWithClientCertExample {
| 
|     public static void main(String[] args) {
|         String jdbcUrl = "jdbc:postgresql://your_host:your_port/your_database";
|         String user = "your_username";
|         String password = "your_password";
|         String sslMode = "verify-full"; // Set to the desired SSLMode
|         String sslRootCert = "/path/to/root.crt"; // Path to the root CA certificate
|         String sslCert = "/path/to/client.crt"; // Path to the client certificate
|         String sslKey = "/path/to/client.key"; // Path to the client private key
| 
|         Properties properties = new Properties();
|         properties.setProperty("user", user);
|         properties.setProperty("password", password);
|         properties.setProperty("sslmode", sslMode);
|         properties.setProperty("sslrootcert", sslRootCert);
|         properties.setProperty("sslcert", sslCert);
|         properties.setProperty("sslkey", sslKey);
| 
|         try {
|             // Load the PostgreSQL JDBC driver
|             Class.forName("org.postgresql.Driver");
| 
|             // Establish the SSL client connection
|             Connection connection = DriverManager.getConnection(jdbcUrl, properties);
| 
|             // Perform database operations as needed
| 
|             // Close the connection
|             connection.close();
|         } catch (ClassNotFoundException | SQLException e) {
|             e.printStackTrace();
|         }
|     }
| }
| ```
| 
| In this example:
| 
| - **`sslrootcert`:** Points to the root CA certificate file (server certificate should be signed by this CA).
| - **`sslcert`:** Points to the client certificate file.
| - **`sslkey`:** Points to the client private key file.
| 
| Make sure to replace the placeholders (`your_host`, `your_port`, `your_database`, `your_username`, and `your_password`) with your actual PostgreSQL server details, and update the paths to the certificate and key files accordingly.
| 
| Key points:
| 
| 1. Ensure that the PostgreSQL server is configured to request client certificates (`ssl` and `require` settings in `pg_hba.conf`).
| 2. The client certificate and private key should be stored in files on the client machine.
| 3. The server certificate must be signed by the root CA certificate specified in `sslrootcert`.
| 4. This example assumes the use of the PostgreSQL JDBC driver (`org.postgresql.Driver`). Ensure you have the correct version of the driver in your classpath.
| 
| By configuring these properties, the JDBC driver will send the client certificate and key during the SSL handshake, and it will validate the server certificate against the specified root CA certificate.

    19.2

20.
